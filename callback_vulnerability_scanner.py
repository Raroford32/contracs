#!/usr/bin/env python3
"""
Scanner for callback/flash loan vulnerabilities
Looking for:
1. Unprotected flash loan callbacks
2. Callback functions that can be triggered externally
3. ERC777/ERC1155 hook exploitation
"""
import json
import subprocess
import re
import time

RPC = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

def rpc_call(method, params):
    payload = {"jsonrpc": "2.0", "method": method, "params": params, "id": 1}
    cmd = ["curl", "-s", "-X", "POST", "-H", "Content-Type: application/json",
           "-d", json.dumps(payload), RPC]
    result = subprocess.run(cmd, capture_output=True, text=True)
    try:
        return json.loads(result.stdout)
    except:
        return None

def eth_call(to, data, from_addr="0x0000000000000000000000000000000000000001", value="0x0"):
    result = rpc_call("eth_call", [{"to": to, "data": data, "from": from_addr, "value": value}, "latest"])
    return result

def estimate_gas(to, data, from_addr="0x0000000000000000000000000000000000000001", value="0x0"):
    result = rpc_call("eth_estimateGas", [{"to": to, "data": data, "from": from_addr, "value": value}])
    return result

def get_balance(addr):
    result = rpc_call("eth_getBalance", [addr, "latest"])
    if result and 'result' in result:
        return int(result['result'], 16) / 1e18
    return 0

def get_code(addr):
    result = rpc_call("eth_getCode", [addr, "latest"])
    if result and 'result' in result:
        return result['result']
    return "0x"

def get_source(addr):
    url = f"https://api.etherscan.io/v2/api?chainid=1&module=contract&action=getsourcecode&address={addr}&apikey={ETHERSCAN_API}"
    result = subprocess.run(["curl", "-s", url], capture_output=True, text=True)
    try:
        data = json.loads(result.stdout)
        if data.get("status") == "1" and data.get("result"):
            return data["result"][0]
    except:
        pass
    return None

print("=" * 80)
print("CALLBACK VULNERABILITY SCANNER")
print("=" * 80)

# Load contracts
with open("contracts.txt", "r") as f:
    contracts = [line.strip() for line in f if line.strip().startswith("0x")]

# Callback function selectors
CALLBACK_SELECTORS = {
    # Flash loan callbacks
    "onFlashLoan": "0x23e30c8b",
    "executeOperation": "0x920f5c84",  # Aave v2
    "uniswapV2Call": "0x10d1e85c",
    "uniswapV3SwapCallback": "0xfa461e33",
    "uniswapV3FlashCallback": "0xe9cbafb0",
    # ERC721/1155 callbacks
    "onERC721Received": "0x150b7a02",
    "onERC1155Received": "0xf23a6e61",
    "onERC1155BatchReceived": "0xbc197c81",
    # ERC777 hooks
    "tokensReceived": "0x0023de29",
    "tokensToSend": "0x75ab9782",
}

vulnerable_contracts = []

print(f"\nScanning {len(contracts)} contracts for callback vulnerabilities...")

for i, addr in enumerate(contracts):
    if i % 100 == 0:
        print(f"Progress: {i}/{len(contracts)}")

    balance = get_balance(addr)
    if balance < 20:
        continue

    code = get_code(addr)
    if len(code) < 200:  # Skip Parity wallets
        continue

    # Test each callback
    callable_callbacks = []
    for name, sel in CALLBACK_SELECTORS.items():
        # Create dummy data for callback
        data = sel + "0" * 256  # Pad with zeros for params

        result = estimate_gas(addr, data)
        if result and 'result' in result:
            gas = int(result['result'], 16)
            if gas > 21000 and gas < 300000:
                callable_callbacks.append({
                    "name": name,
                    "selector": sel,
                    "gas": gas
                })

    if callable_callbacks:
        # Check if these are just fallback (similar gas)
        gases = [c['gas'] for c in callable_callbacks]
        if len(set(gases)) <= 1 or (max(gases) - min(gases)) < 1000:
            continue  # Likely fallback function

        vulnerable_contracts.append({
            "address": addr,
            "balance": balance,
            "callbacks": callable_callbacks
        })
        print(f"\n[FOUND] {addr}")
        print(f"  Balance: {balance:.2f} ETH")
        for cb in callable_callbacks:
            print(f"  {cb['name']}: gas {cb['gas']}")

    time.sleep(0.2)

print("\n" + "=" * 80)
print(f"FOUND {len(vulnerable_contracts)} CONTRACTS WITH CALLBACKS")
print("=" * 80)

# Deep analyze top findings
for contract in sorted(vulnerable_contracts, key=lambda x: -x['balance'])[:5]:
    addr = contract['address']
    print(f"\n{'='*70}")
    print(f"[ANALYZING] {addr}")
    print(f"Balance: {contract['balance']:.4f} ETH")
    print("=" * 70)

    source_data = get_source(addr)
    if source_data:
        src = source_data.get("SourceCode", "")
        contract_name = source_data.get("ContractName", "Unknown")
        print(f"Contract: {contract_name}")

        if src.startswith("{{"):
            try:
                src_json = json.loads(src[1:-1])
                sources = src_json.get("sources", {})
                src = "\n".join([v.get("content", "") for v in sources.values()])
            except:
                pass

        # Find the callback function
        lines = src.split('\n')
        for cb in contract['callbacks']:
            print(f"\n[{cb['name']}]")
            for i, line in enumerate(lines):
                if cb['name'] in line and 'function' in line.lower():
                    print(f"  Found at line {i+1}:")
                    for j in range(i, min(i+25, len(lines))):
                        print(f"    {j+1}: {lines[j][:70]}")
                        if lines[j].strip() == "}" and j > i + 2:
                            break
                    break

    time.sleep(0.5)

# Save findings
with open("callback_findings.json", "w") as f:
    json.dump(vulnerable_contracts, f, indent=2)

print(f"\n[*] Findings saved to callback_findings.json")
