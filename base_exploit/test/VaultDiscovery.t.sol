// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
}

interface IStrategy {
    function governor() external view returns (address);
    function harvesterAddress() external view returns (address);
    function withdraw(address recipient, address asset, uint256 amount) external;
}

contract VaultDiscovery is Test {
    address constant STRATEGY = 0xF611cC500eEE7E4e4763A05FE623E2363c86d2Af;
    address constant SUPER_OETHB = 0xDBFeFD2e8460a6Ee4955A68582F85708BAEA60A3;
    
    string constant RPC = "https://base-mainnet.g.alchemy.com/v2/ltD0ewEiByO5-I6-cyaeA";
    
    function setUp() public {
        vm.createSelectFork(RPC);
    }
    
    function test_FindVault() public view {
        console.log("=== FINDING VAULT ADDRESS ===\n");
        
        // Check common storage slots for vault address
        // In Origin strategies, vaultAddress is typically stored at a specific slot
        
        // Try various selectors that might return vault
        bytes4[] memory selectors = new bytes4[](10);
        selectors[0] = bytes4(0x5a063f63); // vaultAddress()
        selectors[1] = bytes4(0xfbfa77cf); // vaultAddress() variant
        selectors[2] = bytes4(0x1a3cd59a); // vault()
        selectors[3] = bytes4(0x7f1a327c); // pToken()
        selectors[4] = bytes4(0xcd3293de); // platformAddress()
        selectors[5] = bytes4(0x1313cb95); // platformAddress() variant
        selectors[6] = bytes4(0x38d52e0f); // asset()
        selectors[7] = bytes4(0xfc0c546a); // token()
        selectors[8] = bytes4(0x5c60da1b); // implementation()
        selectors[9] = bytes4(0xf851a440); // admin()
        
        string[10] memory names = [
            "vaultAddress()", "vaultAddress_v2()", "vault()", "pToken()",
            "platformAddress()", "platformAddress_v2()", "asset()", "token()",
            "implementation()", "admin()"
        ];
        
        for (uint i = 0; i < 10; i++) {
            (bool success, bytes memory data) = STRATEGY.staticcall(
                abi.encodeWithSelector(selectors[i])
            );
            if (success && data.length >= 32) {
                address result = abi.decode(data, (address));
                if (result != address(0)) {
                    console.log(names[i], result);
                }
            }
        }
        
        // Also check storage slots
        console.log("\n=== STORAGE SLOTS ===");
        
        // Common vault storage slots in Origin strategies
        uint256[] memory slots = new uint256[](10);
        slots[0] = 0; // slot 0
        slots[1] = 1;
        slots[2] = 100;
        slots[3] = 101;
        slots[4] = 200;
        slots[5] = 201;
        slots[6] = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; // EIP1967 impl
        
        for (uint i = 0; i < 7; i++) {
            bytes32 value = vm.load(STRATEGY, bytes32(slots[i]));
            if (value != bytes32(0)) {
                console.log("Slot:", slots[i]);
                console.logBytes32(value);
            }
        }
    }
    
    function test_TryVaultCaller() public {
        console.log("=== TRYING AS VAULT (superOETHb) ===\n");
        
        // The vault is likely superOETHb itself since this is a yield strategy
        vm.startPrank(SUPER_OETHB);
        
        console.log("Caller:", SUPER_OETHB);
        
        try IStrategy(STRATEGY).withdraw(SUPER_OETHB, SUPER_OETHB, 100e18) {
            console.log("SUCCESS! Withdraw as superOETHb worked");
            console.log("superOETHb balance:", IERC20(SUPER_OETHB).balanceOf(SUPER_OETHB) / 1e18);
        } catch Error(string memory reason) {
            console.log("Failed:", reason);
        } catch {
            console.log("Failed: low-level revert");
        }
        
        vm.stopPrank();
    }
}
