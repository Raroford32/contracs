// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

contract PositionAnalysis is Test {
    address constant NFT_MANAGER = 0x827922686190790b37229fd06084350E74485b72;
    address constant CL_POOL = 0x6446021F4E396dA3df4235C62537431372195D38;
    uint256 constant TOKEN_ID = 517500;
    
    string constant RPC = "https://base-mainnet.g.alchemy.com/v2/ltD0ewEiByO5-I6-cyaeA";
    
    function setUp() public {
        vm.createSelectFork(RPC);
    }
    
    function test_PositionRangeViaRawCall() public view {
        console.log("=== POSITION 517500 ANALYSIS ===\n");
        
        // Call positions(517500) and decode manually
        (bool success, bytes memory data) = NFT_MANAGER.staticcall(
            abi.encodeWithSignature("positions(uint256)", TOKEN_ID)
        );
        require(success, "positions call failed");
        
        // Decode relevant fields
        // positions returns: nonce, operator, token0, token1, tickSpacing, tickLower, tickUpper, liquidity, ...
        // Offset: 0:nonce(96), 1:operator(address), 2:token0, 3:token1, 4:tickSpacing(int24), 5:tickLower(int24), 6:tickUpper(int24), 7:liquidity(uint128)
        
        int24 tickLower;
        int24 tickUpper;
        uint128 liquidity;
        
        assembly {
            // Skip first 32 bytes (data length), then decode at offsets
            // Each slot is 32 bytes
            // tickLower is at slot 5 (offset 5*32 = 160 from data start)
            // tickUpper is at slot 6 (offset 6*32 = 192)
            // liquidity is at slot 7 (offset 7*32 = 224)
            tickLower := mload(add(data, 192))  // slot 5
            tickUpper := mload(add(data, 224))  // slot 6
            liquidity := mload(add(data, 256))  // slot 7
        }
        
        // Get current tick
        (bool s2, bytes memory d2) = CL_POOL.staticcall(
            abi.encodeWithSignature("slot0()")
        );
        require(s2, "slot0 call failed");
        
        int24 currentTick;
        assembly {
            // slot0 returns: sqrtPriceX96(uint160), tick(int24), ...
            // tick is at offset 32 (second slot)
            currentTick := mload(add(d2, 64))
        }
        
        console.log("=== TICK RANGE ===");
        console.log("Tick Lower:", tickLower);
        console.log("Tick Upper:", tickUpper);  
        console.log("Current Tick:", currentTick);
        console.log("Liquidity:", liquidity);
        
        // Check if in range
        bool inRange = currentTick >= tickLower && currentTick < tickUpper;
        console.log("");
        console.log("Position IN RANGE:", inRange);
        
        if (inRange) {
            console.log("Position is ACTIVE and earning fees");
        } else {
            console.log("*** POSITION OUT OF RANGE ***");
            if (currentTick < tickLower) {
                console.log("Price below range - 100% token0 (WETH)");
            } else {
                console.log("Price above range - 100% token1 (superOETHb)");
            }
        }
    }
}
