// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IStrategy {
    function governor() external view returns (address);
    function harvesterAddress() external view returns (address);
    function clPool() external view returns (address);
    function rewardTokenAddresses(uint256) external view returns (address[] memory);
    function checkBalance(address asset) external view returns (uint256);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function decimals() external view returns (uint8);
    function symbol() external view returns (string memory);
    function totalSupply() external view returns (uint256);
}

interface ISlipstreamPool {
    function token0() external view returns (address);
    function token1() external view returns (address);
    function liquidity() external view returns (uint128);
    function slot0() external view returns (
        uint160 sqrtPriceX96,
        int24 tick,
        uint16 observationIndex,
        uint16 observationCardinality,
        uint16 observationCardinalityNext,
        bool unlocked
    );
    function gauge() external view returns (address);
}

interface IGauge {
    function stakedContains(address depositor, uint256 tokenId) external view returns (bool);
    function rewardRate() external view returns (uint256);
    function earned(address account, uint256 tokenId) external view returns (uint256);
}

contract ExploreStrategy is Test {
    address constant STRATEGY = 0xF611cC500eEE7E4e4763A05FE623E2363c86d2Af;
    address constant SUPER_OETHB = 0xDBFeFD2e8460a6Ee4955A68582F85708BAEA60A3;
    address constant WETH = 0x4200000000000000000000000000000000000006;
    address constant AERO = 0x940181a94A35A4569E4529A3CDfB74e38FD98631;
    
    string constant RPC = "https://base-mainnet.g.alchemy.com/v2/ltD0ewEiByO5-I6-cyaeA";
    
    IStrategy strategy;
    
    function setUp() public {
        vm.createSelectFork(RPC);
        strategy = IStrategy(STRATEGY);
    }
    
    function test_ExploreState() public view {
        console.log("=== STRATEGY STATE EXPLORATION ===\n");
        
        // Basic info
        console.log("Strategy:", STRATEGY);
        console.log("Governor:", strategy.governor());
        console.log("Harvester:", strategy.harvesterAddress());
        
        // CL Pool
        address pool = strategy.clPool();
        console.log("\nCL Pool:", pool);
        
        if (pool != address(0)) {
            ISlipstreamPool clPool = ISlipstreamPool(pool);
            
            try clPool.token0() returns (address t0) {
                console.log("  Token0:", t0);
            } catch {}
            
            try clPool.token1() returns (address t1) {
                console.log("  Token1:", t1);
            } catch {}
            
            try clPool.liquidity() returns (uint128 liq) {
                console.log("  Liquidity:", liq);
            } catch {}
            
            try clPool.gauge() returns (address g) {
                console.log("  Gauge:", g);
            } catch {}
        }
        
        // Token balances
        console.log("\n=== TOKEN BALANCES ===");
        
        uint256 wethBal = IERC20(WETH).balanceOf(STRATEGY);
        console.log("WETH in strategy:", wethBal / 1e18, "ETH");
        
        uint256 superBal = IERC20(SUPER_OETHB).balanceOf(STRATEGY);
        console.log("superOETHb in strategy:", superBal / 1e18);
        
        uint256 aeroBal = IERC20(AERO).balanceOf(STRATEGY);
        console.log("AERO in strategy:", aeroBal / 1e18);
        
        // Check total value
        console.log("\n=== CHECKING CONTRACT CODE ===");
        uint256 codeSize;
        address impl = STRATEGY;
        assembly {
            codeSize := extcodesize(impl)
        }
        console.log("Strategy code size:", codeSize);
    }
    
    function test_CheckAllViewFunctions() public view {
        console.log("=== CALLING ALL READABLE FUNCTIONS ===\n");
        
        // Try many selectors
        bytes4[] memory selectors = new bytes4[](20);
        selectors[0] = bytes4(0x0c340a24); // governor
        selectors[1] = bytes4(0x791b98bc); // harvesterAddress  
        selectors[2] = bytes4(0xc31c9c07); // clPool
        selectors[3] = bytes4(0x18160ddd); // totalSupply
        selectors[4] = bytes4(0x1072cbea); // totalValue
        selectors[5] = bytes4(0x38d52e0f); // asset
        selectors[6] = bytes4(0x01e1d114); // totalAssets
        selectors[7] = bytes4(0x5a063f63); // vaultAddress
        selectors[8] = bytes4(0xad5c4648); // WETH9
        selectors[9] = bytes4(0x3fc8cef3); // weth
        
        string[10] memory names = ["governor", "harvesterAddress", "clPool", "totalSupply", 
                                   "totalValue", "asset", "totalAssets", "vaultAddress", "WETH9", "weth"];
        
        for (uint i = 0; i < 10; i++) {
            (bool success, bytes memory data) = STRATEGY.staticcall(abi.encodeWithSelector(selectors[i]));
            if (success && data.length >= 32) {
                if (data.length == 32) {
                    uint256 val = abi.decode(data, (uint256));
                    if (val > 1e15 && val < 1e30) {
                        console.log(names[i], ":", val / 1e18);
                    } else if (val > 0 && val < 1e15) {
                        address addr = address(uint160(val));
                        console.log(names[i], ":", addr);
                    }
                }
            }
        }
    }
}
