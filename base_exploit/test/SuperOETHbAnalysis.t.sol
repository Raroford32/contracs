// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
}

interface IOETHb {
    function governor() external view returns (address);
    function strategistAddr() external view returns (address);
    function totalValue() external view returns (uint256);
    function checkBalance() external view returns (uint256);
    function withdrawFromStrategy(address strategy, address recipient, address asset, uint256 amount) external;
    function rebase() external;
    function allocate() external;
}

interface IStrategy {
    function withdraw(address recipient, address asset, uint256 amount) external;
}

contract SuperOETHbAnalysis is Test {
    address constant STRATEGY = 0xF611cC500eEE7E4e4763A05FE623E2363c86d2Af;
    address constant SUPER_OETHB = 0xDBFeFD2e8460a6Ee4955A68582F85708BAEA60A3;
    
    string constant RPC = "https://base-mainnet.g.alchemy.com/v2/ltD0ewEiByO5-I6-cyaeA";
    
    address attacker;
    
    function setUp() public {
        vm.createSelectFork(RPC);
        attacker = makeAddr("attacker");
    }
    
    function test_SuperOETHbFunctions() public view {
        console.log("=== superOETHb FUNCTION CALLS ===\n");
        
        IOETHb vault = IOETHb(SUPER_OETHB);
        
        // Try various functions
        try vault.governor() returns (address gov) {
            console.log("governor:", gov);
        } catch {}
        
        try vault.strategistAddr() returns (address strat) {
            console.log("strategist:", strat);
        } catch {}
        
        try vault.totalValue() returns (uint256 val) {
            console.log("totalValue:", val / 1e18);
        } catch {}
        
        // Check balance
        uint256 supply = IERC20(SUPER_OETHB).totalSupply();
        console.log("\ntotalSupply:", supply / 1e18);
    }
    
    function test_VaultWithdrawFromStrategy() public {
        console.log("=== VAULT WITHDRAW FROM STRATEGY ===\n");
        
        // Get governor
        address governor;
        (bool success, bytes memory data) = SUPER_OETHB.staticcall(
            abi.encodeWithSignature("governor()")
        );
        if (success && data.length >= 32) {
            governor = abi.decode(data, (address));
            console.log("Governor:", governor);
        }
        
        // Try to call withdrawFromStrategy as governor
        vm.startPrank(governor);
        
        console.log("\nAttempting withdrawFromStrategy as governor...");
        
        try IOETHb(SUPER_OETHB).withdrawFromStrategy(
            STRATEGY,
            governor,
            SUPER_OETHB,
            100e18
        ) {
            console.log("SUCCESS!");
        } catch Error(string memory reason) {
            console.log("Failed:", reason);
        } catch (bytes memory lowLevelData) {
            console.log("Failed with low-level error");
            console.logBytes(lowLevelData);
        }
        
        vm.stopPrank();
    }
    
    function test_DirectVaultCall() public {
        console.log("=== DIRECT VAULT -> STRATEGY ===\n");
        
        // The vault should be able to call strategy.withdraw
        // Let's try calling from superOETHb proxy
        
        vm.startPrank(SUPER_OETHB);
        
        console.log("Calling strategy.withdraw from superOETHb...");
        
        try IStrategy(STRATEGY).withdraw(SUPER_OETHB, SUPER_OETHB, 100e18) {
            console.log("SUCCESS!");
        } catch Error(string memory reason) {
            console.log("Failed:", reason);
        } catch {
            console.log("Failed: low-level revert");
        }
        
        vm.stopPrank();
    }
}
