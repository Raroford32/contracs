// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
}

interface ICLGauge {
    function stakedValues(address depositor) external view returns (uint256[] memory);
    function earned(address account, uint256 tokenId) external view returns (uint256);
}

contract FullAnalysis is Test {
    address constant STRATEGY = 0xF611cC500eEE7E4e4763A05FE623E2363c86d2Af;
    address constant CL_POOL = 0x6446021F4E396dA3df4235C62537431372195D38;
    address constant GAUGE = 0xdD234DBe2efF53BED9E8fC0e427ebcd74ed4F429;
    address constant NFT_MANAGER = 0x827922686190790b37229fd06084350E74485b72;
    address constant WETH = 0x4200000000000000000000000000000000000006;
    address constant SUPER_OETHB = 0xDBFeFD2e8460a6Ee4955A68582F85708BAEA60A3;
    address constant AERO = 0x940181a94A35A4569E4529A3CDfB74e38FD98631;
    
    uint256 constant TOKEN_ID = 517500;
    
    string constant RPC = "https://base-mainnet.g.alchemy.com/v2/ltD0ewEiByO5-I6-cyaeA";
    
    function setUp() public {
        vm.createSelectFork(RPC);
    }
    
    function test_FullValueAtRisk() public view {
        console.log("=== FULL VALUE AT RISK ANALYSIS ===\n");
        
        // Pool balances
        uint256 poolWETH = IERC20(WETH).balanceOf(CL_POOL);
        uint256 poolSuper = IERC20(SUPER_OETHB).balanceOf(CL_POOL);
        
        console.log("CL Pool Balances:");
        console.log("  WETH:", poolWETH / 1e18);
        console.log("  superOETHb:", poolSuper / 1e18);
        console.log("  Total ~ETH:", (poolWETH + poolSuper) / 1e18);
        
        // Gauge balances
        uint256 gaugeAERO = IERC20(AERO).balanceOf(GAUGE);
        console.log("\nGauge AERO:", gaugeAERO / 1e18);
        
        // Check strategy's claimable
        uint256[] memory tokenIds = ICLGauge(GAUGE).stakedValues(STRATEGY);
        console.log("\nStrategy staked positions:", tokenIds.length);
        
        if (tokenIds.length > 0) {
            uint256 totalEarned = 0;
            for (uint i = 0; i < tokenIds.length; i++) {
                uint256 earned = ICLGauge(GAUGE).earned(STRATEGY, tokenIds[i]);
                totalEarned += earned;
                console.log("  Token earned AERO:", earned / 1e18);
            }
            console.log("  Total earned:", totalEarned / 1e18, "AERO");
        }
        
        // Position analysis summary
        console.log("\n=== POSITION ANALYSIS ===");
        console.log("Position 517500:");
        console.log("  tickLower: -1");
        console.log("  tickUpper: 0");
        console.log("  Current tick: 23");
        console.log("  IN RANGE: NO");
        console.log("");
        console.log("This position is OUT OF RANGE!");
        console.log("The position is 100% superOETHb");
        console.log("Not earning any trading fees");
        
        // Total superOETHb supply
        uint256 totalSuper = IERC20(SUPER_OETHB).totalSupply();
        console.log("\n=== superOETHb METRICS ===");
        console.log("Total Supply:", totalSuper / 1e18);
        console.log("In CL Pool:", poolSuper * 100 / totalSuper, "% of supply");
    }
    
    function test_ExploitScenarios() public view {
        console.log("=== POTENTIAL EXPLOIT SCENARIOS ===\n");
        
        console.log("1. PRICE MANIPULATION");
        console.log("   Pool has only 10 WETH vs 2026 superOETHb");
        console.log("   Swapping ~10 WETH could significantly move price");
        console.log("   BUT: Position is already out of range");
        console.log("");
        
        console.log("2. REWARD TIMING");
        console.log("   Position is out of range -> no fees earned");
        console.log("   Still earns AERO from gauge (liquidity mining)");
        console.log("   Attacker cannot steal gauge rewards directly");
        console.log("");
        
        console.log("3. CROSS-CONTRACT STATE");
        console.log("   Strategy deposits to gauge");
        console.log("   Gauge holds NFT position");
        console.log("   No obvious state desync vulnerability");
        console.log("");
        
        console.log("4. ORACLE/PRICE FEED");
        console.log("   No external oracle dependency found");
        console.log("   Price is determined by AMM state");
        console.log("");
        
        console.log("=== CONCLUSION ===");
        console.log("No immediately exploitable vulnerability found");
        console.log("Position out of range is a config issue, not exploit");
    }
}
