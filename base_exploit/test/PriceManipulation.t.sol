// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

interface IWETH {
    function deposit() external payable;
    function withdraw(uint256) external;
    function approve(address, uint256) external returns (bool);
    function balanceOf(address) external view returns (uint256);
}

interface ISlipstreamPool {
    function slot0() external view returns (uint160 sqrtPriceX96, int24 tick, uint16, uint16, uint16, bool);
    function liquidity() external view returns (uint128);
    function tickSpacing() external view returns (int24);
    function swap(
        address recipient,
        bool zeroForOne,
        int256 amountSpecified,
        uint160 sqrtPriceLimitX96,
        bytes calldata data
    ) external returns (int256 amount0, int256 amount1);
}

interface ISwapRouter {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        int24 tickSpacing;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }
    function exactInputSingle(ExactInputSingleParams calldata params) external returns (uint256 amountOut);
}

contract PriceManipulation is Test {
    address constant CL_POOL = 0x6446021F4E396dA3df4235C62537431372195D38;
    address constant WETH = 0x4200000000000000000000000000000000000006;
    address constant SUPER_OETHB = 0xDBFeFD2e8460a6Ee4955A68582F85708BAEA60A3;
    
    // Aerodrome swap router on Base
    address constant ROUTER = 0xBE6D8f0d05cC4be24d5167a3eF062215bE6D18a5;
    
    string constant RPC = "https://base-mainnet.g.alchemy.com/v2/ltD0ewEiByO5-I6-cyaeA";
    
    function setUp() public {
        vm.createSelectFork(RPC);
    }
    
    function test_CurrentPriceAnalysis() public view {
        console.log("=== PRICE ANALYSIS ===\n");
        
        ISlipstreamPool pool = ISlipstreamPool(CL_POOL);
        
        (uint160 sqrtPriceX96, int24 tick,,,,) = pool.slot0();
        int24 tickSpacing = pool.tickSpacing();
        uint128 liquidity = pool.liquidity();
        
        console.log("sqrtPriceX96:", sqrtPriceX96);
        console.log("Current tick:", tick);
        console.log("Tick spacing:", tickSpacing);
        console.log("Pool liquidity:", liquidity);
        
        // Calculate price: price = (sqrtPriceX96 / 2^96)^2
        // This gives price of token1 in terms of token0
        // token0 = WETH, token1 = superOETHb
        // So price = superOETHb per WETH
        
        // With tick = 23 and tick spacing = 1
        // price ≈ 1.0001^tick ≈ 1.0023
        // This means 1 WETH ≈ 1.0023 superOETHb
        
        console.log("\nPrice interpretation:");
        console.log("  tick 23 means 1 WETH = ~1.0023 superOETHb");
        console.log("  This is close to 1:1 peg");
        
        // Pool balances
        uint256 weth = IERC20(WETH).balanceOf(CL_POOL);
        uint256 super_ = IERC20(SUPER_OETHB).balanceOf(CL_POOL);
        
        console.log("\nPool reserves:");
        console.log("  WETH:", weth / 1e18);
        console.log("  superOETHb:", super_ / 1e18);
        
        // The imbalance suggests most liquidity is in superOETHb side
        // This happens when price has moved significantly from the position's range
        // OR the position is heavily weighted to one side
    }
    
    function test_EstimateSwapImpact() public view {
        console.log("=== SWAP IMPACT ESTIMATION ===\n");
        
        // Current state
        uint256 wethInPool = IERC20(WETH).balanceOf(CL_POOL);
        console.log("Current WETH in pool:", wethInPool / 1e18);
        
        // If someone swaps 10 ETH into the pool (buying superOETHb)
        // They would roughly double the WETH and take out superOETHb
        console.log("\nHypothetical: Swap 10 ETH for superOETHb");
        console.log("  Would roughly double WETH reserves");
        console.log("  Could significantly move tick down (price of superOETHb drops)");
        
        // If someone swaps 100 ETH
        console.log("\nHypothetical: Swap 100 ETH for superOETHb");
        console.log("  Would 10x WETH reserves");
        console.log("  Could move price dramatically out of range");
        
        // Check total liquidity value at risk
        uint256 totalValue = wethInPool + IERC20(SUPER_OETHB).balanceOf(CL_POOL);
        console.log("\nTotal pool value:", totalValue / 1e18, "ETH equivalent");
    }
    
    function test_CheckPositionRange() public view {
        console.log("=== POSITION RANGE CHECK ===\n");
        
        // The position is token 517500 in gauge
        // We need to check if current tick is within the position's range
        
        ISlipstreamPool pool = ISlipstreamPool(CL_POOL);
        (, int24 currentTick,,,,) = pool.slot0();
        
        console.log("Current tick:", currentTick);
        
        // If tick is outside the position's range:
        // - The position earns no fees
        // - The position has all of one token
        // - This is a potential issue for the strategy
        
        console.log("\nTo find position range, need to call positions() on NFT manager");
        console.log("Position 517500 tick range determines if it's in range");
    }
}
