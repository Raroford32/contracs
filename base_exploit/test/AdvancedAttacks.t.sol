// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

interface IWETH {
    function deposit() external payable;
    function withdraw(uint256) external;
    function approve(address, uint256) external returns (bool);
    function balanceOf(address) external view returns (uint256);
}

interface ISlipstreamRouter {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        int24 tickSpacing;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }
    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);
}

interface IStrategy {
    function deposit(address asset, uint256 amount) external;
    function withdraw(address recipient, address asset, uint256 amount) external;
    function checkBalance(address asset) external view returns (uint256);
    function governor() external view returns (address);
    function harvesterAddress() external view returns (address);
}

contract AdvancedAttacks is Test {
    address constant STRATEGY = 0xF611cC500eEE7E4e4763A05FE623E2363c86d2Af;
    address constant CL_POOL = 0x6446021F4E396dA3df4235C62537431372195D38;
    address constant WETH = 0x4200000000000000000000000000000000000006;
    address constant SUPER_OETHB = 0xDBFeFD2e8460a6Ee4955A68582F85708BAEA60A3;
    address constant AERO = 0x940181a94A35A4569E4529A3CDfB74e38FD98631;
    
    // Aerodrome Slipstream Router
    address constant ROUTER = 0xBE6D8f0d05cC4be24d5167a3eF062215bE6D18a5;
    
    string constant RPC = "https://base-mainnet.g.alchemy.com/v2/ltD0ewEiByO5-I6-cyaeA";
    
    address attacker;
    address governor;
    address harvester;
    
    function setUp() public {
        vm.createSelectFork(RPC);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 1000 ether);
        
        governor = IStrategy(STRATEGY).governor();
        harvester = IStrategy(STRATEGY).harvesterAddress();
    }
    
    function test_AttackAsGovernor() public {
        console.log("=== ATTACK AS GOVERNOR ===\n");
        console.log("Governor:", governor);
        console.log("Harvester:", harvester);
        
        // Impersonate governor
        vm.startPrank(governor);
        
        // Try withdraw as governor
        uint256 balBefore = IERC20(SUPER_OETHB).balanceOf(governor);
        console.log("\nGovernor superOETHb before:", balBefore / 1e18);
        
        try IStrategy(STRATEGY).withdraw(governor, SUPER_OETHB, 100e18) {
            uint256 balAfter = IERC20(SUPER_OETHB).balanceOf(governor);
            console.log("Governor superOETHb after:", balAfter / 1e18);
            console.log("Received:", (balAfter - balBefore) / 1e18);
        } catch Error(string memory reason) {
            console.log("Withdraw failed:", reason);
        } catch {
            console.log("Withdraw failed: low-level revert");
        }
        
        vm.stopPrank();
    }
    
    function test_AttackAsHarvester() public {
        console.log("=== ATTACK AS HARVESTER ===\n");
        console.log("Harvester:", harvester);
        
        vm.startPrank(harvester);
        
        // Check if harvester can do anything special
        console.log("Testing harvester capabilities...");
        
        // Try collectRewardTokens
        (bool success, ) = STRATEGY.call(
            abi.encodeWithSignature("collectRewardTokens()")
        );
        console.log("collectRewardTokens:", success ? "ALLOWED" : "BLOCKED");
        
        vm.stopPrank();
    }
    
    function test_PriceManipulationAttack() public {
        console.log("=== PRICE MANIPULATION ATTACK ===\n");
        
        vm.startPrank(attacker);
        
        // Wrap ETH to WETH
        IWETH(WETH).deposit{value: 100 ether}();
        console.log("Attacker WETH:", IWETH(WETH).balanceOf(attacker) / 1e18);
        
        // Pool state before
        uint256 poolWethBefore = IERC20(WETH).balanceOf(CL_POOL);
        uint256 poolSuperBefore = IERC20(SUPER_OETHB).balanceOf(CL_POOL);
        console.log("\nPool before:");
        console.log("  WETH:", poolWethBefore / 1e18);
        console.log("  superOETHb:", poolSuperBefore / 1e18);
        
        // Approve router
        IWETH(WETH).approve(ROUTER, type(uint256).max);
        
        // Try to swap 50 WETH for superOETHb
        console.log("\nAttempting 50 WETH swap...");
        
        ISlipstreamRouter.ExactInputSingleParams memory params = ISlipstreamRouter.ExactInputSingleParams({
            tokenIn: WETH,
            tokenOut: SUPER_OETHB,
            tickSpacing: 1,
            recipient: attacker,
            deadline: block.timestamp + 3600,
            amountIn: 50 ether,
            amountOutMinimum: 0,
            sqrtPriceLimitX96: 0
        });
        
        try ISlipstreamRouter(ROUTER).exactInputSingle(params) returns (uint256 amountOut) {
            console.log("Swap succeeded! Got:", amountOut / 1e18, "superOETHb");
            
            // Check pool state after
            uint256 poolWethAfter = IERC20(WETH).balanceOf(CL_POOL);
            uint256 poolSuperAfter = IERC20(SUPER_OETHB).balanceOf(CL_POOL);
            console.log("\nPool after:");
            console.log("  WETH:", poolWethAfter / 1e18);
            console.log("  superOETHb:", poolSuperAfter / 1e18);
            
            // Price impact
            console.log("\nPrice impact analysis:");
            console.log("  WETH added to pool:", (poolWethAfter - poolWethBefore) / 1e18);
            console.log("  superOETHb removed:", (poolSuperBefore - poolSuperAfter) / 1e18);
        } catch {
            console.log("Swap failed");
        }
        
        vm.stopPrank();
    }
}
