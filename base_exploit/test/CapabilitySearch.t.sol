// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
}

interface ICLGauge {
    function withdraw(uint256 tokenId) external;
    function getReward(uint256 tokenId) external;
}

interface INFTPositionManager {
    function ownerOf(uint256 tokenId) external view returns (address);
}

interface IStrategy {
    function withdraw(address recipient, address asset, uint256 amount) external;
    function collectRewardTokens() external;
}

interface ISlipstreamPool {
    function slot0() external view returns (uint160, int24, uint16, uint16, uint16, bool);
    function liquidity() external view returns (uint128);
}

contract CapabilitySearch is Test {
    address constant STRATEGY = 0xF611cC500eEE7E4e4763A05FE623E2363c86d2Af;
    address constant CL_POOL = 0x6446021F4E396dA3df4235C62537431372195D38;
    address constant GAUGE = 0xdD234DBe2efF53BED9E8fC0e427ebcd74ed4F429;
    address constant NFT_MANAGER = 0x827922686190790b37229fd06084350E74485b72;
    address constant WETH = 0x4200000000000000000000000000000000000006;
    address constant SUPER_OETHB = 0xDBFeFD2e8460a6Ee4955A68582F85708BAEA60A3;
    address constant AERO = 0x940181a94A35A4569E4529A3CDfB74e38FD98631;
    
    uint256 constant TOKEN_ID = 517500;
    
    string constant RPC = "https://base-mainnet.g.alchemy.com/v2/ltD0ewEiByO5-I6-cyaeA";
    
    address attacker;
    
    function setUp() public {
        vm.createSelectFork(RPC);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }
    
    function test_PositionOwner() public view {
        console.log("=== POSITION OWNERSHIP ===\n");
        
        INFTPositionManager nft = INFTPositionManager(NFT_MANAGER);
        address owner = nft.ownerOf(TOKEN_ID);
        
        console.log("Token ID:", TOKEN_ID);
        console.log("Owner:", owner);
        console.log("Is Gauge?:", owner == GAUGE);
    }
    
    function test_AttackVector_DirectWithdraw() public {
        console.log("=== ATTACK: Direct Withdraw ===\n");
        
        vm.startPrank(attacker);
        
        console.log("Attacker:", attacker);
        console.log("Attempting withdraw from strategy...");
        
        try IStrategy(STRATEGY).withdraw(attacker, SUPER_OETHB, 1000e18) {
            console.log("VULNERABLE!");
        } catch {
            console.log("Blocked (as expected)");
        }
        
        vm.stopPrank();
    }
    
    function test_AttackVector_GaugeWithdraw() public {
        console.log("=== ATTACK: Gauge Withdraw ===\n");
        
        vm.startPrank(attacker);
        
        console.log("Attempting to withdraw NFT from gauge...");
        
        try ICLGauge(GAUGE).withdraw(TOKEN_ID) {
            console.log("VULNERABLE!");
        } catch {
            console.log("Blocked (as expected)");
        }
        
        vm.stopPrank();
    }
    
    function test_AttackVector_CollectRewards() public {
        console.log("=== ATTACK: Collect Rewards ===\n");
        
        vm.startPrank(attacker);
        
        uint256 aeroBefore = IERC20(AERO).balanceOf(attacker);
        console.log("AERO before:", aeroBefore);
        
        try IStrategy(STRATEGY).collectRewardTokens() {
            uint256 aeroAfter = IERC20(AERO).balanceOf(attacker);
            console.log("AERO after:", aeroAfter);
            if (aeroAfter > aeroBefore) {
                console.log("VULNERABLE! Got AERO");
            }
        } catch {
            console.log("Blocked (as expected)");
        }
        
        vm.stopPrank();
    }
    
    function test_PoolImbalanceAnalysis() public view {
        console.log("=== POOL IMBALANCE ANALYSIS ===\n");
        
        uint256 weth = IERC20(WETH).balanceOf(CL_POOL);
        uint256 super_ = IERC20(SUPER_OETHB).balanceOf(CL_POOL);
        
        console.log("WETH in pool:", weth / 1e18);
        console.log("superOETHb in pool:", super_ / 1e18);
        console.log("Ratio superOETHb:WETH:", super_ / weth);
        
        console.log("\nPool is HIGHLY IMBALANCED");
        console.log("1:202 ratio means price manipulation is cheap");
    }
}
