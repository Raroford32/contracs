// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

contract PositionAnalysis2 is Test {
    address constant NFT_MANAGER = 0x827922686190790b37229fd06084350E74485b72;
    address constant CL_POOL = 0x6446021F4E396dA3df4235C62537431372195D38;
    uint256 constant TOKEN_ID = 517500;
    
    string constant RPC = "https://base-mainnet.g.alchemy.com/v2/ltD0ewEiByO5-I6-cyaeA";
    
    function setUp() public {
        vm.createSelectFork(RPC);
    }
    
    function test_DumpPositionData() public view {
        console.log("=== RAW POSITION DATA ===\n");
        
        (bool success, bytes memory data) = NFT_MANAGER.staticcall(
            abi.encodeWithSignature("positions(uint256)", TOKEN_ID)
        );
        require(success, "call failed");
        
        console.log("Data length:", data.length);
        
        // Dump each 32-byte slot
        for (uint i = 0; i < 12 && i * 32 < data.length; i++) {
            bytes32 slot;
            assembly {
                slot := mload(add(add(data, 32), mul(i, 32)))
            }
            console.log("Slot", i);
            console.logBytes32(slot);
        }
    }
    
    function test_DecodePosition() public view {
        console.log("=== DECODED POSITION ===\n");
        
        (bool success, bytes memory data) = NFT_MANAGER.staticcall(
            abi.encodeWithSignature("positions(uint256)", TOKEN_ID)
        );
        require(success, "call failed");
        
        // The struct packing for Slipstream positions:
        // uint96 nonce - packed with operator in same slot
        // address operator - lower 160 bits of slot 0
        // address token0 - slot 1
        // address token1 - slot 2
        // int24 tickSpacing - slot 3
        // int24 tickLower - slot 4
        // int24 tickUpper - slot 5
        // uint128 liquidity - slot 6
        // uint256 feeGrowthInside0LastX128 - slot 7
        // uint256 feeGrowthInside1LastX128 - slot 8
        // uint128 tokensOwed0 - slot 9
        // uint128 tokensOwed1 - slot 10
        
        // But ABI encoding returns each as separate 32-byte slot
        // So decode from data:
        
        uint256 slot4;
        uint256 slot5;
        uint256 slot6;
        
        assembly {
            slot4 := mload(add(data, 160)) // tickLower at position 4
            slot5 := mload(add(data, 192)) // tickUpper at position 5
            slot6 := mload(add(data, 224)) // liquidity at position 6
        }
        
        // int24 is stored in lower 24 bits, sign extended to 256 bits
        int24 tickLower = int24(int256(slot4));
        int24 tickUpper = int24(int256(slot5));
        uint128 liquidity = uint128(slot6);
        
        console.log("Raw slot4 (tickLower):", slot4);
        console.log("Raw slot5 (tickUpper):", slot5);
        console.log("Raw slot6 (liquidity):", slot6);
        
        console.log("\nDecoded:");
        console.log("tickLower:", tickLower);
        console.log("tickUpper:", tickUpper);
        console.log("liquidity:", liquidity);
        
        // Get current tick
        (bool s2, bytes memory d2) = CL_POOL.staticcall(
            abi.encodeWithSignature("slot0()")
        );
        require(s2, "slot0 failed");
        
        int24 currentTick;
        assembly {
            let rawTick := mload(add(d2, 64))
            currentTick := rawTick
        }
        console.log("\nCurrent tick:", currentTick);
        
        bool inRange = currentTick >= tickLower && currentTick < tickUpper;
        console.log("In range:", inRange);
    }
}
