// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
}

interface ICLGauge {
    function stakedValues(address depositor) external view returns (uint256[] memory);
    function rewardRate() external view returns (uint256);
    function rewardToken() external view returns (address);
    function earned(address account, uint256 tokenId) external view returns (uint256);
    function nft() external view returns (address);
}

interface INFTPositionManager {
    function balanceOf(address owner) external view returns (uint256);
    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);
    function ownerOf(uint256 tokenId) external view returns (address);
}

interface ISlipstreamPool {
    function slot0() external view returns (
        uint160 sqrtPriceX96,
        int24 tick,
        uint16 observationIndex,
        uint16 observationCardinality,
        uint16 observationCardinalityNext,
        bool unlocked
    );
    function liquidity() external view returns (uint128);
}

contract DeepExplore is Test {
    address constant STRATEGY = 0xF611cC500eEE7E4e4763A05FE623E2363c86d2Af;
    address constant CL_POOL = 0x6446021F4E396dA3df4235C62537431372195D38;
    address constant GAUGE = 0xdD234DBe2efF53BED9E8fC0e427ebcd74ed4F429;
    address constant WETH = 0x4200000000000000000000000000000000000006;
    address constant SUPER_OETHB = 0xDBFeFD2e8460a6Ee4955A68582F85708BAEA60A3;
    address constant AERO = 0x940181a94A35A4569E4529A3CDfB74e38FD98631;
    
    string constant RPC = "https://base-mainnet.g.alchemy.com/v2/ltD0ewEiByO5-I6-cyaeA";
    
    function setUp() public {
        vm.createSelectFork(RPC);
    }
    
    function test_GaugeAnalysis() public view {
        console.log("=== GAUGE ANALYSIS ===\n");
        
        ICLGauge gauge = ICLGauge(GAUGE);
        
        address rt = gauge.rewardToken();
        console.log("Reward Token:", rt);
        
        uint256 rate = gauge.rewardRate();
        console.log("Reward Rate:", rate);
        console.log("Daily AERO:", rate * 86400 / 1e18);
        
        address nft = gauge.nft();
        console.log("NFT Manager:", nft);
        
        // Check staked positions
        console.log("\n=== STAKED POSITIONS ===");
        uint256[] memory tokenIds = gauge.stakedValues(STRATEGY);
        console.log("Strategy staked positions:", tokenIds.length);
        
        for (uint i = 0; i < tokenIds.length && i < 5; i++) {
            console.log("  Token ID:", tokenIds[i]);
            uint256 earned = gauge.earned(STRATEGY, tokenIds[i]);
            console.log("  Earned AERO:", earned / 1e18);
        }
    }
    
    function test_PoolState() public view {
        console.log("=== POOL STATE ===\n");
        
        ISlipstreamPool pool = ISlipstreamPool(CL_POOL);
        
        (uint160 sqrtPriceX96, int24 tick,,,,) = pool.slot0();
        console.log("sqrtPriceX96:", sqrtPriceX96);
        console.log("Current tick:", tick > 0 ? uint256(uint24(tick)) : 0);
        console.log("Pool liquidity:", pool.liquidity());
        
        // Pool balances
        console.log("\n=== POOL BALANCES ===");
        console.log("WETH in pool:", IERC20(WETH).balanceOf(CL_POOL) / 1e18);
        console.log("superOETHb in pool:", IERC20(SUPER_OETHB).balanceOf(CL_POOL) / 1e18);
    }
    
    function test_ValueCheck() public view {
        console.log("=== VALUE CHECK ===\n");
        
        // Pool totals
        uint256 wethInPool = IERC20(WETH).balanceOf(CL_POOL);
        uint256 superInPool = IERC20(SUPER_OETHB).balanceOf(CL_POOL);
        
        console.log("Pool WETH:", wethInPool / 1e18);
        console.log("Pool superOETHb:", superInPool / 1e18);
        console.log("Total value ~ETH:", (wethInPool + superInPool) / 1e18);
        
        // AERO in gauge
        console.log("\nAERO in gauge:", IERC20(AERO).balanceOf(GAUGE) / 1e18);
        
        // Strategy balance check
        (bool success, bytes memory data) = STRATEGY.staticcall(
            abi.encodeWithSignature("checkBalance(address)", SUPER_OETHB)
        );
        if (success && data.length == 32) {
            console.log("\nStrategy checkBalance(superOETHb):", abi.decode(data, (uint256)) / 1e18);
        }
    }
    
    function test_NFTOwnership() public view {
        console.log("=== NFT OWNERSHIP CHECK ===\n");
        
        // Get NFT manager from gauge
        ICLGauge gauge = ICLGauge(GAUGE);
        address nftAddr = gauge.nft();
        console.log("NFT Manager from gauge:", nftAddr);
        
        INFTPositionManager nft = INFTPositionManager(nftAddr);
        
        // Check balances
        uint256 stratBal = nft.balanceOf(STRATEGY);
        uint256 gaugeBal = nft.balanceOf(GAUGE);
        
        console.log("Strategy NFT balance:", stratBal);
        console.log("Gauge NFT balance:", gaugeBal);
        
        // List gauge NFTs
        if (gaugeBal > 0) {
            console.log("\nGauge NFT token IDs:");
            for (uint i = 0; i < gaugeBal && i < 10; i++) {
                uint256 tokenId = nft.tokenOfOwnerByIndex(GAUGE, i);
                console.log("  ", tokenId);
            }
        }
    }
}
