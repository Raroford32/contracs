#!/usr/bin/env python3
"""
Deep exploit analysis for SavingAccount and EulerBeats
Looking for:
1. msg.value refund manipulation
2. Reserve/balance calculation flaws
3. First depositor attacks
4. Withdrawal calculation bugs
"""
import json
import subprocess
import re

RPC = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

def rpc_call(method, params):
    payload = {"jsonrpc": "2.0", "method": method, "params": params, "id": 1}
    cmd = ["curl", "-s", "-X", "POST", "-H", "Content-Type: application/json",
           "-d", json.dumps(payload), RPC]
    result = subprocess.run(cmd, capture_output=True, text=True)
    try:
        return json.loads(result.stdout)
    except:
        return None

def eth_call(to, data, from_addr="0x0000000000000000000000000000000000000001", value="0x0"):
    result = rpc_call("eth_call", [{"to": to, "data": data, "from": from_addr, "value": value}, "latest"])
    return result

def estimate_gas(to, data, from_addr="0x0000000000000000000000000000000000000001", value="0x0"):
    result = rpc_call("eth_estimateGas", [{"to": to, "data": data, "from": from_addr, "value": value}])
    return result

def get_balance(addr):
    result = rpc_call("eth_getBalance", [addr, "latest"])
    if result and 'result' in result:
        return int(result['result'], 16) / 1e18
    return 0

def get_storage(addr, slot):
    result = rpc_call("eth_getStorageAt", [addr, slot, "latest"])
    if result and 'result' in result:
        return result['result']
    return None

def get_source(addr):
    url = f"https://api.etherscan.io/v2/api?chainid=1&module=contract&action=getsourcecode&address={addr}&apikey={ETHERSCAN_API}"
    result = subprocess.run(["curl", "-s", url], capture_output=True, text=True)
    try:
        data = json.loads(result.stdout)
        if data.get("status") == "1" and data.get("result"):
            return data["result"][0]
    except:
        pass
    return None

def get_code(addr):
    result = rpc_call("eth_getCode", [addr, "latest"])
    if result and 'result' in result:
        return result['result']
    return "0x"

print("=" * 80)
print("SAVING ACCOUNT DEEP EXPLOIT ANALYSIS")
print("=" * 80)

SAVING = "0x6f35a5e6a7301627a090822895e5e7209ed72f77"

print(f"\n[CONTRACT] {SAVING}")
print(f"[BALANCE] {get_balance(SAVING):.4f} ETH")

# Check if it's a proxy
code = get_code(SAVING)
print(f"[CODE LENGTH] {len(code)} chars")

# Check for proxy patterns
if "363d3d373d3d3d363d73" in code.lower():
    print("[!] Contains minimal proxy pattern!")
elif "5c60da1b" in code.lower():  # implementation() selector
    print("[!] Contains EIP-1967 proxy pattern!")

# Get source
source_data = get_source(SAVING)
if source_data:
    src = source_data.get("SourceCode", "")
    contract_name = source_data.get("ContractName", "Unknown")
    print(f"[CONTRACT NAME] {contract_name}")

    # Parse multi-file
    if src.startswith("{{"):
        try:
            src_json = json.loads(src[1:-1])
            sources = src_json.get("sources", {})
            src = "\n".join([v.get("content", "") for v in sources.values()])
        except:
            pass
    elif src.startswith("{"):
        try:
            src_json = json.loads(src)
            sources = src_json.get("sources", {})
            src = "\n".join([v.get("content", "") for v in sources.values()])
        except:
            pass

    print(f"[SOURCE LENGTH] {len(src)} chars")

    # Find the receive() function and fallback
    print("\n[RECEIVE/FALLBACK ANALYSIS]")
    lines = src.split('\n')
    for i, line in enumerate(lines):
        if "receive()" in line or "fallback()" in line:
            print(f"\n  Found at line {i+1}:")
            # Print function body
            for j in range(i, min(i+20, len(lines))):
                print(f"    {j+1}: {lines[j][:80]}")
                if "}" in lines[j] and j > i:
                    break

    # Find withdraw functions
    print("\n[WITHDRAW FUNCTIONS]")
    for i, line in enumerate(lines):
        if re.search(r"function\s+withdraw", line, re.IGNORECASE):
            print(f"\n  Found at line {i+1}:")
            for j in range(i, min(i+30, len(lines))):
                print(f"    {j+1}: {lines[j][:80]}")
                if lines[j].strip() == "}" and j > i + 1:
                    break

    # Find deposit functions
    print("\n[DEPOSIT FUNCTIONS]")
    for i, line in enumerate(lines):
        if re.search(r"function\s+deposit", line, re.IGNORECASE):
            print(f"\n  Found at line {i+1}:")
            for j in range(i, min(i+25, len(lines))):
                print(f"    {j+1}: {lines[j][:80]}")
                if lines[j].strip() == "}" and j > i + 1:
                    break

    # Find send function (potential ETH drain)
    print("\n[SEND FUNCTION]")
    for i, line in enumerate(lines):
        if re.search(r"function\s+send\s*\(", line, re.IGNORECASE):
            print(f"\n  Found at line {i+1}:")
            for j in range(i, min(i+30, len(lines))):
                print(f"    {j+1}: {lines[j][:80]}")
                if lines[j].strip() == "}" and j > i + 1:
                    break

# On-chain state analysis
print("\n" + "=" * 60)
print("[ON-CHAIN STATE]")
print("=" * 60)

# Common function calls
selectors = {
    "owner()": "0x8da5cb5b",
    "paused()": "0x5c975abb",
    "globalConfig()": "0x2cb15864",
    "getBalances()": "0xc84aae17",
}

for name, sel in selectors.items():
    result = eth_call(SAVING, sel)
    if result and result.get('result'):
        r = result['result']
        if len(r) == 66:
            try:
                val = int(r, 16)
                if val < 10**12:
                    print(f"  {name}: {val}")
                else:
                    print(f"  {name}: 0x{r[26:]}")
            except:
                print(f"  {name}: {r[:66]}")
        else:
            print(f"  {name}: {r[:100]}...")

# Check storage
print("\n[STORAGE SLOTS]")
for i in range(10):
    val = get_storage(SAVING, hex(i))
    if val and val != "0x" + "0"*64:
        print(f"  Slot {i}: {val}")

# Test function calls
print("\n" + "=" * 60)
print("[FUNCTION CALL TESTS]")
print("=" * 60)

# Test various selectors with different parameters
test_cases = [
    # (selector, description, from_addr, value)
    ("0xd0e30db0", "deposit()", None, "0xde0b6b3a7640000"),  # 1 ETH
    ("0x2e1a7d4d0000000000000000000000000000000000000000000000000de0b6b3a7640000", "withdraw(1 ETH)", None, "0x0"),
    ("0x3ccfd60b", "withdraw()", None, "0x0"),
    ("0x853828b6", "withdrawAll()", None, "0x0"),
    ("0x4e71d92d", "claim()", None, "0x0"),
    ("0xdb2e21bc", "emergencyWithdraw()", None, "0x0"),
]

for sel, desc, from_addr, value in test_cases:
    if from_addr is None:
        from_addr = "0x0000000000000000000000000000000000000001"
    result = estimate_gas(SAVING, sel, from_addr, value)
    if result:
        if 'result' in result:
            gas = int(result['result'], 16)
            print(f"  [+] {desc} - gas: {gas}")
        elif 'error' in result:
            err = result['error'].get('message', '')[:60]
            print(f"  [-] {desc}: {err}")

# EULER BEATS ANALYSIS
print("\n\n" + "=" * 80)
print("EULER BEATS DEEP EXPLOIT ANALYSIS")
print("=" * 80)

EULER = "0x8754f54074400ce745a7ceddc928fb1b7e985ed6"

print(f"\n[CONTRACT] {EULER}")
print(f"[BALANCE] {get_balance(EULER):.4f} ETH")

source_data = get_source(EULER)
if source_data:
    src = source_data.get("SourceCode", "")
    contract_name = source_data.get("ContractName", "Unknown")
    print(f"[CONTRACT NAME] {contract_name}")

    # Parse multi-file
    if src.startswith("{{"):
        try:
            src_json = json.loads(src[1:-1])
            sources = src_json.get("sources", {})
            src = "\n".join([v.get("content", "") for v in sources.values()])
        except:
            pass

    print(f"[SOURCE LENGTH] {len(src)} chars")

    # Find burnPrint function
    print("\n[BURN PRINT FUNCTION - POTENTIAL EXPLOIT]")
    lines = src.split('\n')
    for i, line in enumerate(lines):
        if "function burnPrint" in line:
            print(f"\n  Found at line {i+1}:")
            for j in range(i, min(i+40, len(lines))):
                print(f"    {j+1}: {lines[j][:80]}")
                if lines[j].strip() == "}" and j > i + 5:
                    break

    # Find _refundSender
    print("\n[_refundSender FUNCTION]")
    for i, line in enumerate(lines):
        if "function _refundSender" in line:
            print(f"\n  Found at line {i+1}:")
            for j in range(i, min(i+20, len(lines))):
                print(f"    {j+1}: {lines[j][:80]}")
                if lines[j].strip() == "}" and j > i + 1:
                    break

    # Find withdraw function
    print("\n[WITHDRAW FUNCTION]")
    for i, line in enumerate(lines):
        if "function withdraw" in line and "external" in line:
            print(f"\n  Found at line {i+1}:")
            for j in range(i, min(i+25, len(lines))):
                print(f"    {j+1}: {lines[j][:80]}")
                if lines[j].strip() == "}" and j > i + 1:
                    break

    # Find getBurnPrice
    print("\n[GET BURN PRICE FUNCTION]")
    for i, line in enumerate(lines):
        if "function getBurnPrice" in line:
            print(f"\n  Found at line {i+1}:")
            for j in range(i, min(i+15, len(lines))):
                print(f"    {j+1}: {lines[j][:80]}")
                if lines[j].strip() == "}" and j > i + 1:
                    break

# On-chain state
print("\n[ON-CHAIN STATE]")

euler_selectors = {
    "owner()": "0x8da5cb5b",
    "reserve()": "0xcd3293de",
    "originalFundsReleased()": "0x72c27b62",
    "PRINT_FUNDS_PERCENTAGE()": "0x2a3b5e22",
}

for name, sel in euler_selectors.items():
    result = eth_call(EULER, sel)
    if result and result.get('result'):
        r = result['result']
        try:
            val = int(r, 16)
            if val < 10**22:
                print(f"  {name}: {val} ({val/1e18:.4f} ETH)" if val > 10**15 else f"  {name}: {val}")
            else:
                print(f"  {name}: {r}")
        except:
            print(f"  {name}: {r[:66]}")

# Test burn price for different token IDs
print("\n[BURN PRICE FOR DIFFERENT TOKENS]")
for token_id in [0, 1, 2, 3, 10, 27]:
    # getBurnPrice(uint256)
    sel = "0x4e75f60d" + hex(token_id)[2:].zfill(64)
    result = eth_call(EULER, sel)
    if result and result.get('result') and result['result'] != "0x":
        try:
            price = int(result['result'], 16)
            print(f"  Token {token_id}: {price} wei ({price/1e18:.4f} ETH)")
        except:
            print(f"  Token {token_id}: {result['result']}")

# Test minting prices
print("\n[PRINT PRICES FOR DIFFERENT TOKENS]")
for token_id in [0, 1, 2, 3]:
    # getPrintPrice(uint256)
    sel = "0x89c39f18" + hex(token_id)[2:].zfill(64)
    result = eth_call(EULER, sel)
    if result and result.get('result') and result['result'] != "0x":
        try:
            price = int(result['result'], 16)
            print(f"  Token {token_id}: {price} wei ({price/1e18:.4f} ETH)")
        except:
            print(f"  Token {token_id}: {result['result']}")

# Check total supply
print("\n[TOTAL SUPPLIES]")
for token_id in range(28):  # EulerBeats has 27 seeds
    # totalSupply(uint256)
    sel = "0xbd85b039" + hex(token_id)[2:].zfill(64)
    result = eth_call(EULER, sel)
    if result and result.get('result') and result['result'] != "0x":
        try:
            supply = int(result['result'], 16)
            if supply > 0:
                # Also get burn price
                burn_sel = "0x4e75f60d" + hex(token_id)[2:].zfill(64)
                burn_result = eth_call(EULER, burn_sel)
                burn_price = 0
                if burn_result and burn_result.get('result'):
                    try:
                        burn_price = int(burn_result['result'], 16)
                    except:
                        pass
                print(f"  Token {token_id}: supply={supply}, burnPrice={burn_price/1e18:.4f} ETH")
        except:
            pass

print("\n" + "=" * 80)
print("ANALYSIS COMPLETE")
print("=" * 80)
