#!/usr/bin/env python3
"""
Analyze contracts with expired time locks
Focus on finding timelocks where the lock period has passed
"""
import json
import subprocess
import re
import time

RPC = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

def rpc_call(method, params):
    payload = {"jsonrpc": "2.0", "method": method, "params": params, "id": 1}
    cmd = ["curl", "-s", "-X", "POST", "-H", "Content-Type: application/json",
           "-d", json.dumps(payload), RPC]
    result = subprocess.run(cmd, capture_output=True, text=True)
    try:
        return json.loads(result.stdout)
    except:
        return None

def eth_call(to, data, from_addr="0x0000000000000000000000000000000000000001", value="0x0"):
    result = rpc_call("eth_call", [{"to": to, "data": data, "from": from_addr, "value": value}, "latest"])
    return result

def estimate_gas(to, data, from_addr="0x0000000000000000000000000000000000000001", value="0x0"):
    result = rpc_call("eth_estimateGas", [{"to": to, "data": data, "from": from_addr, "value": value}])
    return result

def get_balance(addr):
    result = rpc_call("eth_getBalance", [addr, "latest"])
    if result and 'result' in result:
        return int(result['result'], 16) / 1e18
    return 0

def get_storage(addr, slot):
    result = rpc_call("eth_getStorageAt", [addr, slot, "latest"])
    if result and 'result' in result:
        return result['result']
    return None

def get_code(addr):
    result = rpc_call("eth_getCode", [addr, "latest"])
    if result and 'result' in result:
        return result['result']
    return "0x"

def get_source(addr):
    url = f"https://api.etherscan.io/v2/api?chainid=1&module=contract&action=getsourcecode&address={addr}&apikey={ETHERSCAN_API}"
    result = subprocess.run(["curl", "-s", url], capture_output=True, text=True)
    try:
        data = json.loads(result.stdout)
        if data.get("status") == "1" and data.get("result"):
            return data["result"][0]
    except:
        pass
    return None

def get_block_number():
    result = rpc_call("eth_blockNumber", [])
    if result and 'result' in result:
        return int(result['result'], 16)
    return 0

print("=" * 80)
print("EXPIRED TIMELOCK SCANNER")
print("=" * 80)

# Load contracts
with open("contracts.txt", "r") as f:
    contracts = [line.strip() for line in f if line.strip().startswith("0x")]

current_time = int(time.time())
current_block = get_block_number()
print(f"Current time: {current_time}")
print(f"Current block: {current_block}")

# Common timelock selectors
timelock_selectors = {
    "unlockTime()": "0x251c1aa3",
    "lockTime()": "0x0d668087",
    "releaseTime()": "0xb91d4001",
    "endTime()": "0x3197cbb6",
    "deadline()": "0x29dcb0cf",
    "lockedUntil()": "0x8e530f00",
    "lockEnd()": "0x3c607c19",
    "vestingEnd()": "0x6bc82b5f",
    "eta()": "0x32e91fce",
}

release_selectors = {
    "release()": "0x86d1a69f",
    "unlock()": "0xa69df4b5",
    "withdraw()": "0x3ccfd60b",
    "claim()": "0x4e71d92d",
    "execute()": "0x61461954",
}

expired_locks = []

print(f"\nScanning {len(contracts)} contracts for timelocks...")

for i, addr in enumerate(contracts):
    if i % 100 == 0:
        print(f"Progress: {i}/{len(contracts)}")

    balance = get_balance(addr)
    if balance < 10:  # Focus on 10+ ETH
        continue

    # Check for timelock patterns
    for name, sel in timelock_selectors.items():
        result = eth_call(addr, sel)
        if result and result.get('result') and result['result'] != "0x":
            try:
                val = int(result['result'], 16)
                # Check if it's a reasonable timestamp (2015-2030)
                if 1420070400 < val < 1893456000:
                    time_diff = current_time - val
                    days_passed = time_diff / 86400

                    if days_passed > 0:  # Lock has expired
                        expired_locks.append({
                            "address": addr,
                            "balance": balance,
                            "lock_type": name,
                            "unlock_time": val,
                            "days_expired": days_passed
                        })
                        print(f"\n[EXPIRED LOCK] {addr[:20]}...")
                        print(f"  Balance: {balance:.2f} ETH")
                        print(f"  {name}: {val} (expired {days_passed:.0f} days ago)")
                        break
            except:
                pass

    time.sleep(0.15)

print("\n" + "=" * 80)
print(f"FOUND {len(expired_locks)} EXPIRED LOCKS")
print("=" * 80)

# Deep analysis of each expired lock
for lock in sorted(expired_locks, key=lambda x: -x['balance'])[:10]:
    addr = lock['address']
    print(f"\n{'='*70}")
    print(f"[DEEP ANALYSIS] {addr}")
    print(f"Balance: {lock['balance']:.4f} ETH | Expired: {lock['days_expired']:.0f} days")
    print("=" * 70)

    # Get source
    source_data = get_source(addr)
    if source_data:
        src = source_data.get("SourceCode", "")
        contract_name = source_data.get("ContractName", "Unknown")
        print(f"Contract: {contract_name}")

        if src.startswith("{{"):
            try:
                src_json = json.loads(src[1:-1])
                sources = src_json.get("sources", {})
                src = "\n".join([v.get("content", "") for v in sources.values()])
            except:
                pass

        # Look for release/unlock functions
        print("\n[RELEASE FUNCTIONS IN SOURCE]")
        lines = src.split('\n')
        for i, line in enumerate(lines):
            if re.search(r"function\s+(release|unlock|withdraw|claim|execute)", line, re.IGNORECASE):
                print(f"  Line {i+1}: {line.strip()[:70]}")

    # Test release functions
    print("\n[TESTING RELEASE FUNCTIONS]")
    for func_name, sel in release_selectors.items():
        result = estimate_gas(addr, sel)
        if result:
            if 'result' in result:
                gas = int(result['result'], 16)
                if gas > 21000 and gas < 500000:
                    print(f"  [+] {func_name} CALLABLE! Gas: {gas}")

                    # Try calling it
                    call_result = eth_call(addr, sel)
                    if call_result:
                        print(f"      Result: {call_result}")
            elif 'error' in result:
                err = result['error'].get('message', '')[:50]
                print(f"  [-] {func_name}: {err}")

    # Check beneficiary
    beneficiary_selectors = [
        ("beneficiary()", "0x38af3eed"),
        ("owner()", "0x8da5cb5b"),
        ("recipient()", "0x66d003ac"),
    ]

    print("\n[BENEFICIARY CHECK]")
    for name, sel in beneficiary_selectors:
        result = eth_call(addr, sel)
        if result and result.get('result') and result['result'] != "0x":
            addr_val = "0x" + result['result'][26:]
            if addr_val != "0x0000000000000000000000000000000000000000":
                print(f"  {name}: {addr_val}")

                # Check if beneficiary is EOA or contract
                code = get_code(addr_val)
                if code == "0x" or len(code) < 4:
                    print(f"    -> EOA (accessible)")
                else:
                    print(f"    -> Contract (check if accessible)")

    time.sleep(0.5)

print("\n" + "=" * 80)
print("ANALYSIS COMPLETE")
print("=" * 80)
