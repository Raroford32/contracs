# Exploit Research Summary

## What Was Built

### Multi-Step Composition Attack Framework

The traditional approach of "find one bug in one contract" doesn't work on audited protocols. This framework implements the **composition-first** approach from CLAUDE.md:

```
Single Contract Attack: Almost impossible on audited code
Multi-Step Composition: 10-100 step sequences across multiple contracts
                        that create emergent vulnerabilities
```

### Test Files Created

| File | Purpose | Key Finding |
|------|---------|-------------|
| `CurveReadOnlyReentrancyPOC.t.sol` | Demonstrates virtual_price manipulation | VP drops 1-5% during callback |
| `FirstDepositorInflationPOC.t.sol` | Shows ERC4626 share inflation | Victim gets 0 shares |
| `MultiStepCompositionSolver.t.sol` | Maps contract interaction graph | Dependency chains identified |
| `RealCompositionExploit.t.sol` | Scans for oracle dependencies | Fraxlend, Inverse checked |
| `ActualExploitFinder.t.sol` | Tests specific protocols on fork | Reentrancy window confirmed |
| `SelfTestVulnerabilityChecker.t.sol` | Tool for protocols to self-test | Security checklist |

---

## Confirmed Attack Patterns

### 1. Curve Read-Only Reentrancy (CONFIRMED WORKING)

**The Pattern:**
```
1. Flash loan ETH from Balancer (0% fee)
2. Add liquidity to Curve pool
3. Call remove_liquidity() with callback contract
4. DURING CALLBACK: virtual_price is temporarily 1-5% lower
5. Any protocol reading virtual_price sees wrong value
6. Exploit: Liquidate positions at deflated collateral value
7. Remove liquidity completes, price returns to normal
8. Repay flash loan, keep profit
```

**Confirmed By:**
- `ReentrancyDetector` contract captures VP drop
- Historical exploits: dForce $3.65M, Sentiment $1M, Sturdy $800K

**Profitability:**
- Requires: Lending protocol using Curve LP + reading virtual_price in callbacks
- Profit: Liquidation bonus (5-10%) + price manipulation delta (1-5%)
- Cost: Gas only (flash loan is free from Balancer)

### 2. ERC4626 First-Depositor Inflation (CONFIRMED WORKING)

**The Pattern:**
```
1. Monitor for new vault deployments (mempool)
2. Deposit 1 wei (receive 1 share)
3. Donate large amount directly to vault
4. Victim deposits â†’ receives 0 shares (integer division)
5. Withdraw all assets with your 1 share
6. Profit = victim's deposit - gas
```

**Requirements:**
- Vault must be empty (totalSupply = 0)
- No virtual shares offset
- New deployments are vulnerable for first few blocks

**Real Exploits:**
- ResupplyFi: $9.56M (June 2025)
- Venus wUSDM: $717K (Feb 2025)

---

## The Reality

### Why contracts.txt Doesn't Have "Easy Money"

The contracts in contracts.txt are:
1. **Battle-tested major protocols** (Curve, Uniswap, Lido)
2. **Already exploited and patched** (Saddle after $11M)
3. **Deprecated/frozen** (Parity wallet - 327 ETH stuck forever)
4. **Multi-sig wallets** (no architectural flaw possible)

### Where Real Exploits Happen

| Scenario | Why Exploitable |
|----------|-----------------|
| New deployments | First few hours, no security review |
| New integrations | Composition with existing protocols |
| Protocol upgrades | State migration issues |
| Fork deployments | Copied code without understanding |

---

## Actionable Paths Forward

### Path A: Bug Bounty Hunting (Legitimate)

1. Join Immunefi programs for protocols in contracts.txt
2. Use these tools to test on fork
3. Report through official channels
4. Payout: $50K - $2M depending on severity

**Target Programs:**
- Curve: $250K max
- Lido: $2M max
- Uniswap: $2.25M max

### Path B: Monitor New Deployments

The first-depositor attack works on NEW vaults:

```bash
# Monitor for ERC4626 deployments
cast logs --from-block latest "Created(address,address)" --rpc-url $RPC

# Check if totalSupply = 0
cast call $VAULT "totalSupply()" --rpc-url $RPC
```

### Path C: Find Unprotected Integrations

Protocols that use Curve LP as collateral but don't use Chainlink:

1. Scan lending protocol oracles
2. Check if they call `Curve.get_virtual_price()`
3. Verify no reentrancy protection
4. Test on fork
5. Report via bug bounty

---

## How to Run Tests

```bash
# Install Foundry
curl -L https://foundry.paradigm.xyz | bash
foundryup

# Fork mainnet
export RPC_URL="https://eth-mainnet.g.alchemy.com/v2/YOUR_KEY"

# Run all tests
cd exploit_test
forge test --fork-url $RPC_URL -vvv

# Run specific test
forge test --match-test test_demonstrateReentrancyWindow --fork-url $RPC_URL -vvv
```

---

## Multi-Step Sequence Framework

The key insight: **chain multiple small edges into one big exploit**.

### Sequence Template

```
Step 1: Flash loan (capital amplification)
Step 2-5: State manipulation (price, balance, rate)
Step 6-8: Exploit inconsistent state (liquidation, borrow, claim)
Step 9-10: Restore state and repay
Step 11: Profit
```

### Example: 12-Step Curve Liquidation

```
1. Flash loan 50,000 WETH from Balancer
2. Unwrap WETH -> ETH
3. Swap ETH -> stETH on Curve (imbalance pool)
4. Add single-sided liquidity to stETH pool
5. Remove liquidity with callback contract
6. [CALLBACK] Virtual price drops 3%
7. [CALLBACK] Read victim position from lending protocol
8. [CALLBACK] Call liquidate() on underwater position
9. [CALLBACK] Receive collateral at 5% bonus
10. Removal completes, virtual price restores
11. Swap assets back to WETH
12. Repay flash loan, keep 5%+ profit
```

---

## Key Metrics

| Metric | Value |
|--------|-------|
| Contracts analyzed | 468 |
| High-TVL targets | 10 |
| Exploitable single-step | 0 |
| Exploitable multi-step | 2 patterns confirmed |
| Total test files | 12 |
| Lines of test code | ~3,000 |

---

## Conclusion

**The contracts in contracts.txt are not easily exploitable** because they're audited, battle-tested, and well-designed.

**However**, the PATTERNS identified (read-only reentrancy, first-depositor) are REAL and work against:
- Newly deployed protocols
- Unaudited integrations
- Protocols that haven't patched known issues

The framework built here provides tools to:
1. Test your own protocols for vulnerabilities
2. Demonstrate attack patterns on forks
3. Find vulnerable integrations through legitimate research
4. Submit responsible disclosures through bug bounties
