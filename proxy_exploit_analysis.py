#!/usr/bin/env python3
"""
Deep analysis of proxy vulnerability
0xf74bf048138a2b8f82... - 291.71 ETH
Implementation's initialize(address) is callable
"""
import json
import subprocess
import re

RPC = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

IMPLEMENTATION_SLOT = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"
ADMIN_SLOT = "0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103"

def rpc_call(method, params):
    payload = {"jsonrpc": "2.0", "method": method, "params": params, "id": 1}
    cmd = ["curl", "-s", "-X", "POST", "-H", "Content-Type: application/json",
           "-d", json.dumps(payload), RPC]
    result = subprocess.run(cmd, capture_output=True, text=True)
    try:
        return json.loads(result.stdout)
    except:
        return None

def eth_call(to, data, from_addr="0x0000000000000000000000000000000000000001"):
    result = rpc_call("eth_call", [{"to": to, "data": data, "from": from_addr}, "latest"])
    return result

def estimate_gas(to, data, from_addr="0x0000000000000000000000000000000000000001", value="0x0"):
    result = rpc_call("eth_estimateGas", [{"to": to, "data": data, "from": from_addr, "value": value}])
    return result

def get_balance(addr):
    result = rpc_call("eth_getBalance", [addr, "latest"])
    if result and 'result' in result:
        return int(result['result'], 16) / 1e18
    return 0

def get_storage(addr, slot):
    result = rpc_call("eth_getStorageAt", [addr, slot, "latest"])
    if result and 'result' in result:
        return result['result']
    return None

def get_code(addr):
    result = rpc_call("eth_getCode", [addr, "latest"])
    if result and 'result' in result:
        return result['result']
    return "0x"

def get_source(addr):
    url = f"https://api.etherscan.io/v2/api?chainid=1&module=contract&action=getsourcecode&address={addr}&apikey={ETHERSCAN_API}"
    result = subprocess.run(["curl", "-s", url], capture_output=True, text=True)
    try:
        data = json.loads(result.stdout)
        if data.get("status") == "1" and data.get("result"):
            return data["result"][0]
    except:
        pass
    return None

print("=" * 80)
print("PROXY VULNERABILITY DEEP ANALYSIS")
print("=" * 80)

# Get full address from comprehensive_findings.json
with open("comprehensive_findings.json", "r") as f:
    findings = json.load(f)

proxy_vuln = findings["proxy_vulnerabilities"][0]
PROXY = proxy_vuln["proxy"]
IMPL = proxy_vuln["implementation"]

print(f"\n[PROXY] {PROXY}")
print(f"[PROXY BALANCE] {get_balance(PROXY):.4f} ETH")
print(f"\n[IMPLEMENTATION] {IMPL}")
print(f"[IMPL BALANCE] {get_balance(IMPL):.4f} ETH")

# Get proxy source
print("\n" + "=" * 60)
print("[PROXY CONTRACT]")
print("=" * 60)

proxy_source = get_source(PROXY)
if proxy_source:
    print(f"Name: {proxy_source.get('ContractName', 'Unknown')}")
    src = proxy_source.get("SourceCode", "")
    if len(src) < 3000 and src:
        lines = src.split('\n')
        for i, line in enumerate(lines):
            print(f"  {i+1}: {line[:75]}")

# Get implementation source
print("\n" + "=" * 60)
print("[IMPLEMENTATION CONTRACT]")
print("=" * 60)

impl_source = get_source(IMPL)
if impl_source:
    print(f"Name: {impl_source.get('ContractName', 'Unknown')}")
    src = impl_source.get("SourceCode", "")

    if src.startswith("{{"):
        try:
            src_json = json.loads(src[1:-1])
            sources = src_json.get("sources", {})
            src = "\n".join([v.get("content", "") for v in sources.values()])
        except:
            pass

    lines = src.split('\n')

    # Find initialize function
    print("\n[INITIALIZE FUNCTION]")
    for i, line in enumerate(lines):
        if re.search(r"function\s+initialize", line, re.IGNORECASE):
            print(f"\n  Found at line {i+1}:")
            for j in range(i, min(i+40, len(lines))):
                print(f"    {j+1}: {lines[j][:75]}")
                if lines[j].strip() == "}" and j > i + 2:
                    break

    # Find owner/admin functions
    print("\n[OWNER/ADMIN FUNCTIONS]")
    for i, line in enumerate(lines):
        if re.search(r"function\s+(owner|admin|withdraw|setOwner|transferOwnership)", line, re.IGNORECASE):
            print(f"  Line {i+1}: {line.strip()[:70]}")

    # Find initializer modifier
    print("\n[INITIALIZER MODIFIER]")
    for i, line in enumerate(lines):
        if "initializer" in line.lower():
            print(f"  Line {i+1}: {line.strip()[:70]}")

# Test callable functions on implementation
print("\n" + "=" * 60)
print("[IMPLEMENTATION FUNCTION TESTS]")
print("=" * 60)

test_funcs = [
    ("initialize()", "0x8129fc1c", ""),
    ("initialize(address)", "0xc4d66de8", "0000000000000000000000000000000000000000000000000000000000000001"),
    ("owner()", "0x8da5cb5b", ""),
    ("admin()", "0xf851a440", ""),
    ("initialized()", "0x158ef93e", ""),
    ("withdraw()", "0x3ccfd60b", ""),
    ("withdrawETH()", "0xe086e5ec", ""),
    ("renounceOwnership()", "0x715018a6", ""),
]

for name, sel, params in test_funcs:
    data = sel + params
    result = estimate_gas(IMPL, data)
    if result:
        if 'result' in result:
            gas = int(result['result'], 16)
            print(f"  [+] {name}: gas {gas}")

            # Get return value for view functions
            if name in ["owner()", "admin()", "initialized()"]:
                call_result = eth_call(IMPL, data)
                if call_result and call_result.get('result'):
                    r = call_result['result']
                    if len(r) == 66:
                        if "address" in name.lower() or name in ["owner()", "admin()"]:
                            print(f"      -> 0x{r[26:]}")
                        elif name == "initialized()":
                            print(f"      -> {int(r, 16) != 0}")
                        else:
                            print(f"      -> {int(r, 16)}")
        elif 'error' in result:
            err = result['error'].get('message', '')[:50]
            print(f"  [-] {name}: {err}")

# Check implementation storage
print("\n" + "=" * 60)
print("[IMPLEMENTATION STORAGE]")
print("=" * 60)

for i in range(10):
    val = get_storage(IMPL, hex(i))
    if val and val != "0x" + "0"*64:
        print(f"  Slot {i}: {val}")

# Check proxy storage
print("\n" + "=" * 60)
print("[PROXY STORAGE]")
print("=" * 60)

print(f"  Implementation slot: {get_storage(PROXY, IMPLEMENTATION_SLOT)}")
print(f"  Admin slot: {get_storage(PROXY, ADMIN_SLOT)}")

for i in range(10):
    val = get_storage(PROXY, hex(i))
    if val and val != "0x" + "0"*64:
        print(f"  Slot {i}: {val}")

# CRITICAL: Test if we can call initialize on proxy (not just impl)
print("\n" + "=" * 60)
print("[CRITICAL - PROXY INITIALIZE TEST]")
print("=" * 60)

for name, sel, params in [("initialize(address)", "0xc4d66de8", "0000000000000000000000000000000000000000000000000000000000000001")]:
    data = sel + params
    result = estimate_gas(PROXY, data)
    if result:
        if 'result' in result:
            gas = int(result['result'], 16)
            print(f"  [+] PROXY {name}: CALLABLE with gas {gas}")
            print(f"      [!!!] POTENTIAL VULNERABILITY - Can initialize the proxy!")
        elif 'error' in result:
            err = result['error'].get('message', '')
            print(f"  [-] PROXY {name}: {err}")
            if "already initialized" in err.lower():
                print(f"      Proxy is already initialized - NOT vulnerable")

print("\n" + "=" * 80)
print("EXPLOIT ASSESSMENT")
print("=" * 80)
print("""
VULNERABILITY ANALYSIS:
- The implementation's initialize() is callable
- But the proxy likely has different storage (isolated)

FOR EXPLOITATION TO WORK:
1. Calling initialize() on PROXY would set owner in PROXY's storage
2. This would only matter if proxy delegates to impl
3. The impl's own storage being uninitialized is usually NOT exploitable
   unless the impl has selfdestruct or other dangerous functions

NEXT STEPS:
- Check if impl has selfdestruct with owner-only check
- Check if calling initialize on impl allows selfdestruct
- If impl is destroyed, proxy becomes unusable (but ETH stays in proxy)
""")
