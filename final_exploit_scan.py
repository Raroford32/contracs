#!/usr/bin/env python3
"""
Final comprehensive exploit scan
Focus on:
1. Uninitialized proxies
2. Price arbitrage (DEX price vs oracle)
3. Missing access control
4. First depositor opportunities
"""
import json
import subprocess
import re
import time

RPC = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

IMPLEMENTATION_SLOT = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"
ADMIN_SLOT = "0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103"

def rpc_call(method, params):
    payload = {"jsonrpc": "2.0", "method": method, "params": params, "id": 1}
    cmd = ["curl", "-s", "-X", "POST", "-H", "Content-Type: application/json",
           "-d", json.dumps(payload), RPC]
    result = subprocess.run(cmd, capture_output=True, text=True)
    try:
        return json.loads(result.stdout)
    except:
        return None

def eth_call(to, data, from_addr="0x0000000000000000000000000000000000000001", value="0x0"):
    result = rpc_call("eth_call", [{"to": to, "data": data, "from": from_addr, "value": value}, "latest"])
    return result

def estimate_gas(to, data, from_addr="0x0000000000000000000000000000000000000001", value="0x0"):
    result = rpc_call("eth_estimateGas", [{"to": to, "data": data, "from": from_addr, "value": value}])
    return result

def get_balance(addr):
    result = rpc_call("eth_getBalance", [addr, "latest"])
    if result and 'result' in result:
        return int(result['result'], 16) / 1e18
    return 0

def get_storage(addr, slot):
    result = rpc_call("eth_getStorageAt", [addr, slot, "latest"])
    if result and 'result' in result:
        return result['result']
    return None

def get_code(addr):
    result = rpc_call("eth_getCode", [addr, "latest"])
    if result and 'result' in result:
        return result['result']
    return "0x"

def get_source(addr):
    url = f"https://api.etherscan.io/v2/api?chainid=1&module=contract&action=getsourcecode&address={addr}&apikey={ETHERSCAN_API}"
    result = subprocess.run(["curl", "-s", url], capture_output=True, text=True)
    try:
        data = json.loads(result.stdout)
        if data.get("status") == "1" and data.get("result"):
            return data["result"][0]
    except:
        pass
    return None

# Load contracts
with open("contracts.txt", "r") as f:
    contracts = [line.strip() for line in f if line.strip().startswith("0x")]

print("=" * 80)
print("FINAL COMPREHENSIVE EXPLOIT SCAN")
print("=" * 80)

high_priority = []
proxy_findings = []
first_depositor_findings = []

for i, addr in enumerate(contracts):
    if i % 50 == 0:
        print(f"Scanning {i}/{len(contracts)}...")

    balance = get_balance(addr)
    if balance < 50:  # Focus on 50+ ETH
        continue

    # CHECK 1: Proxy patterns
    impl_storage = get_storage(addr, IMPLEMENTATION_SLOT)
    if impl_storage and impl_storage != "0x" + "0"*64:
        impl_addr = "0x" + impl_storage[26:]
        if impl_addr != "0x0000000000000000000000000000000000000000":
            # This is a proxy - check if implementation is initialized
            # Try calling initialize on IMPLEMENTATION directly
            init_selectors = [
                ("initialize()", "0x8129fc1c"),
                ("initialize(address)", "0xc4d66de8"),
            ]

            for func, sel in init_selectors:
                data = sel
                if "address" in func:
                    data = sel + "0000000000000000000000000000000000000000000000000000000000000001"

                # Test on implementation directly
                result = estimate_gas(impl_addr, data)
                if result and 'result' in result:
                    gas = int(result['result'], 16)
                    if gas < 500000:
                        proxy_findings.append({
                            "proxy": addr,
                            "impl": impl_addr,
                            "balance": balance,
                            "callable_init": func,
                            "gas": gas
                        })
                        print(f"\n[PROXY!] {addr[:12]}... - {balance:.1f} ETH")
                        print(f"  Implementation: {impl_addr}")
                        print(f"  {func} callable on impl with gas: {gas}")
                        break

    time.sleep(0.2)

    # CHECK 2: First depositor (totalSupply = 0)
    ts_result = eth_call(addr, "0x18160ddd")  # totalSupply()
    if ts_result and ts_result.get('result') and ts_result['result'] != "0x":
        try:
            total_supply = int(ts_result['result'], 16)
            if total_supply == 0:
                # Empty supply - check if deposit/mint is possible
                mint_result = estimate_gas(addr, "0x1249c58b", value="0xde0b6b3a7640000")
                deposit_result = estimate_gas(addr, "0xd0e30db0", value="0xde0b6b3a7640000")

                if (mint_result and 'result' in mint_result) or (deposit_result and 'result' in deposit_result):
                    first_depositor_findings.append({
                        "address": addr,
                        "balance": balance,
                        "total_supply": 0,
                        "mint_callable": mint_result and 'result' in mint_result,
                        "deposit_callable": deposit_result and 'result' in deposit_result
                    })
                    print(f"\n[FIRST DEPOSITOR!] {addr[:12]}... - {balance:.1f} ETH")
                    print(f"  Total Supply: 0")
                    print(f"  Mint callable: {mint_result and 'result' in mint_result}")
                    print(f"  Deposit callable: {deposit_result and 'result' in deposit_result}")
        except:
            pass

    # CHECK 3: Unprotected admin functions
    admin_funcs = [
        ("setOwner(address)", "0x13af4035"),
        ("transferOwnership(address)", "0xf2fde38b"),
        ("changeAdmin(address)", "0x8f283970"),
    ]

    for func, sel in admin_funcs:
        data = sel + "0000000000000000000000000000000000000000000000000000000000000001"
        result = estimate_gas(addr, data)
        if result and 'result' in result:
            gas = int(result['result'], 16)
            if gas < 100000 and gas > 21000:  # Not just echo, but also not too complex
                # Verify it's not protected
                high_priority.append({
                    "address": addr,
                    "balance": balance,
                    "callable_func": func,
                    "gas": gas,
                    "type": "ADMIN_CALLABLE"
                })
                print(f"\n[ADMIN!] {addr[:12]}... - {balance:.1f} ETH")
                print(f"  {func} callable with gas: {gas}")
                break

# Summary
print("\n" + "=" * 80)
print("FINAL SCAN SUMMARY")
print("=" * 80)

print(f"\n[PROXY FINDINGS] {len(proxy_findings)}")
for f in proxy_findings[:10]:
    print(f"  {f['proxy'][:20]}... | {f['balance']:.1f} ETH | impl init: {f['callable_init']}")

print(f"\n[FIRST DEPOSITOR FINDINGS] {len(first_depositor_findings)}")
for f in first_depositor_findings[:10]:
    print(f"  {f['address'][:20]}... | {f['balance']:.1f} ETH")

print(f"\n[ADMIN CALLABLE FINDINGS] {len(high_priority)}")
for f in high_priority[:10]:
    print(f"  {f['address'][:20]}... | {f['balance']:.1f} ETH | {f['callable_func']}")

# Save all findings
all_findings = {
    "proxy_findings": proxy_findings,
    "first_depositor_findings": first_depositor_findings,
    "admin_callable_findings": high_priority
}

with open("final_exploit_findings.json", "w") as f:
    json.dump(all_findings, f, indent=2)

print("\n[*] Findings saved to final_exploit_findings.json")
