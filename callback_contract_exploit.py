#!/usr/bin/env python3
"""
Deep analysis of 0x00000000a8f806c754549943b6550a2594c9a126
- 138 ETH
- Multiple callbacks callable
"""
import json
import subprocess
import re

RPC = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

def rpc_call(method, params):
    payload = {"jsonrpc": "2.0", "method": method, "params": params, "id": 1}
    cmd = ["curl", "-s", "-X", "POST", "-H", "Content-Type: application/json",
           "-d", json.dumps(payload), RPC]
    result = subprocess.run(cmd, capture_output=True, text=True)
    try:
        return json.loads(result.stdout)
    except:
        return None

def eth_call(to, data, from_addr="0x0000000000000000000000000000000000000001", value="0x0"):
    result = rpc_call("eth_call", [{"to": to, "data": data, "from": from_addr, "value": value}, "latest"])
    return result

def estimate_gas(to, data, from_addr="0x0000000000000000000000000000000000000001", value="0x0"):
    result = rpc_call("eth_estimateGas", [{"to": to, "data": data, "from": from_addr, "value": value}])
    return result

def get_balance(addr):
    result = rpc_call("eth_getBalance", [addr, "latest"])
    if result and 'result' in result:
        return int(result['result'], 16) / 1e18
    return 0

def get_storage(addr, slot):
    result = rpc_call("eth_getStorageAt", [addr, slot, "latest"])
    if result and 'result' in result:
        return result['result']
    return None

def get_code(addr):
    result = rpc_call("eth_getCode", [addr, "latest"])
    if result and 'result' in result:
        return result['result']
    return "0x"

def get_source(addr):
    url = f"https://api.etherscan.io/v2/api?chainid=1&module=contract&action=getsourcecode&address={addr}&apikey={ETHERSCAN_API}"
    result = subprocess.run(["curl", "-s", url], capture_output=True, text=True)
    try:
        data = json.loads(result.stdout)
        if data.get("status") == "1" and data.get("result"):
            return data["result"][0]
    except:
        pass
    return None

print("=" * 80)
print("CALLBACK CONTRACT DEEP ANALYSIS")
print("=" * 80)

TARGET = "0x00000000a8f806c754549943b6550a2594c9a126"

print(f"\n[CONTRACT] {TARGET}")
print(f"[BALANCE] {get_balance(TARGET):.4f} ETH")

# Get bytecode
code = get_code(TARGET)
print(f"[BYTECODE LENGTH] {len(code)} chars")

# Check for Parity pattern
print("\n[PARITY CHECK]")
test_selectors = [
    ("0x8da5cb5b", "owner()"),
    ("0x12345678", "random1()"),
    ("0x87654321", "random2()"),
    ("0xabcdef99", "random3()"),
]

gas_vals = []
for sel, name in test_selectors:
    result = estimate_gas(TARGET, sel)
    if result and 'result' in result:
        gas = int(result['result'], 16)
        gas_vals.append(gas)
        print(f"  {name}: {gas}")
    elif result and 'error' in result:
        print(f"  {name}: ERROR")

positive = [g for g in gas_vals if g > 0]
if len(positive) >= 2:
    variance = max(positive) - min(positive)
    avg = sum(positive) / len(positive)
    pct = (variance / avg * 100) if avg > 0 else 0
    print(f"  Variance: {pct:.1f}%")
    if pct < 15:
        print("  [!] PARITY WALLET PATTERN - All functions have same gas")

# Get source code
source_data = get_source(TARGET)
if source_data:
    src = source_data.get("SourceCode", "")
    contract_name = source_data.get("ContractName", "")
    abi = source_data.get("ABI", "")
    print(f"\n[CONTRACT NAME] {contract_name if contract_name else 'Not verified'}")

    if src:
        if src.startswith("{{"):
            try:
                src_json = json.loads(src[1:-1])
                sources = src_json.get("sources", {})
                src = "\n".join([v.get("content", "") for v in sources.values()])
            except:
                pass

        print(f"[SOURCE LENGTH] {len(src)} chars")

        # Look for key functions
        lines = src.split('\n')

        # Find fallback/receive
        print("\n[FALLBACK/RECEIVE]")
        for i, line in enumerate(lines):
            if "fallback" in line.lower() or "receive" in line.lower():
                if "function" in line.lower() or "()" in line:
                    print(f"  Line {i+1}: {line.strip()[:70]}")

        # Find any function that handles ETH
        print("\n[ETH HANDLING FUNCTIONS]")
        for i, line in enumerate(lines):
            if re.search(r"function\s+\w+.*payable", line, re.IGNORECASE):
                print(f"  Line {i+1}: {line.strip()[:70]}")

        # ABI if available
        if abi:
            print("\n[ABI FUNCTIONS]")
            try:
                abi_json = json.loads(abi)
                for item in abi_json[:20]:  # First 20
                    if item.get("type") == "function":
                        name = item.get("name", "")
                        inputs = item.get("inputs", [])
                        stateMutability = item.get("stateMutability", "")
                        input_types = ",".join([i.get("type", "") for i in inputs])
                        print(f"  {name}({input_types}) - {stateMutability}")
            except:
                pass

else:
    print("\n[!] No source code available - contract not verified")

# Storage analysis
print("\n[STORAGE ANALYSIS]")
for i in range(15):
    val = get_storage(TARGET, hex(i))
    if val and val != "0x" + "0"*64:
        print(f"  Slot {i}: {val}")

# Test various functions
print("\n[FUNCTION TESTS]")

tests = [
    ("0x3ccfd60b", "withdraw()"),
    ("0xd0e30db0", "deposit()"),
    ("0x8da5cb5b", "owner()"),
    ("0x13af4035", "setOwner(address)"),
    ("0xf2fde38b", "transferOwnership(address)"),
    ("0x00000000", "fallback"),
]

for sel, name in tests:
    data = sel
    if "address" in name:
        data += "0000000000000000000000000000000000000000000000000000000000000001"

    value = "0x0"
    if "deposit" in name:
        value = "0xde0b6b3a7640000"  # 1 ETH

    result = estimate_gas(TARGET, data, value=value)
    if result:
        if 'result' in result:
            gas = int(result['result'], 16)
            print(f"  [+] {name}: gas {gas}")
        elif 'error' in result:
            err = result['error'].get('message', '')[:50]
            print(f"  [-] {name}: {err}")

# Check if it's a proxy
print("\n[PROXY CHECK]")
IMPLEMENTATION_SLOT = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"
impl = get_storage(TARGET, IMPLEMENTATION_SLOT)
if impl and impl != "0x" + "0"*64:
    impl_addr = "0x" + impl[26:]
    print(f"  Implementation (EIP-1967): {impl_addr}")

    # Get impl source
    impl_source = get_source(impl_addr)
    if impl_source:
        print(f"  Implementation contract: {impl_source.get('ContractName', 'Unknown')}")

print("\n" + "=" * 80)
