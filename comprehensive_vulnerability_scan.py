#!/usr/bin/env python3
"""
CLAUDE.md Comprehensive Vulnerability Scan
Scans ALL contracts for kernel contradictions and composition attacks
"""
import json
import subprocess
import time
import sys

RPC = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

def rpc_call(method, params):
    payload = {"jsonrpc": "2.0", "method": method, "params": params, "id": 1}
    cmd = ["curl", "-s", "-X", "POST", "-H", "Content-Type: application/json",
           "-d", json.dumps(payload), RPC]
    result = subprocess.run(cmd, capture_output=True, text=True)
    try:
        return json.loads(result.stdout)
    except:
        return None

def get_balance(addr):
    result = rpc_call("eth_getBalance", [addr, "latest"])
    if result and 'result' in result:
        return int(result['result'], 16) / 1e18
    return 0

def get_code(addr):
    result = rpc_call("eth_getCode", [addr, "latest"])
    if result and 'result' in result:
        return result['result']
    return "0x"

def get_source(addr):
    url = f"https://api.etherscan.io/v2/api?chainid=1&module=contract&action=getsourcecode&address={addr}&apikey={ETHERSCAN_API}"
    result = subprocess.run(["curl", "-s", url], capture_output=True, text=True)
    try:
        data = json.loads(result.stdout)
        if data.get("status") == "1" and data.get("result"):
            return data["result"][0]
        return None
    except:
        return None

# Load contracts
with open("contracts.txt", "r") as f:
    contracts = [line.strip() for line in f if line.strip().startswith("0x")]

print("=" * 80)
print("CLAUDE.MD COMPREHENSIVE VULNERABILITY SCAN")
print(f"Scanning {len(contracts)} contracts...")
print("=" * 80)

# First pass: Get balances and filter high-value contracts
high_value = []
print("\n[Phase 1] Scanning balances...")
for i, addr in enumerate(contracts):
    if i % 50 == 0:
        print(f"  Scanned {i}/{len(contracts)}...")

    balance = get_balance(addr)
    if balance >= 50:  # 50+ ETH
        high_value.append({"address": addr, "balance": balance})

print(f"\nFound {len(high_value)} contracts with 50+ ETH")

# Sort by balance
high_value.sort(key=lambda x: x['balance'], reverse=True)

# Second pass: Analyze source code for vulnerability patterns
print("\n[Phase 2] Analyzing source code for vulnerabilities...")

vulnerability_findings = []

for i, contract in enumerate(high_value):
    addr = contract['address']
    balance = contract['balance']

    print(f"\n[{i+1}/{len(high_value)}] {addr} ({balance:.2f} ETH)")

    time.sleep(0.25)  # Rate limiting

    source_data = get_source(addr)
    if not source_data:
        print("  No verified source")
        continue

    src = source_data.get("SourceCode", "")
    name = source_data.get("ContractName", "Unknown")
    compiler = source_data.get("CompilerVersion", "")

    if not src:
        print("  Empty source")
        continue

    # Parse multi-file JSON
    if src.startswith("{{"):
        try:
            src_json = json.loads(src[1:-1])
            sources = src_json.get("sources", {})
            src = "\n".join([v.get("content", "") for v in sources.values()])
        except:
            pass
    elif src.startswith("{"):
        try:
            src_json = json.loads(src)
            sources = src_json.get("sources", {})
            src = "\n".join([v.get("content", "") for v in sources.values()])
        except:
            pass

    src_lower = src.lower()

    # === VULNERABILITY DETECTION PER CLAUDE.MD ===

    vulnerabilities = []

    # 1. REENTRANCY VECTORS
    has_call = ".call{" in src or ".call(" in src or ".call.value" in src
    has_transfer = ".transfer(" in src
    has_send = ".send(" in src
    has_guard = "nonReentrant" in src or "ReentrancyGuard" in src or "locked" in src

    if has_call and not has_guard:
        vulnerabilities.append({
            "type": "POTENTIAL_REENTRANCY",
            "detail": "External call without reentrancy guard",
            "severity": "HIGH"
        })

    # 2. ORACLE MANIPULATION
    if "getreserves" in src_lower and "flashloan" not in src_lower:
        vulnerabilities.append({
            "type": "SPOT_PRICE_ORACLE",
            "detail": "Uses Uniswap V2 reserves for price - flash loan manipulatable",
            "severity": "HIGH"
        })

    if "slot0" in src_lower:
        vulnerabilities.append({
            "type": "SPOT_PRICE_V3",
            "detail": "Uses Uniswap V3 slot0 - flash loan manipulatable",
            "severity": "HIGH"
        })

    if "latestrounddata" in src_lower and "updatedat" not in src_lower:
        vulnerabilities.append({
            "type": "STALE_ORACLE",
            "detail": "Chainlink oracle without staleness check",
            "severity": "MEDIUM"
        })

    # 3. FIRST DEPOSITOR / EMPTY STATE
    if "totalsupply" in src_lower and "totalsupply == 0" not in src_lower:
        if "deposit" in src_lower or "mint" in src_lower:
            if "converttoshares" in src_lower or "converttoassets" in src_lower:
                vulnerabilities.append({
                    "type": "FIRST_DEPOSITOR",
                    "detail": "ERC4626-like vault without totalSupply==0 protection",
                    "severity": "HIGH"
                })

    # 4. UNCHECKED ARITHMETIC (old compilers)
    if "0.4" in compiler or "0.5" in compiler or "0.6" in compiler or "0.7" in compiler:
        if "safemath" not in src_lower and "using safemath" not in src_lower:
            vulnerabilities.append({
                "type": "UNCHECKED_MATH",
                "detail": f"Compiler {compiler} without SafeMath",
                "severity": "MEDIUM"
            })

    # 5. EXTERNAL CALL TARGET CONTROLLABLE
    if "delegatecall" in src_lower:
        vulnerabilities.append({
            "type": "DELEGATECALL",
            "detail": "Uses delegatecall - check if target is controlled",
            "severity": "CRITICAL"
        })

    # 6. FLASH LOAN ATTACK SURFACE
    if "flashloan" in src_lower or "onflashloan" in src_lower or "executeoperation" in src_lower:
        vulnerabilities.append({
            "type": "FLASH_LOAN_ENABLED",
            "detail": "Has flash loan callback - check for composition attacks",
            "severity": "INFO"
        })

    # 7. SIGNATURE REPLAY
    if "ecrecover" in src_lower and "nonce" not in src_lower:
        vulnerabilities.append({
            "type": "SIGNATURE_REPLAY",
            "detail": "Uses ecrecover without nonce - potential replay attack",
            "severity": "HIGH"
        })

    # 8. ARBITRARY EXTERNAL CALL
    if ".call(" in src and "msg.sender" in src:
        # Check if call target is user-controlled
        if "(_to" in src or "(_target" in src or "(_contract" in src:
            vulnerabilities.append({
                "type": "ARBITRARY_CALL",
                "detail": "External call with potentially user-controlled target",
                "severity": "CRITICAL"
            })

    # 9. ACCESS CONTROL ISSUES
    if "tx.origin" in src:
        vulnerabilities.append({
            "type": "TX_ORIGIN_AUTH",
            "detail": "Uses tx.origin for authorization",
            "severity": "MEDIUM"
        })

    # 10. SELFDESTRUCT
    if "selfdestruct" in src_lower or "suicide(" in src_lower:
        if "onlyowner" not in src_lower[:src_lower.find("selfdestruct")+100 if "selfdestruct" in src_lower else 0]:
            vulnerabilities.append({
                "type": "SELFDESTRUCT",
                "detail": "Has selfdestruct - check access control",
                "severity": "HIGH"
            })

    if vulnerabilities:
        finding = {
            "address": addr,
            "name": name,
            "balance": balance,
            "compiler": compiler,
            "vulnerabilities": vulnerabilities
        }
        vulnerability_findings.append(finding)
        print(f"  [FOUND] {name}: {len(vulnerabilities)} potential vulnerabilities")
        for v in vulnerabilities:
            print(f"    - [{v['severity']}] {v['type']}: {v['detail']}")

# Sort by severity and balance
def severity_score(finding):
    score = 0
    for v in finding['vulnerabilities']:
        if v['severity'] == 'CRITICAL':
            score += 100
        elif v['severity'] == 'HIGH':
            score += 10
        elif v['severity'] == 'MEDIUM':
            score += 1
    return score * finding['balance']

vulnerability_findings.sort(key=severity_score, reverse=True)

print("\n" + "=" * 80)
print("TOP PRIORITY TARGETS FOR FORK VERIFICATION")
print("=" * 80)

for i, f in enumerate(vulnerability_findings[:20]):
    print(f"\n{i+1}. {f['name']} ({f['address'][:10]}...)")
    print(f"   Balance: {f['balance']:.2f} ETH | Compiler: {f['compiler']}")
    for v in f['vulnerabilities']:
        print(f"   [{v['severity']}] {v['type']}")

# Save results
with open("vulnerability_scan_results.json", "w") as f:
    json.dump(vulnerability_findings, f, indent=2)

print(f"\n[*] Saved {len(vulnerability_findings)} vulnerability findings")
