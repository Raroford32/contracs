#!/usr/bin/env python3
"""
Analyze contract with callable mint()
0x27a94869341838d5783368a8503fda5fbcd7987c - 84 ETH
"""
import json
import subprocess
import re

RPC = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

IMPLEMENTATION_SLOT = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"

def rpc_call(method, params):
    payload = {"jsonrpc": "2.0", "method": method, "params": params, "id": 1}
    cmd = ["curl", "-s", "-X", "POST", "-H", "Content-Type: application/json",
           "-d", json.dumps(payload), RPC]
    result = subprocess.run(cmd, capture_output=True, text=True)
    try:
        return json.loads(result.stdout)
    except:
        return None

def eth_call(to, data, from_addr="0x0000000000000000000000000000000000000001"):
    result = rpc_call("eth_call", [{"to": to, "data": data, "from": from_addr}, "latest"])
    return result

def estimate_gas(to, data, from_addr="0x0000000000000000000000000000000000000001", value="0x0"):
    result = rpc_call("eth_estimateGas", [{"to": to, "data": data, "from": from_addr, "value": value}])
    return result

def get_balance(addr):
    result = rpc_call("eth_getBalance", [addr, "latest"])
    if result and 'result' in result:
        return int(result['result'], 16) / 1e18
    return 0

def get_storage(addr, slot):
    result = rpc_call("eth_getStorageAt", [addr, slot, "latest"])
    if result and 'result' in result:
        return result['result']
    return None

def get_code(addr):
    result = rpc_call("eth_getCode", [addr, "latest"])
    if result and 'result' in result:
        return result['result']
    return "0x"

def get_source(addr):
    url = f"https://api.etherscan.io/v2/api?chainid=1&module=contract&action=getsourcecode&address={addr}&apikey={ETHERSCAN_API}"
    result = subprocess.run(["curl", "-s", url], capture_output=True, text=True)
    try:
        data = json.loads(result.stdout)
        if data.get("status") == "1" and data.get("result"):
            return data["result"][0]
    except:
        pass
    return None

print("=" * 80)
print("MINT FUNCTION VULNERABILITY ANALYSIS")
print("=" * 80)

TARGET = "0x27a94869341838d5783368a8503fda5fbcd7987c"

print(f"\n[CONTRACT] {TARGET}")
print(f"[BALANCE] {get_balance(TARGET):.4f} ETH")

# Get bytecode
code = get_code(TARGET)
print(f"[BYTECODE LENGTH] {len(code)} chars")

# Check if proxy
impl_slot = get_storage(TARGET, IMPLEMENTATION_SLOT)
if impl_slot and impl_slot != "0x" + "0"*64:
    impl_addr = "0x" + impl_slot[26:]
    print(f"\n[PROXY] Implementation: {impl_addr}")

    impl_source = get_source(impl_addr)
    if impl_source:
        impl_name = impl_source.get("ContractName", "Unknown")
        print(f"  Implementation name: {impl_name}")

        src = impl_source.get("SourceCode", "")
        if src.startswith("{{"):
            try:
                src_json = json.loads(src[1:-1])
                sources = src_json.get("sources", {})
                src = "\n".join([v.get("content", "") for v in sources.values()])
            except:
                pass

        if src:
            lines = src.split('\n')

            # Find mint function
            print("\n[MINT FUNCTION IN IMPLEMENTATION]")
            for i, line in enumerate(lines):
                if re.search(r"function\s+mint\s*\(", line, re.IGNORECASE):
                    print(f"\n  Found at line {i+1}:")
                    for j in range(i, min(i+25, len(lines))):
                        print(f"    {j+1}: {lines[j][:70]}")
                        if lines[j].strip() == "}" and j > i + 2:
                            break

            # Find modifiers
            print("\n[ACCESS CONTROL]")
            for i, line in enumerate(lines):
                if "onlyowner" in line.lower() or "onlyminter" in line.lower():
                    print(f"  Line {i+1}: {line.strip()[:70]}")

# Get proxy source
print("\n[PROXY SOURCE]")
proxy_source = get_source(TARGET)
if proxy_source:
    print(f"Proxy name: {proxy_source.get('ContractName', 'Unknown')}")

# Test functions
print("\n" + "=" * 60)
print("[FUNCTION TESTS]")
print("=" * 60)

tests = [
    ("mint()", "0x1249c58b", "", "0x0"),
    ("mint(uint256)", "0xa0712d68", "0000000000000000000000000000000000000000000000000000000000000001", "0x0"),
    ("mint(address,uint256)", "0x40c10f19", "000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000003e8", "0x0"),
    ("owner()", "0x8da5cb5b", "", "0x0"),
    ("minter()", "0x07546172", "", "0x0"),
    ("totalSupply()", "0x18160ddd", "", "0x0"),
    ("name()", "0x06fdde03", "", "0x0"),
    ("withdraw()", "0x3ccfd60b", "", "0x0"),
]

for name, sel, params, value in tests:
    data = sel + params
    result = estimate_gas(TARGET, data, value=value)
    if result:
        if 'result' in result:
            gas = int(result['result'], 16)
            print(f"  [+] {name}: gas {gas}")

            # Get return value
            if name in ["owner()", "minter()", "name()", "totalSupply()"]:
                call_result = eth_call(TARGET, data)
                if call_result and call_result.get('result') and call_result['result'] != "0x":
                    r = call_result['result']
                    if name in ["owner()", "minter()"]:
                        print(f"      -> 0x{r[26:]}")
                    elif name == "totalSupply()":
                        try:
                            val = int(r, 16)
                            print(f"      -> {val} ({val/1e18:.4f} tokens)")
                        except:
                            pass

        elif 'error' in result:
            err = result['error'].get('message', '')[:60]
            print(f"  [-] {name}: {err}")

# Storage analysis
print("\n" + "=" * 60)
print("[STORAGE ANALYSIS]")
print("=" * 60)

for i in range(15):
    val = get_storage(TARGET, hex(i))
    if val and val != "0x" + "0"*64:
        print(f"  Slot {i}: {val}")

print("\n" + "=" * 80)
print("ANALYSIS COMPLETE")
print("=" * 80)
