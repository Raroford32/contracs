#!/usr/bin/env python3
"""
Deep exploit analysis for CEther (Compound fork)
This contract has 313 ETH and interesting msg.value patterns
"""
import json
import subprocess
import re

RPC = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

def rpc_call(method, params):
    payload = {"jsonrpc": "2.0", "method": method, "params": params, "id": 1}
    cmd = ["curl", "-s", "-X", "POST", "-H", "Content-Type: application/json",
           "-d", json.dumps(payload), RPC]
    result = subprocess.run(cmd, capture_output=True, text=True)
    try:
        return json.loads(result.stdout)
    except:
        return None

def eth_call(to, data, from_addr="0x0000000000000000000000000000000000000001", value="0x0"):
    result = rpc_call("eth_call", [{"to": to, "data": data, "from": from_addr, "value": value}, "latest"])
    return result

def estimate_gas(to, data, from_addr="0x0000000000000000000000000000000000000001", value="0x0"):
    result = rpc_call("eth_estimateGas", [{"to": to, "data": data, "from": from_addr, "value": value}])
    return result

def get_balance(addr):
    result = rpc_call("eth_getBalance", [addr, "latest"])
    if result and 'result' in result:
        return int(result['result'], 16) / 1e18
    return 0

def get_storage(addr, slot):
    result = rpc_call("eth_getStorageAt", [addr, slot, "latest"])
    if result and 'result' in result:
        return result['result']
    return None

def get_source(addr):
    url = f"https://api.etherscan.io/v2/api?chainid=1&module=contract&action=getsourcecode&address={addr}&apikey={ETHERSCAN_API}"
    result = subprocess.run(["curl", "-s", url], capture_output=True, text=True)
    try:
        data = json.loads(result.stdout)
        if data.get("status") == "1" and data.get("result"):
            return data["result"][0]
    except:
        pass
    return None

print("=" * 80)
print("CETHER (COMPOUND FORK) DEEP EXPLOIT ANALYSIS")
print("=" * 80)

CETHER = "0x7b4a7fd41c688a7cb116534e341e44126ef5a0fd"

print(f"\n[CONTRACT] {CETHER}")
print(f"[BALANCE] {get_balance(CETHER):.4f} ETH")

source_data = get_source(CETHER)
if source_data:
    src = source_data.get("SourceCode", "")
    contract_name = source_data.get("ContractName", "Unknown")
    print(f"[CONTRACT NAME] {contract_name}")

    # Parse multi-file
    if src.startswith("{{"):
        try:
            src_json = json.loads(src[1:-1])
            sources = src_json.get("sources", {})
            src = "\n".join([v.get("content", "") for v in sources.values()])
        except:
            pass
    elif src.startswith("{"):
        try:
            src_json = json.loads(src)
            sources = src_json.get("sources", {})
            src = "\n".join([v.get("content", "") for v in sources.values()])
        except:
            pass

    print(f"[SOURCE LENGTH] {len(src)} chars")
    lines = src.split('\n')

    # Find the critical pattern: subUInt(address(this).balance, msg.value)
    print("\n[CRITICAL PATTERN: balance - msg.value]")
    for i, line in enumerate(lines):
        if "address(this).balance" in line and "msg.value" in line:
            print(f"  Line {i+1}: {line.strip()[:80]}")
            # Print context
            for j in range(max(0,i-5), min(len(lines), i+10)):
                print(f"    {j+1}: {lines[j][:80]}")

    # Find doTransferIn
    print("\n[doTransferIn FUNCTION]")
    for i, line in enumerate(lines):
        if "function doTransferIn" in line:
            print(f"  Found at line {i+1}:")
            for j in range(i, min(i+25, len(lines))):
                print(f"    {j+1}: {lines[j][:80]}")
                if lines[j].strip() == "}" and j > i + 5:
                    break

    # Find mint function
    print("\n[MINT FUNCTION]")
    for i, line in enumerate(lines):
        if re.search(r"function\s+mint\s*\(\s*\)", line):
            print(f"  Found at line {i+1}:")
            for j in range(i, min(i+30, len(lines))):
                print(f"    {j+1}: {lines[j][:80]}")
                if lines[j].strip() == "}" and j > i + 1:
                    break

    # Find mintInternal
    print("\n[mintInternal/mintFresh FUNCTION]")
    for i, line in enumerate(lines):
        if "function mintFresh" in line:
            print(f"  Found at line {i+1}:")
            for j in range(i, min(i+50, len(lines))):
                print(f"    {j+1}: {lines[j][:80]}")
                if lines[j].strip() == "}" and j > i + 5:
                    break

    # Check for reentrancy guards
    print("\n[REENTRANCY ANALYSIS]")
    has_mutex = "nonReentrant" in src
    has_cei = False

    # Look for state changes before external calls
    for i, line in enumerate(lines):
        if ".call{" in line or ".transfer(" in line or ".send(" in line:
            # Check if state changes happen after this
            func_start = i
            for j in range(i, max(0, i-30), -1):
                if "function " in lines[j]:
                    func_start = j
                    break

            # Find state changes before the external call
            state_before = False
            for j in range(func_start, i):
                if "+=" in lines[j] or "-=" in lines[j] or " = " in lines[j]:
                    if "storage" in lines[j].lower() or "[" in lines[j]:
                        state_before = True
                        has_cei = True

    print(f"  Has nonReentrant modifier: {has_mutex}")
    print(f"  Appears to use CEI pattern: {has_cei}")

    # Find comptroller interactions
    print("\n[COMPTROLLER INTERACTIONS]")
    for i, line in enumerate(lines):
        if "comptroller" in line.lower() and ("." in line):
            if any(p in line for p in ["mintAllowed", "redeemAllowed", "borrowAllowed", "liquidateBorrow"]):
                print(f"  Line {i+1}: {line.strip()[:80]}")

# On-chain state
print("\n" + "=" * 60)
print("[ON-CHAIN STATE]")
print("=" * 60)

selectors = {
    "totalSupply()": "0x18160ddd",
    "totalBorrows()": "0x47bd3718",
    "totalReserves()": "0x8f840ddd",
    "exchangeRateCurrent()": "0xbd6d894d",
    "comptroller()": "0x5fe3b567",
    "admin()": "0xf851a440",
    "pendingAdmin()": "0x26782247",
    "accrualBlockNumber()": "0x6c540baf",
    "borrowIndex()": "0xaa5af0fd",
    "reserveFactorMantissa()": "0x173b9904",
}

for name, sel in selectors.items():
    result = eth_call(CETHER, sel)
    if result and result.get('result') and result['result'] != "0x":
        r = result['result']
        try:
            val = int(r, 16)
            if "Rate" in name or "Factor" in name or "Index" in name:
                print(f"  {name}: {val} ({val/1e18:.6f})")
            elif "address" in name.lower() or "admin" in name.lower() or "comptroller" in name.lower():
                print(f"  {name}: 0x{r[26:]}")
            else:
                print(f"  {name}: {val}")
        except:
            print(f"  {name}: {r[:66]}")

# Calculate key metrics
print("\n[KEY METRICS]")
total_supply_result = eth_call(CETHER, "0x18160ddd")
total_borrows_result = eth_call(CETHER, "0x47bd3718")
total_reserves_result = eth_call(CETHER, "0x8f840ddd")
exchange_rate_result = eth_call(CETHER, "0xbd6d894d")

if all([total_supply_result, total_borrows_result, total_reserves_result]):
    try:
        total_supply = int(total_supply_result['result'], 16)
        total_borrows = int(total_borrows_result['result'], 16)
        total_reserves = int(total_reserves_result['result'], 16)
        eth_balance = get_balance(CETHER)

        print(f"  Total cETH Supply: {total_supply} ({total_supply/1e8:.2f})")
        print(f"  Total Borrows: {total_borrows/1e18:.4f} ETH")
        print(f"  Total Reserves: {total_reserves/1e18:.4f} ETH")
        print(f"  Contract ETH Balance: {eth_balance:.4f} ETH")

        # Calculate implied total cash
        implied_cash = eth_balance
        print(f"  Implied Cash: {implied_cash:.4f} ETH")

        # Exchange rate calculation
        if exchange_rate_result and exchange_rate_result.get('result'):
            exchange_rate = int(exchange_rate_result['result'], 16)
            print(f"  Exchange Rate: {exchange_rate} ({exchange_rate/1e18:.10f})")

            # Calculate value per cETH
            eth_per_ceth = exchange_rate / 1e18 / 1e10  # normalize
            print(f"  ETH per cETH (approx): {eth_per_ceth:.10f}")

    except Exception as e:
        print(f"  Error calculating metrics: {e}")

# Test function calls
print("\n" + "=" * 60)
print("[FUNCTION CALL TESTS]")
print("=" * 60)

test_cases = [
    ("0x1249c58b", "mint()", "0x0", "0xde0b6b3a7640000"),  # with 1 ETH
    ("0xdb006a75" + "0"*64, "redeem(0)", "0x0", "0x0"),
    ("0x852a12e3" + "0"*56 + "de0b6b3a7640000", "redeemUnderlying(1 ETH)", "0x0", "0x0"),
    ("0xc5ebeaec" + "0"*56 + "de0b6b3a7640000", "borrow(1 ETH)", "0x0", "0x0"),
    ("0x4e4d9fea", "repayBorrow()", "0x0", "0xde0b6b3a7640000"),
    ("0xe9c714f2", "_acceptAdmin()", "0x0", "0x0"),
]

for sel, desc, from_addr, value in test_cases:
    if from_addr == "0x0":
        from_addr = "0x0000000000000000000000000000000000000001"
    result = estimate_gas(CETHER, sel, from_addr, value)
    if result:
        if 'result' in result:
            gas = int(result['result'], 16)
            print(f"  [+] {desc} - gas: {gas}")
        elif 'error' in result:
            err = result['error'].get('message', '')[:80]
            print(f"  [-] {desc}: {err}")

# Check comptroller
print("\n" + "=" * 60)
print("[COMPTROLLER ANALYSIS]")
print("=" * 60)

comptroller_result = eth_call(CETHER, "0x5fe3b567")
if comptroller_result and comptroller_result.get('result'):
    comptroller = "0x" + comptroller_result['result'][26:]
    print(f"Comptroller address: {comptroller}")
    print(f"Comptroller balance: {get_balance(comptroller):.4f} ETH")

    # Check if we can interact with comptroller
    # enterMarkets(address[])
    cether_padded = CETHER[2:].lower().zfill(64)
    enter_markets_data = "0xc2998238" + "0000000000000000000000000000000000000000000000000000000000000020" + "0000000000000000000000000000000000000000000000000000000000000001" + "000000000000000000000000" + cether_padded[24:]

    result = estimate_gas(comptroller, enter_markets_data)
    if result:
        if 'result' in result:
            gas = int(result['result'], 16)
            print(f"  [+] enterMarkets() callable - gas: {gas}")
        elif 'error' in result:
            err = result['error'].get('message', '')[:60]
            print(f"  [-] enterMarkets(): {err}")

print("\n" + "=" * 80)
print("ANALYSIS COMPLETE")
print("=" * 80)
