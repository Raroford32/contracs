#!/usr/bin/env python3
"""
Simple LUSD price check
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
from decimal import Decimal

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"

# Known LUSD-related addresses
ADDRESSES = {
    'LUSD': '0x5f98805a4e8be255a32880fdec7f6728c6568ba0',
    'LUSD_3CRV_old': '0xed279fdd11ca84beef15af5d39bb4d4bee23f0ca',
    '3CRV': '0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490',
    '3pool': '0xbebc44782c7db0a1a60cb6fe97d0b483032ff1c7',
    'Liquity_TroveManager': '0xa39739ef8b0231dbfa0dcda07d7e29faabcf4bb2',
}

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data, debug=False):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        result = resp.json()
        if debug:
            print(f"Call to {to}: {result}")
        if 'error' in result:
            return None
        return result.get("result", "0x")
    except Exception as e:
        print(f"Error: {e}")
        return None

def decode_uint256(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return 0
    try:
        return int(hex_result[:66], 16)  # Take first 32 bytes
    except:
        return 0

def main():
    print("=" * 70)
    print("LUSD SIMPLE PRICE CHECK")
    print("=" * 70)

    # Check 3pool virtual price
    print("\n--- 3POOL ---")
    selector = get_function_selector("get_virtual_price()")
    result = eth_call(ADDRESSES['3pool'], selector)
    if result and len(result) >= 66:
        vp = decode_uint256(result)
        print(f"3pool Virtual Price: {vp / 1e18:.6f}")

    # Check LUSD total supply
    print("\n--- LUSD ---")
    selector = get_function_selector("totalSupply()")
    result = eth_call(ADDRESSES['LUSD'], selector)
    if result and len(result) >= 66:
        supply = decode_uint256(result)
        print(f"LUSD Total Supply: {supply / 1e18:,.0f}")

    # Check Liquity base rate
    print("\n--- LIQUITY ---")
    selector = get_function_selector("baseRate()")
    result = eth_call(ADDRESSES['Liquity_TroveManager'], selector)
    if result and len(result) >= 66:
        rate = decode_uint256(result)
        print(f"Base Rate: {rate / 1e18 * 100:.4f}%")

    # Get ETH price from Liquity
    selector = get_function_selector("lastGoodPrice()")
    result = eth_call('0x4c517d4e2c851ca76d7ec94b805269df0f2201de', selector)
    if result and len(result) >= 66:
        price = decode_uint256(result)
        print(f"ETH Price: ${price / 1e18:.2f}")

    # Try to find actual LUSD/3CRV pool
    print("\n--- FINDING LUSD POOL ---")

    # Check Curve Factory for LUSD pools
    # The LUSD/3CRV metapool should be at a specific address
    # Let me check if it has any ETH or token balance

    lusd_pool = "0xed279fdd11ca84beef15af5d39bb4d4bee23f0ca"

    # Check if it's a contract
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getCode",
        "params": [lusd_pool, "latest"],
        "id": 1
    }
    resp = requests.post(RPC_URL, json=payload, timeout=10)
    code = resp.json().get('result', '0x')
    print(f"LUSD Pool code size: {len(code)} chars")

    if len(code) > 4:
        # It exists, let's check admin
        selector = get_function_selector("admin()")
        result = eth_call(lusd_pool, selector)
        if result and len(result) >= 42:
            admin = "0x" + result[-40:]
            print(f"Pool admin: {admin}")

        # Try coins(0) and coins(1)
        for i in range(2):
            selector = get_function_selector("coins(uint256)")
            data = selector + encode(['uint256'], [i]).hex()
            result = eth_call(lusd_pool, data)
            if result and len(result) >= 42:
                coin = "0x" + result[-40:]
                print(f"Coin[{i}]: {coin}")

    # Check Uniswap V3 LUSD/USDC pool
    print("\n--- UNISWAP V3 LUSD POOLS ---")

    # LUSD/USDC pool address (need to find it)
    # For now, let's check if LUSD has Chainlink oracle
    lusd_chainlink = "0x3D7aE7E594f2f2091Ad8798313450130d0Aba3a0"

    selector = get_function_selector("latestRoundData()")
    result = eth_call(lusd_chainlink, selector)
    if result and len(result) >= 130:
        # Returns (roundId, answer, startedAt, updatedAt, answeredInRound)
        try:
            # Skip first 2 chars (0x), then decode
            data = bytes.fromhex(result[2:])
            roundId = int.from_bytes(data[0:32], 'big')
            answer = int.from_bytes(data[32:64], 'big')
            startedAt = int.from_bytes(data[64:96], 'big')
            updatedAt = int.from_bytes(data[96:128], 'big')

            print(f"LUSD/USD Chainlink Price: ${answer / 1e8:.4f}")
            print(f"Last Updated: {updatedAt}")
        except Exception as e:
            print(f"Error decoding: {e}")

    print("\n" + "=" * 70)
    print("ANALYSIS")
    print("=" * 70)
    print("""
For LUSD cross-protocol arbitrage to work:
1. LUSD must trade below $1 - redemption_fee on DEXs
2. Buy LUSD cheap on DEX
3. Redeem through Liquity at $1 value (minus ~0.7% fee)
4. Net profit if discount > fee + gas

Current Liquity redemption fee is ~0.7%, so LUSD needs to be < $0.993
for arbitrage to be profitable.

This arbitrage is well-known and heavily competed by MEV bots.
Not a novel exploit vector.
""")

if __name__ == "__main__":
    main()
