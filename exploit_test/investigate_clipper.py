#!/usr/bin/env python3
"""
Investigate ClipperPool for rebasing token mishandling.
Flagged: REBASE_TOKEN + PROXY + TIME_UNLOCK
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

CLIPPER = "0xe82906b6b1b04f631d126c974af57a3a7b6a99d9"

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        result = resp.json()
        if 'error' in result:
            return None
        return result.get("result", "0x")
    except:
        return None

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def decode_address(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return None
    return "0x" + hex_result[-40:]

def decode_uint256(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return 0
    return int(hex_result[:66], 16)

def main():
    print("=" * 70)
    print("CLIPPER POOL INVESTIGATION")
    print("=" * 70)

    address = CLIPPER
    print(f"\nAddress: {address}")

    # Get balance
    eth_bal = get_eth_balance(address)
    print(f"ETH Balance: {eth_bal / 1e18:.4f} ETH (${eth_bal / 1e18 * 2279:,.0f})")

    # Get source
    source_data = get_contract_source(address)
    if not source_data:
        print("No verified source")
        return

    source_code = source_data.get('SourceCode', '')
    contract_name = source_data.get('ContractName', 'Unknown')
    print(f"Contract: {contract_name}")
    print(f"Compiler: {source_data.get('CompilerVersion', '')}")

    if not source_code:
        print("Empty source")
        return

    with open('clipper_source.sol', 'w') as f:
        f.write(source_code)
    print("Source saved to clipper_source.sol")

    lower = source_code.lower()

    # Check for rebasing token patterns
    print("\n--- REBASING TOKEN PATTERNS ---")

    patterns = {
        'stETH': 'steth' in lower,
        'wstETH': 'wsteth' in lower,
        'rebasing': 'rebas' in lower,
        'shares': 'shares' in lower,
        'getPooledEth': 'getpooledeth' in lower,
        'balanceOf direct': 'balanceof' in lower,
        'getSharesByPooled': 'getsharesbypooled' in lower,
    }

    for p_name, found in patterns.items():
        print(f"  {p_name}: {'YES' if found else 'NO'}")

    # Check for time-based patterns
    print("\n--- TIME-BASED PATTERNS ---")

    time_patterns = {
        'timelock': 'timelock' in lower,
        'unlock time': 'unlock' in lower,
        'delay': 'delay' in lower,
        'block.timestamp': 'block.timestamp' in lower,
        'vestingEnd': 'vestingend' in lower or 'vesting' in lower,
    }

    for p_name, found in time_patterns.items():
        print(f"  {p_name}: {'YES' if found else 'NO'}")

    # Query contract state
    print("\n--- CONTRACT STATE ---")

    selectors = [
        ("owner()", "owner"),
        ("nAssets()", "nAssets"),
        ("fullyDilutedSupply()", "fullyDilutedSupply"),
        ("lastDeposit()", "lastDeposit"),
        ("depositFee()", "depositFee"),
        ("withdrawalFee()", "withdrawalFee"),
    ]

    for sig, desc in selectors:
        selector = get_function_selector(sig)
        result = eth_call(address, selector)
        if result and result != "0x" and len(result) > 10:
            if 'address' in sig.lower() or 'owner' in sig.lower():
                addr = decode_address(result)
                if addr:
                    print(f"  {desc}: {addr}")
            else:
                value = decode_uint256(result)
                print(f"  {desc}: {value}")

    # Check for WETH/tokens
    print("\n--- ASSET CHECK ---")

    # WETH
    WETH = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"
    selector = get_function_selector("balanceOf(address)")
    data = selector + encode(['address'], [address]).hex()
    result = eth_call(WETH, data)
    if result:
        weth_bal = decode_uint256(result)
        print(f"  WETH Balance: {weth_bal / 1e18:.4f}")

    # stETH
    STETH = "0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84"
    result = eth_call(STETH, data)
    if result:
        steth_bal = decode_uint256(result)
        print(f"  stETH Balance: {steth_bal / 1e18:.4f}")

    # wstETH
    WSTETH = "0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0"
    result = eth_call(WSTETH, data)
    if result:
        wsteth_bal = decode_uint256(result)
        print(f"  wstETH Balance: {wsteth_bal / 1e18:.4f}")

    # USDC
    USDC = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
    result = eth_call(USDC, data)
    if result:
        usdc_bal = decode_uint256(result)
        print(f"  USDC Balance: {usdc_bal / 1e6:.2f}")

    print("\n--- VULNERABILITY ANALYSIS ---")
    print("""
For rebasing token exploitation:
1. Pool must hold stETH directly (not wstETH)
2. Pool must use balanceOf() for accounting
3. Rebase gains must not be tracked internally

For time-unlock exploitation:
1. Must be able to trigger unlock early
2. Or exploit state during unlock transition

Check if Clipper tracks deposits internally vs. balanceOf.
""")

if __name__ == "__main__":
    main()
