#!/usr/bin/env python3
"""
Manual deep analysis of specific high-value contracts.
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import json

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        result = resp.json()
        if 'error' in result:
            return None
        return result.get("result", "0x")
    except:
        return None

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def decode_uint256(hex_result):
    if hex_result == "0x" or not hex_result:
        return 0
    return int(hex_result, 16)

def format_ether(wei):
    return f"{wei / 1e18:.4f}"

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def analyze_etherdelta(address):
    """Deep analysis of EtherDelta exchange contract"""
    print("=" * 70)
    print("ETHERDELTA ANALYSIS")
    print(f"Address: {address}")
    print("=" * 70)

    eth_bal = get_eth_balance(address)
    print(f"\nETH Balance: {format_ether(eth_bal)} ETH (${eth_bal / 1e18 * 2279:,.0f})")

    # Get source code
    source = get_contract_source(address)
    if source:
        source_code = source.get('SourceCode', '')
        print(f"Contract Name: {source.get('ContractName', 'Unknown')}")
        print(f"Compiler: {source.get('CompilerVersion', 'Unknown')}")

        # Look for specific functions
        print("\n--- KEY FUNCTIONS ---")

        # The EtherDelta contract has these key functions:
        # - deposit() - deposit ETH
        # - withdraw(uint256) - withdraw ETH
        # - depositToken(address,uint256) - deposit ERC20
        # - withdrawToken(address,uint256) - withdraw ERC20
        # - trade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256)
        # - cancelOrder(address,uint256,address,uint256,uint256,uint256,uint8,bytes32,bytes32)

        # Check admin/fee functions
        selector = get_function_selector("admin()")
        result = eth_call(address, selector)
        if result and len(result) >= 42:
            admin = "0x" + result[-40:]
            print(f"Admin: {admin}")

        selector = get_function_selector("feeAccount()")
        result = eth_call(address, selector)
        if result and len(result) >= 42:
            fee_account = "0x" + result[-40:]
            print(f"Fee Account: {fee_account}")

        selector = get_function_selector("feeTake()")
        result = eth_call(address, selector)
        if result:
            fee = decode_uint256(result)
            print(f"Fee Take: {fee / 1e18 * 100:.4f}%")

        selector = get_function_selector("feeMake()")
        result = eth_call(address, selector)
        if result:
            fee = decode_uint256(result)
            print(f"Fee Make: {fee / 1e18 * 100:.4f}%")

        # Check if there are any known issues
        print("\n--- VULNERABILITY ANALYSIS ---")

        # EtherDelta uses signature-based orders
        # Potential issues:
        # 1. Signature replay across networks (but mainnet only)
        # 2. Order filling race conditions
        # 3. Precision loss in fee calculations

        # Check the withdraw function specifically
        print("Checking withdraw mechanics...")

        # The withdraw function in EtherDelta:
        # function withdraw(uint amount) {
        #     if (tokens[0][msg.sender] < amount) throw;
        #     tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);
        #     if (!msg.sender.call.value(amount)()) throw;
        # }

        # This is vulnerable to reentrancy! The state update happens BEFORE the external call
        # Wait no - actually the state IS updated before the call. Let me look more carefully.

        if 'withdraw' in source_code.lower():
            # Find the withdraw function
            lines = source_code.split('\n')
            in_withdraw = False
            for i, line in enumerate(lines):
                if 'function withdraw' in line.lower():
                    in_withdraw = True
                    print(f"\nWithdraw function at line {i+1}:")
                if in_withdraw:
                    print(f"  {line}")
                    if '}' in line and in_withdraw:
                        if 'function' not in lines[i+1] if i+1 < len(lines) else True:
                            break

        return source_code
    return None

def analyze_exchange_0x2a0c(address):
    """Analyze the Exchange contract at 0x2a0c..."""
    print("\n" + "=" * 70)
    print("EXCHANGE CONTRACT ANALYSIS")
    print(f"Address: {address}")
    print("=" * 70)

    eth_bal = get_eth_balance(address)
    print(f"\nETH Balance: {format_ether(eth_bal)} ETH (${eth_bal / 1e18 * 2279:,.0f})")

    source = get_contract_source(address)
    if source:
        source_code = source.get('SourceCode', '')
        contract_name = source.get('ContractName', 'Unknown')
        print(f"Contract Name: {contract_name}")

        # Check what protocol this belongs to
        print("\n--- PROTOCOL IDENTIFICATION ---")

        if 'IDEX' in source_code or 'idex' in source_code.lower():
            print("Protocol: IDEX Exchange")
        elif '0x' in source_code:
            print("Protocol: 0x or derivative")
        elif 'oasis' in source_code.lower():
            print("Protocol: Oasis DEX")
        else:
            print("Protocol: Unknown DEX")

        # Check for key functions
        selector = get_function_selector("owner()")
        result = eth_call(address, selector)
        if result and len(result) >= 42:
            owner = "0x" + result[-40:]
            print(f"Owner: {owner}")

        return source_code
    return None

def analyze_acid(address):
    """Analyze the Acid contract"""
    print("\n" + "=" * 70)
    print("ACID CONTRACT ANALYSIS")
    print(f"Address: {address}")
    print("=" * 70)

    eth_bal = get_eth_balance(address)
    print(f"\nETH Balance: {format_ether(eth_bal)} ETH (${eth_bal / 1e18 * 2279:,.0f})")

    source = get_contract_source(address)
    if source:
        source_code = source.get('SourceCode', '')
        contract_name = source.get('ContractName', 'Unknown')
        print(f"Contract Name: {contract_name}")

        # Acid is a Ponzi/game contract
        # Let me check the mechanics

        print("\n--- CONTRACT MECHANICS ---")

        # Check for sell/buy functions
        selector = get_function_selector("sellPrice()")
        result = eth_call(address, selector)
        if result:
            price = decode_uint256(result)
            print(f"Sell Price: {format_ether(price)}")

        selector = get_function_selector("buyPrice()")
        result = eth_call(address, selector)
        if result:
            price = decode_uint256(result)
            print(f"Buy Price: {format_ether(price)}")

        selector = get_function_selector("totalSupply()")
        result = eth_call(address, selector)
        if result:
            supply = decode_uint256(result)
            print(f"Total Supply: {format_ether(supply)}")

        # Check if withdrawable
        selector = get_function_selector("myDividends(bool)")
        # Need to call with msg.sender but we can't
        # Let me check the exit function
        selector = get_function_selector("exit()")
        result = eth_call(address, selector)
        print(f"Exit function exists: {result is not None}")

        return source_code
    return None

def main():
    # High-value targets identified from scanning
    targets = [
        ("0x8d12a197cb00d4747a1fe03395095ce2a5cc6819", "EtherDelta", analyze_etherdelta),
        ("0x2a0c0dbecc7e4d658f48e01e3fa353f44050c208", "Exchange", analyze_exchange_0x2a0c),
        ("0x23ea10cc1e6ebdb499d24e45369a35f43627062f", "Acid", analyze_acid),
    ]

    results = {}
    for address, name, analyzer in targets:
        source_code = analyzer(address)
        if source_code:
            results[name] = {
                'address': address,
                'source': source_code[:1000] + '...' if len(source_code) > 1000 else source_code
            }

    # Save for further analysis
    with open('manual_analysis_results.json', 'w') as f:
        json.dump(results, f, indent=2)

if __name__ == "__main__":
    main()
