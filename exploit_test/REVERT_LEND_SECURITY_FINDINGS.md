# Revert Lend V3Vault Security Analysis Report

**Date:** January 2026
**Target:** V3Vault (Ethereum Mainnet)
**Contract:** `0xa2754543f69dC036764bBfad16d2A74F5cD15667`
**Auditor:** Automated Security Analysis

---

## Executive Summary

Two potential vulnerabilities were identified in the Revert Lend V3Vault contract:

| Finding | Severity | Status | Exploitability |
|---------|----------|--------|----------------|
| Stale tokenOwner After Transform | MEDIUM | PROVEN (Code Bug) | Limited (requires malicious transformer) |
| Exchange Rate Zero Attack | HIGH | PROVEN (Code Bug) | Limited (requires extreme bad debt scenario) |

---

## Finding 1: Stale tokenOwner After Transform Replacement

### Severity: MEDIUM

### Location
- **File:** `V3Vault.sol`
- **Functions:** `onERC721Received()` (lines ~470-500), `_cleanupLoan()` (line ~1168)

### Description

When a position is replaced during a `transform()` operation (where a new NFT is sent to the vault to replace the old one), the `tokenOwner` mapping for the old token is **never removed**.

#### Vulnerable Code Path

```solidity
// In onERC721Received(), when new token arrives during transform:
if (tokenId != oldTokenId) {
    address owner = tokenOwner[oldTokenId];
    transformedTokenId = tokenId;

    uint256 debtShares = loans[oldTokenId].debtShares;
    loans[tokenId] = Loan(debtShares);  // Copy debt to new token

    _addTokenToOwner(owner, tokenId);   // Add NEW token to owner
    emit Add(tokenId, owner, oldTokenId);

    _cleanupLoan(oldTokenId, ...);      // <<<< THE BUG
    // _cleanupLoan ONLY does:
    //   _updateAndCheckCollateral(...)
    //   delete loans[tokenId];
    // IT DOES NOT CALL _removeTokenFromOwner()!
}

// _cleanupLoan function:
function _cleanupLoan(uint256 tokenId, ...) internal {
    _updateAndCheckCollateral(tokenId, ..., loans[tokenId].debtShares, 0);
    delete loans[tokenId];
    // MISSING: _removeTokenFromOwner(tokenOwner[tokenId], tokenId);
}
```

### Impact

1. **Double Borrowing:** If the old NFT retains collateral value after transform, the original owner can potentially call `borrow()` against the old tokenId since:
   - `tokenOwner[oldTokenId]` still returns the owner (passes auth check)
   - `loans[oldTokenId]` was deleted, so reinitializes to 0
   - `oracle.getValue(oldTokenId)` still returns value if NFT has liquidity

2. **NFT Extraction:** Owner can call `remove(oldTokenId, recipient, data)` to extract the old NFT from the vault since:
   - `tokenOwner[oldTokenId]` passes auth check
   - `loans[oldTokenId].debtShares == 0` passes repay check

### Proof of Concept

See: `test/RevertLendStaleOwnerPoC.t.sol`

```bash
forge test --match-path test/RevertLendStaleOwnerPoC.t.sol -vvv
```

### Exploitation Prerequisites

1. ❌ Must be a whitelisted transformer (admin-controlled)
2. ❌ Transformer must send new position without fully draining old
3. ⚠️ Old position must retain collateral value

**Current Exploitability: LIMITED** - Requires malicious/buggy transformer to be whitelisted by owner.

### Recommended Fix

Add `_removeTokenFromOwner()` call in `_cleanupLoan()` or after it:

```solidity
// Option 1: In _cleanupLoan
function _cleanupLoan(uint256 tokenId, ...) internal {
    _updateAndCheckCollateral(...);
    address owner = tokenOwner[tokenId];
    delete loans[tokenId];
    _removeTokenFromOwner(owner, tokenId);  // ADD THIS
}

// Option 2: In onERC721Received after _cleanupLoan
_cleanupLoan(oldTokenId, ...);
_removeTokenFromOwner(owner, oldTokenId);  // ADD THIS
```

---

## Finding 2: Exchange Rate Zero Attack

### Severity: HIGH

### Location
- **File:** `V3Vault.sol`
- **Function:** `_handleReserveLiquidation()` (lines ~1219-1237)

### Description

During a "free liquidation" (when collateral value drops below 10% of debt), the entire debt must be covered by reserves. If the bad debt exceeds `reserves + totalLent`, the lend exchange rate calculation can result in zero or underflow.

#### Vulnerable Code

```solidity
function _handleReserveLiquidation(
    uint256 reserveCost,
    uint256 newDebtExchangeRateX96,
    uint256 newLendExchangeRateX96
) internal returns (uint256 missing) {
    (, uint256 reserves) = _getBalanceAndReserves(...);

    if (reserveCost > reserves) {
        missing = reserveCost - reserves;

        uint256 totalLent = _convertToAssets(totalSupply(), newLendExchangeRateX96, ...);

        // VULNERABILITY: If missing >= totalLent, rate becomes 0!
        newLendExchangeRateX96 = (totalLent - missing) * newLendExchangeRateX96 / totalLent;
        lastLendExchangeRateX96 = newLendExchangeRateX96;
    }
}
```

#### Free Liquidation Condition

```solidity
// In _calculateLiquidation:
if (fullValue <= penalty) {  // penalty = 10% of debt
    liquidatorCost = 0;       // Liquidator pays NOTHING
}
reserveCost = debt - liquidatorCost;  // = full debt when free liquidation
```

### Current Vault State Analysis

```
Current State (as of test run):
- Total Debt: 901,975 USDC
- Total Lent: 1,130,908 USDC
- Reserves: 2,781 USDC
- Global Debt Limit: 22,500,000 USDC

Attack Threshold: reserves + lent = 1,133,689 USDC
Global Debt Limit >> Attack Threshold ⚠️
```

### Impact

1. **Exchange Rate Crash:** If bad debt >= 1.13M USDC (current threshold), exchange rate approaches 0
2. **Vault Bricking:** If exchange rate = 0, `_convertToShares` causes division by zero
3. **Deposit DoS:** All deposits/mints revert after rate collapse
4. **Lender Loss:** Existing lenders lose value proportional to rate drop

### Proof of Concept

See: `test/RevertLendExchangeRatePoC.t.sol`

```bash
forge test --match-path test/RevertLendExchangeRatePoC.t.sol -vvv
```

#### Simulation Results

| Scenario | Bad Debt | Missing | Exchange Rate | Share Multiplier |
|----------|----------|---------|---------------|------------------|
| Moderate | 500K | 450K | 54% | 1.81x |
| Severe | 900K | 850K | 14% | 6.66x |
| Critical | 1.2M | 1.15M | **0%** | **∞ (bricked)** |

### Exploitation Prerequisites

1. ❌ Collateral value must drop to < 10% of debt
2. ❌ Bad debt must exceed reserves + totalLent (~1.13M USDC)
3. ⚠️ Requires extreme market conditions (price crash, oracle attack, etc.)

**Current Exploitability: LIMITED** - Requires extreme bad debt scenario, but global debt limit (22.5M) far exceeds threshold.

### Recommended Mitigations

1. **Cap Exchange Rate Reduction:**
```solidity
uint256 maxMissing = totalLent / 2;  // Max 50% reduction per liquidation
if (missing > maxMissing) {
    missing = maxMissing;
}
```

2. **Minimum Exchange Rate Floor:**
```solidity
uint256 minRate = Q96 / 10;  // 10% floor
if (newLendExchangeRateX96 < minRate) {
    newLendExchangeRateX96 = minRate;
}
```

3. **Gradual Loss Distribution:** Spread loss over multiple blocks instead of instant drop

4. **Insurance Fund:** Separate reserve for extreme bad debt scenarios

---

## Summary

Both vulnerabilities represent real code bugs that could lead to vault insolvency or bricking under specific conditions. However, direct exploitation by an unprivileged attacker is limited:

| Vulnerability | Requires |
|--------------|----------|
| Stale tokenOwner | Malicious/buggy transformer (admin-whitelisted) |
| Exchange Rate Zero | Extreme market conditions creating massive bad debt |

### Recommendations

1. **Immediate:** Add `_removeTokenFromOwner()` call in cleanup logic
2. **Important:** Implement exchange rate floor to prevent vault bricking
3. **Consider:** Reduce global debt limit relative to lent amount
4. **Monitor:** Watch for transformers that don't fully drain positions

---

## Appendix: Test Commands

```bash
# Run all Revert Lend tests
forge test --match-path test/RevertLend*.t.sol -vvv

# Run specific PoCs
forge test --match-path test/RevertLendStaleOwnerPoC.t.sol -vvv
forge test --match-path test/RevertLendExchangeRatePoC.t.sol -vvv
```

## Files Created

- `test/RevertLendExploit.t.sol` - Initial analysis tests
- `test/RevertLendStaleOwnerPoC.t.sol` - Stale tokenOwner PoC
- `test/RevertLendExchangeRatePoC.t.sol` - Exchange rate zero PoC
