# Deep Manual Analysis: EtherDelta Contract (0x8d12a197)
## Balance: 15,280 ETH

## Contract Overview
- Solidity ^0.4.9 (VERY OLD)
- Decentralized exchange with off-chain order matching
- NO ReentrancyGuard
- Admin-controlled fee structure

---

## CRITICAL VULNERABILITY #1: AccountLevels Cross-Contract Reentrancy

```solidity
function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {
    uint feeMakeXfer = safeMul(amount, feeMake) / (1 ether);
    uint feeTakeXfer = safeMul(amount, feeTake) / (1 ether);
    uint feeRebateXfer = 0;
    if (accountLevelsAddr != 0x0) {
      uint accountLevel = AccountLevels(accountLevelsAddr).accountLevel(user);  // EXTERNAL CALL FIRST!
      if (accountLevel==1) feeRebateXfer = safeMul(amount, feeRebate) / (1 ether);
      if (accountLevel==2) feeRebateXfer = feeTakeXfer;
    }
    // BALANCE UPDATES HAPPEN AFTER EXTERNAL CALL!
    tokens[tokenGet][msg.sender] = safeSub(tokens[tokenGet][msg.sender], safeAdd(amount, feeTakeXfer));
    tokens[tokenGet][user] = safeAdd(tokens[tokenGet][user], safeSub(safeAdd(amount, feeRebateXfer), feeMakeXfer));
    ...
}
```

**Pattern**: EXTERNAL CALL before STATE CHANGES in trade execution

**Attack Vector**:
1. Admin sets `accountLevelsAddr` to malicious contract
2. User calls `trade()`
3. `tradeBalances()` calls `maliciousContract.accountLevel(user)`
4. Malicious contract re-enters EtherDelta:
   - Call `withdraw()` to drain ETH
   - Call `withdrawToken()` to drain tokens
   - Call `depositToken()` to add fake balances
5. Original trade completes with inconsistent state

**Admin Control Vector**:
```solidity
function changeAccountLevelsAddr(address accountLevelsAddr_) {
    if (msg.sender != admin) throw;
    accountLevelsAddr = accountLevelsAddr_;
}
```

**Exploitability**: HIGH if admin compromised
**Impact**: Complete fund drainage

---

## CRITICAL VULNERABILITY #2: Cross-Function Reentrancy via ERC-777

### withdrawToken -> trade Attack

```solidity
function withdrawToken(address token, uint amount) {
    if (token==0) throw;
    if (tokens[token][msg.sender] < amount) throw;
    tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);  // Balance reduced
    if (!Token(token).transfer(msg.sender, amount)) throw;  // EXTERNAL CALL with ERC-777
    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);
}
```

**Attack Sequence**:
```
1. Attacker deposits ERC-777 tokenA and standard tokenB
2. Attacker creates order: sell tokenB for tokenA
3. Attacker calls withdrawToken(tokenA, amount)
4. Balance for tokenA reduced
5. Token.transfer() triggers tokensReceived callback
6. In callback, attacker calls trade() with their own order
7. Trade executes: tokenB balance reduced, tokenA balance increased
8. Original withdrawToken completes
9. Result: Attacker got tokenA via withdrawal AND via trade
```

**State Manipulation**:
- During callback, `tokens[tokenA][attacker]` is already reduced
- But `tokens[tokenB][attacker]` is unchanged
- Attacker can execute trades involving tokenB
- Timing advantage for front-running

**Exploitability**: MEDIUM - requires ERC-777 token
**Impact**: Trade manipulation, potential arbitrage

---

## CRITICAL VULNERABILITY #3: withdraw -> Multiple Operations

```solidity
function withdraw(uint amount) {
    if (tokens[0][msg.sender] < amount) throw;
    tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);
    if (!msg.sender.call.value(amount)()) throw;  // Low-level call with all gas
    Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
}
```

**Attack Sequence**:
```
1. Attacker has 10 ETH and 1000 tokenX in EtherDelta
2. Attacker calls withdraw(10 ETH)
3. ETH balance reduced: tokens[0][attacker] = 0
4. msg.sender.call.value(10)() sends ETH and triggers receive()
5. In receive(), attacker executes:
   a. depositToken(tokenX, 500)  // Add more tokenX
   b. trade() with favorable order  // Execute trades
   c. Order multiple other operations
6. Original withdraw completes
7. All operations atomic in single transaction
```

**Impact**:
- Atomic arbitrage opportunities
- State manipulation for favorable trades
- Potential for flash-loan-like attacks (before flash loans existed)

---

## VULNERABILITY #4: Read-Only Reentrancy

```solidity
function balanceOf(address token, address user) constant returns (uint) {
    return tokens[token][user];
}

function availableVolume(...) constant returns(uint) {
    ...
    uint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive;
    ...
}
```

**During withdraw/withdrawToken callbacks**:
- User's balance is reduced
- External contracts calling `balanceOf()` see reduced balance
- `availableVolume()` returns incorrect values

**Cross-Protocol Attack**:
1. External protocol uses EtherDelta.balanceOf() for collateral
2. User withdraws from EtherDelta
3. During callback, user interacts with external protocol
4. External protocol sees reduced collateral
5. User gets liquidated or loses position unfairly

**Impact**: Oracle manipulation for other protocols

---

## VULNERABILITY #5: depositToken Order Dependency

```solidity
function depositToken(address token, uint amount) {
    if (token==0) throw;
    if (!Token(token).transferFrom(msg.sender, this, amount)) throw;  // Call FIRST
    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);  // Update AFTER
    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);
}
```

**Pattern**: Interaction before Effect (reverse CEI)

While this seems safe, with ERC-777's `tokensToSend` hook:
```
1. User calls depositToken(erc777Token, amount)
2. transferFrom() triggers tokensToSend BEFORE tokens move
3. In tokensToSend callback:
   - User's EtherDelta balance is NOT YET increased
   - User can observe "pre-deposit" state
   - User can frontrun their own deposit with trades
```

**Exploitability**: LOW - limited practical impact
**Use Case**: Information leakage, MEV extraction

---

## VULNERABILITY #6: No Token Whitelist + Malicious Token

```solidity
function depositToken(address token, uint amount) {
    if (token==0) throw;  // Only checks token != 0
    if (!Token(token).transferFrom(msg.sender, this, amount)) throw;
    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);
}
```

**Malicious Token Attack**:
1. Attacker deploys MaliciousToken:
   - `transferFrom()` returns true without transferring
   - `transfer()` reverts always
2. Attacker deposits fake tokens
3. Attacker creates order: sell fake tokens for real tokens
4. Victim fills order (off-chain matching)
5. trade() executes:
   - Victim's real tokens go to attacker's balance
   - Attacker's fake tokens go to victim's balance
6. Victim tries to withdraw fake tokens - reverts!
7. Attacker withdraws real tokens

**Exploitability**: MEDIUM - requires victim to accept fake token order
**Impact**: Theft of real tokens, locked victim funds

---

## CROSS-CONTRACT REENTRANCY FLOW DIAGRAM

```
EtherDelta.trade()
    │
    ├──► AccountLevels.accountLevel() [EXTERNAL CALL #1]
    │         │
    │         └──► Malicious re-entry:
    │                  ├── withdraw()
    │                  ├── withdrawToken()
    │                  │      └──► Token.transfer() [EXTERNAL CALL #2]
    │                  │              └──► tokensReceived callback
    │                  │                      └──► trade() [NESTED]
    │                  └── depositToken()
    │                         └──► Token.transferFrom() [EXTERNAL CALL #3]
    │                                └──► tokensToSend callback
    │                                        └──► More operations
    │
    └──► Balance updates (AFTER all external calls complete)
```

---

## ECONOMIC ANALYSIS

**Contract Balance**: 15,280 ETH (~$45M at $3000/ETH)

**Attack Costs**:
- ERC-777 attack: Deploy token, gas costs (~$100-1000)
- Admin compromise: Social engineering / key theft
- Malicious token: Deployment + victim manipulation

**Profit Potential**:
- Full admin compromise: 15,280 ETH ($45M)
- ERC-777 manipulation: Depends on token liquidity
- Malicious token: Limited by victim exposure

---

## HISTORICAL CONTEXT

EtherDelta was exploited multiple times:
1. **2017 DNS Hijack**: Not smart contract related
2. **Front-running**: Off-chain order book was front-run
3. **Admin key theft**: Led to unauthorized withdrawals

The contract's age (2016-2017) predates many security patterns.

---

## CONCLUSION

| Vulnerability | Severity | Exploitability | Vector |
|--------------|----------|----------------|--------|
| AccountLevels Reentrancy | CRITICAL | HIGH (if admin compromised) | Admin sets malicious contract |
| ERC-777 Cross-Function | HIGH | MEDIUM | Token with hooks |
| ETH Withdraw Reentrancy | MEDIUM | MEDIUM | Atomic operations |
| Read-Only Reentrancy | MEDIUM | LOW | Cross-protocol oracle |
| Malicious Token | HIGH | MEDIUM | Social engineering |
| depositToken Callback | LOW | LOW | Information leakage |

**Most Critical Finding**: The `AccountLevels.accountLevel()` external call happens BEFORE balance updates in `tradeBalances()`. This is a textbook cross-contract reentrancy vulnerability.

**Recommendation**:
1. Investigate current `accountLevelsAddr` contract
2. Check admin wallet security
3. Look for ERC-777 tokens traded on the exchange
