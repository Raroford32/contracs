# Deep Analysis: XVIX Protocol Cross-Contract Reentrancy
## Contracts: XVIX Token, Floor, Minter

---

## CRITICAL VULNERABILITY #1: Floor.refund() Cross-Contract Reentrancy

```solidity
// Floor.sol
function refund(address _receiver, uint256 _burnAmount) public override nonReentrant returns (uint256) {
    uint256 refundAmount = getRefundAmount(_burnAmount);  // (1) Read totalSupply
    require(refundAmount > 0, "Floor: refund amount is zero");
    capital = capital.sub(refundAmount);  // (2) Reduce capital

    IXVIX(xvix).burn(msg.sender, _burnAmount);  // (3) Burn XVIX - reduces totalSupply!

    (bool success,) = _receiver.call{value: refundAmount}("");  // (4) EXTERNAL CALL!
    require(success, "Floor: transfer to reciever failed");

    emit Refund(_receiver, refundAmount, _burnAmount);
    emit FloorPrice(capital, IERC20(xvix).totalSupply());
    return refundAmount;
}
```

**Attack Flow:**
```
1. Attacker calls floor.refund(attackerContract, burnAmount)
2. refundAmount = capital * burnAmount / totalSupply * 0.9
3. capital = capital - refundAmount  [STATE CHANGED]
4. xvix.burn() -> totalSupply reduced  [CROSS-CONTRACT STATE CHANGED]
5. ETH sent to attackerContract -> receive() callback
6. In callback, attacker can interact with:
   - Minter.mint() - sees modified capital AND totalSupply
   - Minter.getMintAmount() - calculates with new ratios
   - Any other protocol reading floor.capital() or xvix.totalSupply()
```

**Mathematical Attack Analysis:**

Let:
- C = initial capital
- S = initial totalSupply
- B = burnAmount
- R = refundAmount = C * B / S * 0.9

After burn but during callback:
- capital = C - R
- totalSupply = S - B

**Minter.getMaxMintAmount(X) calculation:**
```
Before attack: X * S / C
During callback: X * (S - B) / (C - R)
                = X * (S - B) / (C - C*B*0.9/S)
                = X * (S - B) / (C * (1 - B*0.9/S))
                = X * (S - B) * S / (C * (S - B*0.9))
```

If B is large relative to S:
- Numerator: S - B (decreases)
- Denominator: S - B*0.9 (decreases slower because of 0.9 factor)

This creates a **temporary price dislocation** during the callback!

---

## CRITICAL VULNERABILITY #2: XVIX transfer() Read-Only Reentrancy

```solidity
// XVIX.sol
function transfer(address _recipient, uint256 _amount) public override returns (bool) {
    _transfer(msg.sender, _recipient, _amount);  // (1) Balance updates
    rebase();  // (2) normalDivisor changes AFTER external call!
    return true;
}

function _transfer(...) private {
    // ... balance calculations ...
    _decreaseBalance(_sender, senderAmount);
    _increaseBalance(_recipient, receiverAmount);
    // ... fund and burn logic ...
    _emitFloorPrice();  // EXTERNAL CALL to floor.capital()
}

function _emitFloorPrice() private {
    if (_isContract(floor)) {
        emit FloorPrice(IFloor(floor).capital(), totalSupply());  // External view call
    }
}
```

**Issue: State Transition Window**

During `_emitFloorPrice()`:
- Balances are updated with OLD normalDivisor
- External call is made to `floor.capital()` (view function)
- After this, `rebase()` changes normalDivisor
- `totalSupply()` will return DIFFERENT value after rebase

**Impact for Other Protocols:**
Any protocol that reads `xvix.totalSupply()` or `xvix.balanceOf()` during this window
will see values that will change after the transaction completes.

---

## CRITICAL VULNERABILITY #3: Minter.mint() State Manipulation

```solidity
// Minter.sol
function mint(address _receiver) public payable nonReentrant {
    require(active, "Minter: not active");
    require(ethReserve > 0, "Minter: insufficient eth reserve");
    require(msg.value > 0, "Minter: insufficient value");

    uint256 toMint = getMintAmount(msg.value);  // (1) Read floor.capital() and totalSupply
    require(toMint > 0, "Minter: mint amount is zero");

    IXVIX(xvix).mint(_receiver, toMint);  // (2) Mint tokens - increases totalSupply
    ethReserve = ethReserve.add(msg.value);  // (3) Update local reserve

    (bool success,) = floor.call{value: msg.value}("");  // (4) EXTERNAL CALL to floor!
    require(success, "Minter: transfer to floor failed");

    emit Mint(_receiver, toMint);
    emit FloorPrice(IFloor(floor).capital(), IERC20(xvix).totalSupply());
}
```

**Attack Flow:**
```
1. Attacker calls minter.mint{value: X}(attackerContract)
2. toMint = getMintAmount(X)  [Based on current capital and totalSupply]
3. xvix.mint(attacker, toMint)  [totalSupply INCREASES]
4. ethReserve += X  [Local state updated]
5. floor.call{value: X}("")  [External call to Floor's receive()]
6. Floor's receive() adds to capital  [capital INCREASES]
7. Transaction completes with new capital and totalSupply
```

**Floor.receive() is protected by nonReentrant**, but during step 5:
- totalSupply has ALREADY increased (step 3)
- capital has NOT YET increased (happens in step 6)

If Floor's receive() could be manipulated or if another contract reads during this window...

---

## COMBINED ATTACK: Flash Loan + Cross-Contract Manipulation

**Prerequisites:**
1. XVIX tokens for burning
2. ETH for minting
3. Flash loan capability

**Attack Sequence:**
```solidity
contract XVIXAttack {
    function attack() external {
        // 1. Flash loan XVIX tokens
        // 2. Flash loan ETH

        // 3. Call floor.refund() with large burnAmount
        //    This triggers callback to this contract
    }

    receive() external payable {
        // During callback from floor.refund():
        // - capital is reduced
        // - totalSupply is reduced (after burn)

        // 4. Call minter.mint() with all ETH
        //    getMintAmount() sees:
        //    - Lower capital (good for attacker - higher max mint)
        //    - Lower totalSupply (changes getMaxMintAmount calculation)

        // 5. The mint amount could be manipulated
        //    to mint more tokens than fair value
    }

    // 6. Repay flash loans, keep profit
}
```

---

## ECONOMIC ANALYSIS

**Protocol TVL Query Needed:**
- Floor contract capital (ETH)
- Current XVIX totalSupply
- Minter ethReserve
- Current market price vs floor price

**Profit Calculation:**
```
If attack can mint 10% more tokens than fair value:
- Flash loan cost: ~0.09% per loan
- Gas cost: ~0.1-1 ETH depending on complexity
- Net profit: 10% of mint value - costs

If floor capital = 100 ETH:
- Potential profit = 10 ETH - 0.1 ETH gas - 0.09 ETH loan fee
- Net: ~9.8 ETH
```

---

## VERIFICATION STEPS

1. **Check Current State on Mainnet:**
   - Floor contract: capital value
   - Minter contract: ethReserve, active status
   - XVIX contract: totalSupply, normalDivisor

2. **Fork Test:**
   - Simulate floor.refund() with callback
   - Check minter.getMintAmount() during callback
   - Calculate if manipulation is profitable

3. **Gas Cost Analysis:**
   - Multiple cross-contract calls
   - Storage reads/writes
   - ETH transfers

---

## CONCLUSION

| Vulnerability | Severity | Complexity | Profit Potential |
|--------------|----------|------------|------------------|
| Floor.refund cross-contract | HIGH | MEDIUM | Depends on TVL |
| XVIX transfer read-only | MEDIUM | HIGH | Oracle manipulation |
| Minter.mint state window | MEDIUM | MEDIUM | Small window |
| Combined flash loan attack | HIGH | HIGH | Scales with TVL |

**Next Step: Fork test to verify economic feasibility**
