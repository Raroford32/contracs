# Deep Manual Analysis: Exchange Contract (0x2a0c0dbe)
## Balance: 16,524 ETH

## Contract Overview
- Solidity ^0.4.16 (OLD - no SafeMath library, no ReentrancyGuard)
- Order-book style exchange with admin-controlled trading
- Supports ETH (address(0)) and any ERC20 token

## CRITICAL VULNERABILITY #1: depositToken() CEI VIOLATION

```solidity
function depositToken(address token, uint256 amount) {
    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);  // EFFECT FIRST!
    lastActiveTransaction[msg.sender] = block.number;
    if (!Token(token).transferFrom(msg.sender, this, amount)) throw;  // INTERACTION AFTER!
    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);
}
```

**Pattern**: EFFECTS before INTERACTIONS (CEI VIOLATED)

**Attack Vector with ERC-777 Token**:
1. Attacker uses ERC-777 token with `tokensToSend` hook
2. Calls `depositToken(erc777Token, amount)`
3. Balance increased: `tokens[token][attacker] += amount`
4. `transferFrom` triggers `tokensToSend` hook on sender
5. During callback, attacker's balance is already inflated
6. Attacker can re-enter `trade()` (if they are admin) or other functions

**Mitigation by Contract**:
- `withdraw()` requires `inactivityReleasePeriod` (100,000 blocks ~ 14 days)
- `trade()` is `onlyAdmin`
- `adminWithdraw()` is `onlyAdmin`

**Exploitability**: LOW - Admin controls mitigate, but design flaw exists

---

## CRITICAL VULNERABILITY #2: Fake Token Attack (No Whitelist)

```solidity
function depositToken(address token, uint256 amount) {
    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);
    lastActiveTransaction[msg.sender] = block.number;
    if (!Token(token).transferFrom(msg.sender, this, amount)) throw;
    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);
}
```

**No token whitelist** - ANY contract address can be used as "token"

**Attack Vector**:
1. Attacker deploys MaliciousToken that:
   - `transferFrom()` returns `true` but transfers nothing
   - `transfer()` reverts (to lock victim funds)
2. Attacker deposits fake tokens
3. If admin executes trade matching attacker's fake tokens against real tokens...
4. Real tokens transferred to attacker's balance
5. Attacker can withdraw real tokens (after inactivity period)

**Mitigation**: Admin controls trade execution
**Exploitability**: MEDIUM if admin is compromised or careless

---

## VULNERABILITY #3: adminWithdraw lastActiveTransaction Update After External Call

```solidity
function adminWithdraw(...) onlyAdmin returns (bool success) {
    // ... checks and balance updates ...
    tokens[token][user] = safeSub(tokens[token][user], amount);  // Balance updated
    // ... fee calculations ...
    if (token == address(0)) {
      if (!user.send(amount)) throw;
    } else {
      if (!Token(token).transfer(user, amount)) throw;  // EXTERNAL CALL
    }
    lastActiveTransaction[user] = block.number;  // Updated AFTER external call
    Withdraw(token, user, amount, tokens[token][user]);
}
```

**Pattern**: State update after external call
**Issue**: `lastActiveTransaction[user]` updated after `Token.transfer()`

During ERC-777 `tokensReceived` hook:
- User's balance already reduced
- But `lastActiveTransaction` not yet updated
- Could allow user to call `withdraw()` if previous lastActiveTransaction was old enough

**Attack Scenario**:
1. User had old deposit (lastActiveTransaction is old)
2. Admin calls adminWithdraw for user with ERC-777 token
3. During `tokensReceived` callback, user calls `withdraw()` for remaining balance
4. `withdraw()` passes because lastActiveTransaction is still old
5. User double-withdraws before lastActiveTransaction update

**Exploitability**: MEDIUM - Requires ERC-777 token and specific timing

---

## VULNERABILITY #4: Cross-Function Reentrancy via Token Callbacks

### Scenario A: depositToken -> withdraw
```
depositToken(erc777Token, X)
  -> tokens[token][msg.sender] += X  (balance inflated)
  -> transferFrom() -> tokensToSend callback
    -> Can't call withdraw() (inactivityReleasePeriod blocks)
```
**Result**: Blocked by inactivity period

### Scenario B: withdraw -> deposit (during ERC-777 tokensReceived)
```
withdraw(token, amount)
  -> tokens[token][msg.sender] -= amount
  -> Token.transfer() -> tokensReceived callback
    -> Call deposit() to add ETH
    -> Call depositToken() with different token
```
**Result**: Could manipulate multiple token balances in single tx
**Exploitability**: LOW - Limited practical impact

### Scenario C: adminWithdraw -> depositToken
```
adminWithdraw(erc777Token, amount, user, ...)
  -> tokens[token][user] -= amount
  -> Token.transfer(user) -> tokensReceived callback on user
    -> user calls depositToken(otherToken, X)
    -> user's balance for otherToken increased
    -> but lastActiveTransaction will be updated twice
```
**Result**: State inconsistency possible

---

## VULNERABILITY #5: Read-Only Reentrancy

```solidity
function balanceOf(address token, address user) constant returns (uint256) {
    return tokens[token][user];
}
```

During token transfer callbacks:
- `tokens[token][user]` may show inconsistent state
- If external contract relies on this for pricing/calculations
- Could be exploited for oracle manipulation

**Exploitability**: LOW for this contract (no internal use of balanceOf)
**Cross-Protocol Risk**: HIGH if other contracts read this

---

## VULNERABILITY #6: Integer Precision Loss in Trade

```solidity
// In trade():
tokens[tradeAddresses[1]][tradeAddresses[3]] = safeAdd(
    tokens[tradeAddresses[1]][tradeAddresses[3]],
    safeMul(safeMul(((1 ether) - tradeValues[7]), tradeValues[1]), tradeValues[4]) / tradeValues[0] / (1 ether)
);
```

Multiple divisions can cause precision loss:
- `(a * b * c) / d / e` instead of `(a * b * c) / (d * e)`
- Rounding errors accumulate

**Attack Vector**:
1. Create orders with values that maximize precision loss
2. Extract dust amounts from many trades
3. Accumulate significant value over time

**Exploitability**: LOW - Requires many transactions, admin control

---

## ECONOMIC ANALYSIS

**Contract Balance**: 16,524 ETH (~$50M at $3000/ETH)

**Attack Requirements**:
1. ERC-777 token attack: Need token listed/used on exchange
2. Fake token attack: Need admin collusion or compromise
3. Precision attack: Need many trades + admin permission

**Realistic Attack Scenarios**:
1. **Admin Key Compromise**: Most likely attack vector
   - Compromise admin key
   - Execute trades draining user balances
   - adminWithdraw all funds

2. **Social Engineering**: Get admin to list malicious token
   - Create legitimate-looking ERC-777 token
   - Exploit during deposits/withdrawals

**Profit Calculation**:
- If 50% of 16,524 ETH is user funds vs protocol reserves
- Potential extraction: ~8,000 ETH
- At $3000/ETH: ~$24M

---

## CONCLUSION

| Vulnerability | Severity | Exploitability | Requires |
|--------------|----------|----------------|----------|
| depositToken CEI | MEDIUM | LOW | ERC-777 + admin collab |
| Fake Token | HIGH | MEDIUM | Admin mistake/compromise |
| adminWithdraw timing | MEDIUM | MEDIUM | ERC-777 + specific state |
| Cross-function reentry | MEDIUM | LOW | ERC-777 |
| Read-only reentry | LOW | LOW | Cross-protocol integration |
| Precision loss | LOW | LOW | Many trades |

**Most Viable Attack**: Admin key compromise + malicious withdrawals

**Recommendation**: Deep investigation of admin wallet security and transaction history
