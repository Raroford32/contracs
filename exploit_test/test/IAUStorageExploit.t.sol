// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract IAUStorageExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    // Address found at offset 1632 in IAU
    address constant FOUND_ADDR = 0xa2336f8FB8612D039631024eA9Bf09c424A9503a;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_CheckFoundAddress() public view {
        console.log("=== CHECKING ADDRESS FROM IAU BYTECODE ===\n");

        console.log("FOUND_ADDR:", FOUND_ADDR);
        console.log("Code size:", FOUND_ADDR.code.length);

        if (FOUND_ADDR.code.length > 0) {
            bytes memory code = FOUND_ADDR.code;
            console.log("\nFunction selectors:");

            bytes4[] memory uniqueSels = new bytes4[](30);
            uint selCount = 0;

            for (uint i = 0; i + 4 < code.length; i++) {
                if (uint8(code[i]) == 0x63) {
                    bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                    if (sel == 0xffffffff || sel == bytes4(0)) continue;

                    bool isUnique = true;
                    for (uint j = 0; j < selCount; j++) {
                        if (uniqueSels[j] == sel) {
                            isUnique = false;
                            break;
                        }
                    }

                    if (isUnique && selCount < 30) {
                        uniqueSels[selCount] = sel;
                        selCount++;
                    }
                }
            }

            for (uint i = 0; i < selCount; i++) {
                console.logBytes4(uniqueSels[i]);
            }

            // Check storage
            console.log("\nStorage:");
            for (uint i = 0; i < 5; i++) {
                bytes32 slot = vm.load(FOUND_ADDR, bytes32(i));
                if (slot != bytes32(0)) {
                    console.log("  Slot", i, ":");
                    console.logBytes32(slot);
                }
            }
        } else {
            console.log("No code deployed");
        }
    }

    function test_DumpAllIAUStorage() public view {
        console.log("=== DUMPING ALL IAU STORAGE ===\n");

        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(IAU, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);

                // Try to interpret as address
                address addr = address(uint160(uint256(slot)));
                if (addr.code.length > 0) {
                    console.log("  As address:", addr);
                    console.log("  Code size:", addr.code.length);
                }
            }
        }
    }

    function test_TraceIAUMinterFunctions() public {
        console.log("=== TRACING IAU MINTER FUNCTIONS ===\n");

        // 0xaa271e1a is isMinter
        // 0x983b2d56 might be addMinter
        // 0x3092afd5 might be removeMinter

        console.log("Known selectors:");
        console.log("isMinter(address):");
        console.logBytes4(bytes4(keccak256("isMinter(address)")));
        console.log("addMinter(address):");
        console.logBytes4(bytes4(keccak256("addMinter(address)")));
        console.log("renounceMinting():");
        console.logBytes4(bytes4(keccak256("renounceMinting()")));

        // Try calling as REDEMPTION_0 (which is a minter)
        vm.startPrank(REDEMPTION_0);

        // Try to add attacker as minter
        (bool s1,) = IAU.call(
            abi.encodeWithSelector(bytes4(0x983b2d56), attacker)
        );
        console.log("addMinter(attacker) as REDEMPTION_0:", s1);

        vm.stopPrank();

        // Check if attacker is now minter
        (bool s2, bytes memory d2) = IAU.staticcall(
            abi.encodeWithSelector(bytes4(0xaa271e1a), attacker)
        );
        if (s2) {
            console.log("Is attacker minter:", abi.decode(d2, (bool)));
        }
    }

    function test_InvestigateMintFlow() public {
        console.log("=== INVESTIGATING MINT FLOW ===\n");

        // If REDEMPTION_0/1 can mint IAU, could we mint a lot and then redeem it?

        uint256 iauSupplyBefore = IERC20(IAU).balanceOf(address(0)); // Not right, just checking

        // Try mint as REDEMPTION_0
        vm.startPrank(REDEMPTION_0);

        console.log("Trying mint functions as REDEMPTION_0:");

        // 0x449a52f8 was found - try it
        (bool s1, bytes memory d1) = IAU.call(
            abi.encodeWithSelector(bytes4(0x449a52f8), attacker, 1000000e18)
        );
        console.log("0x449a52f8(attacker, 1M):", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        // Try standard mint
        (bool s2, bytes memory d2) = IAU.call(
            abi.encodeWithSignature("mint(address,uint256)", attacker, 1000000e18)
        );
        console.log("mint(attacker, 1M):", s2);
        if (!s2 && d2.length >= 4) {
            console.logBytes4(bytes4(d2));
        }

        vm.stopPrank();

        uint256 attackerIAU = IERC20(IAU).balanceOf(attacker);
        console.log("Attacker IAU balance:", attackerIAU / 1e18);
    }

    function test_CheckDelegationTargetSlot() public view {
        console.log("=== CHECKING DELEGATION TARGET SLOT ===\n");

        // The DELEGATECALL at 492 uses SLOAD at 471
        // The push before SLOAD shows what slot it reads

        bytes memory code = IAU.code;

        // Look at bytes before offset 471 to find the slot number
        console.log("Bytecode before SLOAD at 471:");
        for (uint i = 460; i <= 475 && i < code.length; i++) {
            uint8 op = uint8(code[i]);
            console.log(i, "opcode:", op);

            if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                console.log("  PUSH value:", val);
            }
        }
    }

    function test_TryAddMinterDirectly() public {
        console.log("=== TRYING TO ADD MINTER DIRECTLY ===\n");

        // Check who owns IAU
        bytes32 ownerSlot = vm.load(IAU, bytes32(uint256(5)));
        address owner = address(uint160(uint256(ownerSlot)));
        console.log("IAU owner (slot 5):", owner);

        // Prank as owner and try to add minter
        vm.startPrank(owner);

        (bool s1,) = IAU.call(
            abi.encodeWithSelector(bytes4(0x983b2d56), attacker)
        );
        console.log("addMinter as owner:", s1);

        vm.stopPrank();

        // Check if attacker is minter
        (bool s2, bytes memory d2) = IAU.staticcall(
            abi.encodeWithSelector(bytes4(0xaa271e1a), attacker)
        );
        if (s2) {
            console.log("Attacker is minter:", abi.decode(d2, (bool)));
        }
    }

    function test_ExploreIAUSelectors() public {
        console.log("=== EXPLORING IAU SELECTORS ===\n");

        // Try to figure out what each selector does

        // 0x79cc6790 - burn?
        // 0xdd62ed3e - allowance
        // 0x578063dd - ?
        // 0xe30c3978 - pendingOwner?
        // 0xf2fde38b - transferOwnership
        // 0xbdacb303 - ?
        // 0xd33219b4 - ?
        // 0x9816f473 - ?
        // 0x983b2d56 - addMinter
        // 0xa9059cbb - transfer
        // 0x8da5cb5b - owner
        // 0x95d89b41 - symbol
        // 0x42966c68 - burn(uint256)
        // 0x70a08231 - balanceOf
        // 0x715018a6 - renounceOwnership
        // 0x79ba5097 - acceptOwnership
        // 0x449a52f8 - mint?
        // 0x6b32810b - mintersCount?
        // 0x23b872dd - transferFrom
        // 0x3092afd5 - removeMinter
        // 0x313ce567 - decimals
        // 0x06fdde03 - name
        // 0x095ea7b3 - approve
        // 0x18160ddd - totalSupply
        // 0x91815260 - ?
        // 0xc4a11628 - ?
        // 0x43000818 - ?

        console.log("Testing 0xd33219b4:");
        (bool s1, bytes memory d1) = IAU.staticcall(abi.encodeWithSelector(bytes4(0xd33219b4)));
        if (s1 && d1.length >= 32) {
            console.log("  Returns:", uint256(bytes32(d1)));
        }

        console.log("Testing 0x9816f473:");
        (bool s2, bytes memory d2) = IAU.staticcall(abi.encodeWithSelector(bytes4(0x9816f473)));
        if (s2 && d2.length >= 32) {
            console.log("  Returns:", uint256(bytes32(d2)));
            console.log("  As address:", address(uint160(uint256(bytes32(d2)))));
        }

        console.log("Testing 0xbdacb303:");
        (bool s3, bytes memory d3) = IAU.staticcall(abi.encodeWithSelector(bytes4(0xbdacb303)));
        if (s3 && d3.length >= 32) {
            console.log("  Returns:", uint256(bytes32(d3)));
        }

        console.log("Testing 0x91815260:");
        (bool s4, bytes memory d4) = IAU.staticcall(abi.encodeWithSelector(bytes4(0x91815260)));
        if (s4 && d4.length >= 32) {
            console.log("  Returns:", uint256(bytes32(d4)));
        }

        console.log("Testing 0xc4a11628:");
        (bool s5, bytes memory d5) = IAU.staticcall(abi.encodeWithSelector(bytes4(0xc4a11628)));
        if (s5 && d5.length >= 32) {
            console.log("  Returns:", uint256(bytes32(d5)));
        }
    }

    function test_FindMintRestrictions() public {
        console.log("=== FINDING MINT RESTRICTIONS ===\n");

        // See what error we get when trying to mint

        vm.startPrank(VAULT);
        (bool s1, bytes memory d1) = IAU.call(
            abi.encodeWithSignature("mint(address,uint256)", attacker, 100e18)
        );
        console.log("mint as VAULT:", s1);
        if (!s1) {
            console.log("  Error length:", d1.length);
            if (d1.length >= 4) {
                console.log("  Error selector:");
                console.logBytes4(bytes4(d1));
            }
            if (d1.length > 68) {
                // Might have string error
                console.log("  Full error:");
                console.logBytes(d1);
            }
        }

        vm.stopPrank();

        // Try as Timelock (owner)
        address TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;
        vm.startPrank(TIMELOCK);
        (bool s2, bytes memory d2) = IAU.call(
            abi.encodeWithSignature("mint(address,uint256)", attacker, 100e18)
        );
        console.log("mint as TIMELOCK:", s2);
        if (!s2) {
            console.log("  Error length:", d2.length);
            if (d2.length >= 4) {
                console.log("  Error selector:");
                console.logBytes4(bytes4(d2));
            }
        }
        vm.stopPrank();
    }
}
