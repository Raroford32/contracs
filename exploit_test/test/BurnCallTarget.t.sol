// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

contract BurnCallTarget is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_TraceBurnCallTarget() public view {
        console.log("=== TRACING BURN CALL TARGET ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Detailed opcodes from 3480 to 3560 to see what burn() is calling
        console.log("Opcodes 3480-3560:");

        uint i = 3480;
        while (i < 3560 && i < code.length) {
            uint8 op = uint8(code[i]);
            uint skipBytes = 0;

            if (op == 0xf1) console.log(i, "CALL");
            if (op == 0xf4) console.log(i, "DELEGATECALL");
            if (op == 0xfa) console.log(i, "STATICCALL");
            if (op == 0x5b) console.log(i, "JUMPDEST");
            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0x33) console.log(i, "CALLER");
            if (op == 0x35) console.log(i, "CALLDATALOAD");
            if (op == 0x51) console.log(i, "MLOAD");
            if (op == 0x52) console.log(i, "MSTORE");
            if (op == 0x50) console.log(i, "POP");

            if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                if (size == 4) {
                    bytes4 sel = bytes4(uint32(val));
                    console.log(i, "PUSH4:");
                    console.logBytes4(sel);
                } else if (size == 20) {
                    address addr = address(uint160(val));
                    if (addr.code.length > 0) {
                        console.log(i, "PUSH20:", addr);
                    } else if (val > 1e30) {
                        console.log(i, "PUSH20 (mask)");
                    }
                } else {
                    console.log(i, "PUSH:", val);
                }
                skipBytes = size;
            }

            i += 1 + skipBytes;
        }

        // Check what CALL at 3552 is targeting
        console.log("\nAnalyzing CALL at 3552:");

        // Before a CALL, the stack has: gas, addr, value, argsOffset, argsSize, retOffset, retSize
        // Let's look for PUSH operations that set up the target address

        console.log("Looking for target address before CALL:");
        for (uint k = 3480; k < 3552; k++) {
            if (uint8(code[k]) == 0x73) { // PUSH20
                address addr;
                bytes memory addrBytes = new bytes(20);
                for (uint m = 0; m < 20; m++) {
                    addrBytes[m] = code[k + 1 + m];
                }
                assembly {
                    addr := mload(add(addrBytes, 20))
                }
                if (addr != address(0) && (addr.code.length > 0 || uint160(addr) == type(uint160).max)) {
                    console.log("PUSH20 at", k, ":", addr);
                }
            }
            if (uint8(code[k]) == 0x54) { // SLOAD
                console.log("SLOAD at", k, "- target might come from storage");

                // Look for slot number before SLOAD
                for (uint m = (k > 5 ? k - 5 : 0); m < k; m++) {
                    if (uint8(code[m]) >= 0x60 && uint8(code[m]) <= 0x65) {
                        uint8 size = uint8(code[m]) - 0x5f;
                        uint256 slot = 0;
                        for (uint n = 0; n < size; n++) {
                            slot = slot << 8 | uint8(code[m + 1 + n]);
                        }
                        if (slot < 20) {
                            console.log("  Slot:", slot);
                        }
                    }
                }
            }
        }
    }

    function test_IdentifyBurnCallFunction() public view {
        console.log("=== IDENTIFYING WHAT BURN CALLS ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Find the function selector pushed before CALL at 3552
        // The selector is used to build calldata

        console.log("Searching for selector before CALL at 3552:");

        for (uint i = 3500; i < 3552; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                console.log("PUSH4 at", i, ":");
                console.logBytes4(sel);
            }
        }

        // Also look at selector at 3518 which is burn itself
        bytes4 burnSel = bytes4(bytes.concat(code[3519], code[3520], code[3521], code[3522]));
        console.log("\nBurn selector at 3518:");
        console.logBytes4(burnSel);

        // Check if TASSET has a burn function that burn() calls
        console.log("\nTASSET analysis:");

        (bool s1, bytes memory d1) = TASSET.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (s1) {
            console.log("TASSET owner:", abi.decode(d1, (address)));
        }

        // Check what burn selector on TASSET is
        bytes4 tassetBurn = bytes4(keccak256("burn(uint256)"));
        console.log("TASSET burn selector:");
        console.logBytes4(tassetBurn);

        bytes4 tassetBurnFrom = bytes4(keccak256("burnFrom(address,uint256)"));
        console.log("TASSET burnFrom selector:");
        console.logBytes4(tassetBurnFrom);
    }

    function test_WhatHappensDuringBurn() public {
        console.log("=== WHAT HAPPENS DURING BURN ===\n");

        // Theory: burn() might:
        // 1. Call TASSET.burn() or burnFrom() first
        // 2. Then call RC.redeem() to send wstETH to caller

        // But burn() fails - why?

        // Let's check TASSET balance and approval requirements
        console.log("TASSET checks:");
        console.log("TASSET balance of REDEMPTION_1:", IERC20(TASSET).balanceOf(REDEMPTION_1));
        console.log("TASSET balance of attacker:", IERC20(TASSET).balanceOf(attacker));

        // Give attacker TASSET
        deal(TASSET, attacker, 1000e18);
        console.log("After deal - attacker TASSET:", IERC20(TASSET).balanceOf(attacker));

        // Check TASSET's burn function requirements
        vm.startPrank(attacker);

        IERC20(TASSET).approve(REDEMPTION_1, type(uint256).max);
        console.log("Approved REDEMPTION_1");

        // Try calling TASSET.burn directly
        console.log("\nTrying TASSET.burn directly:");
        (bool s1, bytes memory d1) = TASSET.call(
            abi.encodeWithSignature("burn(uint256)", 1e18)
        );
        console.log("TASSET.burn:", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        // Try REDEMPTION_1.burn
        console.log("\nTrying REDEMPTION_1.burn:");
        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSignature("burn(uint256)", 1e18)
        );
        console.log("REDEMPTION_1.burn:", s2);
        if (!s2 && d2.length > 4) {
            console.log("Error data:");
            console.logBytes(d2);
        }

        vm.stopPrank();
    }

    function test_CheckRedemption1ForTAsset() public view {
        console.log("=== CHECKING REDEMPTION_1 FOR TASSET ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Search for TASSET address in bytecode
        bytes memory tassetBytes = abi.encodePacked(TASSET);

        console.log("Searching for TASSET in REDEMPTION_1 bytecode:");
        for (uint i = 0; i + 20 < code.length; i++) {
            bool match_ = true;
            for (uint j = 0; j < 20 && match_; j++) {
                if (code[i + j] != tassetBytes[j]) match_ = false;
            }
            if (match_) {
                console.log("  Found TASSET at offset:", i);

                // Look for what opcode uses this
                if (i > 0 && uint8(code[i-1]) == 0x73) {
                    console.log("    (PUSH20)");
                }
            }
        }

        // Check storage slots for TASSET
        console.log("\nREDEMPTION_1 storage scan for TASSET:");
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(REDEMPTION_1, bytes32(i));
            address addr = address(uint160(uint256(slot)));
            if (addr == TASSET) {
                console.log("  Found at slot", i);
            }
        }

        // Also check view functions
        console.log("\nView functions:");

        (bool s1, bytes memory d1) = REDEMPTION_1.staticcall(
            abi.encodeWithSignature("tETH()")
        );
        if (s1 && d1.length >= 32) {
            console.log("tETH():", abi.decode(d1, (address)));
        }

        (bool s2, bytes memory d2) = REDEMPTION_1.staticcall(
            abi.encodeWithSignature("TASSET()")
        );
        if (s2 && d2.length >= 32) {
            console.log("TASSET():", abi.decode(d2, (address)));
        }

        // Check for eda72134 which returns TASSET
        (bool s3, bytes memory d3) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0xeda72134))
        );
        if (s3 && d3.length >= 32) {
            console.log("eda72134():", abi.decode(d3, (address)));
        }
    }

    function test_FullBurnFlow() public {
        console.log("=== FULL BURN FLOW SIMULATION ===\n");

        // To understand burn(), let's trace what it needs:
        // 1. User calls burn(amount)
        // 2. burn() calls something (CALL at 3552)
        // 3. If that succeeds, proceeds to call RC.redeem

        // The first CALL is probably TASSET.burnFrom(caller, amount)
        // Let's verify by checking if TASSET needs to approve REDEMPTION_1

        console.log("Step 1: Check TASSET authorization");

        // Does REDEMPTION_1 have special permissions on TASSET?
        console.log("REDEMPTION_1 allowance from attacker:", IERC20(TASSET).allowance(attacker, REDEMPTION_1));

        // Check if REDEMPTION_1 is a minter/burner on TASSET
        (bool s1, bytes memory d1) = TASSET.staticcall(
            abi.encodeWithSignature("isMinter(address)", REDEMPTION_1)
        );
        if (s1 && d1.length >= 32) {
            console.log("REDEMPTION_1 isMinter:", abi.decode(d1, (bool)));
        }

        (bool s2, bytes memory d2) = TASSET.staticcall(
            abi.encodeWithSignature("isBurner(address)", REDEMPTION_1)
        );
        if (s2 && d2.length >= 32) {
            console.log("REDEMPTION_1 isBurner:", abi.decode(d2, (bool)));
        }

        // Check TASSET's burners
        console.log("\nTASSET burner checks:");
        (bool s3, bytes memory d3) = TASSET.staticcall(
            abi.encodeWithSignature("burners(address)", REDEMPTION_1)
        );
        if (s3 && d3.length > 0) {
            console.log("burners(REDEMPTION_1) returned");
        }

        // TASSET might be a minimal proxy
        console.log("\nTASSET analysis:");
        console.log("Code size:", TASSET.code.length);

        // Try to find TASSET's implementation
        bytes32 eip1967 = vm.load(TASSET, bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));
        if (eip1967 != bytes32(0)) {
            console.log("EIP-1967 impl:", address(uint160(uint256(eip1967))));
        }
    }
}
