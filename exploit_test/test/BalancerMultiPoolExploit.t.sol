// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// ============================================================================
// Multi-Pool Arbitrage and Cross-Pool Exploitation
// Testing if different pool types have exploitable interactions
// ============================================================================

interface IAsset {}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint256) external;
}

interface IVault {
    enum SwapKind { GIVEN_IN, GIVEN_OUT }

    struct BatchSwapStep {
        bytes32 poolId;
        uint256 assetInIndex;
        uint256 assetOutIndex;
        uint256 amount;
        bytes userData;
    }

    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address payable recipient;
        bool toInternalBalance;
    }

    function batchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds, int256[] memory limits, uint256 deadline) external payable returns (int256[] memory);
    function queryBatchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds) external returns (int256[] memory);
    function manageUserBalance(UserBalanceOp[] memory ops) external payable;
    function getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);

    struct UserBalanceOp {
        UserBalanceOpKind kind;
        IAsset asset;
        uint256 amount;
        address sender;
        address payable recipient;
    }

    enum UserBalanceOpKind { DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL }
}

contract BalancerMultiPoolExploit is Test {
    IVault constant VAULT = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    IWETH constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20 constant BAL = IERC20(0xba100000625a3754423978a60c9317c58a424e3D);
    IERC20 constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    IERC20 constant USDT = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);

    // Pool IDs for different pool types
    bytes32 constant BAL_WETH_POOL = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014; // 80/20 BAL-WETH
    bytes32 constant WSTETH_WETH_POOL = 0x32296969ef14eb0c6d29669c550d4a0449130230000200000000000000000080; // 50/50 wstETH-WETH
    bytes32 constant BB_A_USD_POOL = 0xa13a9247ea42d743238089903570127dda72fe4400000000000000000000035d; // Stable pool
    bytes32 constant WETH_3POOL = 0x96646936b91d6b9d7d0c47c496afbf3d6ec7b6f8000200000000000000000019; // WETH-stable

    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        attacker = address(this);
        vm.deal(attacker, 1000 ether);
        WETH.deposit{value: 500 ether}();
        WETH.approve(address(VAULT), type(uint256).max);
        BAL.approve(address(VAULT), type(uint256).max);
    }

    // ========================================================================
    // TEST: Multi-hop arbitrage through different pool types
    // ========================================================================
    function test_MultiHopArbitrage() public {
        console.log("=== MULTI-HOP ARBITRAGE ANALYSIS ===");

        // Try to find arbitrage path: WETH -> BAL -> other token -> WETH

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // First, get the price from WETH->BAL pool
        uint256 wethAmount = 1 ether;

        IVault.BatchSwapStep[] memory swap1 = new IVault.BatchSwapStep[](1);
        swap1[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,  // WETH
            assetOutIndex: 0, // BAL
            amount: wethAmount,
            userData: ""
        });

        int256[] memory deltas1 = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swap1, assets, funds);
        uint256 balFromWeth = uint256(-deltas1[0]);

        console.log("1 WETH -> BAL (80/20 pool):");
        console.log("  BAL received:", balFromWeth);

        // Check price: BAL back to WETH
        IVault.BatchSwapStep[] memory swap2 = new IVault.BatchSwapStep[](1);
        swap2[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 0,  // BAL
            assetOutIndex: 1, // WETH
            amount: balFromWeth,
            userData: ""
        });

        int256[] memory deltas2 = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swap2, assets, funds);
        uint256 wethBack = uint256(-deltas2[1]);

        console.log("\nBAL back to WETH:");
        console.log("  WETH received:", wethBack);
        console.log("  Round trip loss:", wethAmount - wethBack, "wei");
    }

    // ========================================================================
    // TEST: Internal balance manipulation
    // ========================================================================
    function test_InternalBalanceManipulation() public {
        console.log("=== INTERNAL BALANCE MANIPULATION ===");

        // Deposit WETH to internal balance
        console.log("Step 1: Deposit WETH to internal balance");

        uint256 depositAmount = 10 ether;

        IVault.UserBalanceOp[] memory ops = new IVault.UserBalanceOp[](1);
        ops[0] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
            asset: IAsset(address(WETH)),
            amount: depositAmount,
            sender: attacker,
            recipient: payable(attacker)
        });

        VAULT.manageUserBalance(ops);

        // Check internal balance
        IERC20[] memory tokens = new IERC20[](1);
        tokens[0] = IERC20(address(WETH));
        uint256[] memory balances = VAULT.getInternalBalance(attacker, tokens);

        console.log("  Internal WETH balance:", balances[0]);

        // Now swap using internal balance
        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory fundsInternal = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: true,
            recipient: payable(attacker),
            toInternalBalance: true
        });

        // Multiple swaps with internal balance
        console.log("\nStep 2: Execute 10 swaps using internal balance");

        uint256 swapAmount = 1 ether;
        uint256 totalBalReceived = 0;

        for (uint i = 0; i < 10; i++) {
            IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](1);
            swaps[0] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: swapAmount,
                userData: ""
            });

            int256[] memory limits = new int256[](2);
            limits[0] = 0;
            limits[1] = int256(swapAmount);

            int256[] memory deltas = VAULT.batchSwap(
                IVault.SwapKind.GIVEN_IN,
                swaps,
                assets,
                fundsInternal,
                limits,
                block.timestamp + 1000
            );

            totalBalReceived += uint256(-deltas[0]);
        }

        // Check final internal balances
        IERC20[] memory checkTokens = new IERC20[](2);
        checkTokens[0] = IERC20(address(WETH));
        checkTokens[1] = IERC20(address(BAL));
        uint256[] memory finalBalances = VAULT.getInternalBalance(attacker, checkTokens);

        console.log("Final internal WETH:", finalBalances[0]);
        console.log("Final internal BAL:", finalBalances[1]);
        console.log("Total BAL from swaps:", totalBalReceived);

        // Now swap all BAL back to WETH
        console.log("\nStep 3: Swap all BAL back to WETH");

        IVault.BatchSwapStep[] memory backSwap = new IVault.BatchSwapStep[](1);
        backSwap[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 0,  // BAL
            assetOutIndex: 1, // WETH
            amount: finalBalances[1],
            userData: ""
        });

        int256[] memory backLimits = new int256[](2);
        backLimits[0] = int256(finalBalances[1]);
        backLimits[1] = 0;

        try VAULT.batchSwap(
            IVault.SwapKind.GIVEN_IN,
            backSwap,
            assets,
            fundsInternal,
            backLimits,
            block.timestamp + 1000
        ) {
            // Check final WETH
            uint256[] memory endBalances = VAULT.getInternalBalance(attacker, checkTokens);
            console.log("Final internal WETH:", endBalances[0]);

            if (endBalances[0] > depositAmount) {
                console.log("PROFIT:", endBalances[0] - depositAmount, "wei WETH");
            } else {
                console.log("LOSS:", depositAmount - endBalances[0], "wei WETH");
            }
        } catch {
            console.log("Back swap failed");
        }
    }

    // ========================================================================
    // TEST: Batch operation limits
    // ========================================================================
    function test_BatchOperationLimits() public {
        console.log("=== BATCH OPERATION LIMITS ===");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Test maximum batch sizes
        uint256[] memory sizes = new uint256[](6);
        sizes[0] = 50;
        sizes[1] = 100;
        sizes[2] = 150;
        sizes[3] = 200;
        sizes[4] = 300;
        sizes[5] = 500;

        uint256 amtPerSwap = 0.01 ether;

        for (uint s = 0; s < sizes.length; s++) {
            uint256 size = sizes[s];

            IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](size);
            for (uint i = 0; i < size; i++) {
                swaps[i] = IVault.BatchSwapStep({
                    poolId: BAL_WETH_POOL,
                    assetInIndex: 1,
                    assetOutIndex: 0,
                    amount: amtPerSwap,
                    userData: ""
                });
            }

            try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds) returns (int256[] memory deltas) {
                console.log("Batch size", size, "-> SUCCESS");
                console.log("  Total WETH in:", uint256(deltas[1]));
                console.log("  Total BAL out:", uint256(-deltas[0]));
            } catch Error(string memory reason) {
                console.log("Batch size", size, "-> FAILED:", reason);
                break;
            } catch {
                console.log("Batch size", size, "-> FAILED (no reason)");
                break;
            }
        }
    }

    // ========================================================================
    // TEST: Zero amount swaps in batch
    // ========================================================================
    function test_ZeroAmountSwapsInBatch() public {
        console.log("=== ZERO AMOUNT SWAPS IN BATCH ===");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Create batch with mix of zero and non-zero amounts
        IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](5);

        swaps[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: 1 ether, // Normal
            userData: ""
        });

        swaps[1] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: 0, // Zero
            userData: ""
        });

        swaps[2] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: 1 ether, // Normal
            userData: ""
        });

        swaps[3] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: 0, // Zero
            userData: ""
        });

        swaps[4] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: 1 ether, // Normal
            userData: ""
        });

        try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds) returns (int256[] memory deltas) {
            console.log("Batch with zero amounts ACCEPTED");
            console.log("  WETH in:", uint256(deltas[1]));
            console.log("  BAL out:", uint256(-deltas[0]));
        } catch {
            console.log("Batch with zero amounts REJECTED");
        }
    }

    // ========================================================================
    // TEST: Same asset in/out (self-swap)
    // ========================================================================
    function test_SameAssetInOut() public {
        console.log("=== SAME ASSET IN/OUT TEST ===");

        IAsset[] memory assets = new IAsset[](1);
        assets[0] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Try to swap WETH to WETH in same pool
        IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](1);
        swaps[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 0, // WETH
            assetOutIndex: 0, // WETH (same)
            amount: 1 ether,
            userData: ""
        });

        try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds) returns (int256[] memory deltas) {
            console.log("Self-swap ACCEPTED");
            console.log("  Delta:", deltas[0]);
        } catch Error(string memory reason) {
            console.log("Self-swap REJECTED:", reason);
        } catch {
            console.log("Self-swap REJECTED (no reason)");
        }
    }

    // ========================================================================
    // TEST: Duplicate pool IDs in batch
    // ========================================================================
    function test_DuplicatePoolIds() public {
        console.log("=== DUPLICATE POOL IDS IN BATCH ===");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Create batch where we swap back and forth in same pool
        IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](4);

        // WETH -> BAL
        swaps[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: 1 ether,
            userData: ""
        });

        // BAL -> WETH (back)
        swaps[1] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 0,
            assetOutIndex: 1,
            amount: 0, // Will be filled from previous swap output
            userData: ""
        });

        // WETH -> BAL again
        swaps[2] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: 0, // Will be filled from previous swap output
            userData: ""
        });

        // BAL -> WETH (final)
        swaps[3] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 0,
            assetOutIndex: 1,
            amount: 0, // Will be filled from previous swap output
            userData: ""
        });

        console.log("Testing chained swaps with intermediate amounts = 0");

        try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds) returns (int256[] memory deltas) {
            console.log("Chained swaps ACCEPTED");
            console.log("  Net WETH:", deltas[1]);
            console.log("  Net BAL:", deltas[0]);

            if (deltas[1] > 0) {
                console.log("NET WETH GAINED:", uint256(deltas[1]));
            } else {
                console.log("NET WETH LOST:", uint256(-deltas[1]));
            }
        } catch Error(string memory reason) {
            console.log("Chained swaps REJECTED:", reason);
        } catch {
            console.log("Chained swaps REJECTED");
        }
    }

    // ========================================================================
    // TEST: Very large amounts (whale test)
    // ========================================================================
    function test_VeryLargeAmounts() public {
        console.log("=== VERY LARGE AMOUNT TEST ===");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Test with increasingly large amounts
        uint256[] memory amounts = new uint256[](6);
        amounts[0] = 100 ether;
        amounts[1] = 1000 ether;
        amounts[2] = 10000 ether;
        amounts[3] = 100000 ether;
        amounts[4] = 1000000 ether;
        amounts[5] = type(uint128).max;

        for (uint i = 0; i < amounts.length; i++) {
            uint256 amt = amounts[i];

            IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](1);
            swaps[0] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: amt,
                userData: ""
            });

            try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds) returns (int256[] memory deltas) {
                console.log("Amount:", amt / 1e18, "ETH");
                console.log("  BAL out:", uint256(-deltas[0]) / 1e18);
                console.log("  Rate:", uint256(-deltas[0]) * 1e18 / amt, "BAL/ETH");
            } catch {
                console.log("Amount", amt / 1e18, "ETH -> FAILED");
            }
        }
    }

    receive() external payable {}
}
