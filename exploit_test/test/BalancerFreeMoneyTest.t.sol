// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// ============================================================================
// FREE MONEY TEST
// Testing if batch operations can extract value beyond what math allows
// ============================================================================

interface IAsset {}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint256) external;
}

interface IVault {
    enum SwapKind { GIVEN_IN, GIVEN_OUT }

    struct BatchSwapStep {
        bytes32 poolId;
        uint256 assetInIndex;
        uint256 assetOutIndex;
        uint256 amount;
        bytes userData;
    }

    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address payable recipient;
        bool toInternalBalance;
    }

    function batchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds, int256[] memory limits, uint256 deadline) external payable returns (int256[] memory);
    function queryBatchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds) external returns (int256[] memory);
    function getPoolTokens(bytes32 poolId) external view returns (IERC20[] memory tokens, uint256[] memory balances, uint256 lastChangeBlock);
    function flashLoan(address recipient, IERC20[] memory tokens, uint256[] memory amounts, bytes memory userData) external;
}

interface IFlashLoanRecipient {
    function receiveFlashLoan(IERC20[] memory tokens, uint256[] memory amounts, uint256[] memory feeAmounts, bytes memory userData) external;
}

contract BalancerFreeMoneyTest is Test, IFlashLoanRecipient {
    IVault constant VAULT = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    IWETH constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20 constant BAL = IERC20(0xba100000625a3754423978a60c9317c58a424e3D);

    bytes32 constant BAL_WETH_POOL = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014;

    address attacker;
    bool inFlashLoan;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        attacker = address(this);
        vm.deal(attacker, 100000 ether);
        WETH.deposit{value: 50000 ether}();
        WETH.approve(address(VAULT), type(uint256).max);
        BAL.approve(address(VAULT), type(uint256).max);
    }

    // ========================================================================
    // TEST: Round trip profitability - can we end up with more than we started?
    // ========================================================================
    function test_RoundTripProfitability() public {
        console.log("=== ROUND TRIP PROFITABILITY TEST ===");

        uint256 wethBefore = WETH.balanceOf(attacker);
        uint256 balBefore = BAL.balanceOf(attacker);

        console.log("Starting WETH:", wethBefore / 1e18);
        console.log("Starting BAL:", balBefore / 1e18);

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Step 1: Massive batch WETH -> BAL
        uint256 numSwaps = 200;
        uint256 amtPerSwap = 10 ether;

        IVault.BatchSwapStep[] memory toBal = new IVault.BatchSwapStep[](numSwaps);
        for (uint i = 0; i < numSwaps; i++) {
            toBal[i] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: amtPerSwap,
                userData: ""
            });
        }

        int256[] memory limits1 = new int256[](2);
        limits1[0] = 0;
        limits1[1] = int256(numSwaps * amtPerSwap);

        console.log("\nStep 1: Batch WETH -> BAL");
        console.log("Swaps:", numSwaps);
        console.log("Total WETH:", numSwaps * amtPerSwap / 1e18);

        int256[] memory deltas1 = VAULT.batchSwap(
            IVault.SwapKind.GIVEN_IN,
            toBal,
            assets,
            funds,
            limits1,
            block.timestamp + 1000
        );

        uint256 balGot = uint256(-deltas1[0]);
        console.log("BAL received:", balGot);

        // Step 2: Swap ALL BAL back to WETH using GIVEN_IN
        console.log("\nStep 2: Swap BAL back to WETH");

        IVault.BatchSwapStep[] memory toWeth = new IVault.BatchSwapStep[](1);
        toWeth[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 0,
            assetOutIndex: 1,
            amount: balGot,
            userData: ""
        });

        int256[] memory limits2 = new int256[](2);
        limits2[0] = int256(balGot);
        limits2[1] = 0;

        try VAULT.batchSwap(
            IVault.SwapKind.GIVEN_IN,
            toWeth,
            assets,
            funds,
            limits2,
            block.timestamp + 1000
        ) returns (int256[] memory deltas2) {
            uint256 wethBack = uint256(-deltas2[1]);
            console.log("WETH received back:", wethBack / 1e18);

            uint256 wethAfter = WETH.balanceOf(attacker);
            uint256 balAfter = BAL.balanceOf(attacker);

            console.log("\nFinal balances:");
            console.log("WETH:", wethAfter / 1e18);
            console.log("BAL:", balAfter / 1e18);

            if (wethAfter > wethBefore) {
                console.log("\n!!! PROFIT !!!");
                console.log("WETH profit:", (wethAfter - wethBefore) / 1e18);
            } else {
                console.log("\nLOSS:", (wethBefore - wethAfter) / 1e18, "WETH");
            }
        } catch {
            console.log("Back swap failed");
        }
    }

    // ========================================================================
    // TEST: Flash loan amplified - try to profit with no capital
    // ========================================================================
    function test_FlashLoanAmplified() public {
        console.log("=== FLASH LOAN AMPLIFIED TEST ===");

        uint256 wethBefore = WETH.balanceOf(attacker);
        uint256 balBefore = BAL.balanceOf(attacker);

        console.log("Starting WETH:", wethBefore / 1e18);
        console.log("Starting BAL:", balBefore / 1e18);

        // Flash loan WETH
        uint256 flashAmount = 5000 ether;

        IERC20[] memory tokens = new IERC20[](1);
        tokens[0] = IERC20(address(WETH));

        uint256[] memory amounts = new uint256[](1);
        amounts[0] = flashAmount;

        inFlashLoan = true;

        try VAULT.flashLoan(address(this), tokens, amounts, abi.encode(flashAmount)) {
            uint256 wethAfter = WETH.balanceOf(attacker);
            uint256 balAfter = BAL.balanceOf(attacker);

            console.log("\nAfter flash loan:");
            console.log("WETH:", wethAfter / 1e18);
            console.log("BAL:", balAfter / 1e18);

            if (wethAfter > wethBefore) {
                console.log("!!! WETH PROFIT:", (wethAfter - wethBefore) / 1e18);
            }
            if (balAfter > balBefore) {
                console.log("!!! BAL PROFIT:", (balAfter - balBefore) / 1e18);
            }
        } catch Error(string memory reason) {
            console.log("Flash loan failed:", reason);
        } catch {
            console.log("Flash loan failed");
        }

        inFlashLoan = false;
    }

    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external {
        require(msg.sender == address(VAULT), "Not vault");
        require(inFlashLoan, "Not in flash loan");

        uint256 flashAmount = abi.decode(userData, (uint256));
        console.log("In flash loan with:", flashAmount / 1e18, "WETH");
        console.log("Fee:", feeAmounts[0]);

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: address(this),
            fromInternalBalance: false,
            recipient: payable(address(this)),
            toInternalBalance: false
        });

        // Strategy: Use batch swaps with the flash loaned capital
        // Try to exploit any batch vs single differences

        uint256 numSwaps = 100;
        uint256 amtPerSwap = flashAmount / numSwaps;

        IVault.BatchSwapStep[] memory toBal = new IVault.BatchSwapStep[](numSwaps);
        for (uint i = 0; i < numSwaps; i++) {
            toBal[i] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: amtPerSwap,
                userData: ""
            });
        }

        int256[] memory limits1 = new int256[](2);
        limits1[0] = 0;
        limits1[1] = int256(flashAmount);

        // Execute batch swap WETH -> BAL
        int256[] memory deltas1 = VAULT.batchSwap(
            IVault.SwapKind.GIVEN_IN,
            toBal,
            assets,
            funds,
            limits1,
            block.timestamp + 1000
        );

        uint256 balGot = uint256(-deltas1[0]);
        console.log("BAL from batch:", balGot / 1e18);

        // Swap BAL back to WETH using GIVEN_OUT (request exact flash amount back)
        IVault.BatchSwapStep[] memory toWeth = new IVault.BatchSwapStep[](1);
        toWeth[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 0,
            assetOutIndex: 1,
            amount: amounts[0] + feeAmounts[0], // Need to repay loan + fee
            userData: ""
        });

        int256[] memory limits2 = new int256[](2);
        limits2[0] = int256(balGot); // Can spend all BAL
        limits2[1] = 0;

        try VAULT.batchSwap(
            IVault.SwapKind.GIVEN_OUT,
            toWeth,
            assets,
            funds,
            limits2,
            block.timestamp + 1000
        ) returns (int256[] memory deltas2) {
            uint256 balSpent = uint256(deltas2[0]);
            console.log("BAL spent to get WETH back:", balSpent / 1e18);

            if (balGot > balSpent) {
                console.log("!!! LEFTOVER BAL:", (balGot - balSpent) / 1e18);
            }

            // Repay flash loan
            uint256 totalOwed = amounts[0] + feeAmounts[0];
            tokens[0].transfer(address(VAULT), totalOwed);
        } catch Error(string memory reason) {
            console.log("GIVEN_OUT failed:", reason);
            // If GIVEN_OUT fails, try GIVEN_IN
            toWeth[0].amount = balGot;
            limits2[0] = int256(balGot);

            int256[] memory deltas3 = VAULT.batchSwap(
                IVault.SwapKind.GIVEN_IN,
                toWeth,
                assets,
                funds,
                limits2,
                block.timestamp + 1000
            );

            uint256 wethBack = uint256(-deltas3[1]);
            console.log("WETH from GIVEN_IN:", wethBack / 1e18);

            uint256 totalOwed = amounts[0] + feeAmounts[0];
            if (wethBack >= totalOwed) {
                tokens[0].transfer(address(VAULT), totalOwed);
            } else {
                console.log("Cannot repay, short by:", (totalOwed - wethBack) / 1e18);
                revert("Cannot repay flash loan");
            }
        } catch {
            console.log("GIVEN_OUT failed unexpectedly");
            revert("Swap failed");
        }
    }

    // ========================================================================
    // TEST: Multiple pools - can we arbitrage between pools?
    // ========================================================================
    function test_CrossPoolArbitrage() public {
        console.log("=== CROSS POOL ARBITRAGE TEST ===");

        // Other WETH pools that might have different rates
        bytes32 WSTETH_WETH_POOL = 0x32296969ef14eb0c6d29669c550d4a0449130230000200000000000000000080;

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Check rate in BAL-WETH pool
        IVault.BatchSwapStep[] memory swap1 = new IVault.BatchSwapStep[](1);
        swap1[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: 1 ether,
            userData: ""
        });

        int256[] memory delta1 = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swap1, assets, funds);
        uint256 balPerWeth = uint256(-delta1[0]);

        console.log("BAL-WETH pool rate:");
        console.log("  1 WETH -> BAL:", balPerWeth / 1e18);

        // Get BAL, then check what we can get back for it
        uint256 balAmount = balPerWeth;

        IVault.BatchSwapStep[] memory swap2 = new IVault.BatchSwapStep[](1);
        swap2[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 0,
            assetOutIndex: 1,
            amount: balAmount,
            userData: ""
        });

        int256[] memory delta2 = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swap2, assets, funds);
        uint256 wethBack = uint256(-delta2[1]);

        console.log("\nRound trip:");
        console.log("  BAL back to WETH:", wethBack / 1e18);
        console.log("  Loss:", (1 ether - wethBack) * 100 / 1 ether, "%");
    }

    // ========================================================================
    // TEST: Exploit through internal balance
    // ========================================================================
    function test_InternalBalanceExploit() public {
        console.log("=== INTERNAL BALANCE EXPLOIT ===");

        uint256 wethBefore = WETH.balanceOf(attacker);

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        // Use internal balance for cheaper gas
        IVault.FundManagement memory fundsToInternal = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: true
        });

        IVault.FundManagement memory fundsFromInternal = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: true,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Batch swap to internal balance
        uint256 numSwaps = 100;
        uint256 amtPerSwap = 1 ether;

        IVault.BatchSwapStep[] memory toBal = new IVault.BatchSwapStep[](numSwaps);
        for (uint i = 0; i < numSwaps; i++) {
            toBal[i] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: amtPerSwap,
                userData: ""
            });
        }

        int256[] memory limits1 = new int256[](2);
        limits1[0] = 0;
        limits1[1] = int256(numSwaps * amtPerSwap);

        console.log("Batch WETH -> BAL (to internal balance)");

        int256[] memory deltas1 = VAULT.batchSwap(
            IVault.SwapKind.GIVEN_IN,
            toBal,
            assets,
            fundsToInternal,
            limits1,
            block.timestamp + 1000
        );

        uint256 balGot = uint256(-deltas1[0]);
        console.log("BAL in internal balance:", balGot / 1e18);

        // Now swap back from internal balance
        IVault.BatchSwapStep[] memory toWeth = new IVault.BatchSwapStep[](1);
        toWeth[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 0,
            assetOutIndex: 1,
            amount: balGot,
            userData: ""
        });

        int256[] memory limits2 = new int256[](2);
        limits2[0] = int256(balGot);
        limits2[1] = 0;

        int256[] memory deltas2 = VAULT.batchSwap(
            IVault.SwapKind.GIVEN_IN,
            toWeth,
            assets,
            fundsFromInternal,
            limits2,
            block.timestamp + 1000
        );

        uint256 wethBack = uint256(-deltas2[1]);
        console.log("WETH received back:", wethBack / 1e18);

        uint256 wethAfter = WETH.balanceOf(attacker);

        console.log("\nFinal check:");
        console.log("Started with:", wethBefore / 1e18, "WETH");
        console.log("Ended with:", wethAfter / 1e18, "WETH");

        if (wethAfter > wethBefore) {
            console.log("!!! PROFIT:", (wethAfter - wethBefore) / 1e18, "WETH !!!");
        } else {
            console.log("Loss:", (wethBefore - wethAfter) / 1e18, "WETH");
        }
    }

    receive() external payable {}
}
