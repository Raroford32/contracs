// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Compound III (Comet) Exploit Analysis
 * @notice Analyzing if the MultiplicativePriceFeed staleness bug can be exploited
 *         in Compound III WETH market where WBTC uses this feed
 *
 * Key Finding: The WBTC price feed in WETH Comet uses MultiplicativePriceFeed
 *              which only returns updatedAt from one of two underlying feeds,
 *              potentially hiding staleness of the other feed.
 */

interface IComet {
    function supply(address asset, uint amount) external;
    function withdraw(address asset, uint amount) external;
    function borrowBalanceOf(address account) external view returns (uint256);
    function collateralBalanceOf(address account, address asset) external view returns (uint128);
    function getAssetInfo(uint8 i) external view returns (
        uint8 offset,
        address asset,
        address priceFeed,
        uint64 scale,
        uint64 borrowCollateralFactor,
        uint64 liquidateCollateralFactor,
        uint64 liquidationFactor,
        uint128 supplyCap
    );
    function numAssets() external view returns (uint8);
    function baseToken() external view returns (address);
    function getPrice(address priceFeed) external view returns (uint256);
    function absorb(address absorber, address[] calldata accounts) external;
    function isLiquidatable(address account) external view returns (bool);
    function isBorrowCollateralized(address account) external view returns (bool);
    function baseBorrowMin() external view returns (uint256);
    function getSupplyRate(uint utilization) external view returns (uint64);
}

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
}

interface IWETH {
    function deposit() external payable;
    function withdraw(uint256) external;
    function approve(address, uint256) external returns (bool);
    function balanceOf(address) external view returns (uint256);
}

interface IPriceFeed {
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
    function priceFeedA() external view returns (address);
    function priceFeedB() external view returns (address);
    function decimals() external view returns (uint8);
}

interface IBalancerVault {
    function flashLoan(
        address recipient,
        address[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;
}

contract CompoundIIIExploit is Test {
    address constant COMET_WETH = 0xA17581A9E3356d9A858b789D68B4d866e593aE94;
    address constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant WBTC_PRICE_FEED = 0xd98Be00b5D27fc98112BdE293e487f8D4cA57d07; // MultiplicativePriceFeed
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

    string constant RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    function setUp() public {
        vm.createSelectFork(RPC_URL);
    }

    function test_AnalyzeCometWBTCMarket() public view {
        console.log("=== Compound III WETH Market WBTC Analysis ===\n");

        IComet comet = IComet(COMET_WETH);

        // Find WBTC in the collateral list
        uint8 numAssets = comet.numAssets();
        console.log("Number of collateral assets:", numAssets);

        for (uint8 i = 0; i < numAssets; i++) {
            (,address asset, address priceFeed, uint64 scale, uint64 borrowCF, uint64 liquidateCF,,) = comet.getAssetInfo(i);
            if (asset == WBTC) {
                console.log("\nWBTC Found at index:", i);
                console.log("  Price Feed:", priceFeed);
                console.log("  Scale:", scale);
                console.log("  Borrow CF:", borrowCF);
                console.log("  Liquidate CF:", liquidateCF);

                // Get price
                uint256 price = comet.getPrice(priceFeed);
                console.log("  Current Price:", price);

                // Analyze the multiplicative feed
                IPriceFeed feed = IPriceFeed(priceFeed);
                address feedA = feed.priceFeedA();
                address feedB = feed.priceFeedB();

                console.log("\n  Feed A (WBTC/BTC):", feedA);
                console.log("  Feed B (BTC/ETH):", feedB);

                // Get staleness of both feeds
                (, int256 priceA,,uint256 updatedAtA,) = IPriceFeed(feedA).latestRoundData();
                (, int256 priceB,,uint256 updatedAtB,) = IPriceFeed(feedB).latestRoundData();

                console.log("\n  Feed A price:", uint256(priceA));
                console.log("  Feed A staleness:", (block.timestamp - updatedAtA) / 60, "minutes");

                console.log("\n  Feed B price:", uint256(priceB));
                console.log("  Feed B staleness:", (block.timestamp - updatedAtB) / 60, "minutes");

                // Get combined feed data
                (, int256 combinedPrice,,uint256 combinedUpdatedAt,) = feed.latestRoundData();
                console.log("\n  Combined price:", uint256(combinedPrice));
                console.log("  Combined reported staleness:", (block.timestamp - combinedUpdatedAt) / 60, "minutes");

                // Check if there's hidden staleness
                uint256 realStaleness = block.timestamp - (updatedAtA < updatedAtB ? updatedAtA : updatedAtB);
                uint256 reportedStaleness = block.timestamp - combinedUpdatedAt;

                if (realStaleness > reportedStaleness) {
                    console.log("\n  *** HIDDEN STALENESS DETECTED ***");
                    console.log("  Real staleness:", realStaleness / 60, "minutes");
                    console.log("  Reported staleness:", reportedStaleness / 60, "minutes");
                }
            }
        }
    }

    function test_CheckExploitFeasibility() public view {
        console.log("=== Exploit Feasibility Analysis ===\n");

        IComet comet = IComet(COMET_WETH);

        // Get WBTC info
        (,, address priceFeed,, uint64 borrowCF,,,) = comet.getAssetInfo(6); // WBTC is index 6

        console.log("WBTC Borrow Collateral Factor:", borrowCF);
        console.log("(In basis points, 10000 = 100%)");

        // Calculate how much can be borrowed
        // If borrowCF = 7000, you can borrow 70% of collateral value

        uint256 wbtcPrice = comet.getPrice(priceFeed);
        console.log("\nWBTC price in ETH:", wbtcPrice);

        // If we deposit 1 WBTC worth $100k and price is stale
        // And real price is 5% lower ($95k)
        // At 70% CF, we can borrow 0.7 * $100k = $70k
        // But collateral is only worth $95k
        // If we default, protocol loses $70k - $95k * liquidation bonus = negative
        // Wait, we need price to be HIGHER in oracle than reality to profit

        console.log("\nExploit Logic:");
        console.log("1. Wait for oracle to become stale");
        console.log("2. If real WBTC price drops below oracle price:");
        console.log("   - Deposit WBTC valued at (stale higher) oracle price");
        console.log("   - Borrow WETH against inflated collateral value");
        console.log("   - If price continues to drop, loan becomes undercollateralized");
        console.log("   - Keep borrowed WETH, let position get liquidated");
        console.log("   - Profit = borrowed value - real collateral value");

        console.log("\nRequirements:");
        console.log("- Oracle must be stale (FOUND: 10+ hours)");
        console.log("- Real price must diverge from oracle price");
        console.log("- Divergence must be > (100% - borrowCF) = 30%");
        console.log("- This is a significant market movement requirement");

        console.log("\nCurrent Status:");
        console.log("- Oracle IS stale (10+ hours on Feed B)");
        console.log("- BUT price hasn't moved significantly");
        console.log("- CANNOT immediately exploit without price movement");
    }

    function test_FindAlternativeAttacks() public view {
        console.log("=== Alternative Attack Vector Analysis ===\n");

        // Check if there are any other issues with the Comet market

        IComet comet = IComet(COMET_WETH);

        console.log("Base Token:", comet.baseToken());
        console.log("Base Borrow Min:", comet.baseBorrowMin());

        // Check all collateral assets for potential issues
        uint8 numAssets = comet.numAssets();

        console.log("\nAll Collateral Assets:");
        for (uint8 i = 0; i < numAssets; i++) {
            (,address asset, address priceFeed,,,,,) = comet.getAssetInfo(i);

            // Try to detect if it's a multiplicative feed
            try IPriceFeed(priceFeed).priceFeedA() returns (address feedA) {
                address feedB = IPriceFeed(priceFeed).priceFeedB();

                // Get staleness
                (,,,uint256 updatedAtA,) = IPriceFeed(feedA).latestRoundData();
                (,,,uint256 updatedAtB,) = IPriceFeed(feedB).latestRoundData();

                uint256 stalenessA = block.timestamp - updatedAtA;
                uint256 stalenessB = block.timestamp - updatedAtB;

                console.log("\nAsset", i, "- MULTIPLICATIVE FEED");
                console.log("  Feed A staleness:", stalenessA / 60, "min");
                console.log("  Feed B staleness:", stalenessB / 60, "min");

                // Flag if significantly stale
                if (stalenessA > 3600 || stalenessB > 3600) {
                    console.log("  *** STALE ORACLE DETECTED ***");
                }
            } catch {
                // Not a multiplicative feed, check regular staleness
                try IPriceFeed(priceFeed).latestRoundData() returns (
                    uint80, int256, uint256, uint256 updatedAt, uint80
                ) {
                    uint256 staleness = block.timestamp - updatedAt;
                    if (staleness > 3600) {
                        console.log("Asset stale:", i, staleness / 60);
                    }
                } catch {}
            }
        }
    }

    function test_Summary() public pure {
        console.log("=== COMPOUND III EXPLOIT SUMMARY ===\n");

        console.log("VULNERABILITY FOUND:");
        console.log("- MultiplicativePriceFeed returns staleness of only one feed");
        console.log("- WBTC price feed in Comet WETH has hidden staleness");
        console.log("- Feed B (BTC/ETH) was 10+ hours stale");
        console.log("- Compound's staleness check would pass (checks combined feed)");

        console.log("\nWHY NOT IMMEDIATELY EXPLOITABLE:");
        console.log("1. Need significant price divergence (>30%) to profit");
        console.log("2. Current price hasn't moved much during staleness");
        console.log("3. Attack requires real-world price to move against oracle");

        console.log("\nPOTENTIAL FUTURE EXPLOIT:");
        console.log("- Monitor for high volatility periods");
        console.log("- When BTC drops 5-10%, check if oracle is stale");
        console.log("- If stale, deposit WBTC and borrow at inflated value");
        console.log("- Let position get liquidated if price continues down");

        console.log("\nRISK RATING: MEDIUM");
        console.log("- Bug exists but requires external market conditions");
        console.log("- Not immediately profitable in current state");
    }
}
