// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// Exact copy of PriceFormula from BAMM
contract PriceFormula {
    function getSumFixedPoint(uint256 x, uint256 y, uint256 A) public pure returns(uint) {
        if(x == 0 && y == 0) return 0;

        uint256 sum = x + y;

        for(uint256 i = 0 ; i < 255 ; i++) {
            uint256 dP = sum;
            dP = dP * sum / ((x * 2) + 1);
            dP = dP * sum / ((y * 2) + 1);

            uint256 prevSum = sum;

            uint256 n = (A * 2 * (x + y) + (dP * 2)) * sum;
            uint256 d = (A * 2 - 1) * sum;
            sum = n / (d + dP * 3);

            if(sum <= prevSum + 1 && prevSum <= sum + 1) break;
        }

        return sum;
    }

    function getReturn(uint256 xQty, uint256 xBalance, uint256 yBalance, uint256 A) public pure returns(uint256) {
        uint256 sum = getSumFixedPoint(xBalance, yBalance, A);

        uint256 c = sum * sum / ((xQty + xBalance) * 2);
        c = c * sum / (A * 4);
        uint256 b = (xQty + xBalance) + (sum / (A * 2));
        uint256 yPrev = 0;
        uint256 y = sum;

        for(uint256 i = 0 ; i < 255 ; i++) {
            yPrev = y;
            uint256 n = y * y + c;
            uint256 d = y * 2 + b - sum;
            y = n / d;

            if(y <= yPrev + 1 && yPrev <= y + 1) break;
        }

        return yBalance - y - 1;
    }
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
}

contract PriceFormulaOverflow is Test {
    PriceFormula formula;
    address constant THUSD = 0xCFC5bD99915aAa815401C5a41A927aB7a38d29cf;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        formula = new PriceFormula();
    }

    function testFindContractWithTHUSD() public view {
        console.log("====================================================");
        console.log("FINDING CONTRACTS WITH HIGH THUSD BALANCE");
        console.log("====================================================");

        uint256 balance = IERC20(THUSD).balanceOf(0x097f1ee62E63aCFC3Bf64c1a61d96B3771dd06cB);
        console.log("BAMM THUSD:", balance / 1e18);

        uint256 supply = IERC20(THUSD).totalSupply();
        console.log("THUSD supply:", supply / 1e18);
    }

    function testOverflowInSumFixedPoint() public {
        console.log("====================================================");
        console.log("TESTING getSumFixedPoint OVERFLOW");
        console.log("====================================================");

        // Test case 1: Large x, small y - this caused overflow
        console.log("\n--- Testing x=1e30, y=1 ---");
        try formula.getSumFixedPoint(1e30, 1, 20) returns (uint256 result) {
            console.log("Result:", result);
        } catch {
            console.log("OVERFLOW DETECTED!");
            console.log("Finding threshold...");
            uint256 maxX = _findOverflowThreshold(1);
            console.log("Max x before overflow (y=1):", maxX);
        }

        // Test case 2: Both large
        console.log("\n--- Testing x=1e25, y=1e25 ---");
        try formula.getSumFixedPoint(1e25, 1e25, 20) returns (uint256 result) {
            console.log("Result:", result);
        } catch {
            console.log("OVERFLOW DETECTED!");
        }

        // Test case 3: Realistic pool values with edge
        console.log("\n--- Testing realistic edge case ---");
        uint256 thusdBalance = 50_000_000e18;
        uint256 extremeCollateralUsd = 1e30;
        uint256 yBalance = thusdBalance + (extremeCollateralUsd * 2);

        console.log("xBalance:", thusdBalance / 1e18);

        try formula.getSumFixedPoint(thusdBalance, yBalance, 20) returns (uint256 result) {
            console.log("Result:", result);
        } catch {
            console.log("OVERFLOW with extreme values!");
        }
    }

    function _findOverflowThreshold(uint256 y) internal view returns (uint256) {
        uint256 low = 1e18;
        uint256 high = 1e77;

        while (low < high - 1) {
            uint256 mid = (low + high) / 2;
            try formula.getSumFixedPoint(mid, y, 20) {
                low = mid;
            } catch {
                high = mid;
            }
        }

        return low;
    }

    function testGetReturnOverflow() public view {
        console.log("====================================================");
        console.log("TESTING getReturn OVERFLOW");
        console.log("====================================================");

        uint256 xBalance = 50_000_000e18;
        uint256 yBalance = 50_000_000e18;
        uint256 xQty = 50_000_000e18;

        console.log("Testing: xQty=50M, xBalance=50M, yBalance=50M, A=20");
        try formula.getReturn(xQty, xBalance, yBalance, 20) returns (uint256 result) {
            console.log("Result:", result / 1e18);
        } catch {
            console.log("OVERFLOW DETECTED!");
        }

        console.log("\nTesting: xQty=1, xBalance=50M, yBalance=50M, A=20");
        try formula.getReturn(1, xBalance, yBalance, 20) returns (uint256 result) {
            console.log("Result:", result);
            console.log("Return for 1 wei input!");
        } catch {
            console.log("OVERFLOW DETECTED!");
        }
    }

    function testExploitableScenario() public view {
        console.log("====================================================");
        console.log("SEARCHING FOR EXPLOITABLE SCENARIO");
        console.log("====================================================");

        console.log("\nTesting Newton convergence with various A values:");

        uint256 xBalance = 100e18;
        uint256 yBalance = 100e18;
        uint256 xQty = 10e18;

        for (uint256 A = 1; A <= 200; A += 20) {
            try formula.getReturn(xQty, xBalance, yBalance, A) returns (uint256 result) {
                console.log("A:", A, "Return:", result / 1e18);
            } catch {
                console.log("A:", A, "REVERTED");
            }
        }

        console.log("\n--- Testing imbalanced pools ---");
        uint256 xBal = 100e18;
        uint256 yBal = 10000e18;

        try formula.getReturn(50e18, xBal, yBal, 20) returns (uint256 result) {
            console.log("Imbalanced return:", result / 1e18);
            uint256 expectedRatio = result * 100 / yBal;
            console.log("Got % of y:", expectedRatio);
        } catch {
            console.log("REVERTED");
        }
    }

    function testPrecisionLoss() public view {
        console.log("====================================================");
        console.log("TESTING PRECISION LOSS EXPLOITS");
        console.log("====================================================");

        uint256 xBalance = 50_000_000e18;
        uint256 yBalance = 100_000_000e18;

        console.log("Pool: 50M THUSD, 100M virtual y");

        for (uint256 i = 0; i < 10; i++) {
            uint256 input = 10 ** i;

            try formula.getReturn(input, xBalance, yBalance, 20) returns (uint256 result) {
                console.log("Input:", input, "Output:", result);
                if (result > input) {
                    console.log("*** PROFIT: Output > Input! ***");
                }
            } catch {
                console.log("Input:", input, "REVERTED");
            }
        }
    }

    function testRoundingDirection() public view {
        console.log("====================================================");
        console.log("TESTING ROUNDING DIRECTION");
        console.log("====================================================");

        uint256 xBalance = 1e18;
        uint256 yBalance = 1e18;
        uint256 xQty = 2e18;

        console.log("Testing: swap more than xBalance");
        try formula.getReturn(xQty, xBalance, yBalance, 20) returns (uint256 result) {
            console.log("Result:", result);
            console.log("This should underflow if y > yBalance!");
        } catch {
            console.log("REVERTED (expected - y > yBalance causes underflow)");
        }
    }
}
