// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

interface IComet {
    function supply(address asset, uint256 amount) external;
    function withdraw(address asset, uint256 amount) external;
    function getSupplyRate(uint256 utilization) external view returns (uint64);
    function getBorrowRate(uint256 utilization) external view returns (uint64);
    function totalSupply() external view returns (uint256);
    function totalBorrow() external view returns (uint256);
    function getUtilization() external view returns (uint256);
    function baseToken() external view returns (address);
    function getAssetInfo(uint8 i) external view returns (
        uint8 offset,
        address asset,
        address priceFeed,
        uint64 scale,
        uint64 borrowCollateralFactor,
        uint64 liquidateCollateralFactor,
        uint64 liquidationFactor,
        uint128 supplyCap
    );
    function numAssets() external view returns (uint8);
    function userBasic(address user) external view returns (int104, uint64, uint64, uint16, int104);
}

interface IEigenStrategy {
    function sharesToUnderlyingView(uint256 amountShares) external view returns (uint256);
    function underlyingToSharesView(uint256 amountUnderlying) external view returns (uint256);
    function userUnderlyingView(address user) external view returns (uint256);
    function totalShares() external view returns (uint256);
    function underlyingToken() external view returns (address);
}

interface IStrategyManager {
    function depositIntoStrategy(address strategy, address token, uint256 amount) external returns (uint256);
    function stakerStrategyShares(address staker, address strategy) external view returns (uint256);
}

contract CompoundEigenExploit is Test {
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant STETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;
    address constant COMET_USDC = 0xc3d688B66703497DAA19211EEdff47f25384cdc3;
    address constant EIGEN_STETH_STRATEGY = 0x93c4b944D05dfe6df7645A86cd2206016c51564D;
    address constant EIGEN_MANAGER = 0x858646372CC42E1A627fcE94aa7A7033e7CF075A;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testCompoundV3DeepAnalysis() public view {
        console.log("=====================================================");
        console.log("COMPOUND V3 DEEP ANALYSIS - INTEREST RATE MANIPULATION");
        console.log("=====================================================");

        IComet comet = IComet(COMET_USDC);

        uint256 totalSupply = comet.totalSupply();
        uint256 totalBorrow = comet.totalBorrow();
        uint256 utilization = comet.getUtilization();

        console.log("Total Supply:", totalSupply / 1e6, "USDC");
        console.log("Total Borrow:", totalBorrow / 1e6, "USDC");
        console.log("Utilization:", utilization * 100 / 1e18, "%");

        // Check interest rates at different utilization levels
        console.log("\n--- Interest Rate Curve ---");

        uint64 rate50 = comet.getSupplyRate(0.5e18);
        uint64 rate80 = comet.getSupplyRate(0.8e18);
        uint64 rate90 = comet.getSupplyRate(0.9e18);
        uint64 rate95 = comet.getSupplyRate(0.95e18);
        uint64 rate99 = comet.getSupplyRate(0.99e18);

        console.log("Supply APR @ 50%:", uint256(rate50) * 365 * 24 * 3600 / 1e18 * 100, "bps");
        console.log("Supply APR @ 80%:", uint256(rate80) * 365 * 24 * 3600 / 1e18 * 100, "bps");
        console.log("Supply APR @ 90%:", uint256(rate90) * 365 * 24 * 3600 / 1e18 * 100, "bps");
        console.log("Supply APR @ 95%:", uint256(rate95) * 365 * 24 * 3600 / 1e18 * 100, "bps");
        console.log("Supply APR @ 99%:", uint256(rate99) * 365 * 24 * 3600 / 1e18 * 100, "bps");

        // Check available liquidity for withdrawal (supply - borrow)
        uint256 availableLiquidity = totalSupply - totalBorrow;
        console.log("\n--- Liquidity Analysis ---");
        console.log("Available Liquidity:", availableLiquidity / 1e6, "USDC");

        // Check collateral assets
        console.log("\n--- Collateral Assets ---");
        uint8 numAssets = comet.numAssets();
        console.log("Number of collateral assets:", uint256(numAssets));

        for (uint8 i = 0; i < numAssets; i++) {
            (
                ,
                address asset,
                ,
                ,
                uint64 borrowCF,
                uint64 liquidateCF,
                ,
                uint128 supplyCap
            ) = comet.getAssetInfo(i);

            console.log("\nAsset:", asset);
            console.log("Borrow CF:", uint256(borrowCF) * 100 / 1e18, "%");
            console.log("Liquidate CF:", uint256(liquidateCF) * 100 / 1e18, "%");
            console.log("Supply Cap:", uint256(supplyCap));

            // Check actual balance
            uint256 bal = IERC20(asset).balanceOf(COMET_USDC);
            console.log("Current Balance:", bal);
        }
    }

    function testEigenLayerDeepAnalysis() public view {
        console.log("=====================================================");
        console.log("EIGENLAYER DEEP ANALYSIS - SHARE MANIPULATION");
        console.log("=====================================================");

        IEigenStrategy strategy = IEigenStrategy(EIGEN_STETH_STRATEGY);

        // Get total shares
        uint256 totalShares = strategy.totalShares();
        console.log("Total Shares:", totalShares / 1e18);

        // Get underlying token
        address underlying = strategy.underlyingToken();
        console.log("Underlying Token:", underlying);

        // Check stETH balance in strategy
        uint256 stethBalance = IERC20(STETH).balanceOf(EIGEN_STETH_STRATEGY);
        console.log("stETH in Strategy:", stethBalance / 1e18);

        // Check share to underlying conversion
        if (totalShares > 0) {
            uint256 oneShareValue = strategy.sharesToUnderlyingView(1e18);
            console.log("1 Share = stETH:", oneShareValue / 1e18);

            // Check for any discrepancy (potential inflation attack)
            uint256 impliedBalance = totalShares * oneShareValue / 1e18;
            console.log("Implied Balance:", impliedBalance / 1e18);

            if (stethBalance > impliedBalance) {
                console.log("*** EXCESS stETH ***:", (stethBalance - impliedBalance) / 1e18);
            }
        }

        // Check if first staker vulnerability exists
        if (totalShares == 0 && stethBalance > 0) {
            console.log("*** POTENTIAL FIRST STAKER ATTACK ***");
            console.log("Orphaned stETH:", stethBalance / 1e18);
        }
    }

    function testSearchForRoundingVulnerability() public view {
        console.log("=====================================================");
        console.log("SEARCHING FOR ROUNDING VULNERABILITIES");
        console.log("=====================================================");

        IEigenStrategy strategy = IEigenStrategy(EIGEN_STETH_STRATEGY);

        // Test small share conversions for rounding errors
        console.log("--- Small Share Conversions ---");

        uint256[] memory testAmounts = new uint256[](5);
        testAmounts[0] = 1;
        testAmounts[1] = 10;
        testAmounts[2] = 100;
        testAmounts[3] = 1000;
        testAmounts[4] = 1e18;

        for (uint i = 0; i < testAmounts.length; i++) {
            uint256 shares = testAmounts[i];
            uint256 underlying = strategy.sharesToUnderlyingView(shares);
            uint256 sharesBack = strategy.underlyingToSharesView(underlying);

            console.log("\nShares:", shares);
            console.log("-> Underlying:", underlying);
            console.log("-> Back to Shares:", sharesBack);

            if (sharesBack > shares) {
                console.log("*** ROUNDING PROFIT ***");
            }
        }
    }

    function testCompoundLiquidationAnalysis() public {
        console.log("=====================================================");
        console.log("COMPOUND V3 LIQUIDATION ANALYSIS");
        console.log("=====================================================");

        IComet comet = IComet(COMET_USDC);

        // Find liquidatable positions
        // In Compound V3, positions become liquidatable when collateral value falls below
        // the borrowed amount * liquidation factor

        // We would need to enumerate positions through events or known addresses
        // For now, let's check the liquidation incentive

        console.log("Liquidation analysis requires position enumeration");
        console.log("Checking general parameters...");

        // Check if we can manipulate price feeds
        // Compound uses Chainlink - not directly manipulable

        console.log("\nOracle: Chainlink (not manipulable)");
        console.log("Liquidation: Requires underwater position");
    }

    function testInterestRateArbitrage() public {
        console.log("=====================================================");
        console.log("INTEREST RATE ARBITRAGE ANALYSIS");
        console.log("=====================================================");

        IComet comet = IComet(COMET_USDC);

        uint256 currentUtil = comet.getUtilization();
        console.log("Current Utilization:", currentUtil * 100 / 1e18, "%");

        // Calculate how much supply is needed to move utilization
        uint256 totalSupply = comet.totalSupply();
        uint256 totalBorrow = comet.totalBorrow();

        // To move from 90% to 80% utilization:
        // new_supply = borrow / 0.8
        // delta = new_supply - current_supply

        if (currentUtil > 0.85e18) {
            uint256 targetUtil = 0.8e18;
            uint256 newSupplyNeeded = totalBorrow * 1e18 / targetUtil;
            uint256 deltaSupply = newSupplyNeeded - totalSupply;

            console.log("\n--- To reduce utilization to 80% ---");
            console.log("Additional supply needed:", deltaSupply / 1e6, "USDC");

            // Calculate potential profit from rate change
            uint64 currentRate = comet.getSupplyRate(currentUtil);
            uint64 newRate = comet.getSupplyRate(targetUtil);

            console.log("Current supply rate:", uint256(currentRate));
            console.log("New supply rate:", uint256(newRate));

            if (currentRate > newRate) {
                console.log("Rate would decrease - not profitable for supplier manipulation");
            }
        }
    }
}
