// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Morpho Blue Market Search
 * @notice Find sUSDe markets with high LLTV that could be exploitable
 */

interface IMorphoBlue {
    struct MarketParams {
        address loanToken;
        address collateralToken;
        address oracle;
        address irm;
        uint256 lltv;
    }

    struct Market {
        uint128 totalSupplyAssets;
        uint128 totalSupplyShares;
        uint128 totalBorrowAssets;
        uint128 totalBorrowShares;
        uint128 lastUpdate;
        uint128 fee;
    }

    struct Position {
        uint256 supplyShares;
        uint128 borrowShares;
        uint128 collateral;
    }

    function market(bytes32 id) external view returns (Market memory);
    function idToMarketParams(bytes32 id) external view returns (MarketParams memory);
    function position(bytes32 id, address user) external view returns (Position memory);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function decimals() external view returns (uint8);
    function symbol() external view returns (string memory);
}

interface IChainlinkOracle {
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
}

interface IMorphoOracle {
    function price() external view returns (uint256);
}

contract MorphoMarketSearch is Test {
    address constant MORPHO_BLUE = 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb;
    address constant SUSDE = 0x9D39A5DE30e57443BfF2A8307A4256c8797A3497;
    address constant USDE = 0x4c9EDD5852cd905f086C759E8383e09bff1E68B3;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    // DAI address removed - not critical for search
    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;

    // USDe oracle
    address constant USDE_ORACLE = 0xa569d910839Ae8865Da8F8e70FfFb0cBA869F961;

    string constant RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    // Known Morpho market IDs (from Morpho subgraph/docs)
    // These are keccak256 hashes of MarketParams
    bytes32[] public marketIds;

    function setUp() public {
        vm.createSelectFork(RPC_URL);

        // Add known sUSDe market IDs
        // These IDs come from Morpho's official documentation and subgraph

        // sUSDe/USDC markets at various LLTVs
        marketIds.push(bytes32(0xb323495f7e4148be5643a4ea4a8221eef163e4bccfdedc2a6f4696baacbc86cc)); // sUSDe/USDC 86%
        marketIds.push(bytes32(0x1247f1c237eceae0602eab1470a5061a6dd8f734ba88c7cdc5d6109fb0026b28)); // sUSDe/DAI 91.5%
        marketIds.push(bytes32(0xdc5333039bcf15f1237f7eb0b8f0e51d7e9dcda8df4ef4a01d9b17e5b4c59e26)); // sUSDe/USDC 94.5%
    }

    function test_SearchForHighLLTVSUSDeMarkets() public view {
        console.log("=== MORPHO BLUE sUSDe MARKET SEARCH ===\n");

        IMorphoBlue morpho = IMorphoBlue(MORPHO_BLUE);

        console.log("Total sUSDe in Morpho:", IERC20(SUSDE).balanceOf(MORPHO_BLUE) / 1e18);

        // Check USDe oracle staleness
        (, int256 usdePrice,, uint256 usdeUpdatedAt,) = IChainlinkOracle(USDE_ORACLE).latestRoundData();
        uint256 usdeStaleness = block.timestamp - usdeUpdatedAt;

        console.log("\nUSDe Oracle Status:");
        console.log("  Price:", uint256(usdePrice));
        console.log("  Staleness:", usdeStaleness / 3600, "hours");

        console.log("\n--- Checking Known Market IDs ---");

        for (uint i = 0; i < marketIds.length; i++) {
            bytes32 marketId = marketIds[i];

            try morpho.market(marketId) returns (IMorphoBlue.Market memory m) {
                if (m.totalSupplyAssets > 0) {
                    console.log("\nMarket ID:", i);

                    IMorphoBlue.MarketParams memory params = morpho.idToMarketParams(marketId);

                    console.log("  Loan Token:", params.loanToken);
                    console.log("  Collateral Token:", params.collateralToken);
                    console.log("  Oracle:", params.oracle);
                    console.log("  LLTV:", params.lltv / 1e16, "%");
                    console.log("  Total Supply:", m.totalSupplyAssets);
                    console.log("  Total Borrow:", m.totalBorrowAssets);

                    // Check if collateral is sUSDe
                    if (params.collateralToken == SUSDE) {
                        console.log("  *** sUSDe COLLATERAL MARKET ***");

                        // Calculate divergence needed
                        uint256 divergenceNeeded = (1e18 - params.lltv) * 100 / 1e18;
                        console.log("  Divergence needed to exploit:", divergenceNeeded, "%");

                        if (divergenceNeeded <= 10) {
                            console.log("  !!! HIGH RISK - EXPLOITABLE WITH <10% PRICE MOVE !!!");
                        }
                    }
                }
            } catch {}
        }
    }

    function test_CalculateSUSDeOracleDeviation() public view {
        console.log("=== sUSDe PRICE DEVIATION ANALYSIS ===\n");

        // Check current USDe oracle price
        (, int256 usdePrice,, uint256 usdeUpdatedAt,) = IChainlinkOracle(USDE_ORACLE).latestRoundData();
        uint256 usdeStaleness = block.timestamp - usdeUpdatedAt;

        console.log("USDe Chainlink Oracle:");
        console.log("  Price:", uint256(usdePrice));
        console.log("  Staleness:", usdeStaleness / 3600, "hours");

        // sUSDe has its own exchange rate
        // sUSDe = staked USDe, so 1 sUSDe > 1 USDe due to yield

        // Check sUSDe value
        uint256 susdeBalance = IERC20(SUSDE).balanceOf(MORPHO_BLUE);
        console.log("\nsUSDe in Morpho:", susdeBalance / 1e18);

        // The key question: is the oracle price accurate?
        // During 13 hours of staleness, USDe could have moved

        console.log("\n=== EXPLOIT SCENARIO ===");
        console.log("If USDe real price drops during staleness:");
        console.log("1. Oracle still shows old (higher) price");
        console.log("2. sUSDe collateral valued at old price");
        console.log("3. Borrow more than collateral is worth");
        console.log("4. Keep borrowed funds, collateral gets liquidated at loss");

        console.log("\nFor 94.5% LLTV market:");
        console.log("- Only need 5.5% price drop during staleness");
        console.log("- Current staleness: 13+ hours");
        console.log("- Check if USDe moved >5.5% in this time");
    }

    function test_CheckLiveMarketData() public {
        console.log("=== LIVE MORPHO MARKET DATA ===\n");

        IMorphoBlue morpho = IMorphoBlue(MORPHO_BLUE);

        // Try to enumerate markets by checking common market params
        // sUSDe/USDC with different LLTVs

        address[] memory loanTokens = new address[](3);
        loanTokens[0] = USDC;
        loanTokens[1] = address(bytes20(hex"6B175474E89094C44Da98b954EeedfFe44fCBD3E")); // DAI
        loanTokens[2] = USDT;

        uint256[] memory lltvsToCheck = new uint256[](5);
        lltvsToCheck[0] = 770000000000000000; // 77%
        lltvsToCheck[1] = 860000000000000000; // 86%
        lltvsToCheck[2] = 915000000000000000; // 91.5%
        lltvsToCheck[3] = 945000000000000000; // 94.5%
        lltvsToCheck[4] = 965000000000000000; // 96.5%

        console.log("Searching for sUSDe collateral markets...");

        for (uint i = 0; i < loanTokens.length; i++) {
            for (uint j = 0; j < lltvsToCheck.length; j++) {
                // Compute market ID
                bytes32 marketId = _computeMarketId(
                    loanTokens[i],
                    SUSDE,
                    address(0), // We don't know the oracle
                    address(0), // We don't know the IRM
                    lltvsToCheck[j]
                );

                try morpho.market(marketId) returns (IMorphoBlue.Market memory m) {
                    if (m.totalSupplyAssets > 0) {
                        console.log("\nFOUND MARKET!");
                        console.log("  Loan Token:", loanTokens[i]);
                        console.log("  LLTV:", lltvsToCheck[j] / 1e16, "%");
                        console.log("  Total Supply:", m.totalSupplyAssets);
                    }
                } catch {}
            }
        }
    }

    function _computeMarketId(
        address loanToken,
        address collateralToken,
        address oracle,
        address irm,
        uint256 lltv
    ) internal pure returns (bytes32) {
        return keccak256(abi.encode(loanToken, collateralToken, oracle, irm, lltv));
    }

    function test_DirectMarketQuery() public view {
        console.log("=== DIRECT MORPHO MARKET QUERY ===\n");

        // Known high-value sUSDe market from Morpho analytics
        // This ID is from Morpho's official dashboard

        bytes32 knownId = 0xb323495f7e4148be5643a4ea4a8221eef163e4bccfdedc2a6f4696baacbc86cc;

        IMorphoBlue morpho = IMorphoBlue(MORPHO_BLUE);

        console.log("Querying known sUSDe market...");

        try morpho.market(knownId) returns (IMorphoBlue.Market memory m) {
            console.log("Market found!");
            console.log("  Total Supply Assets:", m.totalSupplyAssets);
            console.log("  Total Borrow Assets:", m.totalBorrowAssets);
            console.log("  Last Update:", m.lastUpdate);

            // Get params
            IMorphoBlue.MarketParams memory params = morpho.idToMarketParams(knownId);
            console.log("\nMarket Parameters:");
            console.log("  Loan Token:", params.loanToken);
            console.log("  Collateral Token:", params.collateralToken);
            console.log("  Oracle:", params.oracle);
            console.log("  LLTV:", params.lltv);

            // Check oracle
            if (params.oracle != address(0)) {
                console.log("\nChecking oracle...");
                try IMorphoOracle(params.oracle).price() returns (uint256 price) {
                    console.log("  Oracle Price:", price);
                } catch {
                    console.log("  Oracle price() call failed");
                }
            }
        } catch {
            console.log("Market not found with this ID");
        }

        // Try another known ID
        bytes32 knownId2 = 0x1247f1c237eceae0602eab1470a5061a6dd8f734ba88c7cdc5d6109fb0026b28;

        try morpho.market(knownId2) returns (IMorphoBlue.Market memory m) {
            console.log("\n--- Second Market ---");
            console.log("  Total Supply:", m.totalSupplyAssets);

            IMorphoBlue.MarketParams memory params = morpho.idToMarketParams(knownId2);
            console.log("  LLTV:", params.lltv / 1e16, "%");
            console.log("  Collateral:", params.collateralToken);
        } catch {}
    }
}
