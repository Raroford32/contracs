// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract ErrorAndConditions is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_DecodeErrors() public view {
        console.log("=== DECODING ERRORS ===\n");

        bytes4 err1 = bytes4(0xa0927dc3);
        bytes4 err2 = bytes4(0xfb8f41b2);

        console.log("Error 0xa0927dc3:");
        console.logBytes4(err1);

        console.log("\nError 0xfb8f41b2:");
        console.logBytes4(err2);

        // Try many more error signatures
        string[60] memory errors = [
            "EpochCapReached()",
            "CapExceeded()",
            "ExceedsEpochCap()",
            "OverEpochCap()",
            "EpochLimitReached()",
            "QuotaExceeded()",
            "RedemptionCapHit()",
            "MaxCapReached()",
            "DailyCapReached()",
            "WeeklyCapReached()",
            "MonthlyCapReached()",
            "PeriodCapReached()",
            "CycleCapReached()",
            "RoundCapReached()",
            "CapReached()",
            "MaxReached()",
            "LimitReached()",
            "QuotaHit()",
            "AmountExceedsCap()",
            "ExceedsLimit()",
            "ExceedsMax()",
            "ExceedsQuota()",
            "OverLimit()",
            "OverMax()",
            "OverQuota()",
            "TooMuch()",
            "TooHigh()",
            "TooLarge()",
            "ExcessAmount()",
            "CapFull()",
            "Paused()",
            "IsPaused()",
            "SystemPaused()",
            "ContractPaused()",
            "RedemptionPaused()",
            "RedeemPaused()",
            "NotActive()",
            "Inactive()",
            "Disabled()",
            "RedemptionDisabled()",
            "RedeemDisabled()",
            "Suspended()",
            "RedemptionSuspended()",
            "NotAllowed()",
            "NotPermitted()",
            "Forbidden()",
            "Blocked()",
            "Restricted()",
            "NotWhitelisted()",
            "NotRegistered()",
            "NotApproved()",
            "UnregisteredUser()",
            "InvalidUser()",
            "UserNotAllowed()",
            "AccessDenied()",
            "PermissionDenied()",
            "NoPermission()",
            "Unauthorized()",
            "OnlyWhitelisted()",
            "WhitelistRequired()"
        ];

        console.log("\nSearching for matches:");
        for (uint i = 0; i < errors.length; i++) {
            bytes4 sel = bytes4(keccak256(bytes(errors[i])));
            if (sel == err1) {
                console.log("0xa0927dc3 MATCH:", errors[i]);
            }
            if (sel == err2) {
                console.log("0xfb8f41b2 MATCH:", errors[i]);
            }
        }
    }

    function test_CheckRedemptionConditions() public view {
        console.log("=== CHECKING REDEMPTION CONDITIONS ===\n");

        // Check various conditions on REDEMPTION_0
        (bool s1, bytes memory d1) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("paused()")
        );
        if (s1 && d1.length >= 32) {
            console.log("R0 paused():", abi.decode(d1, (bool)));
        }

        (bool s2, bytes memory d2) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("active()")
        );
        if (s2 && d2.length >= 32) {
            console.log("R0 active():", abi.decode(d2, (bool)));
        }

        (bool s3, bytes memory d3) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("epochCap()")
        );
        if (s3 && d3.length >= 32) {
            console.log("R0 epochCap():", abi.decode(d3, (uint256)) / 1e18);
        }

        (bool s4, bytes memory d4) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("currentEpochRedemptions()")
        );
        if (s4 && d4.length >= 32) {
            console.log("R0 currentEpochRedemptions():", abi.decode(d4, (uint256)) / 1e18);
        }

        (bool s5, bytes memory d5) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("totalRedeeming()")
        );
        if (s5 && d5.length >= 32) {
            console.log("R0 totalRedeeming():", abi.decode(d5, (uint256)) / 1e18);
        }

        (bool s6, bytes memory d6) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("minRedeemInUnderlying()")
        );
        if (s6 && d6.length >= 32) {
            console.log("R0 minRedeemInUnderlying():", abi.decode(d6, (uint256)) / 1e18);
        }

        (bool s7, bytes memory d7) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("maxRedeemInUnderlying()")
        );
        if (s7 && d7.length >= 32) {
            console.log("R0 maxRedeemInUnderlying():", abi.decode(d7, (uint256)) / 1e18);
        }

        // Check whitelist requirement
        (bool s8, bytes memory d8) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("whitelistEnabled()")
        );
        if (s8 && d8.length >= 32) {
            console.log("R0 whitelistEnabled():", abi.decode(d8, (bool)));
        }

        (bool s9, bytes memory d9) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("isWhitelisted(address)", attacker)
        );
        if (s9 && d9.length >= 32) {
            console.log("R0 isWhitelisted(attacker):", abi.decode(d9, (bool)));
        }
    }

    function test_CheckR1Conditions() public view {
        console.log("=== CHECKING R1 CONDITIONS ===\n");

        (bool s1, bytes memory d1) = REDEMPTION_1.staticcall(
            abi.encodeWithSignature("paused()")
        );
        if (s1 && d1.length >= 32) {
            console.log("R1 paused():", abi.decode(d1, (bool)));
        }

        // Check vault balance
        uint256 vaultBal = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH balance:", vaultBal / 1e18);

        // Check REDEMPTION_1's storage for conditions
        console.log("\nR1 storage slots:");
        for (uint i = 0; i < 15; i++) {
            bytes32 slot = vm.load(REDEMPTION_1, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);

                // Try to interpret
                address addr = address(uint160(uint256(slot)));
                if (addr.code.length > 0 && uint256(slot) > 1e19) {
                    console.log("  -> Contract:", addr);
                } else if (uint256(slot) < 1e6) {
                    console.log("  -> Small value:", uint256(slot));
                }
            }
        }
    }

    function test_FindRedeemFunction() public view {
        console.log("=== FINDING EXACT REDEEM FUNCTION ===\n");

        // The error 0xa0927dc3 for 100e18 and 0xfb8f41b2 for larger amounts
        // suggests different validation paths

        // Let me check R0 bytecode for these error selectors
        bytes memory code = REDEMPTION_0.code;

        console.log("Searching for error selectors in R0:");

        uint found1 = 0;
        uint found2 = 0;
        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == bytes4(0xa0927dc3)) {
                    found1++;
                    console.log("0xa0927dc3 at:", i);
                }
                if (sel == bytes4(0xfb8f41b2)) {
                    found2++;
                    console.log("0xfb8f41b2 at:", i);
                }
            }
        }

        console.log("\n0xa0927dc3 found:", found1, "times");
        console.log("0xfb8f41b2 found:", found2, "times");
    }

    function test_InvestigateR0Flow() public {
        console.log("=== INVESTIGATING R0 REDEMPTION FLOW ===\n");

        // Let's understand what R0 does differently than R1
        // R0 has redeem(uint96) function

        vm.startPrank(attacker);
        deal(IAU, attacker, 1000000e18);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        // First check IAU balance requirements
        uint256 attackerIAU = IERC20(IAU).balanceOf(attacker);
        console.log("Attacker IAU:", attackerIAU / 1e18);

        // Check TASSET requirements
        uint256 attackerTASSET = IERC20(TASSET).balanceOf(attacker);
        console.log("Attacker TASSET:", attackerTASSET / 1e18);

        // Maybe we need TASSET not IAU?
        deal(TASSET, attacker, 100000e18);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        console.log("\nTrying redeem with TASSET approved:");
        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("redeem(1000e18):", s1);
        if (!s1 && d1.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(d1));
        }

        vm.stopPrank();
    }
}
