// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
}

interface IStrategyStorage {
    function actionRegistry() external view returns (address);
    function strategyExecutor() external view returns (address);
    function getStrategies() external view returns (address[] memory);
}

interface IActionRegistry {
    function getAddr(bytes4 _id) external view returns (address);
    function isRegistered(bytes4 _id) external view returns (bool);
    function getActionAddr(bytes4 _id) external view returns (address);
}

contract TreehouseActionRegistry is Test {
    address constant STRATEGY_STORAGE = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;
    address constant STRATEGY_0 = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant aWstETH = 0x0B925eD163218f6662a35e0f0371Ac234f9E9371;

    // Known action IDs from our investigation
    bytes4 constant LIDO_STAKE_ID = 0xd7e40b2d;
    bytes4 constant LIDO_WRAP_ID = 0x43142355;
    bytes4 constant LIDO_UNWRAP_ID = 0xacd039ef;
    bytes4 constant AAVE_SUPPLY_ID = 0xfc33bf00;
    bytes4 constant AAVE_BORROW_ID = 0x9e9290b1;
    bytes4 constant AAVE_PAYBACK_ID = 0x17683e81;
    bytes4 constant AAVE_WITHDRAW_ID = 0x72a6498a;
    bytes4 constant VAULT_PULL_ID = 0xfebcb52a;

    // Potential SendTokens IDs
    bytes4 constant SEND_TOKEN_ID = 0x02abc227;
    bytes4 constant SEND_TOKENS_ID = 0xa87d9d0e;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_GetActionRegistry() public view {
        console.log("=== TREEHOUSE ACTION REGISTRY ===\n");

        // Get ActionRegistry from StrategyStorage
        (bool success, bytes memory data) = STRATEGY_STORAGE.staticcall(
            abi.encodeWithSignature("actionRegistry()")
        );

        if (success && data.length == 32) {
            address registry = abi.decode(data, (address));
            console.log("ActionRegistry:", registry);

            // Now check what actions are registered
            console.log("\nChecking registered actions:");

            // Check known IDs
            bytes4[] memory ids = new bytes4[](12);
            ids[0] = LIDO_STAKE_ID;
            ids[1] = LIDO_WRAP_ID;
            ids[2] = LIDO_UNWRAP_ID;
            ids[3] = AAVE_SUPPLY_ID;
            ids[4] = AAVE_BORROW_ID;
            ids[5] = AAVE_PAYBACK_ID;
            ids[6] = AAVE_WITHDRAW_ID;
            ids[7] = VAULT_PULL_ID;
            ids[8] = SEND_TOKEN_ID;
            ids[9] = SEND_TOKENS_ID;
            ids[10] = 0x19713586; // Unknown from our list
            ids[11] = 0x4f18b88c; // Unknown from our list

            string[12] memory names = [
                "LidoStake",
                "LidoWrap",
                "LidoUnwrap",
                "AaveSupply",
                "AaveBorrow",
                "AavePayback",
                "AaveWithdraw",
                "VaultPull",
                "SendToken",
                "SendTokens",
                "Unknown1",
                "Unknown2"
            ];

            for (uint i = 0; i < ids.length; i++) {
                (bool s, bytes memory d) = registry.staticcall(
                    abi.encodeWithSignature("getAddr(bytes4)", ids[i])
                );
                if (s && d.length == 32) {
                    address actionAddr = abi.decode(d, (address));
                    if (actionAddr != address(0)) {
                        console.log(names[i], "registered at:", actionAddr);
                    }
                }
            }
        } else {
            console.log("Could not get ActionRegistry");
        }
    }

    function test_CheckAllKnownActionIDs() public view {
        console.log("=== CHECKING ALL KNOWN ACTION IDS ===\n");

        // Get ActionRegistry
        (bool success, bytes memory data) = STRATEGY_STORAGE.staticcall(
            abi.encodeWithSignature("actionRegistry()")
        );

        if (!success) {
            console.log("Failed to get ActionRegistry");
            return;
        }

        address registry = abi.decode(data, (address));
        console.log("ActionRegistry:", registry);

        // Known registered action IDs from FINDINGS_DelegatecallHijacking.md
        bytes4[] memory registeredIds = new bytes4[](13);
        registeredIds[0] = 0xd7e40b2d;  // LidoStake
        registeredIds[1] = 0x43142355;  // LidoWrap
        registeredIds[2] = 0xacd039ef;  // Custom
        registeredIds[3] = 0x2161dd34;  // Custom
        registeredIds[4] = 0x245077a0;  // Custom
        registeredIds[5] = 0x3d35d254;  // Custom
        registeredIds[6] = 0xfc33bf00;  // AaveV3Supply
        registeredIds[7] = 0x9e9290b1;  // AaveV3Borrow
        registeredIds[8] = 0x17683e81;  // AaveV3Payback
        registeredIds[9] = 0x72a6498a;  // AaveV3Withdraw
        registeredIds[10] = 0xfebcb52a; // VaultPull
        registeredIds[11] = 0x19713586; // Unknown
        registeredIds[12] = 0x4f18b88c; // Unknown

        console.log("\nQuerying each registered ID:");
        for (uint i = 0; i < registeredIds.length; i++) {
            (bool s, bytes memory d) = registry.staticcall(
                abi.encodeWithSignature("getAddr(bytes4)", registeredIds[i])
            );
            if (s && d.length == 32) {
                address actionAddr = abi.decode(d, (address));
                console.log("ID:");
                console.logBytes4(registeredIds[i]);
                console.log("  Address:", actionAddr);
            }
        }
    }

    function test_ReverseEngineerUnknownActions() public view {
        console.log("=== REVERSE ENGINEERING UNKNOWN ACTIONS ===\n");

        // The 3 unknown action addresses we found
        address[] memory unknowns = new address[](3);
        unknowns[0] = 0xc780112305ED959CEEeb0DE692E2407E4145Fc3A; // ID: 0x19713586
        unknowns[1] = 0x351dd4581d61BCE7101FDf5f6864D510021c7CaB; // ID: 0x4f18b88c
        unknowns[2] = 0x819Bdb303e224CaC4aC14Da17a1ec13895869b65; // ID: 0x3d35d254

        for (uint i = 0; i < unknowns.length; i++) {
            console.log("\n=== Unknown", i, "===");
            console.log("Address:", unknowns[i]);

            bytes memory code = unknowns[i].code;
            console.log("Code size:", code.length);

            // Try common function selectors
            (bool success,) = unknowns[i].staticcall(
                abi.encodeWithSignature("actionType()")
            );
            console.log("Has actionType():", success);

            // Check for token-related selectors in bytecode
            // transfer: 0xa9059cbb
            // transferFrom: 0x23b872dd
            // approve: 0x095ea7b3
            // safeTransfer: 0xb88d4fde (NFT) or custom

            uint256 transferCount = 0;
            uint256 approveCount = 0;

            for (uint j = 0; j + 4 < code.length; j++) {
                bytes4 sel = bytes4(bytes.concat(code[j], code[j+1], code[j+2], code[j+3]));
                if (sel == bytes4(0xa9059cbb)) transferCount++;
                if (sel == bytes4(0x095ea7b3)) approveCount++;
            }

            console.log("Transfer selectors:", transferCount);
            console.log("Approve selectors:", approveCount);

            // Check number of CALL and DELEGATECALL opcodes
            uint256 callCount = 0;
            uint256 delegatecallCount = 0;
            for (uint j = 0; j < code.length; j++) {
                if (uint8(code[j]) == 0xf1) callCount++;
                if (uint8(code[j]) == 0xf4) delegatecallCount++;
            }
            console.log("CALL opcodes:", callCount);
            console.log("DELEGATECALL opcodes:", delegatecallCount);
        }
    }

    function test_FetchSourceCode() public view {
        console.log("=== FETCHING SOURCE CODE HINTS ===\n");

        // For unknown actions, let's check if they have any public getters
        // that might reveal their purpose

        address[] memory unknowns = new address[](3);
        unknowns[0] = 0xc780112305ED959CEEeb0DE692E2407E4145Fc3A;
        unknowns[1] = 0x351dd4581d61BCE7101FDf5f6864D510021c7CaB;
        unknowns[2] = 0x819Bdb303e224CaC4aC14Da17a1ec13895869b65;

        string[15] memory functionNames = [
            "name()",
            "pool()",
            "token()",
            "vault()",
            "aavePool()",
            "lendingPool()",
            "registry()",
            "executeAction(bytes)",
            "executeActionDirect(bytes)",
            "getPool()",
            "router()",
            "weth()",
            "steth()",
            "wsteth()",
            "underlying()"
        ];

        for (uint i = 0; i < unknowns.length; i++) {
            console.log("--- Unknown ---");
            console.log("Index:", i);
            console.log("Address:", unknowns[i]);

            for (uint j = 0; j < functionNames.length; j++) {
                (bool success, bytes memory data) = unknowns[i].staticcall(
                    abi.encodeWithSignature(functionNames[j])
                );
                if (success && data.length > 0) {
                    console.log("  Found:", functionNames[j]);
                }
            }
        }
    }

    function test_CheckCustomActionIDs() public view {
        console.log("=== CHECKING CUSTOM ACTION IDS ===\n");

        // The custom action IDs from our findings:
        // 0xacd039ef - 0xb8cD2bA2A0Ada353aE15398618Fafb1d7BD558C5
        // 0x2161dd34 - 0x3e34E0694204e462Deaf8EBbeEE2bE9F887f3C3b
        // 0x245077a0 - 0x99eAe56224EA5Bcb2c886D0a07154217b7A1E5d1
        // 0x3d35d254 - 0x819Bdb303e224CaC4aC14Da17a1ec13895869b65

        // Let's match IDs to addresses and analyze
        console.log("Custom Action Mapping:");
        console.log("0xacd039ef -> 0xb8cD2bA2A0Ada353aE15398618Fafb1d7BD558C5 (LidoUnwrap)");
        console.log("0x2161dd34 -> 0x3e34E0694204e462Deaf8EBbeEE2bE9F887f3C3b");
        console.log("0x245077a0 -> 0x99eAe56224EA5Bcb2c886D0a07154217b7A1E5d1");
        console.log("0x3d35d254 -> 0x819Bdb303e224CaC4aC14Da17a1ec13895869b65");

        // Analyze each custom action for dangerous patterns
        address action2161dd34 = 0x3e34E0694204e462Deaf8EBbeEE2bE9F887f3C3b;
        address action245077a0 = 0x99eAe56224EA5Bcb2c886D0a07154217b7A1E5d1;
        address action3d35d254 = 0x819Bdb303e224CaC4aC14Da17a1ec13895869b65;

        // Check if any of these could be a token transfer action
        address[] memory actions = new address[](3);
        actions[0] = action2161dd34;
        actions[1] = action245077a0;
        actions[2] = action3d35d254;

        for (uint i = 0; i < actions.length; i++) {
            console.log("\n=== Custom Action", i, "===");
            console.log("Address:", actions[i]);

            // Check storage reads - might indicate what contracts it interacts with
            bytes memory code = actions[i].code;

            // Count SLOAD opcodes (storage reads)
            uint256 sloadCount = 0;
            for (uint j = 0; j < code.length; j++) {
                if (uint8(code[j]) == 0x54) sloadCount++;
            }
            console.log("SLOAD count:", sloadCount);

            // Check for common address constants
            // wstETH: 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0
            // stETH: 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84

            bool hasWstETH = false;
            bool hasStETH = false;

            for (uint j = 0; j + 20 < code.length; j++) {
                bytes20 addr;
                assembly {
                    addr := mload(add(add(code, 32), j))
                }
                if (address(addr) == 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0) hasWstETH = true;
                if (address(addr) == 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84) hasStETH = true;
            }

            console.log("Contains wstETH address:", hasWstETH);
            console.log("Contains stETH address:", hasStETH);
        }
    }
}
