// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// ============================================================================
// VAULT SOLVENCY INVARIANT TEST
//
// The savage invariant: For each token T:
//   real = IERC20(T).balanceOf(vault)
//   owed = sum(cash over pools) + sum(internalBalance over actors)
//   ASSERT: real >= owed
//
// If this fails: you have a real, exploitable accounting bug.
// ============================================================================

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint256) external;
}

interface IAsset {}

interface IVault {
    enum SwapKind { GIVEN_IN, GIVEN_OUT }
    enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }
    enum UserBalanceOpKind { DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL }

    struct BatchSwapStep {
        bytes32 poolId;
        uint256 assetInIndex;
        uint256 assetOutIndex;
        uint256 amount;
        bytes userData;
    }

    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address payable recipient;
        bool toInternalBalance;
    }

    struct UserBalanceOp {
        UserBalanceOpKind kind;
        IAsset asset;
        uint256 amount;
        address sender;
        address payable recipient;
    }

    struct JoinPoolRequest {
        IAsset[] assets;
        uint256[] maxAmountsIn;
        bytes userData;
        bool fromInternalBalance;
    }

    struct ExitPoolRequest {
        IAsset[] assets;
        uint256[] minAmountsOut;
        bytes userData;
        bool toInternalBalance;
    }

    function batchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds, int256[] memory limits, uint256 deadline) external payable returns (int256[] memory);
    function getPoolTokens(bytes32 poolId) external view returns (IERC20[] memory tokens, uint256[] memory balances, uint256 lastChangeBlock);
    function getPoolTokenInfo(bytes32 poolId, IERC20 token) external view returns (uint256 cash, uint256 managed, uint256 lastChangeBlock, address assetManager);
    function getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);
    function manageUserBalance(UserBalanceOp[] memory ops) external payable;
    function joinPool(bytes32 poolId, address sender, address recipient, JoinPoolRequest memory request) external payable;
    function exitPool(bytes32 poolId, address sender, address payable recipient, ExitPoolRequest memory request) external;
}

contract VaultSolvencyInvariant is Test {
    IVault constant VAULT = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    IWETH constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20 constant BAL = IERC20(0xba100000625a3754423978a60c9317c58a424e3D);
    IERC20 constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    // DAI not used in these tests

    // Test actors (closed world)
    address[] actors;
    address actor1;
    address actor2;
    address actor3;

    // Known pools to track
    bytes32[] trackedPools;
    bytes32 constant BAL_WETH_POOL = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014;
    bytes32 constant WSTETH_WETH_POOL = 0x32296969ef14eb0c6d29669c550d4a0449130230000200000000000000000080;

    // Tokens to track
    IERC20[] trackedTokens;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");

        // Create actors
        actor1 = makeAddr("actor1");
        actor2 = makeAddr("actor2");
        actor3 = makeAddr("actor3");

        actors.push(actor1);
        actors.push(actor2);
        actors.push(actor3);

        // Fund actors
        for (uint i = 0; i < actors.length; i++) {
            vm.deal(actors[i], 100 ether);
            vm.prank(actors[i]);
            WETH.deposit{value: 50 ether}();

            // Give BAL
            deal(address(BAL), actors[i], 10000 ether);

            // Approve vault
            vm.startPrank(actors[i]);
            WETH.approve(address(VAULT), type(uint256).max);
            BAL.approve(address(VAULT), type(uint256).max);
            vm.stopPrank();
        }

        // Track pools
        trackedPools.push(BAL_WETH_POOL);

        // Track tokens
        trackedTokens.push(IERC20(address(WETH)));
        trackedTokens.push(BAL);
    }

    // ========================================================================
    // THE SOLVENCY INVARIANT
    // ========================================================================

    function checkSolvencyInvariant() internal view returns (bool solvent, string memory failureReason) {
        for (uint t = 0; t < trackedTokens.length; t++) {
            IERC20 token = trackedTokens[t];

            // Real holdings
            uint256 real = token.balanceOf(address(VAULT));

            // Calculate owed
            uint256 owed = 0;

            // Sum cash from all tracked pools
            for (uint p = 0; p < trackedPools.length; p++) {
                (IERC20[] memory poolTokens, uint256[] memory balances,) = VAULT.getPoolTokens(trackedPools[p]);
                for (uint i = 0; i < poolTokens.length; i++) {
                    if (address(poolTokens[i]) == address(token)) {
                        // Get cash (not managed, since managed is held by asset manager)
                        (uint256 cash,,,) = VAULT.getPoolTokenInfo(trackedPools[p], token);
                        owed += cash;
                    }
                }
            }

            // Sum internal balances from all actors
            IERC20[] memory singleToken = new IERC20[](1);
            singleToken[0] = token;
            for (uint a = 0; a < actors.length; a++) {
                uint256[] memory internalBals = VAULT.getInternalBalance(actors[a], singleToken);
                owed += internalBals[0];
            }

            // THE INVARIANT
            if (real < owed) {
                return (false, string(abi.encodePacked(
                    "INSOLVENCY: Token ", vm.toString(address(token)),
                    " real=", vm.toString(real),
                    " owed=", vm.toString(owed),
                    " shortfall=", vm.toString(owed - real)
                )));
            }
        }

        return (true, "");
    }

    // ========================================================================
    // TEST: Basic solvency after various operations
    // ========================================================================

    function test_SolvencyAfterDeposits() public {
        console.log("=== SOLVENCY TEST: After Deposits ===");

        // Check initial solvency
        (bool solvent, string memory reason) = checkSolvencyInvariant();
        assertTrue(solvent, reason);
        console.log("Initial state: SOLVENT");

        // Actor 1 deposits to internal balance
        vm.startPrank(actor1);
        IVault.UserBalanceOp[] memory ops = new IVault.UserBalanceOp[](1);
        ops[0] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
            asset: IAsset(address(WETH)),
            amount: 10 ether,
            sender: actor1,
            recipient: payable(actor1)
        });
        VAULT.manageUserBalance(ops);
        vm.stopPrank();

        // Check solvency
        (solvent, reason) = checkSolvencyInvariant();
        assertTrue(solvent, reason);
        console.log("After deposit: SOLVENT");
    }

    function test_SolvencyAfterSwaps() public {
        console.log("=== SOLVENCY TEST: After Swaps ===");

        // Initial check
        (bool solvent, string memory reason) = checkSolvencyInvariant();
        assertTrue(solvent, reason);

        // Actor 1 does a swap
        vm.startPrank(actor1);

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](1);
        swaps[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: 1 ether,
            userData: ""
        });

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: actor1,
            fromInternalBalance: false,
            recipient: payable(actor1),
            toInternalBalance: false
        });

        int256[] memory limits = new int256[](2);
        limits[0] = 0;
        limits[1] = int256(2 ether);

        VAULT.batchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds, limits, block.timestamp + 1000);
        vm.stopPrank();

        // Check solvency
        (solvent, reason) = checkSolvencyInvariant();
        assertTrue(solvent, reason);
        console.log("After swap: SOLVENT");
    }

    function test_SolvencyAfterMixedOperations() public {
        console.log("=== SOLVENCY TEST: After Mixed Operations ===");

        // Initial check
        (bool solvent, string memory reason) = checkSolvencyInvariant();
        assertTrue(solvent, reason);

        // Actor 1: Deposit to internal
        vm.startPrank(actor1);
        IVault.UserBalanceOp[] memory ops1 = new IVault.UserBalanceOp[](1);
        ops1[0] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
            asset: IAsset(address(WETH)),
            amount: 5 ether,
            sender: actor1,
            recipient: payable(actor1)
        });
        VAULT.manageUserBalance(ops1);
        vm.stopPrank();

        (solvent, reason) = checkSolvencyInvariant();
        assertTrue(solvent, reason);
        console.log("After actor1 deposit: SOLVENT");

        // Actor 2: Swap using external balance
        vm.startPrank(actor2);
        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](1);
        swaps[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: 0.5 ether,
            userData: ""
        });

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: actor2,
            fromInternalBalance: false,
            recipient: payable(actor2),
            toInternalBalance: false
        });

        int256[] memory limits = new int256[](2);
        limits[0] = 0;
        limits[1] = int256(1 ether);

        VAULT.batchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds, limits, block.timestamp + 1000);
        vm.stopPrank();

        (solvent, reason) = checkSolvencyInvariant();
        assertTrue(solvent, reason);
        console.log("After actor2 swap: SOLVENT");

        // Actor 1: Withdraw from internal
        vm.startPrank(actor1);
        IVault.UserBalanceOp[] memory ops2 = new IVault.UserBalanceOp[](1);
        ops2[0] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.WITHDRAW_INTERNAL,
            asset: IAsset(address(WETH)),
            amount: 2 ether,
            sender: actor1,
            recipient: payable(actor1)
        });
        VAULT.manageUserBalance(ops2);
        vm.stopPrank();

        (solvent, reason) = checkSolvencyInvariant();
        assertTrue(solvent, reason);
        console.log("After actor1 withdraw: SOLVENT");

        // Actor 3: Internal transfer from actor1
        vm.startPrank(actor1);
        IVault.UserBalanceOp[] memory ops3 = new IVault.UserBalanceOp[](1);
        ops3[0] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.TRANSFER_INTERNAL,
            asset: IAsset(address(WETH)),
            amount: 1 ether,
            sender: actor1,
            recipient: payable(actor3)
        });
        VAULT.manageUserBalance(ops3);
        vm.stopPrank();

        (solvent, reason) = checkSolvencyInvariant();
        assertTrue(solvent, reason);
        console.log("After internal transfer: SOLVENT");
    }

    // ========================================================================
    // FUZZ: Random sequences of operations must maintain solvency
    // ========================================================================

    function testFuzz_SolvencyUnderRandomOps(uint256 seed) public {
        // Generate operation sequence from seed
        uint256 numOps = (seed % 20) + 5; // 5-25 operations

        for (uint i = 0; i < numOps; i++) {
            uint256 opSeed = uint256(keccak256(abi.encode(seed, i)));
            uint256 opType = opSeed % 4; // 4 operation types
            uint256 actorIdx = (opSeed >> 8) % actors.length;
            address actor = actors[actorIdx];

            if (opType == 0) {
                // Deposit to internal
                uint256 amt = ((opSeed >> 16) % 5 ether) + 0.01 ether;
                _tryDeposit(actor, amt);
            } else if (opType == 1) {
                // Withdraw from internal
                uint256 amt = ((opSeed >> 16) % 3 ether) + 0.001 ether;
                _tryWithdraw(actor, amt);
            } else if (opType == 2) {
                // Swap
                uint256 amt = ((opSeed >> 16) % 1 ether) + 0.001 ether;
                bool useInternal = (opSeed >> 24) % 2 == 0;
                _trySwap(actor, amt, useInternal);
            } else {
                // Internal transfer
                uint256 toIdx = (opSeed >> 32) % actors.length;
                if (toIdx != actorIdx) {
                    uint256 amt = ((opSeed >> 16) % 2 ether) + 0.001 ether;
                    _tryTransfer(actor, actors[toIdx], amt);
                }
            }

            // CHECK SOLVENCY AFTER EVERY OPERATION
            (bool solvent, string memory reason) = checkSolvencyInvariant();
            assertTrue(solvent, reason);
        }
    }

    function _tryDeposit(address actor, uint256 amt) internal {
        if (WETH.balanceOf(actor) < amt) return;

        vm.startPrank(actor);
        IVault.UserBalanceOp[] memory ops = new IVault.UserBalanceOp[](1);
        ops[0] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
            asset: IAsset(address(WETH)),
            amount: amt,
            sender: actor,
            recipient: payable(actor)
        });
        try VAULT.manageUserBalance(ops) {} catch {}
        vm.stopPrank();
    }

    function _tryWithdraw(address actor, uint256 amt) internal {
        IERC20[] memory tokens = new IERC20[](1);
        tokens[0] = IERC20(address(WETH));
        uint256[] memory bals = VAULT.getInternalBalance(actor, tokens);
        if (bals[0] < amt) amt = bals[0];
        if (amt == 0) return;

        vm.startPrank(actor);
        IVault.UserBalanceOp[] memory ops = new IVault.UserBalanceOp[](1);
        ops[0] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.WITHDRAW_INTERNAL,
            asset: IAsset(address(WETH)),
            amount: amt,
            sender: actor,
            recipient: payable(actor)
        });
        try VAULT.manageUserBalance(ops) {} catch {}
        vm.stopPrank();
    }

    function _trySwap(address actor, uint256 amt, bool useInternal) internal {
        vm.startPrank(actor);

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](1);
        swaps[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: amt,
            userData: ""
        });

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: actor,
            fromInternalBalance: useInternal,
            recipient: payable(actor),
            toInternalBalance: useInternal
        });

        int256[] memory limits = new int256[](2);
        limits[0] = 0;
        limits[1] = int256(amt * 2);

        try VAULT.batchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds, limits, block.timestamp + 1000) {} catch {}
        vm.stopPrank();
    }

    function _tryTransfer(address from, address to, uint256 amt) internal {
        IERC20[] memory tokens = new IERC20[](1);
        tokens[0] = IERC20(address(WETH));
        uint256[] memory bals = VAULT.getInternalBalance(from, tokens);
        if (bals[0] < amt) amt = bals[0];
        if (amt == 0) return;

        vm.startPrank(from);
        IVault.UserBalanceOp[] memory ops = new IVault.UserBalanceOp[](1);
        ops[0] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.TRANSFER_INTERNAL,
            asset: IAsset(address(WETH)),
            amount: amt,
            sender: from,
            recipient: payable(to)
        });
        try VAULT.manageUserBalance(ops) {} catch {}
        vm.stopPrank();
    }

    // ========================================================================
    // TEST: Event ↔ Reality Conservation
    // After each operation, ΔIERC20Balance(vault, T) must equal expected
    // ========================================================================

    function test_EventRealityConservation_Deposit() public {
        console.log("=== EVENT-REALITY: Deposit ===");

        uint256 depositAmount = 5 ether;

        // Snapshot before
        uint256 vaultWethBefore = WETH.balanceOf(address(VAULT));
        uint256 actorWethBefore = WETH.balanceOf(actor1);

        IERC20[] memory tokens = new IERC20[](1);
        tokens[0] = IERC20(address(WETH));
        uint256[] memory internalBefore = VAULT.getInternalBalance(actor1, tokens);

        // Deposit
        vm.startPrank(actor1);
        IVault.UserBalanceOp[] memory ops = new IVault.UserBalanceOp[](1);
        ops[0] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
            asset: IAsset(address(WETH)),
            amount: depositAmount,
            sender: actor1,
            recipient: payable(actor1)
        });
        VAULT.manageUserBalance(ops);
        vm.stopPrank();

        // Snapshot after
        uint256 vaultWethAfter = WETH.balanceOf(address(VAULT));
        uint256 actorWethAfter = WETH.balanceOf(actor1);
        uint256[] memory internalAfter = VAULT.getInternalBalance(actor1, tokens);

        // CONSERVATION CHECKS
        // Vault gained exactly depositAmount
        assertEq(vaultWethAfter - vaultWethBefore, depositAmount, "Vault didn't receive correct amount");

        // Actor lost exactly depositAmount
        assertEq(actorWethBefore - actorWethAfter, depositAmount, "Actor didn't send correct amount");

        // Internal balance increased by depositAmount
        assertEq(internalAfter[0] - internalBefore[0], depositAmount, "Internal balance didn't increase correctly");

        console.log("Event-Reality conservation: VERIFIED");
    }

    function test_EventRealityConservation_Withdraw() public {
        console.log("=== EVENT-REALITY: Withdraw ===");

        // First deposit
        vm.startPrank(actor1);
        IVault.UserBalanceOp[] memory depositOps = new IVault.UserBalanceOp[](1);
        depositOps[0] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
            asset: IAsset(address(WETH)),
            amount: 10 ether,
            sender: actor1,
            recipient: payable(actor1)
        });
        VAULT.manageUserBalance(depositOps);
        vm.stopPrank();

        uint256 withdrawAmount = 3 ether;

        // Snapshot before withdraw
        uint256 vaultWethBefore = WETH.balanceOf(address(VAULT));
        uint256 actorWethBefore = WETH.balanceOf(actor1);

        IERC20[] memory tokens = new IERC20[](1);
        tokens[0] = IERC20(address(WETH));
        uint256[] memory internalBefore = VAULT.getInternalBalance(actor1, tokens);

        // Withdraw
        vm.startPrank(actor1);
        IVault.UserBalanceOp[] memory withdrawOps = new IVault.UserBalanceOp[](1);
        withdrawOps[0] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.WITHDRAW_INTERNAL,
            asset: IAsset(address(WETH)),
            amount: withdrawAmount,
            sender: actor1,
            recipient: payable(actor1)
        });
        VAULT.manageUserBalance(withdrawOps);
        vm.stopPrank();

        // Snapshot after
        uint256 vaultWethAfter = WETH.balanceOf(address(VAULT));
        uint256 actorWethAfter = WETH.balanceOf(actor1);
        uint256[] memory internalAfter = VAULT.getInternalBalance(actor1, tokens);

        // CONSERVATION CHECKS
        // Vault lost exactly withdrawAmount
        assertEq(vaultWethBefore - vaultWethAfter, withdrawAmount, "Vault didn't release correct amount");

        // Actor gained exactly withdrawAmount
        assertEq(actorWethAfter - actorWethBefore, withdrawAmount, "Actor didn't receive correct amount");

        // Internal balance decreased by withdrawAmount
        assertEq(internalBefore[0] - internalAfter[0], withdrawAmount, "Internal balance didn't decrease correctly");

        console.log("Event-Reality conservation: VERIFIED");
    }

    function test_EventRealityConservation_Swap() public {
        console.log("=== EVENT-REALITY: Swap ===");

        uint256 swapAmount = 1 ether;

        // Snapshot before
        uint256 vaultWethBefore = WETH.balanceOf(address(VAULT));
        uint256 vaultBalBefore = BAL.balanceOf(address(VAULT));
        uint256 actorWethBefore = WETH.balanceOf(actor1);
        uint256 actorBalBefore = BAL.balanceOf(actor1);

        // Swap WETH -> BAL
        vm.startPrank(actor1);
        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](1);
        swaps[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: swapAmount,
            userData: ""
        });

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: actor1,
            fromInternalBalance: false,
            recipient: payable(actor1),
            toInternalBalance: false
        });

        int256[] memory limits = new int256[](2);
        limits[0] = 0;
        limits[1] = int256(swapAmount * 2);

        int256[] memory deltas = VAULT.batchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds, limits, block.timestamp + 1000);
        vm.stopPrank();

        // Snapshot after
        uint256 vaultWethAfter = WETH.balanceOf(address(VAULT));
        uint256 vaultBalAfter = BAL.balanceOf(address(VAULT));
        uint256 actorWethAfter = WETH.balanceOf(actor1);
        uint256 actorBalAfter = BAL.balanceOf(actor1);

        // CONSERVATION CHECKS
        // Deltas should match actual balance changes
        int256 expectedWethDelta = int256(vaultWethAfter) - int256(vaultWethBefore);
        int256 expectedBalDelta = int256(vaultBalAfter) - int256(vaultBalBefore);

        // For user: opposite sign
        int256 userWethChange = int256(actorWethAfter) - int256(actorWethBefore);
        int256 userBalChange = int256(actorBalAfter) - int256(actorBalBefore);

        console.log("Returned deltas[0] (BAL):", deltas[0]);
        console.log("Returned deltas[1] (WETH):", deltas[1]);
        console.log("Vault WETH change:", expectedWethDelta);
        console.log("Vault BAL change:", expectedBalDelta);
        console.log("User WETH change:", userWethChange);
        console.log("User BAL change:", userBalChange);

        // User + Vault changes must net to zero (conservation)
        assertEq(userWethChange + expectedWethDelta, 0, "WETH not conserved");
        assertEq(userBalChange + expectedBalDelta, 0, "BAL not conserved");

        console.log("Event-Reality conservation: VERIFIED");
    }

    receive() external payable {}
}
