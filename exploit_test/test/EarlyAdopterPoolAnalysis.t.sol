// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title EarlyAdopterPool Deep Analysis
 * @notice 627 ETH locked in this contract - searching for drain vector
 *
 * CONTRACT REVIEW:
 * - Users deposit ETH or LST tokens (rETH, wstETH, sfrxETH, cbETH)
 * - withdraw() returns user's own deposit
 * - claim() sends to claimReceiverContract (for points)
 *
 * KEY CHECKS:
 * - depositInfo[msg.sender].depositTime != 0 for any operation
 * - nonReentrant on withdraw/claim
 * - transferFunds does state clear BEFORE external calls
 */
contract EarlyAdopterPoolAnalysisTest is Test {
    address constant POOL = 0x7623e9DC0DA6FF821ddb9EbABA794054E078f8c4;

    // LST tokens
    address constant rETH = 0xae78736Cd615f374D3085123A210448E74Fc6393;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant sfrxETH = 0xac3E018457B222d93114458476f3E3416Abbe38F;
    address constant cbETH = 0xBe9895146f7AF43049ca1c1AE358B0541Ea49704;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function test_readPoolState() public view {
        console.log("=== EARLY ADOPTER POOL STATE ===");
        console.log("Pool Address:", POOL);
        console.log("ETH Balance:", POOL.balance / 1e18, "ETH");

        // Check claimingOpen
        (bool success, bytes memory data) = POOL.staticcall(
            abi.encodeWithSignature("claimingOpen()")
        );
        if (success && data.length >= 32) {
            uint8 claimingOpen = abi.decode(data, (uint8));
            console.log("Claiming Open:", claimingOpen);
        }

        // Check claimDeadline
        (success, data) = POOL.staticcall(
            abi.encodeWithSignature("claimDeadline()")
        );
        if (success && data.length >= 32) {
            uint256 deadline = abi.decode(data, (uint256));
            console.log("Claim Deadline:", deadline);
            if (deadline > 0) {
                console.log("Deadline passed:", block.timestamp > deadline);
            }
        }

        // Check claimReceiverContract
        (success, data) = POOL.staticcall(
            abi.encodeWithSignature("claimReceiverContract()")
        );
        if (success && data.length >= 32) {
            address receiver = abi.decode(data, (address));
            console.log("Claim Receiver:", receiver);
        }

        // Check endTime
        (success, data) = POOL.staticcall(
            abi.encodeWithSignature("endTime()")
        );
        if (success && data.length >= 32) {
            uint256 endTime = abi.decode(data, (uint256));
            console.log("End Time:", endTime);
        }

        // Check owner
        (success, data) = POOL.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (success && data.length >= 32) {
            address owner = abi.decode(data, (address));
            console.log("Owner:", owner);
        }

        // Check if paused
        (success, data) = POOL.staticcall(
            abi.encodeWithSignature("paused()")
        );
        if (success && data.length >= 32) {
            bool paused = abi.decode(data, (bool));
            console.log("Paused:", paused);
        }

        // Check TVL
        (success, data) = POOL.staticcall(
            abi.encodeWithSignature("getContractTVL()")
        );
        if (success && data.length >= 32) {
            uint256 tvl = abi.decode(data, (uint256));
            console.log("Total TVL:", tvl / 1e18, "ETH equivalent");
        }

        // Check LST token balances in pool
        console.log("");
        console.log("=== LST BALANCES IN POOL ===");

        checkTokenBalance(rETH, "rETH");
        checkTokenBalance(wstETH, "wstETH");
        checkTokenBalance(sfrxETH, "sfrxETH");
        checkTokenBalance(cbETH, "cbETH");

        console.log("================================");
    }

    function checkTokenBalance(address token, string memory name) internal view {
        (bool success, bytes memory data) = token.staticcall(
            abi.encodeWithSignature("balanceOf(address)", POOL)
        );
        if (success && data.length >= 32) {
            uint256 balance = abi.decode(data, (uint256));
            if (balance > 0) {
                console.log(name, "balance:", balance / 1e18);
            }
        }
    }

    function test_attemptUnauthorizedWithdraw() public {
        console.log("");
        console.log("=== UNAUTHORIZED WITHDRAW ATTEMPT ===");

        address attacker = address(0xDEAD);
        uint256 poolBalanceBefore = POOL.balance;
        uint256 attackerBalanceBefore = attacker.balance;

        console.log("Pool ETH before:", poolBalanceBefore / 1e18);
        console.log("Attacker ETH before:", attackerBalanceBefore / 1e18);

        // Check if attacker has any deposit
        (bool success, bytes memory data) = POOL.staticcall(
            abi.encodeWithSignature("depositInfo(address)", attacker)
        );
        if (success && data.length >= 96) {
            (uint256 depositTime, uint256 ethBal, uint256 erc20Bal) =
                abi.decode(data, (uint256, uint256, uint256));
            console.log("Attacker deposit time:", depositTime);
            console.log("Attacker ETH balance in pool:", ethBal);
            console.log("Attacker ERC20 balance in pool:", erc20Bal);
        }

        // Try to withdraw
        vm.prank(attacker);
        (success,) = POOL.call(abi.encodeWithSignature("withdraw()"));
        console.log("Withdraw succeeded:", success);

        uint256 poolBalanceAfter = POOL.balance;
        uint256 attackerBalanceAfter = attacker.balance;

        console.log("Pool ETH after:", poolBalanceAfter / 1e18);
        console.log("Attacker ETH after:", attackerBalanceAfter / 1e18);

        if (attackerBalanceAfter > attackerBalanceBefore) {
            console.log("!!! EXPLOIT: Attacker gained ETH !!!");
            console.log("Profit:", (attackerBalanceAfter - attackerBalanceBefore) / 1e18, "ETH");
        }

        console.log("=====================================");
    }

    function test_checkExistingDepositors() public view {
        console.log("");
        console.log("=== SAMPLE DEPOSITOR CHECK ===");

        // Check some common addresses that might have deposits
        // (We'd need event logs to find real depositors)

        // Let's check the contract TVL distribution
        (bool success, bytes memory data) = POOL.staticcall(
            abi.encodeWithSignature("getContractTVL()")
        );

        if (success) {
            uint256 tvl = abi.decode(data, (uint256));
            console.log("Contract TVL:", tvl / 1e18);
            console.log("Contract ETH:", POOL.balance / 1e18);

            if (tvl > POOL.balance) {
                console.log("Difference is in LST tokens");
            }
        }

        console.log("==============================");
    }

    function test_flashDepositAttack() public {
        console.log("");
        console.log("=== FLASH DEPOSIT ATTACK TEST ===");

        // Check if we can deposit and immediately withdraw for profit

        // First check if depositing is open
        (bool success, bytes memory data) = POOL.staticcall(
            abi.encodeWithSignature("claimingOpen()")
        );

        uint8 claimingOpen;
        if (success && data.length >= 32) {
            claimingOpen = abi.decode(data, (uint8));
            console.log("Claiming open:", claimingOpen);
        }

        if (claimingOpen == 1) {
            console.log("Depositing is CLOSED (claiming is open)");
            console.log("Cannot flash deposit attack");
        } else {
            console.log("Depositing is OPEN - testing...");

            address attacker = address(0xBEEF);
            vm.deal(attacker, 1 ether);

            uint256 attackerBalBefore = attacker.balance;

            // Deposit
            vm.startPrank(attacker);
            (success,) = POOL.call{value: 0.1 ether}(
                abi.encodeWithSignature("depositEther()")
            );
            console.log("Deposit succeeded:", success);

            if (success) {
                // Immediately withdraw
                (success,) = POOL.call(
                    abi.encodeWithSignature("withdraw()")
                );
                console.log("Withdraw succeeded:", success);
            }
            vm.stopPrank();

            uint256 attackerBalAfter = attacker.balance;
            console.log("Attacker balance before:", attackerBalBefore / 1e18);
            console.log("Attacker balance after:", attackerBalAfter / 1e18);

            if (attackerBalAfter > attackerBalBefore) {
                console.log("!!! PROFIT FOUND !!!");
            } else if (attackerBalAfter < attackerBalBefore) {
                console.log("Lost ETH to gas (expected)");
            }
        }

        console.log("==================================");
    }

    function test_analyzeClaimMechanism() public view {
        console.log("");
        console.log("=== CLAIM MECHANISM ANALYSIS ===");

        // Check claim receiver
        (bool success, bytes memory data) = POOL.staticcall(
            abi.encodeWithSignature("claimReceiverContract()")
        );

        if (success && data.length >= 32) {
            address receiver = abi.decode(data, (address));
            console.log("Claim Receiver Contract:", receiver);

            if (receiver != address(0)) {
                console.log("Receiver is SET - checking if it's exploitable...");

                // Check receiver code size
                uint256 codeSize;
                assembly {
                    codeSize := extcodesize(receiver)
                }
                console.log("Receiver code size:", codeSize);

                if (codeSize == 0) {
                    console.log("!!! WARNING: Receiver has no code - could be EOA !!!");
                }
            } else {
                console.log("Receiver is NOT SET");
            }
        }

        // Check claim deadline
        (success, data) = POOL.staticcall(
            abi.encodeWithSignature("claimDeadline()")
        );

        if (success && data.length >= 32) {
            uint256 deadline = abi.decode(data, (uint256));
            if (deadline > 0) {
                console.log("Deadline:", deadline);
                console.log("Current time:", block.timestamp);
                console.log("Deadline passed:", block.timestamp > deadline);
            }
        }

        console.log("================================");
    }
}
