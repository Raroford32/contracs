// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Cross-Protocol Attack Chain Tests
 * @notice Comprehensive tests for multi-contract attack sequences across:
 *         - SuperVault (ERC4626 + ERC7540)
 *         - Pendle SY/PT/YT
 *         - Underlying yield sources (Morpho, Aave, Euler, Fluid)
 *
 * CRITICAL FINDINGS FROM INVESTIGATION:
 * 1. ALL 4 MANAGERS ARE EOAs (not multi-sigs) - HIGH collusion risk
 * 2. PPS is oracle-provided (forwardPPS), not calculated from yield sources
 * 3. 24-hour staleness window creates timing attack surface
 * 4. Pendle SY mirrors SuperVault PPS exactly (instantaneous)
 * 5. Global hooks root is active (arbitrary external calls possible)
 */
contract CrossProtocolAttackTest is Test {
    // ============ CORE CONTRACTS ============
    address constant SUPERVAULT = 0xf6EbeA08a0Dfd44825f67Fa9963911c81BE2a947;
    address constant STRATEGY = 0x41A9Eb398518D2487301c61D2b33E4e966A9F1DD;
    address constant AGGREGATOR = 0x10AC0b33e1C4501CF3ec1cB1AE51ebfdbd2d4698;

    // ============ PENDLE CONTRACTS ============
    address constant PENDLE_SY = 0x4D654F255D54637112844bd8802b716170904FeE;
    address constant PENDLE_MARKET = 0x3D83a85e0B0fe9cC116A4EFc61bb29Cb29C3cb9a;
    address constant PENDLE_PT = 0x5d99FF7BcD32c432Cbc07fBb0a593EF4cC9d019d;
    address constant PENDLE_YT = 0xb34c5b00C62DC45Bfc63D640bF4e80Fcf2ECEceB;
    address constant PENDLE_ROUTER = 0x888888888889758F76e7103c6CbF23ABbF58F946;

    // ============ TOKENS ============
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    // ============ MANAGER ADDRESSES (ALL EOAs!) ============
    address constant MAIN_MANAGER = 0xb3dCDaA89B0A43bcC59a9BDEEb5583EC2071066c;
    address constant SECONDARY_1 = 0x3A4B6F0Cef9774E1Ee5B2d7409e9F10A8A837376;
    address constant SECONDARY_2 = 0x38Cb1617B61dbBa070Fbd3556d6A3E7fAffCf141;
    address constant SECONDARY_3 = 0xc11E18919c9B6A47e90ca5BcD91A8D8fCB08c235;

    // ============ YIELD SOURCES ============
    address constant STEAKHOUSE_USDC = 0xBEEF01735c132Ada46AA9aA4c54623cAA92A64CB;
    address constant SMOKEHOUSE_USDC = 0xBEeFFF209270748ddd194831b3fa287a5386f5bC;
    address constant STATIC_AAVE_USDC = 0x73edDFa87C71ADdC275c2b9890f5c3a8480bC9E6;
    address constant EULER_EVK_USDC = 0x797DD80692c3b2dAdabCe8e30C07fDE5307D48a9;
    address constant FLUID_USDC = 0x9Fb7b4477576Fe5B32be4C1843aFB1e55F251B33;
    address constant GAUNTLET_CORE = 0x8eB67A509616cd6A7c1B3c8C21D48FF57df3d458;

    // ============ FLASH LOAN SOURCES ============
    address constant MORPHO_BLUE = 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb;
    address constant AAVE_V3_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

    // ============ ORACLES ============
    address constant EULER_ROUTER = 0x83B3b76873D36A28440cF53371dF404c42497136;

    // ============ WHALE ADDRESSES ============
    address constant USDC_WHALE = 0x37305B1cD40574E4C5Ce33f8e8306Be057fD7341;

    // ============ CACHED STATE ============
    uint256 cachedPPS;
    uint256 cachedTotalAssets;
    uint256 cachedTotalSupply;
    uint256 cachedSYExchangeRate;
    uint256 cachedLastUpdate;
    uint256 cachedMaxStaleness;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");

        // Cache state for tests
        cachedPPS = _getPPS();
        cachedSYExchangeRate = _getSYExchangeRate();
        cachedTotalAssets = _getTotalAssets();
        cachedTotalSupply = _getTotalSupply();
        cachedLastUpdate = _getLastUpdateTimestamp();
        cachedMaxStaleness = _getMaxStaleness();

        console.log("=== INITIAL STATE ===");
        console.log("PPS (6 decimals):", cachedPPS);
        console.log("SY Exchange Rate (18 decimals):", cachedSYExchangeRate);
        console.log("Total Assets (USDC):", cachedTotalAssets / 1e6, "USDC");
        console.log("Total Supply (shares):", cachedTotalSupply / 1e6);
        console.log("Last PPS Update:", cachedLastUpdate);
        console.log("Max Staleness:", cachedMaxStaleness, "seconds");
        console.log("");
    }

    // ============ ATTACK 1: Manager EOA Collusion ============

    /**
     * @notice Test manager extraction via fulfillRedeemRequests with minimum payout
     * @dev CRITICAL: All managers are EOAs - no multi-sig protection!
     *
     * Attack Sequence:
     * 1. User requests redeem at PPS = X
     * 2. Time passes, PPS appreciates to X + 10%
     * 3. Manager fulfills at minimum allowed (X * 0.995)
     * 4. Manager keeps 10.5% difference
     * 5. Manager extracts via executeHooks
     */
    function test_ManagerCollusionExtraction() public {
        console.log("=== ATTACK 1: MANAGER EOA COLLUSION ===");
        console.log("");

        // Verify all managers are EOAs (code size = 0)
        uint256 mainManagerCode;
        uint256 sec1Code;
        uint256 sec2Code;
        uint256 sec3Code;

        assembly {
            mainManagerCode := extcodesize(0xb3dCDaA89B0A43bcC59a9BDEEb5583EC2071066c)
            sec1Code := extcodesize(0x3A4B6F0Cef9774E1Ee5B2d7409e9F10A8A837376)
            sec2Code := extcodesize(0x38Cb1617B61dbBa070Fbd3556d6A3E7fAffCf141)
            sec3Code := extcodesize(0xc11E18919c9B6A47e90ca5BcD91A8D8fCB08c235)
        }

        console.log("Main Manager (0xb3dC...) code size:", mainManagerCode);
        console.log("Secondary 1 (0x3A4B...) code size:", sec1Code);
        console.log("Secondary 2 (0x38Cb...) code size:", sec2Code);
        console.log("Secondary 3 (0xc11E...) code size:", sec3Code);

        bool allEOA = mainManagerCode == 0 && sec1Code == 0 && sec2Code == 0 && sec3Code == 0;
        console.log("");
        console.log("ALL MANAGERS ARE EOAs:", allEOA ? "YES (CRITICAL!)" : "NO");

        if (allEOA) {
            console.log("");
            console.log("COLLUSION RISK ASSESSMENT:");
            console.log("  - Any single manager EOA can fulfill redemptions");
            console.log("  - Default slippage: 0.5% (50 bps)");
            console.log("  - If PPS appreciates 10%, manager can keep ~9.5%");
            console.log("  - On $1M redemption at 10% appreciation:");
            console.log("    - User expects: $1,100,000");
            console.log("    - Min payout: $995,000 (at original PPS * 0.995)");
            console.log("    - Manager extracts: $105,000");
            console.log("");
            console.log("EXTRACTION MECHANISM:");
            console.log("  1. Manager sets very low fulfillment amount (within bounds)");
            console.log("  2. Excess assets remain in strategy");
            console.log("  3. Manager calls executeHooks with Merkle proof");
            console.log("  4. Hook transfers assets to manager-controlled address");
        }

        assertTrue(allEOA, "Expected all managers to be EOAs");
    }

    /**
     * @notice Simulate manager extraction with 5% PPS appreciation
     */
    function test_SimulateManagerExtraction_5Percent() public {
        console.log("=== SIMULATE 5% PPS APPRECIATION EXTRACTION ===");
        console.log("");

        uint256 redemptionAmount = 1_000_000 * 1e6; // $1M USDC equivalent in shares
        uint256 originalPPS = cachedPPS; // 1.007027 (6 decimals)
        uint256 newPPS = originalPPS * 105 / 100; // 5% appreciation

        // Calculate expected vs minimum payout
        uint256 expectedAssets = redemptionAmount * newPPS / 1e6;
        uint256 minAssets = redemptionAmount * originalPPS * 995 / 1000 / 1e6; // 0.5% slippage
        uint256 extraction = expectedAssets - minAssets;

        console.log("Redemption Amount (shares):", redemptionAmount / 1e6);
        console.log("Original PPS:", originalPPS);
        console.log("New PPS (+5%):", newPPS);
        console.log("");
        console.log("Expected Assets at new PPS:", expectedAssets / 1e6, "USDC");
        console.log("Minimum Payout Allowed:", minAssets / 1e6, "USDC");
        console.log("Manager Extraction Potential:", extraction / 1e6, "USDC");
        console.log("Extraction Percentage:", extraction * 100 / expectedAssets, "%");

        // Extraction is significant
        assertTrue(extraction > 50_000 * 1e6, "Expected >$50k extraction potential");
    }

    // ============ ATTACK 2: PPS Staleness Timing Attack ============

    /**
     * @notice Test PPS staleness window exploitation
     * @dev 24-hour staleness window creates timing attack surface
     *
     * Attack Sequence:
     * 1. Monitor forwardPPS() calls in mempool
     * 2. If new PPS > old PPS by significant amount
     * 3. Front-run with deposit at old PPS
     * 4. After PPS update, exit via Pendle at new PPS
     */
    function test_PPSStalenessWindow() public {
        console.log("=== ATTACK 2: PPS STALENESS WINDOW ===");
        console.log("");

        console.log("Current Staleness Config:");
        console.log("  Max Staleness:", cachedMaxStaleness / 3600, "hours");
        console.log("  Last Update:", cachedLastUpdate);
        console.log("  Current Block Timestamp:", block.timestamp);

        uint256 age = block.timestamp - cachedLastUpdate;
        console.log("  PPS Age (seconds):", age);
        console.log("  PPS Age (hours):", age / 3600);

        bool isStale = age > cachedMaxStaleness;
        console.log("  Is Stale:", isStale ? "YES" : "NO");

        console.log("");
        console.log("TIMING ATTACK SURFACE:");
        console.log("  - 24-hour window between updates");
        console.log("  - Yield sources accrue continuously");
        console.log("  - PPS reflects NAV at update time");
        console.log("  - If yield sources gain 0.1%/day:");
        console.log("    - End of staleness: PPS is ~0.1% below actual");
        console.log("    - Deposit captures 0.1% free value");
        console.log("");
        console.log("CURRENT DAILY YIELD (estimated):");

        // At 7% APY, daily yield is ~0.019%
        uint256 annualYieldBps = 700; // 7% APY estimate
        uint256 dailyYieldBps = annualYieldBps / 365;
        console.log("  Assuming 7% APY:", dailyYieldBps, "bps/day (~0.019%)");
        console.log("  On $16.7M TVL, daily accrual: ~$3,170");
        console.log("  Max staleness gain: ~0.019% per day");
        console.log("");
        console.log("VERDICT: Low profitability unless PPS update delayed >7 days");
    }

    // ============ ATTACK 3: Cross-Protocol Flash Loan Chain ============

    /**
     * @notice Test cross-protocol flash loan attack through yield sources
     * @dev Attempts to manipulate yield source valuations via flash loans
     *
     * Potential Targets:
     * - Euler EVK: Has external oracle (EulerRouter)
     * - Morpho Blue: Market-based pricing
     * - Aave V3: Interest rate dependent
     */
    function test_CrossProtocolFlashLoanSurface() public {
        console.log("=== ATTACK 3: CROSS-PROTOCOL FLASH LOAN CHAIN ===");
        console.log("");

        console.log("YIELD SOURCE ORACLE DEPENDENCIES:");
        console.log("");

        // Check Euler EVK oracle
        console.log("1. EULER EVK (eUSDC-2):");
        console.log("   Address:", EULER_EVK_USDC);
        console.log("   Oracle: EulerRouter (0x83B3...)");

        // Try to get Euler total assets
        (bool success, bytes memory data) = EULER_EVK_USDC.staticcall(
            abi.encodeWithSignature("totalAssets()")
        );
        if (success && data.length >= 32) {
            uint256 assets = abi.decode(data, (uint256));
            console.log("   Total Assets:", assets / 1e6, "USDC");
        }

        // Check if Euler oracle can be queried
        console.log("   Oracle Type: EulerRouter (custom aggregator)");
        console.log("   Manipulation: Requires understanding EulerRouter sources");
        console.log("");

        // Morpho
        console.log("2. MORPHO BLUE:");
        console.log("   Steakhouse: ~$366M TVL");
        console.log("   Oracle: Market-based (supply/borrow rates)");
        console.log("   Manipulation: Interest rate manipulation via");
        console.log("                 massive borrow/supply changes");
        console.log("");

        // Aave
        console.log("3. AAVE V3 STATIC:");
        console.log("   Uses aToken rebasing for exchange rate");
        console.log("   Oracle: Chainlink for collateral pricing");
        console.log("   Manipulation: Very difficult (Chainlink + liquidity depth)");
        console.log("");

        // Fluid
        console.log("4. INSTADAPP FLUID:");
        console.log("   Exchange Rate: 1.1847");
        console.log("   Oracle: Internal accounting");
        console.log("   Manipulation: Unknown - needs deeper analysis");
        console.log("");

        console.log("CRITICAL INSIGHT:");
        console.log("  PPS is ORACLE-PROVIDED via forwardPPS(), NOT calculated");
        console.log("  from yield source values on-chain!");
        console.log("");
        console.log("  This means manipulating yield sources does NOT directly");
        console.log("  affect PPS. The oracle provider must include the manipulation");
        console.log("  in their off-chain NAV calculation.");
        console.log("");
        console.log("  ATTACK VECTOR: If oracle provider uses on-chain reads,");
        console.log("  flash loan manipulation before forwardPPS() could work.");
    }

    // ============ ATTACK 4: Pendle AMM Arbitrage Chain ============

    /**
     * @notice Test Pendle AMM arbitrage opportunities
     * @dev Exploits price discrepancies between SuperVault PPS and Pendle PT price
     */
    function test_PendleAMMArbitrage() public {
        console.log("=== ATTACK 4: PENDLE AMM ARBITRAGE ===");
        console.log("");

        // Get PT token info
        console.log("PENDLE MARKET STATE:");
        console.log("  Market:", PENDLE_MARKET);
        console.log("  SY:", PENDLE_SY);
        console.log("  PT:", PENDLE_PT);
        console.log("  YT:", PENDLE_YT);
        console.log("");

        // Calculate theoretical PT price
        // PT should trade at discount = 1 / (1 + r)^t
        // where r = implied rate, t = time to maturity

        uint256 expiry;
        (bool success, bytes memory data) = PENDLE_MARKET.staticcall(
            abi.encodeWithSignature("expiry()")
        );
        if (success) {
            expiry = abi.decode(data, (uint256));
        }

        uint256 timeToMaturity = expiry > block.timestamp ? expiry - block.timestamp : 0;
        console.log("  Market Expiry:", expiry);
        console.log("  Time to Maturity:", timeToMaturity / 86400, "days");
        console.log("");

        console.log("PT DISCOUNT ANALYSIS:");
        console.log("  Theoretical PT price = 1 / (1 + r)^t");
        console.log("  At 7% APY, ~3 months to expiry:");
        console.log("  PT Price ~ 0.9828 (1.72% discount)");
        console.log("");
        console.log("  Current SY Exchange Rate:", cachedSYExchangeRate / 1e18);
        console.log("");

        console.log("ARBITRAGE OPPORTUNITY:");
        console.log("  If PT trades below theoretical (>1.72% discount):");
        console.log("  1. Buy PT at discount");
        console.log("  2. Hold to maturity");
        console.log("  3. Redeem PT 1:1 for SY");
        console.log("  4. Redeem SY for SuperVault shares");
        console.log("  5. Redeem SuperVault shares for USDC");
        console.log("");
        console.log("  This is INTENDED behavior, not an exploit.");
        console.log("  Provides ~2% arbitrage for patient capital.");
    }

    // ============ ATTACK 5: Hook Execution Chain ============

    /**
     * @notice Test hook execution attack surface
     * @dev Hooks allow arbitrary external calls with Merkle validation
     */
    function test_HookExecutionSurface() public {
        console.log("=== ATTACK 5: HOOK EXECUTION CHAIN ===");
        console.log("");

        // Get global hooks root
        bytes32 globalRoot;
        (bool success, bytes memory data) = AGGREGATOR.staticcall(
            abi.encodeWithSignature("getGlobalHooksRoot()")
        );
        if (success) {
            globalRoot = abi.decode(data, (bytes32));
        }

        console.log("HOOKS CONFIGURATION:");
        console.log("  Global Hooks Root:");
        console.logBytes32(globalRoot);

        bool hooksActive = globalRoot != bytes32(0);
        console.log("  Hooks System Active:", hooksActive ? "YES" : "NO");
        console.log("");

        if (hooksActive) {
            console.log("HOOK EXECUTION MECHANISM:");
            console.log("  1. Manager calls executeHooks(hooks, merkleProofs)");
            console.log("  2. Each hook is validated against Merkle root");
            console.log("  3. Hook executes arbitrary external call");
            console.log("  4. Can be chained with previous hook output");
            console.log("");
            console.log("ATTACK SURFACE:");
            console.log("  - Hook targets could include:");
            console.log("    - Yield source rebalancing");
            console.log("    - Fee collection");
            console.log("    - Emergency withdrawals");
            console.log("  - With manager collusion:");
            console.log("    - Could execute malicious hooks");
            console.log("    - Extract funds to manager address");
            console.log("  - Mitigation: Merkle root is set by governor");
            console.log("             timelock required for changes");
        }
    }

    // ============ ATTACK 6: Multi-Step Complex Chain ============

    /**
     * @notice Design maximum extraction attack chain
     * @dev Combines multiple vectors for theoretical maximum profit
     */
    function test_MaximumExtractionChain() public {
        console.log("=== ATTACK 6: MAXIMUM EXTRACTION CHAIN ===");
        console.log("");

        console.log("THEORETICAL MAXIMUM EXTRACTION SEQUENCE:");
        console.log("");
        console.log("PREREQUISITES (TIER_3):");
        console.log("  - Control of at least one manager EOA");
        console.log("  - Knowledge of hook Merkle proofs");
        console.log("  - Flash loan access (~$100M)");
        console.log("");

        console.log("STEP 1: Position Building");
        console.log("  - Flash borrow $10M USDC from Balancer");
        console.log("  - Deposit into SuperVault via Pendle SY");
        console.log("  - Receive ~9.93M SY tokens (at PPS 1.007)");
        console.log("");

        console.log("STEP 2: Wait for PPS Appreciation");
        console.log("  - Hold position while yield accrues");
        console.log("  - At 7% APY, ~$1,900/day on $10M");
        console.log("  - After 30 days: ~$57,000 profit accrued");
        console.log("");

        console.log("STEP 3: Request Redemption");
        console.log("  - Call SY.redeem() to get SuperVault shares");
        console.log("  - Call SuperVault.requestRedeem()");
        console.log("  - averageRequestPPS locked in at current PPS");
        console.log("");

        console.log("STEP 4: Manager Fulfillment (WITH COLLUSION)");
        console.log("  - PPS appreciates further (+5% from request time)");
        console.log("  - Manager fulfills at minimum (request PPS * 0.995)");
        console.log("  - Manager extracts: 5% + yield = ~$550,000");
        console.log("");

        console.log("STEP 5: Hook-Based Extraction");
        console.log("  - Manager executes whitelisted hooks");
        console.log("  - Transfers excess to controlled address");
        console.log("  - Difficult to detect (appears as normal operation)");
        console.log("");

        console.log("TOTAL THEORETICAL EXTRACTION:");
        console.log("  On $10M position held 30 days with 5% PPS move:");
        console.log("  - Yield extraction: ~$57,000");
        console.log("  - PPS arbitrage: ~$500,000");
        console.log("  - TOTAL: ~$557,000 (5.57% of position)");
        console.log("");

        console.log("FEASIBILITY ASSESSMENT:");
        console.log("  - Requires manager collusion (TIER_3)");
        console.log("  - Requires 30-day capital lockup");
        console.log("  - Detection: Low (operations appear legitimate)");
        console.log("  - Probability of success: HIGH given EOA managers");
    }

    // ============ HELPERS ============

    function _getPPS() internal view returns (uint256) {
        (bool success, bytes memory data) = AGGREGATOR.staticcall(
            abi.encodeWithSignature("getPPS(address)", STRATEGY)
        );
        return success ? abi.decode(data, (uint256)) : 0;
    }

    function _getSYExchangeRate() internal view returns (uint256) {
        (bool success, bytes memory data) = PENDLE_SY.staticcall(
            abi.encodeWithSignature("exchangeRate()")
        );
        return success ? abi.decode(data, (uint256)) : 0;
    }

    function _getTotalAssets() internal view returns (uint256) {
        (bool success, bytes memory data) = SUPERVAULT.staticcall(
            abi.encodeWithSignature("totalAssets()")
        );
        return success ? abi.decode(data, (uint256)) : 0;
    }

    function _getTotalSupply() internal view returns (uint256) {
        (bool success, bytes memory data) = SUPERVAULT.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        return success ? abi.decode(data, (uint256)) : 0;
    }

    function _getLastUpdateTimestamp() internal view returns (uint256) {
        (bool success, bytes memory data) = AGGREGATOR.staticcall(
            abi.encodeWithSignature("getLastUpdateTimestamp(address)", STRATEGY)
        );
        return success ? abi.decode(data, (uint256)) : 0;
    }

    function _getMaxStaleness() internal view returns (uint256) {
        (bool success, bytes memory data) = AGGREGATOR.staticcall(
            abi.encodeWithSignature("getMaxStaleness(address)", STRATEGY)
        );
        return success ? abi.decode(data, (uint256)) : 86400;
    }
}
