// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// Minimal interfaces for dYdX Solo Margin
interface ISoloMargin {
    struct Info {
        address owner;
        uint256 number;
    }

    enum ActionType {
        Deposit,
        Withdraw,
        Transfer,
        Buy,
        Sell,
        Trade,
        Liquidate,
        Vaporize,
        Call
    }

    enum AssetDenomination { Wei, Par }
    enum AssetReference { Delta, Target }

    struct AssetAmount {
        bool sign;
        AssetDenomination denomination;
        AssetReference ref;
        uint256 value;
    }

    struct ActionArgs {
        ActionType actionType;
        uint256 accountId;
        AssetAmount amount;
        uint256 primaryMarketId;
        uint256 secondaryMarketId;
        address otherAddress;
        uint256 otherAccountId;
        bytes data;
    }

    struct Index {
        uint96 borrow;
        uint96 supply;
        uint32 lastUpdate;
    }

    struct TotalPar {
        uint128 borrow;
        uint128 supply;
    }

    struct Par {
        bool sign;
        uint128 value;
    }

    struct Wei {
        bool sign;
        uint256 value;
    }

    function operate(Info[] calldata accounts, ActionArgs[] calldata actions) external;
    function getNumMarkets() external view returns (uint256);
    function getMarketTokenAddress(uint256 marketId) external view returns (address);
    function getMarketCurrentIndex(uint256 marketId) external view returns (Index memory);
    function getMarketTotalPar(uint256 marketId) external view returns (TotalPar memory);
    function getMarketPriceOracle(uint256 marketId) external view returns (address);
    function getAccountPar(Info calldata account, uint256 marketId) external view returns (Par memory);
    function getAccountWei(Info calldata account, uint256 marketId) external view returns (Wei memory);
    function getAccountValues(Info calldata account) external view returns (uint256, uint256);
    function getMarketPrice(uint256 marketId) external view returns (uint256);
    function getMarketInterestRate(uint256 marketId) external view returns (uint256);
    function getMarketMarginPremium(uint256 marketId) external view returns (uint256);
    function getMarketSpreadPremium(uint256 marketId) external view returns (uint256);
    function getAccountStatus(Info calldata account) external view returns (uint8);
    function getIsLocalOperator(address owner, address operator) external view returns (bool);
    function getIsGlobalOperator(address operator) external view returns (bool);
    function getMarginRatio() external view returns (uint256);
    function getLiquidationSpread() external view returns (uint256);
    function owner() external view returns (address);
    function getRiskParams() external view returns (uint256, uint256, uint256, uint256, uint256, uint256);
    function getRiskLimits() external view returns (uint64, uint64, uint64, uint64, uint64, uint64, uint128);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function decimals() external view returns (uint8);
    function symbol() external view returns (string memory);
}

interface IPriceOracle {
    function getPrice(address token) external view returns (uint256);
}

contract DydxSoloExploit is Test {
    ISoloMargin constant SOLO = ISoloMargin(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e);

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function test_queryDydxState() public {
        uint256 numMarkets = SOLO.getNumMarkets();
        emit log_named_uint("Number of markets", numMarkets);

        for (uint256 i = 0; i < numMarkets; i++) {
            address token = SOLO.getMarketTokenAddress(i);
            ISoloMargin.TotalPar memory totalPar = SOLO.getMarketTotalPar(i);
            uint256 tokenBalance = IERC20(token).balanceOf(address(SOLO));

            emit log_string("---");
            emit log_named_uint("Market ID", i);
            emit log_named_address("Token", token);
            emit log_named_uint("Token balance in Solo", tokenBalance);
            emit log_named_uint("Total supply par", totalPar.supply);
            emit log_named_uint("Total borrow par", totalPar.borrow);

            try SOLO.getMarketPrice(i) returns (uint256 price) {
                emit log_named_uint("Price (36 dec)", price);
            } catch {
                emit log_string("  Price query failed");
            }

            try SOLO.getMarketCurrentIndex(i) returns (ISoloMargin.Index memory idx) {
                emit log_named_uint("Supply index", idx.supply);
                emit log_named_uint("Borrow index", idx.borrow);
                emit log_named_uint("Last update", idx.lastUpdate);
                uint256 staleness = block.timestamp - idx.lastUpdate;
                emit log_named_uint("Staleness (seconds)", staleness);
            } catch {
                emit log_string("  Index query failed");
            }

            try SOLO.getMarketInterestRate(i) returns (uint256 rate) {
                emit log_named_uint("Interest rate per second", rate);
            } catch {
                emit log_string("  Rate query failed");
            }

            // Check oracle address
            try SOLO.getMarketPriceOracle(i) returns (address oracle) {
                emit log_named_address("Oracle", oracle);
            } catch {}
        }

        // Check risk parameters
        uint256 marginRatio = SOLO.getMarginRatio();
        uint256 liquidationSpread = SOLO.getLiquidationSpread();
        emit log_string("=== RISK PARAMS ===");
        emit log_named_uint("Margin ratio (18 dec)", marginRatio);
        emit log_named_uint("Liquidation spread (18 dec)", liquidationSpread);
    }

    function test_checkOracleStalenessDydx() public {
        uint256 numMarkets = SOLO.getNumMarkets();

        for (uint256 i = 0; i < numMarkets; i++) {
            address token = SOLO.getMarketTokenAddress(i);
            address oracle = SOLO.getMarketPriceOracle(i);

            uint256 price = SOLO.getMarketPrice(i);
            ISoloMargin.Index memory idx = SOLO.getMarketCurrentIndex(i);

            emit log_string("---");
            emit log_named_uint("Market", i);
            emit log_named_address("Oracle", oracle);
            emit log_named_uint("Oracle price", price);
            emit log_named_uint("Index last update", idx.lastUpdate);
            emit log_named_uint("Current timestamp", block.timestamp);
            emit log_named_uint("Staleness seconds", block.timestamp - idx.lastUpdate);
        }
    }

    function test_findLiquidatableAccounts() public {
        // Check if any known accounts are liquidatable
        // Test with account number 0 for common DeFi contract addresses
        address[] memory testAddrs = new address[](5);
        testAddrs[0] = address(0x1); // test
        testAddrs[1] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // WETH
        testAddrs[2] = 0x6B175474E89094C44Da98b954EedeAC495271d0F; // DAI
        testAddrs[3] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // USDC
        testAddrs[4] = address(SOLO); // Self

        for (uint256 i = 0; i < testAddrs.length; i++) {
            ISoloMargin.Info memory acct = ISoloMargin.Info({
                owner: testAddrs[i],
                number: 0
            });

            try SOLO.getAccountValues(acct) returns (uint256 supplyValue, uint256 borrowValue) {
                if (borrowValue > 0) {
                    emit log_named_address("Account with borrows", testAddrs[i]);
                    emit log_named_uint("Supply value", supplyValue);
                    emit log_named_uint("Borrow value", borrowValue);

                    // Check if undercollateralized
                    uint256 marginRatio = SOLO.getMarginRatio();
                    uint256 requiredCollateral = borrowValue * (1e18 + marginRatio) / 1e18;
                    if (supplyValue < requiredCollateral) {
                        emit log_string("*** LIQUIDATABLE! ***");
                    }

                    uint8 status = SOLO.getAccountStatus(acct);
                    emit log_named_uint("Account status", status);
                }
            } catch {}
        }
    }

    function test_interestAccrualManipulation() public {
        // Check if we can profit from triggering interest accrual
        uint256 numMarkets = SOLO.getNumMarkets();

        for (uint256 i = 0; i < numMarkets; i++) {
            ISoloMargin.Index memory beforeIdx = SOLO.getMarketCurrentIndex(i);
            ISoloMargin.TotalPar memory totalPar = SOLO.getMarketTotalPar(i);
            uint256 staleness = block.timestamp - beforeIdx.lastUpdate;

            if (staleness > 3600 && totalPar.borrow > 0) { // More than 1 hour stale with active borrows
                address token = SOLO.getMarketTokenAddress(i);
                string memory symbol;
                try IERC20(token).symbol() returns (string memory s) {
                    symbol = s;
                } catch {
                    symbol = "UNKNOWN";
                }

                emit log_string("=== STALE MARKET WITH BORROWS ===");
                emit log_named_uint("Market", i);
                emit log_named_string("Symbol", symbol);
                emit log_named_uint("Staleness (seconds)", staleness);
                emit log_named_uint("Total borrow par", totalPar.borrow);
                emit log_named_uint("Total supply par", totalPar.supply);

                // Calculate pending interest
                try SOLO.getMarketInterestRate(i) returns (uint256 rate) {
                    // Pending borrow interest = borrowPar * borrowIndex * rate * staleness
                    uint256 pendingInterest = uint256(totalPar.borrow) * uint256(beforeIdx.borrow) * rate * staleness / 1e18 / 1e18;
                    emit log_named_uint("Estimated pending interest (wei)", pendingInterest);

                    uint256 price = SOLO.getMarketPrice(i);
                    uint256 pendingUsd = pendingInterest * price / 1e36;
                    emit log_named_uint("Estimated pending interest (USD, 18 dec)", pendingUsd);
                } catch {}
            }
        }
    }

    // Test: Can we use operate() as a flash loan and profit from oracle inconsistency?
    function test_flashLoanArbitrage() public {
        uint256 numMarkets = SOLO.getNumMarkets();

        // Check each market for available liquidity
        for (uint256 i = 0; i < numMarkets; i++) {
            address token = SOLO.getMarketTokenAddress(i);
            uint256 balance = IERC20(token).balanceOf(address(SOLO));

            if (balance > 0) {
                string memory symbol;
                try IERC20(token).symbol() returns (string memory s) {
                    symbol = s;
                } catch {
                    symbol = "UNKNOWN";
                }

                uint256 price = SOLO.getMarketPrice(i);
                uint256 valueUsd = balance * price / 1e36;

                emit log_string("---");
                emit log_named_uint("Market", i);
                emit log_named_string("Symbol", symbol);
                emit log_named_uint("Available liquidity", balance);
                emit log_named_uint("Value USD (18 dec)", valueUsd);
            }
        }
    }
}
