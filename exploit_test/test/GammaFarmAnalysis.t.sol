// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title GammaFarm Deep Analysis
 * @notice Analyzing the yield farming contract for potential exploits
 *
 * KEY FINDINGS FROM SOURCE ANALYSIS:
 *
 * 1. PROFIT FACTOR CALCULATION:
 *    profitFactor = (reward + ending stake) / beginning stake
 *    - If beginning stake is small, profitFactor can be very high
 *    - This affects reward calculations for subsequent users
 *
 * 2. CUMULATIVE SUM (CumS) REWARDS:
 *    stakedRewards = staked * (endSnapshot.stakedCumS - startSnapshot.stakedCumS) / profitFactor
 *    - Complex math with potential precision issues
 *    - Division by profitFactor after multiplication could lose precision
 *
 * 3. EPOCH RESET:
 *    - If profitFactor reaches zero, triggers reset epoch tracking
 *    - Could this be manipulated to steal rewards?
 *
 * 4. SAME-BLOCK FRONTRUN PROTECTION:
 *    - Checks for same-block trades on UniswapV3
 *    - But could be circumvented with multi-block attacks
 */
contract GammaFarmAnalysisTest is Test {
    address constant GAMMA_FARM = 0x5Dc58f812b2e244DABA2fabd33f399cD699D7Ddc;
    address constant LUSD = 0x5f98805A4E8be255a32880FDeC7F6728C6568bA0;
    address constant MAL = 0x6619078Bdd8324E01E9a8D4b3d761b050E5ECF06;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function test_readGammaFarmState() public view {
        console.log("=== GAMMA FARM STATE ANALYSIS ===");
        console.log("Contract:", GAMMA_FARM);

        // Check LUSD balance in contract
        (bool success, bytes memory data) = LUSD.staticcall(
            abi.encodeWithSignature("balanceOf(address)", GAMMA_FARM)
        );
        if (success && data.length >= 32) {
            uint256 lusdBalance = abi.decode(data, (uint256));
            console.log("LUSD Balance:", lusdBalance / 1e18);
        }

        // Check MAL balance in contract
        (success, data) = MAL.staticcall(
            abi.encodeWithSignature("balanceOf(address)", GAMMA_FARM)
        );
        if (success && data.length >= 32) {
            uint256 malBalance = abi.decode(data, (uint256));
            console.log("MAL Balance:", malBalance / 1e18);
        }

        // Check total staked
        (success, data) = GAMMA_FARM.staticcall(
            abi.encodeWithSignature("totalLusdStaked()")
        );
        if (success && data.length >= 32) {
            uint256 totalStaked = abi.decode(data, (uint256));
            console.log("Total LUSD Staked:", totalStaked / 1e18);
        }

        // Check current epoch
        (success, data) = GAMMA_FARM.staticcall(
            abi.encodeWithSignature("currentEpoch()")
        );
        if (success && data.length >= 32) {
            uint256 epoch = abi.decode(data, (uint256));
            console.log("Current Epoch:", epoch);
        }

        // Check if paused
        (success, data) = GAMMA_FARM.staticcall(
            abi.encodeWithSignature("paused()")
        );
        if (success && data.length >= 32) {
            bool paused = abi.decode(data, (bool));
            console.log("Is Paused:", paused);
        }

        // Check if in emergency state
        (success, data) = GAMMA_FARM.staticcall(
            abi.encodeWithSignature("isEmergencyState()")
        );
        if (success && data.length >= 32) {
            bool emergency = abi.decode(data, (bool));
            console.log("Is Emergency State:", emergency);
        }

        console.log("=================================");
    }

    function test_analyzeRewardParams() public view {
        console.log("");
        console.log("=== REWARD PARAMETERS ===");

        // Check reward per second
        (bool success, bytes memory data) = GAMMA_FARM.staticcall(
            abi.encodeWithSignature("malRewardPerSecond()")
        );
        if (success && data.length >= 32) {
            uint256 rewardPerSec = abi.decode(data, (uint256));
            console.log("MAL Reward Per Second:", rewardPerSec);
            console.log("Daily Rewards (approx):", rewardPerSec * 86400 / 1e18);
        }

        // Check decay factor
        (success, data) = GAMMA_FARM.staticcall(
            abi.encodeWithSignature("malDecayFactor()")
        );
        if (success && data.length >= 32) {
            uint256 decayFactor = abi.decode(data, (uint256));
            console.log("MAL Decay Factor:", decayFactor);
        }

        // Check decay period
        (success, data) = GAMMA_FARM.staticcall(
            abi.encodeWithSignature("malDecayPeriodSeconds()")
        );
        if (success && data.length >= 32) {
            uint256 decayPeriod = abi.decode(data, (uint256));
            console.log("Decay Period (seconds):", decayPeriod);
            console.log("Decay Period (days):", decayPeriod / 86400);
        }

        console.log("=========================");
    }

    function test_profitFactorExploitAnalysis() public pure {
        console.log("");
        console.log("=== PROFIT FACTOR EXPLOIT ANALYSIS ===");

        console.log("Formula: profitFactor = (reward + ending_stake) / beginning_stake");
        console.log("");
        console.log("Attack scenario:");
        console.log("1. Attacker deposits minimum (1 LUSD) at start of epoch");
        console.log("2. Epoch runs, collects gains from stability pool");
        console.log("3. If gains >> beginning stake, profitFactor becomes very high");
        console.log("4. This inflates stakedCumS calculation");
        console.log("");
        console.log("Risk Assessment:");
        console.log("- Requires attacker to be sole/major staker at epoch start");
        console.log("- Stability pool gains are proportional to stake");
        console.log("- Hard to achieve high profitFactor with small stake");
        console.log("");
        console.log("VERDICT: Low risk - gains proportional to stake prevents exploit");
        console.log("======================================");
    }

    function test_epochResetExploitAnalysis() public pure {
        console.log("");
        console.log("=== EPOCH RESET EXPLOIT ANALYSIS ===");

        console.log("When profitFactor reaches zero:");
        console.log("- Triggers reset epoch tracking");
        console.log("- Previous CumS values become irrelevant");
        console.log("");
        console.log("Attack scenario:");
        console.log("1. Force profitFactor to zero (total loss in stability pool?)");
        console.log("2. After reset, new deposits start with fresh CumS");
        console.log("3. Could this allow claiming rewards without proper stake?");
        console.log("");
        console.log("Reality check:");
        console.log("- Stability pool rarely has total loss events");
        console.log("- Reset protects users from inheriting bad state");
        console.log("- Not immediately exploitable without extreme conditions");
        console.log("====================================");
    }
}
