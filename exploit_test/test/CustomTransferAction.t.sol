// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

interface IAction {
    function executeAction(bytes memory _callData, uint8[] memory _paramMapping, bytes32[] memory _returnValues) external payable returns (bytes32);
    function executeActionDirect(bytes memory _callData) external payable returns (bytes32);
    function actionType() external view returns (uint8);
}

contract CustomTransferAction is Test {
    // The unknown action with transfer selector
    address constant UNKNOWN_ACTION = 0xc780112305ED959CEEeb0DE692E2407E4145Fc3A;

    // DeFiSaver's official SendToken action for comparison
    address constant DEFISAVER_SENDTOKEN = 0x5c19aF6F5de91209c3bc2Ba447b1f5eb53c50759;
    address constant DEFISAVER_SENDTOKENS = 0x7d05c0ABeF6d91300a237026507c4a2631ddAdEa;
    address constant DEFISAVER_PULLTOKEN = 0x29Bb266A72E585C661e292F7D8CA7C4581a0AF72;

    address constant STRATEGY_0 = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant aWstETH = 0x0B925eD163218f6662a35e0f0371Ac234f9E9371;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_CompareWithDeFiSaverActions() public view {
        console.log("=== COMPARING WITH DEFISAVER ACTIONS ===\n");

        // Compare unknown action with DeFiSaver SendToken
        bytes memory unknownCode = UNKNOWN_ACTION.code;
        bytes memory sendTokenCode = DEFISAVER_SENDTOKEN.code;
        bytes memory sendTokensCode = DEFISAVER_SENDTOKENS.code;
        bytes memory pullTokenCode = DEFISAVER_PULLTOKEN.code;

        console.log("Unknown action code size:", unknownCode.length);
        console.log("DeFiSaver SendToken code size:", sendTokenCode.length);
        console.log("DeFiSaver SendTokens code size:", sendTokensCode.length);
        console.log("DeFiSaver PullToken code size:", pullTokenCode.length);

        // Check if bytecodes are similar
        if (unknownCode.length == sendTokenCode.length) {
            console.log("\nSame size as SendToken - might be same contract!");
            // Compare first 100 bytes
            bool match_ = true;
            for (uint i = 0; i < 100 && i < unknownCode.length; i++) {
                if (unknownCode[i] != sendTokenCode[i]) {
                    match_ = false;
                    break;
                }
            }
            console.log("First 100 bytes match:", match_);
        }

        if (unknownCode.length == sendTokensCode.length) {
            console.log("\nSame size as SendTokens!");
        }

        if (unknownCode.length == pullTokenCode.length) {
            console.log("\nSame size as PullToken!");
        }
    }

    function test_AnalyzeTransferContext() public view {
        console.log("=== ANALYZING TRANSFER CONTEXT ===\n");

        bytes memory code = UNKNOWN_ACTION.code;

        // Look for the transfer call pattern
        // In Solidity, transfer(address,uint256) compiles to:
        // 1. Push selector 0xa9059cbb
        // 2. Push/load recipient address
        // 3. Push/load amount
        // 4. CALL to token

        // Find all occurrences of 0xa9059cbb (transfer selector)
        uint256 count = 0;
        for (uint i = 0; i + 3 < code.length; i++) {
            bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
            if (sel == bytes4(0xa9059cbb)) {
                count++;
                console.log("Transfer selector at offset:", i);

                // Look at surrounding context
                uint256 start = i > 50 ? i - 50 : 0;
                uint256 end = i + 50 < code.length ? i + 50 : code.length;

                // Count CALLDATALOAD in nearby area (indicates reading input params)
                uint256 calldataloadCount = 0;
                for (uint j = start; j < end; j++) {
                    if (uint8(code[j]) == 0x35) calldataloadCount++; // CALLDATALOAD
                }
                console.log("CALLDATALOAD near transfer:", calldataloadCount);
            }
        }
        console.log("Total transfer selectors:", count);
    }

    function test_TrySimulateAction() public {
        console.log("=== SIMULATING ACTION ===\n");

        // Deploy a test contract that will delegatecall the action
        ActionTester tester = new ActionTester();

        // Give tester some tokens
        deal(wstETH, address(tester), 10e18);
        console.log("Tester wstETH balance:", IERC20(wstETH).balanceOf(address(tester)) / 1e18);

        uint256 attackerBefore = IERC20(wstETH).balanceOf(attacker);
        console.log("Attacker wstETH before:", attackerBefore);

        // Try different param structures
        console.log("\n1. Trying (token, to, amount) struct...");
        bytes memory params1 = abi.encode(
            wstETH,
            attacker,
            1e18
        );
        tester.tryAction(UNKNOWN_ACTION, params1);
        console.log("Attacker wstETH after:", IERC20(wstETH).balanceOf(attacker));

        console.log("\n2. Trying (to, token, amount) struct...");
        bytes memory params2 = abi.encode(
            attacker,
            wstETH,
            1e18
        );
        tester.tryAction(UNKNOWN_ACTION, params2);
        console.log("Attacker wstETH after:", IERC20(wstETH).balanceOf(attacker));

        console.log("\n3. Trying (amount, token, to) struct...");
        bytes memory params3 = abi.encode(
            1e18,
            wstETH,
            attacker
        );
        tester.tryAction(UNKNOWN_ACTION, params3);
        console.log("Attacker wstETH after:", IERC20(wstETH).balanceOf(attacker));

        // Check if tokens moved
        uint256 attackerAfter = IERC20(wstETH).balanceOf(attacker);
        if (attackerAfter > attackerBefore) {
            console.log("\n*** CRITICAL: TOKENS TRANSFERRED TO ATTACKER! ***");
        }
    }

    function test_CheckActionInterface() public view {
        console.log("=== CHECKING ACTION INTERFACE ===\n");

        // Try to determine what interface this action implements

        // Check actionType
        (bool success, bytes memory data) = UNKNOWN_ACTION.staticcall(
            abi.encodeWithSignature("actionType()")
        );
        if (success) {
            uint8 actionType = abi.decode(data, (uint8));
            console.log("actionType:", actionType);
            // 0 = FL_ACTION, 1 = STANDARD_ACTION, 2 = CUSTOM_ACTION
            if (actionType == 1) console.log("  -> STANDARD_ACTION");
            if (actionType == 2) console.log("  -> CUSTOM_ACTION");
        } else {
            console.log("No actionType function");
        }

        // Check name
        (success, data) = UNKNOWN_ACTION.staticcall(
            abi.encodeWithSignature("name()")
        );
        if (success) {
            string memory name = abi.decode(data, (string));
            console.log("name:", name);
        }

        // Check registry
        (success, data) = UNKNOWN_ACTION.staticcall(
            abi.encodeWithSignature("registry()")
        );
        if (success && data.length == 32) {
            address registry = abi.decode(data, (address));
            console.log("registry:", registry);
        }
    }

    function test_CompareActionSizes() public view {
        console.log("=== COMPARING ALL TREEHOUSE ACTIONS ===\n");

        // All Treehouse whitelisted actions
        address[] memory actions = new address[](13);
        actions[0] = 0xbdFb29cCD82dB3ccf462F3CB600892b2E6f185C7;  // LidoStake
        actions[1] = 0x160F1f3a512Fa7cCefA0eb08f881282c05d6eb0f;  // LidoWrap
        actions[2] = 0xb8cD2bA2A0Ada353aE15398618Fafb1d7BD558C5;  // LidoUnwrap
        actions[3] = 0x3e34E0694204e462Deaf8EBbeEE2bE9F887f3C3b;  // Unknown
        actions[4] = 0x99eAe56224EA5Bcb2c886D0a07154217b7A1E5d1;  // Unknown
        actions[5] = 0x819Bdb303e224CaC4aC14Da17a1ec13895869b65;  // Unknown
        actions[6] = 0x3503152722beeE269E9B4E0921F2c3D44C90d2b5;  // AaveV3Supply
        actions[7] = 0xEE1F8dc0135EE9dC2e00fac3817b9C530d34B6ba;  // AaveV3Borrow
        actions[8] = 0x71f4d0A74b7F1BB07cc767dC2f4b436E907476DC;  // AaveV3Payback
        actions[9] = 0x0039d822156FF2FD28ac6e19A518660890fcD2E0;  // AaveV3Withdraw
        actions[10] = 0x313Ca6136521D22A7Ea763B3566Ed0B53F5B3AB9; // VaultPull
        actions[11] = 0xc780112305ED959CEEeb0DE692E2407E4145Fc3A; // Unknown (transfer!)
        actions[12] = 0x351dd4581d61BCE7101FDf5f6864D510021c7CaB; // Unknown

        string[13] memory names = [
            "LidoStake",
            "LidoWrap",
            "LidoUnwrap",
            "Unknown_3",
            "Unknown_4",
            "Unknown_5",
            "AaveV3Supply",
            "AaveV3Borrow",
            "AaveV3Payback",
            "AaveV3Withdraw",
            "VaultPull",
            "TRANSFER_ACTION",
            "Unknown_12"
        ];

        console.log("Action sizes and transfer selector presence:\n");
        for (uint i = 0; i < actions.length; i++) {
            bytes memory code = actions[i].code;

            // Check for transfer selector
            bool hasTransfer = false;
            for (uint j = 0; j + 3 < code.length; j++) {
                bytes4 sel = bytes4(bytes.concat(code[j], code[j+1], code[j+2], code[j+3]));
                if (sel == bytes4(0xa9059cbb)) {
                    hasTransfer = true;
                    break;
                }
            }

            console.log(names[i]);
            console.log("  Size:", code.length);
            console.log("  HasTransfer:", hasTransfer);
        }
    }
}

contract ActionTester {
    function tryAction(address action, bytes memory params) external {
        uint8[] memory paramMapping = new uint8[](0);
        bytes32[] memory returnValues = new bytes32[](0);

        bytes memory callData = abi.encodeWithSignature(
            "executeAction(bytes,uint8[],bytes32[])",
            params,
            paramMapping,
            returnValues
        );

        (bool success, bytes memory result) = action.delegatecall(callData);

        if (!success) {
            // Silent failure is ok for testing
        }
    }
}
