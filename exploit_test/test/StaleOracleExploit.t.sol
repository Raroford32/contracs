// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Stale Oracle Exploit Search
 * @notice Finding protocols that use stale USDe oracle for liquidations/borrowing
 */

interface IChainlinkOracle {
    function latestAnswer() external view returns (int256);
    function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80);
    function decimals() external view returns (uint8);
}

interface IAavePool {
    function getUserAccountData(address user) external view returns (
        uint256 totalCollateralETH,
        uint256 totalDebtETH,
        uint256 availableBorrowsETH,
        uint256 currentLiquidationThreshold,
        uint256 ltv,
        uint256 healthFactor
    );
}

interface ICompoundOracle {
    function getUnderlyingPrice(address cToken) external view returns (uint256);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
}

contract StaleOracleExploit is Test {
    // USDe addresses
    address constant USDE = 0x4c9EDD5852cd905f086C759E8383e09bff1E68B3;
    address constant SUSDE = 0x9D39A5DE30e57443BfF2A8307A4256c8797A3497;
    address constant USDE_USD_ORACLE = 0xa569d910839Ae8865Da8F8e70FfFb0cBA869F961;

    // Aave V3
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;

    // Morpho Blue
    address constant MORPHO_BLUE = 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb;

    // Euler
    address constant EULER_V2 = 0x27182842E098f60e3D576794A5bFFb0777E025d3;

    string constant RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    function setUp() public {
        vm.createSelectFork(RPC_URL);
    }

    function test_AnalyzeOracleStaleness() public view {
        console.log("=== USDe Oracle Staleness Analysis ===\n");

        IChainlinkOracle oracle = IChainlinkOracle(USDE_USD_ORACLE);

        int256 price = oracle.latestAnswer();
        (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound) = oracle.latestRoundData();

        uint256 staleness = block.timestamp - updatedAt;

        console.log("Oracle Details:");
        console.log("  Price:", uint256(price));
        console.log("  Decimals:", oracle.decimals());
        console.log("  Round ID:", roundId);
        console.log("  Updated at:", updatedAt);
        console.log("  Current time:", block.timestamp);
        console.log("  Staleness:", staleness, "seconds");
        console.log("           =", staleness / 3600, "hours");

        // Calculate if there's a depeg
        uint256 expectedPrice = 1e8; // $1.00
        uint256 actualPrice = uint256(price);

        if (actualPrice < expectedPrice) {
            uint256 depeg = (expectedPrice - actualPrice) * 100 / expectedPrice;
            console.log("\n  DEPEG DETECTED (bps):", depeg);
        }
    }

    function test_CheckLendingProtocolsForSUSDe() public view {
        console.log("=== Checking Lending Protocols for sUSDe ===\n");

        IERC20 susde = IERC20(SUSDE);

        // Check sUSDe balance in various protocols
        address[] memory protocols = new address[](5);
        protocols[0] = AAVE_POOL;
        protocols[1] = MORPHO_BLUE;
        protocols[2] = EULER_V2;
        protocols[3] = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9; // Aave V2
        protocols[4] = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5; // Compound ETH

        string[5] memory names = [
            "Aave V3",
            "Morpho Blue",
            "Euler V2",
            "Aave V2",
            "Compound"
        ];

        for (uint i = 0; i < protocols.length; i++) {
            if (protocols[i].code.length == 0) continue;

            uint256 balance = susde.balanceOf(protocols[i]);
            if (balance > 0) {
                console.log(names[i], "sUSDe balance:", balance / 1e18);
            }
        }
    }

    function test_FindSUSDeIntegrations() public view {
        console.log("=== Finding sUSDe DeFi Integrations ===\n");

        IERC20 susde = IERC20(SUSDE);
        IERC20 usde = IERC20(USDE);

        // Check total supply and distribution
        uint256 totalSupply = susde.totalSupply();
        console.log("sUSDe Total Supply:", totalSupply / 1e18);

        // Major DeFi protocol addresses to check
        address[] memory defiAddrs = new address[](10);
        defiAddrs[0] = 0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee; // Pendle YT
        defiAddrs[1] = 0x4c9EDD5852cd905f086C759E8383e09bff1E68B3; // USDe
        defiAddrs[2] = 0x5d3a1Ff2b6BAb83b63cd9AD0787074081a52ef34; // sUSDe market?
        defiAddrs[3] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // USDC
        defiAddrs[4] = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // USDT
        defiAddrs[5] = 0x6B175474E89094C44Da98b954EedeAC495271d0F; // DAI
        defiAddrs[6] = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0; // wstETH
        defiAddrs[7] = 0xae78736Cd615f374D3085123A210448E74Fc6393; // rETH
        defiAddrs[8] = 0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e; // Curve USDe pool?
        defiAddrs[9] = 0x02950460E2b9529D0E00284A5fA2d7bDF3fA4d72; // Morpho sUSDe?

        for (uint i = 0; i < defiAddrs.length; i++) {
            if (defiAddrs[i].code.length == 0) continue;

            uint256 balance = susde.balanceOf(defiAddrs[i]);
            if (balance > 1000e18) { // More than 1000 sUSDe
                console.log("Address", i, "has sUSDe:", balance / 1e18);
            }
        }
    }

    function test_OracleArbitrage() public view {
        console.log("=== Oracle Arbitrage Analysis ===\n");

        IChainlinkOracle oracle = IChainlinkOracle(USDE_USD_ORACLE);
        int256 oraclePrice = oracle.latestAnswer();

        // Oracle says 0.999238 USD
        uint256 oracleUSD = uint256(oraclePrice);

        console.log("Oracle USDe price:", oracleUSD, "(1e8 = $1.00)");

        // If a lending protocol uses this oracle and it's stale:
        // 1. Oracle says USDe = $0.999
        // 2. If real price has moved (up or down), there's arbitrage

        // Case 1: Real price went UP to $1.001
        // - Oracle undervalues collateral
        // - Attacker deposits at real price
        // - Protocol values at oracle price (lower)
        // - Attacker can borrow less than they should
        // - NOT profitable

        // Case 2: Real price went DOWN to $0.995
        // - Oracle overvalues collateral
        // - Attacker deposits USDe
        // - Protocol thinks it's worth $0.999 (oracle)
        // - Reality is $0.995
        // - Attacker borrows more than collateral is worth
        // - PROFITABLE if price drops further before liquidation

        console.log("\nOracle Staleness Attack:");
        console.log("If oracle price > real price:");
        console.log("  1. Deposit USDe as collateral");
        console.log("  2. Protocol overvalues (uses stale oracle)");
        console.log("  3. Borrow more than collateral worth");
        console.log("  4. Profit = overvaluation - fees");

        console.log("\nRequires:");
        console.log("  - Lending protocol using this oracle");
        console.log("  - No additional price validation");
        console.log("  - Significant price movement during staleness");
    }

    function test_CheckMorphoForSUSDe() public view {
        console.log("=== Morpho Blue sUSDe Analysis ===\n");

        // Check if Morpho Blue has sUSDe markets
        if (MORPHO_BLUE.code.length == 0) {
            console.log("Morpho Blue not found");
            return;
        }

        IERC20 susde = IERC20(SUSDE);
        uint256 morphoBalance = susde.balanceOf(MORPHO_BLUE);

        console.log("sUSDe in Morpho Blue:", morphoBalance / 1e18);

        if (morphoBalance > 0) {
            console.log("\nMorpho Blue has sUSDe markets!");
            console.log("Investigate oracle configuration...");
        }
    }
}
