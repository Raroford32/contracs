// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title CrossProtocolAnalysis
 * @notice Analyzes cross-protocol compositions for semantic mismatches
 * @dev Focus on: Convex+Curve, Aura+Balancer, and similar composites
 *
 * Valid hypothesis categories (per CLAUDE.md):
 * - CROSS_CONTRACT_SEMANTIC_MISMATCH
 * - ACCOUNTING_DIVERGENCE_OVER_TIME
 * - ORACLE_ECONOMIC_ATTACK (with cost model)
 * - TIMING_WINDOW_EXPLOITATION
 * - CROSS_PROTOCOL_COMPOSITION
 */
contract CrossProtocolAnalysis is Test {
    // === CONVEX PROTOCOL ===
    address constant CONVEX_BOOSTER = 0xF403C135812408BFbE8713b5A23a04b3D48AAE31;
    address constant CONVEX_CVX_TOKEN = 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;
    address constant CONVEX_REWARD_FACTORY = 0xEdCCB35798fAE4925718A43cc608aE136208aa8D;
    address constant CONVEX_STAKER = 0x989AEb4d175e16225E39E87d0D97A3360524AD80;

    // === CURVE PROTOCOL ===
    address constant CURVE_GAUGE_CONTROLLER = 0x2F50D538606Fa9EDD2B11E2446BEb18C9D5846bB;
    address constant CURVE_CRV_TOKEN = 0xD533a949740bb3306d119CC777fa900bA034cd52;
    address constant CURVE_MINTER = 0xd061D61a4d941c39E5453435B6345Dc261C2fcE0;
    address constant CURVE_VOTE_ESCROW = 0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2;

    // === AURA PROTOCOL ===
    address constant AURA_BOOSTER = 0xA57b8d98dAE62B26Ec3bcC4a365338157060B234;
    address constant AURA_TOKEN = 0xC0c293ce456fF0ED870ADd98a0828Dd4d2903DBF;

    // === BALANCER PROTOCOL ===
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address constant BALANCER_BAL_TOKEN = 0xba100000625a3754423978a60c9317c58a424e3D;

    // === INTERFACES ===

    interface IConvexBooster {
        function poolInfo(uint256 _pid) external view returns (
            address lptoken,
            address token,
            address gauge,
            address crvRewards,
            address stash,
            bool shutdown
        );
        function poolLength() external view returns (uint256);
        function deposit(uint256 _pid, uint256 _amount, bool _stake) external returns (bool);
        function withdraw(uint256 _pid, uint256 _amount) external returns (bool);
        function earmarkRewards(uint256 _pid) external returns (bool);
        function earmarkFees() external returns (bool);
        function isShutdown() external view returns (bool);
        function owner() external view returns (address);
        function feeManager() external view returns (address);
        function lockIncentive() external view returns (uint256);
        function stakerIncentive() external view returns (uint256);
        function earmarkIncentive() external view returns (uint256);
        function platformFee() external view returns (uint256);
        function FEE_DENOMINATOR() external view returns (uint256);
    }

    interface ICurveGauge {
        function deposit(uint256 _value) external;
        function deposit(uint256 _value, address _addr) external;
        function withdraw(uint256 _value) external;
        function balanceOf(address _account) external view returns (uint256);
        function totalSupply() external view returns (uint256);
        function claimable_reward(address _addr, address _token) external view returns (uint256);
        function claimable_tokens(address _addr) external returns (uint256);
        function claim_rewards() external;
        function reward_tokens(uint256 _i) external view returns (address);
        function reward_count() external view returns (uint256);
        function lp_token() external view returns (address);
        function working_supply() external view returns (uint256);
        function working_balances(address _addr) external view returns (uint256);
        function integrate_fraction(address _addr) external view returns (uint256);
    }

    interface IBaseRewardPool {
        function stake(uint256 _amount) external returns (bool);
        function stakeFor(address _for, uint256 _amount) external returns (bool);
        function withdraw(uint256 _amount, bool _claim) external returns (bool);
        function withdrawAndUnwrap(uint256 _amount, bool _claim) external returns (bool);
        function getReward(address _account, bool _claimExtras) external returns (bool);
        function earned(address _account) external view returns (uint256);
        function totalSupply() external view returns (uint256);
        function balanceOf(address _account) external view returns (uint256);
        function rewardToken() external view returns (address);
        function rewardRate() external view returns (uint256);
        function periodFinish() external view returns (uint256);
        function lastUpdateTime() external view returns (uint256);
        function rewardPerTokenStored() external view returns (uint256);
        function queuedRewards() external view returns (uint256);
        function currentRewards() external view returns (uint256);
        function historicalRewards() external view returns (uint256);
        function duration() external view returns (uint256);
        function extraRewardsLength() external view returns (uint256);
        function extraRewards(uint256) external view returns (address);
    }

    interface IStaker {
        function balanceOfPool(address _gauge) external view returns (uint256);
        function operator() external view returns (address);
    }

    interface IERC20 {
        function balanceOf(address) external view returns (uint256);
        function totalSupply() external view returns (uint256);
        function transfer(address, uint256) external returns (bool);
        function approve(address, uint256) external returns (bool);
    }

    interface ICRVMinter {
        function mint(address _gauge) external;
        function minted(address _user, address _gauge) external view returns (uint256);
    }

    // === TEST FUNCTIONS ===

    function setUp() public {
        // Fork mainnet at recent block
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    /**
     * @notice HYPOTHESIS 1: Accounting Divergence Between Convex and Curve
     * @dev Check if there's ever a mismatch between:
     *      - Convex's recorded gauge deposits
     *      - Actual gauge balances
     *      - Reward calculations
     */
    function test_H1_ConvexCurveAccountingDivergence() public {
        console.log("=== H1: Convex-Curve Accounting Divergence Analysis ===");

        IConvexBooster booster = IConvexBooster(CONVEX_BOOSTER);
        IStaker staker = IStaker(CONVEX_STAKER);

        uint256 poolLength = booster.poolLength();
        console.log("Total Convex pools:", poolLength);

        uint256 divergentPools = 0;

        // Analyze first 50 pools for divergence
        for (uint256 i = 0; i < 50 && i < poolLength; i++) {
            (
                address lptoken,
                address token,
                address gauge,
                address crvRewards,
                address stash,
                bool shutdown
            ) = booster.poolInfo(i);

            if (shutdown || gauge == address(0)) continue;

            // Check staker's balance in gauge vs recorded
            uint256 stakerGaugeBalance;
            try staker.balanceOfPool(gauge) returns (uint256 bal) {
                stakerGaugeBalance = bal;
            } catch {
                continue;
            }

            // Get actual gauge balance for Convex staker
            uint256 actualGaugeBalance;
            try ICurveGauge(gauge).balanceOf(CONVEX_STAKER) returns (uint256 bal) {
                actualGaugeBalance = bal;
            } catch {
                continue;
            }

            // Check for divergence
            if (stakerGaugeBalance != actualGaugeBalance) {
                divergentPools++;
                console.log("DIVERGENCE FOUND in pool", i);
                console.log("  Staker recorded:", stakerGaugeBalance);
                console.log("  Actual gauge bal:", actualGaugeBalance);
                console.log("  Difference:",
                    stakerGaugeBalance > actualGaugeBalance
                        ? stakerGaugeBalance - actualGaugeBalance
                        : actualGaugeBalance - stakerGaugeBalance
                );
            }
        }

        console.log("\nTotal divergent pools found:", divergentPools);
    }

    /**
     * @notice HYPOTHESIS 2: Reward Timing Window Exploitation
     * @dev Check if there's a timing window between:
     *      - CRV minting on Curve
     *      - Reward distribution on Convex
     *      That could allow capturing rewards without proportional stake time
     */
    function test_H2_RewardTimingWindow() public {
        console.log("=== H2: Reward Timing Window Analysis ===");

        IConvexBooster booster = IConvexBooster(CONVEX_BOOSTER);

        // Get fee structure
        uint256 lockIncentive = booster.lockIncentive();
        uint256 stakerIncentive = booster.stakerIncentive();
        uint256 earmarkIncentive = booster.earmarkIncentive();
        uint256 platformFee = booster.platformFee();
        uint256 denominator = booster.FEE_DENOMINATOR();

        console.log("Convex Fee Structure:");
        console.log("  Lock Incentive:", lockIncentive, "/ 10000");
        console.log("  Staker Incentive:", stakerIncentive, "/ 10000");
        console.log("  Earmark Incentive:", earmarkIncentive, "/ 10000");
        console.log("  Platform Fee:", platformFee, "/ 10000");

        // Analyze high-TVL pools for timing windows
        uint256 poolLength = booster.poolLength();

        for (uint256 i = 0; i < 20 && i < poolLength; i++) {
            (,, address gauge, address crvRewards,,bool shutdown) = booster.poolInfo(i);
            if (shutdown || crvRewards == address(0)) continue;

            IBaseRewardPool rewardPool = IBaseRewardPool(crvRewards);

            uint256 periodFinish = rewardPool.periodFinish();
            uint256 rewardRate = rewardPool.rewardRate();
            uint256 queuedRewards = rewardPool.queuedRewards();
            uint256 duration = rewardPool.duration();
            uint256 totalSupply = rewardPool.totalSupply();

            // Check if rewards have expired and there are queued rewards
            if (block.timestamp > periodFinish && queuedRewards > 0) {
                console.log("\nTIMING WINDOW FOUND in pool", i);
                console.log("  Period finished:", periodFinish);
                console.log("  Current time:", block.timestamp);
                console.log("  Queued rewards:", queuedRewards);
                console.log("  Total staked:", totalSupply);

                // Calculate potential profit from calling earmarkRewards
                uint256 earmarkBonus = (queuedRewards * earmarkIncentive) / denominator;
                console.log("  Earmark bonus available:", earmarkBonus);
            }

            // Check for pending CRV on gauge
            try ICurveGauge(gauge).claimable_tokens(CONVEX_STAKER) returns (uint256 pending) {
                if (pending > 1e20) { // More than 100 CRV
                    console.log("\nLARGE PENDING CRV in pool", i);
                    console.log("  Gauge:", gauge);
                    console.log("  Pending CRV:", pending / 1e18, "CRV");

                    // Calculate earmark incentive
                    uint256 potentialBonus = (pending * earmarkIncentive) / denominator;
                    console.log("  Potential earmark bonus:", potentialBonus / 1e18, "CRV");
                }
            } catch {}
        }
    }

    /**
     * @notice HYPOTHESIS 3: Cross-Protocol State Inconsistency
     * @dev Analyze if state can become inconsistent between:
     *      - Curve gauge state
     *      - Convex pool state
     *      - Reward pool state
     */
    function test_H3_CrossProtocolStateInconsistency() public {
        console.log("=== H3: Cross-Protocol State Inconsistency ===");

        IConvexBooster booster = IConvexBooster(CONVEX_BOOSTER);

        uint256 poolLength = booster.poolLength();
        console.log("Analyzing", poolLength, "pools for state inconsistency");

        uint256 inconsistentPools = 0;

        for (uint256 i = 0; i < 30 && i < poolLength; i++) {
            (
                address lptoken,
                address token,  // cvxLP token
                address gauge,
                address crvRewards,
                address stash,
                bool shutdown
            ) = booster.poolInfo(i);

            if (shutdown || gauge == address(0) || crvRewards == address(0)) continue;

            // Get total supplies from different sources
            uint256 gaugeSupply;
            try ICurveGauge(gauge).totalSupply() returns (uint256 s) {
                gaugeSupply = s;
            } catch { continue; }

            uint256 rewardPoolSupply;
            try IBaseRewardPool(crvRewards).totalSupply() returns (uint256 s) {
                rewardPoolSupply = s;
            } catch { continue; }

            uint256 cvxLPSupply;
            try IERC20(token).totalSupply() returns (uint256 s) {
                cvxLPSupply = s;
            } catch { continue; }

            // Check Convex staker's balance in gauge
            uint256 stakerGaugeBalance;
            try ICurveGauge(gauge).balanceOf(CONVEX_STAKER) returns (uint256 b) {
                stakerGaugeBalance = b;
            } catch { continue; }

            // State consistency checks:
            // 1. cvxLP supply should match staker's gauge balance (minus any dust)
            // 2. Reward pool supply should match staked cvxLP

            bool inconsistent = false;
            string memory reason;

            // Check if cvxLP supply diverged from gauge deposits
            if (cvxLPSupply > 0 && stakerGaugeBalance > 0) {
                uint256 diff = cvxLPSupply > stakerGaugeBalance
                    ? cvxLPSupply - stakerGaugeBalance
                    : stakerGaugeBalance - cvxLPSupply;

                // Allow 0.1% tolerance
                if (diff > cvxLPSupply / 1000) {
                    inconsistent = true;
                    reason = "cvxLP vs gauge balance mismatch";
                }
            }

            if (inconsistent) {
                inconsistentPools++;
                console.log("\nINCONSISTENCY in pool", i);
                console.log("  Reason:", reason);
                console.log("  Gauge total supply:", gaugeSupply);
                console.log("  Staker gauge balance:", stakerGaugeBalance);
                console.log("  cvxLP total supply:", cvxLPSupply);
                console.log("  Reward pool supply:", rewardPoolSupply);
            }
        }

        console.log("\nTotal inconsistent pools:", inconsistentPools);
    }

    /**
     * @notice HYPOTHESIS 4: Extra Rewards Semantic Mismatch
     * @dev Check if extra reward tokens on Curve gauges are handled
     *      differently than CRV rewards, potentially causing loss
     */
    function test_H4_ExtraRewardsSementicMismatch() public {
        console.log("=== H4: Extra Rewards Semantic Mismatch ===");

        IConvexBooster booster = IConvexBooster(CONVEX_BOOSTER);
        uint256 poolLength = booster.poolLength();

        for (uint256 i = 0; i < 50 && i < poolLength; i++) {
            (,, address gauge, address crvRewards, address stash, bool shutdown) = booster.poolInfo(i);
            if (shutdown || gauge == address(0)) continue;

            // Check for extra rewards on gauge
            try ICurveGauge(gauge).reward_count() returns (uint256 count) {
                if (count > 0) {
                    console.log("\nPool", i, "has", count, "extra reward tokens");

                    for (uint256 j = 0; j < count; j++) {
                        address rewardToken = ICurveGauge(gauge).reward_tokens(j);
                        console.log("  Reward token", j, ":", rewardToken);

                        // Check claimable rewards for Convex staker
                        try ICurveGauge(gauge).claimable_reward(CONVEX_STAKER, rewardToken) returns (uint256 claimable) {
                            if (claimable > 0) {
                                console.log("    Claimable:", claimable);

                                // Check if this reward is tracked on Convex side
                                IBaseRewardPool rewardPool = IBaseRewardPool(crvRewards);
                                uint256 extraLength = rewardPool.extraRewardsLength();

                                bool found = false;
                                for (uint256 k = 0; k < extraLength; k++) {
                                    address extraReward = rewardPool.extraRewards(k);
                                    if (extraReward != address(0)) {
                                        try IBaseRewardPool(extraReward).rewardToken() returns (address rt) {
                                            if (rt == rewardToken) found = true;
                                        } catch {}
                                    }
                                }

                                if (!found && claimable > 1e18) {
                                    console.log("    WARNING: Reward not tracked on Convex! Potential loss");
                                }
                            }
                        } catch {}
                    }
                }
            } catch {}
        }
    }

    /**
     * @notice HYPOTHESIS 5: Earmark Timing MEV Opportunity
     * @dev Analyze if there's profitable MEV from:
     *      - Calling earmarkRewards at optimal times
     *      - Front-running large deposits with earmark
     */
    function test_H5_EarmarkTimingMEV() public {
        console.log("=== H5: Earmark Timing MEV Analysis ===");

        IConvexBooster booster = IConvexBooster(CONVEX_BOOSTER);

        uint256 earmarkIncentive = booster.earmarkIncentive();
        console.log("Earmark incentive:", earmarkIncentive, "/ 10000");

        uint256 poolLength = booster.poolLength();
        uint256 totalPendingValue = 0;

        for (uint256 i = 0; i < 100 && i < poolLength; i++) {
            (,, address gauge, address crvRewards,, bool shutdown) = booster.poolInfo(i);
            if (shutdown || gauge == address(0)) continue;

            // Check pending CRV
            try ICurveGauge(gauge).claimable_tokens(CONVEX_STAKER) returns (uint256 pending) {
                if (pending > 0) {
                    uint256 earmarkBonus = (pending * earmarkIncentive) / 10000;
                    totalPendingValue += earmarkBonus;

                    if (earmarkBonus > 1e17) { // > 0.1 CRV
                        console.log("Pool", i, "earmark bonus:", earmarkBonus / 1e18, "CRV");
                    }
                }
            } catch {}
        }

        console.log("\nTotal earmark bonus available:", totalPendingValue / 1e18, "CRV");

        // CRV price ~$0.50
        uint256 usdValue = (totalPendingValue * 50) / (100 * 1e18);
        console.log("Approximate USD value:", usdValue);
    }

    /**
     * @notice HYPOTHESIS 6: Shutdown Pool Reward Extraction
     * @dev Check if shutdown pools have stranded rewards that can be extracted
     */
    function test_H6_ShutdownPoolRewards() public {
        console.log("=== H6: Shutdown Pool Reward Analysis ===");

        IConvexBooster booster = IConvexBooster(CONVEX_BOOSTER);
        uint256 poolLength = booster.poolLength();

        uint256 shutdownPools = 0;
        uint256 totalStrandedCRV = 0;

        for (uint256 i = 0; i < poolLength; i++) {
            (,, address gauge, address crvRewards,, bool shutdown) = booster.poolInfo(i);

            if (shutdown) {
                shutdownPools++;

                // Check for stranded rewards
                if (crvRewards != address(0)) {
                    try IBaseRewardPool(crvRewards).queuedRewards() returns (uint256 queued) {
                        if (queued > 0) {
                            totalStrandedCRV += queued;
                            console.log("Shutdown pool", i, "has queued rewards:", queued / 1e18, "CRV");
                        }
                    } catch {}

                    // Check historical rewards
                    try IBaseRewardPool(crvRewards).historicalRewards() returns (uint256 historical) {
                        if (historical > 0) {
                            console.log("  Historical rewards:", historical / 1e18, "CRV");
                        }
                    } catch {}
                }
            }
        }

        console.log("\nTotal shutdown pools:", shutdownPools);
        console.log("Total potentially stranded CRV:", totalStrandedCRV / 1e18);
    }

    /**
     * @notice HYPOTHESIS 7: Working Balance Desync
     * @dev Check if Curve gauge working_balances (boost) are synced with deposits
     */
    function test_H7_WorkingBalanceDesync() public {
        console.log("=== H7: Working Balance Desync Analysis ===");

        IConvexBooster booster = IConvexBooster(CONVEX_BOOSTER);
        uint256 poolLength = booster.poolLength();

        for (uint256 i = 0; i < 30 && i < poolLength; i++) {
            (,, address gauge,,, bool shutdown) = booster.poolInfo(i);
            if (shutdown || gauge == address(0)) continue;

            try ICurveGauge(gauge).working_supply() returns (uint256 workingSupply) {
                try ICurveGauge(gauge).totalSupply() returns (uint256 totalSupply) {
                    if (totalSupply > 0) {
                        // Check working balance ratio
                        // Max boost is 2.5x, so working_supply should be between totalSupply and 2.5*totalSupply
                        uint256 ratio = (workingSupply * 100) / totalSupply;

                        if (ratio < 40) { // Less than 40% of max boost utilized
                            // Check Convex's working balance
                            try ICurveGauge(gauge).working_balances(CONVEX_STAKER) returns (uint256 convexWorking) {
                                try ICurveGauge(gauge).balanceOf(CONVEX_STAKER) returns (uint256 convexBalance) {
                                    if (convexBalance > 0) {
                                        uint256 convexRatio = (convexWorking * 100) / convexBalance;

                                        if (convexRatio < 100) {
                                            console.log("Pool", i, "- Convex boost suboptimal");
                                            console.log("  Working balance ratio:", convexRatio, "%");
                                            console.log("  Convex balance:", convexBalance / 1e18);
                                            console.log("  Convex working:", convexWorking / 1e18);
                                        }
                                    }
                                }
                            } catch {}
                        }
                    }
                }
            } catch {}
        }
    }

    /**
     * @notice Master analysis function
     */
    function test_MasterAnalysis() public {
        console.log("=== MASTER CROSS-PROTOCOL ANALYSIS ===\n");

        // Run all hypothesis tests
        test_H1_ConvexCurveAccountingDivergence();
        console.log("\n---\n");

        test_H2_RewardTimingWindow();
        console.log("\n---\n");

        test_H3_CrossProtocolStateInconsistency();
        console.log("\n---\n");

        test_H4_ExtraRewardsSementicMismatch();
        console.log("\n---\n");

        test_H5_EarmarkTimingMEV();
        console.log("\n---\n");

        test_H6_ShutdownPoolRewards();
        console.log("\n---\n");

        test_H7_WorkingBalanceDesync();
    }
}
