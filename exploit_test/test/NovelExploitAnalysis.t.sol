// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
}

interface IStakingRewards {
    function stake(uint256 amount) external;
    function withdraw(uint256 amount) external;
    function getReward() external;
    function earned(address account) external view returns (uint256);
    function rewardRate() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function balanceOf(address) external view returns (uint256);
    function stakingToken() external view returns (address);
    function rewardsToken() external view returns (address);
    function periodFinish() external view returns (uint256);
    function lastTimeRewardApplicable() external view returns (uint256);
    function rewardPerToken() external view returns (uint256);
}

interface IPositionManager {
    function deposit(uint256 amount) external;
    function withdraw(uint256 amount) external;
    function claimRewards() external;
    function pendingRewards(address user) external view returns (uint256);
}

interface IERC20Handler {
    function deposit(bytes32 resourceID, address depositor, bytes calldata data) external;
    function withdraw(bytes calldata data) external;
}

interface IEarlyAdopterPool {
    function deposit() external payable;
    function withdraw() external;
    function claim() external;
    function userDeposits(address) external view returns (uint256 amount, uint256 timestamp);
}

contract NovelExploitAnalysis is Test {
    // High-value contracts from analysis
    address constant STAKING_REWARDS = 0x4F48031B0EF8acCea3052Af00A3279fbA31b50D8;
    address constant POSITION_MANAGER = 0x5bb8e5e8602b71b182e0Efe256896a931489A135;
    address constant ERC20_HANDLER = 0x2F1d2754393356AEA6334180DA04BAB84412D580;
    address constant EARLY_ADOPTER = 0x7623e9DC0DA6FF821ddb9EbABA794054E078f8c4;
    address constant HUB_POOL = 0xc186fA914353c44b2E33eBE05f21846F1048bEda;

    // Tokens
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant steCRV = 0x06325440D014e39736583c165C2963BA99fAf14E;
    address constant CHZ = 0x3506424F91fD33084466F402d5D97f05F8e3b4AF;

    // Aave flash loan
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;

    function setUp() public {
        // Fork mainnet at latest block
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testAnalyzeStakingRewards() public view {
        // StakingRewards has ~$120M in LP tokens
        console.log("=== StakingRewards Analysis ===");

        IStakingRewards staking = IStakingRewards(STAKING_REWARDS);

        console.log("Staking Token:", staking.stakingToken());
        console.log("Rewards Token:", staking.rewardsToken());
        console.log("Total Supply:", staking.totalSupply());
        console.log("Reward Rate:", staking.rewardRate());
        console.log("Period Finish:", staking.periodFinish());
        console.log("Current Time:", block.timestamp);

        // Check if rewards are active
        if (staking.periodFinish() > block.timestamp) {
            console.log("Rewards ARE ACTIVE");
            uint256 timeRemaining = staking.periodFinish() - block.timestamp;
            console.log("Time Remaining (seconds):", timeRemaining);

            // Calculate potential reward capture
            uint256 rewardsPerSecond = staking.rewardRate();
            console.log("Rewards per second:", rewardsPerSecond);
        } else {
            console.log("Rewards are EXPIRED");
        }

        // Check steCRV LP token balance
        address stakingToken = staking.stakingToken();
        uint256 contractBalance = IERC20(stakingToken).balanceOf(STAKING_REWARDS);
        console.log("Contract LP Balance:", contractBalance);
    }

    function testAnalyzePositionManager() public view {
        // PositionManager has ~$108M staked
        console.log("=== PositionManager Analysis ===");
        console.log("Contract:", POSITION_MANAGER);
        console.log("ETH Balance:", POSITION_MANAGER.balance);

        // Try to read any public variables
        (bool success, bytes memory data) = POSITION_MANAGER.staticcall(abi.encodeWithSignature("totalStaked()"));
        if (success && data.length >= 32) {
            uint256 totalStaked = abi.decode(data, (uint256));
            console.log("Total Staked:", totalStaked);
        }

        // Try owner
        (success, data) = POSITION_MANAGER.staticcall(abi.encodeWithSignature("owner()"));
        if (success && data.length >= 32) {
            address owner = abi.decode(data, (address));
            console.log("Owner:", owner);
        }
    }

    function testAnalyzeERC20Handler() public view {
        // ERC20Handler has ~$124M CHZ
        console.log("=== ERC20Handler Analysis ===");

        uint256 chzBalance = IERC20(CHZ).balanceOf(ERC20_HANDLER);
        console.log("CHZ Balance:", chzBalance);
        console.log("CHZ Decimals:", IERC20(CHZ).decimals());

        // Read bridge address
        (bool success, bytes memory data) = ERC20_HANDLER.staticcall(abi.encodeWithSignature("_bridgeAddress()"));
        if (success && data.length >= 32) {
            address bridge = abi.decode(data, (address));
            console.log("Bridge Address:", bridge);
        }
    }

    function testAnalyzeEarlyAdopterPool() public {
        // EarlyAdopterPool has 627 ETH
        console.log("=== EarlyAdopterPool Analysis ===");
        console.log("Contract:", EARLY_ADOPTER);
        console.log("ETH Balance:", EARLY_ADOPTER.balance);

        IEarlyAdopterPool pool = IEarlyAdopterPool(EARLY_ADOPTER);

        // Try to read contract state
        (bool success, bytes memory data) = EARLY_ADOPTER.staticcall(abi.encodeWithSignature("claimingOpen()"));
        if (success && data.length >= 32) {
            bool claimingOpen = abi.decode(data, (bool));
            console.log("Claiming Open:", claimingOpen);
        }

        (success, data) = EARLY_ADOPTER.staticcall(abi.encodeWithSignature("owner()"));
        if (success && data.length >= 32) {
            address owner = abi.decode(data, (address));
            console.log("Owner:", owner);
        }

        // Check for pausable state
        (success, data) = EARLY_ADOPTER.staticcall(abi.encodeWithSignature("paused()"));
        if (success && data.length >= 32) {
            bool paused = abi.decode(data, (bool));
            console.log("Paused:", paused);
        }
    }

    function testAnalyzeHubPool() public view {
        // HubPool has ~$10M
        console.log("=== HubPool Analysis ===");
        console.log("Contract:", HUB_POOL);
        console.log("ETH Balance:", HUB_POOL.balance);
        console.log("WETH Balance:", IERC20(WETH).balanceOf(HUB_POOL));

        // Check for utilizedReserves and liquidReserves
        (bool success, bytes memory data) = HUB_POOL.staticcall(
            abi.encodeWithSignature("pooledTokens(address)", WETH)
        );
        if (success && data.length >= 128) {
            // PooledToken struct has multiple fields
            console.log("PooledTokens data retrieved");
        }
    }

    function testNovelFlashLoanScenario() public {
        console.log("=== Novel Flash Loan Scenario Analysis ===");

        // Check AAVE pool liquidity for potential flash loans
        uint256 aaveWethBalance = IERC20(WETH).balanceOf(AAVE_POOL);
        console.log("AAVE WETH Liquidity:", aaveWethBalance);

        // We can flash loan up to this amount for attacks
        // Flash loan fee is 0.05% on Aave V3
        uint256 flashLoanFee = aaveWethBalance * 5 / 10000;
        console.log("Flash Loan Fee for max:", flashLoanFee);

        // Look for contracts where flash loan could:
        // 1. Manipulate exchange rates
        // 2. Capture time-weighted rewards immediately
        // 3. Bypass solvency checks
        // 4. Exploit precision loss in calculations
    }

    function testMathEdgeCases() public pure {
        console.log("=== Math Edge Case Analysis ===");

        // Test precision loss scenarios
        // Common in reward calculations: (amount * rewardPerToken) / 1e18

        // Edge case 1: Very small amounts
        uint256 smallAmount = 1;
        uint256 rewardPerToken = 1e17; // 0.1 tokens per token staked
        uint256 reward = (smallAmount * rewardPerToken) / 1e18;
        console.log("Small amount reward (should be 0):", reward);

        // Edge case 2: Accumulator overflow potential
        uint256 maxUint = type(uint256).max;
        uint256 safeMultiplier = 1e18;
        // This would overflow: maxUint * safeMultiplier
        console.log("Max uint256:", maxUint);

        // Edge case 3: Division truncation
        uint256 totalSupply = 1e18 + 1;
        uint256 rewards = 1e18;
        uint256 perToken = (rewards * 1e18) / totalSupply;
        uint256 reconstructed = (perToken * totalSupply) / 1e18;
        uint256 dustLost = rewards - reconstructed;
        console.log("Dust lost per distribution:", dustLost);
    }
}
