// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

interface IBAMM {
    function getSwapCollateralAmount(uint thusdQty) external view returns (uint collateralAmount);
    function getSwapTHUSDAmount(uint collateralQty) external view returns (uint thusdAmount);
    function swap(uint thusdAmount, uint minCollateralOut, address to) external returns (uint collateralAmount);
    function deposit(uint256 amount) external;
    function withdraw(uint256 numShares) external;
    function fetchPrice() external view returns (uint256);
    function A() external view returns (uint256);
    function fee() external view returns (uint256);
    function maxDiscount() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function balanceOf(address) external view returns (uint256);
    function collateralToken() external view returns (address);
    function thusdToken() external view returns (address);
    function collateralInBAMM() external view returns (uint256);
    function THUSDInBAMM() external view returns (uint256);
    function owner() external view returns (address);
}

interface IPriceFormula {
    function getReturn(uint256 xQty, uint256 xBalance, uint256 yBalance, uint256 A) external view returns (uint256);
    function getSumFixedPoint(uint256 x, uint256 y, uint256 A) external view returns (uint256);
}

contract BAMMExploitAnalysis is Test {
    address constant BAMM = 0x097f1ee62E63aCFC3Bf64c1a61d96B3771dd06cB;

    // Common tokens
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function testBAMMDeepAnalysis() public {
        console.log("=====================================================");
        console.log("BAMM (B.PROTOCOL AMM) - CETUS/BALANCER STYLE ANALYSIS");
        console.log("=====================================================");

        IBAMM bamm = IBAMM(BAMM);

        console.log("\n--- Contract State ---");
        console.log("BAMM Address:", BAMM);
        console.log("ETH Balance:", BAMM.balance);

        // Get token addresses
        try bamm.collateralToken() returns (address collToken) {
            console.log("Collateral Token:", collToken);
            uint256 collBalance = IERC20(collToken).balanceOf(BAMM);
            console.log("Collateral Balance:", collBalance);
        } catch {
            console.log("Could not get collateral token");
        }

        try bamm.thusdToken() returns (address thusd) {
            console.log("THUSD Token:", thusd);
            uint256 thusdBalance = IERC20(thusd).balanceOf(BAMM);
            console.log("THUSD Balance:", thusdBalance);
        } catch {
            console.log("Could not get THUSD token");
        }

        // Get BAMM parameters
        console.log("\n--- BAMM Parameters ---");

        try bamm.A() returns (uint256 A) {
            console.log("Amplification A:", A);
        } catch {
            console.log("Could not get A");
        }

        try bamm.fee() returns (uint256 fee) {
            console.log("Fee (bps):", fee);
        } catch {
            console.log("Could not get fee");
        }

        try bamm.maxDiscount() returns (uint256 maxDiscount) {
            console.log("Max Discount (bps):", maxDiscount);
        } catch {
            console.log("Could not get maxDiscount");
        }

        try bamm.totalSupply() returns (uint256 supply) {
            console.log("LP Total Supply:", supply);
        } catch {
            console.log("Could not get totalSupply");
        }

        // Get internal balances
        console.log("\n--- Internal Balances ---");

        try bamm.collateralInBAMM() returns (uint256 collInBamm) {
            console.log("Collateral in BAMM:", collInBamm);
        } catch {
            console.log("Could not get collateralInBAMM");
        }

        try bamm.THUSDInBAMM() returns (uint256 thusdInBamm) {
            console.log("THUSD in BAMM:", thusdInBamm);
        } catch {
            console.log("Could not get THUSDInBAMM");
        }

        // Check owner
        try bamm.owner() returns (address owner) {
            console.log("\nOwner:", owner);
        } catch {
            console.log("Could not get owner");
        }
    }

    function testBAMMPriceFormulaEdgeCases() public view {
        console.log("=====================================================");
        console.log("BAMM PRICE FORMULA - EDGE CASE ANALYSIS");
        console.log("=====================================================");

        // The price formula uses iterative calculation:
        // getSumFixedPoint: 255 max iterations
        // getReturn: Newton's method for quadratic

        // Potential vulnerabilities:
        // 1. Iteration doesn't converge (infinite gas)
        // 2. Newton's method diverges
        // 3. Overflow in intermediate calculations
        // 4. Precision loss in division

        console.log("\n--- Cetus/Balancer Style Vulnerabilities ---");
        console.log("1. Iterative calculation with 255 max iterations");
        console.log("   - Could fail to converge with extreme inputs");
        console.log("   - Could be manipulated to waste gas");

        console.log("\n2. Newton's method solving:");
        console.log("   - Could diverge with certain initial values");
        console.log("   - Rounding errors accumulate over iterations");

        console.log("\n3. Amplification factor A manipulation:");
        console.log("   - A affects curve shape (1-200 range)");
        console.log("   - Extreme A values could break invariant");

        console.log("\n4. Share inflation attack:");
        console.log("   - First depositor could inflate share value");
        console.log("   - _toShares rounding could be exploited");
    }

    function testBAMMSwapSimulation() public {
        console.log("=== BAMM Swap Simulation ===");

        IBAMM bamm = IBAMM(BAMM);

        // Check if swaps are possible
        uint256 testAmount = 1e18; // 1 THUSD

        try bamm.getSwapCollateralAmount(testAmount) returns (uint256 collOut) {
            console.log("1 THUSD -> Collateral:", collOut);

            // Check for rounding issues
            uint256 testSmall = 1; // 1 wei
            try bamm.getSwapCollateralAmount(testSmall) returns (uint256 smallOut) {
                console.log("1 wei THUSD -> Collateral:", smallOut);

                // If smallOut > 0 with 1 wei input, there might be rounding exploit
                if (smallOut > 0) {
                    console.log("WARNING: Non-zero output for 1 wei input!");
                    console.log("Potential rounding exploit!");
                }
            } catch {
                console.log("Small swap reverted (expected)");
            }
        } catch {
            console.log("Swap simulation failed - likely empty pool");
        }
    }

    function testBAMMFirstDepositorAttack() public {
        console.log("=== BAMM First Depositor Attack Analysis ===");

        IBAMM bamm = IBAMM(BAMM);

        uint256 totalSupply = bamm.totalSupply();
        console.log("Current LP Total Supply:", totalSupply);

        if (totalSupply == 0) {
            console.log("\n*** CRITICAL: Pool is EMPTY! ***");
            console.log("First depositor attack is possible!");
            console.log("\nAttack steps:");
            console.log("1. Deposit minimal amount (1 wei)");
            console.log("2. Receive 1 share");
            console.log("3. Donate tokens directly to contract");
            console.log("4. Share value inflates");
            console.log("5. Other depositors get 0 shares due to rounding");
            console.log("6. Attacker withdraws all donated tokens");
        } else {
            console.log("Pool has liquidity - checking share value...");

            // Get internal balances
            try bamm.collateralInBAMM() returns (uint256 collInBamm) {
                try bamm.THUSDInBAMM() returns (uint256 thusdInBamm) {
                    uint256 totalValue = collInBamm + thusdInBamm;
                    console.log("Total Value in Pool:", totalValue);
                    console.log("Value per Share:", totalValue / totalSupply);

                    // Check if share value is inflated
                    if (totalValue / totalSupply > 1e18) {
                        console.log("\nWARNING: Share value seems inflated!");
                    }
                } catch {}
            } catch {}
        }
    }
}
