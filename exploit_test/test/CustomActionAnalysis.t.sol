// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IAction {
    function executeAction(
        bytes memory _callData,
        bytes32[] memory _subData,
        uint8[] memory _paramMapping,
        bytes32[] memory _returnValues
    ) external payable returns (bytes32);
    function actionType() external view returns (uint8);
}

interface IActionRegistry {
    function getAddr(bytes4 _id) external view returns (address);
    function owner() external view returns (address);
    function isRegistered(bytes4 _id) external view returns (bool);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
}

contract CustomActionAnalysisTest is Test {
    address constant ACTION_REGISTRY = 0x94aF5994EB6841e1D930C95AD0C9F89771c3073F;
    address constant STRATEGY = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    
    // Custom action addresses from earlier analysis
    address constant CUSTOM_1 = 0xb8cD2bA2A0Ada353aE15398618Fafb1d7BD558C5;
    address constant CUSTOM_2 = 0x3e34E0694204e462Deaf8EBbeEE2bE9F887f3C3b;
    address constant CUSTOM_3 = 0x99eAe56224EA5Bcb2c886D0a07154217b7A1E5d1;
    address constant CUSTOM_4 = 0x819Bdb303e224CaC4aC14Da17a1ec13895869b65;
    address constant UNKNOWN_1 = 0x313Ca6136521D22A7Ea763B3566Ed0B53F5B3AB9;
    address constant UNKNOWN_2 = 0xc780112305ED959CEEeb0DE692E2407E4145Fc3A;
    address constant UNKNOWN_3 = 0x351dd4581d61BCE7101FDf5f6864D510021c7CaB;
    
    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeCustomAction1() public view {
        console.log("=== CUSTOM ACTION 1: 0xb8cD2bA2A0Ada353aE15398618Fafb1d7BD558C5 ===\n");
        
        bytes memory code = CUSTOM_1.code;
        console.log("Code size:", code.length);
        
        // Check action type
        try IAction(CUSTOM_1).actionType() returns (uint8 t) {
            console.log("Action type:", t);
        } catch {}
        
        // Check for selectors in code
        _findSelectors(code);
    }

    function test_AnalyzeCustomAction2() public view {
        console.log("=== CUSTOM ACTION 2: 0x3e34E0694204e462Deaf8EBbeEE2bE9F887f3C3b ===\n");
        
        bytes memory code = CUSTOM_2.code;
        console.log("Code size:", code.length);
        
        try IAction(CUSTOM_2).actionType() returns (uint8 t) {
            console.log("Action type:", t);
        } catch {}
        
        _findSelectors(code);
    }

    function test_AnalyzeUnknownAction1() public view {
        console.log("=== UNKNOWN ACTION 1: 0x313Ca6136521D22A7Ea763B3566Ed0B53F5B3AB9 ===\n");
        
        bytes memory code = UNKNOWN_1.code;
        console.log("Code size:", code.length);
        
        try IAction(UNKNOWN_1).actionType() returns (uint8 t) {
            console.log("Action type:", t);
        } catch {}
        
        _findSelectors(code);
    }

    function test_DirectActionCall() public {
        console.log("=== TRYING DIRECT ACTION CALLS ===\n");
        
        vm.startPrank(attacker);
        
        // Try calling action directly (not via delegatecall)
        // This shouldn't give us Strategy's context
        
        bytes memory callData = abi.encode(attacker, 1 ether);
        bytes32[] memory subData = new bytes32[](0);
        uint8[] memory paramMapping = new uint8[](0);
        bytes32[] memory returnValues = new bytes32[](0);
        
        address[] memory actions = new address[](4);
        actions[0] = CUSTOM_1;
        actions[1] = CUSTOM_2;
        actions[2] = CUSTOM_3;
        actions[3] = CUSTOM_4;
        
        for (uint i = 0; i < actions.length; i++) {
            console.log("Trying action:", actions[i]);
            try IAction(actions[i]).executeAction(callData, subData, paramMapping, returnValues) returns (bytes32 result) {
                console.log("SUCCESS! Result:");
                console.logBytes32(result);
            } catch Error(string memory reason) {
                console.log("Failed:", reason);
            } catch {
                console.log("Failed (unknown)");
            }
        }
        
        vm.stopPrank();
    }

    function test_CheckRegistryForAllActions() public view {
        console.log("=== SCANNING REGISTRY FOR ALL ACTIONS ===\n");
        
        // Try a range of action IDs
        IActionRegistry registry = IActionRegistry(ACTION_REGISTRY);
        
        // Known action IDs
        bytes4[] memory knownIds = new bytes4[](13);
        knownIds[0] = bytes4(0xd7e40b2d); // LidoStake
        knownIds[1] = bytes4(0x43142355); // LidoWrap
        knownIds[2] = bytes4(0xacd039ef); // Custom
        knownIds[3] = bytes4(0x2161dd34); // Custom
        knownIds[4] = bytes4(0x245077a0); // Custom
        knownIds[5] = bytes4(0x3d35d254); // Custom
        knownIds[6] = bytes4(0xfc33bf00); // AaveV3Supply
        knownIds[7] = bytes4(0x9e9290b1); // AaveV3Borrow
        knownIds[8] = bytes4(0x17683e81); // AaveV3Payback
        knownIds[9] = bytes4(0x72a6498a); // AaveV3Withdraw
        knownIds[10] = bytes4(0xfebcb52a); // Unknown
        knownIds[11] = bytes4(0x19713586); // Unknown
        knownIds[12] = bytes4(0x4f18b88c); // Unknown
        
        for (uint i = 0; i < knownIds.length; i++) {
            address actionAddr = registry.getAddr(knownIds[i]);
            console.log("Action ID:");
            console.logBytes4(knownIds[i]);
            console.log("Address:", actionAddr);
            console.log("Code size:", actionAddr.code.length);
            console.log("---");
        }
    }

    function test_CheckIfActionsHaveCallbacks() public view {
        console.log("=== CHECKING ACTIONS FOR CALLBACK PATTERNS ===\n");
        
        address[] memory actions = new address[](7);
        actions[0] = CUSTOM_1;
        actions[1] = CUSTOM_2;
        actions[2] = CUSTOM_3;
        actions[3] = CUSTOM_4;
        actions[4] = UNKNOWN_1;
        actions[5] = UNKNOWN_2;
        actions[6] = UNKNOWN_3;
        
        // Callback selectors to look for
        bytes4[] memory callbacks = new bytes4[](5);
        callbacks[0] = bytes4(keccak256("executeOperation(address[],uint256[],uint256[],address,bytes)"));
        callbacks[1] = bytes4(keccak256("receiveFlashLoan(address[],uint256[],uint256[],bytes)"));
        callbacks[2] = bytes4(keccak256("uniswapV3SwapCallback(int256,int256,bytes)"));
        callbacks[3] = bytes4(keccak256("onFlashLoan(address,address,uint256,uint256,bytes)"));
        callbacks[4] = bytes4(keccak256("fallback()"));
        
        for (uint i = 0; i < actions.length; i++) {
            bytes memory code = actions[i].code;
            console.log("\nAction:", actions[i]);
            
            for (uint j = 0; j < callbacks.length; j++) {
                bool found = _findSelectorInCode(code, callbacks[j]);
                if (found) {
                    console.log("FOUND CALLBACK:");
                    console.logBytes4(callbacks[j]);
                }
            }
        }
    }

    function _findSelectors(bytes memory code) internal pure {
        // Look for PUSH4 opcodes (0x63) in bytecode
        for (uint i = 0; i < code.length - 4; i++) {
            if (code[i] == 0x63) {
                bytes4 selector = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                // Only print non-zero and non-trivial selectors
                if (selector != bytes4(0) && selector != bytes4(0xffffffff)) {
                    console.logBytes4(selector);
                }
            }
        }
    }

    function _findSelectorInCode(bytes memory code, bytes4 selector) internal pure returns (bool) {
        for (uint i = 0; i < code.length - 4; i++) {
            if (code[i] == selector[0] &&
                code[i+1] == selector[1] &&
                code[i+2] == selector[2] &&
                code[i+3] == selector[3]) {
                return true;
            }
        }
        return false;
    }
}
