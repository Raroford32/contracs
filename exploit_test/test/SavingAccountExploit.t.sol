// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

interface ISavingAccount {
    function mint(uint256 amount) external;
    function mintFor(uint256 amount, address receiver) external;
    function redeem(uint256 amount) external;
    function claimRedeem(uint256 idx) external;
    function getSharesByAmount(uint256 amount) external view returns (uint256);
    function getAmountByShares(uint256 shares) external view returns (uint256);
    function getTotalUnderlying() external view returns (uint256);
    function totalUnderlying() external view returns (uint256);
    function totalsUSDaLockedAmount() external view returns (uint256);
    function balanceOf(address) external view returns (uint256);
    function targetAPR() external view returns (uint256);
    function unpaidInterest() external view returns (uint256);
    function lastCheckpoint() external view returns (uint256);
}

interface IERC20Mintable {
    function balanceOf(address) external view returns (uint256);
}

/**
 * @title SavingAccount Insolvency Exploit PoC
 * @notice This test demonstrates a potential insolvency scenario where:
 * 1. Interest accrues to totalUnderlying based on APR
 * 2. If POOL_MANAGER doesn't call distributeInterests(), unpaidInterest grows
 * 3. Users can redeem based on inflated totalUnderlying
 * 4. But actual USDA balance may be insufficient for all claims
 */
contract SavingAccountExploitTest is Test {
    // Mainnet addresses
    address constant SAVING_ACCOUNT = 0x01e3cc8E17755989ad2CAFE78A822354Eb5DdFA6;

    // We need to discover USDA and sUSDA addresses from the contract
    ISavingAccount savingAccount;
    IERC20 usda;
    IERC20Mintable susda;

    address attacker = makeAddr("attacker");
    address victim = makeAddr("victim");

    function setUp() public {
        // Fork mainnet
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");

        savingAccount = ISavingAccount(SAVING_ACCOUNT);

        console.log("=== Initial State ===");
        console.log("totalUnderlying:", savingAccount.totalUnderlying());
        console.log("totalsUSDaLockedAmount:", savingAccount.totalsUSDaLockedAmount());
        console.log("targetAPR:", savingAccount.targetAPR());
        console.log("unpaidInterest:", savingAccount.unpaidInterest());
    }

    function testInsolvencyScenario() public {
        // Check current state
        uint256 currentTotal = savingAccount.getTotalUnderlying();
        uint256 storedTotal = savingAccount.totalUnderlying();
        uint256 pendingInterest = currentTotal - storedTotal;

        console.log("\n=== Interest Accrual Analysis ===");
        console.log("Stored totalUnderlying:", storedTotal);
        console.log("Current getTotalUnderlying():", currentTotal);
        console.log("Pending interest accrual:", pendingInterest);
        console.log("Unpaid interest:", savingAccount.unpaidInterest());

        // Calculate potential insolvency
        // If users redeem, they get: shares * totalUnderlying / totalsUSDaLockedAmount
        // But actual USDA balance might be: totalUnderlying - unpaidInterest - pending

        uint256 totalShares = savingAccount.totalsUSDaLockedAmount();
        if (totalShares > 0) {
            uint256 valuePerShare = currentTotal * 1e18 / totalShares;
            console.log("\nValue per share (1e18):", valuePerShare);

            // If valuePerShare > 1e18, users can withdraw more than deposited
            if (valuePerShare > 1e18) {
                uint256 inflationPercent = (valuePerShare - 1e18) * 100 / 1e18;
                console.log("Inflation above deposit:", inflationPercent, "%");
            }
        }
    }

    function testFirstDepositorAdvantage() public {
        // Simulate fresh contract scenario
        uint256 totalShares = savingAccount.totalsUSDaLockedAmount();
        uint256 totalUnderlying = savingAccount.totalUnderlying();

        console.log("\n=== First Depositor Analysis ===");

        if (totalShares == 0) {
            console.log("Contract has no deposits - first depositor gets 1:1 ratio");
            console.log("First deposit of 1e18 gives 1e18 shares");
        } else {
            console.log("Current total shares:", totalShares);
            console.log("Current total underlying:", totalUnderlying);

            // Calculate what 100 USDA deposit would get
            uint256 depositAmount = 100e18;
            uint256 expectedShares = savingAccount.getSharesByAmount(depositAmount);
            console.log("\nFor 100 USDA deposit:");
            console.log("Expected shares:", expectedShares);

            // Calculate redemption value
            uint256 redemptionValue = savingAccount.getAmountByShares(expectedShares);
            console.log("Immediate redemption value:", redemptionValue);

            // Check if there's slippage
            if (redemptionValue < depositAmount) {
                uint256 loss = depositAmount - redemptionValue;
                console.log("Immediate loss from rounding:", loss);
                console.log("Loss percentage:", loss * 10000 / depositAmount, "bps");
            }
        }
    }

    function testRewardTimingExploit() public {
        // Check if interest timing can be exploited
        uint256 lastCheckpoint = savingAccount.lastCheckpoint();
        uint256 timeSinceCheckpoint = block.timestamp - lastCheckpoint;

        console.log("\n=== Reward Timing Analysis ===");
        console.log("Last checkpoint:", lastCheckpoint);
        console.log("Current time:", block.timestamp);
        console.log("Time since checkpoint:", timeSinceCheckpoint, "seconds");
        console.log("Time since checkpoint:", timeSinceCheckpoint / 3600, "hours");

        // Calculate accrued interest since last checkpoint
        uint256 targetAPR = savingAccount.targetAPR();
        uint256 totalUnderlying = savingAccount.totalUnderlying();

        // RPS = targetAPR * totalUnderlying / 365 days / APR_COEFFICIENT
        uint256 APR_COEFFICIENT = 10**8;
        uint256 rps = targetAPR * totalUnderlying / 365 days / APR_COEFFICIENT;

        uint256 accruedInterest = rps * timeSinceCheckpoint;
        console.log("\nRate per second:", rps);
        console.log("Accrued interest since checkpoint:", accruedInterest);

        // If someone mints/redeems NOW, they get credit for all accrued interest
        // This is the "realizeReward" advantage
        console.log("\n[!] Timing exploit: Mint right before realizeReward to capture pending interest");
    }
}
