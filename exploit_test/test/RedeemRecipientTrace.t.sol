// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract RedeemRecipientTrace is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_DetailedBytecodeAnalysis() public view {
        console.log("=== DETAILED BYTECODE ANALYSIS AROUND RC.REDEEM ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Analyze from 4900 to 5100
        console.log("Opcode-by-opcode from 4900-5100:");

        uint i = 4900;
        while (i < 5100 && i < code.length) {
            uint8 op = uint8(code[i]);

            string memory opName = "";
            uint skipBytes = 0;

            if (op == 0x00) opName = "STOP";
            else if (op == 0x01) opName = "ADD";
            else if (op == 0x02) opName = "MUL";
            else if (op == 0x03) opName = "SUB";
            else if (op == 0x04) opName = "DIV";
            else if (op == 0x10) opName = "LT";
            else if (op == 0x11) opName = "GT";
            else if (op == 0x14) opName = "EQ";
            else if (op == 0x15) opName = "ISZERO";
            else if (op == 0x16) opName = "AND";
            else if (op == 0x17) opName = "OR";
            else if (op == 0x19) opName = "NOT";
            else if (op == 0x1a) opName = "BYTE";
            else if (op == 0x1b) opName = "SHL";
            else if (op == 0x1c) opName = "SHR";
            else if (op == 0x20) opName = "SHA3";
            else if (op == 0x30) opName = "ADDRESS";
            else if (op == 0x32) opName = "ORIGIN";
            else if (op == 0x33) opName = "CALLER";
            else if (op == 0x34) opName = "CALLVALUE";
            else if (op == 0x35) opName = "CALLDATALOAD";
            else if (op == 0x36) opName = "CALLDATASIZE";
            else if (op == 0x37) opName = "CALLDATACOPY";
            else if (op == 0x38) opName = "CODESIZE";
            else if (op == 0x39) opName = "CODECOPY";
            else if (op == 0x3d) opName = "RETURNDATASIZE";
            else if (op == 0x3e) opName = "RETURNDATACOPY";
            else if (op == 0x50) opName = "POP";
            else if (op == 0x51) opName = "MLOAD";
            else if (op == 0x52) opName = "MSTORE";
            else if (op == 0x54) opName = "SLOAD";
            else if (op == 0x55) opName = "SSTORE";
            else if (op == 0x56) opName = "JUMP";
            else if (op == 0x57) opName = "JUMPI";
            else if (op == 0x5b) opName = "JUMPDEST";
            else if (op >= 0x80 && op <= 0x8f) opName = string(abi.encodePacked("DUP", uint8(op - 0x7f)));
            else if (op >= 0x90 && op <= 0x9f) opName = string(abi.encodePacked("SWAP", uint8(op - 0x8f)));
            else if (op == 0xf1) opName = "CALL";
            else if (op == 0xf3) opName = "RETURN";
            else if (op == 0xf4) opName = "DELEGATECALL";
            else if (op == 0xfa) opName = "STATICCALL";
            else if (op == 0xfd) opName = "REVERT";

            if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                if (size == 20 && val > 1e30) {
                    console.log(i, "PUSH20 addr mask");
                } else if (size == 20) {
                    console.log(i, "PUSH20:", address(uint160(val)));
                } else if (size == 4) {
                    console.log(i, "PUSH4:");
                    console.logBytes4(bytes4(uint32(val)));
                } else {
                    console.log(i, "PUSH:", val);
                }
                skipBytes = size;
            } else if (bytes(opName).length > 0) {
                console.log(i, opName);
            }

            i += 1 + skipBytes;
        }
    }

    function test_FindRedeemRequestStorage() public view {
        console.log("=== FINDING REDEEM REQUEST STORAGE ===\n");

        // Redemption requests are stored in a mapping
        // mapping(address => RedemptionRequest[])
        //
        // When finalizeRedeem is called, it reads the request
        // and extracts the recipient

        bytes memory code = REDEMPTION_0.code;

        // Find SLOAD operations near the RC.redeem call
        console.log("SLOADs between 4800-5100:");
        for (uint i = 4800; i < 5100 && i < code.length; i++) {
            if (uint8(code[i]) == 0x54) {
                console.log("SLOAD at:", i);

                // Look back for what slot is being loaded
                for (uint j = (i > 20 ? i - 20 : 0); j < i; j++) {
                    if (uint8(code[j]) == 0x20) { // SHA3
                        console.log("  SHA3 at:", j);
                    }
                    if (uint8(code[j]) >= 0x60 && uint8(code[j]) <= 0x65) {
                        uint8 size = uint8(code[j]) - 0x5f;
                        uint256 val = 0;
                        for (uint k = 0; k < size && j + 1 + k < code.length; k++) {
                            val = val << 8 | uint8(code[j + 1 + k]);
                        }
                        if (val < 100) {
                            console.log("  PUSH slot:", val);
                        }
                    }
                }
            }
        }
    }

    function test_DecodeRedeemError() public view {
        console.log("=== DECODING REDEEM ERROR ===\n");

        // Error 0xa0927dc3 - let's try to identify it
        bytes4 errorSel = bytes4(0xa0927dc3);

        // Common error signatures
        bytes4[] memory errors = new bytes4[](15);
        errors[0] = bytes4(keccak256("Paused()"));
        errors[1] = bytes4(keccak256("BelowMinimum()"));
        errors[2] = bytes4(keccak256("InsufficientBalance()"));
        errors[3] = bytes4(keccak256("InvalidAmount()"));
        errors[4] = bytes4(keccak256("AmountTooSmall()"));
        errors[5] = bytes4(keccak256("NotEnoughBalance()"));
        errors[6] = bytes4(keccak256("TransferFailed()"));
        errors[7] = bytes4(keccak256("Unauthorized()"));
        errors[8] = bytes4(keccak256("NotOwner()"));
        errors[9] = bytes4(keccak256("ExceedsMaximum()"));
        errors[10] = bytes4(keccak256("CapReached()"));
        errors[11] = bytes4(keccak256("EpochCapReached()"));
        errors[12] = bytes4(keccak256("NotActive()"));
        errors[13] = bytes4(keccak256("InvalidState()"));
        errors[14] = bytes4(keccak256("TooEarly()"));

        string[15] memory names = [
            "Paused()",
            "BelowMinimum()",
            "InsufficientBalance()",
            "InvalidAmount()",
            "AmountTooSmall()",
            "NotEnoughBalance()",
            "TransferFailed()",
            "Unauthorized()",
            "NotOwner()",
            "ExceedsMaximum()",
            "CapReached()",
            "EpochCapReached()",
            "NotActive()",
            "InvalidState()",
            "TooEarly()"
        ];

        console.log("Looking for error 0xa0927dc3");
        for (uint i = 0; i < errors.length; i++) {
            if (errors[i] == errorSel) {
                console.log("MATCH:", names[i]);
            }
            console.logBytes4(errors[i]);
        }

        // Try some more specific ones
        console.log("\nTrying Treehouse specific errors:");
        bytes4[] memory treehouseErrors = new bytes4[](10);
        treehouseErrors[0] = bytes4(keccak256("BelowMinRedemption()"));
        treehouseErrors[1] = bytes4(keccak256("RedemptionPaused()"));
        treehouseErrors[2] = bytes4(keccak256("InvalidRedemption()"));
        treehouseErrors[3] = bytes4(keccak256("ExceedsCap()"));
        treehouseErrors[4] = bytes4(keccak256("RedemptionCapExceeded()"));
        treehouseErrors[5] = bytes4(keccak256("MinRedeemNotMet()"));
        treehouseErrors[6] = bytes4(keccak256("Redemption__BelowMinimum()"));
        treehouseErrors[7] = bytes4(keccak256("Redemption__Paused()"));
        treehouseErrors[8] = bytes4(keccak256("MinAmountNotMet()"));
        treehouseErrors[9] = bytes4(keccak256("AmountBelowMinimum()"));

        for (uint i = 0; i < treehouseErrors.length; i++) {
            if (treehouseErrors[i] == errorSel) {
                console.log("MATCH!");
            }
            console.logBytes4(treehouseErrors[i]);
        }
    }

    function test_TryLargerRedeemAmount() public {
        console.log("=== TRYING LARGER REDEEM AMOUNTS ===\n");

        // Maybe the error is minimum amount not met
        // minRedeemInUnderlying returned 200000000000000000000 (200 tokens)

        vm.startPrank(attacker);

        deal(IAU, attacker, 1000e18);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        console.log("Attacker IAU balance:", IERC20(IAU).balanceOf(attacker));

        // Try 200 IAU (minimum)
        console.log("\nTrying redeem(200e18):");
        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(200e18))
        );
        console.log("Success:", s1);
        if (!s1 && d1.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(d1));
        }

        // Give more IAU
        deal(IAU, attacker, 10000e18);

        // Try 500 IAU
        console.log("\nTrying redeem(500e18):");
        (bool s2, bytes memory d2) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(500e18))
        );
        console.log("Success:", s2);
        if (!s2 && d2.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(d2));
        }

        vm.stopPrank();
    }

    function test_CheckRedemptionStatus() public view {
        console.log("=== CHECKING REDEMPTION STATUS ===\n");

        // Check various status functions

        (bool s1, bytes memory d1) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("paused()")
        );
        if (s1) {
            console.log("paused():", abi.decode(d1, (bool)));
        }

        (bool s2, bytes memory d2) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("totalRedeeming()")
        );
        if (s2) {
            console.log("totalRedeeming():", abi.decode(d2, (uint256)));
        }

        (bool s3, bytes memory d3) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("cap()")
        );
        if (s3) {
            console.log("cap():", abi.decode(d3, (uint256)));
        }

        (bool s4, bytes memory d4) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("epochCap()")
        );
        if (s4) {
            console.log("epochCap():", abi.decode(d4, (uint256)));
        }

        // Check the 0xa0927dc3 selector in bytecode
        bytes memory code = REDEMPTION_0.code;
        bytes4 errSel = bytes4(0xa0927dc3);

        console.log("\nSearching for error selector in bytecode:");
        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == errSel) {
                    console.log("Error selector found at offset:", i);
                }
            }
        }
    }

    function test_AnalyzeRedemption1Different() public view {
        console.log("=== ANALYZING REDEMPTION_1 DIFFERENCES ===\n");

        bytes memory r0Code = REDEMPTION_0.code;
        bytes memory r1Code = REDEMPTION_1.code;

        console.log("REDEMPTION_0 code size:", r0Code.length);
        console.log("REDEMPTION_1 code size:", r1Code.length);

        // Find RC.redeem in REDEMPTION_1
        bytes4 rcRedeemSel = bytes4(0x7bde82f2);

        console.log("\nSearching for RC.redeem in REDEMPTION_1:");
        for (uint i = 0; i + 4 < r1Code.length; i++) {
            if (uint8(r1Code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(r1Code[i+1], r1Code[i+2], r1Code[i+3], r1Code[i+4]));
                if (sel == rcRedeemSel) {
                    console.log("  Found at offset:", i);

                    // Check for CALL after
                    for (uint j = i; j < i + 100 && j < r1Code.length; j++) {
                        if (uint8(r1Code[j]) == 0xf1) {
                            console.log("  CALL at:", j);
                            break;
                        }
                    }
                }
            }
        }

        // Count CALLER in both
        uint callerR0 = 0;
        uint callerR1 = 0;
        for (uint i = 0; i < r0Code.length; i++) {
            if (uint8(r0Code[i]) == 0x33) callerR0++;
        }
        for (uint i = 0; i < r1Code.length; i++) {
            if (uint8(r1Code[i]) == 0x33) callerR1++;
        }

        console.log("\nCALLER count - R0:", callerR0, "R1:", callerR1);
    }
}
