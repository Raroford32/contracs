// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "forge-std/Test.sol";

interface IStakingProxyERC20 {
    function owner() external view returns (address);
    function gaugeAddress() external view returns (address);
    function stakingToken() external view returns (address);
    function rewards() external view returns (address);
    function pid() external view returns (uint256);
    function feeRegistry() external view returns (address);
    function poolRegistry() external view returns (address);
    function fxnMinter() external view returns (address);
    function usingProxy() external view returns (address);

    function getReward() external;
    function getReward(bool _claim) external;
    function getReward(bool _claim, address[] calldata _tokenList) external;
    function earned() external returns (address[] memory token_addresses, uint256[] memory total_earned);
    function transferTokens(address[] calldata _tokenList) external;
    function deposit(uint256 _amount) external;
    function withdraw(uint256 _amount) external;
    function execute(address _to, uint256 _value, bytes calldata _data) external returns (bool, bytes memory);
}

interface IPoolRegistry {
    function poolLength() external view returns(uint256);
    function poolInfo(uint256 _pid) external view returns(address impl, address gauge, address token, address rewards, uint8 shutdown);
    function vaultMap(uint256 _pid, address _user) external view returns(address vault);
    function addUserVault(uint256 _pid, address _user) external returns(address vault, address stakeAddress, address stakeToken, address rewards);
}

interface IFxnGauge {
    function totalSupply() external view returns(uint256);
    function balanceOf(address) external view returns(uint256);
    function getActiveRewardTokens() external view returns (address[] memory);
    function rewardReceiver(address account) external view returns (address);
    function claim() external;
    function claim(address account) external;
    function claim(address account, address receiver) external;
    function setRewardReceiver(address _newReceiver) external;
}

interface IRewards {
    enum RewardState { NotInitialized, NoRewards, Active }
    function rewardState() external view returns(RewardState);
    function balanceOf(address) external view returns(uint256);
    function rewardTokenLength() external view returns(uint256);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

contract StakingProxyAnalysisTest is Test {
    // Contract addresses
    address constant POOL_REGISTRY = 0xdb95d646012bb87ac2e6cd63eab2c42323c1f5af;
    address constant FEE_REGISTRY = 0x4f258fecc91b2ff162ca702c2bd9abf2af089611;
    address constant FXN_TOKEN = 0x365AccFCa291e7D3914637ABf1F7635dB165Bb09;
    address constant VEFXN_PROXY = 0xd11a4Ee017cA0BECA8FA45fF2abFe9C6267b7881;
    address constant FXN_MINTER = 0xc8b194925d55d5de9555ad1db74c149329f71def;

    // Active pool info (Pool 17)
    uint256 constant ACTIVE_PID = 17;
    address constant POOL17_GAUGE = 0xc2def1e39ff35367f2f2a312a793477c576fd4c3;
    address constant POOL17_TOKEN = 0x9216272158f563488ffc36afb877aca2f265c560;

    IPoolRegistry poolRegistry;

    function setUp() public {
        // Fork mainnet
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        poolRegistry = IPoolRegistry(POOL_REGISTRY);
    }

    function test_ProtocolOverview() public {
        console.log("=== Protocol Overview ===");
        console.log("Pool Registry:", POOL_REGISTRY);
        console.log("Fee Registry:", FEE_REGISTRY);
        console.log("FXN Token:", FXN_TOKEN);
        console.log("Total Pools:", poolRegistry.poolLength());

        // Check pool 17 info
        (address impl, address gauge, address token, address rewards, uint8 shutdown) = poolRegistry.poolInfo(ACTIVE_PID);
        console.log("\n=== Pool 17 (Active) ===");
        console.log("Implementation:", impl);
        console.log("Gauge:", gauge);
        console.log("Staking Token:", token);
        console.log("Rewards:", rewards);
        console.log("Shutdown:", shutdown);

        // Check gauge state
        IFxnGauge fxnGauge = IFxnGauge(gauge);
        console.log("\n=== Gauge State ===");
        console.log("Total Supply:", fxnGauge.totalSupply());

        // Get active reward tokens
        address[] memory rewardTokens = fxnGauge.getActiveRewardTokens();
        console.log("Active Reward Tokens:", rewardTokens.length);
        for (uint i = 0; i < rewardTokens.length; i++) {
            console.log("  Token", i, ":", rewardTokens[i]);
        }
    }

    function test_FindExistingVaults() public {
        console.log("=== Finding Existing Vaults for Pool 17 ===");

        // Try to find vaults by checking common addresses
        // The vaultMap takes (pid, user) and returns vault address

        // Check if any of the top stakers have vaults
        address gauge = POOL17_GAUGE;

        // Query some potential vault owners
        // In practice, we'd query events or iterate through known addresses
        console.log("Gauge address:", gauge);
        console.log("Gauge totalSupply:", IFxnGauge(gauge).totalSupply() / 1e18, "tokens");
    }

    function test_PermissionlessGetReward() public {
        console.log("=== Testing Permissionless getReward() ===");

        // Deploy a mock vault or find an existing one
        // For now, test that getReward functions exist and can be called

        // Get pool info
        (address impl,,,, uint8 shutdown) = poolRegistry.poolInfo(ACTIVE_PID);
        console.log("Pool 17 Implementation:", impl);
        console.log("Pool 17 Shutdown:", shutdown);

        // Note: To fully test, we'd need to:
        // 1. Find an existing vault with balance
        // 2. Call earned() or getReward() as non-owner
        // 3. Verify the rewards flow

        console.log("\nNote: getReward() and earned() are permissionless!");
        console.log("Any address can trigger reward claims for any vault.");
    }

    function test_EarnedVsGetRewardAsymmetry() public {
        console.log("=== Testing earned() vs getReward() Asymmetry ===");

        // Get gauge info
        IFxnGauge gauge = IFxnGauge(POOL17_GAUGE);

        // Check reward tokens
        address[] memory rewardTokens = gauge.getActiveRewardTokens();
        console.log("Gauge Reward Tokens:");
        for (uint i = 0; i < rewardTokens.length; i++) {
            console.log("  ", rewardTokens[i]);
        }

        // Key finding:
        // - earned() calls gauge.claim(address(this), address(this)) -> rewards to vault
        // - getReward() calls gauge.claim() -> uses rewardReceiver -> to owner

        console.log("\nAsymmetry Analysis:");
        console.log("- earned() claims rewards TO VAULT");
        console.log("- getReward() claims rewards TO OWNER via rewardReceiver");
        console.log("- Attacker can call earned() to redirect rewards to vault");
        console.log("- Owner then needs transferTokens() to recover");
    }

    function test_ExecuteFunctionAnalysis() public {
        console.log("=== Analyzing execute() Function ===");

        // The execute() function allows arbitrary calls EXCEPT to:
        // - fxn token (0x365AccFCa291e7D3914637ABf1F7635dB165Bb09)
        // - stakingToken (varies by vault)
        // - rewards contract (varies by vault)

        // ALLOWED targets include:
        // - gaugeAddress (if pool not shutdown)
        // - feeRegistry (0x4f258fecc91b2ff162ca702c2bd9abf2af089611)
        // - poolRegistry (0xdb95d646012bb87ac2e6cd63eab2c42323c1f5af)
        // - fxnMinter (0xc8b194925d55d5de9555ad1db74c149329f71def)
        // - ANY other address!

        console.log("execute() blocked targets:");
        console.log("  - FXN token:", FXN_TOKEN);
        console.log("  - stakingToken: varies per vault");
        console.log("  - rewards: varies per vault");

        console.log("\nexecute() ALLOWED targets:");
        console.log("  - gaugeAddress (if pool not shutdown)");
        console.log("  - feeRegistry:", FEE_REGISTRY);
        console.log("  - poolRegistry:", POOL_REGISTRY);
        console.log("  - fxnMinter:", FXN_MINTER);
        console.log("  - ANY other contract!");

        console.log("\nPotential via execute() to gauge:");
        console.log("  - setRewardReceiver(attacker) - redirect future rewards");
        console.log("  - acceptSharedVote(address) - manipulate boost");
    }

    function test_GaugeSetRewardReceiverViaExecute() public {
        console.log("=== Testing Gauge Manipulation via execute() ===");

        // If a vault owner calls:
        // execute(gaugeAddress, 0, abi.encodeCall(IFxnGauge.setRewardReceiver, (malicious)))
        //
        // Future gauge.claim() calls will send rewards to malicious address
        // This could be used by owner to:
        // 1. Redirect their own rewards (intentional)
        // 2. If owner key is compromised, drain future rewards

        console.log("Owner can use execute() to call gauge.setRewardReceiver()");
        console.log("This would redirect future gauge rewards");
        console.log("Could be intentional or malicious (compromised key)");

        // Check current reward receiver for gauge
        IFxnGauge gauge = IFxnGauge(POOL17_GAUGE);
        console.log("\nNote: rewardReceiver is set per-staker, not globally");
    }

    function test_TransferTokensAnalysis() public {
        console.log("=== Analyzing transferTokens() Function ===");

        // transferTokens() allows owner to withdraw tokens from vault
        // EXCEPT: fxn and gaugeAddress
        //
        // Notice: gaugeAddress is NOT a token, it's the gauge contract
        // This means gauge REWARD TOKENS are NOT blocked!

        console.log("transferTokens() blocked:");
        console.log("  - FXN token (to ensure fees are paid)");
        console.log("  - gaugeAddress (not even a token)");

        console.log("\ntransferTokens() ALLOWED:");
        console.log("  - Gauge reward tokens (WETH, CRV, etc.)");
        console.log("  - Any other ERC20 in vault");

        console.log("\nImplication:");
        console.log("  If earned() is called, gauge rewards go to vault");
        console.log("  Owner can then use transferTokens() to withdraw");
        console.log("  This bypasses the normal getReward() flow");
    }

    function test_SummaryOfFindings() public view {
        console.log("=== SUMMARY OF SECURITY FINDINGS ===\n");

        console.log("1. PERMISSIONLESS FUNCTIONS");
        console.log("   - getReward(): Anyone can trigger reward claims");
        console.log("   - earned(): Anyone can trigger AND redirect to vault");
        console.log("   Risk: Low-Medium (griefing, timing manipulation)\n");

        console.log("2. earned() vs getReward() ASYMMETRY");
        console.log("   - earned() claims to VAULT");
        console.log("   - getReward() claims to OWNER");
        console.log("   Risk: Medium (reward redirect, stuck tokens)\n");

        console.log("3. execute() FUNCTION");
        console.log("   - Can call gauge (setRewardReceiver, etc.)");
        console.log("   - Can call any non-blocked address");
        console.log("   Risk: Low (requires owner, intentional feature)\n");

        console.log("4. transferTokens() ALLOWS GAUGE REWARDS");
        console.log("   - Only blocks FXN and gaugeAddress");
        console.log("   - Gauge reward tokens are withdrawable");
        console.log("   Risk: Low (owner-only, may be intended)\n");

        console.log("OVERALL ASSESSMENT:");
        console.log("No critical exploits found that extract value from others.");
        console.log("Main concerns are around griefing and timing manipulation.");
        console.log("The permissionless earned() function is the most interesting");
        console.log("vector but doesn't appear to cause direct financial loss.");
    }
}
