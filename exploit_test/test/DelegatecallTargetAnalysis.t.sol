// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract DelegatecallTargetAnalysis is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeDynamicSlotCalculation() public view {
        console.log("=== ANALYZING DYNAMIC SLOT CALCULATION ===\n");

        // The PUSH before SLOAD was 0x38e95b = 3729755
        // This could be:
        // 1. A literal slot number
        // 2. Part of a keccak256 calculation

        // Check if slot 3729755 has anything
        bytes32 slot3729755 = vm.load(REDEMPTION_0, bytes32(uint256(3729755)));
        console.log("Slot 3729755:");
        console.logBytes32(slot3729755);

        // But more likely, 0x38e95b is being used in a calculation
        // Common pattern: PUSH (memory location) -> MLOAD -> SLOAD
        // The 3729755 might be pointing to a memory location that holds the actual slot

        // Let's check common mapping patterns:
        // mapping(address => X) at slot N: keccak256(address . N)

        console.log("\nTrying mapping patterns for TASSET address:");
        for (uint base = 0; base < 10; base++) {
            bytes32 slot = keccak256(abi.encode(TASSET, base));
            bytes32 value = vm.load(REDEMPTION_0, slot);
            if (value != bytes32(0)) {
                console.log("  Base", base, "has value:");
                console.logBytes32(value);
            }
        }

        console.log("\nTrying mapping patterns for attacker address:");
        for (uint base = 0; base < 10; base++) {
            bytes32 slot = keccak256(abi.encode(attacker, base));
            bytes32 value = vm.load(REDEMPTION_0, slot);
            if (value != bytes32(0)) {
                console.log("  Base", base, "has value:");
                console.logBytes32(value);
            }
        }
    }

    function test_CheckTASETAsDelegate() public view {
        console.log("=== CHECKING IF TASSET IS DELEGATECALL TARGET ===\n");

        // TASSET (tETH) is stored in Redemption and might be the delegatecall target
        // If Redemption delegatecalls to TASSET, and TASSET has a vulnerability...

        console.log("TASSET address:", TASSET);

        // Check TASSET bytecode for RC.redeem call
        bytes memory code = TASSET.code;
        console.log("TASSET code size:", code.length);

        // Check if TASSET implementation has redeem capability
        address tassetImpl = 0xD1A622566F277AA76c3C47A30469432AAec95E38;
        bytes memory implCode = tassetImpl.code;
        console.log("TASSET impl code size:", implCode.length);

        // Look for RC address in TASSET impl
        bytes memory rcBytes = abi.encodePacked(REDEMPTION_CONTROLLER);
        console.log("\nSearching for RC in TASSET impl...");
        for (uint i = 0; i + 20 < implCode.length; i++) {
            bool match_ = true;
            for (uint j = 0; j < 20; j++) {
                if (implCode[i + j] != rcBytes[j]) {
                    match_ = false;
                    break;
                }
            }
            if (match_) {
                console.log("  Found RC at offset:", i);
            }
        }
    }

    function test_SimulateRedemptionWithVMStore() public {
        console.log("=== SIMULATING REDEMPTION WITH VM.STORE ===\n");

        // If we can prove that modifying a specific storage slot
        // changes the delegatecall target, we've found the vulnerability

        // First, let's understand the redemption flow by creating a valid request
        deal(IAU, attacker, 1000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);
        vm.stopPrank();

        // The redemption data might be stored in:
        // mapping(address => RedemptionRequest[]) where RedemptionRequest contains (amount, to, startTime)

        // Let's try to create a fake redemption by manipulating storage directly
        // First find where user data would be stored

        // For mapping(address => T[]) at slot S:
        // Array length at: keccak256(user . S)
        // Array elements at: keccak256(keccak256(user . S)) + index * element_size

        for (uint baseSlot = 5; baseSlot < 15; baseSlot++) {
            bytes32 arrayLenSlot = keccak256(abi.encode(attacker, baseSlot));
            bytes32 arrayLen = vm.load(REDEMPTION_0, arrayLenSlot);

            if (uint256(arrayLen) > 0 && uint256(arrayLen) < 1000) {
                console.log("Found array at base slot", baseSlot);
                console.log("  Length:", uint256(arrayLen));

                // Get first element
                bytes32 elemSlot = keccak256(abi.encode(arrayLenSlot));
                bytes32 elem = vm.load(REDEMPTION_0, elemSlot);
                console.log("  First element:");
                console.logBytes32(elem);
            }
        }
    }

    function test_CheckForCollision() public view {
        console.log("=== CHECKING FOR STORAGE COLLISION ===\n");

        // If there's a storage collision between the delegatecall target slot
        // and user-controlled data, we can exploit it

        // The SLOAD at 5298 might read from a slot that could be influenced
        // by user data

        // Known addresses in the system
        address[] memory knownAddrs = new address[](5);
        knownAddrs[0] = REDEMPTION_CONTROLLER;
        knownAddrs[1] = VAULT;
        knownAddrs[2] = TASSET;
        knownAddrs[3] = IAU;
        knownAddrs[4] = attacker;

        console.log("Checking slots derived from known addresses:");

        for (uint a = 0; a < knownAddrs.length; a++) {
            for (uint base = 0; base < 10; base++) {
                bytes32 slot = keccak256(abi.encode(knownAddrs[a], base));
                uint256 slotNum = uint256(slot);

                // Check if this slot number is close to any interesting values
                if (slotNum < 10000000) {
                    console.log("\nLow slot number found!");
                    console.log("  Address index:", a);
                    console.log("  Base:", base);
                    console.log("  Slot:", slotNum);
                }
            }
        }
    }

    function test_ExploitSummary() public view {
        console.log("=== EXPLOIT SUMMARY ===\n");

        uint256 vaultBalance = IERC20(wstETH).balanceOf(VAULT);

        console.log("CONFIRMED VULNERABILITY:");
        console.log("========================");
        console.log("");
        console.log("1. RC.redeem(amount, to) transfers wstETH from Vault to 'to'");
        console.log("2. RC only allows registered Redemption contracts to call redeem()");
        console.log("3. REDEMPTION_0 and REDEMPTION_1 are registered");
        console.log("4. When calling RC.redeem AS a Redemption contract,");
        console.log("   attacker can specify ANY address as 'to' parameter");
        console.log("");
        console.log("IMPACT:");
        console.log("-------");
        console.log("Vault wstETH balance:", vaultBalance / 1e18);
        console.log("Estimated USD value: $", vaultBalance * 2300 / 1e18);
        console.log("");
        console.log("MISSING PIECE:");
        console.log("--------------");
        console.log("Need to find how unprivileged attacker can trigger");
        console.log("Redemption.finalizeRedeem() with controlled 'to' address");
        console.log("OR exploit the DELEGATECALL at offset 5323");
    }
}
