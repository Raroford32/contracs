// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title FraxQueue Deficit Investigation
 * @notice Deep analysis of the ETH deficit discovered in FraxEtherRedemptionQueue
 * @dev The queue shows liabilities > balance, investigating if this is exploitable
 */

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

interface IERC721 {
    function ownerOf(uint256 tokenId) external view returns (address);
    function balanceOf(address owner) external view returns (uint256);
}

interface IFraxRedemptionQueue is IERC721 {
    struct RedemptionQueueState {
        uint64 nextNftId;
        uint64 queueLengthSecs;
        uint64 redemptionFee;
        uint32 earlyExitFee;
    }

    struct RedemptionQueueAccounting {
        uint128 etherLiabilities;
        uint128 unclaimedFees;
    }

    function enterRedemptionQueue(uint120 _amountToRedeem, address _recipient) external returns (uint256);
    function burnRedemptionTicketNft(uint256 _nftId, address payable _recipient) external;
    function earlyBurnRedemptionTicketNft(uint256 _nftId, address _recipient) external;
    function redemptionQueueState() external view returns (RedemptionQueueState memory);
    function redemptionQueueAccounting() external view returns (RedemptionQueueAccounting memory);
    function nftInformation(uint256 _nftId) external view returns (
        bool hasBeenRedeemed,
        uint64 maturity,
        uint64 redemptionTime,
        uint120 amount,
        address recipient
    );
}

interface IFrxEthMinter {
    function submitAndDeposit(address recipient) external payable returns (uint256 shares);
}

contract FraxDeficitExploitTest is Test {
    address constant FRAX_QUEUE = 0x82bA8da44Cd5261762e629dd5c605b17715727bd;
    address constant FRXETH = 0x5E8422345238F34275888049021821E8E08CAa1f;
    address constant FRXETH_MINTER = 0xbAFA44EFE7901E04E39Dad13167D089C559c1138;
    address constant SFRXETH = 0xac3E018457B222d93114458476f3E3416Abbe38F;

    string constant RPC_URL = "https://eth-mainnet.public.blastapi.io";

    address attacker = makeAddr("attacker");

    function setUp() public {
        vm.createSelectFork(RPC_URL);
    }

    /**
     * @notice Analyze the deficit situation in detail
     */
    function test_AnalyzeDeficit() public {
        console.log("=== FraxQueue Deficit Deep Analysis ===\n");

        IFraxRedemptionQueue queue = IFraxRedemptionQueue(FRAX_QUEUE);
        IERC20 frxEth = IERC20(FRXETH);

        // Get state
        IFraxRedemptionQueue.RedemptionQueueState memory state = queue.redemptionQueueState();
        IFraxRedemptionQueue.RedemptionQueueAccounting memory accounting = queue.redemptionQueueAccounting();

        uint256 contractEth = address(FRAX_QUEUE).balance;
        uint256 etherLiabilities = accounting.etherLiabilities;

        console.log("CONTRACT STATE:");
        console.log("  ETH Balance:", contractEth / 1e18, "ETH");
        console.log("  ETH Liabilities:", etherLiabilities / 1e18, "ETH");
        console.log("  Unclaimed Fees:", accounting.unclaimedFees / 1e18, "ETH");
        console.log("  Next NFT ID:", state.nextNftId);
        console.log("  Queue Length:", state.queueLengthSecs / 86400, "days");

        if (contractEth < etherLiabilities) {
            uint256 deficit = etherLiabilities - contractEth;
            console.log("\n  *** DEFICIT DETECTED ***");
            console.log("  Shortfall:", deficit / 1e18, "ETH");
            console.log("  Shortfall USD (~$3200/ETH): $", (deficit / 1e18) * 3200);
        }

        // Analyze mature NFTs
        console.log("\n=== MATURE NFTs ANALYSIS ===");
        uint256 totalMatureAmount = 0;
        uint256 matureCount = 0;

        for (uint256 i = 1; i < state.nextNftId && i < 100; i++) {
            try queue.nftInformation(i) returns (
                bool hasBeenRedeemed,
                uint64 maturity,
                uint64 /* redemptionTime */,
                uint120 amount,
                address /* recipient */
            ) {
                if (!hasBeenRedeemed && maturity <= block.timestamp) {
                    totalMatureAmount += amount;
                    matureCount++;
                    if (matureCount <= 5) {
                        console.log("  NFT - Mature, amount:", amount / 1e18, "ETH");
                    }
                }
            } catch {
                // NFT might not exist
            }
        }

        console.log("\n  Total mature NFTs (first 100):", matureCount);
        console.log("  Total mature amount:", totalMatureAmount / 1e18, "ETH");

        // Check if there's a race condition
        console.log("\n=== RACE CONDITION ANALYSIS ===");

        if (totalMatureAmount > contractEth) {
            console.log("  !! CRITICAL: More mature ETH than available !!");
            console.log("  Mature amount:", totalMatureAmount / 1e18, "ETH");
            console.log("  Available:", contractEth / 1e18, "ETH");
            console.log("  Race condition delta:", (totalMatureAmount - contractEth) / 1e18, "ETH");
        }

        // Check frxETH held by queue (for early exits)
        uint256 queueFrxEth = frxEth.balanceOf(FRAX_QUEUE);
        console.log("\n  frxETH held by queue:", queueFrxEth / 1e18);
    }

    /**
     * @notice Simulate a bank run scenario where all mature NFT holders try to redeem
     */
    function test_BankRunScenario() public {
        console.log("=== Bank Run Simulation ===\n");

        IFraxRedemptionQueue queue = IFraxRedemptionQueue(FRAX_QUEUE);
        IFraxRedemptionQueue.RedemptionQueueState memory state = queue.redemptionQueueState();

        uint256 initialBalance = address(FRAX_QUEUE).balance;
        console.log("Initial queue ETH balance:", initialBalance / 1e18, "ETH");

        // Find mature NFTs and their owners
        address[] memory owners = new address[](50);
        uint256[] memory nftIds = new uint256[](50);
        uint256[] memory amounts = new uint256[](50);
        uint256 count = 0;

        for (uint256 i = 1; i < state.nextNftId && count < 50; i++) {
            try queue.nftInformation(i) returns (
                bool hasBeenRedeemed,
                uint64 maturity,
                uint64 /* redemptionTime */,
                uint120 amount,
                address /* recipient */
            ) {
                if (!hasBeenRedeemed && maturity <= block.timestamp && amount > 0) {
                    try queue.ownerOf(i) returns (address owner) {
                        owners[count] = owner;
                        nftIds[count] = i;
                        amounts[count] = amount;
                        count++;
                    } catch {}
                }
            } catch {}
        }

        console.log("Found", count, "mature NFTs");

        // Simulate redemptions
        uint256 totalRedeemed = 0;
        uint256 failedRedemptions = 0;

        for (uint256 i = 0; i < count; i++) {
            address owner = owners[i];
            uint256 nftId = nftIds[i];
            uint256 amount = amounts[i];

            uint256 balanceBefore = address(FRAX_QUEUE).balance;

            if (balanceBefore >= amount) {
                // Owner tries to redeem
                vm.prank(owner);
                try queue.burnRedemptionTicketNft(nftId, payable(owner)) {
                    totalRedeemed += amount;
                    console.log("Redeemed NFT SUCCESS:", amount / 1e18, "ETH");
                } catch {
                    console.log("Redeemed NFT FAILED:", amount / 1e18, "ETH");
                    failedRedemptions++;
                }
            } else {
                console.log("NFT INSUFFICIENT BALANCE:", amount / 1e18, "ETH");
                failedRedemptions++;
            }
        }

        console.log("\n=== BANK RUN RESULTS ===");
        console.log("Total redeemed:", totalRedeemed / 1e18, "ETH");
        console.log("Failed redemptions:", failedRedemptions);
        console.log("Final balance:", address(FRAX_QUEUE).balance / 1e18, "ETH");

        if (failedRedemptions > 0) {
            console.log("\n*** VULNERABILITY CONFIRMED: Some users cannot redeem! ***");
        }
    }

    /**
     * @notice Test if we can profit from being "first in line" during a deficit
     */
    function test_FrontRunRedemption() public {
        console.log("=== Front-Running Redemption Analysis ===\n");

        IFraxRedemptionQueue queue = IFraxRedemptionQueue(FRAX_QUEUE);
        IERC20 frxEth = IERC20(FRXETH);

        IFraxRedemptionQueue.RedemptionQueueState memory state = queue.redemptionQueueState();
        IFraxRedemptionQueue.RedemptionQueueAccounting memory accounting = queue.redemptionQueueAccounting();

        uint256 contractEth = address(FRAX_QUEUE).balance;
        uint256 etherLiabilities = accounting.etherLiabilities;

        console.log("Current state:");
        console.log("  ETH in contract:", contractEth / 1e18);
        console.log("  Liabilities:", etherLiabilities / 1e18);

        // If there's a deficit and we own a mature NFT, we're at risk
        // Strategy: Early exit might be better than waiting for potential insolvency

        // Calculate early exit value vs waiting
        uint256 earlyExitFee = state.earlyExitFee; // in bps (10000 = 100%)
        console.log("  Early exit fee (bps):", earlyExitFee);

        // Find a mature NFT to analyze
        for (uint256 i = 1; i < state.nextNftId && i < 50; i++) {
            try queue.nftInformation(i) returns (
                bool hasBeenRedeemed,
                uint64 maturity,
                uint64 /* redemptionTime */,
                uint120 amount,
                address /* recipient */
            ) {
                if (!hasBeenRedeemed && maturity <= block.timestamp && amount > 1 ether) {
                    uint256 earlyExitValue = amount * (10000 - earlyExitFee) / 10000;

                    console.log("\nNFT analysis:");
                    console.log("  Amount:", amount / 1e18, "ETH");
                    console.log("  Early exit value:", earlyExitValue / 1e18, "ETH");
                    console.log("  Fee lost:", (amount - earlyExitValue) / 1e18, "ETH");

                    // If deficit > potential fee loss, early exit might be better
                    if (contractEth < etherLiabilities) {
                        console.log("  WARNING: Contract has deficit, redemption may fail!");
                    }

                    break; // Just analyze one NFT
                }
            } catch {}
        }
    }

    /**
     * @notice Check if depositing frxETH right before redemptions processes can be profitable
     */
    function test_DepositBeforeRedemptionTiming() public {
        console.log("=== Deposit Timing Attack Analysis ===\n");

        IFraxRedemptionQueue queue = IFraxRedemptionQueue(FRAX_QUEUE);
        IERC20 frxEth = IERC20(FRXETH);

        // Get current frxETH price info
        uint256 frxEthSupply = frxEth.totalSupply();
        console.log("frxETH total supply:", frxEthSupply / 1e18);

        // The queue length determines when new deposits become redeemable
        IFraxRedemptionQueue.RedemptionQueueState memory state = queue.redemptionQueueState();
        console.log("Queue length:", state.queueLengthSecs / 86400, "days");

        // If we deposit and wait, we get ETH 1:1 (minus any fees)
        // This creates arbitrage opportunities if frxETH trades below peg

        // Check if entering queue now would be profitable given the deficit
        console.log("\nTiming analysis:");
        console.log("  If frxETH is at 0.99 ETH and we:");
        console.log("  1. Buy frxETH on market at 0.99 ETH");
        console.log("  2. Enter redemption queue");
        console.log("  3. Wait", state.queueLengthSecs / 86400, "days");
        console.log("  4. Redeem for 1.00 ETH");
        console.log("  Profit: 1% minus gas costs");

        // BUT if there's a deficit, last in line might not get paid
        IFraxRedemptionQueue.RedemptionQueueAccounting memory accounting = queue.redemptionQueueAccounting();
        uint256 deficit = accounting.etherLiabilities > address(FRAX_QUEUE).balance
            ? accounting.etherLiabilities - address(FRAX_QUEUE).balance
            : 0;

        if (deficit > 0) {
            console.log("\n  *** WARNING: Deficit exists ***");
            console.log("  Current deficit:", deficit / 1e18, "ETH");
            console.log("  New depositors will be LAST in line");
            console.log("  Risk of not being able to redeem if deficit persists");
        }
    }

    /**
     * @notice Summary of findings
     */
    function test_ExploitSummary() public view {
        console.log("=== FraxQueue Deficit Exploit Summary ===\n");

        IFraxRedemptionQueue queue = IFraxRedemptionQueue(FRAX_QUEUE);
        IFraxRedemptionQueue.RedemptionQueueAccounting memory accounting = queue.redemptionQueueAccounting();

        uint256 contractEth = address(FRAX_QUEUE).balance;
        uint256 etherLiabilities = accounting.etherLiabilities;

        console.log("FINDINGS:");
        console.log("1. FraxEtherRedemptionQueue has a deficit");
        console.log("   - ETH Balance:", contractEth / 1e18, "ETH");
        console.log("   - Liabilities:", etherLiabilities / 1e18, "ETH");

        if (etherLiabilities > contractEth) {
            uint256 deficit = etherLiabilities - contractEth;
            console.log("   - Deficit (ETH):", deficit / 1e18);
            console.log("   - Deficit (USD):", (deficit / 1e18) * 3200);
        }

        console.log("\n2. IMPACT:");
        console.log("   - If all mature NFT holders redeem, some will fail");
        console.log("   - Last-in-line risk for new depositors");
        console.log("   - Potential bank run scenario");

        console.log("\n3. NOT IMMEDIATELY EXPLOITABLE BECAUSE:");
        console.log("   - Requires waiting for queue (", queue.redemptionQueueState().queueLengthSecs / 86400, "days)");
        console.log("   - Protocol can add ETH to cover deficit");
        console.log("   - Early exit has 50% fee");

        console.log("\n4. STATUS: UNPROVEN (watchlist)");
        console.log("   - Economic risk exists but no immediate drain vector");
        console.log("   - Monitor for worsening deficit");
    }
}
