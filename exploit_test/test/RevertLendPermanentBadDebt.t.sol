// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "forge-std/Test.sol";

/**
 * @title Permanent Bad Debt Attack Vector Analysis
 * @notice Combined attack: safety buffer bypass + liquidation revert
 *
 * CRITICAL FINDING: _handleReserveLiquidation can revert permanently
 *
 * In _handleReserveLiquidation():
 *   newLendExchangeRateX96 = (totalLent - missing) * newLendExchangeRateX96 / totalLent;
 *
 * If missing >= totalLent, this UNDERFLOWS and liquidation REVERTS!
 * The bad debt becomes PERMANENTLY UNLIQUIDATABLE.
 */

interface IV3Vault {
    function asset() external view returns (address);
    function totalAssets() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function vaultInfo() external view returns (
        uint256 debt, uint256 lent, uint256 balance, uint256 reserves,
        uint256 debtExchangeRateX96, uint256 lendExchangeRateX96
    );
    function globalDebtLimit() external view returns (uint256);
    function minLoanSize() external view returns (uint256);
    function transformerAllowList(address) external view returns (bool);
    function loanInfo(uint256 tokenId) external view returns (
        uint256 debt, uint256 fullValue, uint256 collateralValue,
        uint256 liquidationCost, uint256 liquidationValue
    );
}

interface IV3Oracle {
    function maxPoolPriceDifference() external view returns (uint16);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
}

contract RevertLendPermanentBadDebt is Test {
    IV3Vault constant vault = IV3Vault(0xa2754543f69dC036764bBfad16d2A74F5cD15667);
    IV3Oracle constant oracle = IV3Oracle(0xe0151d335A6C4AB0600Ae4000a9CAAf7b236072f);
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant LEVERAGE_TRANSFORMER = 0x227AcFb22A7b6E0c91021e861f50926d3c553A96;

    uint256 constant Q32 = 2**32;
    uint256 constant Q96 = 2**96;
    uint256 constant MAX_LIQUIDATION_PENALTY_X32 = Q32 * 10 / 100; // 10%

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    /**
     * @notice Analyze the permanent bad debt vulnerability
     *
     * Attack path:
     * 1. Create position at very high LTV (96-100%) via transform
     * 2. Small price movement -> underwater
     * 3. Oracle manipulation blocks normal liquidation
     * 4. Interest accrues, debt grows
     * 5. Eventually position enters "free liquidation" territory (fullValue < 10% of debt)
     * 6. Free liquidation: reserveCost = debt (liquidatorCost = 0)
     * 7. If debt > totalLent + reserves, _handleReserveLiquidation REVERTS
     * 8. Position is PERMANENTLY unliquidatable
     */
    function test_PermanentBadDebtAnalysis() public view {
        console.log("=== PERMANENT BAD DEBT VULNERABILITY ===");
        console.log("");

        (uint256 debt, uint256 lent,, uint256 reserves,,) = vault.vaultInfo();
        uint256 globalDebtLimit = vault.globalDebtLimit();

        console.log("Current Vault State:");
        console.log("  Total Debt:", debt / 1e6, "USDC");
        console.log("  Total Lent:", lent / 1e6, "USDC");
        console.log("  Reserves:", reserves / 1e6, "USDC");
        console.log("  Global Debt Limit:", globalDebtLimit / 1e6, "USDC");
        console.log("");

        // Calculate threshold for permanent bad debt
        // For liquidation to revert: missing >= totalLent
        // missing = reserveCost - reserves
        // In free liquidation: reserveCost = debt
        // So: debt - reserves >= totalLent
        // debt >= totalLent + reserves

        uint256 permanentBadDebtThreshold = lent + reserves;
        console.log("Permanent Bad Debt Threshold:", permanentBadDebtThreshold / 1e6, "USDC");
        console.log("");

        // How much additional bad debt needed?
        if (debt < permanentBadDebtThreshold) {
            uint256 additionalNeeded = permanentBadDebtThreshold - debt;
            console.log("Additional Bad Debt Needed:", additionalNeeded / 1e6, "USDC");
        } else {
            console.log("!!! ALREADY ABOVE THRESHOLD - LIQUIDATION COULD FAIL !!!");
        }
        console.log("");

        console.log("VULNERABILITY CODE:");
        console.log("  _handleReserveLiquidation():");
        console.log("    if (reserveCost > reserves) {");
        console.log("        missing = reserveCost - reserves;");
        console.log("        uint256 totalLent = _convertToAssets(totalSupply(), newLendExchangeRateX96);");
        console.log("        // UNDERFLOWS IF missing >= totalLent");
        console.log("        newLendExchangeRateX96 = (totalLent - missing) * ...");
        console.log("    }");
        console.log("");

        // Check if LeverageTransformer is whitelisted
        bool leverageAllowed = vault.transformerAllowList(LEVERAGE_TRANSFORMER);
        console.log("LeverageTransformer whitelisted:", leverageAllowed);
        console.log("");
    }

    /**
     * @notice Simulate free liquidation scenario
     */
    function test_FreeLiquidationMath() public view {
        console.log("=== FREE LIQUIDATION MATH ===");
        console.log("");

        (uint256 totalDebt, uint256 totalLent,, uint256 reserves,,) = vault.vaultInfo();

        // Scenario: Position with debt that has collapsed to free liquidation
        uint256 positionDebt = 1_500_000e6; // 1.5M USDC debt
        uint256 penalty = positionDebt * MAX_LIQUIDATION_PENALTY_X32 / Q32; // 10% = 150K

        // Free liquidation occurs when fullValue <= penalty
        uint256 fullValue = penalty / 2; // Position collapsed to 75K (half of penalty)

        console.log("Simulated Free Liquidation:");
        console.log("  Position Debt:", positionDebt / 1e6, "USDC");
        console.log("  Penalty (10%):", penalty / 1e6, "USDC");
        console.log("  Position Value:", fullValue / 1e6, "USDC (collapsed)");
        console.log("");

        // In free liquidation: liquidatorCost = 0, reserveCost = debt
        uint256 liquidatorCost = 0;
        uint256 reserveCost = positionDebt;

        console.log("Liquidation Costs:");
        console.log("  Liquidator pays:", liquidatorCost / 1e6, "USDC (free!)");
        console.log("  Reserve covers:", reserveCost / 1e6, "USDC");
        console.log("");

        // Calculate missing
        uint256 missing = reserveCost > reserves ? reserveCost - reserves : 0;
        console.log("Missing Amount:");
        console.log("  Reserves available:", reserves / 1e6, "USDC");
        console.log("  Missing:", missing / 1e6, "USDC");
        console.log("");

        // Check if liquidation would revert
        if (missing >= totalLent) {
            console.log("!!! LIQUIDATION WOULD REVERT !!!");
            console.log("  Missing >= Total Lent");
            console.log("  (totalLent - missing) would UNDERFLOW");
            console.log("");
            console.log("RESULT: PERMANENT BAD DEBT");
        } else {
            console.log("Liquidation would succeed (barely)");
            console.log("  New exchange rate would drop significantly");
            uint256 newRateMultiplier = (totalLent - missing) * 100 / totalLent;
            console.log("  Rate multiplier:", newRateMultiplier, "%");
        }
    }

    /**
     * @notice Calculate attack cost and requirements
     */
    function test_AttackCostAnalysis() public view {
        console.log("=== ATTACK COST ANALYSIS ===");
        console.log("");

        (uint256 totalDebt, uint256 totalLent,, uint256 reserves,,) = vault.vaultInfo();
        uint256 globalLimit = vault.globalDebtLimit();

        // Threshold for permanent bad debt
        uint256 threshold = totalLent + reserves;

        console.log("For Permanent Bad Debt Attack:");
        console.log("  Need total bad debt >", threshold / 1e6, "USDC");
        console.log("");

        // Can attacker create this much bad debt?
        uint256 availableDebtCapacity = globalLimit - totalDebt;
        console.log("Available Debt Capacity:", availableDebtCapacity / 1e6, "USDC");

        if (availableDebtCapacity >= threshold) {
            console.log("  SUFFICIENT capacity exists!");
            console.log("");
            console.log("Attack Steps:");
            console.log("  1. Deposit collateral (Uniswap V3 positions)");
            console.log("  2. Use LeverageTransformer to borrow at ~99% LTV");
            console.log("  3. Manipulate oracle to block liquidation");
            console.log("  4. Wait for position to enter free liquidation territory");
            console.log("  5. Liquidation reverts permanently");
            console.log("");
            console.log("Cost: Collateral loss (but creates permanent protocol insolvency)");
        } else {
            console.log("  Insufficient capacity for single attack");
            console.log("  Would need multiple coordinated positions");
        }
    }

    /**
     * @notice Demonstrate the underflow in _handleReserveLiquidation
     */
    function test_UnderflowProof() public pure {
        console.log("=== UNDERFLOW PROOF ===");
        console.log("");

        // Simulated values
        uint256 totalLent = 1_130_000e6;  // 1.13M USDC
        uint256 reserves = 3_000e6;        // 3K USDC
        uint256 reserveCost = 1_500_000e6; // 1.5M USDC (free liquidation of large bad debt)

        console.log("Scenario:");
        console.log("  Total Lent:", totalLent / 1e6, "USDC");
        console.log("  Reserves:", reserves / 1e6, "USDC");
        console.log("  Reserve Cost:", reserveCost / 1e6, "USDC");
        console.log("");

        uint256 missing = reserveCost - reserves;
        console.log("  Missing = reserveCost - reserves =", missing / 1e6, "USDC");
        console.log("");

        if (missing > totalLent) {
            console.log("!!! UNDERFLOW CONDITION MET !!!");
            console.log("  missing > totalLent");
            console.log("  (totalLent - missing) would be negative");
            console.log("  In Solidity 0.8+, this REVERTS");
            console.log("");
            console.log("CONSEQUENCE:");
            console.log("  liquidate() always reverts for this position");
            console.log("  Bad debt is PERMANENT and UNLIQUIDATABLE");
        } else {
            uint256 result = totalLent - missing;
            console.log("No underflow, result:", result / 1e6, "USDC");
        }
    }

    /**
     * @notice Combined attack summary
     */
    function test_CombinedAttackSummary() public view {
        console.log("=== COMBINED ATTACK: PERMANENT PROTOCOL INSOLVENCY ===");
        console.log("");

        (uint256 debt, uint256 lent,, uint256 reserves,,) = vault.vaultInfo();

        console.log("VULNERABILITY CHAIN:");
        console.log("");
        console.log("1. SAFETY BUFFER BYPASS (via transform)");
        console.log("   - Normal borrow: collateralValue * 95% >= debt");
        console.log("   - Transform mode: collateralValue >= debt (no buffer!)");
        console.log("   - Can borrow up to 100% of collateral value");
        console.log("");
        console.log("2. ORACLE MANIPULATION (low-liq pools)");
        console.log("   - Oracle reverts if |spot - derived| > 200 bps");
        console.log("   - Attacker swaps in pool to push deviation");
        console.log("   - All liquidation calls revert on oracle check");
        console.log("");
        console.log("3. INTEREST ACCRUAL (time passes)");
        console.log("   - Debt grows with interest while unliquidatable");
        console.log("   - Position gets deeper underwater");
        console.log("");
        console.log("4. FREE LIQUIDATION TERRITORY");
        console.log("   - When fullValue < 10% of debt");
        console.log("   - liquidatorCost = 0");
        console.log("   - reserveCost = full debt");
        console.log("");
        console.log("5. LIQUIDATION REVERT (underflow)");
        console.log("   - If bad debt > totalLent + reserves");
        console.log("   - _handleReserveLiquidation underflows");
        console.log("   - Liquidation permanently reverts");
        console.log("");

        console.log("CURRENT THRESHOLDS:");
        console.log("  Bad debt threshold:", (lent + reserves) / 1e6, "USDC");
        console.log("  Current debt:", debt / 1e6, "USDC");
        console.log("  Room to threshold:", (lent + reserves - debt) / 1e6, "USDC");
        console.log("");

        console.log("IMPACT:");
        console.log("  - Protocol becomes permanently insolvent");
        console.log("  - Lenders cannot withdraw (no liquidity)");
        console.log("  - Bad debt locked forever");
        console.log("  - Vault essentially bricked");
        console.log("");

        console.log("SEVERITY: CRITICAL");
        console.log("STATUS: DESIGN FLAW (underflow not guarded)");
        console.log("");

        console.log("RECOMMENDED FIX:");
        console.log("  In _handleReserveLiquidation:");
        console.log("  if (missing >= totalLent) {");
        console.log("      newLendExchangeRateX96 = 1; // Floor at minimum");
        console.log("  } else {");
        console.log("      newLendExchangeRateX96 = (totalLent - missing) * ...;");
        console.log("  }");
    }
}
