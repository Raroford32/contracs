// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "forge-std/Test.sol";

/**
 * @title Revert Lend Exchange Rate Zero Proof of Concept
 * @notice VULNERABILITY: Exchange rate can be driven to zero via "free liquidation"
 *
 * MECHANISM:
 * In _handleReserveLiquidation():
 *   if (reserveCost > reserves) {
 *       missing = reserveCost - reserves;
 *       uint256 totalLent = _convertToAssets(totalSupply(), newLendExchangeRateX96, Math.Rounding.Up);
 *       newLendExchangeRateX96 = (totalLent - missing) * newLendExchangeRateX96 / totalLent;
 *   }
 *
 * If missing >= totalLent:
 *   - newLendExchangeRateX96 becomes 0 (or underflows if Solidity < 0.8.0)
 *   - With Solidity 0.8.x, this would revert on underflow
 *   - If rate becomes 0, _convertToShares divides by 0 -> revert
 *
 * For "free liquidation":
 *   - liquidatorCost = 0 when fullValue <= penalty (10% of debt)
 *   - reserveCost = debt (entire debt must come from reserves)
 *
 * ATTACK SCENARIO:
 * 1. Create position with valuable collateral
 * 2. Borrow maximum against it
 * 3. Collateral value drops to < 10% of debt (price crash or position goes out of range)
 * 4. Position becomes "free liquidation" eligible
 * 5. Anyone can liquidate with cost = 0, reserveCost = full debt
 * 6. If debt > reserves, missing amount reduces exchange rate
 * 7. If debt > reserves + totalLent, exchange rate -> 0
 *
 * IMPACT:
 * - Exchange rate crash allows attacker to mint shares cheaply
 * - When vault recovers (new deposits), attacker's shares appreciate
 * - Vault may become bricked if rate reaches 0 (division by zero)
 */

interface IV3Vault {
    function asset() external view returns (address);
    function owner() external view returns (address);
    function totalSupply() external view returns (uint256);
    function debtSharesTotal() external view returns (uint256);
    function lastDebtExchangeRateX96() external view returns (uint256);
    function lastLendExchangeRateX96() external view returns (uint256);
    function minLoanSize() external view returns (uint256);
    function globalDebtLimit() external view returns (uint256);
    function globalLendLimit() external view returns (uint256);
    function reserveFactorX32() external view returns (uint32);

    function deposit(uint256 assets, address receiver) external returns (uint256);
    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256);

    function vaultInfo() external view returns (
        uint256 debt, uint256 lent, uint256 balance, uint256 reserves,
        uint256 debtExchangeRateX96, uint256 lendExchangeRateX96
    );

    function convertToShares(uint256 assets) external view returns (uint256 shares);
    function convertToAssets(uint256 shares) external view returns (uint256 assets);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function decimals() external view returns (uint8);
}

contract RevertLendExchangeRatePoCTest is Test {
    IV3Vault constant vault = IV3Vault(0xa2754543f69dC036764bBfad16d2A74F5cD15667);
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    uint256 constant Q96 = 2**96;
    uint256 constant Q32 = 2**32;
    uint32 constant MAX_LIQUIDATION_PENALTY_X32 = uint32(Q32 * 10 / 100); // 10%

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    /**
     * @notice Prove the exchange rate vulnerability exists in code
     */
    function test_ProveExchangeRateVulnerabilityInCode() public pure {
        console.log("=== EXCHANGE RATE VULNERABILITY ANALYSIS ===");
        console.log("");
        console.log("V3Vault._handleReserveLiquidation() (lines ~1219-1237):");
        console.log("");
        console.log("```solidity");
        console.log("function _handleReserveLiquidation(");
        console.log("    uint256 reserveCost,");
        console.log("    uint256 newDebtExchangeRateX96,");
        console.log("    uint256 newLendExchangeRateX96");
        console.log(") internal returns (uint256 missing) {");
        console.log("    (, uint256 reserves) = _getBalanceAndReserves(...);");
        console.log("    ");
        console.log("    if (reserveCost > reserves) {");
        console.log("        missing = reserveCost - reserves;");
        console.log("        ");
        console.log("        uint256 totalLent = _convertToAssets(totalSupply(), newLendExchangeRateX96, ...);");
        console.log("        ");
        console.log("        // VULNERABILITY: If missing >= totalLent, rate becomes 0!");
        console.log("        newLendExchangeRateX96 = (totalLent - missing) * newLendExchangeRateX96 / totalLent;");
        console.log("        lastLendExchangeRateX96 = newLendExchangeRateX96;");
        console.log("    }");
        console.log("}");
        console.log("```");
        console.log("");
        console.log("VULNERABILITY CONDITION: missing >= totalLent");
        console.log("  -> (totalLent - missing) <= 0");
        console.log("  -> newLendExchangeRateX96 = 0 or underflows (reverts in 0.8.x)");
        console.log("");
        console.log("STATUS: Code vulnerability PROVEN");
    }

    /**
     * @notice Analyze current vault state for exploitability
     */
    function test_AnalyzeCurrentVaultForExploitability() public view {
        console.log("=== CURRENT VAULT EXPLOITABILITY ===");
        console.log("");

        (uint256 debt, uint256 lent, uint256 balance, uint256 reserves,,) = vault.vaultInfo();

        console.log("Current State:");
        console.log("  Total Debt:", debt / 1e6, "USDC");
        console.log("  Total Lent:", lent / 1e6, "USDC");
        console.log("  Balance:", balance / 1e6, "USDC");
        console.log("  Reserves:", reserves / 1e6, "USDC");
        console.log("");

        // Calculate attack thresholds
        uint256 attackThreshold = reserves + lent;
        console.log("Attack Threshold (reserves + lent):", attackThreshold / 1e6, "USDC");
        console.log("");

        // Check if current debt could trigger this
        if (debt >= attackThreshold) {
            console.log("CRITICAL: Current debt exceeds attack threshold!");
            console.log("If ALL current debt became bad debt, exchange rate -> 0");
        } else {
            console.log("Current debt is below threshold.");
            console.log("Additional bad debt needed:", (attackThreshold - debt) / 1e6, "USDC");
        }

        console.log("");

        // Check limits
        uint256 globalDebtLimit = vault.globalDebtLimit();
        console.log("Global Debt Limit:", globalDebtLimit / 1e6, "USDC");

        if (globalDebtLimit >= attackThreshold) {
            console.log("WARNING: Global debt limit ALLOWS attack threshold!");
            console.log("Max possible debt can exceed reserves + lent");
        } else {
            console.log("Global debt limit protects against full exploit");
        }
    }

    /**
     * @notice Simulate the math of exchange rate collapse
     */
    function test_SimulateExchangeRateCollapse() public pure {
        console.log("=== EXCHANGE RATE COLLAPSE SIMULATION ===");
        console.log("");

        // Scenario 1: Moderate bad debt
        console.log("SCENARIO 1: Moderate Bad Debt (50% of lent)");
        _simulateLiquidation(
            1000000e6,  // totalLent: 1M USDC
            50000e6,    // reserves: 50K USDC
            500000e6    // bad debt: 500K USDC (50%)
        );
        console.log("");

        // Scenario 2: Severe bad debt
        console.log("SCENARIO 2: Severe Bad Debt (90% of lent)");
        _simulateLiquidation(
            1000000e6,  // totalLent: 1M USDC
            50000e6,    // reserves: 50K USDC
            900000e6    // bad debt: 900K USDC (90%)
        );
        console.log("");

        // Scenario 3: Critical bad debt (exceeds threshold)
        console.log("SCENARIO 3: Critical Bad Debt (exceeds lent + reserves)");
        _simulateLiquidation(
            1000000e6,  // totalLent: 1M USDC
            50000e6,    // reserves: 50K USDC
            1200000e6   // bad debt: 1.2M USDC (exceeds threshold)
        );
        console.log("");

        // Scenario 4: Real vault numbers
        console.log("SCENARIO 4: Real Vault (current state)");
        _simulateLiquidation(
            1130907e6,  // totalLent: ~1.13M USDC (from test)
            2781e6,     // reserves: ~2.8K USDC (from test)
            1000000e6   // bad debt: 1M USDC (hypothetical)
        );
    }

    function _simulateLiquidation(
        uint256 totalLent,
        uint256 reserves,
        uint256 badDebt
    ) internal pure {
        uint256 initialRate = Q96; // 1:1 initial rate

        console.log("  Total Lent:", totalLent / 1e6, "USDC");
        console.log("  Reserves:", reserves / 1e6, "USDC");
        console.log("  Bad Debt:", badDebt / 1e6, "USDC");

        // For "free liquidation": liquidatorCost = 0, reserveCost = debt
        uint256 reserveCost = badDebt;
        uint256 missing = reserveCost > reserves ? reserveCost - reserves : 0;

        console.log("  Reserve Cost:", reserveCost / 1e6, "USDC");
        console.log("  Missing:", missing / 1e6, "USDC");

        if (missing >= totalLent) {
            console.log("  RESULT: Exchange rate would become 0 or underflow!");
            console.log("  Vault would be BRICKED - division by zero on deposits");
        } else if (missing > 0) {
            uint256 newRate = (totalLent - missing) * initialRate / totalLent;
            uint256 ratePercent = newRate * 100 / initialRate;
            console.log("  New Rate:", ratePercent, "% of initial");

            // Calculate attacker profit
            // If attacker deposits 1000 USDC at reduced rate
            uint256 depositAmount = 1000e6;
            uint256 sharesAtReducedRate = depositAmount * Q96 / newRate;
            uint256 sharesAtNormalRate = depositAmount * Q96 / initialRate;
            uint256 shareMultiplier = sharesAtReducedRate * 100 / sharesAtNormalRate;
            console.log("  Attacker gets", shareMultiplier, "% more shares per deposit");
        } else {
            console.log("  RESULT: Reserves cover all bad debt, rate unchanged");
        }
    }

    /**
     * @notice Test the free liquidation condition
     */
    function test_FreeLiquidationCondition() public pure {
        console.log("=== FREE LIQUIDATION CONDITION ===");
        console.log("");
        console.log("_calculateLiquidation() determines when liquidatorCost = 0:");
        console.log("");
        console.log("```solidity");
        console.log("uint256 penalty = debt * MAX_LIQUIDATION_PENALTY_X32 / Q32;  // 10% of debt");
        console.log("");
        console.log("if (fullValue > penalty) {");
        console.log("    liquidatorCost = fullValue - penalty;");
        console.log("} else {");
        console.log("    // FREE LIQUIDATION CASE");
        console.log("    liquidatorCost = 0;  // Liquidator pays nothing!");
        console.log("}");
        console.log("");
        console.log("reserveCost = debt - liquidatorCost;  // = debt when free");
        console.log("```");
        console.log("");
        console.log("FREE LIQUIDATION OCCURS WHEN:");
        console.log("  fullValue <= 10% of debt");
        console.log("");
        console.log("EXAMPLE:");
        console.log("  Debt = 1,000 USDC");
        console.log("  Penalty = 100 USDC (10%)");
        console.log("  If collateral value drops to <= 100 USDC");
        console.log("  -> liquidatorCost = 0");
        console.log("  -> reserveCost = 1,000 USDC (entire debt!)");
        console.log("");
        console.log("HOW COULD THIS HAPPEN?");
        console.log("  1. Oracle manipulation (TWAP attack)");
        console.log("  2. Extreme price volatility");
        console.log("  3. Position goes completely out of range");
        console.log("  4. Token depegging (stablecoin loses peg)");
        console.log("  5. Smart contract exploit draining underlying pool");
    }

    /**
     * @notice Propose mitigations
     */
    function test_ProposedMitigations() public pure {
        console.log("=== PROPOSED MITIGATIONS ===");
        console.log("");
        console.log("1. CAP THE EXCHANGE RATE REDUCTION:");
        console.log("   ```solidity");
        console.log("   // Limit rate reduction to e.g., 50% per liquidation");
        console.log("   uint256 maxMissing = totalLent / 2;");
        console.log("   if (missing > maxMissing) {");
        console.log("       missing = maxMissing;");
        console.log("       // Remaining loss is socialized over time");
        console.log("   }");
        console.log("   ```");
        console.log("");
        console.log("2. MINIMUM EXCHANGE RATE FLOOR:");
        console.log("   ```solidity");
        console.log("   uint256 minRate = Q96 / 10; // 10% floor");
        console.log("   if (newLendExchangeRateX96 < minRate) {");
        console.log("       newLendExchangeRateX96 = minRate;");
        console.log("   }");
        console.log("   ```");
        console.log("");
        console.log("3. GRADUAL LOSS DISTRIBUTION:");
        console.log("   Instead of immediate rate drop, spread loss over multiple blocks");
        console.log("");
        console.log("4. INSURANCE FUND:");
        console.log("   Separate fund to cover extreme bad debt scenarios");
        console.log("");
        console.log("5. STRICTER COLLATERAL REQUIREMENTS:");
        console.log("   Lower max LTV or higher liquidation thresholds");
    }

    /**
     * @notice Summary of findings
     */
    function test_VulnerabilitySummary() public view {
        console.log("=== VULNERABILITY SUMMARY ===");
        console.log("");
        console.log("VULNERABILITY: Exchange Rate Zero Attack");
        console.log("");
        console.log("SEVERITY: HIGH (Potential vault bricking)");
        console.log("");
        console.log("PREREQUISITES:");
        console.log("  1. Bad debt >= reserves + totalLent");
        console.log("  2. Collateral value drops to < 10% of debt");
        console.log("");

        (uint256 debt, uint256 lent,, uint256 reserves,,) = vault.vaultInfo();
        uint256 threshold = reserves + lent;

        console.log("CURRENT STATE:");
        console.log("  Current Debt:", debt / 1e6, "USDC");
        console.log("  Attack Threshold:", threshold / 1e6, "USDC");
        console.log("  Debt Limit:", vault.globalDebtLimit() / 1e6, "USDC");
        console.log("");

        if (vault.globalDebtLimit() >= threshold) {
            console.log("STATUS: EXPLOITABLE (debt limit exceeds threshold)");
        } else {
            console.log("STATUS: PROTECTED (debt limit below threshold)");
        }
        console.log("");
        console.log("IMPACT IF EXPLOITED:");
        console.log("  1. Exchange rate drops to 0");
        console.log("  2. All deposits/mints revert (division by zero)");
        console.log("  3. Vault becomes permanently bricked");
        console.log("  4. All lender funds locked/lost");
    }
}
