// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";

interface IDBR {
    function balances(address) external view returns (uint256);
    function balanceOf(address) external view returns (uint256);
    function deficitOf(address) external view returns (uint256);
    function debts(address) external view returns (uint256);
    function dueTokensAccrued(address) external view returns (uint256);
    function lastUpdated(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function _totalSupply() external view returns (uint256);
    function totalDueTokensAccrued() external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function accrueDueTokens(address) external;
    function operator() external view returns (address);
    function markets(address) external view returns (bool);
    function signedBalanceOf(address) external view returns (int);
}

interface IMarket {
    function borrow(uint256) external;
    function repay(address, uint256) external;
    function deposit(uint256) external;
    function withdraw(uint256) external;
    function debts(address) external view returns (uint256);
    function escrows(address) external view returns (address);
    function collateral() external view returns (address);
    function dola() external view returns (address);
    function dbr() external view returns (address);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract DBRExploit is Test {
    address constant DBR = 0xAD038Eb671c44b853887A7E32528FaB35dC5D710;
    address constant INV_MARKET = 0x63Df5e23Db45a2066508318f172bA45B9CD37035;

    address attacker = makeAddr("attacker");

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    // NOVEL TEST 1: Check if transfer can be exploited when user has debt
    // The transfer checks balanceOf (which includes accrued debt)
    // but subtracts from balances (raw). Can this desync be exploited?
    function testNovel_TransferWithDebt() public {
        IDBR dbr = IDBR(DBR);

        console.log("=== Transfer + Debt Desync Analysis ===");

        // Find a user with debt
        // Check DBR state
        console.log("Total Supply:", dbr.totalSupply());
        console.log("Total Due Accrued:", dbr.totalDueTokensAccrued());

        // The key insight: if user has debt accruing, their balanceOf changes over time
        // but their `balances[user]` stays constant until accrueDueTokens is called

        // Can we exploit timing between balanceOf check and balances modification?
    }

    // NOVEL TEST 2: Can we grief a user's DBR by calling accrueDueTokens?
    function testNovel_GriefByAccrue() public {
        IDBR dbr = IDBR(DBR);

        console.log("=== AccrueDueTokens Grief Analysis ===");

        // accrueDueTokens is public - anyone can call it for any user
        // This crystalizes their debt into dueTokensAccrued
        // But does this have any adverse effect?

        // The debt accrues anyway (it's calculated in balanceOf/deficitOf)
        // So calling accrueDueTokens just moves it from "virtual" to "crystalized"
        // No grief vector here

        console.log("No grief possible - accrual happens regardless");
    }

    // NOVEL TEST 3: Integer edge case - what if debt is extremely large?
    function testNovel_LargeDebtOverflow() public {
        IDBR dbr = IDBR(DBR);

        console.log("=== Large Debt Overflow Analysis ===");

        // accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days
        //
        // If debt is close to max uint256, this multiplication could overflow
        // But Solidity 0.8.x has built-in overflow checks
        // So it would revert, potentially DoS'ing the user

        // But can an unprivileged attacker set someone's debt high?
        // Only markets can call onBorrow which increases debt
        // So attacker would need market access

        console.log("Overflow not exploitable - only markets set debt");
    }

    // NOVEL TEST 4: Cross-user debt manipulation
    // When user A transfers to user B, does B's debt state change?
    function testNovel_TransferDebtInheritance() public {
        IDBR dbr = IDBR(DBR);

        console.log("=== Transfer Debt Inheritance Analysis ===");

        // Transfer only moves balances[from] to balances[to]
        // It doesn't touch debts, dueTokensAccrued, or lastUpdated
        // So debt is NOT inherited - this is correct

        // But what if we transfer DBR to someone with deficit?
        // They'd receive DBR and reduce their deficit
        // This is intended behavior

        console.log("No debt inheritance - balances are independent of debt");
    }

    // NOVEL TEST 5: Check for rounding attack in debt accrual
    function testNovel_RoundingAccrual() public {
        IDBR dbr = IDBR(DBR);

        console.log("=== Rounding Attack Analysis ===");

        // accrued = (block.timestamp - lastUpdated) * debt / 365 days
        // = deltaTime * debt / 31536000

        // If deltaTime * debt < 31536000, accrued rounds to 0

        // For debt of 1 DOLA (1e18), to accrue 1 DBR (1e18):
        // 1e18 = deltaTime * 1e18 / 31536000
        // deltaTime = 31536000 seconds = 1 year

        // For debt of 1e18 and 1 second:
        // accrued = 1 * 1e18 / 31536000 = ~31.7e12 (non-zero)

        // So there's no significant rounding loss

        uint256 oneYear = 365 days;
        uint256 debt = 1e18;
        uint256 oneSecond = 1;

        uint256 accruedOneSecond = oneSecond * debt / oneYear;
        console.log("Accrued in 1 second (1 DOLA debt):", accruedOneSecond);
        // Should be ~31.7e12

        console.log("No significant rounding attack possible");
    }

    // NOVEL TEST 6: signedBalanceOf overflow
    function testNovel_SignedBalanceOverflow() public {
        IDBR dbr = IDBR(DBR);

        console.log("=== SignedBalance Overflow Analysis ===");

        // signedBalanceOf:
        // return int(balances[user]) - int(dueTokensAccrued[user]) - int(accrued);

        // If balances is > 2^255-1, int() cast would overflow
        // But balances can only grow via mint/transfer
        // Total supply is limited, so this shouldn't happen

        console.log("Raw total supply:", dbr._totalSupply());

        // Check if anyone has massive balance
        // This would require someone to have most of the supply
    }
}
