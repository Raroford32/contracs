// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
}

contract AccessControlAudit is Test {
    // EIP-1967 slots
    bytes32 constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    bytes32 constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
    bytes32 constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;

    // Common owner slots
    bytes32 constant OWNABLE_SLOT = bytes32(uint256(0)); // Often slot 0

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testScanProxyVulnerabilities() public view {
        console.log("=====================================================");
        console.log("PROXY VULNERABILITY SCANNER");
        console.log("=====================================================");

        // High-value contracts to check
        address[20] memory targets = [
            0x889edC2eDab5f40e902b864aD4d7AdE8E412F9B1, // Lido Queue
            0x8315177aB297bA92A06054cE80a67Ed4DBd7ed3a, // Arbitrum Bridge
            0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb, // Morpho
            0x858646372CC42E1A627fcE94aa7A7033e7CF075A, // EigenLayer
            0x93c4b944D05dfe6df7645A86cd2206016c51564D, // EigenLayer stETH
            0x097f1ee62E63aCFC3Bf64c1a61d96B3771dd06cB, // BAMM PCV
            0x920623AcBa785ED9a70d33ACab53631e1e834675, // BAMM
            0xF5BCE5077908a1b7370B9ae04AdC565EBd643966, // BentoBox
            0xc3d688B66703497DAA19211EEdff47f25384cdc3, // Compound
            0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2, // Aave Pool
            0xBA12222222228d8Ba445958a75a0704d566BF2C8, // Balancer Vault
            0x00000000005BBB0EF59571E58418F9a4357b68A0, // Pendle Router
            0x000000000022D473030F116dDEE9F6B43aC78BA3, // Permit2
            0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84, // stETH
            0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0, // wstETH
            0xF403C135812408BFbE8713b5A23a04b3D48AAE31, // Convex Booster
            0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B, // CVX
            0x72a19342e8F1838460eBFCCEf09F6585e32db86E, // cvxCRV
            0xD533a949740bb3306d119CC777fa900bA034cd52, // CRV
            address(0)
        ];

        for (uint i = 0; i < targets.length; i++) {
            if (targets[i] == address(0)) continue;
            if (targets[i].code.length == 0) continue;

            console.log("\n=== Contract:", targets[i], "===");

            // Check for proxy implementation
            bytes32 implSlot = vm.load(targets[i], IMPLEMENTATION_SLOT);
            address impl = address(uint160(uint256(implSlot)));
            if (impl != address(0) && impl.code.length > 0) {
                console.log("PROXY - Implementation:", impl);

                // Check if implementation is initializable
                bool isInitialized = checkInitialized(impl);
                if (!isInitialized) {
                    console.log("*** CRITICAL: IMPLEMENTATION NOT INITIALIZED ***");
                }
            }

            // Check admin slot
            bytes32 adminSlot = vm.load(targets[i], ADMIN_SLOT);
            address admin = address(uint160(uint256(adminSlot)));
            if (admin != address(0)) {
                console.log("Proxy Admin:", admin);
            }

            // Check beacon
            bytes32 beaconSlot = vm.load(targets[i], BEACON_SLOT);
            address beacon = address(uint160(uint256(beaconSlot)));
            if (beacon != address(0) && beacon.code.length > 0) {
                console.log("Beacon:", beacon);

                // Check beacon owner
                bytes32 beaconOwner = vm.load(beacon, bytes32(0));
                console.log("Beacon Owner Slot 0:", address(uint160(uint256(beaconOwner))));
            }

            // Check slot 0 for owner
            bytes32 slot0 = vm.load(targets[i], bytes32(0));
            address possibleOwner = address(uint160(uint256(slot0)));
            if (possibleOwner != address(0) && possibleOwner != address(1)) {
                console.log("Slot 0 (possible owner):", possibleOwner);
            }

            // Check for AccessControl admin role
            checkAccessControl(targets[i]);
        }
    }

    function checkInitialized(address impl) internal view returns (bool) {
        // Check common initialization storage patterns
        // Most implementations use slot 0 or a specific init slot

        // Try calling initializer view functions
        (bool success, bytes memory data) = impl.staticcall(
            abi.encodeWithSignature("initialized()")
        );
        if (success && data.length >= 32) {
            return abi.decode(data, (bool));
        }

        // Check for OpenZeppelin Initializable pattern (_initialized slot)
        // _initialized is typically at a specific slot
        bytes32 initSlot = vm.load(impl, bytes32(uint256(0)));
        uint8 initValue = uint8(uint256(initSlot));

        return initValue > 0;
    }

    function checkAccessControl(address target) internal view {
        // DEFAULT_ADMIN_ROLE = 0x00
        bytes32 DEFAULT_ADMIN = bytes32(0);

        // Check if contract has AccessControl
        (bool success, bytes memory data) = target.staticcall(
            abi.encodeWithSignature("hasRole(bytes32,address)", DEFAULT_ADMIN, address(0))
        );

        if (success) {
            console.log("Has AccessControl pattern");

            // Check who has admin role
            address[5] memory commonAdmins = [
                address(0),
                0xCFF14Fee5e7aAB362040656b8B8F37bC1cae8eb6, // Common deployer
                0x0000000000000000000000000000000000000001,
                0x0000000000000000000000000000000000000000,
                address(this)
            ];

            for (uint j = 0; j < commonAdmins.length; j++) {
                (bool hasRoleSuccess, bytes memory hasRoleData) = target.staticcall(
                    abi.encodeWithSignature("hasRole(bytes32,address)", DEFAULT_ADMIN, commonAdmins[j])
                );
                if (hasRoleSuccess && hasRoleData.length >= 32) {
                    bool hasRole = abi.decode(hasRoleData, (bool));
                    if (hasRole) {
                        console.log("Admin role holder:", commonAdmins[j]);
                    }
                }
            }
        }

        // Check for Ownable pattern
        (success, data) = target.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (success && data.length >= 32) {
            address owner = abi.decode(data, (address));
            console.log("Owner:", owner);

            // Check if owner is zero (potentially claimable)
            if (owner == address(0)) {
                console.log("*** OWNER IS ZERO - CHECK CLAIMABLE ***");
            }
        }

        // Check for pending owner (2-step transfer)
        (success, data) = target.staticcall(
            abi.encodeWithSignature("pendingOwner()")
        );
        if (success && data.length >= 32) {
            address pendingOwner = abi.decode(data, (address));
            if (pendingOwner != address(0)) {
                console.log("*** PENDING OWNER SET:", pendingOwner, "***");
            }
        }
    }

    function testCheckSpecificVulnerabilities() public view {
        console.log("=====================================================");
        console.log("SPECIFIC VULNERABILITY CHECKS");
        console.log("=====================================================");

        // Check for contracts with open role granting
        address[10] memory accessControlContracts = [
            0x858646372CC42E1A627fcE94aa7A7033e7CF075A, // EigenLayer StrategyManager
            0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb, // Morpho
            0xc3d688B66703497DAA19211EEdff47f25384cdc3, // Compound
            0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2, // Aave Pool
            0xBA12222222228d8Ba445958a75a0704d566BF2C8, // Balancer
            0xF403C135812408BFbE8713b5A23a04b3D48AAE31, // Convex
            0x889edC2eDab5f40e902b864aD4d7AdE8E412F9B1, // Lido
            0x8315177aB297bA92A06054cE80a67Ed4DBd7ed3a, // Arbitrum
            0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84, // Lido stETH
            address(0)
        ];

        for (uint i = 0; i < accessControlContracts.length; i++) {
            if (accessControlContracts[i] == address(0)) continue;

            console.log("\n=== Checking:", accessControlContracts[i], "===");

            // Try to find grantRole function without access control
            checkOpenRoleGrant(accessControlContracts[i]);

            // Check for paused state
            checkPausedState(accessControlContracts[i]);

            // Check for timelock
            checkTimelockBypass(accessControlContracts[i]);
        }
    }

    function checkOpenRoleGrant(address target) internal view {
        // Check if grantRole exists
        (bool success,) = target.staticcall(
            abi.encodeWithSignature("getRoleAdmin(bytes32)", bytes32(0))
        );

        if (success) {
            console.log("Has role admin system");

            // Check common role hashes
            bytes32[] memory commonRoles = new bytes32[](5);
            commonRoles[0] = keccak256("ADMIN_ROLE");
            commonRoles[1] = keccak256("MINTER_ROLE");
            commonRoles[2] = keccak256("PAUSER_ROLE");
            commonRoles[3] = keccak256("UPGRADER_ROLE");
            commonRoles[4] = keccak256("MANAGER_ROLE");

            for (uint j = 0; j < commonRoles.length; j++) {
                (bool adminSuccess, bytes memory adminData) = target.staticcall(
                    abi.encodeWithSignature("getRoleAdmin(bytes32)", commonRoles[j])
                );
                if (adminSuccess && adminData.length >= 32) {
                    bytes32 roleAdmin = abi.decode(adminData, (bytes32));
                    if (roleAdmin == bytes32(0)) {
                        console.log("Role", j, "admin is DEFAULT_ADMIN");
                    }
                }
            }
        }
    }

    function checkPausedState(address target) internal view {
        (bool success, bytes memory data) = target.staticcall(
            abi.encodeWithSignature("paused()")
        );
        if (success && data.length >= 32) {
            bool isPaused = abi.decode(data, (bool));
            if (isPaused) {
                console.log("*** CONTRACT IS PAUSED ***");
            } else {
                console.log("Contract not paused");
            }
        }
    }

    function checkTimelockBypass(address target) internal view {
        // Check for timelock addresses
        (bool success, bytes memory data) = target.staticcall(
            abi.encodeWithSignature("timelock()")
        );
        if (success && data.length >= 32) {
            address timelock = abi.decode(data, (address));
            console.log("Timelock:", timelock);
        }

        // Check for guardian/emergency roles
        (success, data) = target.staticcall(
            abi.encodeWithSignature("guardian()")
        );
        if (success && data.length >= 32) {
            address guardian = abi.decode(data, (address));
            console.log("Guardian:", guardian);
        }
    }

    function testFindUninitializedProxies() public {
        console.log("=====================================================");
        console.log("SEARCHING FOR UNINITIALIZED PROXIES");
        console.log("=====================================================");

        // Scan for proxies with uninitialized implementations
        address[10] memory proxyCandidates = [
            0x889edC2eDab5f40e902b864aD4d7AdE8E412F9B1,
            0x8315177aB297bA92A06054cE80a67Ed4DBd7ed3a,
            0x858646372CC42E1A627fcE94aa7A7033e7CF075A,
            0x93c4b944D05dfe6df7645A86cd2206016c51564D,
            0xc3d688B66703497DAA19211EEdff47f25384cdc3,
            0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2,
            0xBA12222222228d8Ba445958a75a0704d566BF2C8,
            0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84,
            0xF403C135812408BFbE8713b5A23a04b3D48AAE31,
            address(0)
        ];

        for (uint i = 0; i < proxyCandidates.length; i++) {
            if (proxyCandidates[i] == address(0)) continue;

            bytes32 implSlot = vm.load(proxyCandidates[i], IMPLEMENTATION_SLOT);
            address impl = address(uint160(uint256(implSlot)));

            if (impl != address(0) && impl.code.length > 0) {
                console.log("\n=== Proxy:", proxyCandidates[i], "===");
                console.log("Implementation:", impl);

                // Try to initialize the implementation directly
                (bool canInit,) = impl.call(
                    abi.encodeWithSignature("initialize()")
                );
                if (canInit) {
                    console.log("*** CAN CALL INITIALIZE ON IMPLEMENTATION ***");
                }

                // Try with common initialize signatures
                tryInitialize(impl);
            }
        }
    }

    function tryInitialize(address impl) internal {
        // Common initialize signatures
        bytes4[] memory initSigs = new bytes4[](5);
        initSigs[0] = bytes4(keccak256("initialize()"));
        initSigs[1] = bytes4(keccak256("initialize(address)"));
        initSigs[2] = bytes4(keccak256("init()"));
        initSigs[3] = bytes4(keccak256("__init()"));
        initSigs[4] = bytes4(keccak256("setup(address)"));

        for (uint i = 0; i < initSigs.length; i++) {
            // We don't actually call, just check if it would revert
            bytes memory callData;
            if (i == 1 || i == 4) {
                callData = abi.encodeWithSelector(initSigs[i], address(this));
            } else {
                callData = abi.encodeWithSelector(initSigs[i]);
            }

            (bool success,) = impl.staticcall(callData);
            if (!success) {
                // Check revert reason - if it's "already initialized" that's expected
                // If it reverts for other reasons, might be exploitable
            }
        }
    }
}
