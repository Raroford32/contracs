// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Novel Exploit Search - Deep Protocol Analysis
 * @notice Searching for immediately exploitable vulnerabilities
 * @dev Focus: Share manipulation, reward theft, flash loan attacks, cross-protocol invariant breaks
 */

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
    function allowance(address, address) external view returns (uint256);
}

interface IERC4626 {
    function deposit(uint256 assets, address receiver) external returns (uint256);
    function redeem(uint256 shares, address receiver, address owner) external returns (uint256);
    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256);
    function mint(uint256 shares, address receiver) external returns (uint256);
    function totalAssets() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function convertToShares(uint256 assets) external view returns (uint256);
    function convertToAssets(uint256 shares) external view returns (uint256);
    function previewDeposit(uint256 assets) external view returns (uint256);
    function previewRedeem(uint256 shares) external view returns (uint256);
    function asset() external view returns (address);
    function maxDeposit(address) external view returns (uint256);
}

interface IAaveV3Pool {
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata interestRateModes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

interface IBalancerVault {
    function flashLoan(
        address recipient,
        address[] calldata tokens,
        uint256[] calldata amounts,
        bytes calldata userData
    ) external;
}

interface ISUSDe {
    function deposit(uint256 assets, address receiver) external returns (uint256);
    function redeem(uint256 shares, address receiver, address owner) external returns (uint256);
    function totalAssets() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function cooldownDuration() external view returns (uint24);
    function cooldownShares(uint256 shares) external;
    function unstake(address receiver) external;
    function cooldowns(address) external view returns (uint104 cooldownEnd, uint152 underlyingAmount);
}

interface IUSDe is IERC20 {
    function mint(address to, uint256 amount) external;
}

interface IEthenaMinting {
    function mint(
        bytes calldata route,
        address stableToken,
        uint256 stableTokenAmount,
        uint256 usdeAmount
    ) external returns (uint256);
}

interface IChainlinkOracle {
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
    function decimals() external view returns (uint8);
}

interface ICurvePool {
    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256);
    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);
    function balances(uint256 i) external view returns (uint256);
    function get_virtual_price() external view returns (uint256);
}

interface IMorpho {
    function supply(
        address marketParams,
        uint256 assets,
        uint256 shares,
        address onBehalf,
        bytes calldata data
    ) external returns (uint256, uint256);
    function borrow(
        address marketParams,
        uint256 assets,
        uint256 shares,
        address onBehalf,
        address receiver
    ) external returns (uint256, uint256);
}

contract NovelExploitSearch3 is Test {
    // Core addresses
    address constant AAVE_V3_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

    // Ethena
    address constant USDE = 0x4c9EDD5852cd905f086C759E8383e09bff1E68B3;
    address constant SUSDE = 0x9D39A5DE30e57443BfF2A8307A4256c8797A3497;
    address constant ETHENA_MINTING = 0xe3490297a08d6fC8Da46Edb7B6142E4F461b62D3;

    // Stablecoins
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;

    // Curve pools
    address constant CURVE_USDE_USDC = 0x02950460E2b9529D0E00284A5fA2d7bDF3fA4d72;

    // Test addresses
    address attacker;
    address victim;

    string constant RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        victim = makeAddr("victim");
    }

    /**
     * @notice Test sUSDe for share/cooldown manipulation
     */
    function test_sUSDe_Analysis() public {
        console.log("=== sUSDe Deep Analysis ===\n");

        ISUSDe susde = ISUSDe(SUSDE);
        IERC20 usde = IERC20(USDE);

        uint256 totalAssets = susde.totalAssets();
        uint256 totalSupply = susde.totalSupply();
        uint24 cooldown = susde.cooldownDuration();

        console.log("sUSDe State:");
        console.log("  Total Assets (USDe):", totalAssets / 1e18);
        console.log("  Total Supply (sUSDe):", totalSupply / 1e18);
        console.log("  Cooldown Duration:", cooldown);

        if (totalSupply > 0) {
            uint256 sharePrice = totalAssets * 1e18 / totalSupply;
            console.log("  Share Price (18 decimals):", sharePrice);

            // Check for any imbalance
            if (sharePrice > 1.1e18) {
                console.log("  NOTE: Share price elevated - yield accumulated");
            }
        }

        // Check USDe balance directly in contract vs totalAssets
        uint256 directBalance = usde.balanceOf(SUSDE);
        console.log("\n  Direct USDe Balance:", directBalance / 1e18);
        console.log("  Reported totalAssets:", totalAssets / 1e18);

        if (directBalance > totalAssets) {
            uint256 excess = directBalance - totalAssets;
            console.log("  EXCESS (unaccounted USDe):", excess / 1e18);
        }
    }

    /**
     * @notice Test for share inflation in various ERC4626 vaults
     */
    function test_VaultShareInflation() public {
        console.log("=== ERC4626 Share Inflation Search ===\n");

        // List of ERC4626 vaults to check
        address[] memory vaults = new address[](5);
        vaults[0] = SUSDE;  // sUSDe
        vaults[1] = 0xac3E018457B222d93114458476f3E3416Abbe38F; // sfrxETH
        vaults[2] = 0x9Ba021B0a9b958B5E75cE9f6dff97C7eE52cb3E6; // apxETH
        vaults[3] = 0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee; // weETH (wrapped eETH)
        vaults[4] = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0; // wstETH

        for (uint256 i = 0; i < vaults.length; i++) {
            address vault = vaults[i];
            if (vault.code.length == 0) continue;

            _analyzeVault(vault, i);
        }
    }

    function _analyzeVault(address vault, uint256 index) internal {
        try IERC4626(vault).totalSupply() returns (uint256 supply) {
            try IERC4626(vault).totalAssets() returns (uint256 assets) {
                console.log("Vault", index, ":", vault);
                console.log("  Supply:", supply / 1e18);
                console.log("  Assets:", assets / 1e18);

                if (supply == 0) {
                    console.log("  STATUS: EMPTY VAULT - First depositor attack possible!\n");
                    return;
                }

                uint256 sharePrice = assets * 1e18 / supply;
                console.log("  Share Price:", sharePrice / 1e15);

                // Check for donation attack viability
                try IERC4626(vault).previewDeposit(1e18) returns (uint256 previewShares) {
                    try IERC4626(vault).previewRedeem(previewShares) returns (uint256 previewAssets) {
                        uint256 loss = 1e18 > previewAssets ? 1e18 - previewAssets : 0;
                        console.log("  Deposit/Redeem Loss:", loss);

                        if (loss > 1e15) { // More than 0.1% loss
                            console.log("  WARNING: Significant loss on round-trip!\n");
                        }
                    } catch {}
                } catch {}
                console.log("");
            } catch {}
        } catch {}
    }

    /**
     * @notice Test Curve pool virtual price manipulation
     */
    function test_CurvePoolAnalysis() public {
        console.log("=== Curve Pool Analysis ===\n");

        // USDe/USDC pool
        ICurvePool pool = ICurvePool(CURVE_USDE_USDC);

        try pool.get_virtual_price() returns (uint256 vp) {
            console.log("USDe/USDC Pool:");
            console.log("  Virtual Price:", vp / 1e15);

            try pool.balances(0) returns (uint256 bal0) {
                try pool.balances(1) returns (uint256 bal1) {
                    console.log("  Balance 0:", bal0 / 1e18);
                    console.log("  Balance 1:", bal1 / 1e6); // USDC has 6 decimals

                    // Check imbalance ratio
                    uint256 bal0_normalized = bal0 / 1e18;
                    uint256 bal1_normalized = bal1 / 1e6;

                    if (bal0_normalized > 0 && bal1_normalized > 0) {
                        uint256 ratio = bal0_normalized * 100 / bal1_normalized;
                        console.log("  Imbalance Ratio:", ratio);

                        if (ratio > 110 || ratio < 90) {
                            console.log("  POTENTIAL: Pool significantly imbalanced!");
                        }
                    }
                } catch {}
            } catch {}
        } catch {
            console.log("Pool not accessible");
        }
    }

    /**
     * @notice Search for oracle price discrepancies that could enable arbitrage
     */
    function test_OraclePriceAnalysis() public {
        console.log("=== Oracle Price Discrepancy Search ===\n");

        // Chainlink price feeds
        address ethUsd = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;
        address stethUsd = 0xCfE54B5cD566aB89272946F602D76Ea879CAb4a8;
        address usdeUsd = 0xa569d910839Ae8865Da8F8e70FfFb0cBA869F961;

        console.log("ETH/USD Oracle:");
        _checkOracle(ethUsd);

        console.log("\nstETH/USD Oracle:");
        _checkOracle(stethUsd);

        console.log("\nUSDe/USD Oracle:");
        _checkOracle(usdeUsd);
    }

    function _checkOracle(address oracle) internal {
        if (oracle.code.length == 0) {
            console.log("  Oracle not deployed");
            return;
        }

        try IChainlinkOracle(oracle).latestRoundData() returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80
        ) {
            uint8 decimals = IChainlinkOracle(oracle).decimals();
            console.log("  Price:", uint256(answer));
            console.log("  Decimals:", decimals);
            console.log("  Updated:", updatedAt);
            console.log("  Staleness:", block.timestamp - updatedAt);

            // Check for stale price (> 1 hour)
            if (block.timestamp - updatedAt > 3600) {
                console.log("  WARNING: Price is stale!");
            }
        } catch {
            console.log("  Failed to fetch price");
        }
    }

    /**
     * @notice Test for flash loan attack vectors on staking protocols
     */
    function test_FlashLoanAttackVectors() public {
        console.log("=== Flash Loan Attack Vector Analysis ===\n");

        // Check available flash loan liquidity
        console.log("Available Flash Loan Liquidity:");

        IERC20 usdc = IERC20(USDC);
        IERC20 usde = IERC20(USDE);

        uint256 balancerUSDC = usdc.balanceOf(BALANCER_VAULT);
        console.log("  Balancer USDC:", balancerUSDC / 1e6);

        // Check if any protocol can be manipulated with large flash loans
        console.log("\nPotential Attack Targets:");

        // sUSDe - Can we manipulate with large USDe flash loan?
        uint256 susdeAssets = ISUSDe(SUSDE).totalAssets();
        uint256 susdeSupply = ISUSDe(SUSDE).totalSupply();
        console.log("  sUSDe Total Assets:", susdeAssets / 1e18);

        // Check if donation attack is viable
        uint256 usdeBalance = usde.balanceOf(SUSDE);
        if (usdeBalance > susdeAssets) {
            console.log("  sUSDe has unaccounted balance:", (usdeBalance - susdeAssets) / 1e18);
        }
    }

    /**
     * @notice Deep search for protocol invariant violations
     */
    function test_InvariantViolationSearch() public {
        console.log("=== Protocol Invariant Violation Search ===\n");

        // Test 1: sUSDe invariant - totalAssets should match accounting
        _checkSusdeInvariant();

        // Test 2: Check for any vaults with accounting discrepancies
        _checkVaultAccountingInvariants();
    }

    function _checkSusdeInvariant() internal {
        console.log("sUSDe Invariant Check:");

        IERC20 usde = IERC20(USDE);
        ISUSDe susde = ISUSDe(SUSDE);

        uint256 actualBalance = usde.balanceOf(SUSDE);
        uint256 reportedAssets = susde.totalAssets();
        uint256 totalShares = susde.totalSupply();

        console.log("  Actual USDe Balance:", actualBalance / 1e18);
        console.log("  Reported Total Assets:", reportedAssets / 1e18);
        console.log("  Total Shares:", totalShares / 1e18);

        // The invariant: actualBalance >= reportedAssets
        if (actualBalance < reportedAssets) {
            console.log("  INVARIANT VIOLATION: Balance < Reported Assets!");
            uint256 deficit = reportedAssets - actualBalance;
            console.log("  Deficit:", deficit / 1e18, "USDe");
        } else {
            console.log("  Invariant holds: Balance >= Reported Assets");
            console.log("  Surplus:", (actualBalance - reportedAssets) / 1e18);
        }
    }

    function _checkVaultAccountingInvariants() internal {
        console.log("\nVault Accounting Invariants:");

        // Check apxETH
        address apxeth = 0x9Ba021B0a9b958B5E75cE9f6dff97C7eE52cb3E6;
        address pxeth = 0x04C154b66CB340F3Ae24111CC767e0184Ed00Cc6;

        if (apxeth.code.length > 0) {
            console.log("\napxETH Analysis:");

            try IERC4626(apxeth).totalAssets() returns (uint256 assets) {
                try IERC4626(apxeth).totalSupply() returns (uint256 supply) {
                    uint256 underlyingBalance = IERC20(pxeth).balanceOf(apxeth);

                    console.log("  totalAssets():", assets / 1e18);
                    console.log("  totalSupply():", supply / 1e18);
                    console.log("  Underlying balance:", underlyingBalance / 1e18);

                    // Additional internal state if available
                    (bool success, bytes memory data) = apxeth.staticcall(
                        abi.encodeWithSignature("totalStaked()")
                    );
                    if (success && data.length >= 32) {
                        uint256 totalStaked = abi.decode(data, (uint256));
                        console.log("  totalStaked():", totalStaked / 1e18);

                        // Check if there's a discrepancy
                        if (assets != totalStaked) {
                            console.log("  DISCREPANCY between totalAssets and totalStaked!");
                        }
                    }
                } catch {}
            } catch {}
        }
    }

    /**
     * @notice Summary of exploit search
     */
    function test_ExploitSearchSummary() public view {
        console.log("=== Novel Exploit Search Summary ===\n");

        console.log("METHODOLOGY:");
        console.log("1. Scanning ERC4626 vaults for share inflation vulnerabilities");
        console.log("2. Checking oracle prices for staleness/manipulation");
        console.log("3. Analyzing Curve pools for imbalance exploitation");
        console.log("4. Testing flash loan attack vectors");
        console.log("5. Searching for protocol invariant violations");
        console.log("");

        console.log("KEY FINDINGS TO VERIFY:");
        console.log("- sUSDe cooldown mechanism - check if bypass possible");
        console.log("- apxETH share price vs underlying balance");
        console.log("- Cross-protocol interactions between vaults");
        console.log("");

        console.log("CONTINUING SEARCH...");
    }
}
