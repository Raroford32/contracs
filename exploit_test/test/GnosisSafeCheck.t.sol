// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IGnosisSafe {
    function getThreshold() external view returns (uint256);
    function getOwners() external view returns (address[] memory);
    function nonce() external view returns (uint256);
    function isOwner(address owner) external view returns (bool);
    function VERSION() external view returns (string memory);
}

contract GnosisSafeCheckTest is Test {
    address constant TARGET = 0xC82Abe4dFA94b9B5453d31274Fb7500459a0d12d;  // 9997 ETH
    
    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testIsGnosisSafe() public view {
        console.log("=== GNOSIS SAFE CHECK ===");
        console.log("Target:", TARGET);
        console.log("Balance:", TARGET.balance / 1e18, "ETH");
        
        IGnosisSafe safe = IGnosisSafe(TARGET);
        
        try safe.getThreshold() returns (uint256 threshold) {
            console.log("Threshold:", threshold);
        } catch {}
        
        try safe.nonce() returns (uint256 n) {
            console.log("Nonce:", n);
        } catch {}
        
        try safe.VERSION() returns (string memory v) {
            console.log("Version:", v);
        } catch {}
        
        try safe.getOwners() returns (address[] memory owners) {
            console.log("Owner count:", owners.length);
            for (uint i = 0; i < owners.length && i < 5; i++) {
                console.log("Owner", i, ":", owners[i]);
            }
        } catch {}
        
        // Check if attacker is owner
        try safe.isOwner(address(this)) returns (bool isOwner) {
            console.log("Attacker is owner:", isOwner);
        } catch {}
    }
}
