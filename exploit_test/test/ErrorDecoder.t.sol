// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract ErrorDecoder is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_DecodeErrors() public pure {
        console.log("=== DECODING ERRORS ===\n");

        console.log("Target errors:");
        console.log("  0xa0927dc3 - small amounts");
        console.log("  0xfb8f41b2 - large amounts\n");

        // Try IAU-related errors
        bytes4 err1 = bytes4(keccak256("InsufficientIAU()"));
        bytes4 err2 = bytes4(keccak256("InsufficientIAUBalance()"));
        bytes4 err3 = bytes4(keccak256("NotEnoughIAU()"));
        bytes4 err4 = bytes4(keccak256("IAUTransferFailed()"));
        bytes4 err5 = bytes4(keccak256("BurnFailed()"));

        console.log("InsufficientIAU():");
        console.logBytes4(err1);
        console.log("InsufficientIAUBalance():");
        console.logBytes4(err2);
        console.log("NotEnoughIAU():");
        console.logBytes4(err3);
        console.log("IAUTransferFailed():");
        console.logBytes4(err4);
        console.log("BurnFailed():");
        console.logBytes4(err5);

        // Try cap/limit errors
        bytes4 err6 = bytes4(keccak256("ExceedsRedemptionCap()"));
        bytes4 err7 = bytes4(keccak256("ExceedsRemainingCap()"));
        bytes4 err8 = bytes4(keccak256("CapReached()"));
        bytes4 err9 = bytes4(keccak256("RedemptionCapExceeded()"));
        bytes4 err10 = bytes4(keccak256("DailyCapExceeded()"));

        console.log("\nExceedsRedemptionCap():");
        console.logBytes4(err6);
        console.log("ExceedsRemainingCap():");
        console.logBytes4(err7);
        console.log("CapReached():");
        console.logBytes4(err8);
        console.log("RedemptionCapExceeded():");
        console.logBytes4(err9);
        console.log("DailyCapExceeded():");
        console.logBytes4(err10);

        // Try min amount errors
        bytes4 err11 = bytes4(keccak256("BelowMinRedemption()"));
        bytes4 err12 = bytes4(keccak256("AmountBelowMin()"));
        bytes4 err13 = bytes4(keccak256("MinRedemptionNotMet()"));
        bytes4 err14 = bytes4(keccak256("AmountTooSmall()"));

        console.log("\nBelowMinRedemption():");
        console.logBytes4(err11);
        console.log("AmountBelowMin():");
        console.logBytes4(err12);
        console.log("MinRedemptionNotMet():");
        console.logBytes4(err13);
        console.log("AmountTooSmall():");
        console.logBytes4(err14);

        // Try period/time errors
        bytes4 err15 = bytes4(keccak256("RedemptionNotStarted()"));
        bytes4 err16 = bytes4(keccak256("RedemptionEnded()"));
        bytes4 err17 = bytes4(keccak256("OutsideRedemptionPeriod()"));

        console.log("\nRedemptionNotStarted():");
        console.logBytes4(err15);
        console.log("RedemptionEnded():");
        console.logBytes4(err16);
        console.log("OutsideRedemptionPeriod():");
        console.logBytes4(err17);

        // More specific
        bytes4 err18 = bytes4(keccak256("ExceedsUserCap()"));
        bytes4 err19 = bytes4(keccak256("ExceedsAllowance()"));
        bytes4 err20 = bytes4(keccak256("ExceedsMaxRedemption()"));

        console.log("\nExceedsUserCap():");
        console.logBytes4(err18);
        console.log("ExceedsAllowance():");
        console.logBytes4(err19);
        console.log("ExceedsMaxRedemption():");
        console.logBytes4(err20);
    }

    function test_FindExactAmountThreshold() public {
        console.log("=== FINDING EXACT AMOUNT THRESHOLD ===\n");

        deal(IAU, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        // Binary search for the threshold
        uint256 low = 0;
        uint256 high = 300e18;
        bytes4 lastError;

        console.log("Binary searching for error threshold...");

        while (high - low > 1e18) {
            uint256 mid = (low + high) / 2;
            
            (bool success, bytes memory data) = REDEMPTION_0.call(
                abi.encodeWithSignature("redeem(uint96)", uint96(mid))
            );

            if (!success && data.length >= 4) {
                bytes4 err = bytes4(data);
                if (err == bytes4(0xa0927dc3)) {
                    low = mid;
                    lastError = err;
                } else {
                    high = mid;
                    lastError = err;
                }
            } else {
                high = mid;
            }
        }

        console.log("Threshold found around (IAU):"); console.log("  Low:", low / 1e18); console.log("  High:", high / 1e18);
        console.log("Low error (0xa0927dc3) up to:", low / 1e18);
        console.log("High error (0xfb8f41b2) from:", high / 1e18);

        vm.stopPrank();
    }

    function test_CheckRedemptionCaps() public view {
        console.log("=== CHECKING REDEMPTION CAPS ===\n");

        // Try various cap-related view functions
        bytes4[] memory selectors = new bytes4[](20);
        selectors[0] = bytes4(keccak256("cap()"));
        selectors[1] = bytes4(keccak256("redemptionCap()"));
        selectors[2] = bytes4(keccak256("dailyCap()"));
        selectors[3] = bytes4(keccak256("userCap()"));
        selectors[4] = bytes4(keccak256("maxPerUser()"));
        selectors[5] = bytes4(keccak256("maxPerTx()"));
        selectors[6] = bytes4(keccak256("minAmount()"));
        selectors[7] = bytes4(keccak256("minRedemption()"));
        selectors[8] = bytes4(keccak256("remainingCap()"));
        selectors[9] = bytes4(keccak256("availableCap()"));
        selectors[10] = bytes4(keccak256("totalCap()"));
        selectors[11] = bytes4(keccak256("globalCap()"));
        selectors[12] = bytes4(keccak256("epochCap()"));
        selectors[13] = bytes4(keccak256("currentEpochCap()"));
        selectors[14] = bytes4(keccak256("maxRedemption()"));
        selectors[15] = bytes4(keccak256("minRedemptionAmount()"));
        selectors[16] = bytes4(keccak256("maxRedemptionAmount()"));
        selectors[17] = bytes4(keccak256("capPerEpoch()"));
        selectors[18] = bytes4(keccak256("epochDuration()"));
        selectors[19] = bytes4(keccak256("currentEpoch()"));

        string[20] memory names = [
            "cap",
            "redemptionCap",
            "dailyCap",
            "userCap",
            "maxPerUser",
            "maxPerTx",
            "minAmount",
            "minRedemption",
            "remainingCap",
            "availableCap",
            "totalCap",
            "globalCap",
            "epochCap",
            "currentEpochCap",
            "maxRedemption",
            "minRedemptionAmount",
            "maxRedemptionAmount",
            "capPerEpoch",
            "epochDuration",
            "currentEpoch"
        ];

        console.log("Testing cap-related functions:");

        for (uint i = 0; i < selectors.length; i++) {
            (bool success, bytes memory data) = REDEMPTION_0.staticcall(
                abi.encodeWithSelector(selectors[i])
            );
            if (success && data.length == 32) {
                uint256 val = abi.decode(data, (uint256));
                if (val > 0) {
                    console.log("  ", names[i], ":", val);
                }
            }
        }
    }

    function test_AnalyzeEpochMechanism() public view {
        console.log("=== ANALYZING EPOCH MECHANISM ===\n");

        // The protocol might use epochs for redemption caps
        // 0x3a2ef9df returned 604800 = 7 days in seconds

        // Check storage slot 3 which had: 0x0000000000000000002710000000000000000000000000000000000000000000
        // 0x2710 = 10000 - this could be the conversion rate BPS (100%)

        bytes32 slot3 = vm.load(REDEMPTION_0, bytes32(uint256(3)));
        console.log("Slot 3 (raw):");
        console.logBytes32(slot3);

        // Decode slot 3
        uint256 slot3Val = uint256(slot3);
        console.log("\nSlot 3 decoded:");
        console.log("  Top 128 bits:", slot3Val >> 128);
        console.log("  Bottom 128 bits:", uint128(slot3Val));

        // Check slot 4 which had epoch-like data
        bytes32 slot4 = vm.load(REDEMPTION_0, bytes32(uint256(4)));
        console.log("\nSlot 4 (raw):");
        console.logBytes32(slot4);

        // Decode - looks like packed epoch data
        uint256 slot4Val = uint256(slot4);
        console.log("Slot 4 decoded:");
        console.log("  Bytes 0-3 (uint32):", uint32(slot4Val >> 224));  // = 5
        console.log("  Bytes 4-7 (uint32):", uint32(slot4Val >> 192));  // epoch count?
        
        // Middle bits might be timestamps or amounts
        console.log("  Middle 96 bits as ETH:", (slot4Val >> 96) & ((1 << 96) - 1));
        console.log("  Bottom 96 bits as ETH:", (slot4Val & ((1 << 96) - 1)) / 1e18);
    }

    function test_CheckIfInEpochWindow() public view {
        console.log("=== CHECKING EPOCH WINDOW ===\n");

        // The error might be because we're outside an epoch window
        
        // Check current time vs epoch boundaries
        console.log("Current block timestamp:", block.timestamp);
        console.log("Current block:", block.number);

        // Try to find epoch-related info
        (bool success, bytes memory data) = REDEMPTION_0.staticcall(
            abi.encodeWithSelector(bytes4(0x458f5815)) // returned 5
        );
        if (success) {
            console.log("0x458f5815 (epoch?):", abi.decode(data, (uint256)));
        }

        // 0x3a2ef9df = 604800 (epoch duration?)
        (success, data) = REDEMPTION_0.staticcall(
            abi.encodeWithSelector(bytes4(0x3a2ef9df))
        );
        if (success) {
            uint256 duration = abi.decode(data, (uint256));
            console.log("0x3a2ef9df (duration?):", duration); console.log("  In days:", duration / 86400);
        }
    }
}
