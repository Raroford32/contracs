// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract ExploitSelectors is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_MatchSuccessfulSelectors() public view {
        console.log("=== MATCHING SUCCESSFUL SELECTORS ===\n");

        // Successful selectors: 0x458f5815, 0x252c50f3, 0x06e29712, 0x1650cf97, 0x411557d1

        // Generate many function signatures
        string[50] memory sigs = [
            "finalizeRedeem(uint256)",
            "processRedeem(uint256)",
            "claimRedeem(uint256)",
            "cancelRedeem(uint256)",
            "completeRedeem(uint256)",
            "settleRedeem(uint256)",
            "executeRedeem(uint256)",
            "getRedemption(uint256)",
            "redemption(uint256)",
            "userRedeem(uint256)",
            "claim(uint256)",
            "withdraw(uint256)",
            "deposit(uint256)",
            "stake(uint256)",
            "unstake(uint256)",
            "burn(uint256)",
            "mint(uint256)",
            "createProxy(uint256)",
            "deployProxy(uint256)",
            "getProxy(uint256)",
            "setFee(uint256)",
            "setMinRedeem(uint256)",
            "setMaxRedeem(uint256)",
            "setCap(uint256)",
            "setRedemptionDelay(uint256)",
            "pendingRedeem(uint256)",
            "redeemPending(uint256)",
            "claimPending(uint256)",
            "finalizePending(uint256)",
            "process(uint256)",
            "finalize(uint256)",
            "execute(uint256)",
            "complete(uint256)",
            "settle(uint256)",
            "redemptionInfo(uint256)",
            "userInfo(uint256)",
            "queuedRedeem(uint256)",
            "pendingAmount(uint256)",
            "redeemAmount(uint256)",
            "minRedeemInUnderlying(uint256)",
            "maxRedeemInUnderlying(uint256)",
            "redeemDelay(uint256)",
            "epochRedemption(uint256)",
            "epochAmount(uint256)",
            "epochCap(uint256)",
            "currentEpoch(uint256)",
            "getEpoch(uint256)",
            "epoch(uint256)",
            "fee(uint256)",
            "feeRate(uint256)"
        ];

        bytes4[] memory targets = new bytes4[](5);
        targets[0] = bytes4(0x458f5815);
        targets[1] = bytes4(0x252c50f3);
        targets[2] = bytes4(0x06e29712);
        targets[3] = bytes4(0x1650cf97);
        targets[4] = bytes4(0x411557d1);

        for (uint i = 0; i < sigs.length; i++) {
            bytes4 sel = bytes4(keccak256(bytes(sigs[i])));
            for (uint j = 0; j < targets.length; j++) {
                if (sel == targets[j]) {
                    console.log("MATCH!");
                    console.log(sigs[i]);
                    console.logBytes4(sel);
                }
            }
        }
    }

    function test_InvestigateSuccessSelectors() public {
        console.log("=== INVESTIGATING SUCCESSFUL SELECTORS ===\n");

        vm.startPrank(attacker);
        deal(IAU, attacker, 100000e18);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // 0x458f5815
        console.log("Calling 0x458f5815 with different args:");
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x458f5815), 0)
        );
        console.log("  arg=0:", s1);
        if (s1 && d1.length > 0) {
            console.log("  Return data length:", d1.length);
            if (d1.length == 32) {
                console.log("  As uint256:", abi.decode(d1, (uint256)));
            }
        }

        (bool s1b, bytes memory d1b) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x458f5815), attacker)
        );
        console.log("  arg=attacker:", s1b);

        // 0x252c50f3
        console.log("\nCalling 0x252c50f3:");
        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x252c50f3), 0)
        );
        console.log("  arg=0:", s2);
        if (s2 && d2.length == 32) {
            console.log("  As uint256:", abi.decode(d2, (uint256)));
        }

        // 0x06e29712
        console.log("\nCalling 0x06e29712:");
        (bool s3, bytes memory d3) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x06e29712), 0)
        );
        console.log("  arg=0:", s3);
        if (s3 && d3.length == 32) {
            uint256 result = abi.decode(d3, (uint256));
            console.log("  As uint256:", result);
            if (result > 1e15 && result < 1e25) {
                console.log("  Looks like amount:", result / 1e18);
            }
        }

        // 0x1650cf97
        console.log("\nCalling 0x1650cf97:");
        (bool s4, bytes memory d4) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x1650cf97), 0)
        );
        console.log("  arg=0:", s4);
        if (s4 && d4.length == 32) {
            console.log("  As uint256:", abi.decode(d4, (uint256)));
        }

        // 0x411557d1
        console.log("\nCalling 0x411557d1:");
        (bool s5, bytes memory d5) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x411557d1), 0)
        );
        console.log("  arg=0:", s5);
        if (s5 && d5.length == 32) {
            uint256 result = abi.decode(d5, (uint256));
            console.log("  As uint256:", result);
            if (result > 1e15 && result < 1e25) {
                console.log("  Looks like amount:", result / 1e18);
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
    }

    function test_TryProcessOrFinalizeRedeem() public {
        console.log("=== TRYING PROCESS/FINALIZE REDEEM ===\n");

        // Maybe the selectors are for processing pending redemptions
        // Let's create a redemption first, then try to process it

        vm.startPrank(attacker);
        deal(IAU, attacker, 100000e18);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Try creating a redemption request first
        console.log("Trying to create redemption request:");

        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSignature("requestRedeem(uint256)", 1000e18)
        );
        console.log("requestRedeem(uint256):", s1);
        if (!s1 && d1.length >= 4) console.logBytes4(bytes4(d1));

        (bool s2, bytes memory d2) = REDEMPTION_0.call(
            abi.encodeWithSignature("requestRedeem(uint256)", 1000e18)
        );
        console.log("requestRedeem (R0):", s2);
        if (!s2 && d2.length >= 4) console.logBytes4(bytes4(d2));

        // Try redeem on R0 (different signature)
        (bool s3, bytes memory d3) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("redeem(uint96) R0:", s3);
        if (!s3 && d3.length >= 4) console.logBytes4(bytes4(d3));

        // Now try to finalize
        console.log("\nTrying to finalize:");

        (bool s4, bytes memory d4) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x458f5815), 0)
        );
        console.log("0x458f5815(0):", s4);

        (bool s5, bytes memory d5) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x411557d1), 0)
        );
        console.log("0x411557d1(0):", s5);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker wstETH:", attackerWstETH);
    }

    function test_BruteForceMoreSignatures() public view {
        console.log("=== BRUTE FORCE MORE SIGNATURES ===\n");

        bytes4[] memory targets = new bytes4[](5);
        targets[0] = bytes4(0x458f5815);
        targets[1] = bytes4(0x252c50f3);
        targets[2] = bytes4(0x06e29712);
        targets[3] = bytes4(0x1650cf97);
        targets[4] = bytes4(0x411557d1);

        // More signatures
        string[100] memory sigs = [
            "minRedeemInUnderlying()",
            "maxRedeemInUnderlying()",
            "redeemDelay()",
            "pendingRedemptions()",
            "totalRedeeming()",
            "totalPending()",
            "totalQueued()",
            "queueLength()",
            "minRedeem()",
            "maxRedeem()",
            "redeemFee()",
            "redemptionFee()",
            "withdrawalFee()",
            "performanceFee()",
            "managementFee()",
            "protocolFee()",
            "feeRecipient()",
            "underlying()",
            "asset()",
            "token()",
            "share()",
            "totalAssets()",
            "totalSupply()",
            "totalShares()",
            "pricePerShare()",
            "exchangeRate()",
            "getExchangeRate()",
            "index()",
            "getIndex()",
            "currentIndex()",
            "redemptionController()",
            "getRedemptionController()",
            "rc()",
            "getRC()",
            "vault()",
            "getVault()",
            "wstETH()",
            "getwstETH()",
            "iau()",
            "getIAU()",
            "tAsset()",
            "gettAsset()",
            "implementation()",
            "getImplementation()",
            "proxy()",
            "getProxy()",
            "userProxy()",
            "getUserProxy()",
            "createProxy()",
            "deployProxy()",
            "pendingRedemption(address)",
            "userPendingRedemption(address)",
            "redemptionOf(address)",
            "getRedemptionOf(address)",
            "balanceOf(address)",
            "sharesOf(address)",
            "pendingOf(address)",
            "queuedOf(address)",
            "claimableOf(address)",
            "getClaimable(address)",
            "earned(address)",
            "getEarned(address)",
            "rewards(address)",
            "getRewards(address)",
            "proxyOf(address)",
            "getProxyOf(address)",
            "proxyFor(address)",
            "getProxyFor(address)",
            "proxies(address)",
            "getProxies(address)",
            "userProxies(address)",
            "getUserProxies(address)",
            "redemptions(uint256)",
            "getRedemptions(uint256)",
            "redemptionRequests(uint256)",
            "getRedemptionRequests(uint256)",
            "queue(uint256)",
            "getQueue(uint256)",
            "pending(uint256)",
            "getPending(uint256)",
            "queued(uint256)",
            "getQueued(uint256)",
            "request(uint256)",
            "getRequest(uint256)",
            "redemptionInfo(address,uint256)",
            "getRedemptionInfo(address,uint256)",
            "userRedemption(address,uint256)",
            "getUserRedemption(address,uint256)",
            "pendingRedemption(address,uint256)",
            "getPendingRedemption(address,uint256)",
            "queuedRedemption(address,uint256)",
            "getQueuedRedemption(address,uint256)",
            "claimable(address,uint256)",
            "getClaimable(address,uint256)",
            "available(address,uint256)",
            "getAvailable(address,uint256)",
            "amount(address,uint256)",
            "getAmount(address,uint256)",
            "value(address,uint256)",
            "getValue(address,uint256)"
        ];

        for (uint i = 0; i < sigs.length; i++) {
            bytes4 sel = bytes4(keccak256(bytes(sigs[i])));
            for (uint j = 0; j < targets.length; j++) {
                if (sel == targets[j]) {
                    console.log("MATCH!");
                    console.log(sigs[i]);
                    console.logBytes4(sel);
                }
            }
        }
    }
}
