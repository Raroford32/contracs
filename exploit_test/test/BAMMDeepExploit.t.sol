// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

// BAMM interface - calling functions directly
interface IBAMM {
    // Try multiple potential function signatures
    function swap(uint256 thusdAmount, uint256 minCollateralReturn, address dest) external returns (uint256);
    function deposit(uint256 thusdAmount) external;
    function withdraw(uint256 numShares) external;
    function getSwapCollateralAmount(uint256 thusdQty) external view returns (uint256 collateralAmount, uint256 feeTHUSDAmount);
    function getSwapTHUSDAmount(uint256 collateralQty) external view returns (uint256);
    function fetchPrice() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function balanceOf(address) external view returns (uint256);
    function SP() external view returns (address);
    function THUSD() external view returns (address);
    function collateral() external view returns (address);
    function A() external view returns (uint256);
}

interface IPriceFormula {
    function getSumFixedPoint(uint256 x, uint256 y, uint256 A) external pure returns (uint256);
    function getReturn(uint256 xQty, uint256 xBalance, uint256 yBalance, uint256 A) external pure returns (uint256);
}

interface IStabilityPool {
    function getDepositorCollateralGain(address) external view returns (uint256);
    function getCompoundedTHUSDDeposit(address) external view returns (uint256);
    function provideToSP(uint256) external;
    function withdrawFromSP(uint256) external;
    function P() external view returns (uint256);
}

contract BAMMDeepExploit is Test {
    address constant BAMM = 0x097f1ee62E63aCFC3Bf64c1a61d96B3771dd06cB;
    address constant THUSD = 0xCFC5bD99915aAa815401C5a41A927aB7a38d29cf;

    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function testBAMMFullAnalysis() public {
        console.log("====================================================");
        console.log("BAMM DEEP EXPLOIT ANALYSIS - 50M THUSD AT STAKE");
        console.log("====================================================");

        // Check THUSD balance in BAMM
        uint256 thusdBalance = IERC20(THUSD).balanceOf(BAMM);
        console.log("\nTHUSD in BAMM:", thusdBalance);
        console.log("THUSD in BAMM (human):", thusdBalance / 1e18, "THUSD");

        // Try to read BAMM state via raw calls
        console.log("\n--- Reading BAMM State via Raw Calls ---");

        // Try SP()
        (bool success, bytes memory data) = BAMM.staticcall(abi.encodeWithSignature("SP()"));
        if (success && data.length >= 32) {
            address sp = abi.decode(data, (address));
            console.log("Stability Pool:", sp);

            // Get Stability Pool state
            if (sp != address(0)) {
                uint256 spThusd = IERC20(THUSD).balanceOf(sp);
                console.log("THUSD in SP:", spThusd / 1e18);

                // Check P factor
                (bool pSuccess, bytes memory pData) = sp.staticcall(abi.encodeWithSignature("P()"));
                if (pSuccess && pData.length >= 32) {
                    uint256 P = abi.decode(pData, (uint256));
                    console.log("SP P factor:", P);
                }
            }
        }

        // Try collateral()
        (success, data) = BAMM.staticcall(abi.encodeWithSignature("collateral()"));
        if (success && data.length >= 32) {
            address coll = abi.decode(data, (address));
            console.log("Collateral Token:", coll);

            if (coll != address(0)) {
                uint256 collBalance = IERC20(coll).balanceOf(BAMM);
                console.log("Collateral in BAMM:", collBalance);
            }
        }

        // Try A() - amplification factor
        (success, data) = BAMM.staticcall(abi.encodeWithSignature("A()"));
        if (success && data.length >= 32) {
            uint256 A = abi.decode(data, (uint256));
            console.log("Amplification A:", A);
        }

        // Try fetchPrice()
        (success, data) = BAMM.staticcall(abi.encodeWithSignature("fetchPrice()"));
        if (success && data.length >= 32) {
            uint256 price = abi.decode(data, (uint256));
            console.log("Current Price:", price);
        }
    }

    function testBAMMSwapEdgeCases() public {
        console.log("====================================================");
        console.log("BAMM SWAP EDGE CASE TESTING");
        console.log("====================================================");

        // Try getSwapCollateralAmount with various inputs
        console.log("\n--- Testing getSwapCollateralAmount ---");

        // Test 1: Normal amount
        (bool success, bytes memory data) = BAMM.staticcall(
            abi.encodeWithSignature("getSwapCollateralAmount(uint256)", 1e18)
        );
        if (success && data.length >= 64) {
            (uint256 collOut, uint256 fee) = abi.decode(data, (uint256, uint256));
            console.log("1 THUSD -> Collateral:", collOut);
            console.log("Fee:", fee);
        } else {
            console.log("Normal swap call failed");
        }

        // Test 2: Very small amount (1 wei) - rounding exploit?
        (success, data) = BAMM.staticcall(
            abi.encodeWithSignature("getSwapCollateralAmount(uint256)", 1)
        );
        if (success && data.length >= 64) {
            (uint256 collOut, uint256 fee) = abi.decode(data, (uint256, uint256));
            console.log("\n1 WEI THUSD -> Collateral:", collOut);
            console.log("Fee:", fee);
            if (collOut > 0) {
                console.log("*** POTENTIAL ROUNDING EXPLOIT! ***");
            }
        }

        // Test 3: Huge amount
        uint256 hugeThusd = 50_000_000e18; // All THUSD
        (success, data) = BAMM.staticcall(
            abi.encodeWithSignature("getSwapCollateralAmount(uint256)", hugeThusd)
        );
        if (success && data.length >= 64) {
            (uint256 collOut, uint256 fee) = abi.decode(data, (uint256, uint256));
            console.log("\n50M THUSD -> Collateral:", collOut);
            console.log("Fee:", fee);
        } else {
            console.log("Huge swap failed (expected - would drain pool)");
        }

        // Test 4: Amount that might cause iteration issues
        uint256 weirdAmount = type(uint128).max;
        (success, data) = BAMM.staticcall(
            abi.encodeWithSignature("getSwapCollateralAmount(uint256)", weirdAmount)
        );
        if (success && data.length >= 64) {
            (uint256 collOut, uint256 fee) = abi.decode(data, (uint256, uint256));
            console.log("\nMAX_UINT128 THUSD -> Collateral:", collOut);
            console.log("Fee:", fee);
        } else {
            console.log("\nMAX_UINT128 swap reverted (expected)");
        }
    }

    function testBAMMDepositExploit() public {
        console.log("====================================================");
        console.log("BAMM DEPOSIT EXPLOIT TESTING");
        console.log("====================================================");

        // Get attacker some THUSD (simulate by pranking a whale)
        address thusdWhale = 0x66017D22b0f8556afDd19FC67041899Eb65a21bb; // A known THUSD holder

        uint256 whaleBalance = IERC20(THUSD).balanceOf(thusdWhale);
        console.log("Whale THUSD balance:", whaleBalance / 1e18);

        if (whaleBalance > 0) {
            vm.startPrank(thusdWhale);

            // Try to deposit
            IERC20(THUSD).approve(BAMM, type(uint256).max);

            // Check BAMM share state before
            (bool success, bytes memory data) = BAMM.staticcall(
                abi.encodeWithSignature("totalSupply()")
            );
            uint256 totalSharesBefore = 0;
            if (success && data.length >= 32) {
                totalSharesBefore = abi.decode(data, (uint256));
                console.log("\nTotal Shares Before:", totalSharesBefore);
            }

            // Try deposit
            uint256 depositAmount = 1e18; // 1 THUSD
            try IBAMM(BAMM).deposit(depositAmount) {
                console.log("Deposit succeeded!");

                // Check shares received
                (success, data) = BAMM.staticcall(
                    abi.encodeWithSignature("balanceOf(address)", thusdWhale)
                );
                if (success && data.length >= 32) {
                    uint256 shares = abi.decode(data, (uint256));
                    console.log("Shares received:", shares);
                    console.log("Share ratio:", shares * 1e18 / depositAmount);
                }
            } catch Error(string memory reason) {
                console.log("Deposit failed:", reason);
            } catch {
                console.log("Deposit failed (unknown error)");
            }

            vm.stopPrank();
        }
    }

    function testBAMMPriceFormulaExploit() public view {
        console.log("====================================================");
        console.log("BAMM PRICE FORMULA EXPLOIT ANALYSIS");
        console.log("====================================================");

        // The price formula uses iterative calculation
        // Potential exploits:
        // 1. Input values that cause non-convergence (255 iterations max)
        // 2. Values that cause Newton's method to diverge
        // 3. Precision loss in intermediate calculations

        console.log("\n--- Potential Attack Vectors ---");
        console.log("1. Non-convergence attack:");
        console.log("   - Input extreme x/y ratios to prevent convergence");
        console.log("   - Could cause gas exhaustion or wrong prices");

        console.log("\n2. Newton's method divergence:");
        console.log("   - Specific initial values cause oscillation");
        console.log("   - getReturn() could return wrong values");

        console.log("\n3. Share ratio attack:");
        console.log("   - YieldBoxRebase has 1e8 minimum shares");
        console.log("   - First depositor could still inflate if:");
        console.log("     * Deposit minimum -> get 1e8 shares");
        console.log("     * Donate directly -> inflate share value");
        console.log("     * Others deposit -> get 0 shares due to rounding");

        console.log("\n4. Stability Pool interaction:");
        console.log("   - BAMM uses SP for collateral");
        console.log("   - SP P factor affects BAMM calculations");
        console.log("   - If P changes during swap, could profit");
    }

    function testFindBAMMVulnerability() public {
        console.log("====================================================");
        console.log("SEARCHING FOR BAMM VULNERABILITY");
        console.log("====================================================");

        // The BAMM uses B.Protocol mechanics
        // Key interaction: BAMM <-> Stability Pool <-> Collateral

        uint256 thusdInBamm = IERC20(THUSD).balanceOf(BAMM);
        console.log("\n1. THUSD in BAMM:", thusdInBamm / 1e18);

        // Check what the BAMM actually owns in SP
        (bool success, bytes memory data) = BAMM.staticcall(abi.encodeWithSignature("SP()"));
        if (success && data.length >= 32) {
            address sp = abi.decode(data, (address));
            console.log("2. Stability Pool:", sp);

            // Check BAMM's deposit in SP
            (success, data) = sp.staticcall(
                abi.encodeWithSignature("getCompoundedTHUSDDeposit(address)", BAMM)
            );
            if (success && data.length >= 32) {
                uint256 bammDeposit = abi.decode(data, (uint256));
                console.log("3. BAMM deposit in SP:", bammDeposit / 1e18);
            }

            // Check BAMM's collateral gain
            (success, data) = sp.staticcall(
                abi.encodeWithSignature("getDepositorCollateralGain(address)", BAMM)
            );
            if (success && data.length >= 32) {
                uint256 collGain = abi.decode(data, (uint256));
                console.log("4. BAMM collateral gain:", collGain / 1e18);
            }
        }

        // The key insight: BAMM might not properly account for
        // the difference between THUSD balance and SP deposit
        // If thusdInBamm != bammDeposit in SP, there's an accounting issue

        console.log("\n--- Potential Exploit Paths ---");
        console.log("A. If THUSD in contract != THUSD in SP:");
        console.log("   - Attacker could arbitrage the difference");
        console.log("B. If collateral gain not claimed:");
        console.log("   - Attacker could trigger claim + steal");
        console.log("C. If swap uses wrong price during liquidations:");
        console.log("   - Attacker could front-run liquidations");
    }
}
