// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
}

contract BytecodeAnalysis is Test {
    address constant TRANSFER_ACTION = 0xc780112305ED959CEEeb0DE692E2407E4145Fc3A;
    address constant STRATEGY_0 = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant aWstETH = 0x0B925eD163218f6662a35e0f0371Ac234f9E9371;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_ExtractEmbeddedAddresses() public view {
        console.log("=== EXTRACTING EMBEDDED ADDRESSES ===\n");

        bytes memory code = TRANSFER_ACTION.code;
        console.log("Code size:", code.length);

        // Known addresses to look for
        address[] memory knownAddrs = new address[](10);
        knownAddrs[0] = wstETH;
        knownAddrs[1] = aWstETH;
        knownAddrs[2] = VAULT;
        knownAddrs[3] = STRATEGY_0;
        knownAddrs[4] = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84; // stETH
        knownAddrs[5] = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2; // Aave Pool
        knownAddrs[6] = 0x2F111C1Fa4dE9bC6B26c4D0F232c605c81e6EA27; // DeFiSaver Registry
        knownAddrs[7] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // WETH
        knownAddrs[8] = 0x1111111254EEB25477B68fb85Ed929f73A960582; // 1inch
        knownAddrs[9] = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510; // RedemptionController

        string[10] memory names = [
            "wstETH",
            "aWstETH",
            "Vault",
            "Strategy0",
            "stETH",
            "AavePool",
            "DeFiSaverRegistry",
            "WETH",
            "1inch",
            "RedemptionController"
        ];

        console.log("Searching for known addresses:\n");
        for (uint a = 0; a < knownAddrs.length; a++) {
            for (uint i = 0; i + 19 < code.length; i++) {
                bytes20 addr;
                assembly {
                    addr := mload(add(add(code, 32), i))
                }
                if (address(addr) == knownAddrs[a]) {
                    console.log("Found", names[a], "at offset:", i);
                }
            }
        }

        // Extract ALL unique addresses from bytecode
        console.log("\nAll addresses found in bytecode:");
        for (uint i = 0; i + 19 < code.length; i++) {
            bytes20 addrBytes;
            assembly {
                addrBytes := mload(add(add(code, 32), i))
            }
            address addr = address(addrBytes);

            // Filter to likely addresses (has code or is known token/protocol)
            if (addr != address(0) && addr.code.length > 0) {
                // Check if it's a likely embedded constant (preceded by PUSH20)
                if (i > 0 && uint8(code[i-1]) == 0x73) { // PUSH20 opcode
                    console.log("  Address at", i, ":", addr);
                    console.log("    Code size:", addr.code.length);
                }
            }
        }
    }

    function test_AnalyzeFunctionSignatures() public view {
        console.log("=== ANALYZING FUNCTION SIGNATURES ===\n");

        bytes memory code = TRANSFER_ACTION.code;

        // Common function selectors to look for
        bytes4[] memory selectors = new bytes4[](20);
        selectors[0] = bytes4(keccak256("transfer(address,uint256)"));
        selectors[1] = bytes4(keccak256("transferFrom(address,address,uint256)"));
        selectors[2] = bytes4(keccak256("approve(address,uint256)"));
        selectors[3] = bytes4(keccak256("balanceOf(address)"));
        selectors[4] = bytes4(keccak256("withdraw(uint256)"));
        selectors[5] = bytes4(keccak256("withdraw(address,uint256)"));
        selectors[6] = bytes4(keccak256("deposit(uint256)"));
        selectors[7] = bytes4(keccak256("executeAction(bytes,uint8[],bytes32[])"));
        selectors[8] = bytes4(keccak256("executeActionDirect(bytes)"));
        selectors[9] = bytes4(keccak256("vault()"));
        selectors[10] = bytes4(keccak256("token()"));
        selectors[11] = bytes4(keccak256("unwrap(uint256)"));
        selectors[12] = bytes4(keccak256("wrap(uint256)"));
        selectors[13] = bytes4(keccak256("safeTransfer(address,address,uint256)"));
        selectors[14] = bytes4(keccak256("safeTransferFrom(address,address,address,uint256)"));
        selectors[15] = bytes4(keccak256("pull(address,uint256)"));
        selectors[16] = bytes4(keccak256("push(address,uint256)"));
        selectors[17] = bytes4(keccak256("send(address,uint256)"));
        selectors[18] = bytes4(keccak256("redeem(uint256)"));
        selectors[19] = bytes4(keccak256("_executeAction(bytes,uint8[],bytes32[])"));

        string[20] memory names = [
            "transfer",
            "transferFrom",
            "approve",
            "balanceOf",
            "withdraw(uint256)",
            "withdraw(address,uint256)",
            "deposit",
            "executeAction",
            "executeActionDirect",
            "vault",
            "token",
            "unwrap",
            "wrap",
            "safeTransfer",
            "safeTransferFrom",
            "pull",
            "push",
            "send",
            "redeem",
            "_executeAction"
        ];

        console.log("Searching for function selectors:\n");
        for (uint s = 0; s < selectors.length; s++) {
            for (uint i = 0; i + 3 < code.length; i++) {
                bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
                if (sel == selectors[s]) {
                    console.log("Found", names[s], "at offset:", i);
                    console.logBytes4(selectors[s]);
                }
            }
        }
    }

    function test_SimulateAsStrategy() public {
        console.log("=== SIMULATING AS STRATEGY ===\n");

        // The real attack would need to come from Strategy via delegatecall
        // Let's simulate what happens if Strategy calls this action

        // First, give Strategy some wstETH to transfer
        deal(wstETH, STRATEGY_0, 10e18);
        console.log("Strategy wstETH balance:", IERC20(wstETH).balanceOf(STRATEGY_0) / 1e18);

        uint256 attackerBefore = IERC20(wstETH).balanceOf(attacker);
        console.log("Attacker wstETH before:", attackerBefore);

        // Prank as Strategy and try to delegatecall the action
        vm.startPrank(STRATEGY_0);

        // Try various param structures
        bytes[] memory paramStructs = new bytes[](5);

        // Structure 1: (address token, address to, uint256 amount)
        paramStructs[0] = abi.encode(wstETH, attacker, 1e18);

        // Structure 2: (address to, uint256 amount) - token might be hardcoded
        paramStructs[1] = abi.encode(attacker, 1e18);

        // Structure 3: (uint256 amount, address to)
        paramStructs[2] = abi.encode(1e18, attacker);

        // Structure 4: (address token, uint256 amount, address to)
        paramStructs[3] = abi.encode(wstETH, 1e18, attacker);

        // Structure 5: Just the recipient if amount is from returnValue
        paramStructs[4] = abi.encode(attacker);

        for (uint i = 0; i < paramStructs.length; i++) {
            console.log("\nTrying structure", i);

            (bool success,) = TRANSFER_ACTION.delegatecall(
                abi.encodeWithSignature(
                    "executeAction(bytes,uint8[],bytes32[])",
                    paramStructs[i],
                    new uint8[](0),
                    new bytes32[](0)
                )
            );

            if (success) {
                console.log("  SUCCESS!");
                uint256 attackerAfter = IERC20(wstETH).balanceOf(attacker);
                if (attackerAfter > attackerBefore) {
                    console.log("  CRITICAL: Attacker received tokens!");
                    console.log("  Amount:", (attackerAfter - attackerBefore) / 1e18);
                }
            }
        }

        vm.stopPrank();

        uint256 attackerFinal = IERC20(wstETH).balanceOf(attacker);
        console.log("\nFinal attacker wstETH:", attackerFinal);
    }

    function test_DecompileBytecode() public view {
        console.log("=== DECOMPILING BYTECODE PATTERNS ===\n");

        bytes memory code = TRANSFER_ACTION.code;

        // Look for the dispatch table (JUMPI patterns after selector comparison)
        console.log("Looking for function dispatch table...\n");

        // Find all PUSH4 followed by EQ (selector comparison pattern)
        for (uint i = 0; i + 5 < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 selector = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));

                // Check if followed by EQ (0x14) within next few bytes
                for (uint j = i + 5; j < i + 10 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x14) { // EQ
                        console.log("Found selector at offset", i);
                        console.logBytes4(selector);
                        break;
                    }
                }
            }
        }

        // Count specific opcodes for behavior analysis
        uint256 sstore = 0;
        uint256 sload = 0;
        uint256 call = 0;
        uint256 delegatecall = 0;
        uint256 staticcall = 0;
        uint256 calldataload = 0;
        uint256 calldatacopy = 0;

        for (uint i = 0; i < code.length; i++) {
            uint8 op = uint8(code[i]);
            if (op == 0x55) sstore++;
            if (op == 0x54) sload++;
            if (op == 0xf1) call++;
            if (op == 0xf4) delegatecall++;
            if (op == 0xfa) staticcall++;
            if (op == 0x35) calldataload++;
            if (op == 0x37) calldatacopy++;
        }

        console.log("\nOpcode analysis:");
        console.log("  SSTORE:", sstore);
        console.log("  SLOAD:", sload);
        console.log("  CALL:", call);
        console.log("  DELEGATECALL:", delegatecall);
        console.log("  STATICCALL:", staticcall);
        console.log("  CALLDATALOAD:", calldataload);
        console.log("  CALLDATACOPY:", calldatacopy);
    }
}
