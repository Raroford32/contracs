// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// Exact copy of PriceFormula from BAMM
contract PriceFormula {
    function getSumFixedPoint(uint256 x, uint256 y, uint256 A) public pure returns(uint) {
        if(x == 0 && y == 0) return 0;

        uint256 sum = x + y;

        for(uint256 i = 0 ; i < 255 ; i++) {
            uint256 dP = sum;
            dP = dP * sum / ((x * 2) + 1);
            dP = dP * sum / ((y * 2) + 1);

            uint256 prevSum = sum;

            uint256 n = (A * 2 * (x + y) + (dP * 2)) * sum;
            uint256 d = (A * 2 - 1) * sum;
            sum = n / (d + dP * 3);

            if(sum <= prevSum + 1 && prevSum <= sum + 1) break;
        }

        return sum;
    }

    function getReturn(uint256 xQty, uint256 xBalance, uint256 yBalance, uint256 A) public pure returns(uint256) {
        uint256 sum = getSumFixedPoint(xBalance, yBalance, A);

        uint256 c = sum * sum / ((xQty + xBalance) * 2);
        c = c * sum / (A * 4);
        uint256 b = (xQty + xBalance) + (sum / (A * 2));
        uint256 yPrev = 0;
        uint256 y = sum;

        for(uint256 i = 0 ; i < 255 ; i++) {
            yPrev = y;
            uint256 n = y * y + c;
            uint256 d = y * 2 + b - sum;
            y = n / d;

            if(y <= yPrev + 1 && yPrev <= y + 1) break;
        }

        return yBalance - y - 1;
    }
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

contract BAMMPrecisionProfit is Test {
    PriceFormula formula;
    address constant THUSD = 0xCFC5bD99915aAa815401C5a41A927aB7a38d29cf;

    uint256 constant PRECISION = 1e18;
    uint256 constant A = 20; // BAMM's A value

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        formula = new PriceFormula();
    }

    function testSimulateBAMMSwapProfitability() public view {
        console.log("====================================================");
        console.log("SIMULATING BAMM SWAP PROFITABILITY");
        console.log("====================================================");

        // Simulate BAMM state based on actual values
        // BAMM has ~50M THUSD
        uint256 thusdBalance = 50_000_000e18;

        // Need to estimate collateral value
        // If BAMM accumulated collateral from liquidations...
        // Let's simulate different scenarios

        console.log("\n--- Scenario 1: Equal USD value (THUSD = Collateral USD) ---");
        _testScenario(thusdBalance, thusdBalance); // yBalance = thusd + 2*thusd = 3*thusd

        console.log("\n--- Scenario 2: 2x Collateral USD value ---");
        _testScenario(thusdBalance, thusdBalance * 2);

        console.log("\n--- Scenario 3: 10x Collateral USD value (post-liquidation) ---");
        _testScenario(thusdBalance, thusdBalance * 10);

        console.log("\n--- Scenario 4: Small collateral (0.1x) ---");
        _testScenario(thusdBalance, thusdBalance / 10);

        console.log("\n--- Scenario 5: Tiny collateral (0.01x) ---");
        _testScenario(thusdBalance, thusdBalance / 100);
    }

    function _testScenario(uint256 thusdBalance, uint256 collateralUsdValue) internal view {
        uint256 yBalance = thusdBalance + (collateralUsdValue * 2);

        console.log("THUSD Balance:", thusdBalance / 1e18);
        console.log("Collateral USD Value:", collateralUsdValue / 1e18);
        console.log("Virtual Y Balance:", yBalance / 1e18);

        // Test swap of 1 THUSD
        uint256 swapAmount = 1e18;
        uint256 usdReturn = formula.getReturn(swapAmount, thusdBalance, yBalance, A);

        console.log("Swap 1 THUSD -> USD Return:", usdReturn / 1e18);

        // Calculate profit/loss
        if (usdReturn > swapAmount) {
            uint256 profit = usdReturn - swapAmount;
            console.log("*** PROFIT:", profit * 100 / swapAmount, "% ***");
        } else {
            uint256 loss = swapAmount - usdReturn;
            console.log("Loss:", loss * 100 / swapAmount, "%");
        }
    }

    function testFindProfitableConfiguration() public view {
        console.log("====================================================");
        console.log("FINDING PROFITABLE CONFIGURATIONS");
        console.log("====================================================");

        uint256 thusdBalance = 50_000_000e18;

        console.log("\nSearching for ratio where profit > 0...");

        // Try different collateral ratios
        for (uint256 ratio = 1; ratio <= 20; ratio++) {
            uint256 collateralUsdValue = thusdBalance * ratio;
            uint256 yBalance = thusdBalance + (collateralUsdValue * 2);

            uint256 swapAmount = 1e18;
            uint256 usdReturn = formula.getReturn(swapAmount, thusdBalance, yBalance, A);

            int256 profitBps = int256(usdReturn * 10000 / swapAmount) - 10000;

            if (profitBps > 0) {
                console.log("Ratio:", ratio);
                console.log("Profit bps:", uint256(profitBps));
            }
        }
    }

    function testExactBAMMProfitExtraction() public view {
        console.log("====================================================");
        console.log("EXACT BAMM PROFIT EXTRACTION ANALYSIS");
        console.log("====================================================");

        // The key insight:
        // BAMM uses virtual y = thusd + 2*collateral_usd
        // When collateral_usd is high (post-liquidation), y >> x
        // The curve favors swapping x for y when y > x

        // If pool has 50M THUSD and collateral worth $100M:
        // xBalance = 50M, yBalance = 50M + 200M = 250M

        uint256 thusdBalance = 50_000_000e18;
        uint256 collateralUsdValue = 100_000_000e18;
        uint256 yBalance = thusdBalance + (collateralUsdValue * 2);

        console.log("Pool state:");
        console.log("- THUSD:", thusdBalance / 1e18);
        console.log("- Collateral USD:", collateralUsdValue / 1e18);
        console.log("- Virtual Y:", yBalance / 1e18);
        console.log("- Ratio y/x:", yBalance * 100 / thusdBalance / 100);

        // Test various swap amounts
        uint256[] memory amounts = new uint256[](6);
        amounts[0] = 1e18;        // 1 THUSD
        amounts[1] = 100e18;      // 100 THUSD
        amounts[2] = 1000e18;     // 1K THUSD
        amounts[3] = 10000e18;    // 10K THUSD
        amounts[4] = 100000e18;   // 100K THUSD
        amounts[5] = 1000000e18;  // 1M THUSD

        console.log("\nSwap analysis:");
        for (uint i = 0; i < amounts.length; i++) {
            uint256 swapAmount = amounts[i];
            uint256 usdReturn = formula.getReturn(swapAmount, thusdBalance, yBalance, A);

            console.log("\nSwap:", swapAmount / 1e18, "THUSD");
            console.log("Return:", usdReturn / 1e18, "USD");

            if (usdReturn > swapAmount) {
                uint256 profitPercent = (usdReturn - swapAmount) * 100 / swapAmount;
                console.log("PROFIT:", profitPercent, "%");
            }
        }
    }

    function testRealAttackScenario() public view {
        console.log("====================================================");
        console.log("REAL ATTACK SCENARIO SIMULATION");
        console.log("====================================================");

        // Attack premise:
        // 1. BAMM accumulates collateral from liquidations
        // 2. Virtual y becomes much larger than x
        // 3. Attacker swaps THUSD for collateral at favorable rate
        // 4. Profit = (collateral_value - thusd_input)

        uint256 thusdBalance = 50_000_000e18;

        // Simulate post-liquidation state
        // If ETH drops 50%, borrowers get liquidated, BAMM gains ETH
        // Let's say BAMM gained 25,000 ETH at $3000 = $75M collateral
        uint256 ethPrice = 3000e18;
        uint256 ethGained = 25000e18; // 25,000 ETH
        uint256 collateralUsdValue = ethGained * ethPrice / PRECISION;

        uint256 yBalance = thusdBalance + (collateralUsdValue * 2);

        console.log("Post-liquidation state:");
        console.log("- THUSD in pool:", thusdBalance / 1e18);
        console.log("- ETH gained:", ethGained / 1e18);
        console.log("- ETH price:", ethPrice / 1e18);
        console.log("- Collateral USD:", collateralUsdValue / 1e18);
        console.log("- Virtual Y:", yBalance / 1e18);

        // Attack: Swap 1M THUSD
        uint256 attackAmount = 1_000_000e18;
        uint256 usdReturn = formula.getReturn(attackAmount, thusdBalance, yBalance, A);

        console.log("\nATTACK:");
        console.log("- Input:", attackAmount / 1e18, "THUSD");
        console.log("- USD Return:", usdReturn / 1e18);

        // Convert USD return to ETH
        uint256 ethReturn = usdReturn * PRECISION / ethPrice;
        console.log("- ETH Return:", ethReturn / 1e18);
        console.log("- ETH value at current price:", ethReturn * ethPrice / 1e36);

        if (usdReturn > attackAmount) {
            uint256 profit = usdReturn - attackAmount;
            console.log("\n*** PROFIT:", profit / 1e18, "USD ***");
            console.log("*** ROI:", profit * 100 / attackAmount, "% ***");
        }
    }

    function testMaximumExtractableValue() public view {
        console.log("====================================================");
        console.log("MAXIMUM EXTRACTABLE VALUE ANALYSIS");
        console.log("====================================================");

        // What's the maximum an attacker can extract?

        uint256 thusdBalance = 50_000_000e18;
        uint256 collateralUsdValue = 75_000_000e18; // Realistic post-liquidation

        uint256 yBalance = thusdBalance + (collateralUsdValue * 2);

        console.log("Pool state:");
        console.log("- THUSD:", thusdBalance / 1e18);
        console.log("- Collateral USD:", collateralUsdValue / 1e18);

        // Try swapping increasing amounts
        uint256 totalProfit = 0;
        uint256 swapAmount = 10_000_000e18; // 10M THUSD at a time

        for (uint i = 0; i < 5; i++) {
            uint256 currentThusd = thusdBalance + (i * swapAmount);
            uint256 currentY = currentThusd + (collateralUsdValue * 2);

            uint256 usdReturn = formula.getReturn(swapAmount, currentThusd, currentY, A);

            console.log("\nRound", i + 1, ":");
            console.log("- Swap:", swapAmount / 1e18, "THUSD");
            console.log("- Return:", usdReturn / 1e18, "USD");

            if (usdReturn > swapAmount) {
                totalProfit += usdReturn - swapAmount;
            }
        }

        console.log("\n=================");
        console.log("Total Profit:", totalProfit / 1e18, "USD");
    }
}
