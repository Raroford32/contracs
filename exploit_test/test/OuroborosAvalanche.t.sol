// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// ============================================================================
// OUROBOROS AVALANCHE
// The ultimate math-breaker stress test for Balancer V2 Vault
// Single transaction, repeated cycles through ALL accounting paths
// ============================================================================

interface IAsset {}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint256) external;
}

interface IVault {
    enum SwapKind { GIVEN_IN, GIVEN_OUT }
    enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }
    enum UserBalanceOpKind { DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL }

    struct BatchSwapStep {
        bytes32 poolId;
        uint256 assetInIndex;
        uint256 assetOutIndex;
        uint256 amount;
        bytes userData;
    }

    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address payable recipient;
        bool toInternalBalance;
    }

    struct UserBalanceOp {
        UserBalanceOpKind kind;
        IAsset asset;
        uint256 amount;
        address sender;
        address payable recipient;
    }

    struct JoinPoolRequest {
        IAsset[] assets;
        uint256[] maxAmountsIn;
        bytes userData;
        bool fromInternalBalance;
    }

    struct ExitPoolRequest {
        IAsset[] assets;
        uint256[] minAmountsOut;
        bytes userData;
        bool toInternalBalance;
    }

    function batchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds, int256[] memory limits, uint256 deadline) external payable returns (int256[] memory);
    function queryBatchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds) external returns (int256[] memory);
    function getPoolTokens(bytes32 poolId) external view returns (IERC20[] memory tokens, uint256[] memory balances, uint256 lastChangeBlock);
    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);
    function getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);
    function manageUserBalance(UserBalanceOp[] memory ops) external payable;
    function joinPool(bytes32 poolId, address sender, address recipient, JoinPoolRequest memory request) external payable;
    function exitPool(bytes32 poolId, address sender, address payable recipient, ExitPoolRequest memory request) external;
    function getPoolTokenInfo(bytes32 poolId, IERC20 token) external view returns (uint256 cash, uint256 managed, uint256 lastChangeBlock, address assetManager);
}

contract OuroborosAvalanche is Test {
    IVault constant VAULT = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    IWETH constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20 constant BAL = IERC20(0xba100000625a3754423978a60c9317c58a424e3D);

    // 80/20 BAL-WETH pool (TWO_TOKEN specialization)
    bytes32 constant BAL_WETH_POOL = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014;

    address attacker;

    // Snapshot structure
    struct Snapshot {
        uint256[] poolBalances;
        uint256 lastChangeBlock;
        uint256[] internalBalances;
        uint256[] vaultTokenBalances;
        uint256[] attackerTokenBalances;
        uint256[] tokenCash;
        uint256[] tokenManaged;
    }

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        attacker = address(this);
        vm.deal(attacker, 10000 ether);
        WETH.deposit{value: 5000 ether}();
        WETH.approve(address(VAULT), type(uint256).max);
        BAL.approve(address(VAULT), type(uint256).max);
    }

    // ========================================================================
    // SNAPSHOT FUNCTIONS
    // ========================================================================

    function takeSnapshot(bytes32 poolId, IERC20[] memory tokens) internal view returns (Snapshot memory snap) {
        // Pool balances
        (, uint256[] memory poolBals, uint256 lastBlock) = VAULT.getPoolTokens(poolId);
        snap.poolBalances = poolBals;
        snap.lastChangeBlock = lastBlock;

        // Internal balances
        snap.internalBalances = VAULT.getInternalBalance(attacker, tokens);

        // Vault and attacker external balances
        snap.vaultTokenBalances = new uint256[](tokens.length);
        snap.attackerTokenBalances = new uint256[](tokens.length);
        snap.tokenCash = new uint256[](tokens.length);
        snap.tokenManaged = new uint256[](tokens.length);

        for (uint i = 0; i < tokens.length; i++) {
            snap.vaultTokenBalances[i] = tokens[i].balanceOf(address(VAULT));
            snap.attackerTokenBalances[i] = tokens[i].balanceOf(attacker);

            (uint256 cash, uint256 managed,,) = VAULT.getPoolTokenInfo(poolId, tokens[i]);
            snap.tokenCash[i] = cash;
            snap.tokenManaged[i] = managed;
        }
    }

    function logSnapshot(string memory label, Snapshot memory snap) internal view {
        console.log("=== SNAPSHOT:", label, "===");
        for (uint i = 0; i < snap.poolBalances.length; i++) {
            console.log("Token", i, "pool balance:", snap.poolBalances[i]);
            console.log("  cash:", snap.tokenCash[i]);
            console.log("  managed:", snap.tokenManaged[i]);
            console.log("  internal:", snap.internalBalances[i]);
            console.log("  vault holds:", snap.vaultTokenBalances[i]);
            console.log("  attacker holds:", snap.attackerTokenBalances[i]);
        }
    }

    // ========================================================================
    // INVARIANT CHECKS
    // ========================================================================

    function checkInvariants(bytes32 poolId, IERC20[] memory tokens, string memory phase) internal view returns (bool ok) {
        ok = true;

        for (uint i = 0; i < tokens.length; i++) {
            (uint256 cash, uint256 managed,,) = VAULT.getPoolTokenInfo(poolId, tokens[i]);
            (, uint256[] memory poolBals,) = VAULT.getPoolTokens(poolId);

            // INVARIANT 1: poolBalance[i] == cash + managed
            if (poolBals[i] != cash + managed) {
                console.log("!!! INVARIANT VIOLATION at", phase, "!!!");
                console.log("Token", i, ": poolBalance != cash + managed");
                console.log("  poolBalance:", poolBals[i]);
                console.log("  cash:", cash);
                console.log("  managed:", managed);
                console.log("  cash+managed:", cash + managed);
                ok = false;
            }
        }

        return ok;
    }

    // ========================================================================
    // THE OUROBOROS AVALANCHE TEST
    // ========================================================================

    function test_OuroborosAvalanche() public {
        console.log("=== OUROBOROS AVALANCHE ===");
        console.log("Single-tx stress test through ALL accounting paths");

        // Get pool info
        (address poolAddr, IVault.PoolSpecialization spec) = VAULT.getPool(BAL_WETH_POOL);
        console.log("Pool address:", poolAddr);
        console.log("Specialization:", uint(spec));

        // Get tokens
        (IERC20[] memory tokens,,) = VAULT.getPoolTokens(BAL_WETH_POOL);
        console.log("Token 0 (BAL):", address(tokens[0]));
        console.log("Token 1 (WETH):", address(tokens[1]));

        // Define amounts
        uint256 L = 100 ether;  // Large amount
        uint256 S = 1 wei;      // Smallest unit

        // First, acquire some BAL for testing
        acquireBAL(10 ether);

        // STEP 0: Initial snapshot
        Snapshot memory snapBefore = takeSnapshot(BAL_WETH_POOL, tokens);
        logSnapshot("BEFORE", snapBefore);

        // Check initial invariants
        require(checkInvariants(BAL_WETH_POOL, tokens, "INITIAL"), "Initial invariants failed");

        // STEP 1: Create mixed internal/external funding state
        console.log("\n=== STEP 1: Create mixed funding state ===");
        createMixedFunding(tokens, L, S);

        Snapshot memory snapAfterFunding = takeSnapshot(BAL_WETH_POOL, tokens);
        logSnapshot("AFTER_FUNDING", snapAfterFunding);

        // Run multiple avalanche cycles
        uint256 NUM_CYCLES = 5;
        console.log("\n=== RUNNING", NUM_CYCLES, "AVALANCHE CYCLES ===");

        for (uint cycle = 0; cycle < NUM_CYCLES; cycle++) {
            console.log("\n--- CYCLE", cycle, "---");

            // STEP 2: Ouroboros batchSwap (alternating directions)
            ouroborosBatchSwap(tokens, 16);

            // Check invariants after swaps
            require(checkInvariants(BAL_WETH_POOL, tokens, "AFTER_SWAPS"), "Invariants failed after swaps");

            // STEP 3: Micro operations with internal balance
            microInternalOperations(tokens, S);

            // Check invariants after micro ops
            require(checkInvariants(BAL_WETH_POOL, tokens, "AFTER_MICRO"), "Invariants failed after micro ops");
        }

        // STEP 4: Final snapshot and comparison
        Snapshot memory snapAfter = takeSnapshot(BAL_WETH_POOL, tokens);
        logSnapshot("AFTER_AVALANCHE", snapAfter);

        // Final invariant check
        require(checkInvariants(BAL_WETH_POOL, tokens, "FINAL"), "Final invariants failed");

        // Check for conservation violations
        checkConservation(snapBefore, snapAfter, tokens);

        console.log("\n=== OUROBOROS AVALANCHE COMPLETE ===");
    }

    // ========================================================================
    // HELPER: Acquire BAL tokens for testing
    // ========================================================================

    function acquireBAL(uint256 wethAmount) internal {
        console.log("Acquiring BAL with", wethAmount / 1e18, "WETH");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](1);
        swaps[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: wethAmount,
            userData: ""
        });

        int256[] memory limits = new int256[](2);
        limits[0] = 0;
        limits[1] = int256(wethAmount);

        VAULT.batchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds, limits, block.timestamp + 1000);

        console.log("BAL acquired:", BAL.balanceOf(attacker));
    }

    // ========================================================================
    // STEP 1: Create mixed internal/external funding
    // ========================================================================

    function createMixedFunding(IERC20[] memory tokens, uint256 L, uint256 S) internal {
        // Deposit unbalanced amounts to internal balance
        // BAL: deposit L to internal, keep S external
        // WETH: deposit S to internal, keep L external

        uint256 balBalance = tokens[0].balanceOf(attacker);
        uint256 wethBalance = tokens[1].balanceOf(attacker);

        console.log("Creating mixed funding...");
        console.log("  BAL external:", balBalance);
        console.log("  WETH external:", wethBalance);

        // Deposit some BAL to internal (leave small amount external)
        uint256 balToDeposit = balBalance > 1 ether ? 1 ether : balBalance / 2;

        // Deposit some WETH to internal (small amount)
        uint256 wethToDeposit = 0.01 ether;

        IVault.UserBalanceOp[] memory ops = new IVault.UserBalanceOp[](2);

        ops[0] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
            asset: IAsset(address(tokens[0])),
            amount: balToDeposit,
            sender: attacker,
            recipient: payable(attacker)
        });

        ops[1] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
            asset: IAsset(address(tokens[1])),
            amount: wethToDeposit,
            sender: attacker,
            recipient: payable(attacker)
        });

        VAULT.manageUserBalance(ops);

        uint256[] memory internal_bals = VAULT.getInternalBalance(attacker, tokens);
        console.log("  BAL internal:", internal_bals[0]);
        console.log("  WETH internal:", internal_bals[1]);
    }

    // ========================================================================
    // STEP 2: Ouroboros batchSwap - alternating directions
    // ========================================================================

    function ouroborosBatchSwap(IERC20[] memory tokens, uint256 numSteps) internal {
        console.log("Ouroboros batchSwap with", numSteps, "steps");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(tokens[0]));
        assets[1] = IAsset(address(tokens[1]));

        // Use internal balance for both source and destination
        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: true,
            recipient: payable(attacker),
            toInternalBalance: true
        });

        // Create alternating swap steps
        IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](numSteps);

        // Alternate between small and large amounts, and directions
        uint256 smallAmt = 0.0001 ether;
        uint256 largeAmt = 0.001 ether;

        for (uint i = 0; i < numSteps; i++) {
            uint256 amt = (i % 2 == 0) ? smallAmt : largeAmt;
            uint256 inIdx = (i % 2 == 0) ? 1 : 0;  // Alternate: WETH->BAL, BAL->WETH
            uint256 outIdx = (i % 2 == 0) ? 0 : 1;

            swaps[i] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: inIdx,
                assetOutIndex: outIdx,
                amount: amt,
                userData: ""
            });
        }

        // Set generous limits
        int256[] memory limits = new int256[](2);
        limits[0] = int256(10 ether);
        limits[1] = int256(10 ether);

        try VAULT.batchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds, limits, block.timestamp + 1000) returns (int256[] memory deltas) {
            console.log("  Swap completed");
            console.log("  BAL delta:", deltas[0]);
            console.log("  WETH delta:", deltas[1]);
        } catch Error(string memory reason) {
            console.log("  Swap failed:", reason);
        } catch {
            console.log("  Swap failed (no reason)");
        }
    }

    // ========================================================================
    // STEP 3: Micro internal balance operations
    // ========================================================================

    function microInternalOperations(IERC20[] memory tokens, uint256 microAmt) internal {
        console.log("Micro internal operations...");

        // Get current internal balances
        uint256[] memory intBals = VAULT.getInternalBalance(attacker, tokens);

        // Withdraw small amount from internal to external, then deposit back
        if (intBals[1] >= 1000) { // If we have some WETH internal
            IVault.UserBalanceOp[] memory ops = new IVault.UserBalanceOp[](2);

            // Withdraw 1000 wei WETH from internal
            ops[0] = IVault.UserBalanceOp({
                kind: IVault.UserBalanceOpKind.WITHDRAW_INTERNAL,
                asset: IAsset(address(tokens[1])),
                amount: 1000,
                sender: attacker,
                recipient: payable(attacker)
            });

            // Deposit 999 wei WETH back to internal (off-by-one)
            ops[1] = IVault.UserBalanceOp({
                kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
                asset: IAsset(address(tokens[1])),
                amount: 999,
                sender: attacker,
                recipient: payable(attacker)
            });

            try VAULT.manageUserBalance(ops) {
                console.log("  Micro ops completed");
            } catch {
                console.log("  Micro ops failed");
            }
        }
    }

    // ========================================================================
    // Conservation check
    // ========================================================================

    function checkConservation(Snapshot memory snapBefore, Snapshot memory snapAfter, IERC20[] memory tokens) internal view {
        console.log("\n=== CONSERVATION CHECK ===");

        for (uint i = 0; i < tokens.length; i++) {
            // Total before = pool + internal + attacker external
            uint256 totalBefore = snapBefore.poolBalances[i] + snapBefore.internalBalances[i] + snapBefore.attackerTokenBalances[i];
            uint256 totalAfter = snapAfter.poolBalances[i] + snapAfter.internalBalances[i] + snapAfter.attackerTokenBalances[i];

            console.log("Token", i, ":");
            console.log("  Total before:", totalBefore);
            console.log("  Total after:", totalAfter);

            if (totalAfter > totalBefore) {
                console.log("  !!! CONSERVATION VIOLATION: MORE TOKENS APPEARED !!!");
                console.log("  Gain:", totalAfter - totalBefore);
            } else if (totalAfter < totalBefore) {
                console.log("  Loss:", totalBefore - totalAfter);
                console.log("  (Expected due to fees/slippage)");
            } else {
                console.log("  Exactly conserved");
            }
        }
    }

    // ========================================================================
    // EXTENDED TEST: Maximum stress with larger cycles
    // ========================================================================

    function test_OuroborosMaxStress() public {
        console.log("=== OUROBOROS MAX STRESS ===");

        (IERC20[] memory tokens,,) = VAULT.getPoolTokens(BAL_WETH_POOL);

        // Acquire BAL
        acquireBAL(50 ether);

        // Create funding
        createMixedFunding(tokens, 10 ether, 1 wei);

        // Run many cycles with larger batch sizes
        uint256 NUM_CYCLES = 10;

        for (uint cycle = 0; cycle < NUM_CYCLES; cycle++) {
            console.log("Cycle", cycle);

            // Larger batch (32 steps)
            ouroborosBatchSwap(tokens, 32);

            // Check invariants
            bool ok = checkInvariants(BAL_WETH_POOL, tokens, "cycle");
            if (!ok) {
                console.log("!!! INVARIANT FAILURE AT CYCLE", cycle, "!!!");
                break;
            }

            // Micro operations
            microInternalOperations(tokens, 1);
        }

        // Final check
        checkInvariants(BAL_WETH_POOL, tokens, "FINAL");
        console.log("Max stress test complete");
    }

    // ========================================================================
    // EXTREME TEST: Push limits with odd numbers
    // ========================================================================

    function test_OuroborosOddNumbers() public {
        console.log("=== OUROBOROS ODD NUMBERS ===");
        console.log("Testing with amounts that don't divide evenly");

        (IERC20[] memory tokens,,) = VAULT.getPoolTokens(BAL_WETH_POOL);

        // Acquire BAL
        acquireBAL(10 ether);

        // Create funding with odd amounts
        uint256 oddAmount1 = 1234567890123456789; // Odd wei amount
        uint256 oddAmount2 = 9876543210987654321; // Another odd amount

        // Deposit odd amounts to internal
        IVault.UserBalanceOp[] memory ops = new IVault.UserBalanceOp[](2);

        ops[0] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
            asset: IAsset(address(tokens[0])),
            amount: oddAmount1 > BAL.balanceOf(attacker) ? BAL.balanceOf(attacker) / 3 : oddAmount1,
            sender: attacker,
            recipient: payable(attacker)
        });

        ops[1] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
            asset: IAsset(address(tokens[1])),
            amount: oddAmount2 > WETH.balanceOf(attacker) ? WETH.balanceOf(attacker) / 3 : oddAmount2,
            sender: attacker,
            recipient: payable(attacker)
        });

        VAULT.manageUserBalance(ops);

        // Run cycles with prime number of steps
        uint256[] memory primeSteps = new uint256[](5);
        primeSteps[0] = 7;
        primeSteps[1] = 11;
        primeSteps[2] = 13;
        primeSteps[3] = 17;
        primeSteps[4] = 19;

        for (uint i = 0; i < primeSteps.length; i++) {
            console.log("Testing with", primeSteps[i], "steps");
            ouroborosBatchSwap(tokens, primeSteps[i]);

            bool ok = checkInvariants(BAL_WETH_POOL, tokens, "prime_cycle");
            if (!ok) {
                console.log("!!! FAILURE WITH", primeSteps[i], "STEPS !!!");
                break;
            }
        }

        console.log("Odd numbers test complete");
    }

    // ========================================================================
    // DRIFT DETECTOR: Look for accumulated dust
    // ========================================================================

    function test_DriftDetector1000Cycles() public {
        console.log("=== DRIFT DETECTOR - 1000 CYCLES ===");
        console.log("Running 1000 cycles to find where math breaks");

        (IERC20[] memory tokens,,) = VAULT.getPoolTokens(BAL_WETH_POOL);

        // Acquire BAL
        acquireBAL(100 ether);
        createMixedFunding(tokens, 10 ether, 1 wei);

        // Take initial snapshot
        Snapshot memory initial = takeSnapshot(BAL_WETH_POOL, tokens);

        // Run 1000 cycles
        uint256 NUM_CYCLES = 1000;
        uint256 driftThreshold = 1; // Alert on ANY drift

        for (uint cycle = 0; cycle < NUM_CYCLES; cycle++) {
            // Batch swap cycle with alternating sizes
            ouroborosBatchSwap(tokens, 16);

            // Micro internal operations every cycle
            microInternalOperations(tokens, 1);

            // Check invariants EVERY cycle
            bool ok = checkInvariants(BAL_WETH_POOL, tokens, "cycle");
            if (!ok) {
                console.log("!!! INVARIANT FAILURE AT CYCLE", cycle, "!!!");
                break;
            }

            // Log progress and check for drift every 100 cycles
            if (cycle % 100 == 0) {
                console.log("Cycle:", cycle);
                Snapshot memory current = takeSnapshot(BAL_WETH_POOL, tokens);

                // Check for drift in pool balances vs cash+managed
                for (uint i = 0; i < tokens.length; i++) {
                    if (current.poolBalances[i] != current.tokenCash[i] + current.tokenManaged[i]) {
                        uint256 drift = current.poolBalances[i] > (current.tokenCash[i] + current.tokenManaged[i])
                            ? current.poolBalances[i] - (current.tokenCash[i] + current.tokenManaged[i])
                            : (current.tokenCash[i] + current.tokenManaged[i]) - current.poolBalances[i];

                        console.log("  Token", i, "DRIFT:", drift);

                        if (drift > driftThreshold) {
                            console.log("!!! SIGNIFICANT DRIFT DETECTED !!!");
                        }
                    }
                }

                // Check conservation
                uint256 totalBefore0 = initial.poolBalances[0] + initial.internalBalances[0] + initial.attackerTokenBalances[0];
                uint256 totalAfter0 = current.poolBalances[0] + current.internalBalances[0] + current.attackerTokenBalances[0];

                if (totalAfter0 > totalBefore0) {
                    console.log("  !!! TOKEN 0 GAINED:", totalAfter0 - totalBefore0);
                }
            }
        }

        // Final comparison
        Snapshot memory final_snap = takeSnapshot(BAL_WETH_POOL, tokens);
        checkConservation(initial, final_snap, tokens);

        console.log("1000 cycle drift detection complete");
    }

    // ========================================================================
    // GAS-EFFICIENT VERSION: Run 1000 cycles with minimal logging
    // ========================================================================

    function test_DriftDetector1000CyclesEfficient() public {
        console.log("=== DRIFT DETECTOR - 1000 CYCLES (EFFICIENT) ===");

        (IERC20[] memory tokens,,) = VAULT.getPoolTokens(BAL_WETH_POOL);

        // Acquire BAL
        acquireBAL(100 ether);
        createMixedFunding(tokens, 10 ether, 1 wei);

        // Take initial snapshot
        Snapshot memory initial = takeSnapshot(BAL_WETH_POOL, tokens);

        uint256 NUM_CYCLES = 1000;
        uint256 invariantFailures = 0;
        uint256 driftEvents = 0;
        uint256 maxDrift = 0;
        uint256 cyclesCompleted = 0;

        for (uint cycle = 0; cycle < NUM_CYCLES; cycle++) {
            // Gas-efficient swap: 8 steps instead of 16
            efficientBatchSwap(tokens, 8);

            // Simplified micro ops
            efficientMicroOps(tokens);

            // Check invariants (silent)
            if (!silentInvariantCheck(BAL_WETH_POOL, tokens)) {
                invariantFailures++;
                console.log("!!! INVARIANT FAILURE AT CYCLE", cycle);
                break;
            }

            cyclesCompleted++;

            // Only log every 200 cycles to save gas
            if (cycle % 200 == 0 && cycle > 0) {
                console.log("Completed cycle", cycle);

                // Quick drift check
                (,uint256[] memory poolBals,) = VAULT.getPoolTokens(BAL_WETH_POOL);
                for (uint i = 0; i < tokens.length; i++) {
                    (uint256 cash, uint256 managed,,) = VAULT.getPoolTokenInfo(BAL_WETH_POOL, tokens[i]);
                    if (poolBals[i] != cash + managed) {
                        uint256 drift = poolBals[i] > (cash + managed)
                            ? poolBals[i] - (cash + managed)
                            : (cash + managed) - poolBals[i];
                        if (drift > maxDrift) maxDrift = drift;
                        driftEvents++;
                    }
                }
            }
        }

        // Final results
        console.log("\n=== FINAL RESULTS ===");
        console.log("Cycles completed:", cyclesCompleted);
        console.log("Invariant failures:", invariantFailures);
        console.log("Drift events:", driftEvents);
        console.log("Max drift:", maxDrift);

        // Final conservation check
        Snapshot memory final_snap = takeSnapshot(BAL_WETH_POOL, tokens);

        for (uint i = 0; i < tokens.length; i++) {
            uint256 totalBefore = initial.poolBalances[i] + initial.internalBalances[i] + initial.attackerTokenBalances[i];
            uint256 totalAfter = final_snap.poolBalances[i] + final_snap.internalBalances[i] + final_snap.attackerTokenBalances[i];

            if (totalAfter > totalBefore) {
                console.log("!!! TOKEN", i, "GAINED:", totalAfter - totalBefore);
            } else if (totalAfter < totalBefore) {
                console.log("Token", i, "lost (fees):", totalBefore - totalAfter);
            }
        }
    }

    // Gas-efficient batch swap (fewer swaps per batch)
    function efficientBatchSwap(IERC20[] memory tokens, uint256 numSteps) internal {
        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(tokens[0]));
        assets[1] = IAsset(address(tokens[1]));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: true,
            recipient: payable(attacker),
            toInternalBalance: true
        });

        IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](numSteps);
        uint256 amt = 0.0001 ether;

        for (uint i = 0; i < numSteps; i++) {
            swaps[i] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: i % 2,
                assetOutIndex: (i + 1) % 2,
                amount: amt,
                userData: ""
            });
        }

        int256[] memory limits = new int256[](2);
        limits[0] = int256(10 ether);
        limits[1] = int256(10 ether);

        try VAULT.batchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds, limits, block.timestamp + 1000) {
            // Success, no logging to save gas
        } catch {
            // Silently continue
        }
    }

    // Gas-efficient micro ops
    function efficientMicroOps(IERC20[] memory tokens) internal {
        uint256[] memory intBals = VAULT.getInternalBalance(attacker, tokens);

        if (intBals[1] >= 1000) {
            IVault.UserBalanceOp[] memory ops = new IVault.UserBalanceOp[](2);

            ops[0] = IVault.UserBalanceOp({
                kind: IVault.UserBalanceOpKind.WITHDRAW_INTERNAL,
                asset: IAsset(address(tokens[1])),
                amount: 1000,
                sender: attacker,
                recipient: payable(attacker)
            });

            ops[1] = IVault.UserBalanceOp({
                kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
                asset: IAsset(address(tokens[1])),
                amount: 999,
                sender: attacker,
                recipient: payable(attacker)
            });

            try VAULT.manageUserBalance(ops) {} catch {}
        }
    }

    // Silent invariant check
    function silentInvariantCheck(bytes32 poolId, IERC20[] memory tokens) internal view returns (bool) {
        for (uint i = 0; i < tokens.length; i++) {
            (uint256 cash, uint256 managed,,) = VAULT.getPoolTokenInfo(poolId, tokens[i]);
            (, uint256[] memory poolBals,) = VAULT.getPoolTokens(poolId);
            if (poolBals[i] != cash + managed) {
                return false;
            }
        }
        return true;
    }

    // ========================================================================
    // ULTRA-EFFICIENT: Maximum cycles with minimum gas
    // ========================================================================

    function test_UltraEfficient2000Cycles() public {
        console.log("=== ULTRA EFFICIENT - 2000 CYCLES ===");

        (IERC20[] memory tokens,,) = VAULT.getPoolTokens(BAL_WETH_POOL);
        acquireBAL(100 ether);
        createMixedFunding(tokens, 10 ether, 1 wei);

        Snapshot memory initial = takeSnapshot(BAL_WETH_POOL, tokens);

        uint256 NUM_CYCLES = 2000;
        uint256 cyclesCompleted = 0;

        for (uint cycle = 0; cycle < NUM_CYCLES; cycle++) {
            // Minimal 4-step swap
            efficientBatchSwap(tokens, 4);
            efficientMicroOps(tokens);

            if (!silentInvariantCheck(BAL_WETH_POOL, tokens)) {
                console.log("BREAK AT CYCLE", cycle);
                break;
            }

            cyclesCompleted++;

            if (cycle % 500 == 0 && cycle > 0) {
                console.log("Cycle", cycle, "OK");
            }
        }

        console.log("Completed:", cyclesCompleted, "/ 2000");

        // Final conservation
        Snapshot memory final_snap = takeSnapshot(BAL_WETH_POOL, tokens);
        for (uint i = 0; i < tokens.length; i++) {
            uint256 before_total = initial.poolBalances[i] + initial.internalBalances[i] + initial.attackerTokenBalances[i];
            uint256 after_total = final_snap.poolBalances[i] + final_snap.internalBalances[i] + final_snap.attackerTokenBalances[i];

            if (after_total > before_total) {
                console.log("!!! PROFIT TOKEN", i, ":", after_total - before_total);
            }
        }
    }

    // ========================================================================
    // EXTREME: 10,000 cycles to find absolute breaking point
    // ========================================================================

    function test_Extreme10000Cycles() public {
        console.log("=== EXTREME - 10000 CYCLES ===");

        (IERC20[] memory tokens,,) = VAULT.getPoolTokens(BAL_WETH_POOL);
        acquireBAL(100 ether);
        createMixedFunding(tokens, 10 ether, 1 wei);

        Snapshot memory initial = takeSnapshot(BAL_WETH_POOL, tokens);

        uint256 NUM_CYCLES = 10000;
        uint256 cyclesCompleted = 0;
        uint256 driftDetected = 0;

        for (uint cycle = 0; cycle < NUM_CYCLES; cycle++) {
            // Minimal 4-step swap
            efficientBatchSwap(tokens, 4);
            efficientMicroOps(tokens);

            if (!silentInvariantCheck(BAL_WETH_POOL, tokens)) {
                console.log("!!! BREAK AT CYCLE", cycle, "!!!");
                break;
            }

            cyclesCompleted++;

            if (cycle % 1000 == 0 && cycle > 0) {
                console.log("Cycle", cycle, "OK");

                // Check for any token gains (exploitability)
                Snapshot memory current = takeSnapshot(BAL_WETH_POOL, tokens);
                for (uint i = 0; i < tokens.length; i++) {
                    uint256 before_total = initial.poolBalances[i] + initial.internalBalances[i] + initial.attackerTokenBalances[i];
                    uint256 after_total = current.poolBalances[i] + current.internalBalances[i] + current.attackerTokenBalances[i];

                    if (after_total > before_total) {
                        console.log("  TOKEN", i, "GAINED:", after_total - before_total);
                        driftDetected++;
                    }
                }
            }
        }

        console.log("\n=== FINAL REPORT ===");
        console.log("Completed:", cyclesCompleted, "/ 10000");
        console.log("Drift events:", driftDetected);

        // Final conservation
        Snapshot memory final_snap = takeSnapshot(BAL_WETH_POOL, tokens);
        for (uint i = 0; i < tokens.length; i++) {
            uint256 before_total = initial.poolBalances[i] + initial.internalBalances[i] + initial.attackerTokenBalances[i];
            uint256 after_total = final_snap.poolBalances[i] + final_snap.internalBalances[i] + final_snap.attackerTokenBalances[i];

            if (after_total >= before_total) {
                console.log("Token", i, "delta: +", after_total - before_total);
            } else {
                console.log("Token", i, "delta: -", before_total - after_total);
            }
        }
    }

    receive() external payable {}
}
