// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../../src/framework/VulnDiscoveryOrchestrator.sol";
import "../../src/framework/VulnDiscoveryFramework.sol";

/**
 * @title VulnDiscoveryTest
 * @notice Main test suite for running vulnerability discovery framework
 * @dev Use with mainnet fork: forge test --match-contract VulnDiscoveryTest --fork-url $ETH_RPC_URL -vvv
 */
contract VulnDiscoveryTest is Test {

    VulnDiscoveryOrchestrator public orchestrator;

    // Common DeFi addresses for testing
    address constant AAVE_V3_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    address constant UNISWAP_V3_FACTORY = 0x1F98431c8aD98523631AE4a59f267346ea31F984;
    address constant COMPOUND_COMPTROLLER = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;
    address constant CURVE_3POOL = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;

    function setUp() public {
        orchestrator = new VulnDiscoveryOrchestrator();
    }

    // ============ SINGLE CONTRACT ANALYSIS ============

    function test_analyzeContract() public {
        // Replace with target contract address
        address target = 0x36f513fe52123addb4d004348a0801dc443bbb31; // First contract from list

        console.log("===========================================");
        console.log("  VULNERABILITY DISCOVERY FRAMEWORK");
        console.log("===========================================");
        console.log("Target:", target);
        console.log("Block:", block.number);
        console.log("");

        if (target.code.length == 0) {
            console.log("ERROR: No code at target address");
            return;
        }

        VulnDiscoveryOrchestrator.FullAnalysis memory analysis = orchestrator.analyzeContract(target);

        // Assertions for findings
        if (analysis.criticalCount > 0) {
            console.log("!!! CRITICAL VULNERABILITIES FOUND !!!");
        }

        if (analysis.exploitFound) {
            console.log("!!! EXPLOIT DISCOVERED !!!");
            console.log("Profit potential (wei):", analysis.maxProfitWei);
        }
    }

    // ============ BATCH ANALYSIS ============

    function test_batchAnalyze() public {
        // Sample contracts from contracts.txt
        address[] memory targets = new address[](5);
        targets[0] = 0x36f513fe52123addb4d004348a0801dc443bbb31;
        targets[1] = 0x763b8a88ac40edb6cc5c13faac1fcff4b393218d;
        targets[2] = 0x38cdb1a8207264c1a07c42c43a4c3ed4bfab7cea;
        targets[3] = 0xc785d05961b3c537cac11f1d496876a255f6d650;
        targets[4] = 0xf9d9f4ae37d09d50a279058c008a4fa98b6336b6;

        console.log("===========================================");
        console.log("  BATCH VULNERABILITY ANALYSIS");
        console.log("===========================================");
        console.log("Analyzing", targets.length, "contracts...");
        console.log("");

        VulnDiscoveryOrchestrator.FullAnalysis[] memory results = orchestrator.batchAnalyze(targets);

        // Summary
        uint256 totalCritical = 0;
        uint256 totalHigh = 0;
        uint256 exploitsFound = 0;

        for (uint256 i = 0; i < results.length; i++) {
            totalCritical += results[i].criticalCount;
            totalHigh += results[i].highCount;
            if (results[i].exploitFound) exploitsFound++;
        }

        console.log("");
        console.log("===========================================");
        console.log("  BATCH SUMMARY");
        console.log("===========================================");
        console.log("Total Critical Vulns:", totalCritical);
        console.log("Total High Vulns:", totalHigh);
        console.log("Exploits Found:", exploitsFound);
    }

    // ============ INVARIANT FUZZING ============

    function test_fuzzInvariants() public {
        address target = 0x36f513fe52123addb4d004348a0801dc443bbb31;

        console.log("===========================================");
        console.log("  INVARIANT FUZZING");
        console.log("===========================================");

        (bool violated, string memory invariantName) = orchestrator.fuzzInvariants(target, 100);

        if (violated) {
            console.log("!!! INVARIANT VIOLATED !!!");
            console.log("Invariant:", invariantName);
        } else {
            console.log("No invariant violations in 100 iterations");
        }
    }

    // ============ PROTOCOL-SPECIFIC TESTS ============

    function test_analyzeAaveV3() public {
        console.log("===========================================");
        console.log("  AAVE V3 ANALYSIS");
        console.log("===========================================");

        if (AAVE_V3_POOL.code.length == 0) {
            console.log("SKIP: Not on mainnet fork");
            return;
        }

        VulnDiscoveryOrchestrator.FullAnalysis memory analysis = orchestrator.analyzeContract(AAVE_V3_POOL);

        console.log("Total Functions:", analysis.totalFunctions);
        console.log("Critical Issues:", analysis.criticalCount);
    }

    function test_analyzeUniswapV3() public {
        console.log("===========================================");
        console.log("  UNISWAP V3 ANALYSIS");
        console.log("===========================================");

        if (UNISWAP_V3_FACTORY.code.length == 0) {
            console.log("SKIP: Not on mainnet fork");
            return;
        }

        VulnDiscoveryOrchestrator.FullAnalysis memory analysis = orchestrator.analyzeContract(UNISWAP_V3_FACTORY);

        console.log("Total Functions:", analysis.totalFunctions);
        console.log("Critical Issues:", analysis.criticalCount);
    }

    // ============ SPECIFIC VULNERABILITY TESTS ============

    function test_oracleVulnerability() public {
        address target = 0x36f513fe52123addb4d004348a0801dc443bbb31;

        OracleSecurityChecker oracleChecker = orchestrator.oracleChecker();

        // Find and analyze oracle
        (bool success, bytes memory data) = target.staticcall(
            abi.encodeWithSignature("oracle()")
        );

        if (success && data.length >= 32) {
            address oracle = abi.decode(data, (address));
            if (oracle != address(0) && oracle.code.length > 0) {
                OracleSecurityChecker.OracleAnalysis memory analysis =
                    oracleChecker.analyzeOracle(oracle, target);

                console.log("Oracle:", oracle);
                console.log("Is Manipulable:", analysis.isManipulable);
                console.log("Is Stale:", analysis.isStale);
            }
        }
    }

    function test_reentrancyVulnerability() public {
        address target = 0x36f513fe52123addb4d004348a0801dc443bbb31;

        ReentrancyDetector detector = orchestrator.reentrancyDetector();

        // Test common function selectors
        bytes4[] memory selectors = new bytes4[](5);
        selectors[0] = bytes4(keccak256("withdraw(uint256)"));
        selectors[1] = bytes4(keccak256("deposit(uint256)"));
        selectors[2] = bytes4(keccak256("transfer(address,uint256)"));
        selectors[3] = bytes4(keccak256("claim()"));
        selectors[4] = bytes4(keccak256("redeem(uint256)"));

        for (uint256 i = 0; i < selectors.length; i++) {
            ReentrancyDetector.ReentrancyAnalysis memory analysis =
                detector.analyzeReentrancy(target, selectors[i]);

            if (!analysis.hasReentrancyGuard && analysis.hasExternalCallBeforeStateUpdate) {
                console.log("!!! POTENTIAL REENTRANCY !!!");
                console.log("Selector:", uint32(selectors[i]));
            }
        }
    }

    function test_arithmeticVulnerability() public {
        address target = 0x36f513fe52123addb4d004348a0801dc443bbb31;

        ArithmeticPrecisionAudit auditor = orchestrator.arithmeticAudit();

        // Test amounts
        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 1;
        amounts[1] = 1e6;
        amounts[2] = 1e18;
        amounts[3] = type(uint128).max;
        amounts[4] = type(uint256).max;

        bytes4 selector = bytes4(keccak256("deposit(uint256)"));

        ArithmeticPrecisionAudit.PrecisionAnalysis memory analysis =
            auditor.analyzePrecision(target, selector, amounts);

        if (analysis.hasRoundingVuln) {
            console.log("!!! ROUNDING VULNERABILITY !!!");
            console.log("Profit:", analysis.roundingProfit);
        }

        if (analysis.hasPrecisionDrift) {
            console.log("!!! PRECISION DRIFT !!!");
            console.log("Drift per iteration:", analysis.driftPerIteration);
        }
    }

    // ============ FLASH LOAN EXPLOIT TESTS ============

    function test_flashLoanExploit() public {
        // This test would attempt flash loan based exploits
        // Requires mainnet fork

        address target = 0x36f513fe52123addb4d004348a0801dc443bbb31;

        console.log("===========================================");
        console.log("  FLASH LOAN EXPLOIT TEST");
        console.log("===========================================");

        // Simulate having flash loan capital
        address attacker = makeAddr("attacker");
        vm.deal(attacker, 1000 ether);

        // Would integrate with actual flash loan providers here
        console.log("Flash loan exploit tests require full integration");
    }

    // ============ MONITORING TESTS ============

    function test_monitoring() public {
        address target = 0x36f513fe52123addb4d004348a0801dc443bbb31;

        AutomatedMonitor monitor = orchestrator.monitor();

        // Configure monitoring
        monitor.setDefaultConfig(target);

        // Run initial monitoring
        AutomatedMonitor.Anomaly[] memory anomalies = monitor.monitor(target);

        console.log("Initial anomalies detected:", anomalies.length);

        // Simulate some activity and re-monitor
        // ...

        // Check for anomalies
        AutomatedMonitor.Anomaly[] memory criticalAnomalies = monitor.getCriticalAnomalies();

        if (criticalAnomalies.length > 0) {
            console.log("!!! CRITICAL ANOMALIES DETECTED !!!");
            for (uint256 i = 0; i < criticalAnomalies.length; i++) {
                console.log("Type:", uint256(criticalAnomalies[i].anomalyType));
                console.log("Description:", criticalAnomalies[i].description);
            }
        }
    }
}

/**
 * @title QuickExploitTest
 * @notice Quick test for validating specific exploits
 */
contract QuickExploitTest is Test {

    function setUp() public {}

    function test_quickExploit() public {
        address target = vm.envOr("TARGET", address(0));

        if (target == address(0)) {
            console.log("Set TARGET env var to run this test");
            return;
        }

        console.log("Testing target:", target);
        console.log("Code size:", target.code.length);

        // Quick balance check
        console.log("ETH balance:", target.balance);

        // Check for common vulnerabilities
        // ...
    }
}

/**
 * @title InvariantTest
 * @notice Invariant tests for the framework
 */
contract InvariantTest is StdInvariant, Test {

    VulnDiscoveryOrchestrator public orchestrator;
    address public target;

    function setUp() public {
        orchestrator = new VulnDiscoveryOrchestrator();
        target = 0x36f513fe52123addb4d004348a0801dc443bbb31;

        // Set up target functions for invariant testing
        targetContract(target);
    }

    function invariant_noUnauthorizedAccess() public {
        // Check that unprivileged users cannot access admin functions
        // This is checked during analysis
    }

    function invariant_conservationOfValue() public {
        // Check that value is conserved in transfers
        // Would need specific implementation per protocol
    }
}
