// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract UnknownSelectorsDeep is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_DeepDiveUnknownSelectors() public {
        console.log("=== DEEP DIVING UNKNOWN SELECTORS ===\n");

        // Unknown selectors that succeeded:
        // 0xeda72134, 0xfd424ea8, 0xc5d664c6, 0x9307e802

        // Try with different parameters and see return values

        console.log("Testing 0xeda72134:");
        (bool s1, bytes memory d1) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0xeda72134))
        );
        console.log("  No params:", s1);
        if (s1) {
            console.log("  Return length:", d1.length);
            if (d1.length == 32) {
                console.log("  As uint:", abi.decode(d1, (uint256)));
                console.log("  As address:", abi.decode(d1, (address)));
            }
        }

        console.log("\nTesting 0xfd424ea8:");
        (bool s2, bytes memory d2) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0xfd424ea8))
        );
        console.log("  No params:", s2);
        if (s2) {
            console.log("  Return length:", d2.length);
            if (d2.length == 32) {
                console.log("  As uint:", abi.decode(d2, (uint256)));
                console.log("  As address:", abi.decode(d2, (address)));
            }
        }

        console.log("\nTesting 0xc5d664c6:");
        (bool s3, bytes memory d3) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0xc5d664c6))
        );
        console.log("  No params:", s3);
        if (s3) {
            console.log("  Return length:", d3.length);
            if (d3.length == 32) {
                console.log("  As uint:", abi.decode(d3, (uint256)));
                console.log("  As address:", abi.decode(d3, (address)));
            }
        }

        console.log("\nTesting 0x9307e802:");
        (bool s4, bytes memory d4) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0x9307e802))
        );
        console.log("  No params:", s4);
        if (s4) {
            console.log("  Return length:", d4.length);
            if (d4.length == 32) {
                console.log("  As uint:", abi.decode(d4, (uint256)));
                console.log("  As address:", abi.decode(d4, (address)));
            }
        }

        // Try with address parameter
        console.log("\n--- With address parameter ---");

        console.log("\nTesting 0xeda72134(attacker):");
        (bool s5, bytes memory d5) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0xeda72134), attacker)
        );
        console.log("  Success:", s5);
        if (s5 && d5.length == 32) {
            console.log("  As uint:", abi.decode(d5, (uint256)));
        }

        console.log("\nTesting 0x9307e802(attacker):");
        (bool s6, bytes memory d6) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0x9307e802), attacker)
        );
        console.log("  Success:", s6);
        if (s6 && d6.length == 32) {
            console.log("  As uint:", abi.decode(d6, (uint256)));
        }
    }

    function test_MatchMoreFunctionNames() public pure {
        console.log("=== MATCHING MORE FUNCTION NAMES ===\n");

        // Unknown: 0xeda72134, 0xfd424ea8, 0xc5d664c6, 0x9307e802

        string[100] memory funcs = [
            "asset()",
            "getAsset()",
            "redemptionAsset()",
            "tAsset()",
            "TAU()",
            "token()",
            "underlying()",
            "underlyingAsset()",
            "collateral()",
            "getCollateral()",
            "rewardToken()",
            "getRewardToken()",
            "baseToken()",
            "getProxy()",
            "getUserProxy()",
            "getClaimProxy()",
            "claimProxy()",
            "proxyFactory()",
            "factory()",
            "getFactory()",
            "controller()",
            "getController()",
            "redeemController()",
            "redemptionController()",
            "staking()",
            "getStaking()",
            "stakingContract()",
            "rewardsDistributor()",
            "rewardDistributor()",
            "distributor()",
            "accumulatedFees()",
            "pendingFees()",
            "totalFees()",
            "fee()",
            "feeRate()",
            "protocolFee()",
            "feeBps()",
            "redemptionFee()",
            "minRedemption()",
            "maxRedemption()",
            "redemptionDelay()",
            "cooldownPeriod()",
            "lockPeriod()",
            "withdrawalDelay()",
            "delayPeriod()",
            "epoch()",
            "currentEpoch()",
            "round()",
            "nonce()",
            "version()",
            "getVersion()",
            "totalRedemptions()",
            "pendingRedemptions()",
            "activeRedemptions()",
            "redeemableAmount()",
            "claimableAmount()",
            "claimable(address)",
            "pendingRewards(address)",
            "earned(address)",
            "rewards(address)",
            "balances(address)",
            "deposits(address)",
            "userInfo(address)",
            "getUserInfo(address)",
            "getRedeemInfo(address)",
            "getRedemption(address)",
            "redemptions(address)",
            "claims(address)",
            "proxies(address)",
            "userProxies(address)",
            "proxyOf(address)",
            "proxyFor(address)",
            "getProxyFor(address)",
            "claimProxyFor(address)",
            "getClaimProxyFor(address)",
            "hasProxy(address)",
            "proxyExists(address)",
            "isProxy(address)",
            "registered(address)",
            "isRegistered(address)",
            "authorized(address)",
            "isAuthorized(address)",
            "whitelisted(address)",
            "isWhitelisted(address)",
            "blacklisted(address)",
            "implementation()",
            "getImplementation()",
            "logic()",
            "beacon()",
            "proxy()",
            "admin()",
            "getAdmin()",
            "manager()",
            "guardian()",
            "keeper()",
            "operator()",
            "pauser()",
            "governor()",
            "governance()",
            "timelock()"
        ];

        bytes4[4] memory targets = [
            bytes4(0xeda72134),
            bytes4(0xfd424ea8),
            bytes4(0xc5d664c6),
            bytes4(0x9307e802)
        ];

        for (uint t = 0; t < 4; t++) {
            console.log("\nLooking for:");
            console.logBytes4(targets[t]);

            for (uint i = 0; i < 100; i++) {
                bytes4 sel = bytes4(keccak256(bytes(funcs[i])));
                if (sel == targets[t]) {
                    console.log("MATCH:", funcs[i]);
                }
            }
        }
    }

    function test_CheckRedemption0Selectors() public view {
        console.log("=== CHECKING REDEMPTION_0 SELECTORS ===\n");

        // R0 has different bytecode - let's check its selectors

        bytes memory code = REDEMPTION_0.code;

        console.log("Function selectors in R0:");
        bytes4[] memory found = new bytes4[](30);
        uint count = 0;

        for (uint i = 0; i + 4 < 400 && i < code.length && count < 30; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                bool isSelector = false;
                for (uint j = i + 5; j < i + 15 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x14) {
                        isSelector = true;
                        break;
                    }
                }
                if (isSelector && sel != bytes4(0) && uint32(sel) > 0x1000) {
                    bool unique = true;
                    for (uint k = 0; k < count; k++) {
                        if (found[k] == sel) unique = false;
                    }
                    if (unique) {
                        found[count] = sel;
                        count++;
                        console.logBytes4(sel);
                    }
                }
            }
        }
    }

    function test_CompareR0R1Selectors() public view {
        console.log("=== COMPARING R0 AND R1 SELECTORS ===\n");

        // R1 selectors we know work
        bytes4[] memory r1Sels = new bytes4[](4);
        r1Sels[0] = bytes4(0xeda72134);
        r1Sels[1] = bytes4(0xfd424ea8);
        r1Sels[2] = bytes4(0xc5d664c6);
        r1Sels[3] = bytes4(0x9307e802);

        console.log("Testing R1 selectors on R0:");
        for (uint i = 0; i < r1Sels.length; i++) {
            (bool s, bytes memory d) = REDEMPTION_0.staticcall(
                abi.encodeWithSelector(r1Sels[i])
            );
            console.log("\nSelector:");
            console.logBytes4(r1Sels[i]);
            console.log("Success:", s);
            if (s && d.length == 32) {
                console.log("Value:", abi.decode(d, (uint256)));
            }
        }

        // Try redeem selector on both
        bytes4 redeemSel = bytes4(keccak256("redeem(uint96)"));
        console.log("\n--- redeem(uint96) selector ---");
        console.logBytes4(redeemSel);

        (bool s1,) = REDEMPTION_0.staticcall(abi.encodeWithSelector(redeemSel));
        console.log("R0:", s1);

        (bool s2,) = REDEMPTION_1.staticcall(abi.encodeWithSelector(redeemSel));
        console.log("R1:", s2);
    }

    function test_ExploreR0Create2() public view {
        console.log("=== EXPLORING R0 CREATE2 ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Find CREATE2 in R0
        console.log("CREATE2 in R0:");
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf5) {
                console.log("\nCREATE2 at:", i);

                // Context
                for (uint j = (i > 50 ? i - 50 : 0); j < i; j++) {
                    uint8 op = uint8(code[j]);
                    if (op == 0x33) console.log(j, "CALLER");
                    if (op == 0x54) console.log(j, "SLOAD");
                    if (op == 0x7f) {
                        // PUSH32
                        bytes32 val;
                        for (uint k = 0; k < 32 && j + 1 + k < code.length; k++) {
                            val = bytes32(uint256(val) << 8 | uint8(code[j + 1 + k]));
                        }
                        console.log(j, "PUSH32:");
                        console.logBytes32(val);
                    }
                }
            }
        }
    }

    function test_R0ProxyCreation() public {
        console.log("=== TESTING R0 PROXY CREATION ===\n");

        deal(TASSET, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        // Try redeem on R0 - this should work!
        console.log("Trying redeem on R0:");
        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("redeem:", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        // Check if any proxy was created for attacker
        // We need to find the init code hash for R0
        bytes32 r0InitHash;
        bytes memory r0Code = REDEMPTION_0.code;
        for (uint i = 4200; i < 4400 && i < r0Code.length; i++) {
            if (uint8(r0Code[i]) == 0x7f) { // PUSH32
                for (uint k = 0; k < 32 && i + 1 + k < r0Code.length; k++) {
                    r0InitHash = bytes32(uint256(r0InitHash) << 8 | uint8(r0Code[i + 1 + k]));
                }
                console.log("R0 init hash at", i, ":");
                console.logBytes32(r0InitHash);
            }
        }

        vm.stopPrank();
    }
}
