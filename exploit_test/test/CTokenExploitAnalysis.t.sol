// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface ICToken {
    function mint(uint256 mintAmount) external returns (uint256);
    function redeem(uint256 redeemTokens) external returns (uint256);
    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);
    function borrow(uint256 borrowAmount) external returns (uint256);
    function exchangeRateStored() external view returns (uint256);
    function exchangeRateCurrent() external returns (uint256);
    function totalSupply() external view returns (uint256);
    function totalBorrows() external view returns (uint256);
    function totalReserves() external view returns (uint256);
    function getCash() external view returns (uint256);
    function borrowIndex() external view returns (uint256);
    function accrualBlockNumber() external view returns (uint256);
    function underlying() external view returns (address);
    function comptroller() external view returns (address);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
}

/**
 * @title CToken Exchange Rate Manipulation Analysis
 * @notice Analyzing potential attack vectors:
 *
 * 1. FIRST MINTER ATTACK:
 *    - First minter deposits small amount
 *    - Donates underlying to inflate exchange rate
 *    - Subsequent minters get rounded down
 *
 * 2. FLASH LOAN + BORROW ATTACK:
 *    - Flash borrow large amount
 *    - Manipulate interest accrual
 *    - Profit from rate changes
 *
 * 3. EXCHANGE RATE PRECISION:
 *    - exchangeRate = (cash + borrows - reserves) / totalSupply
 *    - If totalSupply is low, rounding errors amplified
 */
contract CTokenExploitAnalysisTest is Test {
    address constant CTOKEN = 0x0568F6cb5A0E84FACa107D02f81ddEB1803f3B50;

    ICToken cToken;
    IERC20 underlying;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        cToken = ICToken(CTOKEN);

        // Get underlying token
        try cToken.underlying() returns (address u) {
            underlying = IERC20(u);
        } catch {}
    }

    function testExchangeRateAnalysis() public {
        uint256 exchangeRate = cToken.exchangeRateStored();
        uint256 totalSupply = cToken.totalSupply();
        uint256 totalBorrows = cToken.totalBorrows();
        uint256 totalReserves = cToken.totalReserves();
        uint256 cash = cToken.getCash();

        console.log("=== Exchange Rate Analysis ===");
        console.log("Exchange rate (1e18):", exchangeRate);
        console.log("Total supply (cTokens):", totalSupply);
        console.log("Total borrows:", totalBorrows);
        console.log("Total reserves:", totalReserves);
        console.log("Cash:", cash);

        // exchangeRate = (cash + borrows - reserves) * 1e18 / totalSupply
        if (totalSupply > 0) {
            uint256 calculatedRate = ((cash + totalBorrows - totalReserves) * 1e18) / totalSupply;
            console.log("\nCalculated rate:", calculatedRate);

            // Check for first minter vulnerability
            if (totalSupply < 1e10) {
                console.log("\n[!] LOW SUPPLY: First minter attack possible");
                console.log("Supply <1e10 makes donation attacks effective");
            }
        }
    }

    function testFirstMinterScenario() public view {
        uint256 totalSupply = cToken.totalSupply();
        uint256 exchangeRate = cToken.exchangeRateStored();

        console.log("\n=== First Minter Attack Analysis ===");

        if (totalSupply == 0) {
            console.log("[CRITICAL] Zero supply - first minter can set exchange rate");
            console.log("Attack: Deposit 1 wei, donate 1e18, next depositor gets 0 cTokens");
        } else if (totalSupply < 1e15) {
            // Calculate minimum donation to double exchange rate
            uint256 currentUnderlying = (totalSupply * exchangeRate) / 1e18;
            uint256 donationNeeded = currentUnderlying; // To double the rate

            console.log("Current underlying value:", currentUnderlying);
            console.log("Donation to double rate:", donationNeeded);

            // Calculate victim loss
            uint256 victimDeposit = 1e18; // 1 token
            uint256 victimCTokensNormal = (victimDeposit * 1e18) / exchangeRate;
            uint256 victimCTokensAfterDonation = (victimDeposit * 1e18) / (exchangeRate * 2);
            uint256 victimLoss = victimCTokensNormal - victimCTokensAfterDonation;

            console.log("\nVictim deposits:", victimDeposit);
            console.log("Normal cTokens:", victimCTokensNormal);
            console.log("After donation:", victimCTokensAfterDonation);
            console.log("cTokens stolen:", victimLoss);
        } else {
            console.log("Supply is high enough to mitigate first minter attacks");
            console.log("Total supply:", totalSupply);
        }
    }

    function testBorrowIndexManipulation() public view {
        uint256 borrowIndex = cToken.borrowIndex();
        uint256 accrualBlock = cToken.accrualBlockNumber();
        uint256 currentBlock = block.number;
        uint256 blocksSinceAccrual = currentBlock - accrualBlock;

        console.log("\n=== Borrow Index Analysis ===");
        console.log("Borrow index:", borrowIndex);
        console.log("Last accrual block:", accrualBlock);
        console.log("Current block:", currentBlock);
        console.log("Blocks since accrual:", blocksSinceAccrual);

        // Interest accrues per block
        // Large gaps allow interest to compound significantly
        if (blocksSinceAccrual > 7200) { // ~1 day of blocks
            console.log("\n[!] STALE ACCRUAL: Interest not updated for >1 day");
            console.log("First interaction will accrue significant interest");
            console.log("Timing attack possible before accrual");
        }
    }
}
