// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title veiZi Deep Analysis
 * @notice Analyzing the voting escrow NFT system for potential exploits
 *
 * KEY OBSERVATIONS:
 * 1. Rewards are transferred FROM rewardInfo.provider TO recipient
 *    - If provider lacks balance/approval, transaction reverts (DoS)
 * 2. Only one staked NFT per address allowed
 * 3. Merge function consolidates locked amounts
 * 4. increaseAmount allows adding to locked positions
 *
 * ATTACK VECTORS TO EXPLORE:
 * 1. Flash loan + stake/unstake for reward capture
 * 2. Merge manipulation to concentrate voting power
 * 3. Reward calculation precision issues
 */
contract VeiZiAnalysisTest is Test {
    address constant VEIZI = 0xB56A454d8DaC2AD4cB82337887717a2a427Fcd00;

    // iZi token
    address constant IZI_TOKEN = 0x9ad37205d608B8b219e6a2573f922094CEc5c200;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function test_readVeiZiState() public view {
        console.log("=== VEIZI CONTRACT STATE ===");
        console.log("Contract:", VEIZI);

        // Get staking token
        (bool success, bytes memory data) = VEIZI.staticcall(
            abi.encodeWithSignature("token()")
        );
        if (success && data.length >= 32) {
            address token = abi.decode(data, (address));
            console.log("Token:", token);
        }

        // Get total staked amount
        (success, data) = VEIZI.staticcall(
            abi.encodeWithSignature("stakeiZiAmount()")
        );
        if (success && data.length >= 32) {
            uint256 staked = abi.decode(data, (uint256));
            console.log("Total Staked iZi:", staked / 1e18);
        }

        // Get total supply (number of NFTs)
        (success, data) = VEIZI.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        if (success && data.length >= 32) {
            uint256 supply = abi.decode(data, (uint256));
            console.log("Total NFT Supply:", supply);
        }

        // Get stake number
        (success, data) = VEIZI.staticcall(
            abi.encodeWithSignature("stakeNum()")
        );
        if (success && data.length >= 32) {
            uint256 stakeNum = abi.decode(data, (uint256));
            console.log("Number of Staked NFTs:", stakeNum);
        }

        console.log("============================");
    }

    function test_analyzeRewardInfo() public view {
        console.log("");
        console.log("=== REWARD INFO ANALYSIS ===");

        // Get reward info - it's a struct so we need to call rewardInfo() getter
        (bool success, bytes memory data) = VEIZI.staticcall(
            abi.encodeWithSignature("rewardInfo()")
        );

        if (success && data.length >= 96) {
            // RewardInfo struct: provider, accRewardPerShare, rewardPerSecond
            (address provider, uint256 accRewardPerShare, uint256 rewardPerSecond) =
                abi.decode(data, (address, uint256, uint256));

            console.log("Reward Provider:", provider);
            console.log("Accumulated Reward Per Share:", accRewardPerShare);
            console.log("Reward Per Second:", rewardPerSecond);

            // Check provider's token balance and allowance
            if (provider != address(0)) {
                (bool s2, bytes memory d2) = IZI_TOKEN.staticcall(
                    abi.encodeWithSignature("balanceOf(address)", provider)
                );
                if (s2 && d2.length >= 32) {
                    uint256 providerBalance = abi.decode(d2, (uint256));
                    console.log("Provider iZi Balance:", providerBalance / 1e18);
                }

                (s2, d2) = IZI_TOKEN.staticcall(
                    abi.encodeWithSignature("allowance(address,address)", provider, VEIZI)
                );
                if (s2 && d2.length >= 32) {
                    uint256 allowance = abi.decode(d2, (uint256));
                    console.log("Provider Allowance to veiZi:", allowance / 1e18);
                }
            }
        } else {
            console.log("Could not fetch reward info");
        }

        console.log("============================");
    }

    function test_flashStakeAnalysis() public view {
        console.log("");
        console.log("=== FLASH STAKE ATTACK ANALYSIS ===");

        console.log("Attack hypothesis:");
        console.log("1. Flash loan large amount of iZi tokens");
        console.log("2. Create lock (stake) with max lock time");
        console.log("3. Immediately claim rewards");
        console.log("4. Unstake and repay flash loan");
        console.log("");

        // Get current epoch/timing info
        (bool success, bytes memory data) = VEIZI.staticcall(
            abi.encodeWithSignature("epoch()")
        );
        if (success && data.length >= 32) {
            uint256 epoch = abi.decode(data, (uint256));
            console.log("Current Epoch:", epoch);
        }

        // Check if there's a minimum lock time
        (success, data) = VEIZI.staticcall(
            abi.encodeWithSignature("MINTIME()")
        );
        if (success && data.length >= 32) {
            uint256 minTime = abi.decode(data, (uint256));
            console.log("Minimum Lock Time:", minTime / 86400, "days");
        }

        // Check max lock time
        (success, data) = VEIZI.staticcall(
            abi.encodeWithSignature("MAXTIME()")
        );
        if (success && data.length >= 32) {
            uint256 maxTime = abi.decode(data, (uint256));
            console.log("Maximum Lock Time:", maxTime / 86400, "days");
        }

        console.log("");
        console.log("BLOCKING FACTORS for flash stake attack:");
        console.log("1. Lock must have end time > block.timestamp");
        console.log("2. Cannot unstake until lock expires");
        console.log("3. Flash loan must be repaid in same tx");
        console.log("");
        console.log("VERDICT: Flash stake NOT viable - funds are locked");
        console.log("==================================");
    }

    function test_mergeVotingPowerAnalysis() public pure {
        console.log("");
        console.log("=== MERGE VOTING POWER ANALYSIS ===");

        console.log("Merge function allows consolidating locked amounts:");
        console.log("- Both NFTs must be owned/approved by caller");
        console.log("- Neither NFT can be staked");
        console.log("- Target NFT end time >= source NFT end time");
        console.log("");
        console.log("Potential issues:");
        console.log("1. Weight curve updates could have precision loss");
        console.log("2. Large merges could cause unexpected voting power");
        console.log("");
        console.log("But these require owning multiple NFTs legitimately");
        console.log("Not an unprivileged attack vector");
        console.log("===================================");
    }

    function test_rewardCalculationPrecision() public pure {
        console.log("");
        console.log("=== REWARD CALCULATION PRECISION ===");

        console.log("Reward formula:");
        console.log("reward = (lastVeiZi * (accRewardPerShare - lastTouchAccRewardPerShare)) / Q128");
        console.log("");
        console.log("Q128 = 2^128 = 340282366920938463463374607431768211456");
        console.log("");
        console.log("Precision analysis:");
        console.log("- Division by Q128 happens AFTER multiplication");
        console.log("- This prevents most precision loss attacks");
        console.log("- Dust amounts lost to truncation go to contract");
        console.log("");
        console.log("VERDICT: Standard precision handling, no exploit vector");
        console.log("====================================");
    }
}
