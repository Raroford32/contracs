// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";

interface IDolaSavings {
    function stake(uint256 amount, address recipient) external;
    function unstake(uint256 amount) external;
    function claim(address to) external;
    function claimable(address user) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function balanceOf(address) external view returns (uint256);
    function rewardIndexMantissa() external view returns (uint256);
    function stakerIndexMantissa(address) external view returns (uint256);
    function accruedRewards(address) external view returns (uint256);
    function yearlyRewardBudget() external view returns (uint256);
    function maxRewardPerDolaMantissa() external view returns (uint256);
    function lastUpdate() external view returns (uint256);
    function sweep(address token, uint256 amount, address to) external;
    function gov() external view returns (address);
    function operator() external view returns (address);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

interface IMarket {
    function deposit(uint256 amount) external;
    function withdraw(uint256 amount) external;
    function borrow(uint256 amount) external;
    function repay(address user, uint256 amount) external;
    function liquidate(address user, uint256 repaidDebt) external;
    function forceReplenish(address user, uint256 amount) external;
    function debts(address) external view returns (uint256);
    function escrows(address) external view returns (address);
    function getCreditLimit(address user) external view returns (uint256);
    function oracle() external view returns (address);
    function collateral() external view returns (address);
    function collateralFactorBps() external view returns (uint256);
    function gov() external view returns (address);
}

interface IOracle {
    function getPrice(address token, uint256 collateralFactorBps) external returns (uint256);
    function viewPrice(address token, uint256 collateralFactorBps) external view returns (uint256);
}

contract NovelDeepAnalysis is Test {
    address constant DOLA_SAVINGS = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4;
    address constant DOLA = 0x865377367054516e17014CcdED1e7d814EDC9ce4;
    address constant DBR = 0xAD038Eb671c44b853887A7E32528FaB35dC5D710;

    // Inverse Finance Market
    address constant INV_MARKET = 0x63Df5e23Db45a2066508318f172bA45B9CD37035;

    address attacker = makeAddr("attacker");
    address victim = makeAddr("victim");

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    // INVARIANT 1: Total supply should equal sum of all balances
    // Can we break this by manipulating stake/unstake order?
    function testInvariant_TotalSupplyConsistency() public {
        IDolaSavings ds = IDolaSavings(DOLA_SAVINGS);

        console.log("=== Invariant Test: Total Supply ===");
        console.log("Total Supply:", ds.totalSupply());
        console.log("DOLA Balance:", IERC20(DOLA).balanceOf(DOLA_SAVINGS));

        // Check: totalSupply <= DOLA balance in contract
        uint256 dolaBal = IERC20(DOLA).balanceOf(DOLA_SAVINGS);
        uint256 totalSupply = ds.totalSupply();

        if (dolaBal < totalSupply) {
            console.log("!!! CRITICAL: Contract is insolvent !!!");
            console.log("Shortfall:", totalSupply - dolaBal);
        }

        // Check reward index state
        console.log("Reward Index:", ds.rewardIndexMantissa());
        console.log("Yearly Budget:", ds.yearlyRewardBudget());
        console.log("Max Per Dola:", ds.maxRewardPerDolaMantissa());
    }

    // NOVEL ATTACK VECTOR 1: Precision loss through small stakes
    // If we stake/unstake small amounts repeatedly, does precision loss accumulate?
    function testNovel_PrecisionLossAccumulation() public {
        IDolaSavings ds = IDolaSavings(DOLA_SAVINGS);

        console.log("=== Novel Test: Precision Loss ===");

        // Get a whale with DOLA
        address whale = 0x8f97cca30dBe80E7a8B462f1dD1A51c32aCCcFc2; // Large DOLA holder

        uint256 initialIndex = ds.rewardIndexMantissa();
        uint256 initialTotalSupply = ds.totalSupply();

        console.log("Initial index:", initialIndex);
        console.log("Initial total supply:", initialTotalSupply);

        // Simulate many small time advances to check for precision loss
        uint256 budget = ds.yearlyRewardBudget();
        uint256 maxPerDola = ds.maxRewardPerDolaMantissa();

        // Calculate expected rewards per second
        uint256 maxBudget = (maxPerDola * initialTotalSupply) / 1e18;
        uint256 effectiveBudget = budget > maxBudget ? maxBudget : budget;
        uint256 rewardPerSecond = effectiveBudget / 365 days;

        console.log("Effective budget:", effectiveBudget);
        console.log("Reward per second:", rewardPerSecond);
        console.log("Index increase per second:", (rewardPerSecond * 1e18) / initialTotalSupply);

        // If index increase per second rounds to 0, there's precision loss
        if (initialTotalSupply > 0 && (rewardPerSecond * 1e18) / initialTotalSupply == 0) {
            console.log("!!! POTENTIAL: Precision loss detected !!!");
        }
    }

    // NOVEL ATTACK VECTOR 2: Stake-for-other manipulation
    // Can we manipulate someone's rewards by staking for them at specific times?
    function testNovel_StakeForOtherTiming() public {
        IDolaSavings ds = IDolaSavings(DOLA_SAVINGS);

        console.log("=== Novel Test: Stake-For-Other Timing ===");

        // Check if staking for someone else affects their reward calculation
        // The updateIndex modifier is called with recipient, not msg.sender

        // Find an existing staker
        // Check their current claimable
        address existingStaker = 0x926dF14a23BE491164dCF93f4c468A50ef659D5B; // Example

        uint256 stakerBalance = ds.balanceOf(existingStaker);
        uint256 stakerIndex = ds.stakerIndexMantissa(existingStaker);
        uint256 globalIndex = ds.rewardIndexMantissa();
        uint256 claimableBefore = ds.claimable(existingStaker);

        console.log("Staker balance:", stakerBalance);
        console.log("Staker index:", stakerIndex);
        console.log("Global index:", globalIndex);
        console.log("Claimable before:", claimableBefore);

        // If staker index < global index, they have unclaimed rewards
        if (stakerIndex < globalIndex && stakerBalance > 0) {
            uint256 unclaimed = (globalIndex - stakerIndex) * stakerBalance / 1e18;
            console.log("Calculated unclaimed:", unclaimed);
        }
    }

    // NOVEL ATTACK VECTOR 3: Cross-contract state desync
    // Check Market + DolaSavings interaction
    function testNovel_CrossContractDesync() public {
        console.log("=== Novel Test: Cross-Contract State ===");

        // Check if Market and DolaSavings share any state that could desync
        IMarket market = IMarket(INV_MARKET);

        try market.oracle() returns (address oracle) {
            console.log("Market Oracle:", oracle);

            try market.collateral() returns (address coll) {
                console.log("Market Collateral:", coll);

                try market.collateralFactorBps() returns (uint256 cf) {
                    console.log("Collateral Factor:", cf);

                    // Check oracle price
                    try IOracle(oracle).viewPrice(coll, cf) returns (uint256 price) {
                        console.log("Collateral Price:", price);
                    } catch {
                        console.log("viewPrice failed");
                    }
                } catch {}
            } catch {}
        } catch {
            console.log("Market oracle() failed");
        }
    }

    // NOVEL ATTACK VECTOR 4: Flash loan + reward manipulation
    // Can we use flash loans to manipulate reward distribution?
    function testNovel_FlashLoanRewardManipulation() public {
        IDolaSavings ds = IDolaSavings(DOLA_SAVINGS);

        console.log("=== Novel Test: Flash Loan Reward Manipulation ===");

        uint256 totalSupply = ds.totalSupply();
        uint256 yearlyBudget = ds.yearlyRewardBudget();
        uint256 maxPerDola = ds.maxRewardPerDolaMantissa();

        // Calculate: if we flash loan a huge amount of DOLA and stake
        // Can we dilute other stakers' rewards in the same block?

        // The reward calculation happens in updateIndex:
        // rewardsAccrued = deltaT * budget * mantissa / 365 days
        // But deltaT = 0 within same block!

        // So flash loan attack within same block doesn't work for time-based rewards
        console.log("Same-block flash loan: deltaT = 0, no reward accrual");
        console.log("Flash loan attack NOT viable for same-block");

        // But what about cross-block?
        // Block N: Flash loan, stake huge amount
        // Block N+1: Rewards accrue based on huge totalSupply
        // Block N+1: Unstake, repay flash loan
        // This would dilute all stakers' rewards for that period

        // Calculate impact:
        uint256 flashLoanAmount = 100_000_000 * 1e18; // 100M DOLA
        uint256 newTotalSupply = totalSupply + flashLoanAmount;

        uint256 maxBudgetBefore = (maxPerDola * totalSupply) / 1e18;
        uint256 maxBudgetAfter = (maxPerDola * newTotalSupply) / 1e18;

        console.log("Current total supply:", totalSupply);
        console.log("With 100M flash loan:", newTotalSupply);
        console.log("Max budget before:", maxBudgetBefore);
        console.log("Max budget after:", maxBudgetAfter);

        // The reward per token decreases, but attacker gets share of rewards
        // Is this profitable? Need to calculate flash loan cost vs reward share
    }

    // NOVEL ATTACK VECTOR 5: Index overflow/underflow
    function testNovel_IndexOverflow() public {
        IDolaSavings ds = IDolaSavings(DOLA_SAVINGS);

        console.log("=== Novel Test: Index Overflow Check ===");

        uint256 currentIndex = ds.rewardIndexMantissa();
        uint256 maxUint = type(uint256).max;

        console.log("Current index:", currentIndex);
        console.log("Max uint256:", maxUint);
        console.log("Remaining headroom:", maxUint - currentIndex);

        // How long until overflow at current rate?
        uint256 budget = ds.yearlyRewardBudget();
        uint256 totalSupply = ds.totalSupply();

        if (totalSupply > 0 && budget > 0) {
            uint256 indexPerYear = (budget * 1e18) / totalSupply;
            uint256 yearsToOverflow = (maxUint - currentIndex) / indexPerYear;
            console.log("Index increase per year:", indexPerYear);
            console.log("Years to overflow:", yearsToOverflow);
        }
    }

    // NOVEL ATTACK VECTOR 6: Sweep function edge case
    // Can we manipulate contract balance to allow gov to sweep user funds?
    function testNovel_SweepManipulation() public {
        IDolaSavings ds = IDolaSavings(DOLA_SAVINGS);

        console.log("=== Novel Test: Sweep Manipulation ===");

        uint256 dolaBal = IERC20(DOLA).balanceOf(DOLA_SAVINGS);
        uint256 totalSupply = ds.totalSupply();

        console.log("DOLA balance:", dolaBal);
        console.log("Total supply:", totalSupply);

        // sweep() check: balanceOf(this) - totalSupply >= amount
        // For gov to steal user funds, they need balanceOf < totalSupply

        // Can totalSupply > balanceOf ever happen?
        // - totalSupply increases on stake() after transferFrom
        // - totalSupply decreases on unstake() before transfer

        // The ordering is:
        // stake: balanceOf[recipient] += amount; totalSupply += amount; transferFrom()
        // This is vulnerable! If transferFrom fails silently, totalSupply increases without DOLA

        // But DOLA uses standard ERC20 which reverts on failure
        // However, if DOLA had a fee-on-transfer...

        console.log("Checking if DOLA has transfer fee...");
        // Standard DOLA doesn't have transfer fee

        if (dolaBal < totalSupply) {
            uint256 deficit = totalSupply - dolaBal;
            console.log("!!! DEFICIT FOUND:", deficit);
            console.log("Gov could potentially exploit this via sweep!");
        } else {
            uint256 excess = dolaBal - totalSupply;
            console.log("Excess DOLA (sweepable):", excess);
        }
    }
}
