// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title EthenaMinting Deep Analysis
 * @notice Analyzing the nonce bitmap system for potential replay or collision attacks
 *
 * KEY OBSERVATIONS FROM SOURCE CODE:
 *
 * NONCE BITMAP ANALYSIS:
 * function verifyNonce(address sender, uint128 nonce) public view returns (uint128, uint256, uint256) {
 *     if (nonce == 0) revert InvalidNonce();
 *     uint128 invalidatorSlot = uint64(nonce) >> 8;  // Takes bits 8-71 (64 bits but truncated from nonce)
 *     uint256 invalidatorBit = 1 << uint8(nonce);    // Takes bits 0-7
 *     uint256 invalidator = _orderBitmaps[sender][invalidatorSlot];
 *     if (invalidator & invalidatorBit != 0) revert InvalidNonce();
 *     return (invalidatorSlot, invalidator, invalidatorBit);
 * }
 *
 * POTENTIAL ISSUE: Nonce is uint128 (128 bits) but:
 * - invalidatorSlot uses uint64(nonce) >> 8, which only considers bits 0-71
 * - invalidatorBit uses uint8(nonce), which only considers bits 0-7
 * - Total bits used: 72 bits (0-71)
 * - IGNORED: bits 72-127 (56 bits!)
 *
 * This means two nonces that differ ONLY in bits 72-127 would:
 * 1. Map to the same slot
 * 2. Map to the same bit
 * 3. Be treated as duplicates!
 *
 * IMPACT ANALYSIS:
 * - NOT a replay attack (using A then B fails, not succeeds twice)
 * - IS a potential DoS/griefing vector (legitimate nonces could be blocked)
 * - Depends on how nonces are generated by the off-chain system
 */
contract EthenaMintingAnalysisTest is Test {
    address constant ETHENA_MINTING = 0xe3490297a08d6fC8Da46Edb7B6142E4F461b62D3;

    // Interface for the parts we need
    function verifyNonce(address sender, uint128 nonce) external view returns (uint128, uint256, uint256) {}
    function delegatedSigner(address signer, address delegatedBy) external view returns (uint8) {}
    function stablesDeltaLimit() external view returns (uint128) {}
    function getDomainSeparator() external view returns (bytes32) {}
    function globalConfig() external view returns (uint128 globalMaxMintPerBlock, uint128 globalMaxRedeemPerBlock) {}

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function test_readContractState() public view {
        console.log("=== ETHENA MINTING STATE ANALYSIS ===");
        console.log("Contract:", ETHENA_MINTING);

        // Get global config
        (bool success, bytes memory data) = ETHENA_MINTING.staticcall(
            abi.encodeWithSignature("globalConfig()")
        );
        if (success && data.length >= 64) {
            (uint128 maxMint, uint128 maxRedeem) = abi.decode(data, (uint128, uint128));
            console.log("Global Max Mint Per Block:", maxMint / 1e18);
            console.log("Global Max Redeem Per Block:", maxRedeem / 1e18);
        }

        // Get stables delta limit
        (success, data) = ETHENA_MINTING.staticcall(
            abi.encodeWithSignature("stablesDeltaLimit()")
        );
        if (success && data.length >= 32) {
            uint128 deltaLimit = abi.decode(data, (uint128));
            console.log("Stables Delta Limit:", deltaLimit);
        }

        // Get domain separator
        (success, data) = ETHENA_MINTING.staticcall(
            abi.encodeWithSignature("getDomainSeparator()")
        );
        if (success && data.length >= 32) {
            bytes32 domainSep = abi.decode(data, (bytes32));
            console.log("Domain Separator:");
            console.logBytes32(domainSep);
        }

        console.log("=====================================");
    }

    /**
     * @notice Demonstrate the nonce collision - two different uint128 nonces mapping to same slot+bit
     */
    function test_nonceBitmapCollisionDemo() public pure {
        console.log("");
        console.log("=== NONCE BITMAP COLLISION ANALYSIS ===");

        // Two different nonces that would collide
        // Nonce A: low 72 bits = 0x1234567890ABCDEF12
        // Nonce B: same low 72 bits, but bit 72 is set

        uint128 nonceA = 0x1234567890ABCDEF12;
        uint128 nonceB = 0x1234567890ABCDEF12 + (uint128(1) << 72);

        console.log("Nonce A:", nonceA);
        console.log("Nonce B:", nonceB);
        console.log("Nonces are different:", nonceA != nonceB);

        // Calculate bitmap positions as the contract does
        uint128 slotA = uint64(nonceA) >> 8;
        uint128 slotB = uint64(nonceB) >> 8;
        uint256 bitA = 1 << uint8(nonceA);
        uint256 bitB = 1 << uint8(nonceB);

        console.log("");
        console.log("Slot A:", slotA);
        console.log("Slot B:", slotB);
        console.log("Slots equal:", slotA == slotB);

        console.log("");
        console.log("Bit position A:", uint8(nonceA));
        console.log("Bit position B:", uint8(nonceB));
        console.log("Bits equal:", bitA == bitB);

        console.log("");
        if (slotA == slotB && bitA == bitB) {
            console.log("!!! COLLISION CONFIRMED !!!");
            console.log("Two different nonces map to the same bitmap position");
            console.log("This means if nonceA is used, nonceB will be rejected as duplicate");
        }

        console.log("=========================================");
    }

    /**
     * @notice Calculate the number of unique nonce values vs theoretical max
     */
    function test_nonceSpaceAnalysis() public pure {
        console.log("");
        console.log("=== NONCE SPACE ANALYSIS ===");

        // uint128 = 2^128 possible values
        // But only bits 0-71 are used (72 bits)
        // Actual unique nonces = 2^72

        console.log("Theoretical nonce space: 2^128");
        console.log("Actual unique nonces: 2^72");
        console.log("Collision factor: 2^56 nonces map to each slot+bit");
        console.log("");
        console.log("For each used nonce, 72057594037927935 other nonces become invalid");
        console.log("(2^56 - 1 = 72,057,594,037,927,935)");

        console.log("============================");
    }

    /**
     * @notice Test if this could lead to exploit via specific nonce crafting
     *
     * Attack scenario analysis:
     * 1. User signs order with nonce A
     * 2. Attacker sees this in mempool
     * 3. Can attacker craft nonce B that collides with A and front-run?
     *
     * Answer: NO - because the signature is over the FULL nonce (all 128 bits)
     * So even if B maps to same slot+bit, the signature for A won't work for B
     */
    function test_signatureCollisionAnalysis() public pure {
        console.log("");
        console.log("=== SIGNATURE + NONCE COLLISION ANALYSIS ===");

        console.log("Question: Can attacker exploit nonce collision?");
        console.log("");
        console.log("Order struct includes full nonce:");
        console.log("  Order(order_id, order_type, expiry, nonce, benefactor, ...)");
        console.log("");
        console.log("Signature is computed over hashOrder(order) which includes FULL nonce");
        console.log("");
        console.log("Attack scenario:");
        console.log("1. User signs order with nonce A = 0x1234...");
        console.log("2. Attacker crafts nonce B (collides with A in bitmap)");
        console.log("3. Attacker tries to use user's signature with nonce B");
        console.log("");
        console.log("Result: FAILS - signature is over full nonce A, won't verify for nonce B");
        console.log("");
        console.log("The nonce collision only causes:");
        console.log("- Reduced nonce space (2^72 instead of 2^128)");
        console.log("- Potential for legitimate nonce conflicts if nonces");
        console.log("  are generated poorly by off-chain system");
        console.log("");
        console.log("VERDICT: Design inefficiency, NOT exploitable vulnerability");
        console.log("==========================================");
    }

    /**
     * @notice Check for delegated signer abuse potential
     */
    function test_delegatedSignerAnalysis() public view {
        console.log("");
        console.log("=== DELEGATED SIGNER ANALYSIS ===");

        // Check some random addresses for delegated signer status
        address testBenefactor = 0x1234567890123456789012345678901234567890;
        address testSigner = 0xabCDEF1234567890ABcDEF1234567890aBCDeF12;

        (bool success, bytes memory data) = ETHENA_MINTING.staticcall(
            abi.encodeWithSignature("delegatedSigner(address,address)", testSigner, testBenefactor)
        );

        if (success && data.length >= 32) {
            uint8 status = abi.decode(data, (uint8));
            console.log("Delegated Signer Status (0=none, 1=pending, 2=accepted, 3=rejected):", status);
        }

        console.log("");
        console.log("Delegation flow:");
        console.log("1. Benefactor calls setDelegatedSigner(signer)");
        console.log("2. Signer calls confirmDelegatedSigner(benefactor)");
        console.log("3. Both parties must agree - no unilateral delegation");
        console.log("");
        console.log("VERDICT: Secure - requires mutual consent");
        console.log("================================");
    }

    /**
     * @notice Analyze the stables delta limit for potential price manipulation
     */
    function test_stablesDeltaLimitAnalysis() public view {
        console.log("");
        console.log("=== STABLES DELTA LIMIT ANALYSIS ===");

        (bool success, bytes memory data) = ETHENA_MINTING.staticcall(
            abi.encodeWithSignature("stablesDeltaLimit()")
        );

        if (success && data.length >= 32) {
            uint128 deltaLimit = abi.decode(data, (uint128));
            console.log("Stables Delta Limit:", deltaLimit);
            console.log("As percentage:", deltaLimit, "/ 10000 basis points");
            console.log("Meaning:", deltaLimit / 100, "% deviation allowed from 1:1");

            if (deltaLimit == 0) {
                console.log("Delta limit is 0 - strict 1:1 required for stables");
            } else {
                console.log("");
                console.log("Potential MEV opportunity:");
                console.log("If delta limit is non-zero, mint/redeem at off-peg rates");
                console.log("But this requires MINTER_ROLE - not unprivileged attack");
            }
        }

        console.log("====================================");
    }
}
