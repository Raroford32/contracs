// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract ContractChainAnalysis is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    // Contract chain discovered
    address constant VAULT_SLOT2 = 0x1af329D2C4CeaF45E1D8062c696b09FfadDb933a;
    address constant VAULT_SLOT5 = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;
    address constant SLOT5_SLOT5 = 0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeSlot5Slot5Contract() public view {
        console.log("=== ANALYZING SLOT5's SLOT5 CONTRACT ===\n");

        console.log("Address:", SLOT5_SLOT5);
        console.log("Code size:", SLOT5_SLOT5.code.length);

        if (SLOT5_SLOT5.code.length > 0) {
            bytes memory code = SLOT5_SLOT5.code;

            // Find selectors
            console.log("\nFunction selectors:");
            bytes4[] memory uniqueSels = new bytes4[](40);
            uint selCount = 0;

            for (uint i = 0; i + 4 < code.length && selCount < 40; i++) {
                if (uint8(code[i]) == 0x63) {
                    bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                    if (sel == 0xffffffff || sel == bytes4(0)) continue;

                    bool isUnique = true;
                    for (uint j = 0; j < selCount; j++) {
                        if (uniqueSels[j] == sel) {
                            isUnique = false;
                            break;
                        }
                    }

                    if (isUnique) {
                        uniqueSels[selCount] = sel;
                        selCount++;
                    }
                }
            }

            for (uint i = 0; i < selCount; i++) {
                console.logBytes4(uniqueSels[i]);
            }

            // Check storage
            console.log("\nStorage slots:");
            for (uint i = 0; i < 10; i++) {
                bytes32 slot = vm.load(SLOT5_SLOT5, bytes32(i));
                if (slot != bytes32(0)) {
                    console.log("Slot", i, ":");
                    console.logBytes32(slot);
                }
            }
        }
    }

    function test_TrySlot5Slot5Interaction() public {
        console.log("=== TRYING SLOT5_SLOT5 INTERACTION ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Try as SLOT5_SLOT5
        vm.startPrank(SLOT5_SLOT5);

        (bool s1,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("RC.redeem as SLOT5_SLOT5:", s1);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("*** SLOT5_SLOT5 CAN DRAIN! ***");
        }
    }

    function test_AnalyzeVaultDelegatecalls() public view {
        console.log("=== ANALYZING VAULT DELEGATECALLS ===\n");

        bytes memory code = VAULT.code;

        console.log("Vault code size:", code.length);
        console.log("\nDELEGATECALL locations:");

        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) { // DELEGATECALL
                console.log("\nDELEGATECALL at offset:", i);

                // Look for SLOAD before it
                uint start = i > 100 ? i - 100 : 0;
                for (uint j = start; j < i; j++) {
                    if (uint8(code[j]) == 0x54) {
                        console.log("  SLOAD at:", j);
                    }
                    if (uint8(code[j]) == 0x35) {
                        console.log("  CALLDATALOAD at:", j);
                    }
                    if (uint8(code[j]) == 0x73) {
                        console.log("  PUSH20 at:", j);
                    }
                }
            }
        }
    }

    function test_TraceFullContractChain() public view {
        console.log("=== TRACING FULL CONTRACT CHAIN ===\n");

        console.log("VAULT -> slot 2 -> VAULT_SLOT2");
        console.log("VAULT_SLOT2:", VAULT_SLOT2);

        console.log("\nVAULT -> slot 5 -> VAULT_SLOT5");
        console.log("VAULT_SLOT5:", VAULT_SLOT5);

        console.log("\nVAULT_SLOT5 -> slot 5 -> SLOT5_SLOT5");
        console.log("SLOT5_SLOT5:", SLOT5_SLOT5);

        // Check if there are more levels
        bytes32 nextLevel = vm.load(SLOT5_SLOT5, bytes32(uint256(5)));
        if (nextLevel != bytes32(0)) {
            address next = address(uint160(uint256(nextLevel)));
            if (next.code.length > 0) {
                console.log("\nSLOT5_SLOT5 -> slot 5 ->", next);
            }
        }

        // Check slot 6 (RC is often at slot 6)
        console.log("\nChecking for RC references:");
        bytes32 vaultSlot6 = vm.load(VAULT, bytes32(uint256(6)));
        console.log("Vault slot 6:");
        console.logBytes32(vaultSlot6);
        console.log("(Should be RC:", REDEMPTION_CONTROLLER, ")");
    }

    function test_CheckVaultFunctionMapping() public view {
        console.log("=== CHECKING VAULT FUNCTION MAPPING ===\n");

        // What vault functions might call to slot 2 or slot 5?

        bytes memory code = VAULT.code;

        // Find function selectors in Vault
        console.log("Vault selectors with potential delegatecall:");

        // Look for patterns where SLOAD(2) or SLOAD(5) followed by DELEGATECALL
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0x54) { // SLOAD
                // Check what slot is loaded (look for PUSH before)
                if (i > 0) {
                    uint8 prevOp = uint8(code[i-1]);
                    if (prevOp == 0x60) { // PUSH1
                        uint8 slotNum = uint8(code[i]);
                        // Actually need to look at i-1's operand
                    }
                }

                // Look for DELEGATECALL after
                for (uint j = i; j < i + 50 && j < code.length; j++) {
                    if (uint8(code[j]) == 0xf4) {
                        console.log("SLOAD at", i, "-> DELEGATECALL at", j);
                        break;
                    }
                }
            }
        }
    }

    function test_TryVaultSelectorsWithCallback() public {
        console.log("=== TRYING VAULT SELECTORS WITH CALLBACK ===\n");

        // Maybe some vault functions delegate to slot 2 or 5 with attacker params

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        deal(wstETH, attacker, 1000e18);

        vm.startPrank(attacker);
        IERC20(wstETH).approve(VAULT, type(uint256).max);

        // Try deposit to different receivers
        console.log("Trying deposit variations:");

        (bool s1,) = VAULT.call(
            abi.encodeWithSignature("deposit(uint256,address)", 10e18, attacker)
        );
        console.log("deposit(10, attacker):", s1);

        (bool s2,) = VAULT.call(
            abi.encodeWithSignature("deposit(uint256,address)", 10e18, REDEMPTION_0)
        );
        console.log("deposit(10, R0):", s2);

        // Try mint
        (bool s3,) = VAULT.call(
            abi.encodeWithSignature("mint(uint256,address)", 10e18, attacker)
        );
        console.log("mint(10, attacker):", s3);

        // Try withdraw
        (bool s4,) = VAULT.call(
            abi.encodeWithSignature("withdraw(uint256,address,address)", 10e18, attacker, attacker)
        );
        console.log("withdraw(10, attacker, attacker):", s4);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault balance change:", int256(vaultAfter) - int256(vaultBefore));
    }

    function test_CheckVaultSlot2Owner() public view {
        console.log("=== CHECKING VAULT_SLOT2 OWNER ===\n");

        bytes32 ownerSlot = vm.load(VAULT_SLOT2, bytes32(uint256(0)));
        address owner = address(uint160(uint256(ownerSlot)));

        console.log("VAULT_SLOT2 owner:", owner);
        console.log("Owner code size:", owner.code.length);

        if (owner.code.length > 0) {
            console.log("\n*** OWNER IS A CONTRACT ***");

            // Check its storage
            for (uint i = 0; i < 5; i++) {
                bytes32 slot = vm.load(owner, bytes32(i));
                if (slot != bytes32(0)) {
                    console.log("Owner slot", i, ":");
                    console.logBytes32(slot);
                }
            }
        }
    }

    function test_FullChainRCInteraction() public {
        console.log("=== TESTING FULL CHAIN RC INTERACTION ===\n");

        // Test if any contract in the chain can call RC.redeem

        address[] memory chain = new address[](4);
        chain[0] = VAULT;
        chain[1] = VAULT_SLOT2;
        chain[2] = VAULT_SLOT5;
        chain[3] = SLOT5_SLOT5;

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        for (uint i = 0; i < chain.length; i++) {
            console.log("\nTrying as:", chain[i]);

            vm.startPrank(chain[i]);

            (bool s,) = REDEMPTION_CONTROLLER.call(
                abi.encodeWithSignature("redeem(uint256,address)", 50e18, attacker)
            );
            console.log("  RC.redeem:", s);

            vm.stopPrank();
        }

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault after:", vaultAfter / 1e18);
        console.log("Attacker:", attackerBal / 1e18);

        if (attackerBal > 0) {
            console.log("\n*** FOUND EXPLOIT CHAIN! ***");
        }
    }
}
