// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

contract ActionChainExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_DecodeErrorFb8f41b2() public view {
        console.log("=== DECODING ERROR 0xfb8f41b2 ===\n");

        bytes4 errorSel = bytes4(0xfb8f41b2);

        bytes4[] memory errors = new bytes4[](20);
        errors[0] = bytes4(keccak256("InvalidCaller()"));
        errors[1] = bytes4(keccak256("NotAllowed()"));
        errors[2] = bytes4(keccak256("NotWhitelisted()"));
        errors[3] = bytes4(keccak256("NotRegistered()"));
        errors[4] = bytes4(keccak256("InvalidSender()"));
        errors[5] = bytes4(keccak256("Unauthorized()"));
        errors[6] = bytes4(keccak256("AccessDenied()"));
        errors[7] = bytes4(keccak256("OnlyRedemption()"));
        errors[8] = bytes4(keccak256("CallerNotAllowed()"));
        errors[9] = bytes4(keccak256("InvalidRedeemer()"));
        errors[10] = bytes4(keccak256("NotAuthorized()"));
        errors[11] = bytes4(keccak256("RedeemFailed()"));
        errors[12] = bytes4(keccak256("InvalidRequest()"));
        errors[13] = bytes4(keccak256("NotPending()"));
        errors[14] = bytes4(keccak256("AlreadyFinalized()"));
        errors[15] = bytes4(keccak256("NoRequest()"));
        errors[16] = bytes4(keccak256("RequestNotFound()"));
        errors[17] = bytes4(keccak256("IndexOutOfBounds()"));
        errors[18] = bytes4(keccak256("InvalidIndex()"));
        errors[19] = bytes4(keccak256("NoPendingRedemption()"));

        string[20] memory names = [
            "InvalidCaller()",
            "NotAllowed()",
            "NotWhitelisted()",
            "NotRegistered()",
            "InvalidSender()",
            "Unauthorized()",
            "AccessDenied()",
            "OnlyRedemption()",
            "CallerNotAllowed()",
            "InvalidRedeemer()",
            "NotAuthorized()",
            "RedeemFailed()",
            "InvalidRequest()",
            "NotPending()",
            "AlreadyFinalized()",
            "NoRequest()",
            "RequestNotFound()",
            "IndexOutOfBounds()",
            "InvalidIndex()",
            "NoPendingRedemption()"
        ];

        console.log("Looking for 0xfb8f41b2:\n");
        for (uint i = 0; i < errors.length; i++) {
            if (errors[i] == errorSel) {
                console.log("*** MATCH:", names[i]);
            }
            console.logBytes4(errors[i]);
        }
    }

    function test_AnalyzeCall3552() public view {
        console.log("=== ANALYZING CALL AT 3552 ===\n");

        bytes memory code = REDEMPTION_1.code;

        console.log("Opcodes around 3552:");

        uint i = 3450;
        while (i < 3600 && i < code.length) {
            uint8 op = uint8(code[i]);
            uint skipBytes = 0;

            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0x55) console.log(i, "SSTORE");
            if (op == 0xf1) console.log(i, "CALL");
            if (op == 0xf4) console.log(i, "DELEGATECALL");
            if (op == 0x33) console.log(i, "CALLER");
            if (op == 0x32) console.log(i, "ORIGIN");
            if (op == 0x30) console.log(i, "ADDRESS");

            if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                if (size == 20 && val > 1e30) {
                    console.log(i, "PUSH20 (mask)");
                } else if (size == 20) {
                    console.log(i, "PUSH20:");
                    console.log("  ", address(uint160(val)));
                } else if (size == 4) {
                    console.log(i, "PUSH4:");
                    console.logBytes4(bytes4(uint32(val)));
                } else if (val < 1000) {
                    console.log(i, "PUSH:", val);
                }
                skipBytes = size;
            }

            i += 1 + skipBytes;
        }
    }

    function test_FindProxyCreationInSystem() public view {
        console.log("=== FINDING PROXY CREATION PATTERNS ===\n");

        bytes memory r0code = REDEMPTION_0.code;
        bytes memory r1code = REDEMPTION_1.code;

        console.log("Checking REDEMPTION_0:");
        uint createCount0 = 0;
        uint create2Count0 = 0;
        for (uint i = 0; i < r0code.length; i++) {
            if (uint8(r0code[i]) == 0xf0) createCount0++;
            if (uint8(r0code[i]) == 0xf5) create2Count0++;
        }
        console.log("CREATE count:", createCount0);
        console.log("CREATE2 count:", create2Count0);

        console.log("\nChecking REDEMPTION_1:");
        uint createCount1 = 0;
        uint create2Count1 = 0;
        for (uint i = 0; i < r1code.length; i++) {
            if (uint8(r1code[i]) == 0xf0) createCount1++;
            if (uint8(r1code[i]) == 0xf5) create2Count1++;
        }
        console.log("CREATE count:", createCount1);
        console.log("CREATE2 count:", create2Count1);

        bytes memory rccode = REDEMPTION_CONTROLLER.code;
        console.log("\nChecking RedemptionController:");
        uint createCountRC = 0;
        uint create2CountRC = 0;
        for (uint i = 0; i < rccode.length; i++) {
            if (uint8(rccode[i]) == 0xf0) createCountRC++;
            if (uint8(rccode[i]) == 0xf5) create2CountRC++;
        }
        console.log("CREATE count:", createCountRC);
        console.log("CREATE2 count:", create2CountRC);
    }

    function test_CheckRedemptionRegistration() public view {
        console.log("=== CHECKING REDEMPTION REGISTRATION ===\n");

        bytes memory code = REDEMPTION_CONTROLLER.code;

        console.log("RC function selectors:");
        bytes4[] memory found = new bytes4[](30);
        uint count = 0;

        for (uint i = 0; i + 4 < code.length && count < 30; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                bool isValid = false;
                for (uint j = i + 5; j < i + 15 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x14) {
                        isValid = true;
                        break;
                    }
                }
                if (isValid && sel != bytes4(0) && sel != bytes4(0xffffffff) && uint32(sel) > 0x1000) {
                    bool unique = true;
                    for (uint k = 0; k < count; k++) {
                        if (found[k] == sel) unique = false;
                    }
                    if (unique) {
                        found[count] = sel;
                        count++;
                    }
                }
            }
        }

        for (uint i = 0; i < count; i++) {
            console.logBytes4(found[i]);
        }

        console.log("\nTrying registration-related calls:");

        (bool s1, bytes memory d1) = REDEMPTION_CONTROLLER.staticcall(
            abi.encodeWithSignature("redemptions(uint256)", 0)
        );
        if (s1) {
            console.log("redemptions(0):", abi.decode(d1, (address)));
        }

        (bool s2, bytes memory d2) = REDEMPTION_CONTROLLER.staticcall(
            abi.encodeWithSignature("redemptions(uint256)", 1)
        );
        if (s2) {
            console.log("redemptions(1):", abi.decode(d2, (address)));
        }

        (bool s3, bytes memory d3) = REDEMPTION_CONTROLLER.staticcall(
            abi.encodeWithSignature("isRedemption(address)", REDEMPTION_0)
        );
        if (s3) {
            console.log("isRedemption(R0):", abi.decode(d3, (bool)));
        }

        (bool s4, bytes memory d4) = REDEMPTION_CONTROLLER.staticcall(
            abi.encodeWithSignature("registered(address)", REDEMPTION_0)
        );
        if (s4) {
            console.log("registered(R0):", abi.decode(d4, (bool)));
        }
    }

    function test_CheckAddressAsProxy() public view {
        console.log("=== CHECKING RC REDEMPTION MAPPING ===\n");

        bytes32 redemption0Entry = vm.load(
            REDEMPTION_CONTROLLER,
            keccak256(abi.encode(REDEMPTION_0, uint256(4)))
        );
        console.log("RC mapping slot for REDEMPTION_0:");
        console.logBytes32(redemption0Entry);

        bytes32 redemption1Entry = vm.load(
            REDEMPTION_CONTROLLER,
            keccak256(abi.encode(REDEMPTION_1, uint256(4)))
        );
        console.log("\nRC mapping slot for REDEMPTION_1:");
        console.logBytes32(redemption1Entry);
    }
}
