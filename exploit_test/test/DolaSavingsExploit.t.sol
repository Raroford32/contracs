// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

interface IDolaSavings {
    function stake(uint256 amount, address recipient) external;
    function unstake(uint256 amount) external;
    function claim(address to) external;
    function claimAndUnstake(uint256 amount, address to) external;
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function rewardIndexMantissa() external view returns (uint256);
    function stakerIndexMantissa(address) external view returns (uint256);
    function accruedRewards(address) external view returns (uint256);
    function yearlyRewardBudget() external view returns (uint256);
    function lastUpdate() external view returns (uint256);
    function dola() external view returns (address);
    function dbr() external view returns (address);
}

/**
 * @title DolaSavings Precision & Timing Exploit Analysis
 * @notice Analyzing multiple attack vectors:
 *
 * 1. PRECISION LOSS ATTACK:
 *    - rewardsAccrued = deltaT * yearlyBudget * mantissa / 365 days
 *    - rewardIndexMantissa += rewardsAccrued / _totalSupply
 *    - If rewardsAccrued < _totalSupply, division = 0, rewards lost
 *
 * 2. SAME-BLOCK TIMING ATTACK:
 *    - First staker in block captures accumulated rewards
 *    - Later stakers in same block get index but no time delta
 *
 * 3. FLASH STAKE ATTACK:
 *    - Flash loan DOLA, stake large amount
 *    - Capture disproportionate share of rewards
 *    - Unstake and repay, profit the rewards
 */
contract DolaSavingsExploitTest is Test {
    address constant DOLA_SAVINGS = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4;

    IDolaSavings dolaSavings;
    IERC20 dola;
    IERC20 dbr;

    address attacker = makeAddr("attacker");

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        dolaSavings = IDolaSavings(DOLA_SAVINGS);
        dola = IERC20(dolaSavings.dola());
        dbr = IERC20(dolaSavings.dbr());
    }

    function testPrecisionLossAnalysis() public view {
        uint256 totalSupply = dolaSavings.totalSupply();
        uint256 yearlyBudget = dolaSavings.yearlyRewardBudget();
        uint256 lastUpdate = dolaSavings.lastUpdate();
        uint256 currentIndex = dolaSavings.rewardIndexMantissa();

        console.log("=== Precision Loss Analysis ===");
        console.log("Total supply:", totalSupply);
        console.log("Budget (annual):", yearlyBudget);
        console.log("Last update:", lastUpdate);
        console.log("Current index:", currentIndex);

        // Calculate minimum time for 1 wei reward
        // rewardsAccrued = deltaT * yearlyBudget * 1e18 / 365 days
        // Need rewardsAccrued >= totalSupply for index to increase
        // deltaT >= totalSupply * 365 days / (yearlyBudget * 1e18)

        if (yearlyBudget > 0 && totalSupply > 0) {
            uint256 mantissa = 1e18;
            uint256 minDeltaT = (totalSupply * 365 days) / (yearlyBudget * mantissa);
            console.log("\nMinimum seconds for 1 wei reward:", minDeltaT);

            // If minDeltaT > 1, there's precision loss
            if (minDeltaT > 1) {
                console.log("[!] PRECISION LOSS: Rewards lost for updates < ", minDeltaT, "seconds");

                // Calculate lost rewards per day from precision
                uint256 updatesPerDay = 86400 / minDeltaT;
                uint256 dailyBudget = yearlyBudget / 365;
                uint256 lossPerUpdate = dailyBudget / updatesPerDay;
                console.log("Potential daily loss from rounding:", lossPerUpdate);
            }
        }
    }

    function testSameBlockTimingExploit() public view {
        uint256 totalSupply = dolaSavings.totalSupply();
        uint256 yearlyBudget = dolaSavings.yearlyRewardBudget();
        uint256 lastUpdate = dolaSavings.lastUpdate();
        uint256 timeSinceUpdate = block.timestamp - lastUpdate;

        console.log("\n=== Same-Block Timing Analysis ===");
        console.log("Time since last update:", timeSinceUpdate, "seconds");

        if (yearlyBudget > 0 && totalSupply > 0) {
            // Calculate pending rewards
            uint256 mantissa = 1e18;
            uint256 pendingRewards = (timeSinceUpdate * yearlyBudget * mantissa) / 365 days;
            uint256 indexIncrease = pendingRewards / totalSupply;

            console.log("Pending rewards (mantissa):", pendingRewards);
            console.log("Index increase pending:", indexIncrease);

            // First caller captures this, subsequent callers in same block get nothing
            console.log("\n[!] TIMING EXPLOIT:");
            console.log("First stake/claim in block captures", indexIncrease, "index");
            console.log("All other operations in same block get 0 new rewards");
        }
    }

    function testFlashStakeVector() public view {
        uint256 totalSupply = dolaSavings.totalSupply();
        uint256 yearlyBudget = dolaSavings.yearlyRewardBudget();
        uint256 lastUpdate = dolaSavings.lastUpdate();
        uint256 timeSinceUpdate = block.timestamp - lastUpdate;

        console.log("\n=== Flash Stake Attack Vector ===");

        if (yearlyBudget > 0 && totalSupply > 0) {
            // Attacker flash loans 10x current supply
            uint256 flashAmount = totalSupply * 10;
            uint256 newTotalSupply = totalSupply + flashAmount;

            // Calculate reward share
            uint256 mantissa = 1e18;
            uint256 pendingRewards = (timeSinceUpdate * yearlyBudget * mantissa) / 365 days;

            // Attacker's share: flashAmount / newTotalSupply * rewards
            uint256 attackerShare = (flashAmount * pendingRewards) / (newTotalSupply * mantissa);
            uint256 existingShare = (totalSupply * pendingRewards) / (newTotalSupply * mantissa);

            console.log("Flash loan amount:", flashAmount);
            console.log("Attacker captures rewards:", attackerShare);
            console.log("Existing stakers get:", existingShare);
            console.log("Attacker share %:", attackerShare * 100 / (attackerShare + existingShare));

            // Profit = attackerShare (DBR tokens)
            // Cost = flash loan fee + gas
            console.log("\n[!] FLASH STAKE PROFIT:");
            console.log("Profit (DBR):", attackerShare);
            console.log("Cost: flash loan fee (~0.09%) + gas");
        }
    }
}
