// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Immediate Drain Scanner
 * @notice Scan multiple contracts for potential immediate drain vulnerabilities
 *
 * Looking for:
 * 1. Contracts with significant ETH/token balances
 * 2. Permissionless withdraw/claim functions
 * 3. Accounting bugs that allow extracting more than deposited
 * 4. Reentrancy vulnerabilities
 */
contract ImmediateDrainScannerTest is Test {
    // Common tokens
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;

    // Contracts to scan from contracts.txt
    address[] public targets;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");

        // Add high-priority targets (contracts with potential funds)
        targets.push(0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4); // DolaSavings
        targets.push(0x996913c8c08472f584ab8834e925b06D0eb1D813); // RewardVault
        targets.push(0x5Dc58f812b2e244DABA2fabd33f399cD699D7Ddc); // GammaFarm
        targets.push(0x9A0C8Ff858d273f57072D714bca7411D717501D7); // st1INCH
        targets.push(0xB56A454d8DaC2AD4cB82337887717a2a427Fcd00); // veiZi
        targets.push(0x46b2DeAe6eFf3011008EA27EA36b7c27255ddFA9); // wDYDX
        targets.push(0x7623e9DC0DA6FF821ddb9EbABA794054E078f8c4); // EarlyAdopterPool
        targets.push(0x36AEAe0E411a1E28372e0d66f02E57744EbE7599); // V3Vault
    }

    function test_scanBalances() public view {
        console.log("=== BALANCE SCAN ===");
        console.log("");

        for (uint i = 0; i < targets.length; i++) {
            address target = targets[i];
            console.log("Target", i, ":", target);

            // Check ETH balance
            uint256 ethBalance = target.balance;
            if (ethBalance > 0) {
                console.log("  ETH Balance:", ethBalance / 1e18, "ETH");
            }

            // Check WETH balance
            (bool success, bytes memory data) = WETH.staticcall(
                abi.encodeWithSignature("balanceOf(address)", target)
            );
            if (success && data.length >= 32) {
                uint256 balance = abi.decode(data, (uint256));
                if (balance > 0) {
                    console.log("  WETH Balance:", balance / 1e18);
                }
            }

            // Check USDC balance
            (success, data) = USDC.staticcall(
                abi.encodeWithSignature("balanceOf(address)", target)
            );
            if (success && data.length >= 32) {
                uint256 balance = abi.decode(data, (uint256));
                if (balance > 0) {
                    console.log("  USDC Balance:", balance / 1e6);
                }
            }

            // Check DAI balance
            (success, data) = DAI.staticcall(
                abi.encodeWithSignature("balanceOf(address)", target)
            );
            if (success && data.length >= 32) {
                uint256 balance = abi.decode(data, (uint256));
                if (balance > 0) {
                    console.log("  DAI Balance:", balance / 1e18);
                }
            }

            console.log("");
        }
    }

    function test_attemptPermissionlessWithdraw() public {
        console.log("=== PERMISSIONLESS WITHDRAW ATTEMPTS ===");
        console.log("");

        address attacker = address(0xBEEF);
        vm.startPrank(attacker);

        for (uint i = 0; i < targets.length; i++) {
            address target = targets[i];
            console.log("Target", i, ":", target);

            // Try common withdraw selectors
            bytes4[] memory selectors = new bytes4[](8);
            selectors[0] = bytes4(keccak256("withdraw()"));
            selectors[1] = bytes4(keccak256("withdraw(uint256)"));
            selectors[2] = bytes4(keccak256("claim()"));
            selectors[3] = bytes4(keccak256("harvest()"));
            selectors[4] = bytes4(keccak256("exit()"));
            selectors[5] = bytes4(keccak256("emergencyWithdraw()"));
            selectors[6] = bytes4(keccak256("getReward()"));
            selectors[7] = bytes4(keccak256("claimRewards()"));

            for (uint j = 0; j < selectors.length; j++) {
                (bool success,) = target.call(abi.encodeWithSelector(selectors[j]));
                if (success) {
                    console.log("  !!! PERMISSIONLESS CALL SUCCEEDED:", uint32(selectors[j]));
                }
            }

            console.log("");
        }

        vm.stopPrank();
    }

    function test_checkDolaSavingsDirectly() public {
        console.log("=== DOLA SAVINGS DEEP CHECK ===");

        address dolaSavings = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4;

        // Check DBR balance
        (bool success, bytes memory data) = dolaSavings.staticcall(
            abi.encodeWithSignature("dbr()")
        );
        if (success && data.length >= 32) {
            address dbr = abi.decode(data, (address));
            console.log("DBR Token:", dbr);

            (success, data) = dbr.staticcall(
                abi.encodeWithSignature("balanceOf(address)", dolaSavings)
            );
            if (success && data.length >= 32) {
                uint256 dbrBalance = abi.decode(data, (uint256));
                console.log("DBR Balance in DolaSavings:", dbrBalance);

                if (dbrBalance > 0) {
                    console.log("!!! DBR BALANCE NON-ZERO - FLASH STAKE MIGHT BE VIABLE !!!");
                } else {
                    console.log("DBR Balance is 0 - flash stake blocked");
                }
            }
        }

        // Check total supply of sDOLA
        (success, data) = dolaSavings.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        if (success && data.length >= 32) {
            uint256 totalSupply = abi.decode(data, (uint256));
            console.log("sDOLA Total Supply:", totalSupply / 1e18);
        }

        console.log("============================");
    }

    function test_checkV3VaultDirectly() public {
        console.log("=== V3 VAULT DEEP CHECK ===");

        address v3Vault = 0x36AEAe0E411a1E28372e0d66f02E57744EbE7599;

        // Check total assets
        (bool success, bytes memory data) = v3Vault.staticcall(
            abi.encodeWithSignature("totalAssets()")
        );
        if (success && data.length >= 32) {
            uint256 totalAssets = abi.decode(data, (uint256));
            console.log("V3Vault Total Assets:", totalAssets / 1e6, "USDC");
        }

        // Check if paused
        (success, data) = v3Vault.staticcall(
            abi.encodeWithSignature("emergencyAdmin()")
        );
        if (success && data.length >= 32) {
            address admin = abi.decode(data, (address));
            console.log("Emergency Admin:", admin);
        }

        // Check global debt limit
        (success, data) = v3Vault.staticcall(
            abi.encodeWithSignature("globalDebtLimit()")
        );
        if (success && data.length >= 32) {
            uint256 limit = abi.decode(data, (uint256));
            console.log("Global Debt Limit:", limit / 1e6, "USDC");
        }

        console.log("========================");
    }

    function test_checkRewardVaultDirectly() public {
        console.log("=== REWARD VAULT DEEP CHECK ===");

        address rewardVault = 0x996913c8c08472f584ab8834e925b06D0eb1D813;
        address LINK = 0x514910771AF9Ca656af840dff83E8264EcF986CA;

        // Check LINK balance
        (bool success, bytes memory data) = LINK.staticcall(
            abi.encodeWithSignature("balanceOf(address)", rewardVault)
        );
        if (success && data.length >= 32) {
            uint256 linkBalance = abi.decode(data, (uint256));
            console.log("LINK Balance in RewardVault:", linkBalance / 1e18);
        }

        // Check if paused
        (success, data) = rewardVault.staticcall(
            abi.encodeWithSignature("isPaused()")
        );
        if (success && data.length >= 32) {
            bool paused = abi.decode(data, (bool));
            console.log("Is Paused:", paused);
        }

        // Try to claim as random address
        address attacker = address(0xDEAD);
        vm.prank(attacker);
        (success,) = rewardVault.call(
            abi.encodeWithSignature("claimReward()")
        );
        console.log("Permissionless claim attempt:", success ? "SUCCEEDED" : "FAILED");

        console.log("==============================");
    }
}
