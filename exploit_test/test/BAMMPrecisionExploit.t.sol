// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

interface IBAMM {
    function deposit(uint256 thusdAmount) external;
    function withdraw(uint256 numShares) external;
    function swap(uint256 thusdAmount, uint256 minCollateralReturn, address payable dest) external returns(uint);
    function getSwapCollateralAmount(uint256 thusdQty) external view returns(uint256 collateralAmount, uint256 feeTHUSDAmount);
    function getCollateralBalance() external view returns (uint256);
    function fetchPrice() external view returns(uint256);
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function SP() external view returns (address);
    function thusdToken() external view returns (address);
    function A() external view returns (uint256);
    function fee() external view returns (uint256);
}

interface IStabilityPool {
    function getCompoundedTHUSDDeposit(address) external view returns (uint256);
    function getDepositorCollateralGain(address) external view returns (uint256);
    function provideToSP(uint256) external;
    function withdrawFromSP(uint256) external;
}

// Inline PriceFormula to test edge cases
contract PriceFormulaTester {
    function getSumFixedPoint(uint256 x, uint256 y, uint256 A) public pure returns(uint) {
        if(x == 0 && y == 0) return 0;

        uint256 sum = x + y;

        for(uint256 i = 0 ; i < 255 ; i++) {
            uint256 dP = sum;
            dP = dP * sum / ((x * 2) + 1);
            dP = dP * sum / ((y * 2) + 1);

            uint256 prevSum = sum;

            uint256 n = (A * 2 * (x + y) + (dP * 2)) * sum;
            uint256 d = (A * 2 - 1) * sum;
            sum = n / (d + dP * 3);

            if(sum <= prevSum + 1 && prevSum <= sum + 1) break;
        }

        return sum;
    }

    function getReturn(uint256 xQty, uint256 xBalance, uint256 yBalance, uint256 A) public pure returns(uint256) {
        uint256 sum = getSumFixedPoint(xBalance, yBalance, A);

        uint256 c = sum * sum / ((xQty + xBalance) * 2);
        c = c * sum / (A * 4);
        uint256 b = (xQty + xBalance) + (sum / (A * 2));
        uint256 yPrev = 0;
        uint256 y = sum;

        for(uint256 i = 0 ; i < 255 ; i++) {
            yPrev = y;
            uint256 n = y * y + c;
            uint256 d = y * 2 + b - sum;
            y = n / d;

            if(y <= yPrev + 1 && yPrev <= y + 1) break;
        }

        return yBalance - y - 1;
    }

    // Test specific edge cases
    function testDivergence(uint256 x, uint256 y, uint256 A) public pure returns(uint256 iterations, uint256 result) {
        if(x == 0 && y == 0) return (0, 0);

        uint256 sum = x + y;

        for(uint256 i = 0 ; i < 255 ; i++) {
            uint256 dP = sum;
            dP = dP * sum / ((x * 2) + 1);
            dP = dP * sum / ((y * 2) + 1);

            uint256 prevSum = sum;

            uint256 n = (A * 2 * (x + y) + (dP * 2)) * sum;
            uint256 d = (A * 2 - 1) * sum;
            sum = n / (d + dP * 3);

            if(sum <= prevSum + 1 && prevSum <= sum + 1) {
                return (i, sum);
            }
        }

        return (255, sum); // Did not converge
    }
}

contract BAMMPrecisionExploit is Test {
    address constant BAMM = 0x097f1ee62E63aCFC3Bf64c1a61d96B3771dd06cB;
    address constant THUSD = 0xCFC5bD99915aAa815401C5a41A927aB7a38d29cf;

    PriceFormulaTester formulaTester;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        formulaTester = new PriceFormulaTester();
    }

    function testBAMMStateAnalysis() public view {
        console.log("====================================================");
        console.log("BAMM STATE ANALYSIS - 50M THUSD");
        console.log("====================================================");

        IBAMM bamm = IBAMM(BAMM);

        // Get BAMM parameters
        uint256 A = bamm.A();
        uint256 fee = bamm.fee();
        console.log("Amplification A:", A);
        console.log("Fee (bps):", fee);

        // Get balances
        address sp = bamm.SP();
        console.log("Stability Pool:", sp);

        uint256 thusdInBamm = IERC20(THUSD).balanceOf(BAMM);
        console.log("THUSD directly in BAMM:", thusdInBamm / 1e18);

        uint256 thusdInSP = IStabilityPool(sp).getCompoundedTHUSDDeposit(BAMM);
        console.log("THUSD in SP (compounded):", thusdInSP / 1e18);

        uint256 collGain = IStabilityPool(sp).getDepositorCollateralGain(BAMM);
        console.log("Collateral gain from SP:", collGain / 1e18);

        uint256 collBalance = bamm.getCollateralBalance();
        console.log("Total collateral balance:", collBalance / 1e18);

        uint256 price = bamm.fetchPrice();
        console.log("Collateral price:", price / 1e18);

        uint256 totalShares = bamm.totalSupply();
        console.log("Total shares:", totalShares);
    }

    function testPriceFormulaEdgeCases() public view {
        console.log("====================================================");
        console.log("PRICE FORMULA EDGE CASE TESTING");
        console.log("====================================================");

        uint256 A = 20; // BAMM's A value

        // Test 1: Extreme ratio x >> y
        console.log("\n--- Test 1: x >> y ---");
        _testCase(1e30, 1, A);

        // Test 2: Extreme ratio y >> x
        console.log("\n--- Test 2: y >> x ---");
        _testCase(1, 1e30, A);

        // Test 3: Values that might cause precision loss
        console.log("\n--- Test 3: Precision edge ---");
        _testCase(type(uint128).max, type(uint128).max, A);

        // Test 4: Small values
        console.log("\n--- Test 4: Small values ---");
        _testCase(100, 100, A);
    }

    function _testCase(uint256 x, uint256 y, uint256 A) internal view {
        (uint256 iter, uint256 result) = formulaTester.testDivergence(x, y, A);
        console.log("Iterations:", iter);
        console.log("Result:", result);
        if (iter == 255) {
            console.log("*** NON-CONVERGENCE DETECTED ***");
        }
    }

    function testSwapRoundingExploit() public {
        console.log("====================================================");
        console.log("SWAP ROUNDING EXPLOIT TEST");
        console.log("====================================================");

        IBAMM bamm = IBAMM(BAMM);

        // Test various input amounts for rounding issues
        uint256[] memory testAmounts = new uint256[](10);
        testAmounts[0] = 1;           // 1 wei
        testAmounts[1] = 100;         // 100 wei
        testAmounts[2] = 1e15;        // 0.001 THUSD
        testAmounts[3] = 1e16;        // 0.01 THUSD
        testAmounts[4] = 1e17;        // 0.1 THUSD
        testAmounts[5] = 1e18;        // 1 THUSD
        testAmounts[6] = 1e18 + 1;    // 1 THUSD + 1 wei
        testAmounts[7] = 1e18 - 1;    // 1 THUSD - 1 wei
        testAmounts[8] = 123456789;   // Random small
        testAmounts[9] = 1e27;        // 1 billion THUSD

        console.log("\nTesting swap amounts for rounding exploits:");

        for (uint i = 0; i < testAmounts.length; i++) {
            try bamm.getSwapCollateralAmount(testAmounts[i]) returns (uint256 collOut, uint256 feeOut) {
                console.log("\nInput:", testAmounts[i]);
                console.log("Collateral out:", collOut);
                console.log("Fee:", feeOut);

                if (collOut > 0 && testAmounts[i] < 1e15) {
                    console.log("*** POTENTIAL ROUNDING EXPLOIT - Small input yields output! ***");
                }
            } catch {
                console.log("\nInput:", testAmounts[i]);
                console.log("REVERTED");
            }
        }
    }

    function testShareInflationViaDirectDeposit() public {
        console.log("====================================================");
        console.log("SHARE INFLATION VIA DIRECT DEPOSIT TEST");
        console.log("====================================================");

        // The attack: send collateral directly to BAMM to manipulate share value
        IBAMM bamm = IBAMM(BAMM);

        uint256 totalSharesBefore = bamm.totalSupply();
        uint256 collateralBefore = bamm.getCollateralBalance();
        uint256 price = bamm.fetchPrice();

        console.log("Total shares before:", totalSharesBefore);
        console.log("Collateral before:", collateralBefore);
        console.log("Price:", price / 1e18);

        // Calculate share value before
        address sp = bamm.SP();
        uint256 thusdValue = IStabilityPool(sp).getCompoundedTHUSDDeposit(BAMM);
        uint256 totalValueBefore = thusdValue + (collateralBefore * price / 1e18);
        console.log("THUSD value:", thusdValue / 1e18);
        console.log("Total value (THUSD):", totalValueBefore / 1e18);

        if (totalSharesBefore > 0) {
            uint256 shareValueBefore = totalValueBefore * 1e18 / (totalSharesBefore + 1e8);
            console.log("Share value before:", shareValueBefore);
        }

        // Simulate sending 10 ETH directly to BAMM
        uint256 attackAmount = 10 ether;
        address attacker = makeAddr("attacker");
        vm.deal(attacker, attackAmount);

        vm.prank(attacker);
        (bool success,) = BAMM.call{value: attackAmount}("");

        if (success) {
            console.log("\n*** DIRECT ETH DEPOSIT SUCCEEDED ***");

            uint256 collateralAfter = bamm.getCollateralBalance();
            console.log("Collateral after:", collateralAfter);

            uint256 totalValueAfter = thusdValue + (collateralAfter * price / 1e18);
            console.log("Total value after:", totalValueAfter / 1e18);

            if (totalSharesBefore > 0) {
                uint256 shareValueAfter = totalValueAfter * 1e18 / (totalSharesBefore + 1e8);
                console.log("Share value after:", shareValueAfter);
                console.log("Share value inflated!");
            }
        } else {
            console.log("Direct ETH deposit failed (expected if ERC20 collateral)");
        }
    }

    function testWithdrawCalculationMismatch() public {
        console.log("====================================================");
        console.log("WITHDRAW CALCULATION ANALYSIS");
        console.log("====================================================");

        // Key insight: deposit uses combined value, withdraw uses separate values
        // This creates potential for value extraction if ratios change

        IBAMM bamm = IBAMM(BAMM);
        address sp = bamm.SP();

        uint256 thusdValue = IStabilityPool(sp).getCompoundedTHUSDDeposit(BAMM);
        uint256 collateralValue = bamm.getCollateralBalance();
        uint256 price = bamm.fetchPrice();
        uint256 totalShares = bamm.totalSupply();

        console.log("Current state:");
        console.log("- THUSD in SP:", thusdValue / 1e18);
        console.log("- Collateral:", collateralValue);
        console.log("- Price:", price / 1e18);
        console.log("- Total shares:", totalShares);

        // For a hypothetical 1e18 shares
        uint256 testShares = 1e18;

        // Deposit calculation (combined):
        uint256 combinedValue = thusdValue + (collateralValue * price / 1e18);
        console.log("- Combined USD value:", combinedValue / 1e18);

        // Withdraw calculation (separate):
        // YieldBoxRebase: amount = (share * totalAmount) / (totalShares + 1e8)
        uint256 thusdOut = (testShares * thusdValue) / (totalShares + 1e8);
        uint256 collOut = (testShares * collateralValue) / (totalShares + 1e8);

        console.log("\nFor", testShares / 1e18, "shares withdrawal:");
        console.log("- THUSD out:", thusdOut / 1e18);
        console.log("- Collateral out:", collOut);
        console.log("- Collateral USD value:", collOut * price / 1e36);

        uint256 totalWithdrawValue = thusdOut + (collOut * price / 1e18);
        console.log("- Total withdraw value:", totalWithdrawValue / 1e18);
    }

    function testActualSwapExecution() public {
        console.log("====================================================");
        console.log("ACTUAL SWAP EXECUTION TEST");
        console.log("====================================================");

        // Find a THUSD whale and try actual swap
        address thusdWhale = 0x66017D22b0f8556afDd19FC67041899Eb65a21bb;
        uint256 whaleBalance = IERC20(THUSD).balanceOf(thusdWhale);

        console.log("THUSD whale balance:", whaleBalance / 1e18);

        if (whaleBalance < 1e18) {
            // Try to find another whale
            address[] memory potentialWhales = new address[](3);
            potentialWhales[0] = 0xCFC5bD99915aAa815401C5a41A927aB7a38d29cf; // THUSD itself
            potentialWhales[1] = BAMM; // BAMM might have THUSD
            potentialWhales[2] = IBAMM(BAMM).SP(); // Stability Pool

            for (uint i = 0; i < potentialWhales.length; i++) {
                uint256 bal = IERC20(THUSD).balanceOf(potentialWhales[i]);
                console.log("Potential whale", i, "balance:", bal / 1e18);
            }

            console.log("No whale with sufficient THUSD found for test");
            return;
        }

        vm.startPrank(thusdWhale);

        IERC20(THUSD).approve(BAMM, type(uint256).max);

        // Get quote first
        (uint256 expectedColl, uint256 expectedFee) = IBAMM(BAMM).getSwapCollateralAmount(1e18);
        console.log("Expected collateral for 1 THUSD:", expectedColl);
        console.log("Expected fee:", expectedFee);

        if (expectedColl > 0) {
            uint256 balBefore = thusdWhale.balance;

            try IBAMM(BAMM).swap(1e18, 1, payable(thusdWhale)) returns (uint256 received) {
                console.log("Swap succeeded!");
                console.log("Received:", received);
                console.log("Balance increase:", thusdWhale.balance - balBefore);
            } catch Error(string memory reason) {
                console.log("Swap failed:", reason);
            } catch {
                console.log("Swap failed with unknown error");
            }
        }

        vm.stopPrank();
    }
}
