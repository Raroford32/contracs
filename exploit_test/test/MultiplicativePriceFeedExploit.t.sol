// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Multiplicative Price Feed Staleness Exploit
 * @notice The MultiplicativePriceFeed contract has a critical vulnerability:
 *         It only returns updatedAt from priceFeedB, ignoring priceFeedA's staleness!
 *
 *         If priceFeedA is stale but priceFeedB is fresh, downstream contracts
 *         checking updatedAt will think the combined price is fresh when it's not.
 */

interface IPriceFeed {
    function decimals() external view returns (uint8);
    function description() external view returns (string memory);
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
    function priceFeedA() external view returns (address);
    function priceFeedB() external view returns (address);
}

interface IChainlinkOracle {
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
    function decimals() external view returns (uint8);
    function description() external view returns (string memory);
}

interface IComet {
    function getAssetInfo(uint8 i) external view returns (
        uint8 offset,
        address asset,
        address priceFeed,
        uint64 scale,
        uint64 borrowCollateralFactor,
        uint64 liquidateCollateralFactor,
        uint64 liquidationFactor,
        uint128 supplyCap
    );
    function numAssets() external view returns (uint8);
    function baseToken() external view returns (address);
    function baseTokenPriceFeed() external view returns (address);
    function getPrice(address priceFeed) external view returns (uint256);
    function totalsCollateral(address asset) external view returns (uint128, uint128);
    function absorb(address absorber, address[] calldata accounts) external;
    function isLiquidatable(address account) external view returns (bool);
    function getCollateralReserves(address asset) external view returns (int);
}

contract MultiplicativePriceFeedExploit is Test {
    address constant MULTIPLICATIVE_FEED = 0xd98Be00b5D27fc98112BdE293e487f8D4cA57d07;

    // Compound III (Comet) markets that might use this feed
    address constant COMET_USDC = 0xc3d688B66703497DAA19211EEdff47f25384cdc3;
    address constant COMET_WETH = 0xA17581A9E3356d9A858b789D68B4d866e593aE94;

    string constant RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    function setUp() public {
        vm.createSelectFork(RPC_URL);
    }

    function test_AnalyzeMultiplicativeFeed() public view {
        console.log("=== MultiplicativePriceFeed Staleness Vulnerability ===\n");

        IPriceFeed feed = IPriceFeed(MULTIPLICATIVE_FEED);

        console.log("Description:", feed.description());
        console.log("Decimals:", feed.decimals());

        address feedA = feed.priceFeedA();
        address feedB = feed.priceFeedB();

        console.log("\nPrice Feed A:", feedA);
        console.log("Price Feed B:", feedB);

        // Get data from feed A
        IChainlinkOracle oracleA = IChainlinkOracle(feedA);
        (, int256 priceA,,uint256 updatedAtA,) = oracleA.latestRoundData();
        uint256 stalenessA = block.timestamp - updatedAtA;

        console.log("\nFeed A:");
        console.log("  Description:", oracleA.description());
        console.log("  Price:", uint256(priceA));
        console.log("  Staleness:", stalenessA, "seconds");
        console.log("          =", stalenessA / 3600, "hours");

        // Get data from feed B
        IChainlinkOracle oracleB = IChainlinkOracle(feedB);
        (, int256 priceB,,uint256 updatedAtB,) = oracleB.latestRoundData();
        uint256 stalenessB = block.timestamp - updatedAtB;

        console.log("\nFeed B:");
        console.log("  Description:", oracleB.description());
        console.log("  Price:", uint256(priceB));
        console.log("  Staleness:", stalenessB, "seconds");
        console.log("          =", stalenessB / 3600, "hours");

        // Get combined data
        (, int256 combinedPrice,,uint256 combinedUpdatedAt,) = feed.latestRoundData();

        console.log("\nCombined Feed:");
        console.log("  Price:", uint256(combinedPrice));
        console.log("  UpdatedAt:", combinedUpdatedAt);
        console.log("  Reported Staleness:", block.timestamp - combinedUpdatedAt, "seconds");

        // THE BUG: Combined updatedAt only reflects feed B!
        console.log("\n=== VULNERABILITY ===");
        console.log("Combined feed returns updatedAt from Feed B ONLY!");
        console.log("If Feed A is stale, downstream won't know!");

        if (stalenessA > stalenessB) {
            console.log("\nFeed A is MORE STALE than Feed B!");
            console.log("  Real staleness:", stalenessA, "seconds");
            console.log("  Reported staleness:", stalenessB, "seconds");
            console.log("  Hidden staleness:", stalenessA - stalenessB, "seconds");
        }
    }

    function test_CheckCometMarkets() public view {
        console.log("=== Checking Compound III (Comet) Markets ===\n");

        // Check USDC Comet
        _checkCometMarket(COMET_USDC, "USDC Comet");

        // Check WETH Comet
        _checkCometMarket(COMET_WETH, "WETH Comet");
    }

    function _checkCometMarket(address comet, string memory name) internal view {
        console.log("Market:", name);

        IComet c = IComet(comet);

        address baseTokenFeed = c.baseTokenPriceFeed();
        console.log("  Base Token Feed:", baseTokenFeed);

        uint8 numAssets = c.numAssets();
        console.log("  Num Collateral Assets:", numAssets);

        for (uint8 i = 0; i < numAssets; i++) {
            (,address asset, address priceFeed,,,,,) = c.getAssetInfo(i);
            console.log("\n  Asset", i, ":", asset);
            console.log("    Price Feed:", priceFeed);

            if (priceFeed == MULTIPLICATIVE_FEED) {
                console.log("    *** USES MULTIPLICATIVE FEED! ***");
            }

            // Check if it's a multiplicative feed
            try IPriceFeed(priceFeed).priceFeedA() returns (address feedA) {
                console.log("    This is a Multiplicative Feed!");
                console.log("    Feed A:", feedA);
                console.log("    Feed B:", IPriceFeed(priceFeed).priceFeedB());
            } catch {}
        }
        console.log("");
    }

    function test_ExploitScenario() public view {
        console.log("=== Exploit Scenario Analysis ===\n");

        IPriceFeed feed = IPriceFeed(MULTIPLICATIVE_FEED);
        address feedA = feed.priceFeedA();
        address feedB = feed.priceFeedB();

        IChainlinkOracle oracleA = IChainlinkOracle(feedA);
        IChainlinkOracle oracleB = IChainlinkOracle(feedB);

        (, int256 priceA,,uint256 updatedAtA,) = oracleA.latestRoundData();
        (, int256 priceB,,uint256 updatedAtB,) = oracleB.latestRoundData();

        uint256 stalenessA = block.timestamp - updatedAtA;
        uint256 stalenessB = block.timestamp - updatedAtB;

        console.log("Current State:");
        console.log("  Feed A price:", uint256(priceA));
        console.log("  Feed A staleness:", stalenessA / 3600, "hours");
        console.log("  Feed B price:", uint256(priceB));
        console.log("  Feed B staleness:", stalenessB / 3600, "hours");

        console.log("\nExploit Requirements:");
        console.log("1. Feed A must become significantly stale (>24h)");
        console.log("2. Real price of Feed A asset must move significantly");
        console.log("3. Feed B must stay fresh (to hide staleness)");
        console.log("4. Attacker deposits collateral at stale (favorable) price");
        console.log("5. Borrows against inflated collateral value");
        console.log("6. When real price corrects, loan is undercollateralized");
        console.log("   but position was opened at favorable stale price");

        console.log("\nProfit Calculation:");
        console.log("If Feed A 10% stale-high and borrowed at 80% LTV:");
        uint256 depositValue = 1_000_000e18; // $1M
        uint256 borrowAt80LTV = depositValue * 80 / 100;
        uint256 realValue = depositValue * 90 / 100; // 10% lower
        uint256 profit = borrowAt80LTV - realValue; // $80k profit

        console.log("  Deposit appears to be worth: $1,000,000");
        console.log("  Can borrow (80% LTV): $800,000");
        console.log("  Real deposit value: $900,000");
        console.log("  Potential profit if default: $", profit / 1e18, "k");

        console.log("\nBLOCKERS:");
        console.log("- Comet may have additional staleness checks");
        console.log("- Need to verify this feed is actually used");
        console.log("- Need significant price movement during staleness");
    }
}
