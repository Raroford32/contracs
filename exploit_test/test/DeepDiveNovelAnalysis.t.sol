// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
    function allowance(address, address) external view returns (uint256);
}

interface IStakingRewards {
    function stake(uint256 amount) external;
    function withdraw(uint256 amount) external;
    function getReward() external;
    function exit() external;
    function earned(address account) external view returns (uint256);
    function rewardRate() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function balanceOf(address) external view returns (uint256);
    function stakingToken() external view returns (address);
    function rewardsToken() external view returns (address);
    function periodFinish() external view returns (uint256);
    function lastTimeRewardApplicable() external view returns (uint256);
    function rewardPerToken() external view returns (uint256);
    function rewardPerTokenStored() external view returns (uint256);
    function lastUpdateTime() external view returns (uint256);
    function rewardsDuration() external view returns (uint256);
    function rewards(address) external view returns (uint256);
    function userRewardPerTokenPaid(address) external view returns (uint256);
    function owner() external view returns (address);
    function rewardsDistribution() external view returns (address);
    function paused() external view returns (bool);
    function recoverERC20(address tokenAddress, uint256 tokenAmount) external;
}

interface IPositionManager {
    function deposit(uint256 _collateral_in, uint256 _min_shares_out) external returns (uint256);
    function startWithdrawal(uint256 _shares_amount) external;
    function completeWithdrawal(uint256 _withdrawal_epoch, uint256 _min_out) external returns (uint256, uint256);
    function completeNextWithdrawal(uint256 _min_out) external returns (uint256, uint256);
    function assemble(uint256 _min_shares_out) external returns (uint256, uint256);
    function disassemble(uint256 _percentage, uint256 _min_collateral_out) external returns (uint256);
    function getLPTBalance() external view returns (uint256);
    function getCurrentEpoch() external view returns (uint256);
    function owner() external view returns (address);
    function executors(address) external view returns (bool);
    function collateral() external view returns (address);
    function WNATIVE() external view returns (address);
    function execute(address _to, uint256 _value, bytes calldata _data) external payable;
}

interface IVault {
    function collateral() external view returns (address);
    function activeSharesOf(address account) external view returns (uint256);
    function slashableBalanceOf(address account) external view returns (uint256);
    function activeStake() external view returns (uint256);
    function currentEpoch() external view returns (uint256);
    function deposit(address onBehalfOf, uint256 amount) external returns (uint256, uint256);
    function redeem(address claimer, uint256 shares) external returns (uint256, uint256);
}

interface IWETH {
    function deposit() external payable;
    function withdraw(uint256) external;
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
}

interface IFlashLoanReceiver {
    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    ) external returns (bool);
}

interface IAavePool {
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata interestRateModes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

interface ICurvePool {
    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external payable returns (uint256);
    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);
    function coins(uint256) external view returns (address);
    function balances(uint256) external view returns (uint256);
}

contract DeepDiveNovelAnalysis is Test {
    // High-value contracts
    address constant STAKING_REWARDS = 0x4F48031B0EF8acCea3052Af00A3279fbA31b50D8;
    address constant POSITION_MANAGER = 0x5bb8e5e8602b71b182e0Efe256896a931489A135;
    address constant ERC20_HANDLER = 0x2F1d2754393356AEA6334180DA04BAB84412D580;
    address constant EARLY_ADOPTER = 0x7623e9DC0DA6FF821ddb9EbABA794054E078f8c4;

    // Tokens
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant steCRV = 0x06325440D014e39736583c165C2963BA99fAf14E;
    address constant CHZ = 0x3506424F91fD33084466F402d5D97f05F8e3b4AF;
    address constant LDO = 0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32;

    // DEXs
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    address constant CURVE_STETH_POOL = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;

    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    /*//////////////////////////////////////////////////////////////
                    STAKING REWARDS DEEP ANALYSIS
    //////////////////////////////////////////////////////////////*/

    function testStakingRewardsDeepAnalysis() public {
        console.log("========================================");
        console.log("STAKING REWARDS DEEP CONTRACT ANALYSIS");
        console.log("========================================");

        IStakingRewards staking = IStakingRewards(STAKING_REWARDS);

        // 1. Check if stakingToken == rewardsToken (accounting attack surface)
        address stakingToken = staking.stakingToken();
        address rewardsToken = staking.rewardsToken();
        console.log("\n--- Token Configuration ---");
        console.log("Staking Token:", stakingToken);
        console.log("Rewards Token:", rewardsToken);
        console.log("Are they the same?", stakingToken == rewardsToken);

        // 2. Check contract balances
        uint256 stakingTokenBalance = IERC20(stakingToken).balanceOf(STAKING_REWARDS);
        uint256 rewardsTokenBalance = IERC20(rewardsToken).balanceOf(STAKING_REWARDS);
        uint256 totalStaked = staking.totalSupply();
        console.log("\n--- Balance Analysis ---");
        console.log("Contract Staking Token Balance:", stakingTokenBalance);
        console.log("Contract Rewards Token Balance:", rewardsTokenBalance);
        console.log("Total Staked (internal accounting):", totalStaked);
        console.log("Difference (potential orphan tokens):", stakingTokenBalance > totalStaked ? stakingTokenBalance - totalStaked : 0);

        // 3. Check rewards state
        console.log("\n--- Rewards State ---");
        console.log("Reward Rate:", staking.rewardRate());
        console.log("Rewards Duration:", staking.rewardsDuration());
        console.log("Period Finish:", staking.periodFinish());
        console.log("Current Time:", block.timestamp);
        console.log("Last Update Time:", staking.lastUpdateTime());
        console.log("RewardPerTokenStored:", staking.rewardPerTokenStored());

        bool rewardsActive = staking.periodFinish() > block.timestamp;
        console.log("Rewards Active:", rewardsActive);

        if (rewardsActive) {
            uint256 timeRemaining = staking.periodFinish() - block.timestamp;
            uint256 pendingRewards = timeRemaining * staking.rewardRate();
            console.log("Time Remaining (seconds):", timeRemaining);
            console.log("Pending Rewards to Distribute:", pendingRewards);
        }

        // 4. Check access control
        console.log("\n--- Access Control ---");
        console.log("Owner:", staking.owner());
        console.log("Rewards Distribution:", staking.rewardsDistribution());
        console.log("Paused:", staking.paused());

        // 5. Calculate rewardPerToken potential
        if (totalStaked > 0 && staking.rewardRate() > 0) {
            // Test: What happens if we flash loan stake a huge amount?
            // Since reward calculation uses totalSupply in denominator,
            // a flash stake would dilute rewards per token for that instant
            // but since time doesn't pass in flash loan, no rewards accumulate
            console.log("\n--- Flash Stake Analysis ---");
            uint256 currentRPT = staking.rewardPerToken();
            console.log("Current RewardPerToken:", currentRPT);

            // If attacker stakes X tokens, new totalSupply = totalStaked + X
            // New rewardPerToken rate = rewardRate * 1e18 / (totalStaked + X)
            // Attacker's share of future rewards = X / (totalStaked + X)
            // But this requires TIME to pass - can't exploit in flash loan
        }
    }

    function testStakingRewardsRecoverERC20Vulnerability() public {
        console.log("========================================");
        console.log("STAKING REWARDS recoverERC20 ANALYSIS");
        console.log("========================================");

        IStakingRewards staking = IStakingRewards(STAKING_REWARDS);
        address stakingToken = staking.stakingToken();
        address rewardsToken = staking.rewardsToken();
        address owner = staking.owner();

        // The recoverERC20 function only checks against stakingToken
        // It does NOT check against rewardsToken
        // This means owner could accidentally drain reward tokens
        // But this is OWNER only - not exploitable by unprivileged attacker

        console.log("Staking Token (protected):", stakingToken);
        console.log("Rewards Token (NOT protected from recoverERC20):", rewardsToken);
        console.log("Owner:", owner);

        uint256 rewardsBalance = IERC20(rewardsToken).balanceOf(STAKING_REWARDS);
        console.log("Rewards Token Balance in Contract:", rewardsBalance);

        // This is NOT an exploit for unprivileged attacker
        // Just documenting the behavior
        console.log("\nConclusion: Only owner can call recoverERC20");
        console.log("No unprivileged attack vector here");
    }

    function testStakingRewardsExitFunction() public {
        console.log("========================================");
        console.log("STAKING REWARDS exit() ANALYSIS");
        console.log("========================================");

        // exit() calls withdraw() then getReward()
        // withdraw() and getReward() are nonReentrant
        // But exit() itself is NOT marked nonReentrant
        // However, the reentrancy guard is counter-based
        // So even if stakingToken has callback, reentering would fail

        IStakingRewards staking = IStakingRewards(STAKING_REWARDS);
        address stakingToken = staking.stakingToken();

        console.log("Staking Token:", stakingToken);
        console.log("This is steCRV LP token - standard ERC20, no callbacks");
        console.log("Even if it had callbacks, reentrancy guard prevents exploit");
    }

    function testStakingRewardsPrecisionLoss() public {
        console.log("========================================");
        console.log("STAKING REWARDS PRECISION ANALYSIS");
        console.log("========================================");

        IStakingRewards staking = IStakingRewards(STAKING_REWARDS);
        uint256 totalSupply = staking.totalSupply();
        uint256 rewardRate = staking.rewardRate();

        if (rewardRate == 0 || totalSupply == 0) {
            console.log("No active rewards or no stakers");
            return;
        }

        // rewardPerToken calculation:
        // rewardPerTokenStored + (time_elapsed * rewardRate * 1e18 / totalSupply)

        // Check for precision loss per second
        uint256 perSecondNumerator = rewardRate * 1e18;
        uint256 perSecondReward = perSecondNumerator / totalSupply;
        uint256 dustPerSecond = perSecondNumerator % totalSupply;

        console.log("Reward Rate:", rewardRate);
        console.log("Total Supply:", totalSupply);
        console.log("Per Second Reward Per Token:", perSecondReward);
        console.log("Dust Lost Per Second:", dustPerSecond);

        // If dustPerSecond is significant relative to perSecondReward,
        // there's precision loss
        if (dustPerSecond > 0) {
            uint256 daysRemaining = 0;
            if (staking.periodFinish() > block.timestamp) {
                daysRemaining = (staking.periodFinish() - block.timestamp) / 1 days;
            }
            uint256 totalDustLoss = dustPerSecond * daysRemaining * 1 days;
            console.log("Days Remaining:", daysRemaining);
            console.log("Total Dust Loss Over Period:", totalDustLoss);
            console.log("Conclusion: Dust accumulates but stays in contract");
        }
    }

    /*//////////////////////////////////////////////////////////////
                    POSITION MANAGER DEEP ANALYSIS
    //////////////////////////////////////////////////////////////*/

    function testPositionManagerDeepAnalysis() public {
        console.log("========================================");
        console.log("POSITION MANAGER DEEP CONTRACT ANALYSIS");
        console.log("========================================");

        IPositionManager pm = IPositionManager(POSITION_MANAGER);

        // 1. Check access control
        console.log("\n--- Access Control ---");
        address owner = pm.owner();
        console.log("Owner:", owner);

        // Check if attacker is executor
        bool attackerIsExecutor = pm.executors(attacker);
        console.log("Attacker is Executor:", attackerIsExecutor);

        // Check if address(0) is executor (misconfiguration)
        bool zeroIsExecutor = pm.executors(address(0));
        console.log("Zero Address is Executor:", zeroIsExecutor);

        // 2. Check vault configuration
        console.log("\n--- Vault Configuration ---");
        address collateral = pm.collateral();
        console.log("Collateral Token:", collateral);
        console.log("WNATIVE:", pm.WNATIVE());

        uint256 lpBalance = pm.getLPTBalance();
        console.log("LP Balance (shares):", lpBalance);
        console.log("Current Epoch:", pm.getCurrentEpoch());

        // 3. Check if we can call any function without being executor
        console.log("\n--- Function Access Test ---");

        vm.startPrank(attacker);

        // Try calling deposit
        try pm.deposit(1e18, 0) {
            console.log("CRITICAL: deposit() callable by attacker!");
        } catch {
            console.log("deposit() protected by onlyExecutor - GOOD");
        }

        // Try calling assemble
        try pm.assemble(0) {
            console.log("CRITICAL: assemble() callable by attacker!");
        } catch {
            console.log("assemble() protected by onlyExecutor - GOOD");
        }

        // Try calling execute
        try pm.execute(attacker, 0, "") {
            console.log("CRITICAL: execute() callable by attacker!");
        } catch {
            console.log("execute() protected by onlyOwner - GOOD");
        }

        vm.stopPrank();

        // 4. Check contract balances
        console.log("\n--- Balance Analysis ---");
        if (collateral != address(0)) {
            uint256 collateralBalance = IERC20(collateral).balanceOf(POSITION_MANAGER);
            console.log("Collateral Balance in Contract:", collateralBalance);
        }
        uint256 ethBalance = POSITION_MANAGER.balance;
        console.log("ETH Balance:", ethBalance);
    }

    function testPositionManagerReceiveFunction() public {
        console.log("========================================");
        console.log("POSITION MANAGER receive() ANALYSIS");
        console.log("========================================");

        // The contract has receive() external payable {}
        // This allows anyone to send ETH to the contract
        // But the ETH can only be retrieved by owner via withdraw()

        uint256 balanceBefore = POSITION_MANAGER.balance;
        console.log("ETH Balance Before:", balanceBefore);

        vm.prank(attacker);
        (bool success,) = POSITION_MANAGER.call{value: 1 ether}("");

        uint256 balanceAfter = POSITION_MANAGER.balance;
        console.log("ETH Sent:", success);
        console.log("ETH Balance After:", balanceAfter);
        console.log("Delta:", balanceAfter - balanceBefore);
        console.log("Conclusion: Can send ETH but can't retrieve without owner access");
    }

    /*//////////////////////////////////////////////////////////////
                    ERC20 HANDLER DEEP ANALYSIS
    //////////////////////////////////////////////////////////////*/

    function testERC20HandlerDeepAnalysis() public {
        console.log("========================================");
        console.log("ERC20 HANDLER DEEP CONTRACT ANALYSIS");
        console.log("========================================");

        // Check CHZ balance
        uint256 chzBalance = IERC20(CHZ).balanceOf(ERC20_HANDLER);
        console.log("CHZ Balance:", chzBalance);
        console.log("CHZ Balance (human):", chzBalance / 1e18, "CHZ");

        // Try to read bridge address
        (bool success, bytes memory data) = ERC20_HANDLER.staticcall(
            abi.encodeWithSignature("_bridgeAddress()")
        );
        if (success && data.length >= 32) {
            address bridge = abi.decode(data, (address));
            console.log("\nBridge Address:", bridge);

            // Check if bridge has any special permissions
            if (bridge != address(0)) {
                console.log("Checking bridge contract...");

                // Try to read bridge state
                (bool bSuccess, bytes memory bData) = bridge.staticcall(
                    abi.encodeWithSignature("_resourceIDToHandlerAddress(bytes32)")
                );
                if (bSuccess) {
                    console.log("Bridge has resourceIDToHandler mapping");
                }
            }
        }

        // Read handler state
        (success, data) = ERC20_HANDLER.staticcall(
            abi.encodeWithSignature("_contractWhitelist(address)", CHZ)
        );
        if (success && data.length >= 32) {
            bool isWhitelisted = abi.decode(data, (bool));
            console.log("CHZ in Contract Whitelist:", isWhitelisted);
        }

        // Check if deposit function is accessible
        console.log("\n--- Function Access Test ---");
        vm.startPrank(attacker);

        // deposit requires onlyBridge modifier
        bytes32 fakeResourceId = bytes32(uint256(1));
        bytes memory fakeData = abi.encode(uint256(100), address(attacker));

        try IERC20Handler(ERC20_HANDLER).deposit(fakeResourceId, attacker, fakeData) {
            console.log("CRITICAL: deposit() callable by attacker!");
        } catch {
            console.log("deposit() protected - GOOD");
        }

        // Try withdraw
        try IERC20Handler(ERC20_HANDLER).withdraw(fakeData) {
            console.log("CRITICAL: withdraw() callable by attacker!");
        } catch {
            console.log("withdraw() protected - GOOD");
        }

        vm.stopPrank();
    }

    /*//////////////////////////////////////////////////////////////
                    EARLY ADOPTER POOL ANALYSIS
    //////////////////////////////////////////////////////////////*/

    function testEarlyAdopterPoolDeepAnalysis() public {
        console.log("========================================");
        console.log("EARLY ADOPTER POOL DEEP ANALYSIS");
        console.log("========================================");

        uint256 ethBalance = EARLY_ADOPTER.balance;
        console.log("ETH Balance:", ethBalance);
        console.log("ETH Balance (human):", ethBalance / 1e18, "ETH");

        // Check state variables
        (bool success, bytes memory data) = EARLY_ADOPTER.staticcall(
            abi.encodeWithSignature("claimingOpen()")
        );
        if (success && data.length >= 32) {
            bool claimingOpen = abi.decode(data, (bool));
            console.log("\nClaiming Open:", claimingOpen);
        }

        (success, data) = EARLY_ADOPTER.staticcall(abi.encodeWithSignature("owner()"));
        if (success && data.length >= 32) {
            address owner = abi.decode(data, (address));
            console.log("Owner:", owner);
        }

        (success, data) = EARLY_ADOPTER.staticcall(abi.encodeWithSignature("paused()"));
        if (success && data.length >= 32) {
            bool paused = abi.decode(data, (bool));
            console.log("Paused:", paused);
        }

        // Check deposit/withdraw functionality
        console.log("\n--- Function Access Test ---");
        vm.startPrank(attacker);

        // Try deposit
        try IEarlyAdopterPool(EARLY_ADOPTER).deposit{value: 1 ether}() {
            console.log("deposit() succeeded");
            // Check our deposit
            (uint256 amount, uint256 timestamp) = IEarlyAdopterPool(EARLY_ADOPTER).userDeposits(attacker);
            console.log("Our deposit amount:", amount);
            console.log("Our deposit timestamp:", timestamp);
        } catch Error(string memory reason) {
            console.log("deposit() failed:", reason);
        } catch {
            console.log("deposit() failed: unknown error");
        }

        vm.stopPrank();
    }

    /*//////////////////////////////////////////////////////////////
                    NOVEL SCENARIO: TIME MANIPULATION
    //////////////////////////////////////////////////////////////*/

    function testTimeManipulationScenario() public {
        console.log("========================================");
        console.log("TIME MANIPULATION SCENARIO ANALYSIS");
        console.log("========================================");

        IStakingRewards staking = IStakingRewards(STAKING_REWARDS);

        // In StakingRewards, rewards are calculated based on:
        // lastTimeRewardApplicable() - lastUpdateTime
        // where lastTimeRewardApplicable = min(block.timestamp, periodFinish)

        // If periodFinish is in the past, rewards stop accumulating
        // If we could somehow manipulate lastUpdateTime backwards... no we can't

        uint256 periodFinish = staking.periodFinish();
        uint256 lastUpdateTime = staking.lastUpdateTime();
        uint256 currentTime = block.timestamp;

        console.log("Period Finish:", periodFinish);
        console.log("Last Update Time:", lastUpdateTime);
        console.log("Current Time:", currentTime);

        if (periodFinish > currentTime) {
            console.log("Rewards are ACTIVE");

            // Warp time forward to test
            uint256 warpTo = periodFinish + 1;
            vm.warp(warpTo);

            uint256 rewardPerTokenAfterWarp = staking.rewardPerToken();
            console.log("After time warp to period finish + 1:");
            console.log("RewardPerToken:", rewardPerTokenAfterWarp);

            // Reset
            vm.warp(currentTime);
        } else {
            console.log("Rewards are EXPIRED");
            console.log("Time since expiry:", currentTime - periodFinish);
        }
    }

    /*//////////////////////////////////////////////////////////////
                    HELPERS
    //////////////////////////////////////////////////////////////*/

    function _min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }
}

interface IERC20Handler {
    function deposit(bytes32 resourceID, address depositor, bytes calldata data) external;
    function withdraw(bytes calldata data) external;
}

interface IEarlyAdopterPool {
    function deposit() external payable;
    function withdraw() external;
    function claim() external;
    function userDeposits(address) external view returns (uint256 amount, uint256 timestamp);
}
