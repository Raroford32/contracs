// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
    function symbol() external view returns (string memory);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

interface IProxy {
    function implementation() external view returns (address);
    function proxy__getImplementation() external view returns (address);
}

interface ICauldron {
    function cook(uint8[] calldata actions, uint256[] calldata values, bytes[] calldata datas) external payable returns (uint256, uint256);
    function accrue() external;
    function totalBorrow() external view returns (uint128 elastic, uint128 base);
    function userBorrowPart(address) external view returns (uint256);
    function userCollateralShare(address) external view returns (uint256);
    function bentoBox() external view returns (address);
    function collateral() external view returns (address);
    function oracle() external view returns (address);
    function oracleData() external view returns (bytes memory);
    function exchangeRate() external view returns (uint256);
    function updateExchangeRate() external returns (bool updated, uint256 rate);
    function COLLATERIZATION_RATE() external view returns (uint256);
    function LIQUIDATION_MULTIPLIER() external view returns (uint256);
    function totalCollateralShare() external view returns (uint256);
    function feeTo() external view returns (address);
    function masterContract() external view returns (address);
    function magicInternetMoney() external view returns (address);
    function accrueInfo() external view returns (uint64 lastAccrued, uint128 feesEarned, uint64 INTEREST_PER_SECOND);
}

interface IBentoBox {
    function balanceOf(address token, address user) external view returns (uint256);
    function toAmount(address token, uint256 share, bool roundUp) external view returns (uint256);
    function toShare(address token, uint256 amount, bool roundUp) external view returns (uint256);
    function totals(address token) external view returns (uint128 elastic, uint128 base);
    function deposit(address token, address from, address to, uint256 amount, uint256 share) external payable returns (uint256 amountOut, uint256 shareOut);
    function withdraw(address token, address from, address to, uint256 amount, uint256 share) external returns (uint256 amountOut, uint256 shareOut);
    function flashLoan(address borrower, address receiver, address token, uint256 amount, bytes calldata data) external;
}

interface IWithdrawalQueue {
    function getLastRequestId() external view returns (uint256);
    function getLastFinalizedRequestId() external view returns (uint256);
    function getWithdrawalStatus(uint256[] calldata _requestIds) external view returns (WithdrawalRequestStatus[] memory);
    function getClaimableEther(uint256[] calldata _requestIds, uint256[] calldata _hints) external view returns (uint256[] memory);
    function requestWithdrawals(uint256[] calldata _amounts, address _owner) external returns (uint256[] memory);
    function claimWithdrawals(uint256[] calldata _requestIds, uint256[] calldata _hints) external;

    struct WithdrawalRequestStatus {
        uint256 amountOfStETH;
        uint256 amountOfShares;
        address owner;
        uint256 timestamp;
        bool isFinalized;
        bool isClaimed;
    }
}

interface IAavePool {
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata interestRateModes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

contract DeepProtocolAnalysis is Test {
    // CauldronV3 (Abracadabra-style) - HAS COOK()
    address constant CAULDRON_V3 = 0x7Ce7D9ED62B9A6c5aCe1c6Ec9aeb115FA3064757;
    address constant BENTOBOX = 0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce;

    // Lido WithdrawalQueue
    address constant LIDO_QUEUE = 0x889edC2eDab5f40e902b864aD4d7AdE8E412F9B1;

    // Tokens
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant MIM = 0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3;
    address constant stETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;
    address constant yvDAI = 0xdA816459F1AB5631232FE5e97a05BBBb94970c95;

    // AAVE for flash loans
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;

    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    /*//////////////////////////////////////////////////////////////
                CAULDRON V3 ABRACADABRA-STYLE ANALYSIS
    //////////////////////////////////////////////////////////////*/

    function testCauldronV3DeepDive() public {
        console.log("=====================================================");
        console.log("CAULDRON V3 - ABRACADABRA COOK() VULNERABILITY CHECK");
        console.log("=====================================================");

        ICauldron cauldron = ICauldron(CAULDRON_V3);

        console.log("\n--- Protocol State ---");

        // Get MIM token (borrowed asset)
        address mimToken = cauldron.magicInternetMoney();
        console.log("MIM Token:", mimToken);

        // Get collateral info
        address collateral = cauldron.collateral();
        console.log("Collateral (yvDAI):", collateral);

        // Get BentoBox balances
        IBentoBox bento = IBentoBox(BENTOBOX);

        // MIM available in BentoBox
        uint256 mimInBento = bento.balanceOf(mimToken, CAULDRON_V3);
        console.log("\nMIM available to borrow (BentoBox):", mimInBento);

        // Total borrows
        (uint128 elastic, uint128 base) = cauldron.totalBorrow();
        console.log("Total Borrowed (elastic):", elastic);
        console.log("Total Borrowed (base):", base);

        // Total collateral
        uint256 totalColl = cauldron.totalCollateralShare();
        console.log("Total Collateral Shares:", totalColl);

        // Exchange rate
        uint256 exchangeRate = cauldron.exchangeRate();
        console.log("Exchange Rate:", exchangeRate);

        // Collateralization rate
        uint256 collRate = cauldron.COLLATERIZATION_RATE();
        console.log("Collaterization Rate:", collRate);
        console.log("Collaterization Rate %:", collRate * 100 / 1e5);

        // Accrue info
        (uint64 lastAccrued, uint128 feesEarned, uint64 interestPerSec) = cauldron.accrueInfo();
        console.log("\nLast Accrued:", lastAccrued);
        console.log("Fees Earned:", feesEarned);
        console.log("Interest Per Second:", interestPerSec);

        console.log("\n--- ABRACADABRA VULNERABILITY ANALYSIS ---");

        // The Abracadabra exploit worked by:
        // 1. Using cook() to sequence multiple actions
        // 2. ACTION_CALL (30) to manipulate external state mid-cook
        // 3. Solvency only checked at END

        // Calculate potential profit
        // If we can borrow without sufficient collateral...

        // Max borrow = collateral * exchangeRate * collRate / 1e5
        // But we need to find a way to bypass solvency

        // Check if we can use ACTION_CALL (30)
        console.log("\nPotential attack via cook():");
        console.log("1. Deposit minimal collateral (ACTION 1)");
        console.log("2. Borrow MIM (ACTION 3)");
        console.log("3. Use borrowed MIM to manipulate oracle (ACTION 30)");
        console.log("4. Borrow more MIM at new rate (ACTION 3)");
        console.log("5. Solvency check at end might pass due to rate change");

        // Check oracle
        address oracle = cauldron.oracle();
        console.log("\nOracle:", oracle);

        // See if oracle can be manipulated in same tx
        console.log("Need to analyze oracle for same-tx manipulation...");
    }

    function testCauldronCookActions() public {
        console.log("=== CauldronV3 cook() Action Analysis ===");

        // Action constants from Abracadabra
        uint8 ACTION_ADD_COLLATERAL = 10;
        uint8 ACTION_REMOVE_COLLATERAL = 4;
        uint8 ACTION_BORROW = 5;
        uint8 ACTION_REPAY = 2;
        uint8 ACTION_CALL = 30;
        uint8 ACTION_BENTO_DEPOSIT = 20;
        uint8 ACTION_BENTO_WITHDRAW = 21;
        uint8 ACTION_BENTO_TRANSFER = 22;
        uint8 ACTION_BENTO_TRANSFER_MULTIPLE = 23;
        uint8 ACTION_BENTO_SETAPPROVAL = 24;
        uint8 ACTION_GET_REPAY_SHARE = 40;
        uint8 ACTION_GET_REPAY_PART = 41;

        console.log("Available cook() actions:");
        console.log("  ADD_COLLATERAL:", ACTION_ADD_COLLATERAL);
        console.log("  REMOVE_COLLATERAL:", ACTION_REMOVE_COLLATERAL);
        console.log("  BORROW:", ACTION_BORROW);
        console.log("  REPAY:", ACTION_REPAY);
        console.log("  CALL (external):", ACTION_CALL);
        console.log("  BENTO_DEPOSIT:", ACTION_BENTO_DEPOSIT);
        console.log("  BENTO_WITHDRAW:", ACTION_BENTO_WITHDRAW);

        // The key is ACTION_CALL (30) which allows arbitrary external calls
        console.log("\nACTION_CALL (30) is the key attack vector!");
        console.log("It allows arbitrary external calls mid-cook()");
        console.log("If oracle can be manipulated via this...");
    }

    /*//////////////////////////////////////////////////////////////
                    LIDO WITHDRAWAL QUEUE ANALYSIS
    //////////////////////////////////////////////////////////////*/

    function testLidoWithdrawalQueueAnalysis() public {
        console.log("=====================================================");
        console.log("LIDO WITHDRAWAL QUEUE - DEEP ANALYSIS");
        console.log("=====================================================");

        console.log("\nContract:", LIDO_QUEUE);
        console.log("ETH Balance:", LIDO_QUEUE.balance);

        // Get implementation address (it's a proxy)
        try IProxy(LIDO_QUEUE).proxy__getImplementation() returns (address impl) {
            console.log("Implementation:", impl);
        } catch {
            console.log("Could not get implementation via proxy__getImplementation");
        }

        // Try ERC1967 slot
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 implAddr = vm.load(LIDO_QUEUE, implSlot);
        console.log("Implementation (ERC1967 slot):", address(uint160(uint256(implAddr))));

        // Get queue state
        IWithdrawalQueue queue = IWithdrawalQueue(LIDO_QUEUE);

        try queue.getLastRequestId() returns (uint256 lastId) {
            console.log("\nLast Request ID:", lastId);
        } catch {
            console.log("Could not get last request ID");
        }

        try queue.getLastFinalizedRequestId() returns (uint256 finalizedId) {
            console.log("Last Finalized ID:", finalizedId);
        } catch {
            console.log("Could not get last finalized ID");
        }

        // Check stETH balance
        uint256 stEthBalance = IERC20(stETH).balanceOf(LIDO_QUEUE);
        console.log("stETH Balance:", stEthBalance);

        console.log("\n--- Potential Attack Vectors ---");
        console.log("1. Request manipulation (create/cancel abuse)");
        console.log("2. Finalization racing (front-running)");
        console.log("3. Share vs ETH calculation rounding");
        console.log("4. Queue index overflow/manipulation");
    }

    /*//////////////////////////////////////////////////////////////
                    BENTOBOX FLASH LOAN TEST
    //////////////////////////////////////////////////////////////*/

    function testBentoBoxFlashLoanCapability() public view {
        console.log("=== BentoBox Flash Loan Analysis ===");

        IBentoBox bento = IBentoBox(BENTOBOX);

        // Check available MIM for flash loan
        (uint128 elastic, uint128 base) = bento.totals(MIM);
        console.log("MIM in BentoBox:");
        console.log("  Elastic:", elastic);
        console.log("  Base:", base);

        uint256 mimBalance = IERC20(MIM).balanceOf(BENTOBOX);
        console.log("  Actual Balance:", mimBalance);

        console.log("\nFlash loan potential:");
        console.log("  Can flash loan up to:", mimBalance, "MIM");
        console.log("  Fee: 0.05% (BentoBox standard)");
    }

    /*//////////////////////////////////////////////////////////////
                    ORACLE MANIPULATION TEST
    //////////////////////////////////////////////////////////////*/

    function testOracleManipulation() public {
        console.log("=== Oracle Manipulation Analysis ===");

        ICauldron cauldron = ICauldron(CAULDRON_V3);
        address oracle = cauldron.oracle();

        console.log("Oracle Address:", oracle);

        // Check oracle type
        (bool success, bytes memory data) = oracle.staticcall(abi.encodeWithSignature("peekSpot(bytes)"));
        if (success && data.length >= 32) {
            uint256 spotPrice = abi.decode(data, (uint256));
            console.log("Spot Price:", spotPrice);
        }

        // Check if oracle uses DEX for pricing
        (success, data) = oracle.staticcall(abi.encodeWithSignature("source()"));
        if (success && data.length >= 32) {
            address source = abi.decode(data, (address));
            console.log("Oracle Source:", source);
        }

        // If oracle uses Curve/Uniswap pools, it might be manipulable
        console.log("\nOracle manipulation requires:");
        console.log("1. Oracle uses on-chain DEX price");
        console.log("2. DEX pool is manipulable with flash loan");
        console.log("3. cook() allows oracle update mid-execution");
    }
}
