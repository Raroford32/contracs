// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract RCSelectorsDeep is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    // Vault slot 5 address
    address constant VAULT_SLOT5 = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;

    // Address found at R0 CALL offset 9404
    address constant R0_CALL_TARGET = 0x58221220D7cDe93ae04c34a2F1e83dfd824afa92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_DecodeSuccessfulRCSelectors() public view {
        console.log("=== DECODING SUCCESSFUL RC SELECTORS ===\n");

        // These selectors returned success when called as attacker:
        // 0xc5d664c6, 0xe30c3978, 0x9fd0506d, 0xa5956078
        // 0x8da5cb5b (owner), 0x5c975abb (paused), 0x38a63183, 0x411557d1

        bytes4[] memory sels = new bytes4[](8);
        sels[0] = bytes4(0xc5d664c6);
        sels[1] = bytes4(0xe30c3978);
        sels[2] = bytes4(0x9fd0506d);
        sels[3] = bytes4(0xa5956078);
        sels[4] = bytes4(0x8da5cb5b); // owner
        sels[5] = bytes4(0x5c975abb); // paused
        sels[6] = bytes4(0x38a63183);
        sels[7] = bytes4(0x411557d1);

        // Try to determine what they return
        for (uint i = 0; i < sels.length; i++) {
            (bool s, bytes memory d) = REDEMPTION_CONTROLLER.staticcall(
                abi.encodeWithSelector(sels[i])
            );
            if (s) {
                console.log("Selector", i, ":");
                console.logBytes4(sels[i]);
                if (d.length == 32) {
                    uint256 val = abi.decode(d, (uint256));
                    if (val == 0 || val == 1) {
                        console.log("  Bool/Flag:", val);
                    } else if (val < type(uint160).max && val > 0x1000) {
                        console.log("  Address:", address(uint160(val)));
                    } else {
                        console.log("  Value:", val);
                    }
                } else {
                    console.log("  Return length:", d.length);
                    console.logBytes(d);
                }
            }
        }

        // Try common function signatures to match
        console.log("\nMatching known signatures:");
        console.log("wstETH():");
        console.logBytes4(bytes4(keccak256("wstETH()")));
        console.log("pendingOwner():");
        console.logBytes4(bytes4(keccak256("pendingOwner()")));
        console.log("paused():");
        console.logBytes4(bytes4(keccak256("paused()")));
        console.log("redemptions(address):");
        console.logBytes4(bytes4(keccak256("redemptions(address)")));
        console.log("getRedemption(address):");
        console.logBytes4(bytes4(keccak256("getRedemption(address)")));
        console.log("vault():");
        console.logBytes4(bytes4(keccak256("vault()")));
        console.log("asset():");
        console.logBytes4(bytes4(keccak256("asset()")));
        console.log("totalRedemptions():");
        console.logBytes4(bytes4(keccak256("totalRedemptions()")));
    }

    function test_InvestigateVaultSlot5() public {
        console.log("=== INVESTIGATING VAULT SLOT 5 ADDRESS ===\n");

        console.log("Address:", VAULT_SLOT5);
        console.log("Code size:", VAULT_SLOT5.code.length);

        if (VAULT_SLOT5.code.length > 0) {
            console.log("Has code - analyzing...");

            // Check storage
            console.log("\nStorage:");
            for (uint i = 0; i < 10; i++) {
                bytes32 slot = vm.load(VAULT_SLOT5, bytes32(i));
                if (slot != bytes32(0)) {
                    console.log("Slot", i, ":");
                    console.logBytes32(slot);
                }
            }

            // Try common view functions
            bytes4[] memory viewSels = new bytes4[](10);
            viewSels[0] = bytes4(keccak256("owner()"));
            viewSels[1] = bytes4(keccak256("name()"));
            viewSels[2] = bytes4(keccak256("vault()"));
            viewSels[3] = bytes4(keccak256("asset()"));
            viewSels[4] = bytes4(keccak256("redemptionController()"));
            viewSels[5] = bytes4(keccak256("balanceOf(address)"));
            viewSels[6] = bytes4(keccak256("totalSupply()"));
            viewSels[7] = bytes4(keccak256("implementation()"));
            viewSels[8] = bytes4(keccak256("admin()"));
            viewSels[9] = bytes4(keccak256("allowance(address,address)"));

            console.log("\nView functions:");
            for (uint i = 0; i < viewSels.length; i++) {
                (bool s, bytes memory d) = VAULT_SLOT5.staticcall(
                    abi.encodeWithSelector(viewSels[i], attacker, attacker)
                );
                if (s && d.length >= 32) {
                    console.log("Found:");
                    console.logBytes4(viewSels[i]);
                }
            }

            // Is this address registered in RC?
            bytes32 regKey = keccak256(abi.encode(VAULT_SLOT5, uint256(4)));
            bytes32 regVal = vm.load(REDEMPTION_CONTROLLER, regKey);
            console.log("\nRC registration:", uint256(regVal));

            // Can it call RC.redeem?
            vm.startPrank(VAULT_SLOT5);
            (bool s1,) = REDEMPTION_CONTROLLER.call(
                abi.encodeWithSignature("redeem(uint256,address)", 1000e18, attacker)
            );
            console.log("\nCan call RC.redeem:", s1);
            vm.stopPrank();

            if (IERC20(wstETH).balanceOf(attacker) > 0) {
                console.log("*** VAULT_SLOT5 CAN DRAIN! ***");
            }
        }
    }

    function test_InvestigateR0CallTarget() public {
        console.log("=== INVESTIGATING R0 CALL TARGET ===\n");

        console.log("Address:", R0_CALL_TARGET);
        console.log("Code size:", R0_CALL_TARGET.code.length);

        if (R0_CALL_TARGET.code.length > 0) {
            console.log("Has code - analyzing...");

            // This is an external contract that R0 calls
            // Could be a dependency we can manipulate

            // Check storage
            console.log("\nStorage:");
            for (uint i = 0; i < 10; i++) {
                bytes32 slot = vm.load(R0_CALL_TARGET, bytes32(i));
                if (slot != bytes32(0)) {
                    console.log("Slot", i, ":");
                    console.logBytes32(slot);
                }
            }

            // Check if it's a proxy
            bytes32 implSlot = vm.load(R0_CALL_TARGET, bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));
            if (implSlot != bytes32(0)) {
                console.log("\nEIP-1967 implementation:", address(uint160(uint256(implSlot))));
            }

            // Try calling functions on it
            console.log("\nTrying functions:");
            bytes4[] memory sels = new bytes4[](15);
            sels[0] = bytes4(keccak256("owner()"));
            sels[1] = bytes4(keccak256("getPrice()"));
            sels[2] = bytes4(keccak256("latestAnswer()"));
            sels[3] = bytes4(keccak256("rate()"));
            sels[4] = bytes4(keccak256("exchangeRate()"));
            sels[5] = bytes4(keccak256("conversionRate()"));
            sels[6] = bytes4(keccak256("getRate()"));
            sels[7] = bytes4(keccak256("decimals()"));
            sels[8] = bytes4(keccak256("version()"));
            sels[9] = bytes4(keccak256("description()"));
            sels[10] = bytes4(keccak256("asset()"));
            sels[11] = bytes4(keccak256("underlying()"));
            sels[12] = bytes4(keccak256("totalAssets()"));
            sels[13] = bytes4(keccak256("convertToAssets(uint256)"));
            sels[14] = bytes4(keccak256("convertToShares(uint256)"));

            for (uint i = 0; i < sels.length; i++) {
                (bool s, bytes memory d) = R0_CALL_TARGET.staticcall(
                    abi.encodeWithSelector(sels[i], 1e18)
                );
                if (s && d.length >= 32) {
                    console.log("Found:");
                    console.logBytes4(sels[i]);
                    uint256 val = abi.decode(d, (uint256));
                    console.log("  Value:", val);
                }
            }
        } else {
            console.log("NO CODE - potential CREATE2 target or dead address");
        }
    }

    function test_FindR0StorageModificationFunctions() public {
        console.log("=== FINDING R0 STORAGE MODIFICATION FUNCTIONS ===\n");

        // We need to find a function in R0 that can modify redemption storage
        // without proper authorization

        bytes memory code = REDEMPTION_0.code;

        // Find all selectors in R0
        console.log("All selectors in R0:");
        bytes4[] memory foundSels = new bytes4[](50);
        uint selCount = 0;

        for (uint i = 0; i + 4 < 500 && i < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));

                bool isSelector = false;
                for (uint j = i + 5; j < i + 15 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x14) {
                        isSelector = true;
                        break;
                    }
                }

                if (isSelector && sel != bytes4(0) && uint32(sel) > 0x1000) {
                    bool unique = true;
                    for (uint k = 0; k < selCount; k++) {
                        if (foundSels[k] == sel) unique = false;
                    }
                    if (unique && selCount < 50) {
                        foundSels[selCount] = sel;
                        selCount++;
                        console.logBytes4(sel);
                    }
                }
            }
        }

        // Match known function signatures
        console.log("\n=== MATCHING KNOWN SIGNATURES ===");
        console.log("redeem(uint96):");
        console.logBytes4(bytes4(keccak256("redeem(uint96)")));
        console.log("finalizeRedeem(uint256):");
        console.logBytes4(bytes4(keccak256("finalizeRedeem(uint256)")));
        console.log("cancelRedeem(uint256):");
        console.logBytes4(bytes4(keccak256("cancelRedeem(uint256)")));
        console.log("setRedemption(address,uint256):");
        console.logBytes4(bytes4(keccak256("setRedemption(address,uint256)")));
        console.log("updateRedemption(uint256,uint256):");
        console.logBytes4(bytes4(keccak256("updateRedemption(uint256,uint256)")));
        console.log("emergencyRedeem(uint256):");
        console.logBytes4(bytes4(keccak256("emergencyRedeem(uint256)")));
        console.log("adminRedeem(address,uint256):");
        console.logBytes4(bytes4(keccak256("adminRedeem(address,uint256)")));
        console.log("execute(address,bytes):");
        console.logBytes4(bytes4(keccak256("execute(address,bytes)")));
        console.log("multicall(bytes[]):");
        console.logBytes4(bytes4(keccak256("multicall(bytes[])")));

        // Try calling all found selectors with attacker to find state-changing ones
        console.log("\n=== TESTING STATE-CHANGING SELECTORS ===");

        vm.startPrank(attacker);

        deal(TASSET, attacker, 100000e18);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        for (uint i = 0; i < selCount; i++) {
            bytes32 storageBefore = vm.load(REDEMPTION_0, bytes32(uint256(0)));

            (bool s,) = REDEMPTION_0.call{gas: 500000}(
                abi.encodeWithSelector(foundSels[i], attacker, uint256(1000e18), uint256(0))
            );

            bytes32 storageAfter = vm.load(REDEMPTION_0, bytes32(uint256(0)));

            if (s) {
                console.log("\nSUCCESS:");
                console.logBytes4(foundSels[i]);
                if (storageBefore != storageAfter) {
                    console.log("  *** STORAGE CHANGED! ***");
                }
            }
        }

        vm.stopPrank();
    }

    function test_AnalyzeRedemptionTimestampStorage() public {
        console.log("=== ANALYZING REDEMPTION TIMESTAMP STORAGE ===\n");

        // From previous test, the redemption struct storage is:
        // elem0: 0x0000000000000000000000000000003635c9adc5dea0000000000000696a6577
        //        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ amount (1000e18)    ^^^^^^^^ timestamp

        // The timestamp is in the lower 4 bytes
        // We need to find if there's any function that can modify this

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        // Create redemption
        REDEMPTION_0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        vm.stopPrank();

        // Get the storage location
        bytes32 arrayBase = keccak256(abi.encode(attacker, uint256(5)));
        bytes32 elemBase = keccak256(abi.encodePacked(arrayBase));

        bytes32 elem0 = vm.load(REDEMPTION_0, elemBase);
        console.log("Original elem0:");
        console.logBytes32(elem0);

        uint256 amount = (uint256(elem0) >> 32) & ((1 << 96) - 1);
        uint256 timestamp = uint256(elem0) & 0xFFFFFFFF;

        console.log("Decoded amount:", amount / 1e18);
        console.log("Decoded timestamp:", timestamp);
        console.log("Current time:", block.timestamp);
        console.log("Time until mature:", timestamp > block.timestamp ? timestamp - block.timestamp : 0);

        // Can we call cancelRedeem to modify the struct?
        console.log("\n=== TESTING CANCEL AND REREDEEM ===");

        vm.startPrank(attacker);

        // Try cancel
        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("cancelRedeem(uint256)", 0)
        );
        console.log("cancelRedeem:", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        // Check balance
        console.log("TASSET balance after cancel attempt:", IERC20(TASSET).balanceOf(attacker) / 1e18);

        vm.stopPrank();

        // Check if storage changed
        bytes32 elem0After = vm.load(REDEMPTION_0, elemBase);
        console.log("\nElem0 after cancel attempt:");
        console.logBytes32(elem0After);

        if (elem0 != elem0After) {
            console.log("*** STORAGE CHANGED! ***");
        }
    }

    function test_CheckAllR0DelegatecallTargets() public view {
        console.log("=== CHECKING ALL R0 DELEGATECALL TARGETS ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Find all DELEGATECALL and what they target
        console.log("DELEGATECALL operations:");
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) { // DELEGATECALL
                console.log("\nDELEGATECALL at offset:", i);

                // Look back for SLOAD which loads the target
                for (uint j = (i > 50 ? i - 50 : 0); j < i; j++) {
                    if (uint8(code[j]) == 0x54) { // SLOAD
                        console.log("  SLOAD at:", j);

                        // Find what slot is loaded
                        for (uint k = j - 1; k > j - 10 && k < code.length; k--) {
                            uint8 op = uint8(code[k]);
                            if (op >= 0x60 && op <= 0x65) { // PUSH1-PUSH6
                                uint8 size = op - 0x5f;
                                uint256 slotNum = 0;
                                for (uint l = 0; l < size && k + 1 + l < code.length; l++) {
                                    slotNum = slotNum << 8 | uint8(code[k + 1 + l]);
                                }
                                console.log("  Loading from slot:", slotNum);

                                // Check what's in that slot
                                bytes32 slotVal = vm.load(REDEMPTION_0, bytes32(slotNum));
                                if (slotVal != bytes32(0)) {
                                    console.log("  Slot value:");
                                    console.logBytes32(slotVal);
                                    address target = address(uint160(uint256(slotVal)));
                                    if (target != address(0)) {
                                        console.log("  Target address:", target);
                                        console.log("  Target code size:", target.code.length);
                                    }
                                }
                                break;
                            }
                        }
                    }
                }
            }
        }
    }

    function test_ExploitViaDelegatecallTargetManipulation() public {
        console.log("=== TESTING DELEGATECALL TARGET MANIPULATION ===\n");

        // The DELEGATECALL at offset 5323 loads target from a storage slot
        // If we can control that slot, we can redirect the delegatecall

        // First, find which slot
        bytes memory code = REDEMPTION_0.code;

        // Around 5323, look for the pattern
        console.log("Bytecode around DELEGATECALL at 5323:");
        for (uint i = 5280; i < 5350 && i < code.length; i++) {
            uint8 op = uint8(code[i]);
            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0xf4) console.log(i, "DELEGATECALL");
            if (op >= 0x60 && op <= 0x65) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                if (val < 100) console.log(i, "PUSH slot:", val);
            }
        }

        // Slots 29 and others might be targets
        // Check what's currently in slot 29
        bytes32 slot29 = vm.load(REDEMPTION_0, bytes32(uint256(29)));
        console.log("\nSlot 29 value:");
        console.logBytes32(slot29);

        // If we can set slot 29 to our malicious contract...
        // But how? Look for SSTORE to slot 29

        console.log("\nSearching for SSTORE to low slots:");
        for (uint i = 0; i < code.length - 5; i++) {
            if (uint8(code[i]) == 0x55) { // SSTORE
                // Look back for slot number
                for (uint j = i - 1; j > (i > 20 ? i - 20 : 0); j--) {
                    uint8 op = uint8(code[j]);
                    if (op >= 0x60 && op <= 0x62) { // PUSH1-3
                        uint8 size = op - 0x5f;
                        uint256 slotNum = 0;
                        for (uint k = 0; k < size && j + 1 + k < code.length; k++) {
                            slotNum = slotNum << 8 | uint8(code[j + 1 + k]);
                        }
                        if (slotNum < 50) {
                            console.log("SSTORE to slot", slotNum, "at offset", i);
                        }
                        break;
                    }
                }
            }
        }
    }
}
