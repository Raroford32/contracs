// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

contract WhitelistBypass is Test {
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant UNKNOWN_CONTRACT = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_DecodeErrorSelector() public pure {
        console.log("=== DECODING ERROR 0xa0927dc3 ===\n");

        // Common whitelist-related errors
        bytes4 err1 = bytes4(keccak256("NotWhitelisted()"));
        bytes4 err2 = bytes4(keccak256("WhitelistOnly()"));
        bytes4 err3 = bytes4(keccak256("NotInWhitelist()"));
        bytes4 err4 = bytes4(keccak256("AddressNotWhitelisted()"));
        bytes4 err5 = bytes4(keccak256("SenderNotWhitelisted()"));
        bytes4 err6 = bytes4(keccak256("CallerNotWhitelisted()"));
        bytes4 err7 = bytes4(keccak256("InWhitelistOnlyMode()"));
        bytes4 err8 = bytes4(keccak256("WhitelistModeEnabled()"));

        console.log("NotWhitelisted():");
        console.logBytes4(err1);
        console.log("WhitelistOnly():");
        console.logBytes4(err2);
        console.log("NotInWhitelist():");
        console.logBytes4(err3);
        console.log("AddressNotWhitelisted():");
        console.logBytes4(err4);
        console.log("SenderNotWhitelisted():");
        console.logBytes4(err5);
        console.log("CallerNotWhitelisted():");
        console.logBytes4(err6);
        console.log("InWhitelistOnlyMode():");
        console.logBytes4(err7);
        console.log("WhitelistModeEnabled():");
        console.logBytes4(err8);

        console.log("\nTarget error: 0xa0927dc3");
    }

    function test_AnalyzeUnknownContract() public view {
        console.log("=== ANALYZING UNKNOWN CONTRACT ===\n");

        // 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8
        console.log("Unknown contract:", UNKNOWN_CONTRACT);
        console.log("Code size:", UNKNOWN_CONTRACT.code.length);

        if (UNKNOWN_CONTRACT.code.length > 0) {
            bytes memory code = UNKNOWN_CONTRACT.code;

            // Count opcodes
            uint256 delegatecallCount = 0;
            uint256 callCount = 0;
            uint256 staticcallCount = 0;

            for (uint i = 0; i < code.length; i++) {
                if (uint8(code[i]) == 0xf4) delegatecallCount++;
                if (uint8(code[i]) == 0xf1) callCount++;
                if (uint8(code[i]) == 0xfa) staticcallCount++;
            }

            console.log("DELEGATECALL:", delegatecallCount);
            console.log("CALL:", callCount);
            console.log("STATICCALL:", staticcallCount);

            // Check for transfer/transferFrom selectors
            bytes4 transferSel = bytes4(0xa9059cbb);
            bytes4 transferFromSel = bytes4(0x23b872dd);

            for (uint i = 0; i + 3 < code.length; i++) {
                bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
                if (sel == transferSel) {
                    console.log("Has transfer at:", i);
                }
                if (sel == transferFromSel) {
                    console.log("Has transferFrom at:", i);
                }
            }
        }

        // Check storage
        console.log("\nChecking storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(UNKNOWN_CONTRACT, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // Check EIP-1967 slots
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 implValue = vm.load(UNKNOWN_CONTRACT, implSlot);
        if (implValue != bytes32(0)) {
            console.log("\nIs PROXY! Implementation:");
            console.logBytes32(implValue);
        }
    }

    function test_FindWhitelistMapping() public view {
        console.log("=== FINDING WHITELIST MAPPING IN REDEMPTION ===\n");

        // Try different slot bases for whitelist mapping
        address owner = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

        for (uint base = 0; base < 20; base++) {
            // mapping(address => bool) pattern
            bytes32 keyAttacker = keccak256(abi.encode(attacker, base));
            bytes32 valueAttacker = vm.load(REDEMPTION_0, keyAttacker);

            bytes32 keyOwner = keccak256(abi.encode(owner, base));
            bytes32 valueOwner = vm.load(REDEMPTION_0, keyOwner);

            if (valueOwner != bytes32(0)) {
                console.log("Base slot", base, "has owner entry:");
                console.logBytes32(valueOwner);
            }
        }
    }

    function test_TryRedeemAsWhitelistedUser() public {
        console.log("=== TRYING TO REDEEM AS WHITELISTED USER ===\n");

        // Find a whitelisted user
        // The contract owner is likely whitelisted
        address owner = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

        deal(IAU, owner, 1000e18);

        vm.startPrank(owner);

        console.log("Owner IAU balance:", IERC20(IAU).balanceOf(owner) / 1e18);

        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        console.log("\nTrying redeem as owner...");
        (bool success, bytes memory data) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("Success:", success);
        if (!success) {
            console.log("Error:");
            console.logBytes4(bytes4(data));
        }

        vm.stopPrank();
    }

    function test_CheckIfWhitelistCanBeDisabled() public {
        console.log("=== CHECKING IF WHITELIST CAN BE DISABLED ===\n");

        // Look for setWhitelistEnabled, disableWhitelist, etc.
        bytes memory code = REDEMPTION_0.code;

        bytes4[] memory selectors = new bytes4[](10);
        selectors[0] = bytes4(keccak256("setWhitelistEnabled(bool)"));
        selectors[1] = bytes4(keccak256("disableWhitelist()"));
        selectors[2] = bytes4(keccak256("enableWhitelist()"));
        selectors[3] = bytes4(keccak256("setWhitelistOnly(bool)"));
        selectors[4] = bytes4(keccak256("toggleWhitelist()"));
        selectors[5] = bytes4(keccak256("addToWhitelist(address)"));
        selectors[6] = bytes4(keccak256("removeFromWhitelist(address)"));
        selectors[7] = bytes4(keccak256("setWhitelist(address,bool)"));
        selectors[8] = bytes4(keccak256("updateWhitelist(address,bool)"));
        selectors[9] = bytes4(keccak256("whitelistAdd(address)"));

        string[10] memory names = [
            "setWhitelistEnabled",
            "disableWhitelist",
            "enableWhitelist",
            "setWhitelistOnly",
            "toggleWhitelist",
            "addToWhitelist",
            "removeFromWhitelist",
            "setWhitelist",
            "updateWhitelist",
            "whitelistAdd"
        ];

        console.log("Searching for whitelist management functions:");

        for (uint s = 0; s < selectors.length; s++) {
            for (uint i = 0; i + 3 < code.length; i++) {
                bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
                if (sel == selectors[s]) {
                    console.log("  Found:", names[s]);
                    console.logBytes4(selectors[s]);
                    break;
                }
            }
        }
    }

    function test_FindMerkleProofPattern() public view {
        console.log("=== CHECKING FOR MERKLE PROOF WHITELIST ===\n");

        // Some protocols use Merkle proofs for whitelisting
        // Look for keccak256 and verify patterns

        bytes memory code = REDEMPTION_0.code;

        // Count SHA3 operations (keccak256 in EVM)
        uint256 sha3Count = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0x20) sha3Count++; // SHA3 opcode
        }
        console.log("SHA3 (keccak256) operations:", sha3Count);

        // Look for merkle-related selectors
        bytes4[] memory merkleSelectors = new bytes4[](5);
        merkleSelectors[0] = bytes4(keccak256("verifyProof(bytes32[],bytes32,bytes32)"));
        merkleSelectors[1] = bytes4(keccak256("merkleRoot()"));
        merkleSelectors[2] = bytes4(keccak256("setMerkleRoot(bytes32)"));
        merkleSelectors[3] = bytes4(keccak256("redeem(uint96,bytes32[])"));
        merkleSelectors[4] = bytes4(keccak256("redeemWithProof(uint96,bytes32[])"));

        console.log("\nSearching for merkle-related selectors:");
        for (uint s = 0; s < merkleSelectors.length; s++) {
            for (uint i = 0; i + 3 < code.length; i++) {
                bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
                if (sel == merkleSelectors[s]) {
                    console.log("  Found at offset:", i);
                    console.logBytes4(merkleSelectors[s]);
                }
            }
        }
    }

    function test_AnalyzeRedemptionCalldata() public view {
        console.log("=== ANALYZING REDEMPTION CALLDATA PATTERNS ===\n");

        // The redeem function might take more params
        // Let's look for different redeem signatures
        
        bytes4[] memory redeemSelectors = new bytes4[](10);
        redeemSelectors[0] = bytes4(keccak256("redeem(uint96)"));
        redeemSelectors[1] = bytes4(keccak256("redeem(uint256)"));
        redeemSelectors[2] = bytes4(keccak256("redeem(uint96,address)"));
        redeemSelectors[3] = bytes4(keccak256("redeem(uint256,address)"));
        redeemSelectors[4] = bytes4(keccak256("redeem(uint96,bytes)"));
        redeemSelectors[5] = bytes4(keccak256("redeem(uint96,bytes32[])"));
        redeemSelectors[6] = bytes4(keccak256("redeem(uint256,bytes32[])"));
        redeemSelectors[7] = bytes4(keccak256("redeem(address,uint96)"));
        redeemSelectors[8] = bytes4(keccak256("redeemTo(uint96,address)"));
        redeemSelectors[9] = bytes4(keccak256("redeemFor(address,uint96)"));

        console.log("Known redeem selector: 0x7630c4a8");

        console.log("\nChecking various redeem signatures:");
        for (uint i = 0; i < redeemSelectors.length; i++) {
            console.logBytes4(redeemSelectors[i]);
        }

        // Check bytecode for all PUSH4 that could be selectors
        bytes memory code = REDEMPTION_0.code;
        
        console.log("\nRedemption function selectors in bytecode:");
        for (uint i = 0; i + 5 < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 selector = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                
                // Check if it matches any redeem pattern
                for (uint j = 0; j < redeemSelectors.length; j++) {
                    if (selector == redeemSelectors[j]) {
                        console.log("  Found redeem variant at:", i);
                        console.logBytes4(selector);
                    }
                }
            }
        }
    }

    function test_CheckRedemption1() public {
        console.log("=== CHECKING REDEMPTION 1 ===\n");

        // Maybe Redemption 1 has different whitelist settings

        deal(IAU, attacker, 1000e18);

        vm.startPrank(attacker);

        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        console.log("Trying redeem on Redemption 1...");
        (bool success, bytes memory data) = REDEMPTION_1.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("Success:", success);
        if (!success) {
            console.log("Error:");
            console.logBytes4(bytes4(data));
        }

        vm.stopPrank();
    }
}
