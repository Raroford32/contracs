// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IFraxEtherRedemptionQueue {
    function redemptionQueueState() external view returns (uint64, uint64, uint64, uint64);
    function redemptionQueueAccounting() external view returns (uint128 etherLiabilities, uint128 unclaimedFees);
    function nftInformation(uint256 nftId) external view returns (bool hasBeenRedeemed, uint64 maturity, uint120 amount, uint64 earlyExitFee);
    function ownerOf(uint256 tokenId) external view returns (address);
    function enterRedemptionQueue(address _recipient, uint120 _amountToRedeem) external returns (uint256);
    function burnRedemptionTicketNft(uint256 _nftId, address payable _recipient) external;
    function earlyBurnRedemptionTicketNft(address payable _recipient, uint256 _nftId) external returns (uint120);
    function timelockAddress() external view returns (address);
    function operatorAddress() external view returns (address);
    function getApproved(uint256 tokenId) external view returns (address);
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract FraxQueueDeepAnalysisTest is Test {
    address constant FRAX_QUEUE = 0x82bA8da44Cd5261762e629dd5c605b17715727bd;
    address constant FRXETH = 0x5E8422345238F34275888049021821E8E08CAa1f;
    
    IFraxEtherRedemptionQueue queue;
    
    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        queue = IFraxEtherRedemptionQueue(FRAX_QUEUE);
    }
    
    function testFindMatureNFTOwners() public view {
        console.log("=== FINDING MATURE NFT HOLDERS ===");
        
        (uint64 nextNftId,,,) = queue.redemptionQueueState();
        
        uint256 count = 0;
        for (uint256 i = 0; i < nextNftId && count < 20; i++) {
            (bool hasBeenRedeemed, uint64 maturity, uint120 amount,) = queue.nftInformation(i);
            
            if (!hasBeenRedeemed && amount > 0 && block.timestamp >= maturity) {
                try queue.ownerOf(i) returns (address owner) {
                    console.log("\nNFT ID:", i);
                    console.log("Owner:", owner);
                    console.log("Amount:", amount / 1e18, "ETH");
                    console.log("Maturity:", maturity);
                    count++;
                } catch {}
            }
        }
    }
    
    // Test: Can we exploit by sandwich attacking a redemption?
    function testSandwichRedemption() public {
        console.log("=== SANDWICH ATTACK ANALYSIS ===");
        
        // Get state before
        uint256 ethBefore = FRAX_QUEUE.balance;
        (uint128 liabBefore,) = queue.redemptionQueueAccounting();
        
        console.log("ETH Balance:", ethBefore / 1e18);
        console.log("Liabilities:", uint256(liabBefore) / 1e18);
        
        // The issue: When someone redeems, the contract ETH decreases
        // If we could trigger many redemptions atomically, we could drain the contract
        // But we need to own NFTs to redeem them
        
        console.log("\nConclusion: Cannot sandwich without owning NFTs");
    }
    
    // Test: Check if there's any callable function we can abuse
    function testCheckCallableFunctions() public {
        console.log("=== CHECKING CALLABLE FUNCTIONS ===");
        
        // Check operator permissions
        address operator = queue.operatorAddress();
        address timelock = queue.timelockAddress();
        
        console.log("Operator:", operator);
        console.log("Timelock:", timelock);
        
        // Operator can:
        // - setQueueLengthSecs
        // - setRedemptionFee
        // - setEarlyExitFee
        // - recoverErc20 (only unclaimedFees)
        // - pause/unpause
        
        // Timelock can:
        // - recoverEther (only excess ETH)
        // - setOperatorAddress
        
        // Neither can be called by unprivileged attacker
        console.log("\nNo callable functions for unprivileged attacker");
    }
    
    // Test: Early exit economic analysis
    function testEarlyExitEconomics() public view {
        console.log("=== EARLY EXIT ECONOMICS ===");
        
        (,, uint64 redemptionFee, uint64 earlyExitFee) = queue.redemptionQueueState();
        
        // If someone enters the queue and immediately early exits,
        // they get frxETH back minus fees
        
        // Calculate: 100 frxETH -> enter -> early exit -> how much frxETH?
        uint256 testAmount = 100e18;
        uint256 afterRedemptionFee = testAmount * (1e6 - redemptionFee) / 1e6;
        uint256 afterEarlyExitFee = afterRedemptionFee * (1e6 - earlyExitFee) / 1e6;
        
        console.log("Input: 100 frxETH");
        console.log("After redemption fee:", afterRedemptionFee / 1e18, "ETH value minted");
        console.log("After early exit fee:", afterEarlyExitFee / 1e18, "frxETH back");
        console.log("Loss:", (testAmount - afterEarlyExitFee) * 100 / testAmount, "% loss");
        
        // Check frxETH/ETH exchange rate on Curve
        // If frxETH trades at a discount, maybe there's arbitrage?
        console.log("\nNote: Need to check frxETH/ETH rate for potential arbitrage");
    }
}
