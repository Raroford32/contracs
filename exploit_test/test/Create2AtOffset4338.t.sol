// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract Create2AtOffset4338 is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeCreate2At4338() public view {
        console.log("=== ANALYZING CREATE2 AT 4338 WITH CALLER ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Detailed analysis from 4200 to 4400
        console.log("Bytecode from 4200-4400:");

        uint i = 4200;
        while (i < 4400 && i < code.length) {
            uint8 op = uint8(code[i]);
            uint skipBytes = 0;

            string memory opName;
            if (op == 0x00) opName = "STOP";
            if (op == 0x01) opName = "ADD";
            if (op == 0x14) opName = "EQ";
            if (op == 0x15) opName = "ISZERO";
            if (op == 0x20) opName = "SHA3";
            if (op == 0x30) opName = "ADDRESS";
            if (op == 0x33) opName = "CALLER";
            if (op == 0x34) opName = "CALLVALUE";
            if (op == 0x35) opName = "CALLDATALOAD";
            if (op == 0x36) opName = "CALLDATASIZE";
            if (op == 0x39) opName = "CODECOPY";
            if (op == 0x3b) opName = "EXTCODESIZE";
            if (op == 0x3c) opName = "EXTCODECOPY";
            if (op == 0x51) opName = "MLOAD";
            if (op == 0x52) opName = "MSTORE";
            if (op == 0x54) opName = "SLOAD";
            if (op == 0x55) opName = "SSTORE";
            if (op == 0x56) opName = "JUMP";
            if (op == 0x57) opName = "JUMPI";
            if (op == 0x5b) opName = "JUMPDEST";
            if (op == 0x80) opName = "DUP1";
            if (op == 0x81) opName = "DUP2";
            if (op == 0x82) opName = "DUP3";
            if (op == 0x90) opName = "SWAP1";
            if (op == 0x91) opName = "SWAP2";
            if (op == 0xf0) opName = "CREATE";
            if (op == 0xf1) opName = "CALL";
            if (op == 0xf3) opName = "RETURN";
            if (op == 0xf4) opName = "DELEGATECALL";
            if (op == 0xf5) opName = "CREATE2";
            if (op == 0xfd) opName = "REVERT";

            if (bytes(opName).length > 0) {
                console.log(i, opName);
            }

            if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                if (size == 32) {
                    console.log(i, "PUSH32:");
                    console.logBytes32(bytes32(val));
                } else if (size == 4) {
                    console.log(i, "PUSH4:");
                    console.logBytes4(bytes4(uint32(val)));
                } else if (size <= 4 && val < 10000) {
                    console.log(i, "PUSH:", val);
                } else if (size == 20) {
                    console.log(i, "PUSH20:", address(uint160(val)));
                }
                skipBytes = size;
            }

            i += 1 + skipBytes;
        }
    }

    function test_WhatIsSlot32() public view {
        console.log("=== CHECKING SLOT 32 IN REDEMPTION_1 ===\n");

        bytes32 slot32 = vm.load(REDEMPTION_1, bytes32(uint256(32)));
        console.log("Slot 32:");
        console.logBytes32(slot32);

        address addr32 = address(uint160(uint256(slot32)));
        console.log("As address:", addr32);

        if (addr32.code.length > 0) {
            console.log("Code size:", addr32.code.length);
        }

        // Check surrounding slots
        console.log("\nSurrounding slots:");
        for (uint s = 28; s < 40; s++) {
            bytes32 slot = vm.load(REDEMPTION_1, bytes32(s));
            if (slot != bytes32(0)) {
                console.log("Slot", s, ":");
                console.logBytes32(slot);
            }
        }
    }

    function test_FindFunctionThatCallsCreate2At4338() public view {
        console.log("=== FINDING FUNCTION FOR CREATE2 AT 4338 ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Find JUMPDEST that leads to 4338
        // The function dispatcher at the beginning jumps to different functions
        // We need to find which selector leads to code around 4338

        // Find JUMPDESTs near 4338
        console.log("JUMPDESTs near 4338:");
        for (uint i = 4000; i < 4400 && i < code.length; i++) {
            if (uint8(code[i]) == 0x5b) {
                console.log("JUMPDEST at:", i);
            }
        }

        // Now trace from function selectors to see which one reaches 4338
        // First, get all selectors
        console.log("\nFunction selectors in R1:");
        bytes4[] memory found = new bytes4[](30);
        uint count = 0;

        for (uint i = 0; i + 4 < 300 && i < code.length && count < 30; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                bool isSelector = false;
                for (uint j = i + 5; j < i + 15 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x14) {
                        isSelector = true;
                        break;
                    }
                }
                if (isSelector && sel != bytes4(0) && uint32(sel) > 0x1000) {
                    bool unique = true;
                    for (uint k = 0; k < count; k++) {
                        if (found[k] == sel) unique = false;
                    }
                    if (unique) {
                        found[count] = sel;
                        count++;
                        console.logBytes4(sel);
                    }
                }
            }
        }

        // Known selectors to check
        console.log("\nKnown selectors:");
        console.log("redeem(uint96):");
        console.logBytes4(bytes4(keccak256("redeem(uint96)")));
        console.log("finalizeRedeem(uint256):");
        console.logBytes4(bytes4(keccak256("finalizeRedeem(uint256)")));
        console.log("claimRewards():");
        console.logBytes4(bytes4(keccak256("claimRewards()")));
        console.log("claimRewards(address):");
        console.logBytes4(bytes4(keccak256("claimRewards(address)")));
    }

    function test_TriggerCreate2Path() public {
        console.log("=== TRYING TO TRIGGER CREATE2 PATH ===\n");

        // The CREATE2 at 4338 uses CALLER
        // It might be triggered by claimRewards or similar

        deal(TASSET, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(REDEMPTION_1, type(uint256).max);

        // First create a redemption
        console.log("Creating redemption...");
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("redeem:", s1);
        if (!s1 && d1.length >= 4) console.logBytes4(bytes4(d1));

        vm.stopPrank();

        // Check if a proxy was created
        // The proxy address would be computed as:
        // CREATE2 = keccak256(0xff ++ deployer ++ salt ++ init_code_hash)[12:]

        // If CALLER is part of salt, we can predict addresses
        console.log("\nChecking for attacker-specific proxy:");

        // Try different salt patterns
        // Pattern 1: Just CALLER
        bytes32 salt1 = bytes32(uint256(uint160(attacker)));
        console.log("Salt pattern 1 (CALLER):");
        console.logBytes32(salt1);

        // We'd need the init code hash to compute the address
        // Let's try to find it in the bytecode

        bytes memory code = REDEMPTION_1.code;
        console.log("\nSearching for PUSH32 (init code hash) before CREATE2 at 4338:");
        for (uint i = 4200; i < 4338 && i < code.length; i++) {
            if (uint8(code[i]) == 0x7f) { // PUSH32
                bytes32 hash;
                for (uint j = 0; j < 32 && i + 1 + j < code.length; j++) {
                    hash = bytes32(uint256(hash) << 8 | uint8(code[i + 1 + j]));
                }
                console.log("PUSH32 at", i, ":");
                console.logBytes32(hash);
            }
        }
    }

    function test_ClaimRewardsCreate2() public {
        console.log("=== TESTING CLAIM REWARDS CREATE2 ===\n");

        // The CREATE2 at 4338 might be in a rewards claiming function
        // that creates a user-specific proxy to receive rewards

        deal(TASSET, attacker, 100000e18);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(REDEMPTION_1, type(uint256).max);

        // Create redemption first
        REDEMPTION_1.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        // Now try claim functions
        console.log("\nTrying claim functions:");

        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSignature("claimRewards()")
        );
        console.log("claimRewards():", s1);
        if (s1 && d1.length > 0) console.logBytes(d1);

        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSignature("claimRewards(address)", attacker)
        );
        console.log("claimRewards(address):", s2);

        (bool s3, bytes memory d3) = REDEMPTION_1.call(
            abi.encodeWithSignature("claim()")
        );
        console.log("claim():", s3);

        (bool s4, bytes memory d4) = REDEMPTION_1.call(
            abi.encodeWithSignature("claim(address)", attacker)
        );
        console.log("claim(address):", s4);

        (bool s5, bytes memory d5) = REDEMPTION_1.call(
            abi.encodeWithSignature("getRewards()")
        );
        console.log("getRewards():", s5);

        (bool s6, bytes memory d6) = REDEMPTION_1.call(
            abi.encodeWithSignature("collectRewards()")
        );
        console.log("collectRewards():", s6);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
    }

    function test_IdentifyCreate2InitCode() public view {
        console.log("=== IDENTIFYING CREATE2 INIT CODE ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Look for CODECOPY which copies init code
        // CREATE2 at 4338 - find CODECOPY before it

        console.log("Looking for CODECOPY before CREATE2 at 4338:");

        for (uint i = 4200; i < 4338 && i < code.length; i++) {
            if (uint8(code[i]) == 0x39) { // CODECOPY
                console.log("CODECOPY at:", i);

                // CODECOPY (destOffset, offset, size)
                // Look for the size value
                uint j = i - 1;
                while (j > i - 10 && j < code.length) {
                    uint8 op = uint8(code[j]);
                    if (op >= 0x60 && op <= 0x65) {
                        uint8 size = op - 0x5f;
                        uint256 val = 0;
                        for (uint k = 0; k < size && j + 1 + k < code.length; k++) {
                            val = val << 8 | uint8(code[j + 1 + k]);
                        }
                        console.log("  Size might be:", val);
                    }
                    j--;
                }
            }
        }

        // Also look at what MSTORE stores before CREATE2
        console.log("\nMSTORE operations before CREATE2 at 4338:");
        for (uint i = 4200; i < 4338 && i < code.length; i++) {
            if (uint8(code[i]) == 0x52) { // MSTORE
                console.log("MSTORE at:", i);
            }
        }
    }

    function test_TraceEntireCreate2Flow() public view {
        console.log("=== TRACING ENTIRE CREATE2 FLOW ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Find what function leads to CREATE2 at 4338
        // by tracing JUMPDEST -> code flow

        // The flow is: selector match -> JUMPI to function -> ... -> CREATE2

        // Find the nearest JUMPDEST before 4338
        uint nearestJumpdest = 0;
        for (uint i = 4000; i < 4338; i++) {
            if (uint8(code[i]) == 0x5b) nearestJumpdest = i;
        }
        console.log("Nearest JUMPDEST before 4338:", nearestJumpdest);

        // Now find what jumps TO this jumpdest
        // JUMPI pushes destination then condition, then jumps if condition != 0
        // Look for PUSH <jumpdest> before JUMPI

        console.log("\nSearching for JUMPs to", nearestJumpdest, ":");

        uint16 target = uint16(nearestJumpdest);
        for (uint i = 0; i + 3 < code.length; i++) {
            if (uint8(code[i]) == 0x61) { // PUSH2
                uint16 dest = uint16(uint8(code[i+1])) << 8 | uint8(code[i+2]);
                if (dest == target) {
                    console.log("Found PUSH2", target, "at:", i);

                    // Check if followed by JUMPI
                    for (uint j = i + 3; j < i + 10 && j < code.length; j++) {
                        if (uint8(code[j]) == 0x57) {
                            console.log("  -> JUMPI at:", j);
                        }
                    }
                }
            }
        }

        // Also check selectors that might lead here
        console.log("\nLooking for selectors that route to near 4338:");
        // This is complex - let's try calling functions and see which triggers CREATE2
    }
}
