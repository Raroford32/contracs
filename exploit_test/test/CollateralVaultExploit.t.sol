// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function decimals() external view returns (uint8);
    function allowance(address owner, address spender) external view returns (uint256);
}

interface ICollateralVault {
    struct CollateralBalance {
        uint256 available;
        uint256 reserved;
    }

    function withdrawalFeeBasisPoints() external view returns (uint16);
    function getAccountCollateralBalance(address account, address token) external view returns (CollateralBalance memory);
    function depositToAccount(address account, address[] calldata tokens, uint256[] calldata amounts) external;
    function withdraw(address token, uint256 amount, address destination) external;
    function transferCollateral(address token, uint256 amount, address destination) external;
    function getCollateralToken(address token) external view returns (bool enabled, uint256 cumulativeBalance);
}

/**
 * @title CollateralVault Exploit Analysis
 * @notice Testing fee rounding and other potential exploits
 */
contract CollateralVaultExploitTest is Test {
    address constant VAULT = 0x5d2725fdE4d7Aa3388DA4519ac0449Cc031d675f;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

    ICollateralVault vault;
    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        vault = ICollateralVault(VAULT);
        attacker = makeAddr("attacker");
    }

    function testVaultState() public view {
        console.log("=== VAULT STATE ===");

        uint16 feeBps = vault.withdrawalFeeBasisPoints();
        console.log("Withdrawal fee (bps):", feeBps);
        console.log("Fee percentage:", feeBps * 100 / 10000, "%");

        // Check balances
        uint256 usdcBal = IERC20(USDC).balanceOf(VAULT);
        uint256 usdtBal = IERC20(USDT).balanceOf(VAULT);
        uint256 wethBal = IERC20(WETH).balanceOf(VAULT);

        console.log("\nVault balances:");
        console.log("USDC:", usdcBal / 1e6);
        console.log("USDT:", usdtBal / 1e6);
        console.log("WETH:", wethBal / 1e18);
    }

    function testFeeRoundingAnalysis() public view {
        console.log("\n=== FEE ROUNDING ANALYSIS ===");

        uint16 feeBps = vault.withdrawalFeeBasisPoints();

        // Test small amounts where fee rounds to 0
        // fee = (amount * feeBps) / 10000
        // fee = 0 when amount * feeBps < 10000
        // amount < 10000 / feeBps

        uint256 maxZeroFeeAmount = 10000 / feeBps - 1;
        console.log("Max amount with zero fee:", maxZeroFeeAmount);

        // For USDC (6 decimals), this would be:
        uint256 maxZeroFeeUSDC = maxZeroFeeAmount; // in wei
        console.log("Max zero fee in USDC (wei):", maxZeroFeeUSDC);

        // This is effectively worthless - less than 1 USDC
        // Not exploitable profitably

        // Check for larger amount rounding
        uint256 testAmount = 1000000e6; // 1M USDC
        uint256 fee = (testAmount * feeBps) / 10000;
        console.log("\nFee for 1M USDC:", fee / 1e6, "USDC");

        // Test deposit -> withdraw cycle
        uint256 afterWithdraw = testAmount - fee;
        console.log("After withdraw:", afterWithdraw / 1e6, "USDC");
        console.log("Loss:", (testAmount - afterWithdraw) / 1e6, "USDC");
    }

    function testTransferCollateralNoFee() public view {
        console.log("\n=== TRANSFER COLLATERAL (NO FEE) ===");

        // transferCollateral doesn't charge a fee
        // But it only moves from your own balance

        console.log("transferCollateral() moves your own balance - no exploit");
        console.log("withdraw() charges fee - normal behavior");

        // The only way to exploit would be if we could:
        // 1. Get someone else's balance transferred to us
        // 2. Find a state inconsistency

        // Check collateralizable contracts
        console.log("\nCollateralizable contracts can pool/reserve collateral");
        console.log("But they require governance approval");
    }

    function testDepositAndWithdrawCycle() public {
        console.log("\n=== DEPOSIT AND WITHDRAW CYCLE ===");

        // Get some USDC for testing
        address usdcWhale = 0x37305B1cD40574E4C5Ce33f8e8306Be057fD7341;

        uint256 depositAmount = 1000e6; // 1000 USDC

        vm.startPrank(usdcWhale);

        uint256 whaleBefore = IERC20(USDC).balanceOf(usdcWhale);
        console.log("Whale balance before:", whaleBefore / 1e6, "USDC");

        // Approve and deposit
        IERC20(USDC).approve(VAULT, depositAmount);

        address[] memory tokens = new address[](1);
        tokens[0] = USDC;
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = depositAmount;

        vault.depositToAccount(usdcWhale, tokens, amounts);

        ICollateralVault.CollateralBalance memory balance = vault.getAccountCollateralBalance(usdcWhale, USDC);
        console.log("Vault balance after deposit:", balance.available / 1e6, "USDC");

        // Withdraw
        vault.withdraw(USDC, balance.available, usdcWhale);

        uint256 whaleAfter = IERC20(USDC).balanceOf(usdcWhale);
        console.log("Whale balance after:", whaleAfter / 1e6, "USDC");

        uint256 loss = whaleBefore - whaleAfter;
        console.log("Loss (fee):", loss / 1e6, "USDC");

        vm.stopPrank();

        // Verify fee calculation
        uint16 feeBps = vault.withdrawalFeeBasisPoints();
        uint256 expectedFee = (depositAmount * feeBps) / 10000;
        console.log("Expected fee:", expectedFee / 1e6, "USDC");

        assertEq(loss, expectedFee, "Fee should match");
    }
}
