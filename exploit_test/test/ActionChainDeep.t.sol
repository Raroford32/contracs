// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract ActionChainDeep is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_FindCreate2InitCode() public view {
        console.log("=== FINDING CREATE2 INIT CODE IN RC ===\n");

        bytes memory code = REDEMPTION_CONTROLLER.code;

        // CREATE2 opcode is at certain offsets
        // Let's find what init code is used

        console.log("Searching for CREATE2 patterns:");

        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf5) { // CREATE2
                console.log("\nCREATE2 at offset:", i);

                // Look back for init code hash or code copy
                // Pattern usually: CODECOPY + CREATE2 or hardcoded hash

                for (uint j = (i > 100 ? i - 100 : 0); j < i; j++) {
                    if (uint8(code[j]) == 0x39) { // CODECOPY
                        console.log("  CODECOPY at:", j);
                    }
                    if (uint8(code[j]) == 0x3c) { // EXTCODECOPY
                        console.log("  EXTCODECOPY at:", j);
                    }
                    if (uint8(code[j]) == 0x52) { // MSTORE
                        console.log("  MSTORE at:", j);
                    }
                }

                // Check if there's a hash nearby (32 bytes)
                for (uint j = (i > 50 ? i - 50 : 0); j < i; j++) {
                    if (uint8(code[j]) == 0x7f) { // PUSH32
                        console.log("  PUSH32 at:", j);
                        console.log("  Hash:");
                        bytes32 hash;
                        for (uint k = 0; k < 32; k++) {
                            hash = bytes32(uint256(hash) << 8 | uint8(code[j + 1 + k]));
                        }
                        console.logBytes32(hash);
                    }
                }
            }
        }
    }

    function test_RCRegistrationMechanism() public view {
        console.log("=== ANALYZING RC REGISTRATION ===\n");

        // Check if there's a way to register new redemptions
        // addRedemption selector: 0x1fe923d3

        bytes memory code = REDEMPTION_CONTROLLER.code;

        // Find addRedemption and what it checks
        bytes4 addRedempSel = bytes4(keccak256("addRedemption(address)"));
        console.log("addRedemption selector:");
        console.logBytes4(addRedempSel);

        console.log("\nSearching for owner checks in RC:");

        // Find SLOAD of slot 0 (owner)
        for (uint i = 0; i + 2 < code.length; i++) {
            if (uint8(code[i]) == 0x60 && uint8(code[i+1]) == 0x00 && uint8(code[i+2]) == 0x54) {
                console.log("PUSH1 0 + SLOAD at:", i);

                // Check for CALLER + EQ after
                bool hasCallerCheck = false;
                for (uint j = i; j < i + 20 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x33) { // CALLER
                        hasCallerCheck = true;
                        console.log("  -> CALLER check at:", j);
                    }
                    if (uint8(code[j]) == 0x14 && hasCallerCheck) { // EQ
                        console.log("  -> EQ at:", j);
                        console.log("  *** THIS IS AN OWNER CHECK ***");
                        break;
                    }
                }
            }
        }

        // Check mapping(address => bool) pattern for redemptions
        console.log("\nSearching for mapping access patterns (redemption registry):");
        for (uint i = 0; i + 5 < code.length; i++) {
            // Pattern: PUSH1 4 (slot 4 for mappings often) + SHA3
            if (uint8(code[i]) == 0x20) { // SHA3/KECCAK256
                console.log("SHA3 at:", i);
            }
        }
    }

    function test_WhereDoesCreate2Deploy() public {
        console.log("=== WHERE DOES CREATE2 DEPLOY? ===\n");

        // Try to trigger CREATE2 by calling various functions
        // and see what address it tries to deploy to

        vm.startPrank(attacker);

        console.log("Attacker address:", attacker);

        // Calculate predicted addresses with different salts
        // CREATE2 address = keccak256(0xff ++ deployer ++ salt ++ keccak256(init_code))[12:]

        // If CALLER is used as salt, the address would be:
        bytes32 salt = bytes32(uint256(uint160(attacker)));
        console.log("Salt from attacker address:");
        console.logBytes32(salt);

        // We need to know the init_code_hash
        // Let's try triggering the CREATE2 and catching the address

        deal(TASSET, attacker, 10000e18);
        IERC20(TASSET).approve(REDEMPTION_1, type(uint256).max);

        console.log("\nTrying redeem on R1:");
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("Success:", s1);
        if (!s1 && d1.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(d1));
        }

        vm.stopPrank();

        // Check if any new contract was created
        // by looking at the redeemer's proxy address

        console.log("\nChecking for newly created proxies:");

        // Try to get redeemer info
        (bool s2, bytes memory d2) = REDEMPTION_1.staticcall(
            abi.encodeWithSignature("getRedeemLength(address)", attacker)
        );
        if (s2 && d2.length >= 32) {
            uint256 len = abi.decode(d2, (uint256));
            console.log("Attacker redeem length:", len);
        }
    }

    function test_ProxyDeploymentPattern() public view {
        console.log("=== ANALYZING PROXY DEPLOYMENT PATTERN ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Find where proxy bytecode might be stored
        // Usually it's a minimal proxy (EIP-1167) pattern

        // EIP-1167 minimal proxy bytecode:
        // 363d3d373d3d3d363d73IMPLEMENTATION5af43d82803e903d91602b57fd5bf3

        bytes memory minimalProxyPrefix = hex"363d3d373d3d3d363d73";

        console.log("Searching for minimal proxy pattern:");

        for (uint i = 0; i + 10 < code.length; i++) {
            bool match_ = true;
            for (uint j = 0; j < 10 && match_; j++) {
                if (code[i + j] != minimalProxyPrefix[j]) match_ = false;
            }
            if (match_) {
                console.log("Found minimal proxy pattern at:", i);

                // Extract the implementation address
                address impl;
                bytes memory implBytes = new bytes(20);
                for (uint k = 0; k < 20 && i + 10 + k < code.length; k++) {
                    implBytes[k] = code[i + 10 + k];
                }
                assembly {
                    impl := mload(add(implBytes, 20))
                }
                console.log("Implementation:", impl);
            }
        }

        // Also look for PUSH20 of addresses that might be proxy targets
        console.log("\nPUSH20 addresses in R1:");
        for (uint i = 0; i + 21 < code.length; i++) {
            if (uint8(code[i]) == 0x73) { // PUSH20
                address addr;
                bytes memory addrBytes = new bytes(20);
                for (uint j = 0; j < 20; j++) {
                    addrBytes[j] = code[i + 1 + j];
                }
                assembly {
                    addr := mload(add(addrBytes, 20))
                }
                if (addr != address(0) && uint160(addr) > 0x1000) {
                    console.log("Address at", i, ":");
                    console.log(addr);
                }
            }
        }
    }

    function test_FindUserProxyCreation() public {
        console.log("=== FINDING USER PROXY CREATION ===\n");

        // The "action chaining" pattern suggests:
        // 1. Attacker creates/owns a proxy
        // 2. Assets flow to that proxy
        // 3. Attacker extracts from proxy

        // Let's see if there's a function that creates a user-specific proxy

        bytes4[] memory proxySels = new bytes4[](10);
        proxySels[0] = bytes4(keccak256("createProxy()"));
        proxySels[1] = bytes4(keccak256("createProxy(address)"));
        proxySels[2] = bytes4(keccak256("deployProxy()"));
        proxySels[3] = bytes4(keccak256("getProxy(address)"));
        proxySels[4] = bytes4(keccak256("getUserProxy(address)"));
        proxySels[5] = bytes4(keccak256("proxyFor(address)"));
        proxySels[6] = bytes4(keccak256("proxies(address)"));
        proxySels[7] = bytes4(keccak256("userProxies(address)"));
        proxySels[8] = bytes4(keccak256("createRedemption()"));
        proxySels[9] = bytes4(keccak256("createRedemption(address)"));

        console.log("Trying proxy-related selectors on REDEMPTION_1:");

        for (uint i = 0; i < proxySels.length; i++) {
            (bool s,) = REDEMPTION_1.staticcall{gas: 100000}(
                abi.encodeWithSelector(proxySels[i], attacker)
            );
            if (s) {
                console.log("SUCCESS:");
                console.logBytes4(proxySels[i]);
            }
        }

        // Try on RC too
        console.log("\nTrying on REDEMPTION_CONTROLLER:");

        for (uint i = 0; i < proxySels.length; i++) {
            (bool s,) = REDEMPTION_CONTROLLER.staticcall{gas: 100000}(
                abi.encodeWithSelector(proxySels[i], attacker)
            );
            if (s) {
                console.log("SUCCESS:");
                console.logBytes4(proxySels[i]);
            }
        }
    }

    function test_VaultDirectAccess() public {
        console.log("=== CHECKING VAULT DIRECT ACCESS ===\n");

        // Maybe we can interact with Vault directly?

        console.log("Vault address:", VAULT);
        console.log("Vault wstETH:", IERC20(wstETH).balanceOf(VAULT) / 1e18);

        // Try common vault functions
        bytes4[] memory vaultSels = new bytes4[](15);
        vaultSels[0] = bytes4(keccak256("withdraw(uint256)"));
        vaultSels[1] = bytes4(keccak256("withdraw(uint256,address)"));
        vaultSels[2] = bytes4(keccak256("redeem(uint256)"));
        vaultSels[3] = bytes4(keccak256("redeem(uint256,address)"));
        vaultSels[4] = bytes4(keccak256("transfer(address,uint256)"));
        vaultSels[5] = bytes4(keccak256("approve(address,uint256)"));
        vaultSels[6] = bytes4(keccak256("withdrawTo(address,uint256)"));
        vaultSels[7] = bytes4(keccak256("claim(address)"));
        vaultSels[8] = bytes4(keccak256("claimAll()"));
        vaultSels[9] = bytes4(keccak256("sweep(address)"));
        vaultSels[10] = bytes4(keccak256("sweepToken(address,uint256)"));
        vaultSels[11] = bytes4(keccak256("emergencyWithdraw()"));
        vaultSels[12] = bytes4(keccak256("execute(address,bytes)"));
        vaultSels[13] = bytes4(keccak256("owner()"));
        vaultSels[14] = bytes4(keccak256("authorized(address)"));

        vm.startPrank(attacker);

        console.log("\nTrying vault functions as attacker:");
        for (uint i = 0; i < vaultSels.length; i++) {
            (bool s, bytes memory d) = VAULT.call{gas: 200000}(
                abi.encodeWithSelector(vaultSels[i], 100e18, attacker)
            );
            if (s) {
                console.log("SUCCESS:");
                console.logBytes4(vaultSels[i]);
                if (d.length > 0) console.logBytes(d);
            }
        }

        vm.stopPrank();

        // Check vault authorization mechanism
        console.log("\nVault storage slots:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(VAULT, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }
    }

    function test_CheckRedemptionRegistration() public view {
        console.log("=== CHECKING REDEMPTION REGISTRATION ===\n");

        // How does RC know R0 and R1 are valid?
        // There must be a mapping or storage

        // Check RC storage for R0 and R1
        console.log("Checking if R0 is registered:");
        bytes32 key0 = keccak256(abi.encode(REDEMPTION_0, uint256(4)));
        bytes32 val0 = vm.load(REDEMPTION_CONTROLLER, key0);
        console.log("Key hash for R0 at slot 4:");
        console.logBytes32(key0);
        console.log("Value:");
        console.logBytes32(val0);

        console.log("\nChecking if R1 is registered:");
        bytes32 key1 = keccak256(abi.encode(REDEMPTION_1, uint256(4)));
        bytes32 val1 = vm.load(REDEMPTION_CONTROLLER, key1);
        console.log("Value:");
        console.logBytes32(val1);

        // Try other slots
        console.log("\nTrying other mapping slots:");
        for (uint slot = 0; slot < 10; slot++) {
            bytes32 k0 = keccak256(abi.encode(REDEMPTION_0, slot));
            bytes32 v0 = vm.load(REDEMPTION_CONTROLLER, k0);
            if (v0 != bytes32(0)) {
                console.log("R0 at slot", slot, ":");
                console.logBytes32(v0);
            }

            bytes32 k1 = keccak256(abi.encode(REDEMPTION_1, slot));
            bytes32 v1 = vm.load(REDEMPTION_CONTROLLER, k1);
            if (v1 != bytes32(0)) {
                console.log("R1 at slot", slot, ":");
                console.logBytes32(v1);
            }
        }
    }
}
