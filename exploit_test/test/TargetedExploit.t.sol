// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

interface ILidoQueue {
    function requestWithdrawals(uint256[] calldata amounts, address owner) external returns (uint256[] memory);
    function claimWithdrawal(uint256 requestId) external;
    function getLastRequestId() external view returns (uint256);
    function getLastFinalizedRequestId() external view returns (uint256);
    function getWithdrawalStatus(uint256[] calldata requestIds)
        external view returns (
            uint256[] memory amountOfStETH,
            uint256[] memory amountOfShares,
            address[] memory owner,
            uint256[] memory timestamp,
            bool[] memory isFinalized,
            bool[] memory isClaimed
        );
    function findCheckpointHints(uint256[] calldata requestIds, uint256 firstIndex, uint256 lastIndex)
        external view returns (uint256[] memory);
    function claimWithdrawals(uint256[] calldata requestIds, uint256[] calldata hints) external;
}

interface IAavePool {
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata interestRateModes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;

    function flashLoanSimple(
        address receiverAddress,
        address asset,
        uint256 amount,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

interface IBentoBox {
    function flashLoan(
        address borrower,
        address receiver,
        address token,
        uint256 amount,
        bytes calldata data
    ) external;
    function balanceOf(address token, address account) external view returns (uint256);
    function totals(address token) external view returns (uint128 elastic, uint128 base);
    function deposit(address token, address from, address to, uint256 amount, uint256 share) external returns (uint256, uint256);
    function withdraw(address token, address from, address to, uint256 amount, uint256 share) external returns (uint256, uint256);
}

contract TargetedExploit is Test {
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant STETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    address constant BENTO = 0xF5BCE5077908a1b7370B9ae04AdC565EBd643966;
    address constant LIDO_QUEUE = 0x889edC2eDab5f40e902b864aD4d7AdE8E412F9B1;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testBentoBoxShareManipulation() public {
        console.log("=====================================================");
        console.log("BENTOBOX SHARE MANIPULATION TEST");
        console.log("=====================================================");

        IBentoBox bento = IBentoBox(BENTO);

        // Check BentoBox totals for WETH
        (uint128 elastic, uint128 base) = bento.totals(WETH);
        console.log("WETH Elastic (real):", uint256(elastic) / 1e18);
        console.log("WETH Base (shares):", uint256(base) / 1e18);

        if (base > 0) {
            uint256 shareToAmount = uint256(elastic) * 1e18 / uint256(base);
            console.log("Share to Amount ratio:", shareToAmount / 1e18);

            // Check for inflation attack possibility
            if (base < 1e18) {
                console.log("*** LOW BASE - POTENTIAL INFLATION ATTACK ***");
            }

            // Check for rounding issues
            if (elastic > base * 2) {
                console.log("*** HIGH ELASTIC/BASE RATIO ***");
            }
        }

        // Check other tokens
        address[3] memory tokens = [
            0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, // USDC
            0xdAC17F958D2ee523a2206206994597C13D831ec7, // USDT
            0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3  // MIM
        ];

        for (uint i = 0; i < tokens.length; i++) {
            try bento.totals(tokens[i]) returns (uint128 e, uint128 b) {
                if (e > 0 || b > 0) {
                    console.log("\n--- Token:", tokens[i], "---");
                    console.log("Elastic:", uint256(e));
                    console.log("Base:", uint256(b));
                }
            } catch {}
        }
    }

    function testLidoQueueVulnerabilities() public view {
        console.log("=====================================================");
        console.log("LIDO QUEUE VULNERABILITY ANALYSIS");
        console.log("=====================================================");

        ILidoQueue queue = ILidoQueue(LIDO_QUEUE);

        uint256 lastRequest = queue.getLastRequestId();
        uint256 lastFinalized = queue.getLastFinalizedRequestId();

        console.log("Last Request ID:", lastRequest);
        console.log("Last Finalized:", lastFinalized);
        console.log("Pending requests:", lastRequest - lastFinalized);

        console.log("\n--- Checking Recent Requests ---");

        // Check status of last few finalized requests
        uint256[] memory requestIds = new uint256[](5);
        for (uint i = 0; i < 5; i++) {
            requestIds[i] = lastFinalized - i;
        }

        // Note: The actual interface may differ, checking what we can
        console.log("Checking requests around finalization boundary...");

        // Try to find unclaimed withdrawals
        for (uint256 id = lastFinalized - 10; id <= lastFinalized; id++) {
            uint256[] memory singleId = new uint256[](1);
            singleId[0] = id;

            try queue.getWithdrawalStatus(singleId) returns (
                uint256[] memory amounts,
                uint256[] memory shares,
                address[] memory owners,
                uint256[] memory,
                bool[] memory finalized,
                bool[] memory claimed
            ) {
                if (finalized[0] && !claimed[0]) {
                    console.log("\n*** UNCLAIMED FINALIZED WITHDRAWAL ***");
                    console.log("ID:", id);
                    console.log("Amount:", amounts[0] / 1e18);
                    console.log("Owner:", owners[0]);
                }
            } catch {}
        }
    }

    function testAaveFlashLoanCapabilities() public view {
        console.log("=====================================================");
        console.log("AAVE FLASH LOAN CAPABILITIES");
        console.log("=====================================================");

        console.log("Aave Pool:", AAVE_POOL);

        // Check liquidity for flash loans
        uint256 wethAvailable = IERC20(WETH).balanceOf(AAVE_POOL);
        uint256 usdcAvailable = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48).balanceOf(AAVE_POOL);

        console.log("WETH available:", wethAvailable / 1e18);
        console.log("USDC available:", usdcAvailable / 1e6);

        // Flash loan fee is 0.05% on Aave V3
        console.log("Flash loan fee: 0.05%");
        console.log("1000 ETH flash loan cost: 0.5 ETH");
    }

    function testSearchForVulnerableVaults() public view {
        console.log("=====================================================");
        console.log("SEARCHING FOR VULNERABLE VAULT PATTERNS");
        console.log("=====================================================");

        // Known vault addresses to check
        address[10] memory vaults = [
            0xa354F35829Ae975e850e23e9615b11Da1B3dC4DE, // yvUSDC
            0xa258C4606Ca8206D8aA700cE2143D7db854D168c, // yvWETH
            0xdA816459F1AB5631232FE5e97a05BBBb94970c95, // yvDAI
            0xB8C3B7A2A618C552C23B1E4701109a9E756Bab67, // Yearn DAI
            0x5f18C75AbDAe578b483E5F43f12a39cF75b973a9, // Yearn USDC
            0xc5bDdf9843308380375a611c18B50Fb9341f502A, // Yearn WETH
            0x27b7b1ad7288079A66d12350c828D3C00A6F07d7, // Yearn
            0x378cb52b00F9D0921cb46dFc099CFf73b42419dC, // Yearn LUSD
            0x7Da96a3891Add058AdA2E826306D812C638D87a7, // Yearn USDT
            address(0)
        ];

        for (uint i = 0; i < vaults.length; i++) {
            if (vaults[i] == address(0)) continue;
            if (vaults[i].code.length == 0) continue;

            console.log("\n--- Vault:", vaults[i], "---");

            // Check total supply
            (bool s1, bytes memory d1) = vaults[i].staticcall(
                abi.encodeWithSignature("totalSupply()")
            );
            uint256 totalSupply = 0;
            if (s1 && d1.length >= 32) {
                totalSupply = abi.decode(d1, (uint256));
                console.log("Total Supply:", totalSupply / 1e18);
            }

            // Check total assets
            (bool s2, bytes memory d2) = vaults[i].staticcall(
                abi.encodeWithSignature("totalAssets()")
            );
            uint256 totalAssets = 0;
            if (s2 && d2.length >= 32) {
                totalAssets = abi.decode(d2, (uint256));
                console.log("Total Assets:", totalAssets / 1e18);
            }

            // Check for price per share anomalies
            if (totalSupply > 0 && totalAssets > 0) {
                uint256 pricePerShare = totalAssets * 1e18 / totalSupply;
                console.log("Price Per Share:", pricePerShare / 1e18);

                // Anomaly: price per share should be close to 1 initially
                // If much higher, accumulated profit; if lower, potential loss
                if (pricePerShare < 0.9e18) {
                    console.log("*** ANOMALY: PPS < 0.9 ***");
                }
                if (pricePerShare > 10e18) {
                    console.log("*** HIGH PPS - Check for rounding ***");
                }
            }

            // Check for first depositor vulnerability
            if (totalSupply == 0) {
                console.log("*** EMPTY VAULT - FIRST DEPOSITOR ATTACK POSSIBLE ***");
            }
        }
    }

    function testStETHArbitrage() public view {
        console.log("=====================================================");
        console.log("stETH/ETH ARBITRAGE CHECK");
        console.log("=====================================================");

        // Get stETH/ETH rate on Lido
        uint256 stEthSupply = IERC20(STETH).totalSupply();
        console.log("stETH Total Supply:", stEthSupply / 1e18);

        // Check Curve pool rate
        address curvePool = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;

        (bool success, bytes memory data) = curvePool.staticcall(
            abi.encodeWithSignature("get_dy(int128,int128,uint256)", int128(0), int128(1), uint256(1e18))
        );

        if (success && data.length >= 32) {
            uint256 output = abi.decode(data, (uint256));
            console.log("1 ETH -> stETH via Curve:", output / 1e18);

            if (output > 1.01e18) {
                console.log("*** ARBITRAGE: stETH cheap ***");
            }
            if (output < 0.99e18) {
                console.log("*** ARBITRAGE: stETH expensive ***");
            }
        }

        // Reverse direction
        (success, data) = curvePool.staticcall(
            abi.encodeWithSignature("get_dy(int128,int128,uint256)", int128(1), int128(0), uint256(1e18))
        );

        if (success && data.length >= 32) {
            uint256 output = abi.decode(data, (uint256));
            console.log("1 stETH -> ETH via Curve:", output / 1e18);
        }
    }
}
