// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Targeted Exploit Search
 * @notice Focused search for immediately exploitable vulnerabilities
 */

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
}

interface IERC4626 {
    function deposit(uint256 assets, address receiver) external returns (uint256);
    function redeem(uint256 shares, address receiver, address owner) external returns (uint256);
    function totalAssets() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function convertToShares(uint256 assets) external view returns (uint256);
    function convertToAssets(uint256 shares) external view returns (uint256);
    function previewDeposit(uint256 assets) external view returns (uint256);
    function previewRedeem(uint256 shares) external view returns (uint256);
    function asset() external view returns (address);
}

interface IConvexBooster {
    function deposit(uint256, uint256, bool) external returns (bool);
    function withdraw(uint256, uint256) external returns (bool);
    function poolInfo(uint256) external view returns (address, address, address, address, address, bool);
}

interface ICurveGauge {
    function balanceOf(address) external view returns (uint256);
}

contract TargetedExploit is Test {
    // pxETH related
    address constant APXETH_VAULT = 0xCb6DFd06973bF66C8bD2779538e5C8311B8070B8;
    address constant AUTO_PXETH = 0x9Ba021B0a9b958B5E75cE9f6dff97C7eE52cb3E6;
    address constant PXETH = 0x04C154b66CB340F3Ae24111CC767e0184Ed00Cc6;

    // Convex
    address constant CONVEX_BOOSTER = 0xF403C135812408BFbE8713b5A23a04b3D48AAE31;

    address attacker;
    address victim;

    string constant RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        victim = makeAddr("victim");
    }

    function test_ApxETHVault_Analysis() public {
        console.log("=== ApxETHVault Analysis ===\n");

        IERC4626 vault = IERC4626(APXETH_VAULT);
        IERC20 pxeth = IERC20(PXETH);

        uint256 totalAssets = vault.totalAssets();
        uint256 totalSupply = vault.totalSupply();

        console.log("Vault State:");
        console.log("  Total Assets:", totalAssets / 1e18);
        console.log("  Total Supply:", totalSupply / 1e18);

        if (totalSupply > 0) {
            uint256 sharePrice = totalAssets * 1e18 / totalSupply;
            console.log("  Share Price:", sharePrice);
        }

        uint256 directBalance = pxeth.balanceOf(APXETH_VAULT);
        console.log("\n  Direct pxETH balance:", directBalance / 1e18);
        console.log("  Reported totalAssets:", totalAssets / 1e18);

        if (directBalance > totalAssets) {
            console.log("  EXCESS:", (directBalance - totalAssets) / 1e18);
        } else if (directBalance < totalAssets) {
            console.log("  DEFICIT:", (totalAssets - directBalance) / 1e18);
        }
    }

    function test_FirstDepositorSearch() public {
        console.log("=== First Depositor Attack Search ===\n");

        address[] memory vaults = new address[](4);
        vaults[0] = APXETH_VAULT;
        vaults[1] = AUTO_PXETH;
        vaults[2] = 0x9D39A5DE30e57443BfF2A8307A4256c8797A3497; // sUSDe
        vaults[3] = 0xac3E018457B222d93114458476f3E3416Abbe38F; // sfrxETH

        for (uint i = 0; i < vaults.length; i++) {
            address vault = vaults[i];
            if (vault.code.length == 0) continue;

            try IERC4626(vault).totalSupply() returns (uint256 supply) {
                if (supply == 0) {
                    console.log("Vault", i, "is EMPTY - First depositor attack possible!");
                    console.log("  Address:", vault);
                } else {
                    console.log("Vault", i, "- Supply:", supply / 1e18);
                }
            } catch {}
        }
    }

    function test_ConvexPoolAnalysis() public {
        console.log("=== Convex Pool Analysis ===\n");

        IConvexBooster booster = IConvexBooster(CONVEX_BOOSTER);

        for (uint256 i = 0; i < 3; i++) {
            try booster.poolInfo(i) returns (
                address lptoken,
                address token,
                address gauge,
                address crvRewards,
                address stash,
                bool shutdown
            ) {
                if (!shutdown && gauge != address(0)) {
                    console.log("Pool", i);
                    console.log("  LP Token:", lptoken);
                    console.log("  Active:", !shutdown);
                    
                    uint256 gaugeBalance = ICurveGauge(gauge).balanceOf(address(booster));
                    console.log("  Gauge Balance:", gaugeBalance / 1e18);
                    console.log("");
                }
            } catch {}
        }
    }

    function test_DonationAttack() public {
        console.log("=== Donation Attack Analysis ===\n");

        IERC4626 vault = IERC4626(AUTO_PXETH);

        uint256 totalSupply = vault.totalSupply();
        uint256 totalAssets = vault.totalAssets();

        console.log("AutoPxEth:");
        console.log("  Total Supply:", totalSupply / 1e18);
        console.log("  Total Assets:", totalAssets / 1e18);

        if (totalSupply > 0) {
            uint256 donationAmount = 100e18;
            uint256 newAssets = totalAssets + donationAmount;
            uint256 newSharePrice = newAssets * 1e18 / totalSupply;
            uint256 oldSharePrice = totalAssets * 1e18 / totalSupply;

            console.log("\n  100 pxETH Donation Impact:");
            console.log("    Old price:", oldSharePrice);
            console.log("    New price:", newSharePrice);
            
            uint256 pctIncrease = (newSharePrice - oldSharePrice) * 100 / oldSharePrice;
            console.log("    Increase %:", pctIncrease);

            if (totalSupply < 10000e18) {
                console.log("\n  LOW SUPPLY - Donation attack may be viable!");
            }
        }
    }

    function test_AccountingCheck() public {
        console.log("=== Accounting Discrepancy Check ===\n");

        IERC20 pxeth = IERC20(PXETH);

        uint256 pxethInAuto = pxeth.balanceOf(AUTO_PXETH);
        uint256 pxethInApx = pxeth.balanceOf(APXETH_VAULT);
        uint256 totalPxeth = pxeth.totalSupply();

        console.log("pxETH Distribution:");
        console.log("  Total Supply:", totalPxeth / 1e18);
        console.log("  In AutoPxEth:", pxethInAuto / 1e18);
        console.log("  In ApxEthVault:", pxethInApx / 1e18);

        try IERC4626(AUTO_PXETH).totalAssets() returns (uint256 reported) {
            console.log("\n  AutoPxEth reported:", reported / 1e18);
            if (pxethInAuto != reported) {
                console.log("  DISCREPANCY:", (pxethInAuto > reported ? pxethInAuto - reported : reported - pxethInAuto) / 1e18);
            }
        } catch {}
    }
}
