// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface ICurvePool {
    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);
    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external payable returns (uint256);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

interface IFraxEtherMinter {
    function submitAndGive(address recipient) external payable;
}

contract FrxEthArbitrageTest is Test {
    // Curve frxETH/ETH pool
    address constant CURVE_POOL = 0xa1F8A6807c402E4A15ef4EBa36528A3FED24E577;
    address constant FRXETH = 0x5E8422345238F34275888049021821E8E08CAa1f;
    address constant FRAX_MINTER = 0xbAFA44EFE7901E04E39Dad13167D089C559c1138;
    address constant FRAX_QUEUE = 0x82bA8da44Cd5261762e629dd5c605b17715727bd;
    
    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }
    
    function testCheckFrxEthRate() public view {
        console.log("=== frxETH / ETH EXCHANGE RATE ===");
        
        ICurvePool curve = ICurvePool(CURVE_POOL);
        
        // Check how much ETH you get for 1 frxETH
        uint256 oneETH = 1e18;
        
        // frxETH -> ETH (i=1 frxETH, j=0 ETH)
        uint256 ethOut = curve.get_dy(1, 0, oneETH);
        console.log("1 frxETH -> ETH:", ethOut);
        console.log("Rate:", ethOut * 10000 / oneETH, "/ 10000");
        
        // ETH -> frxETH (i=0 ETH, j=1 frxETH)
        uint256 frxEthOut = curve.get_dy(0, 1, oneETH);
        console.log("1 ETH -> frxETH:", frxEthOut);
        console.log("Rate:", frxEthOut * 10000 / oneETH, "/ 10000");
        
        // Analysis:
        // If frxETH trades at discount (<1 ETH per frxETH):
        //   - Can't profit from redemption queue (you get less frxETH back via early exit)
        // If frxETH trades at premium (>1 ETH per frxETH):
        //   - Could potentially profit by:
        //     1. Flash borrow ETH
        //     2. Mint frxETH (1:1 from Frax minter)
        //     3. Sell frxETH on Curve for more ETH
        //     4. Repay flash loan + profit
        //   - BUT: This doesn't involve the redemption queue at all
        
        console.log("\n=== ARBITRAGE ANALYSIS ===");
        
        if (frxEthOut > oneETH) {
            console.log("frxETH at PREMIUM - check for mint & sell arbitrage");
            uint256 profit = frxEthOut - oneETH;
            console.log("Potential profit per ETH:", profit);
        } else if (ethOut < oneETH) {
            console.log("frxETH at DISCOUNT - no queue arbitrage possible");
        } else {
            console.log("frxETH at parity - no arbitrage");
        }
    }
    
    function testMintAndSellArbitrage() public {
        console.log("=== MINT AND SELL ARBITRAGE TEST ===");
        
        ICurvePool curve = ICurvePool(CURVE_POOL);
        
        // Check: mint 100 ETH worth of frxETH, sell on Curve
        uint256 testAmount = 100e18;
        
        // Get expected frxETH output from Curve
        uint256 frxEthFromCurve = curve.get_dy(0, 1, testAmount);
        console.log("100 ETH -> frxETH on Curve:", frxEthFromCurve / 1e18);
        
        // Frax minter gives 1:1
        uint256 frxEthFromMint = testAmount;
        console.log("100 ETH -> frxETH via mint:", frxEthFromMint / 1e18);
        
        if (frxEthFromCurve > frxEthFromMint) {
            console.log("Curve gives more frxETH than mint - no arbitrage this direction");
        } else {
            console.log("Mint gives more frxETH than Curve - check reverse");
        }
        
        // Reverse: Sell frxETH for ETH
        uint256 ethFromSelling = curve.get_dy(1, 0, frxEthFromMint);
        console.log("Selling 100 frxETH for ETH:", ethFromSelling / 1e18);
        
        if (ethFromSelling > testAmount) {
            uint256 profit = ethFromSelling - testAmount;
            console.log("\n!!! POTENTIAL ARBITRAGE !!!");
            console.log("Profit:", profit / 1e18, "ETH");
            console.log("Profit %:", profit * 100 / testAmount, "%");
        } else {
            console.log("\nNo arbitrage: would lose ETH");
            console.log("Loss:", (testAmount - ethFromSelling) / 1e18, "ETH");
        }
    }
}
