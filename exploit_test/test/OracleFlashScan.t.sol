// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

interface IAavePool {
    function flashLoan(
        address receiver,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata modes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

contract OracleFlashScan is Test {
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testSearchOracleVulnerabilities() public view {
        console.log("=====================================================");
        console.log("SEARCHING FOR ORACLE VULNERABILITIES");
        console.log("=====================================================");

        // Check contracts that might use vulnerable oracles
        // Look for getPrice, latestPrice, getRate functions

        // THUSD system uses Chainlink - already checked
        // Let's check other contracts

        address[5] memory targets = [
            0xF5BCE5077908a1b7370B9ae04AdC565EBd643966, // BentoBox
            0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2, // Aave V3
            0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9, // Aave V2
            0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, // WETH
            0x920623AcBa785ED9a70d33ACab53631e1e834675  // BAMM
        ];

        for (uint i = 0; i < targets.length; i++) {
            address target = targets[i];
            console.log("\n--- Contract:", target, "---");

            // Check for oracle-related functions
            _tryCall(target, "getPrice(address)");
            _tryCall(target, "latestPrice()");
            _tryCall(target, "getAssetPrice(address)");
            _tryCall(target, "fetchPrice()");
        }
    }

    function _tryCall(address target, string memory sig) internal view {
        (bool success,) = target.staticcall(
            abi.encodeWithSignature(sig, address(0))
        );
        if (success) {
            console.log("Has:", sig);
        }
    }

    function testAnalyzeCauldrons() public view {
        console.log("=====================================================");
        console.log("ANALYZING ABRACADABRA CAULDRONS");
        console.log("=====================================================");

        // Cauldrons have cook() function with potential bypass
        // Similar to recent Abracadabra exploit

        address[3] memory cauldrons = [
            0x7b7473a76D6ae86CE19f7352A1E89F6C9dc39020, // CauldronV3
            0xc6B2b3fE7c3D7a6f823D9106E22e66660709001e, // Another Cauldron
            0x806e16ec797c69afa8590A55723CE4CC1b54050E  // SPELL Cauldron
        ];

        for (uint i = 0; i < cauldrons.length; i++) {
            address cauldron = cauldrons[i];
            if (cauldron.code.length == 0) continue;

            console.log("\n--- Cauldron:", cauldron, "---");

            // Check state
            (bool success, bytes memory data) = cauldron.staticcall(
                abi.encodeWithSignature("totalBorrow()")
            );
            if (success && data.length >= 64) {
                (uint128 elastic, uint128 base) = abi.decode(data, (uint128, uint128));
                console.log("Total Borrow Elastic:", uint256(elastic) / 1e18);
                console.log("Total Borrow Base:", uint256(base) / 1e18);
            }

            // Check MIM balance (borrowed token)
            address MIM = 0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3;
            uint256 mimBal = IERC20(MIM).balanceOf(cauldron);
            console.log("MIM in Cauldron:", mimBal / 1e18);

            // Check collateral
            (success, data) = cauldron.staticcall(
                abi.encodeWithSignature("collateral()")
            );
            if (success && data.length >= 32) {
                address collateral = abi.decode(data, (address));
                console.log("Collateral token:", collateral);
                uint256 collBal = IERC20(collateral).balanceOf(cauldron);
                console.log("Collateral balance:", collBal / 1e18);
            }
        }
    }

    function testFlashLoanCapabilities() public view {
        console.log("=====================================================");
        console.log("FLASH LOAN CAPABILITIES CHECK");
        console.log("=====================================================");

        // Check available flash loan liquidity
        console.log("Aave V3 Pool:", AAVE_POOL);

        uint256 wethLiquidity = IERC20(WETH).balanceOf(AAVE_POOL);
        console.log("WETH available:", wethLiquidity / 1e18);

        address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
        uint256 usdcLiquidity = IERC20(USDC).balanceOf(AAVE_POOL);
        console.log("USDC available:", usdcLiquidity / 1e6);

        // BentoBox flash loans
        address bento = 0xF5BCE5077908a1b7370B9ae04AdC565EBd643966;
        uint256 bentoWeth = IERC20(WETH).balanceOf(bento);
        console.log("BentoBox WETH:", bentoWeth / 1e18);
    }

    function testSearchGMXStyleVulnerabilities() public view {
        console.log("=====================================================");
        console.log("SEARCHING FOR GMX-STYLE CROSS-CONTRACT REENTRANCY");
        console.log("=====================================================");

        // GMX was exploited via cross-contract reentrancy
        // Look for contracts with multiple entry points

        // Check for contracts with:
        // 1. External calls during state updates
        // 2. Callback mechanisms
        // 3. Multiple interacting contracts

        address[3] memory targets = [
            0xA906F338CB21815cBc4Bc87ace9e68c87eF8d8F1, // Arbitrum bridge
            0x8315177aB297bA92A06054cE80a67Ed4DBd7ed3a, // Arbitrum rollup
            0x4Dbd4fc535Ac27206064B68FfCf827b0A60BAB3f  // Arbitrum inbox
        ];

        for (uint i = 0; i < targets.length; i++) {
            address target = targets[i];
            if (target.code.length == 0) continue;

            console.log("\n--- Contract:", target, "---");
            console.log("ETH Balance:", target.balance / 1e18);

            uint256 wethBal = IERC20(WETH).balanceOf(target);
            if (wethBal > 0) {
                console.log("WETH Balance:", wethBal / 1e18);
            }
        }
    }

    function testAnalyzeYearnVaults() public view {
        console.log("=====================================================");
        console.log("ANALYZING YEARN-STYLE VAULTS");
        console.log("=====================================================");

        // Yearn was exploited via invariant bugs
        // Check vault share calculations

        address[3] memory vaults = [
            0xa354F35829Ae975e850e23e9615b11Da1B3dC4DE, // yvUSDC
            0xa258C4606Ca8206D8aA700cE2143D7db854D168c, // yvWETH
            0xdA816459F1AB5631232FE5e97a05BBBb94970c95  // yvDAI
        ];

        for (uint i = 0; i < vaults.length; i++) {
            address vault = vaults[i];
            if (vault.code.length == 0) continue;

            console.log("\n--- Vault:", vault, "---");

            (bool success, bytes memory data) = vault.staticcall(
                abi.encodeWithSignature("totalSupply()")
            );
            if (success && data.length >= 32) {
                console.log("Total Shares:", abi.decode(data, (uint256)) / 1e18);
            }

            (success, data) = vault.staticcall(
                abi.encodeWithSignature("totalAssets()")
            );
            if (success && data.length >= 32) {
                console.log("Total Assets:", abi.decode(data, (uint256)) / 1e18);
            }

            (success, data) = vault.staticcall(
                abi.encodeWithSignature("pricePerShare()")
            );
            if (success && data.length >= 32) {
                console.log("Price Per Share:", abi.decode(data, (uint256)) / 1e18);
            }
        }
    }
}
