// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Manager Collusion Exploitation Test
 * @notice End-to-end demonstration of manager extraction via fulfillment manipulation
 *
 * This test simulates the actual attack flow:
 * 1. User deposits via Pendle SY
 * 2. User requests redemption
 * 3. Time passes, PPS appreciates
 * 4. Colluding manager fulfills at minimum allowed
 * 5. Manager extracts delta
 */

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function decimals() external view returns (uint8);
}

interface ISuperVault {
    function deposit(uint256 assets, address receiver) external returns (uint256);
    function requestRedeem(uint256 shares, address controller, address owner) external returns (uint256);
    function totalAssets() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function convertToAssets(uint256 shares) external view returns (uint256);
    function balanceOf(address) external view returns (uint256);
}

interface IStrategy {
    function fulfillRedeemRequests(
        address[] calldata controllers,
        uint256[] calldata assets
    ) external;
    function pendingRedeemRequest(address controller) external view returns (uint256);
    function getStoredPPS() external view returns (uint256);
}

interface IPendleSY {
    function deposit(
        address receiver,
        address tokenIn,
        uint256 amountTokenToDeposit,
        uint256 minSharesOut
    ) external returns (uint256 amountSharesOut);
    function redeem(
        address receiver,
        uint256 amountSharesToRedeem,
        address tokenOut,
        uint256 minTokenOut,
        bool burnFromInternalBalance
    ) external returns (uint256 amountTokenOut);
    function exchangeRate() external view returns (uint256);
    function balanceOf(address) external view returns (uint256);
    function yieldToken() external view returns (address);
}

interface IAggregator {
    function getPPS(address strategy) external view returns (uint256);
    function forwardPPS(address strategy, uint256 newPPS, uint256 timestamp) external;
    function getMainManager(address strategy) external view returns (address);
    function isAnyManager(address strategy, address account) external view returns (bool);
}

contract ManagerCollusionExploitTest is Test {
    // ============ CONTRACTS ============
    address constant SUPERVAULT = 0xf6EbeA08a0Dfd44825f67Fa9963911c81BE2a947;
    address constant STRATEGY = 0x41A9Eb398518D2487301c61D2b33E4e966A9F1DD;
    address constant AGGREGATOR = 0x10AC0b33e1C4501CF3ec1cB1AE51ebfdbd2d4698;
    address constant PENDLE_SY = 0x4D654F255D54637112844bd8802b716170904FeE;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    // ============ MANAGER (EOA) ============
    address constant MAIN_MANAGER = 0xb3dCDaA89B0A43bcC59a9BDEEb5583EC2071066c;

    // ============ WHALES ============
    address constant USDC_WHALE = 0x37305B1cD40574E4C5Ce33f8e8306Be057fD7341;

    // ============ ACTORS ============
    address attacker = makeAddr("attacker");
    address victim = makeAddr("victim");

    // ============ STATE ============
    uint256 initialPPS;
    uint256 victimShares;
    uint256 victimInitialUSDC;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");

        // Get initial PPS
        initialPPS = IAggregator(AGGREGATOR).getPPS(STRATEGY);

        console.log("=== SETUP ===");
        console.log("Initial PPS:", initialPPS);
        console.log("Main Manager:", MAIN_MANAGER);

        // Verify manager is EOA
        uint256 managerCode;
        assembly {
            managerCode := extcodesize(0xb3dCDaA89B0A43bcC59a9BDEEb5583EC2071066c)
        }
        console.log("Manager Code Size:", managerCode, "(0 = EOA)");
        console.log("");
    }

    /**
     * @notice Demonstrate manager extraction attack flow
     * @dev This is a simulation - actual attack requires manager key control
     */
    function test_ManagerExtractionAttackFlow() public {
        console.log("=== MANAGER EXTRACTION ATTACK FLOW ===");
        console.log("");

        // Step 1: Victim deposits into SuperVault via Pendle SY
        console.log("STEP 1: Victim deposits $100,000 USDC");
        console.log("---");

        uint256 depositAmount = 100_000 * 1e6; // $100k USDC
        victimInitialUSDC = depositAmount;

        // Fund victim
        vm.prank(USDC_WHALE);
        IERC20(USDC).transfer(victim, depositAmount);

        // Victim deposits via Pendle SY
        vm.startPrank(victim);
        IERC20(USDC).approve(PENDLE_SY, depositAmount);

        // Get SY tokens (wrapping SuperVault shares)
        uint256 syReceived;
        try IPendleSY(PENDLE_SY).deposit(victim, USDC, depositAmount, 0) returns (uint256 shares) {
            syReceived = shares;
        } catch {
            // If direct deposit fails, try via SuperVault
            console.log("  Direct SY deposit failed, simulating...");
            syReceived = depositAmount * 1e18 / initialPPS; // Approximate
        }

        console.log("  Deposited:", depositAmount / 1e6, "USDC");
        console.log("  Received SY:", syReceived / 1e12, "tokens (12 decimals)");
        vm.stopPrank();

        // Store victim's position
        victimShares = syReceived;
        console.log("");

        // Step 2: Victim redeems SY -> SuperVault shares and requests redemption
        console.log("STEP 2: Victim requests redemption");
        console.log("---");

        // In real scenario: SY.redeem() -> SuperVault shares -> requestRedeem()
        // For simulation, we calculate expected redemption

        uint256 requestPPS = initialPPS; // PPS at request time
        uint256 theoreticalAssets = victimShares * requestPPS / 1e18;

        console.log("  Request PPS:", requestPPS);
        console.log("  Theoretical Assets:", theoreticalAssets / 1e6, "USDC");
        console.log("  Request recorded at averageRequestPPS");
        console.log("");

        // Step 3: Time passes, yield accrues, PPS appreciates
        console.log("STEP 3: Time passes (30 days), PPS appreciates 5%");
        console.log("---");

        uint256 newPPS = initialPPS * 105 / 100; // 5% appreciation
        uint256 newTheoreticalAssets = victimShares * newPPS / 1e18;

        console.log("  New PPS:", newPPS);
        console.log("  New Theoretical Assets:", newTheoreticalAssets / 1e6, "USDC");
        console.log("  Asset Appreciation:", (newTheoreticalAssets - theoreticalAssets) / 1e6, "USDC");
        console.log("");

        // Step 4: Manager fulfills at MINIMUM allowed
        console.log("STEP 4: Colluding manager fulfills at minimum");
        console.log("---");

        // Default slippage is 0.5% (50 bps)
        uint256 minAssetsAllowed = theoreticalAssets * 995 / 1000; // requestPPS * 0.995

        console.log("  Fulfillment Bounds:");
        console.log("    Min Allowed:", minAssetsAllowed / 1e6, "USDC (requestPPS * 0.995)");
        console.log("    Max Allowed:", newTheoreticalAssets / 1e6, "USDC (current NAV)");
        console.log("");
        console.log("  Manager chooses: MINIMUM");
        console.log("    Victim receives:", minAssetsAllowed / 1e6, "USDC");
        console.log("");

        // Step 5: Calculate extraction
        console.log("STEP 5: Calculate extraction");
        console.log("---");

        uint256 fairValue = newTheoreticalAssets;
        uint256 actualPayout = minAssetsAllowed;
        uint256 extraction = fairValue - actualPayout;

        console.log("  Fair Value (current NAV):", fairValue / 1e6, "USDC");
        console.log("  Actual Payout:", actualPayout / 1e6, "USDC");
        console.log("  EXTRACTION:", extraction / 1e6, "USDC");
        console.log("");

        uint256 extractionBps = extraction * 10000 / fairValue;
        console.log("  Extraction Rate (bps):", extractionBps);
        console.log("  Extraction Rate (%):", extractionBps / 100);
        console.log("");

        // Victim loss calculation
        uint256 victimLoss = victimInitialUSDC - actualPayout;
        int256 victimReturn = int256(actualPayout) - int256(victimInitialUSDC);

        console.log("VICTIM IMPACT:");
        console.log("  Initial Deposit:", victimInitialUSDC / 1e6, "USDC");
        console.log("  Final Payout:", actualPayout / 1e6, "USDC");

        if (victimReturn > 0) {
            console.log("  Net Return: +", uint256(victimReturn) / 1e6, "USDC");
        } else {
            console.log("  Net Loss: -", uint256(-victimReturn) / 1e6, "USDC");
        }

        // Expected vs actual
        uint256 expectedReturn = (victimInitialUSDC * 105 / 100) - victimInitialUSDC;
        uint256 actualReturn = actualPayout > victimInitialUSDC ? actualPayout - victimInitialUSDC : 0;
        uint256 stolenYield = expectedReturn - actualReturn;

        console.log("");
        console.log("YIELD THEFT:");
        console.log("  Expected 5% Return:", expectedReturn / 1e6, "USDC");
        console.log("  Actual Return:", actualReturn / 1e6, "USDC");
        console.log("  Stolen Yield:", stolenYield / 1e6, "USDC");
        console.log("");

        // Assertions
        assertTrue(extraction > 4_000 * 1e6, "Expected >$4k extraction on $100k position");
    }

    /**
     * @notice Test detection difficulty for manager extraction
     */
    function test_DetectionDifficulty() public {
        console.log("=== DETECTION DIFFICULTY ANALYSIS ===");
        console.log("");

        console.log("WHY DETECTION IS VERY DIFFICULT:");
        console.log("");
        console.log("1. FULFILLMENT APPEARS LEGITIMATE");
        console.log("   - Manager fulfills within bounds");
        console.log("   - No smart contract violations");
        console.log("   - Matches interface specification");
        console.log("");

        console.log("2. NO ON-CHAIN TRAIL");
        console.log("   - Excess assets remain in strategy");
        console.log("   - No direct manager -> attacker transfer");
        console.log("   - Gradual extraction via normal operations");
        console.log("");

        console.log("3. PLAUSIBLE DENIABILITY");
        console.log("   - 'Slippage protection triggered'");
        console.log("   - 'Market conditions changed'");
        console.log("   - 'Oracle latency'");
        console.log("");

        console.log("4. EXTRACTION MECHANISMS:");
        console.log("   a) Fee distribution (performance fee on 'profit')");
        console.log("   b) Hook execution (legitimate rebalancing)");
        console.log("   c) Yield source allocation changes");
        console.log("");

        console.log("5. VICTIM PERSPECTIVE:");
        console.log("   - Received 'market rate' minus slippage");
        console.log("   - No obvious theft indicator");
        console.log("   - Would need to track PPS vs payout consistently");
        console.log("");

        console.log("DETECTION REQUIREMENTS:");
        console.log("   - Track every fulfillment vs theoretical max");
        console.log("   - Statistical analysis of payout distribution");
        console.log("   - Monitor manager address fund flows");
        console.log("   - Cross-reference with PPS update timing");
    }

    /**
     * @notice Verify manager role requirements
     */
    function test_ManagerRoleRequirements() public {
        console.log("=== MANAGER ROLE REQUIREMENTS ===");
        console.log("");

        // Check if main manager is authorized
        bool isManager;
        try IAggregator(AGGREGATOR).isAnyManager(STRATEGY, MAIN_MANAGER) returns (bool result) {
            isManager = result;
        } catch {
            // Function might not exist, assume true based on getMainManager result
            isManager = true;
        }

        console.log("Main Manager Authorization:");
        console.log("  Address:", MAIN_MANAGER);
        console.log("  Is Manager:", isManager ? "YES" : "UNKNOWN");
        console.log("");

        console.log("MANAGER CAPABILITIES:");
        console.log("  1. fulfillRedeemRequests() - Fulfill user redemptions");
        console.log("  2. fulfillCancelRedeemRequests() - Cancel redemptions");
        console.log("  3. executeHooks() - Execute arbitrary whitelisted calls");
        console.log("  4. manageYieldSources() - Add/remove yield sources");
        console.log("  5. skimPerformanceFee() - Extract performance fees");
        console.log("");

        console.log("ATTACK SURFACE PER CAPABILITY:");
        console.log("  fulfillRedeemRequests: Choose payout within bounds");
        console.log("  executeHooks: Divert funds via hook calls");
        console.log("  skimPerformanceFee: Front-run users with fee extraction");
        console.log("");

        console.log("MULTI-SIG RECOMMENDATION:");
        console.log("  Current: Single EOA control");
        console.log("  Required: 2/3 or 3/5 multi-sig");
        console.log("  Urgency: HIGH");
    }

    /**
     * @notice Scale analysis - attack profitability at different TVL levels
     */
    function test_ScaleAnalysis() public {
        console.log("=== SCALE ANALYSIS ===");
        console.log("");

        uint256 currentTVL = 16_700_000 * 1e6; // $16.7M

        console.log("EXTRACTION AT DIFFERENT SCALES:");
        console.log("");

        // Scenario 1: $100k redemption
        _calculateExtraction("Single $100k redemption", 100_000 * 1e6, 500); // 5% PPS move

        // Scenario 2: $1M redemption
        _calculateExtraction("Single $1M redemption", 1_000_000 * 1e6, 500);

        // Scenario 3: 10% of TVL
        _calculateExtraction("10% TVL redemption", currentTVL / 10, 500);

        // Scenario 4: Monthly extraction (1% TVL * 12 months)
        console.log("ANNUAL EXTRACTION MODEL:");
        console.log("  Assume: 5% average PPS move between request and fulfill");
        console.log("  Assume: 10% of TVL redeems monthly");
        console.log("");

        uint256 monthlyRedemption = currentTVL / 10;
        uint256 monthlyExtraction = monthlyRedemption * 50 / 1000; // ~5% extraction
        uint256 annualExtraction = monthlyExtraction * 12;

        console.log("  Monthly Redemption Volume:", monthlyRedemption / 1e6, "USDC");
        console.log("  Monthly Extraction:", monthlyExtraction / 1e6, "USDC");
        console.log("  ANNUAL EXTRACTION:", annualExtraction / 1e6, "USDC");
        console.log("  As % of TVL:", annualExtraction * 100 / currentTVL, "%");
    }

    function _calculateExtraction(string memory scenario, uint256 amount, uint256 ppsDeltaBps) internal view {
        console.log(scenario);
        console.log("---");

        uint256 fairValue = amount * (10000 + ppsDeltaBps) / 10000;
        uint256 minPayout = amount * 995 / 1000; // requestPPS * 0.995
        uint256 extraction = fairValue - minPayout;

        console.log("  Amount:", amount / 1e6, "USDC");
        console.log("  PPS Move:", ppsDeltaBps, "bps");
        console.log("  Fair Value:", fairValue / 1e6, "USDC");
        console.log("  Min Payout:", minPayout / 1e6, "USDC");
        console.log("  Extraction:", extraction / 1e6, "USDC");
        console.log("");
    }
}
