// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
}

interface ICurvePool {
    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);
    function balances(uint256 i) external view returns (uint256);
    function coins(uint256 i) external view returns (address);
    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256);
    function fee() external view returns (uint256);
}

interface IUniV2Factory {
    function getPair(address tokenA, address tokenB) external view returns (address);
}

interface IUniV2Pair {
    function getReserves() external view returns (uint112, uint112, uint32);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}

interface IUniV3Factory {
    function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address);
}

interface IUniV3Pool {
    function slot0() external view returns (uint160, int24, uint16, uint16, uint16, uint8, bool);
    function liquidity() external view returns (uint128);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function flash(address recipient, uint256 amount0, uint256 amount1, bytes calldata data) external;
    function fee() external view returns (uint24);
}

interface IAaveV2Pool {
    function flashLoan(address, address[] calldata, uint256[] calldata, uint256[] calldata,
        address, bytes calldata, uint16) external;
    function getReserveData(address asset) external view returns (
        uint256, uint128, uint128, uint128, uint128, uint128, uint40,
        address aTokenAddress, address, address, address, uint8
    );
}

interface IBalancerVault {
    function flashLoan(address recipient, address[] calldata tokens,
        uint256[] calldata amounts, bytes calldata userData) external;
}

interface IHydroOracle {
    function getPrice(address asset) external view returns (uint256);
}

contract HydroFlashInvestigation is Test {
    address constant HYDRO = 0x241e82C79452F51fbfc89Fac6d912e021dB1a3B7;
    address constant HBTC = 0x0316EB71485b0Ab14103307bf65a021042c6d380;
    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant DAI  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;

    // Curve pools
    address constant CURVE_HBTC_POOL = 0x4CA9b3063Ec5866A4B82E437059D2C43d1be596F;

    // DEX factories
    address constant UNI_V2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;
    address constant UNI_V3_FACTORY = 0x1F98431c8aD98523631AE4a59f267346ea31F984;
    address constant SUSHI_FACTORY  = 0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac;

    // Flash loan providers
    address constant AAVE_V2_POOL   = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;
    address constant BALANCER_VAULT  = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

    uint16 constant MARKET_HBTC_USDT = 5;

    string constant RPC = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    function setUp() public {
        vm.createSelectFork(RPC);
    }

    // ========== TEST 1: Map all HBTC liquidity ==========
    function test_01_hbtc_liquidity_map() public view {
        console.log("=== HBTC LIQUIDITY MAP ===");
        console.log("Block:", block.number);

        // HBTC token state
        uint256 totalSupply = IERC20(HBTC).totalSupply();
        console.log("HBTC total supply:", totalSupply / 1e18);

        // Curve HBTC/WBTC pool
        console.log("");
        console.log("--- Curve HBTC/WBTC Pool ---");
        uint256 curveHBTC = IERC20(HBTC).balanceOf(CURVE_HBTC_POOL);
        uint256 curveWBTC = IERC20(WBTC).balanceOf(CURVE_HBTC_POOL);
        console.log("HBTC in pool (raw):", curveHBTC);
        console.log("HBTC in pool:", curveHBTC / 1e18);
        console.log("WBTC in pool (sat):", curveWBTC);

        // Exchange rates
        if (curveHBTC > 1e16) {
            try ICurvePool(CURVE_HBTC_POOL).get_dy(1, 0, 1e8) returns (uint256 out) {
                console.log("1 WBTC -> HBTC (raw):", out);
            } catch { console.log("get_dy 1->0 failed"); }
        }

        // Uniswap V2 HBTC pairs
        console.log("");
        console.log("--- Uniswap V2 HBTC Pairs ---");
        _logUniV2(UNI_V2_FACTORY, HBTC, WETH, "Uni HBTC/WETH");
        _logUniV2(UNI_V2_FACTORY, HBTC, USDT, "Uni HBTC/USDT");
        _logUniV2(UNI_V2_FACTORY, HBTC, WBTC, "Uni HBTC/WBTC");
        _logUniV2(UNI_V2_FACTORY, HBTC, USDC, "Uni HBTC/USDC");

        // SushiSwap HBTC pairs
        console.log("");
        console.log("--- SushiSwap HBTC Pairs ---");
        _logUniV2(SUSHI_FACTORY, HBTC, WETH, "Sushi HBTC/WETH");
        _logUniV2(SUSHI_FACTORY, HBTC, WBTC, "Sushi HBTC/WBTC");

        // Uniswap V3 HBTC pools
        console.log("");
        console.log("--- Uniswap V3 HBTC Pools ---");
        _logUniV3(HBTC, WETH, 3000, "HBTC/WETH 0.3%");
        _logUniV3(HBTC, WETH, 10000, "HBTC/WETH 1%");
        _logUniV3(HBTC, WBTC, 3000, "HBTC/WBTC 0.3%");
        _logUniV3(HBTC, USDT, 3000, "HBTC/USDT 0.3%");

        // Big HBTC holders
        console.log("");
        console.log("--- Known HBTC Holders ---");
        _logBalance(HBTC, CURVE_HBTC_POOL, "Curve HBTC Pool");
        _logBalance(HBTC, HYDRO, "Hydro");
        _logBalance(HBTC, BALANCER_VAULT, "Balancer Vault");
        _logBalance(HBTC, 0x28C6c06298d514Db089934071355E5743bf21d60, "Binance14");
        _logBalance(HBTC, 0x21a31Ee1afC51d94C2eFcCAa2092aD1028285549, "Binance15");
        _logBalance(HBTC, 0xDFd5293D8e347dFe59E90eFd55b2956a1343963d, "Binance");
        _logBalance(HBTC, 0x6cC5F688a315f3dC28A7781717a9A798a59fDA7b, "OKX");
        _logBalance(HBTC, 0x46340b20830761efd32832A74d7169B29FEB9758, "CryptoCom");
    }

    // ========== TEST 2: Hydro protocol state ==========
    function test_02_hydro_state() public view {
        console.log("=== HYDRO PROTOCOL STATE ===");
        console.log("USDT:", IERC20(USDT).balanceOf(HYDRO) / 1e6, "USDT");
        console.log("USDC:", IERC20(USDC).balanceOf(HYDRO) / 1e6, "USDC");
        console.log("DAI:", IERC20(DAI).balanceOf(HYDRO) / 1e18, "DAI");
        console.log("WBTC:", IERC20(WBTC).balanceOf(HYDRO));
        console.log("HBTC:", IERC20(HBTC).balanceOf(HYDRO));
        console.log("ETH:", HYDRO.balance / 1e18, "ETH");
        console.log("USDT raw:", IERC20(USDT).balanceOf(HYDRO));

        // Oracle check
        console.log("");
        console.log("--- Hydro Oracle ---");
        // Read oracle from Hydro storage
        // slot for oracle mapping is protocol-specific
    }

    // ========== TEST 3: Flash loan providers ==========
    function test_03_flash_providers() public view {
        console.log("=== FLASH LOAN PROVIDERS ===");

        // Aave V2 reserves
        console.log("--- Aave V2 ---");
        _logAaveV2(WBTC, "WBTC");
        _logAaveV2(USDT, "USDT");
        _logAaveV2(USDC, "USDC");
        _logAaveV2(DAI, "DAI");
        _logAaveV2(WETH, "WETH");
        _logAaveV2(HBTC, "HBTC");

        // Balancer
        console.log("");
        console.log("--- Balancer Vault ---");
        _logBalance(WBTC, BALANCER_VAULT, "WBTC");
        _logBalance(USDT, BALANCER_VAULT, "USDT");
        _logBalance(USDC, BALANCER_VAULT, "USDC");
        _logBalance(DAI, BALANCER_VAULT, "DAI");
        _logBalance(WETH, BALANCER_VAULT, "WETH");
        _logBalance(HBTC, BALANCER_VAULT, "HBTC");

        // UniV2 flash swap sources (WBTC pairs)
        console.log("");
        console.log("--- Uniswap V2 Flash Swap (WBTC) ---");
        _logUniV2(UNI_V2_FACTORY, WBTC, WETH, "WBTC/WETH");
        _logUniV2(UNI_V2_FACTORY, WBTC, USDT, "WBTC/USDT");
        _logUniV2(UNI_V2_FACTORY, WBTC, USDC, "WBTC/USDC");

        // UniV3 flash (WBTC pools)
        console.log("");
        console.log("--- Uniswap V3 Flash (WBTC) ---");
        _logUniV3(WBTC, WETH, 3000, "WBTC/WETH 0.3%");
        _logUniV3(WBTC, WETH, 500, "WBTC/WETH 0.05%");
        _logUniV3(WBTC, USDC, 3000, "WBTC/USDC 0.3%");
    }

    // ========== TEST 4: Curve exchange rates ==========
    function test_04_curve_rates() public view {
        console.log("=== CURVE EXCHANGE RATES ===");

        // Coin layout
        address c0 = ICurvePool(CURVE_HBTC_POOL).coins(0);
        address c1 = ICurvePool(CURVE_HBTC_POOL).coins(1);
        console.log("coins(0):", c0);
        console.log("coins(1):", c1);
        console.log("(HBTC:", HBTC, ")");
        console.log("(WBTC:", WBTC, ")");

        uint256 b0 = ICurvePool(CURVE_HBTC_POOL).balances(0);
        uint256 b1 = ICurvePool(CURVE_HBTC_POOL).balances(1);
        console.log("balances(0):", b0);
        console.log("balances(1):", b1);

        try ICurvePool(CURVE_HBTC_POOL).fee() returns (uint256 f) {
            console.log("Pool fee:", f);
        } catch {}

        console.log("");
        console.log("--- WBTC -> HBTC rates ---");
        uint256[6] memory amounts = [uint256(0.01e8), 0.05e8, 0.1e8, 0.5e8, 1e8, 2e8];
        for (uint i = 0; i < amounts.length; i++) {
            try ICurvePool(CURVE_HBTC_POOL).get_dy(1, 0, amounts[i]) returns (uint256 out) {
                console.log("WBTC in (sat):", amounts[i]);
                console.log("  HBTC out (raw):", out);
            } catch {
                console.log("WBTC in (sat):", amounts[i]);
                console.log("  FAILED (insufficient liquidity)");
            }
        }

        console.log("");
        console.log("--- HBTC -> WBTC rates ---");
        uint256[4] memory hAmounts = [uint256(0.1e18), 0.5e18, 1e18, 2e18];
        for (uint i = 0; i < hAmounts.length; i++) {
            try ICurvePool(CURVE_HBTC_POOL).get_dy(0, 1, hAmounts[i]) returns (uint256 out) {
                console.log("HBTC in (raw):", hAmounts[i]);
                console.log("  WBTC out (sat):", out);
            } catch {
                console.log("HBTC in (raw):", hAmounts[i]);
                console.log("  FAILED");
            }
        }
    }

    // ========== TEST 5: All Uniswap HBTC pairs deep dive ==========
    function test_05_uniswap_hbtc_deep() public view {
        console.log("=== UNISWAP HBTC DEEP DIVE ===");

        // Check ALL fee tiers for V3
        uint24[4] memory fees = [uint24(100), 500, 3000, 10000];
        address[4] memory tokens = [WETH, WBTC, USDT, USDC];
        string[4] memory names = ["WETH", "WBTC", "USDT", "USDC"];

        for (uint i = 0; i < tokens.length; i++) {
            console.log("");
            console.log("HBTC /", names[i]);
            for (uint j = 0; j < fees.length; j++) {
                address pool = IUniV3Factory(UNI_V3_FACTORY).getPool(HBTC, tokens[i], fees[j]);
                if (pool != address(0)) {
                    uint128 liq = IUniV3Pool(pool).liquidity();
                    uint256 bal0 = IERC20(IUniV3Pool(pool).token0()).balanceOf(pool);
                    uint256 bal1 = IERC20(IUniV3Pool(pool).token1()).balanceOf(pool);
                    console.log("  V3 fee:", fees[j]);
                    console.log("    pool:", pool);
                    console.log("    liquidity:", liq);
                    console.log("    token0 bal:", bal0);
                    console.log("    token1 bal:", bal1);
                }
            }
        }

        // Check if there's a Uniswap V2 HBTC/WETH pair (flash swap source)
        console.log("");
        address hbtcWeth = IUniV2Factory(UNI_V2_FACTORY).getPair(HBTC, WETH);
        console.log("Uni V2 HBTC/WETH:", hbtcWeth);
        if (hbtcWeth != address(0)) {
            (uint112 r0, uint112 r1,) = IUniV2Pair(hbtcWeth).getReserves();
            console.log("  r0:", uint256(r0));
            console.log("  r1:", uint256(r1));
            console.log("  token0:", IUniV2Pair(hbtcWeth).token0());
        }
    }

    // ========== TEST 6: Profit calculation for all routes ==========
    function test_06_profit_routes() public view {
        console.log("=== PROFIT ROUTE ANALYSIS ===");
        uint256 hydroUSDT = IERC20(USDT).balanceOf(HYDRO);
        uint256 curveHBTC = IERC20(HBTC).balanceOf(CURVE_HBTC_POOL);

        console.log("Hydro USDT available:", hydroUSDT / 1e6);
        console.log("Curve HBTC available:", curveHBTC / 1e18);
        console.log("Curve HBTC raw:", curveHBTC);

        // Route A: Flash WBTC -> Curve WBTC->HBTC -> Hydro deposit+borrow USDT
        // Then: use USDT to buy back WBTC to repay flash, keep profit
        console.log("");
        console.log("=== ROUTE A: Flash WBTC -> Curve -> Hydro ===");
        console.log("Step 1: Flash loan WBTC (Balancer: 0 fee)");

        // Need to know: how much WBTC to get all curve HBTC?
        // We need to try amounts
        if (curveHBTC > 0) {
            // Try 1 WBTC
            try ICurvePool(CURVE_HBTC_POOL).get_dy(1, 0, 1e8) returns (uint256 hOut) {
                console.log("1 WBTC -> HBTC:", hOut / 1e18);
                // Each HBTC borrows ~51,600 USDT from Hydro
                uint256 borrowable = (hOut * 51600) / 1e18;
                console.log("  Borrowable USDT:", borrowable);
                // Cost: need to repay 1 WBTC. At ~$65K, need ~65000 USDT to buy back
                console.log("  Cost to repay (USDT):", uint256(65000));
                if (borrowable > 65000) {
                    console.log("  NET PROFIT:", borrowable - 65000);
                } else {
                    console.log("  NET LOSS:", 65000 - borrowable);
                }
            } catch {
                console.log("1 WBTC -> HBTC: FAILED");
            }
        }

        // Route B: Flash USDT -> buy HBTC via Curve (USDT->WBTC->HBTC) -> Hydro borrow
        console.log("");
        console.log("=== ROUTE B: Flash USDT -> DEX -> Hydro ===");
        console.log("Need: USDT -> WBTC -> HBTC path");

        // Route C: Direct flash swap HBTC from Uniswap V2/V3 if pairs exist
        console.log("");
        console.log("=== ROUTE C: Flash Swap HBTC directly ===");
        address hbtcWethV2 = IUniV2Factory(UNI_V2_FACTORY).getPair(HBTC, WETH);
        if (hbtcWethV2 != address(0)) {
            (uint112 r0, uint112 r1,) = IUniV2Pair(hbtcWethV2).getReserves();
            console.log("V2 HBTC/WETH exists!");
            console.log("  reserves:", uint256(r0));
            console.log("  reserves:", uint256(r1));
        } else {
            console.log("No V2 HBTC/WETH pair");
        }

        // Route D: Multi-source - combine Curve + Uniswap HBTC
        console.log("");
        console.log("=== ROUTE D: Multi-source HBTC ===");
        console.log("Curve HBTC:", curveHBTC / 1e18);
        // Any other HBTC source on chain?
    }

    // ========== HELPERS ==========

    function _logUniV2(address factory, address tA, address tB, string memory label) internal view {
        address pair = IUniV2Factory(factory).getPair(tA, tB);
        if (pair != address(0)) {
            (uint112 r0, uint112 r1,) = IUniV2Pair(pair).getReserves();
            console.log(label, "pair:", pair);
            console.log("  r0:", uint256(r0));
            console.log("  r1:", uint256(r1));
        } else {
            console.log(label, ": NO PAIR");
        }
    }

    function _logUniV3(address tA, address tB, uint24 fee, string memory label) internal view {
        address pool = IUniV3Factory(UNI_V3_FACTORY).getPool(tA, tB, fee);
        if (pool != address(0)) {
            uint128 liq = IUniV3Pool(pool).liquidity();
            console.log(label, "pool:", pool);
            console.log("  liquidity:", liq);
        } else {
            console.log(label, ": NO POOL");
        }
    }

    function _logBalance(address token, address holder, string memory label) internal view {
        uint256 bal = IERC20(token).balanceOf(holder);
        console.log(label, ":", bal);
    }

    function _logAaveV2(address asset, string memory label) internal view {
        try IAaveV2Pool(AAVE_V2_POOL).getReserveData(asset) returns (
            uint256, uint128, uint128, uint128, uint128, uint128, uint40,
            address aToken, address, address, address, uint8
        ) {
            uint256 avail = IERC20(asset).balanceOf(aToken);
            console.log(label, "aToken:", aToken);
            console.log("  available:", avail);
        } catch {
            console.log(label, ": NOT in Aave V2");
        }
    }
}
