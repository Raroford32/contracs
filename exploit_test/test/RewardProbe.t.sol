// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IRewards {
    function stake(uint256) external;
    function withdraw(uint256) external;
    function getReward() external;
    function earned(address) external view returns (uint256);
    function balanceOf(address) external view returns (uint256);
    function rewardRate() external view returns (uint256);
    function totalSupply() external view returns (uint256);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

// Check staking contracts for flash stake vulnerabilities
contract RewardProbeTest is Test {
    // Staking contracts from the list
    address[] targets = [
        0x10ab606B067C9C461d8893c47C7512472E19e2Ce,  // StakingRewards
        0x5954aB967Bc958940b7EB73ee84797Dc8a2AFbb9   // ApeCoin staking
    ];
    
    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testRewardStates() public view {
        for (uint i = 0; i < targets.length; i++) {
            console.log("\n=== Target:", targets[i], "===");
            IRewards r = IRewards(targets[i]);
            
            try r.rewardRate() returns (uint256 rate) {
                console.log("rewardRate:", rate);
            } catch {}
            
            try r.totalSupply() returns (uint256 supply) {
                console.log("totalSupply:", supply);
            } catch {}
            
            try r.earned(address(this)) returns (uint256 earned) {
                console.log("earned(this):", earned);
            } catch {}
        }
    }

    // Check if there's any ETH-based staking pool we can exploit
    function testETHStakingVectors() public {
        console.log("\n=== ETH Staking Vectors ===");
        
        // Check for ETH-accepting staking contracts
        address[] memory ethTargets = new address[](3);
        ethTargets[0] = 0xC82Abe4dFA94b9B5453d31274Fb7500459a0d12d;  // 9997 ETH unverified
        ethTargets[1] = 0x9cbDbd7Fa768Ad6E9546FF57238722fA9B925329;  // 3274 ETH unverified
        ethTargets[2] = 0xdD276dc5223d0120F9BF1776F38957CC8DA23Cb0;  // 800 ETH
        
        for (uint i = 0; i < ethTargets.length; i++) {
            address t = ethTargets[i];
            console.log("\nTarget:", t);
            console.log("Balance:", t.balance / 1e18, "ETH");
            
            // Try sending 1 wei to see if it's a deposit contract
            uint256 balBefore = t.balance;
            (bool success,) = t.call{value: 1}("");
            console.log("Accept ETH:", success);
            
            // Check storage slot 0 for owner/admin pattern
            bytes32 slot0 = vm.load(t, bytes32(uint256(0)));
            address potentialOwner = address(uint160(uint256(slot0)));
            if (potentialOwner != address(0) && potentialOwner.code.length == 0) {
                console.log("Potential owner:", potentialOwner);
            }
        }
    }
}
