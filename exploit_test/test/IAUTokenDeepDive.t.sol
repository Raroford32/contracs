// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

interface IIAU {
    function mint(address to, uint256 amount) external;
    function burn(address from, uint256 amount) external;
    function transfer(address to, uint256 amount) external returns (bool);
}

contract IAUTokenDeepDive is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeIAUBytecode() public view {
        console.log("=== ANALYZING IAU TOKEN BYTECODE ===\n");

        bytes memory code = IAU.code;
        console.log("IAU code size:", code.length);

        // Find all function selectors
        console.log("\nIAU function selectors (unique):");
        bytes4[] memory uniqueSels = new bytes4[](100);
        uint selCount = 0;

        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == 0xffffffff || sel == bytes4(0)) continue;

                bool isUnique = true;
                for (uint j = 0; j < selCount; j++) {
                    if (uniqueSels[j] == sel) {
                        isUnique = false;
                        break;
                    }
                }

                if (isUnique && selCount < 100) {
                    uniqueSels[selCount] = sel;
                    selCount++;
                }
            }
        }

        for (uint i = 0; i < selCount && i < 50; i++) {
            console.logBytes4(uniqueSels[i]);
        }
    }

    function test_CheckIAUForCallbacks() public view {
        console.log("=== CHECKING IAU FOR CALLBACK PATTERNS ===\n");

        bytes memory code = IAU.code;

        // Look for CALL opcodes
        uint callCount = 0;
        uint delegatecallCount = 0;
        uint staticcallCount = 0;

        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf1) callCount++;
            if (uint8(code[i]) == 0xf4) delegatecallCount++;
            if (uint8(code[i]) == 0xfa) staticcallCount++;
        }

        console.log("CALL count:", callCount);
        console.log("DELEGATECALL count:", delegatecallCount);
        console.log("STATICCALL count:", staticcallCount);

        // Check for known callback selectors
        console.log("\nSearching for callback selectors:");

        // ERC777 tokensReceived
        bytes4 tokensReceived = bytes4(keccak256("tokensReceived(address,address,address,uint256,bytes,bytes)"));
        // transferAndCall
        bytes4 transferAndCall = bytes4(keccak256("transferAndCall(address,uint256,bytes)"));
        // onTokenTransfer
        bytes4 onTokenTransfer = bytes4(keccak256("onTokenTransfer(address,uint256,bytes)"));
        // approveAndCall
        bytes4 approveAndCall = bytes4(keccak256("approveAndCall(address,uint256,bytes)"));

        console.log("tokensReceived:");
        console.logBytes4(tokensReceived);
        console.log("transferAndCall:");
        console.logBytes4(transferAndCall);
        console.log("onTokenTransfer:");
        console.logBytes4(onTokenTransfer);
        console.log("approveAndCall:");
        console.logBytes4(approveAndCall);

        // Search in code
        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == transferAndCall) {
                    console.log("FOUND transferAndCall at:", i);
                }
                if (sel == approveAndCall) {
                    console.log("FOUND approveAndCall at:", i);
                }
            }
        }
    }

    function test_CheckIAUStorage() public view {
        console.log("=== CHECKING IAU STORAGE ===\n");

        console.log("Key storage slots:");
        for (uint i = 0; i < 15; i++) {
            bytes32 slot = vm.load(IAU, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("  Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // Check EIP-1967 slots
        bytes32 impl = vm.load(IAU, bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));
        bytes32 admin = vm.load(IAU, bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));

        console.log("\nEIP-1967 slots:");
        console.log("Implementation slot:");
        console.logBytes32(impl);
        console.log("Admin slot:");
        console.logBytes32(admin);
    }

    function test_TryIAUFunctions() public {
        console.log("=== TRYING IAU FUNCTIONS ===\n");

        deal(IAU, attacker, 10000e18);

        vm.startPrank(attacker);

        // Try transferAndCall if exists
        (bool s1,) = IAU.call(
            abi.encodeWithSignature("transferAndCall(address,uint256,bytes)", REDEMPTION_0, 100e18, "")
        );
        console.log("transferAndCall:", s1);

        // Try approveAndCall
        (bool s2,) = IAU.call(
            abi.encodeWithSignature("approveAndCall(address,uint256,bytes)", REDEMPTION_0, 100e18, "")
        );
        console.log("approveAndCall:", s2);

        // Try permit
        (bool s3,) = IAU.call(
            abi.encodeWithSignature("permit(address,address,uint256,uint256,uint8,bytes32,bytes32)",
                attacker, REDEMPTION_0, 100e18, block.timestamp + 1000, 27, bytes32(0), bytes32(0))
        );
        console.log("permit:", s3);

        vm.stopPrank();
    }

    function test_CheckRedemption0ForCallbacks() public view {
        console.log("=== CHECKING REDEMPTION_0 FOR CALLBACK TRIGGERS ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Find all CALL opcodes and analyze what they call
        console.log("CALL opcodes in REDEMPTION_0:");
        uint callNum = 0;

        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf1) {
                callNum++;
                console.log("\nCALL #", callNum, "at offset:", i);

                // Look backwards for what address is being called
                uint start = i > 100 ? i - 100 : 0;
                for (uint j = start; j < i; j++) {
                    if (uint8(code[j]) == 0x73) { // PUSH20
                        bytes memory addrBytes = new bytes(20);
                        for (uint k = 0; k < 20 && j + 1 + k < code.length; k++) {
                            addrBytes[k] = code[j + 1 + k];
                        }
                        address addr = address(bytes20(addrBytes));
                        if (addr != address(0)) {
                            console.log("  Found address:", addr);
                        }
                    }
                }
            }
        }
    }

    function test_InvestigateRedemption0RedeemFunction() public view {
        console.log("=== INVESTIGATING REDEMPTION_0 REDEEM FUNCTION ===\n");

        // The redeem(uint96) function should:
        // 1. Transfer IAU from caller
        // 2. Create a redemption request
        // 3. Maybe call something that we can hook into

        bytes memory code = REDEMPTION_0.code;

        // redeem(uint96) = 0x7bde82f2
        bytes4 redeemSel = bytes4(keccak256("redeem(uint96)"));
        console.log("redeem(uint96) selector:");
        console.logBytes4(redeemSel);

        // Find where this selector is used
        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == redeemSel) {
                    console.log("Found redeem selector at offset:", i);
                }
            }
        }
    }

    function test_CheckForDelegateCallInTransfer() public view {
        console.log("=== CHECKING IF IAU TRANSFER TRIGGERS DELEGATECALL ===\n");

        // When we transfer IAU to REDEMPTION_0, does it trigger any callbacks?
        // Let's check the IAU transfer function

        bytes memory code = IAU.code;

        // transfer(address,uint256) = 0xa9059cbb
        bytes4 transferSel = bytes4(keccak256("transfer(address,uint256)"));
        console.log("transfer selector:");
        console.logBytes4(transferSel);

        // Check if there's a CALL or DELEGATECALL after transfer logic
        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == transferSel) {
                    console.log("Found transfer selector at offset:", i);

                    // Look for CALL/DELEGATECALL in next 500 bytes
                    for (uint j = i; j < i + 500 && j < code.length; j++) {
                        if (uint8(code[j]) == 0xf1) {
                            console.log("  CALL at:", j);
                        }
                        if (uint8(code[j]) == 0xf4) {
                            console.log("  DELEGATECALL at:", j);
                        }
                    }
                    break;
                }
            }
        }
    }

    function test_InvestigateVaultDeposit() public {
        console.log("=== INVESTIGATING VAULT DEPOSIT FLOW ===\n");

        // Maybe we can exploit via the deposit flow?
        // If depositing triggers some callback...

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        deal(wstETH, attacker, 10 ether);

        vm.startPrank(attacker);
        IERC20(wstETH).approve(VAULT, type(uint256).max);

        // Try deposit functions
        (bool s1,) = VAULT.call(
            abi.encodeWithSignature("deposit(uint256,address)", 1 ether, attacker)
        );
        console.log("deposit(uint256,address):", s1);

        (bool s2,) = VAULT.call(
            abi.encodeWithSignature("mint(uint256,address)", 1 ether, attacker)
        );
        console.log("mint(uint256,address):", s2);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH after:", vaultAfter / 1e18);
    }

    function test_CheckStrategyInteraction() public view {
        console.log("=== CHECKING STRATEGY INTERACTION ===\n");

        // The Aave strategy at 0x60d2D94 might have callback patterns

        address STRATEGY = 0x60D2d9485c3C5e59f5C65D00691e6894ADCDb396;

        bytes memory code = STRATEGY.code;
        console.log("Strategy code size:", code.length);

        if (code.length > 0) {
            // Find function selectors
            console.log("\nStrategy function selectors:");
            bytes4[] memory uniqueSels = new bytes4[](50);
            uint selCount = 0;

            for (uint i = 0; i + 4 < code.length; i++) {
                if (uint8(code[i]) == 0x63) {
                    bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                    if (sel == 0xffffffff || sel == bytes4(0)) continue;

                    bool isUnique = true;
                    for (uint j = 0; j < selCount; j++) {
                        if (uniqueSels[j] == sel) {
                            isUnique = false;
                            break;
                        }
                    }

                    if (isUnique && selCount < 50) {
                        uniqueSels[selCount] = sel;
                        selCount++;
                    }
                }
            }

            for (uint i = 0; i < selCount && i < 30; i++) {
                console.logBytes4(uniqueSels[i]);
            }

            // Check for DELEGATECALL
            uint dcCount = 0;
            for (uint i = 0; i < code.length; i++) {
                if (uint8(code[i]) == 0xf4) dcCount++;
            }
            console.log("\nDELEGATECALL count:", dcCount);
        }
    }
}
