// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";

interface ICellar {
    function totalAssets() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function asset() external view returns (address);
    function deposit(uint256 assets, address receiver) external returns (uint256);
    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256);
    function redeem(uint256 shares, address receiver, address owner) external returns (uint256);
    function convertToShares(uint256 assets) external view returns (uint256);
    function convertToAssets(uint256 shares) external view returns (uint256);
    function previewDeposit(uint256 assets) external view returns (uint256);
    function previewRedeem(uint256 shares) external view returns (uint256);
    function balanceOf(address) external view returns (uint256);
    function owner() external view returns (address);
    function isShutdown() external view returns (bool);
    function automationActions() external view returns (address);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

interface IBalancerVault {
    function flashLoan(
        address recipient,
        address[] calldata tokens,
        uint256[] calldata amounts,
        bytes calldata userData
    ) external;
}

contract CellarExploit is Test {
    address constant CELLAR = 0xeA1A6307D9b18F8d1cbf1c3Dd6aad8416C06a221;
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address attacker = makeAddr("attacker");

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testCellarState() public view {
        ICellar cellar = ICellar(CELLAR);

        console.log("=== Cellar State Analysis ===");
        console.log("Cellar:", CELLAR);

        // Check basic state
        try cellar.totalAssets() returns (uint256 totalAssets) {
            console.log("Total Assets:", totalAssets);
        } catch {
            console.log("totalAssets() failed");
        }

        try cellar.totalSupply() returns (uint256 totalSupply) {
            console.log("Total Supply:", totalSupply);
        } catch {
            console.log("totalSupply() failed");
        }

        try cellar.asset() returns (address asset) {
            console.log("Asset:", asset);
            console.log("Asset balance in cellar:", IERC20(asset).balanceOf(CELLAR));
        } catch {
            console.log("asset() failed");
        }

        try cellar.owner() returns (address owner) {
            console.log("Owner:", owner);
        } catch {
            console.log("owner() failed");
        }

        try cellar.isShutdown() returns (bool shutdown) {
            console.log("Is Shutdown:", shutdown);
        } catch {
            console.log("isShutdown() failed");
        }

        // Check share/asset conversion
        try cellar.convertToShares(1e18) returns (uint256 shares) {
            console.log("1 asset -> shares:", shares);
        } catch {
            console.log("convertToShares() failed");
        }

        try cellar.convertToAssets(1e18) returns (uint256 assets) {
            console.log("1 share -> assets:", assets);
        } catch {
            console.log("convertToAssets() failed");
        }
    }

    function testCheckShareInflationAttack() public {
        ICellar cellar = ICellar(CELLAR);

        // Check if vault is empty (potential inflation attack)
        try cellar.totalSupply() returns (uint256 totalSupply) {
            try cellar.totalAssets() returns (uint256 totalAssets) {
                console.log("Total Supply:", totalSupply);
                console.log("Total Assets:", totalAssets);

                if (totalSupply == 0 || totalAssets == 0) {
                    console.log("!!! POTENTIAL: Empty vault - inflation attack possible !!!");
                }

                if (totalSupply > 0 && totalAssets > 0) {
                    uint256 ratio = (totalAssets * 1e18) / totalSupply;
                    console.log("Asset/Share ratio:", ratio);

                    // Check for abnormal ratio
                    if (ratio > 1e19 || ratio < 1e17) {
                        console.log("!!! ABNORMAL RATIO !!!");
                    }
                }
            } catch {}
        } catch {}
    }

    function testCheckFlashLoanAttack() public {
        ICellar cellar = ICellar(CELLAR);

        console.log("=== Flash Loan Attack Check ===");

        // Check if we can use flash loans to manipulate the vault
        try cellar.asset() returns (address asset) {
            console.log("Cellar asset:", asset);

            // Check balancer vault balance of this asset
            uint256 balancerBalance = IERC20(asset).balanceOf(BALANCER_VAULT);
            console.log("Balancer Vault has:", balancerBalance);

            // Check cellar total assets
            try cellar.totalAssets() returns (uint256 totalAssets) {
                console.log("Cellar total assets:", totalAssets);

                // Check if flash loan could significantly impact price
                if (balancerBalance > totalAssets * 10) {
                    console.log("!!! Flash loan could be 10x+ cellar assets !!!");
                }
            } catch {}
        } catch {}
    }

    function testCheckOracleManipulation() public {
        ICellar cellar = ICellar(CELLAR);

        console.log("=== Oracle Check ===");

        // Check if there's an automationActions contract that might have oracle logic
        try cellar.automationActions() returns (address automation) {
            console.log("Automation Actions:", automation);
        } catch {
            console.log("No automationActions");
        }

        // Try to check oracle-related functions
        (bool success, bytes memory data) = CELLAR.staticcall(abi.encodeWithSignature("sharePriceOracle()"));
        if (success && data.length >= 32) {
            address oracle = abi.decode(data, (address));
            console.log("Share Price Oracle:", oracle);

            if (oracle != address(0)) {
                // Check oracle price
                (success, data) = oracle.staticcall(abi.encodeWithSignature("getLatestAnswer()"));
                if (success && data.length >= 32) {
                    uint256 price = abi.decode(data, (uint256));
                    console.log("Oracle price:", price);
                }
            }
        }
    }

    function testDepositWithdrawExploit() public {
        ICellar cellar = ICellar(CELLAR);

        console.log("=== Deposit/Withdraw Exploit Check ===");

        try cellar.asset() returns (address asset) {
            // Try to get some of the asset via deal
            vm.startPrank(attacker);

            // Check if we can deposit and withdraw atomically
            try cellar.previewDeposit(1e18) returns (uint256 sharesOut) {
                console.log("Preview deposit 1e18:", sharesOut, "shares");

                if (sharesOut > 0) {
                    try cellar.previewRedeem(sharesOut) returns (uint256 assetsBack) {
                        console.log("Preview redeem shares:", sharesOut);
                        console.log("Assets back:", assetsBack);

                        // Check for rounding profit
                        if (assetsBack > 1e18) {
                            console.log("!!! POTENTIAL: Rounding profit possible !!!");
                        }
                    } catch {}
                }
            } catch {}

            vm.stopPrank();
        } catch {}
    }
}
