// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

interface ISavingAccount {
    function mint(uint256 amount) external;
    function redeem(uint256 amount) external;
    function claimRedeem(uint256 idx) external;
    function getSharesByAmount(uint256 amount) external view returns (uint256);
    function getAmountByShares(uint256 shares) external view returns (uint256);
    function getTotalUnderlying() external view returns (uint256);
    function totalUnderlying() external view returns (uint256);
    function totalsUSDaLockedAmount() external view returns (uint256);
    function targetAPR() external view returns (uint256);
    function unpaidInterest() external view returns (uint256);
    function usda() external view returns (address);
    function susda() external view returns (address);
    function processPeriod() external view returns (uint256);
    function redeemDetails(uint256) external view returns (uint256, uint256, address, uint256, bool);
}

/**
 * @title SavingAccount Deep Analysis - Complex Insolvency Scenario
 * @notice Analyzing the gap between promised returns and actual backing
 *
 * REASONING:
 * 1. totalUnderlying grows based on APR calculation (virtual interest)
 * 2. unpaidInterest tracks what POOL_MANAGER should deposit
 * 3. If POOL_MANAGER never calls distributeInterests(), contract becomes insolvent
 * 4. Users can redeem based on inflated totalUnderlying, but actual USDA is less
 *
 * COMPLEX SCENARIO:
 * - Last users to redeem cannot claim because USDA balance is exhausted
 * - This creates a "bank run" scenario where early redeemers win
 */
contract SavingAccountDeepAnalysisTest is Test {
    address constant SAVING_ACCOUNT = 0x01e3cc8E17755989ad2CAFE78A822354Eb5DdFA6;

    ISavingAccount savingAccount;
    IERC20 usda;
    IERC20 susda;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        savingAccount = ISavingAccount(SAVING_ACCOUNT);
        usda = IERC20(savingAccount.usda());
        susda = IERC20(savingAccount.susda());
    }

    function testInsolvencyGapAnalysis() public view {
        uint256 actualUsdaBalance = usda.balanceOf(SAVING_ACCOUNT);
        uint256 promisedUnderlying = savingAccount.getTotalUnderlying();
        uint256 unpaidInterest = savingAccount.unpaidInterest();
        uint256 totalShares = savingAccount.totalsUSDaLockedAmount();

        console.log("=== Insolvency Gap Analysis ===");
        console.log("Actual USDA in contract:", actualUsdaBalance);
        console.log("Promised totalUnderlying:", promisedUnderlying);
        console.log("Unpaid interest:", unpaidInterest);
        console.log("Total sUSDA shares:", totalShares);

        // Calculate the gap
        if (promisedUnderlying > actualUsdaBalance) {
            uint256 gap = promisedUnderlying - actualUsdaBalance;
            console.log("\n[CRITICAL] Insolvency Gap:", gap);
            console.log("Gap as % of promised:", gap * 100 / promisedUnderlying, "%");

            // Calculate how many users can actually redeem
            uint256 redeemableShares = (actualUsdaBalance * totalShares) / promisedUnderlying;
            uint256 strandedShares = totalShares - redeemableShares;
            console.log("\nShares that can be redeemed:", redeemableShares);
            console.log("Shares that will be stranded:", strandedShares);
            console.log("Stranded as % of total:", strandedShares * 100 / totalShares, "%");
        }
    }

    function testBankRunScenario() public view {
        uint256 actualUsdaBalance = usda.balanceOf(SAVING_ACCOUNT);
        uint256 totalShares = savingAccount.totalsUSDaLockedAmount();
        uint256 promisedUnderlying = savingAccount.getTotalUnderlying();

        console.log("\n=== Bank Run Scenario Analysis ===");

        // If all users try to redeem simultaneously
        uint256 totalPromisedPayout = promisedUnderlying;

        console.log("Total promised payout:", totalPromisedPayout);
        console.log("Actual available:", actualUsdaBalance);

        if (totalPromisedPayout > actualUsdaBalance) {
            uint256 shortfall = totalPromisedPayout - actualUsdaBalance;
            console.log("\n[!] SHORTFALL:", shortfall);

            // Percentage of users who lose everything
            uint256 lossPercentage = shortfall * 100 / totalPromisedPayout;
            console.log("Last", lossPercentage, "% of redeemers lose their funds");

            // In USDA terms
            console.log("Total funds at risk:", shortfall);
        }
    }

    function testRedeemRaceCondition() public view {
        // Check processPeriod - users must wait before claiming
        uint256 processPeriod = savingAccount.processPeriod();
        uint256 actualBalance = usda.balanceOf(SAVING_ACCOUNT);
        uint256 promisedUnderlying = savingAccount.getTotalUnderlying();

        console.log("\n=== Redeem Race Condition Analysis ===");
        console.log("Process period:", processPeriod / 1 days, "days");

        // During processPeriod, interest continues accruing
        // New redeemers during this period increase the gap further
        uint256 targetAPR = savingAccount.targetAPR();
        uint256 APR_COEFFICIENT = 10**8;

        // Interest accrued during processPeriod
        uint256 rps = (targetAPR * savingAccount.totalUnderlying()) / 365 days / APR_COEFFICIENT;
        uint256 interestDuringProcess = rps * processPeriod;

        console.log("Interest accruing during wait period:", interestDuringProcess);
        console.log("This further increases the insolvency gap");

        // Gap grows while users wait
        uint256 currentGap = promisedUnderlying > actualBalance ? promisedUnderlying - actualBalance : 0;
        uint256 projectedGap = currentGap + interestDuringProcess;
        console.log("\nCurrent gap:", currentGap);
        console.log("Projected gap after process period:", projectedGap);
    }
}
