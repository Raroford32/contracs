// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

interface IStabilityPool {
    function getCompoundedTHUSDDeposit(address) external view returns (uint256);
    function getDepositorCollateralGain(address) external view returns (uint256);
    function provideToSP(uint256) external;
    function withdrawFromSP(uint256) external;
}

interface IAggregatorV3 {
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
    function decimals() external view returns (uint8);
}

// Need to call BAMM via low-level calls since interface might differ
contract BAMMRealExploit is Test {
    // Known addresses
    address constant THUSD = 0xCFC5bD99915aAa815401C5a41A927aB7a38d29cf;
    address constant BAMM_ADDRESS = 0x097f1ee62E63aCFC3Bf64c1a61d96B3771dd06cB;

    uint256 constant PRECISION = 1e18;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testReadBAMMState() public view {
        console.log("====================================================");
        console.log("READING ACTUAL BAMM STATE");
        console.log("====================================================");

        // Check THUSD balance directly
        uint256 thusdBalance = IERC20(THUSD).balanceOf(BAMM_ADDRESS);
        console.log("THUSD in BAMM:", thusdBalance / 1e18);

        // Try to read various state via raw calls
        console.log("\n--- Attempting to read BAMM storage ---");

        // Common function selectors
        _tryCall(BAMM_ADDRESS, "SP()");
        _tryCall(BAMM_ADDRESS, "priceAggregator()");
        _tryCall(BAMM_ADDRESS, "collateralERC20()");
        _tryCall(BAMM_ADDRESS, "A()");
        _tryCall(BAMM_ADDRESS, "fee()");
        _tryCall(BAMM_ADDRESS, "maxDiscount()");
        _tryCall(BAMM_ADDRESS, "totalSupply()");
        _tryCall(BAMM_ADDRESS, "fetchPrice()");
        _tryCall(BAMM_ADDRESS, "getCollateralBalance()");
    }

    function _tryCall(address target, string memory sig) internal view {
        (bool success, bytes memory data) = target.staticcall(
            abi.encodeWithSignature(sig)
        );

        console.log("\n", sig);
        if (success && data.length >= 32) {
            if (data.length == 32) {
                uint256 val = abi.decode(data, (uint256));
                if (val > 0 && val < type(uint160).max) {
                    // Could be address
                    console.log("  Value/Address:", val);
                } else {
                    console.log("  Value:", val);
                }
            }
        } else {
            console.log("  FAILED");
        }
    }

    function testAnalyzeContractCode() public view {
        console.log("====================================================");
        console.log("ANALYZING CONTRACT CODE AT BAMM ADDRESS");
        console.log("====================================================");

        // Check if it's a proxy
        bytes32 implementationSlot = bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1);
        bytes32 impl = vm.load(BAMM_ADDRESS, implementationSlot);

        if (uint256(impl) != 0) {
            console.log("Contract is a PROXY!");
            console.log("Implementation:", address(uint160(uint256(impl))));
        } else {
            console.log("Contract is not EIP-1967 proxy");
        }

        // Check code size
        uint256 codeSize = BAMM_ADDRESS.code.length;
        console.log("Code size:", codeSize);
    }

    function testFindActualBAMM() public view {
        console.log("====================================================");
        console.log("FINDING THE ACTUAL BAMM CONTRACT");
        console.log("====================================================");

        // The contract at 0x097f... might be a PCV controller, not BAMM
        // Let's find contracts that:
        // 1. Hold THUSD
        // 2. Have the BAMM functions

        uint256 thusdAtAddress = IERC20(THUSD).balanceOf(BAMM_ADDRESS);
        console.log("THUSD at 0x097f:", thusdAtAddress / 1e18);

        // This contract has 50M THUSD. Let's check what functions it has.
        // From the ABI we saw BAMMDeposit, BAMMWithdraw events
        // This suggests it's a PCV Controller that USES a BAMM, not the BAMM itself

        // Try to find BAMM address stored in this contract
        (bool success, bytes memory data) = BAMM_ADDRESS.staticcall(
            abi.encodeWithSignature("bamm()")
        );

        if (success && data.length >= 32) {
            address bamm = abi.decode(data, (address));
            console.log("Found BAMM address:", bamm);

            // Check this BAMM
            uint256 bammThusd = IERC20(THUSD).balanceOf(bamm);
            console.log("THUSD in actual BAMM:", bammThusd / 1e18);
        } else {
            console.log("bamm() call failed, trying other methods...");

            // Try reading storage slot 0
            bytes32 slot0 = vm.load(BAMM_ADDRESS, bytes32(uint256(0)));
            console.log("Storage slot 0:", uint256(slot0));
        }
    }

    function testCheckAllTHUSDHolders() public view {
        console.log("====================================================");
        console.log("CHECKING ALL MAJOR THUSD HOLDERS");
        console.log("====================================================");

        // Known addresses from protocol
        address[] memory addresses = new address[](5);
        addresses[0] = 0x097f1ee62E63aCFC3Bf64c1a61d96B3771dd06cB; // Current target
        addresses[1] = THUSD; // Token contract itself
        addresses[2] = 0xCFC5bD99915aAa815401C5a41A927aB7a38d29cf; // Same as THUSD
        addresses[3] = address(0); // Check if any at 0x0
        addresses[4] = 0x0000000000000000000000000000000000000001; // Burn address

        for (uint i = 0; i < addresses.length; i++) {
            if (addresses[i] != address(0)) {
                uint256 bal = IERC20(THUSD).balanceOf(addresses[i]);
                if (bal > 0) {
                    console.log("Address:", addresses[i]);
                    console.log("Balance:", bal / 1e18);
                }
            }
        }
    }

    function testExploitIfPossible() public {
        console.log("====================================================");
        console.log("ATTEMPTING EXPLOIT ON CURRENT STATE");
        console.log("====================================================");

        // First, check if we can find a getSwapCollateralAmount function
        (bool success, bytes memory data) = BAMM_ADDRESS.staticcall(
            abi.encodeWithSignature("getSwapCollateralAmount(uint256)", 1e18)
        );

        if (success && data.length >= 64) {
            (uint256 collateralAmount, uint256 feeAmount) = abi.decode(data, (uint256, uint256));
            console.log("getSwapCollateralAmount(1 THUSD):");
            console.log("- Collateral:", collateralAmount);
            console.log("- Fee:", feeAmount);

            // If collateralAmount > 1e18 in USD terms, we have profit!
        } else {
            console.log("getSwapCollateralAmount failed");
            console.log("This contract doesn't have BAMM swap function");

            // Try depositToBAMM which exists according to ABI
            _tryCall(BAMM_ADDRESS, "depositToBAMM(uint256)");
            _tryCall(BAMM_ADDRESS, "withdrawFromBAMM(uint256)");
        }
    }

    function testFindBAMMThroughEvents() public view {
        console.log("====================================================");
        console.log("ANALYZING CONTRACT THROUGH BYTECODE");
        console.log("====================================================");

        // Read first 20 storage slots to find addresses
        console.log("First 20 storage slots:");
        for (uint256 i = 0; i < 20; i++) {
            bytes32 slot = vm.load(BAMM_ADDRESS, bytes32(i));
            uint256 value = uint256(slot);

            // Check if it could be an address (has non-zero bytes in address range)
            if (value > 0 && value < type(uint160).max) {
                address potential = address(uint160(value));
                if (potential.code.length > 0) {
                    console.log("Slot", i, "- Address with code:", potential);
                }
            }
        }
    }
}
