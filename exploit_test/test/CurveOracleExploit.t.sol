// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title CurvestETHsdVaultV2 Oracle Analysis
 * @notice Analyzing the price oracle for potential manipulation vectors
 */

interface IChainlinkOracle {
    function latestAnswer() external view returns (int256);
    function decimals() external view returns (uint8);
}

interface ICurvePool {
    function get_virtual_price() external view returns (uint256);
    function balances(uint256) external view returns (uint256);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract CurveOracleExploit is Test {
    // Curve stETH pool
    address constant CURVE_STETH_POOL = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;

    // Oracles
    address constant ETH_USD_ORACLE = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;
    address constant STETH_ETH_ORACLE = 0x86392dC19c0b719886221c78AB11eb8Cf5c52812;

    // Tokens
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address steth;

    string constant RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        // Using bytes conversion to avoid checksum issues
        steth = address(bytes20(hex"ae7ab96520DE3A18E5e111B5EaAB4Ae14e47C0D4"));
    }

    function test_AnalyzeCurveVirtualPrice() public view {
        console.log("=== Curve stETH Pool Virtual Price Analysis ===\n");

        ICurvePool pool = ICurvePool(CURVE_STETH_POOL);

        uint256 virtualPrice = pool.get_virtual_price();
        console.log("Current virtual_price:", virtualPrice);
        console.log("Virtual price (ETH terms):", virtualPrice / 1e18);

        // Check pool balances
        uint256 ethBalance = pool.balances(0);
        uint256 stethBalance = pool.balances(1);
        console.log("\nPool balances:");
        console.log("  ETH:", ethBalance / 1e18);
        console.log("  stETH:", stethBalance / 1e18);
        if (ethBalance > 0) {
            console.log("  Ratio (stETH/ETH):", stethBalance * 100 / ethBalance);
        }
    }

    function test_VirtualPriceManipulation() public {
        console.log("=== Virtual Price Manipulation Test ===\n");

        ICurvePool pool = ICurvePool(CURVE_STETH_POOL);

        uint256 vpBefore = pool.get_virtual_price();
        console.log("Virtual price before:", vpBefore);

        // Try to manipulate via large swap
        address attacker = makeAddr("attacker");
        vm.deal(attacker, 10000 ether);

        vm.startPrank(attacker);

        // Call exchange with ETH
        (bool success,) = CURVE_STETH_POOL.call{value: 10000 ether}(
            abi.encodeWithSignature("exchange(int128,int128,uint256,uint256)", 0, 1, 10000 ether, 0)
        );

        if (success) {
            uint256 vpAfter = pool.get_virtual_price();
            console.log("Virtual price after 10k ETH swap:", vpAfter);

            int256 delta = int256(vpAfter) - int256(vpBefore);
            console.log("Delta:", delta > 0 ? uint256(delta) : uint256(-delta));
        } else {
            console.log("Swap failed");
        }

        vm.stopPrank();
    }

    function test_OracleZeroVirtualPrice() public pure {
        console.log("=== Zero Virtual Price Vulnerability ===\n");

        console.log("CurvestETHsdVaultV2 vulnerability:");
        console.log("1. virtualprice starts at 0 (not initialized in constructor)");
        console.log("2. updateVirtualPrice() has NO access control");
        console.log("3. latestAnswer() = (pricePerShare * minPrice * virtualprice) / 1e36");
        console.log("4. IF virtualprice = 0, oracle returns 0!");
        console.log("");
        console.log("Impact if lending protocol uses this oracle:");
        console.log("  - All collateral valued at $0");
        console.log("  - All positions instantly liquidatable");
        console.log("  - Attacker can liquidate at 0 cost");
    }

    function test_SearchForDependentProtocols() public view {
        console.log("=== Searching for protocols using CurvestETHsdVaultV2 ===\n");

        // Check known StakeDAO and Curve-related addresses
        address[5] memory addrs = [
            0x73968b9a57c6E53d41345FD57a6E6ae27d6CDB2F, // sd-steCRV gauge
            0xF403C135812408BFbE8713b5A23a04b3D48AAE31, // Convex Booster
            CURVE_STETH_POOL,
            0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0, // wstETH
            0xC13e21B648A5Ee794902342038FF3aDAB66BE987  // DolaFraxBP gauge
        ];

        for (uint i = 0; i < addrs.length; i++) {
            address addr = addrs[i];
            if (addr.code.length == 0) continue;

            // Try getPricePerFullShare
            (bool success, bytes memory data) = addr.staticcall(
                abi.encodeWithSignature("getPricePerFullShare()")
            );
            if (success && data.length >= 32) {
                console.log("Address", i, "has getPricePerFullShare");
            }

            // Try get_virtual_price
            (success, data) = addr.staticcall(
                abi.encodeWithSignature("get_virtual_price()")
            );
            if (success && data.length >= 32) {
                uint256 vp = abi.decode(data, (uint256));
                console.log("Address", i, "virtual_price:", vp);
            }
        }
    }

    receive() external payable {}
}
