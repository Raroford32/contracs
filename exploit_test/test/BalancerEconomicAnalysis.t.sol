// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// ============================================================================
// Economic Analysis: Is the rounding exploit profitable?
// ============================================================================

interface IAsset {}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint256) external;
}

interface IVault {
    enum SwapKind { GIVEN_IN, GIVEN_OUT }

    struct BatchSwapStep {
        bytes32 poolId;
        uint256 assetInIndex;
        uint256 assetOutIndex;
        uint256 amount;
        bytes userData;
    }

    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address payable recipient;
        bool toInternalBalance;
    }

    function batchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds, int256[] memory limits, uint256 deadline) external payable returns (int256[] memory);
    function queryBatchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds) external returns (int256[] memory);
}

contract BalancerEconomicAnalysis is Test {
    IVault constant VAULT = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    IWETH constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20 constant BAL = IERC20(0xba100000625a3754423978a60c9317c58a424e3D);

    bytes32 constant BAL_WETH_POOL = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014;

    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        attacker = address(this);
        vm.deal(attacker, 1000 ether);
        WETH.deposit{value: 500 ether}();
        WETH.approve(address(VAULT), type(uint256).max);
        BAL.approve(address(VAULT), type(uint256).max);
    }

    // ========================================================================
    // ECONOMIC ANALYSIS: Calculate profit vs gas cost
    // ========================================================================
    function test_EconomicAnalysis() public {
        console.log("=== ECONOMIC ANALYSIS OF ROUNDING EXPLOIT ===");
        console.log("");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Measure actual gas cost for the exploit sequence
        uint256 gasStart = gasleft();

        // Step 1: GIVEN_IN WETH -> BAL
        IVault.BatchSwapStep[] memory swap1 = new IVault.BatchSwapStep[](1);
        swap1[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: 1 ether,
            userData: ""
        });

        int256[] memory limits1 = new int256[](2);
        limits1[0] = 0;
        limits1[1] = int256(1 ether);

        int256[] memory deltas1 = VAULT.batchSwap(IVault.SwapKind.GIVEN_IN, swap1, assets, funds, limits1, block.timestamp + 1000);
        uint256 balReceived = uint256(-deltas1[0]);

        uint256 gasAfterSwap1 = gasleft();
        uint256 gasSwap1 = gasStart - gasAfterSwap1;

        // Step 2: GIVEN_OUT to get back 1 WETH
        IVault.BatchSwapStep[] memory swap2 = new IVault.BatchSwapStep[](1);
        swap2[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 0,
            assetOutIndex: 1,
            amount: 1 ether, // Want exactly 1 WETH back
            userData: ""
        });

        int256[] memory limits2 = new int256[](2);
        limits2[0] = int256(balReceived);
        limits2[1] = 0;

        int256[] memory deltas2 = VAULT.batchSwap(IVault.SwapKind.GIVEN_OUT, swap2, assets, funds, limits2, block.timestamp + 1000);
        uint256 balSpent = uint256(deltas2[0]);

        uint256 gasAfterSwap2 = gasleft();
        uint256 gasSwap2 = gasAfterSwap1 - gasAfterSwap2;
        uint256 totalGas = gasSwap1 + gasSwap2;

        // Calculate profit
        uint256 balProfit = balReceived > balSpent ? balReceived - balSpent : 0;

        console.log("=== GAS COSTS ===");
        console.log("Swap 1 gas (WETH->BAL):", gasSwap1);
        console.log("Swap 2 gas (BAL->WETH):", gasSwap2);
        console.log("Total gas:", totalGas);

        console.log("\n=== TOKEN FLOW ===");
        console.log("BAL received from GIVEN_IN:", balReceived);
        console.log("BAL spent in GIVEN_OUT:", balSpent);
        console.log("BAL profit:", balProfit);

        // Calculate at different gas prices
        console.log("\n=== PROFITABILITY ANALYSIS ===");
        console.log("(Assuming BAL/ETH price from pool ratio)");

        // Get current BAL/WETH price estimate
        uint256 balPriceInWei = 1 ether / (balReceived / 1e18); // Rough estimate

        uint256[] memory gasPrices = new uint256[](5);
        gasPrices[0] = 5 gwei;   // Low
        gasPrices[1] = 10 gwei;  // Normal
        gasPrices[2] = 20 gwei;  // Medium
        gasPrices[3] = 50 gwei;  // High
        gasPrices[4] = 100 gwei; // Very high

        for (uint i = 0; i < gasPrices.length; i++) {
            uint256 gasPrice = gasPrices[i];
            uint256 gasCostWei = totalGas * gasPrice;

            // Convert BAL profit to ETH equivalent
            uint256 profitInWei = (balProfit * balPriceInWei) / 1e18;

            console.log("\nAt", gasPrice / 1e9, "gwei gas price:");
            console.log("  Gas cost (wei):", gasCostWei);
            console.log("  BAL profit value (wei):", profitInWei);

            if (profitInWei > gasCostWei) {
                console.log("  NET PROFIT (wei):", profitInWei - gasCostWei);
                console.log("  ==> PROFITABLE!");
            } else {
                console.log("  NET LOSS (wei):", gasCostWei - profitInWei);
                console.log("  ==> NOT PROFITABLE");
            }
        }
    }

    // ========================================================================
    // SCALE ANALYSIS: What scale would be needed for profitability?
    // ========================================================================
    function test_ScaleAnalysis() public {
        console.log("=== SCALE ANALYSIS ===");
        console.log("");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // The key insight: rounding profit is ~20k wei per swap
        // But can we batch many swaps to amortize gas?

        uint256[] memory batchSizes = new uint256[](6);
        batchSizes[0] = 1;
        batchSizes[1] = 10;
        batchSizes[2] = 50;
        batchSizes[3] = 100;
        batchSizes[4] = 200;
        batchSizes[5] = 500;

        uint256 amtPerSwap = 0.1 ether;

        for (uint i = 0; i < batchSizes.length; i++) {
            uint256 batchSize = batchSizes[i];

            // Measure gas for this batch size
            uint256 gasStart = gasleft();

            // Create batch of GIVEN_IN swaps
            IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](batchSize);
            for (uint j = 0; j < batchSize; j++) {
                swaps[j] = IVault.BatchSwapStep({
                    poolId: BAL_WETH_POOL,
                    assetInIndex: 1,
                    assetOutIndex: 0,
                    amount: amtPerSwap,
                    userData: ""
                });
            }

            try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds) returns (int256[] memory deltas) {
                uint256 gasUsed = gasStart - gasleft();
                uint256 balOut = uint256(-deltas[0]);

                // Calculate rounding profit potential (~ batchSize * 20k wei)
                uint256 estimatedProfit = batchSize * 20000; // ~20k wei per swap

                // At 10 gwei gas price
                uint256 gasCost10Gwei = gasUsed * 10 gwei;

                console.log("\nBatch size:", batchSize);
                console.log("  Gas used:", gasUsed);
                console.log("  BAL out:", balOut);
                console.log("  Est. rounding profit (wei):", estimatedProfit);
                console.log("  Gas cost @10gwei (wei):", gasCost10Gwei);

                if (estimatedProfit > gasCost10Gwei) {
                    console.log("  ==> PROFITABLE @ 10 gwei!");
                }
            } catch {
                console.log("\nBatch size:", batchSize, "-> FAILED (too large?)");
            }

            // Reset gas for next iteration
            vm.resetGasMetering();
        }
    }

    // ========================================================================
    // INTERNAL BALANCE EXPLOIT: Use internal balance to reduce gas
    // ========================================================================
    function test_InternalBalanceExploit() public {
        console.log("=== INTERNAL BALANCE GAS OPTIMIZATION ===");
        console.log("");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        // Test 1: Normal swap (external balance)
        IVault.FundManagement memory fundsExternal = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        IVault.BatchSwapStep[] memory swap1 = new IVault.BatchSwapStep[](1);
        swap1[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: 1 ether,
            userData: ""
        });

        int256[] memory limits = new int256[](2);
        limits[0] = 0;
        limits[1] = int256(1 ether);

        uint256 gasStart1 = gasleft();
        VAULT.batchSwap(IVault.SwapKind.GIVEN_IN, swap1, assets, fundsExternal, limits, block.timestamp + 1000);
        uint256 gasExternal = gasStart1 - gasleft();

        console.log("External balance swap gas:", gasExternal);

        // Test 2: Internal balance swap (should be cheaper)
        // First, deposit to internal balance
        IVault.FundManagement memory fundsToInternal = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: true
        });

        VAULT.batchSwap(IVault.SwapKind.GIVEN_IN, swap1, assets, fundsToInternal, limits, block.timestamp + 1000);

        // Now swap using internal balance
        IVault.FundManagement memory fundsInternal = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: true,
            recipient: payable(attacker),
            toInternalBalance: true
        });

        // Swap BAL back to WETH (from internal balance)
        IVault.BatchSwapStep[] memory swap2 = new IVault.BatchSwapStep[](1);
        swap2[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 0,
            assetOutIndex: 1,
            amount: 1 ether,
            userData: ""
        });

        limits[0] = type(int256).max;
        limits[1] = 0;

        uint256 gasStart2 = gasleft();
        try VAULT.batchSwap(IVault.SwapKind.GIVEN_OUT, swap2, assets, fundsInternal, limits, block.timestamp + 1000) {
            uint256 gasInternal = gasStart2 - gasleft();
            console.log("Internal balance swap gas:", gasInternal);
            console.log("Gas saved:", gasExternal - gasInternal);
        } catch {
            console.log("Internal balance swap failed");
        }
    }

    // ========================================================================
    // FLASH LOAN BASED EXPLOIT: No capital required
    // ========================================================================
    function test_FlashLoanEconomics() public {
        console.log("=== FLASH LOAN EXPLOIT ECONOMICS ===");
        console.log("");

        // Key question: With 0% flash loan fee from Balancer,
        // can we exploit the rounding with borrowed capital?

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Simulate a flash loan of 1000 ETH
        uint256 flashAmount = 1000 ether;

        console.log("Flash loan amount:", flashAmount / 1e18, "ETH");
        console.log("Flash loan fee: 0 (Balancer has no flash loan fee)");

        // Calculate: If we do 1000 swaps of 1 ETH each
        // Each swap has ~20k wei rounding profit
        // Total profit: 1000 * 20000 = 20,000,000 wei = 0.00002 ETH

        uint256 numSwaps = 1000;
        uint256 profitPerSwap = 20000; // wei
        uint256 totalProfit = numSwaps * profitPerSwap;

        console.log("\nWith 1000 swaps:");
        console.log("  Profit per swap (wei):", profitPerSwap);
        console.log("  Total profit (wei):", totalProfit);
        console.log("  Total profit (ETH):", totalProfit * 1e18 / 1e18 / 1e18);

        // Estimate gas for 1000 operations
        // Each batchSwap call ~150k gas, query ~50k gas
        uint256 gasPerOp = 200000;
        uint256 totalGas = numSwaps * gasPerOp * 2; // Two swaps per round trip

        console.log("\nGas estimate:");
        console.log("  Gas per operation:", gasPerOp);
        console.log("  Total gas:", totalGas);

        // At different gas prices
        uint256[] memory gasPrices = new uint256[](3);
        gasPrices[0] = 5 gwei;
        gasPrices[1] = 10 gwei;
        gasPrices[2] = 20 gwei;

        for (uint i = 0; i < gasPrices.length; i++) {
            uint256 gasPrice = gasPrices[i];
            uint256 gasCost = totalGas * gasPrice;

            console.log("\nAt", gasPrice / 1e9, "gwei:");
            console.log("  Gas cost (wei):", gasCost);
            console.log("  Profit (wei):", totalProfit);

            if (totalProfit > gasCost) {
                console.log("  NET PROFIT (wei):", totalProfit - gasCost);
            } else {
                console.log("  NET LOSS (wei):", gasCost - totalProfit);
            }
        }

        // What gas price would be break-even?
        uint256 breakEvenGasPrice = totalProfit / totalGas;
        console.log("\nBreak-even gas price:", breakEvenGasPrice, "wei");
        console.log("Break-even gas price:", breakEvenGasPrice / 1e9, "gwei");

        // Conclusion
        console.log("\n=== CONCLUSION ===");
        console.log("The rounding exploit exists but is NOT economically viable");
        console.log("because gas costs exceed the rounding profit by orders of magnitude.");
    }

    // ========================================================================
    // MEV BUNDLE ANALYSIS: Could this work in an MEV bundle?
    // ========================================================================
    function test_MEVBundleAnalysis() public {
        console.log("=== MEV BUNDLE ANALYSIS ===");
        console.log("");

        // In an MEV bundle, we might be able to:
        // 1. Reduce gas costs through batching
        // 2. Extract value through sandwich attacks

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Test: Maximum batch size for a single transaction
        // Balancer supports up to ~100 swaps in a batch

        uint256 maxBatchSize = 100;
        uint256 amtPerSwap = 1 ether;

        IVault.BatchSwapStep[] memory largeSwaps = new IVault.BatchSwapStep[](maxBatchSize);
        for (uint i = 0; i < maxBatchSize; i++) {
            largeSwaps[i] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: amtPerSwap,
                userData: ""
            });
        }

        uint256 gasStart = gasleft();
        int256[] memory deltas = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, largeSwaps, assets, funds);
        uint256 queryGas = gasStart - gasleft();

        console.log("Batch of 100 swaps:");
        console.log("  Query gas:", queryGas);
        console.log("  Estimated execution gas:", queryGas * 3);

        uint256 totalRoundingProfit = maxBatchSize * 20000; // ~20k wei per swap
        console.log("  Total rounding profit (wei):", totalRoundingProfit);

        uint256 execGas = queryGas * 3;
        uint256 breakEven = totalRoundingProfit / execGas;
        console.log("  Break-even gas price (wei):", breakEven);

        console.log("\n=== FINAL VERDICT ===");
        console.log("Rounding profit: ~20,000 wei per swap");
        console.log("This is approximately 0.00002 gwei");
        console.log("Gas prices are typically 5-50 gwei");
        console.log("Therefore: EXPLOIT NOT PROFITABLE");
        console.log("");
        console.log("The rounding difference is REAL but economically insignificant.");
        console.log("Would need gas prices below 0.00002 gwei to be profitable.");
    }

    receive() external payable {}
}
