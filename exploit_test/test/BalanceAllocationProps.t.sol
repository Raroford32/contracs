// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// ============================================================================
// BALANCE ALLOCATION PROPERTY TESTS
//
// Pure mathematical identities that MUST hold for all valid inputs.
// If any fail: you have a bug. Period.
//
// These test the core bit-packing logic that underlies ALL Vault accounting.
// ============================================================================

/// @notice Recreated BalanceAllocation library matching Balancer V2's implementation
/// @dev Original: https://github.com/balancer/balancer-v2-monorepo/blob/master/pkg/vault/contracts/BalanceAllocation.sol
library BalanceAllocation {
    // Balancer uses bytes32 to pack:
    // - For General/MinimalSwapInfo pools: [cash (112 bits)][managed (112 bits)][lastChangeBlock (32 bits)]
    // - For TwoToken pools (shared): packs both balances A and B together

    // Bit positions
    uint256 private constant _BALANCE_OFFSET = 0;
    uint256 private constant _MANAGED_OFFSET = 112;
    uint256 private constant _LAST_CHANGE_BLOCK_OFFSET = 224;

    // Masks
    uint256 private constant _MAX_BALANCE = 2**(112) - 1;  // ~5.2e33, way more than any token supply

    // ========================================================================
    // STANDARD BALANCE (General/MinimalSwapInfo pools)
    // ========================================================================

    function toBalance(
        uint256 cash,
        uint256 managed,
        uint256 lastChangeBlock
    ) internal pure returns (bytes32) {
        // Validate inputs fit in their bit ranges
        require(cash <= _MAX_BALANCE, "BALANCE_OVERFLOW");
        require(managed <= _MAX_BALANCE, "BALANCE_OVERFLOW");
        require(lastChangeBlock <= type(uint32).max, "BLOCK_OVERFLOW");

        return bytes32(
            cash |
            (managed << _MANAGED_OFFSET) |
            (lastChangeBlock << _LAST_CHANGE_BLOCK_OFFSET)
        );
    }

    function cash(bytes32 balance) internal pure returns (uint256) {
        return uint256(balance) & _MAX_BALANCE;
    }

    function managed(bytes32 balance) internal pure returns (uint256) {
        return (uint256(balance) >> _MANAGED_OFFSET) & _MAX_BALANCE;
    }

    function lastChangeBlock(bytes32 balance) internal pure returns (uint256) {
        return uint256(balance) >> _LAST_CHANGE_BLOCK_OFFSET;
    }

    function total(bytes32 balance) internal pure returns (uint256) {
        return cash(balance) + managed(balance);
    }

    function isZero(bytes32 balance) internal pure returns (bool) {
        // Only the first 224 bits (cash + managed) need to be zero
        return uint256(balance) & (2**224 - 1) == 0;
    }

    // ========================================================================
    // BALANCE MODIFICATIONS
    // ========================================================================

    function increaseCash(bytes32 balance, uint256 amount) internal pure returns (bytes32) {
        uint256 newCash = cash(balance) + amount;
        require(newCash <= _MAX_BALANCE, "BALANCE_OVERFLOW");
        return toBalance(newCash, managed(balance), lastChangeBlock(balance));
    }

    function decreaseCash(bytes32 balance, uint256 amount) internal pure returns (bytes32) {
        uint256 currentCash = cash(balance);
        require(currentCash >= amount, "INSUFFICIENT_CASH");
        return toBalance(currentCash - amount, managed(balance), lastChangeBlock(balance));
    }

    function cashToManaged(bytes32 balance, uint256 amount) internal pure returns (bytes32) {
        uint256 currentCash = cash(balance);
        require(currentCash >= amount, "INSUFFICIENT_CASH");

        uint256 newManaged = managed(balance) + amount;
        require(newManaged <= _MAX_BALANCE, "BALANCE_OVERFLOW");

        return toBalance(currentCash - amount, newManaged, lastChangeBlock(balance));
    }

    function managedToCash(bytes32 balance, uint256 amount) internal pure returns (bytes32) {
        uint256 currentManaged = managed(balance);
        require(currentManaged >= amount, "INSUFFICIENT_MANAGED");

        uint256 newCash = cash(balance) + amount;
        require(newCash <= _MAX_BALANCE, "BALANCE_OVERFLOW");

        return toBalance(newCash, currentManaged - amount, lastChangeBlock(balance));
    }

    function setManaged(bytes32 balance, uint256 newManaged) internal pure returns (bytes32) {
        require(newManaged <= _MAX_BALANCE, "BALANCE_OVERFLOW");
        return toBalance(cash(balance), newManaged, lastChangeBlock(balance));
    }

    function setLastChangeBlock(bytes32 balance, uint256 newBlock) internal pure returns (bytes32) {
        require(newBlock <= type(uint32).max, "BLOCK_OVERFLOW");
        return toBalance(cash(balance), managed(balance), newBlock);
    }

    // ========================================================================
    // SHARED BALANCE (TwoToken pools)
    // Packs TWO balances into TWO bytes32 slots
    // ========================================================================

    // For TwoToken pools, we need to pack balanceA and balanceB together
    // This uses a different scheme:
    // sharedCash:    [cashA (112 bits)][cashB (112 bits)][lastChangeBlock (32 bits)]
    // sharedManaged: [managedA (112 bits)][managedB (112 bits)][unused (32 bits)]

    function toSharedCash(
        bytes32 balanceA,
        bytes32 balanceB
    ) internal pure returns (bytes32) {
        uint256 cashA = cash(balanceA);
        uint256 cashB = cash(balanceB);
        uint256 lastBlock = lastChangeBlock(balanceA); // Use A's block

        return bytes32(
            cashA |
            (cashB << _MANAGED_OFFSET) |
            (lastBlock << _LAST_CHANGE_BLOCK_OFFSET)
        );
    }

    function toSharedManaged(
        bytes32 balanceA,
        bytes32 balanceB
    ) internal pure returns (bytes32) {
        uint256 managedA = managed(balanceA);
        uint256 managedB = managed(balanceB);

        return bytes32(
            managedA |
            (managedB << _MANAGED_OFFSET)
        );
    }

    function fromSharedToBalanceA(
        bytes32 sharedCash,
        bytes32 sharedManaged
    ) internal pure returns (bytes32) {
        uint256 cashA = uint256(sharedCash) & _MAX_BALANCE;
        uint256 managedA = uint256(sharedManaged) & _MAX_BALANCE;
        uint256 lastBlock = uint256(sharedCash) >> _LAST_CHANGE_BLOCK_OFFSET;

        return toBalance(cashA, managedA, lastBlock);
    }

    function fromSharedToBalanceB(
        bytes32 sharedCash,
        bytes32 sharedManaged
    ) internal pure returns (bytes32) {
        uint256 cashB = (uint256(sharedCash) >> _MANAGED_OFFSET) & _MAX_BALANCE;
        uint256 managedB = (uint256(sharedManaged) >> _MANAGED_OFFSET) & _MAX_BALANCE;
        uint256 lastBlock = uint256(sharedCash) >> _LAST_CHANGE_BLOCK_OFFSET;

        return toBalance(cashB, managedB, lastBlock);
    }
}

// ============================================================================
// PROPERTY TEST CONTRACT
// ============================================================================

contract BalanceAllocationProps is Test {
    using BalanceAllocation for bytes32;

    uint256 constant MAX_BALANCE = 2**112 - 1;

    // ========================================================================
    // IDENTITY 1: Shared packing must round-trip exactly
    // ========================================================================

    function test_shared_roundtrip_fuzz(
        uint256 cashA,
        uint256 managedA,
        uint256 cashB,
        uint256 managedB,
        uint32 blockNo
    ) public pure {
        // Bound to valid ranges
        cashA    = bound(cashA,    0, MAX_BALANCE);
        managedA = bound(managedA, 0, MAX_BALANCE);
        cashB    = bound(cashB,    0, MAX_BALANCE);
        managedB = bound(managedB, 0, MAX_BALANCE);

        // Create original balances
        bytes32 bA = BalanceAllocation.toBalance(cashA, managedA, blockNo);
        bytes32 bB = BalanceAllocation.toBalance(cashB, managedB, blockNo);

        // Pack to shared format
        bytes32 sc = BalanceAllocation.toSharedCash(bA, bB);
        bytes32 sm = BalanceAllocation.toSharedManaged(bA, bB);

        // Unpack back
        bytes32 recoveredA = BalanceAllocation.fromSharedToBalanceA(sc, sm);
        bytes32 recoveredB = BalanceAllocation.fromSharedToBalanceB(sc, sm);

        // Must be identical
        assertEq(recoveredA, bA, "Balance A corrupted in shared round-trip");
        assertEq(recoveredB, bB, "Balance B corrupted in shared round-trip");
    }

    // ========================================================================
    // IDENTITY 2: Total must be conserved under internal transforms
    // ========================================================================

    function test_total_conservation_cashToManaged_fuzz(
        uint256 cashVal,
        uint256 managedVal,
        uint32 blockNo,
        uint256 amt
    ) public pure {
        cashVal    = bound(cashVal,    0, MAX_BALANCE);
        managedVal = bound(managedVal, 0, MAX_BALANCE);

        // Ensure cash + managed doesn't overflow
        if (cashVal > MAX_BALANCE - managedVal) {
            managedVal = MAX_BALANCE - cashVal;
        }

        bytes32 b = BalanceAllocation.toBalance(cashVal, managedVal, blockNo);
        uint256 total0 = b.total();

        // cashToManaged: only valid up to cash
        amt = bound(amt, 0, cashVal);

        // Also ensure new managed doesn't overflow
        if (amt > MAX_BALANCE - managedVal) {
            amt = MAX_BALANCE - managedVal;
        }

        bytes32 b2 = b.cashToManaged(amt);

        // Total must be preserved
        assertEq(b2.total(), total0, "Total changed after cashToManaged");
    }

    function test_total_conservation_managedToCash_fuzz(
        uint256 cashVal,
        uint256 managedVal,
        uint32 blockNo,
        uint256 amt
    ) public pure {
        cashVal    = bound(cashVal,    0, MAX_BALANCE);
        managedVal = bound(managedVal, 0, MAX_BALANCE);

        // Ensure cash + managed doesn't overflow
        if (cashVal > MAX_BALANCE - managedVal) {
            managedVal = MAX_BALANCE - cashVal;
        }

        bytes32 b = BalanceAllocation.toBalance(cashVal, managedVal, blockNo);
        uint256 total0 = b.total();

        // managedToCash: only valid up to managed
        amt = bound(amt, 0, managedVal);

        // Also ensure new cash doesn't overflow
        if (amt > MAX_BALANCE - cashVal) {
            amt = MAX_BALANCE - cashVal;
        }

        bytes32 b2 = b.managedToCash(amt);

        // Total must be preserved
        assertEq(b2.total(), total0, "Total changed after managedToCash");
    }

    function test_total_increase_cash_fuzz(
        uint256 cashVal,
        uint256 managedVal,
        uint32 blockNo,
        uint256 amt
    ) public pure {
        cashVal    = bound(cashVal,    0, MAX_BALANCE / 2);
        managedVal = bound(managedVal, 0, MAX_BALANCE / 2);
        amt        = bound(amt, 0, MAX_BALANCE / 2);

        bytes32 b = BalanceAllocation.toBalance(cashVal, managedVal, blockNo);
        uint256 total0 = b.total();

        bytes32 b2 = b.increaseCash(amt);

        // Total must increase by exactly amt
        assertEq(b2.total(), total0 + amt, "Total didn't increase correctly");
    }

    function test_total_decrease_cash_fuzz(
        uint256 cashVal,
        uint256 managedVal,
        uint32 blockNo,
        uint256 amt
    ) public pure {
        cashVal    = bound(cashVal,    0, MAX_BALANCE);
        managedVal = bound(managedVal, 0, MAX_BALANCE);

        bytes32 b = BalanceAllocation.toBalance(cashVal, managedVal, blockNo);
        uint256 total0 = b.total();

        // Only decrease up to available cash
        amt = bound(amt, 0, cashVal);

        bytes32 b2 = b.decreaseCash(amt);

        // Total must decrease by exactly amt
        assertEq(b2.total(), total0 - amt, "Total didn't decrease correctly");
    }

    // ========================================================================
    // IDENTITY 3: Selectors must be consistent
    // ========================================================================

    function test_selector_consistency_fuzz(
        uint256 cashVal,
        uint256 managedVal,
        uint32 blockNo
    ) public pure {
        cashVal    = bound(cashVal,    0, MAX_BALANCE);
        managedVal = bound(managedVal, 0, MAX_BALANCE);

        bytes32 b = BalanceAllocation.toBalance(cashVal, managedVal, blockNo);

        // Selectors must return original values
        assertEq(b.cash(), cashVal, "cash() doesn't match input");
        assertEq(b.managed(), managedVal, "managed() doesn't match input");
        assertEq(b.lastChangeBlock(), blockNo, "lastChangeBlock() doesn't match input");
        assertEq(b.total(), cashVal + managedVal, "total() doesn't equal cash + managed");
    }

    // ========================================================================
    // IDENTITY 4: isZero must be correct
    // ========================================================================

    function test_isZero_fuzz(
        uint256 cashVal,
        uint256 managedVal,
        uint32 blockNo
    ) public pure {
        cashVal    = bound(cashVal,    0, MAX_BALANCE);
        managedVal = bound(managedVal, 0, MAX_BALANCE);

        bytes32 b = BalanceAllocation.toBalance(cashVal, managedVal, blockNo);

        bool expectedZero = (cashVal == 0 && managedVal == 0);
        assertEq(b.isZero(), expectedZero, "isZero() incorrect");
    }

    // ========================================================================
    // IDENTITY 5: Bit field isolation (no bleed between fields)
    // ========================================================================

    function test_bit_field_isolation_fuzz(
        uint256 cashVal,
        uint256 managedVal,
        uint32 blockNo
    ) public pure {
        // Use extreme values to test bit boundaries
        cashVal    = bound(cashVal,    0, MAX_BALANCE);
        managedVal = bound(managedVal, 0, MAX_BALANCE);

        bytes32 b = BalanceAllocation.toBalance(cashVal, managedVal, blockNo);

        // Modify one field and verify others unchanged
        bytes32 b2 = BalanceAllocation.setManaged(b, 0);
        assertEq(b2.cash(), cashVal, "cash changed when setting managed");
        assertEq(b2.lastChangeBlock(), blockNo, "block changed when setting managed");

        bytes32 b3 = BalanceAllocation.setLastChangeBlock(b, 0);
        assertEq(b3.cash(), cashVal, "cash changed when setting block");
        assertEq(b3.managed(), managedVal, "managed changed when setting block");
    }

    // ========================================================================
    // IDENTITY 6: Commutativity of operations
    // ========================================================================

    function test_cashToManaged_managedToCash_roundtrip_fuzz(
        uint256 cashVal,
        uint256 managedVal,
        uint32 blockNo,
        uint256 amt
    ) public pure {
        cashVal    = bound(cashVal,    1, MAX_BALANCE / 2);
        managedVal = bound(managedVal, 0, MAX_BALANCE / 2);
        amt        = bound(amt, 0, cashVal);

        // Ensure we have room
        if (amt > MAX_BALANCE - managedVal) {
            amt = MAX_BALANCE - managedVal;
        }

        bytes32 b = BalanceAllocation.toBalance(cashVal, managedVal, blockNo);

        // Move cash to managed, then back
        bytes32 b2 = b.cashToManaged(amt);
        bytes32 b3 = b2.managedToCash(amt);

        // Should return to original state
        assertEq(b3.cash(), b.cash(), "Cash not restored after round-trip");
        assertEq(b3.managed(), b.managed(), "Managed not restored after round-trip");
        assertEq(b3.lastChangeBlock(), b.lastChangeBlock(), "Block changed in round-trip");
    }

    // ========================================================================
    // IDENTITY 7: Shared balance field isolation
    // ========================================================================

    function test_shared_balance_field_isolation_fuzz(
        uint256 cashA,
        uint256 managedA,
        uint256 cashB,
        uint256 managedB,
        uint32 blockNo
    ) public pure {
        // Bound to valid ranges with room for modification
        cashA    = bound(cashA,    0, MAX_BALANCE / 2);
        managedA = bound(managedA, 0, MAX_BALANCE / 2);
        cashB    = bound(cashB,    0, MAX_BALANCE / 2);
        managedB = bound(managedB, 0, MAX_BALANCE / 2);

        bytes32 bA = BalanceAllocation.toBalance(cashA, managedA, blockNo);
        bytes32 bB = BalanceAllocation.toBalance(cashB, managedB, blockNo);

        bytes32 sc = BalanceAllocation.toSharedCash(bA, bB);
        bytes32 sm = BalanceAllocation.toSharedManaged(bA, bB);

        // Recover and verify fields are isolated
        bytes32 recA = BalanceAllocation.fromSharedToBalanceA(sc, sm);
        bytes32 recB = BalanceAllocation.fromSharedToBalanceB(sc, sm);

        // A's fields must not bleed into B's
        assertEq(recA.cash(), cashA, "A's cash corrupted");
        assertEq(recA.managed(), managedA, "A's managed corrupted");
        assertEq(recB.cash(), cashB, "B's cash corrupted");
        assertEq(recB.managed(), managedB, "B's managed corrupted");

        // Modify A's cash (simulated) and verify B unchanged
        bytes32 modA = BalanceAllocation.toBalance(cashA + 1, managedA, blockNo);
        bytes32 sc2 = BalanceAllocation.toSharedCash(modA, bB);
        bytes32 sm2 = BalanceAllocation.toSharedManaged(modA, bB);

        bytes32 recB2 = BalanceAllocation.fromSharedToBalanceB(sc2, sm2);
        assertEq(recB2.cash(), cashB, "B's cash changed when A modified");
        assertEq(recB2.managed(), managedB, "B's managed changed when A modified");
    }

    // ========================================================================
    // EDGE CASE: Maximum values
    // ========================================================================

    function test_max_values() public pure {
        uint256 maxBal = MAX_BALANCE;
        uint32 maxBlock = type(uint32).max;

        bytes32 b = BalanceAllocation.toBalance(maxBal, 0, maxBlock);
        assertEq(b.cash(), maxBal, "Max cash failed");
        assertEq(b.lastChangeBlock(), maxBlock, "Max block failed");

        bytes32 b2 = BalanceAllocation.toBalance(0, maxBal, 0);
        assertEq(b2.managed(), maxBal, "Max managed failed");
    }

    // ========================================================================
    // EDGE CASE: Zero values
    // ========================================================================

    function test_zero_values() public pure {
        bytes32 b = BalanceAllocation.toBalance(0, 0, 0);

        assertEq(b.cash(), 0, "Zero cash failed");
        assertEq(b.managed(), 0, "Zero managed failed");
        assertEq(b.lastChangeBlock(), 0, "Zero block failed");
        assertEq(b.total(), 0, "Zero total failed");
        assertTrue(b.isZero(), "isZero failed for zero balance");
    }

    // ========================================================================
    // EDGE CASE: Boundary values (2^112 - 1, 2^112)
    // ========================================================================

    function test_boundary_overflow() public {
        uint256 maxBal = MAX_BALANCE;

        // This should work
        bytes32 b = BalanceAllocation.toBalance(maxBal, 0, 0);
        assertEq(b.cash(), maxBal);

        // This should revert - test via try/catch since library call
        bool reverted = false;
        try this.helperToBalance(maxBal + 1, 0, 0) {
            // Should not reach here
        } catch {
            reverted = true;
        }
        assertTrue(reverted, "Should have reverted for overflow");
    }

    // Helper for testing reverts on library calls
    function helperToBalance(uint256 c, uint256 m, uint256 blk) external pure returns (bytes32) {
        return BalanceAllocation.toBalance(c, m, blk);
    }

    // ========================================================================
    // HIGH-VOLUME FUZZ: Run many iterations to find edge cases
    // ========================================================================

    function testFuzz_massiveRoundTrip(
        uint256 seed
    ) public pure {
        // Generate multiple test cases from seed
        for (uint i = 0; i < 10; i++) {
            uint256 cashA = uint256(keccak256(abi.encode(seed, i, "cashA"))) % (MAX_BALANCE + 1);
            uint256 managedA = uint256(keccak256(abi.encode(seed, i, "managedA"))) % (MAX_BALANCE + 1);
            uint256 cashB = uint256(keccak256(abi.encode(seed, i, "cashB"))) % (MAX_BALANCE + 1);
            uint256 managedB = uint256(keccak256(abi.encode(seed, i, "managedB"))) % (MAX_BALANCE + 1);
            uint32 blockNo = uint32(uint256(keccak256(abi.encode(seed, i, "block"))));

            bytes32 bA = BalanceAllocation.toBalance(cashA, managedA, blockNo);
            bytes32 bB = BalanceAllocation.toBalance(cashB, managedB, blockNo);

            bytes32 sc = BalanceAllocation.toSharedCash(bA, bB);
            bytes32 sm = BalanceAllocation.toSharedManaged(bA, bB);

            bytes32 recA = BalanceAllocation.fromSharedToBalanceA(sc, sm);
            bytes32 recB = BalanceAllocation.fromSharedToBalanceB(sc, sm);

            require(recA == bA, "Massive roundtrip failed for A");
            require(recB == bB, "Massive roundtrip failed for B");
        }
    }
}

// ============================================================================
// SIGNED/UNSIGNED BOUNDARY TESTS
// ============================================================================

contract SignedBoundaryProps is Test {
    // Test int256 boundary conditions that can cause issues

    function test_int256_boundary_cast_fuzz(uint256 val) public pure {
        // The dangerous boundary is type(int256).max
        // If val > type(int256).max, casting to int256 will produce negative value

        if (val <= uint256(type(int256).max)) {
            int256 signed = int256(val);
            assertGe(signed, 0, "Positive value became negative");
            assertEq(uint256(signed), val, "Cast didn't preserve value");
        }
        // Values > int256.max would revert in safe code
    }

    function test_int256_min_abs_danger() public pure {
        // int256.min is dangerous because abs(int256.min) overflows
        int256 minVal = type(int256).min;

        // This would overflow: -minVal
        // In safe code this should be guarded
        assertEq(minVal, -2**255, "int256.min value check");
    }

    function test_delta_sign_preservation_fuzz(
        uint256 before_bal,
        uint256 after_bal
    ) public pure {
        before_bal = bound(before_bal, 0, uint256(type(int256).max));
        after_bal = bound(after_bal, 0, uint256(type(int256).max));

        // Calculate delta as Balancer does
        int256 delta = int256(after_bal) - int256(before_bal);

        // Verify the delta correctly represents the change
        if (after_bal >= before_bal) {
            assertGe(delta, 0, "Positive change has negative delta");
            assertEq(uint256(delta), after_bal - before_bal, "Delta magnitude wrong");
        } else {
            assertLt(delta, 0, "Negative change has positive delta");
            assertEq(uint256(-delta), before_bal - after_bal, "Delta magnitude wrong");
        }
    }
}
