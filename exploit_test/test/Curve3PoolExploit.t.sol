// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

interface ICurve3Pool {
    function get_virtual_price() external view returns (uint256);
    function balances(uint256 i) external view returns (uint256);
    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);
    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256);
}

contract Curve3PoolExploit is Test {
    address constant CURVE_3POOL = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;
    address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    
    string constant RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    
    function setUp() public {
        vm.createSelectFork(RPC_URL);
    }
    
    function test_3PoolBalances() public view {
        console.log("=== Curve 3Pool Balance Analysis ===\n");
        
        ICurve3Pool pool = ICurve3Pool(CURVE_3POOL);
        
        uint256 b0 = pool.balances(0);
        uint256 b1 = pool.balances(1);
        uint256 b2 = pool.balances(2);
        
        console.log("Pool Balances (raw):");
        console.log("  Index 0 (DAI):", b0);
        console.log("  Index 1 (USDC):", b1);
        console.log("  Index 2 (USDT):", b2);
        
        console.log("\nNormalized:");
        console.log("  DAI:", b0 / 1e18);
        console.log("  USDC:", b1 / 1e6);
        console.log("  USDT:", b2 / 1e6);
        
        // Check actual token balances
        console.log("\nActual Balances:");
        console.log("  DAI:", IERC20(DAI).balanceOf(CURVE_3POOL) / 1e18);
        console.log("  USDC:", IERC20(USDC).balanceOf(CURVE_3POOL) / 1e6);
        console.log("  USDT:", IERC20(USDT).balanceOf(CURVE_3POOL) / 1e6);
        
        console.log("\nVirtual Price:", pool.get_virtual_price());
    }
    
    function test_ExchangeRates() public view {
        console.log("=== Exchange Rates ===\n");
        
        ICurve3Pool pool = ICurve3Pool(CURVE_3POOL);
        
        uint256 daiToUsdc = pool.get_dy(0, 1, 1000e18);
        uint256 usdcToDai = pool.get_dy(1, 0, 1000e6);
        
        console.log("Exchange 1000 tokens:");
        console.log("  1000 DAI -> USDC:", daiToUsdc / 1e6);
        console.log("  1000 USDC -> DAI:", usdcToDai / 1e18);
        
        if (daiToUsdc > 1000e6) {
            console.log("\n  Arbitrage: DAI->USDC profitable!");
        }
        if (usdcToDai > 1000e18) {
            console.log("\n  Arbitrage: USDC->DAI profitable!");
        }
    }
    
    function test_ArbitrageAttempt() public {
        console.log("=== Arbitrage Attempt ===\n");
        
        ICurve3Pool pool = ICurve3Pool(CURVE_3POOL);
        IERC20 usdc = IERC20(USDC);
        IERC20 dai = IERC20(DAI);
        
        address attacker = makeAddr("attacker");
        deal(address(usdc), attacker, 100000e6);
        
        uint256 before = usdc.balanceOf(attacker);
        console.log("Before:", before / 1e6, "USDC");
        
        vm.startPrank(attacker);
        usdc.approve(CURVE_3POOL, type(uint256).max);
        dai.approve(CURVE_3POOL, type(uint256).max);
        
        uint256 daiOut = pool.exchange(1, 0, 100000e6, 0);
        console.log("DAI received:", daiOut / 1e18);
        
        uint256 usdcBack = pool.exchange(0, 1, daiOut, 0);
        console.log("USDC back:", usdcBack / 1e6);
        vm.stopPrank();
        
        if (usdcBack > before) {
            console.log("\nPROFIT:", (usdcBack - before) / 1e6);
        } else {
            console.log("\nLoss:", (before - usdcBack) / 1e6);
        }
    }
}
