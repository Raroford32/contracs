// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IFraxEtherRedemptionQueue {
    struct RedemptionQueueState {
        uint64 nextNftId;
        uint64 queueLengthSecs;
        uint64 redemptionFee;
        uint64 earlyExitFee;
    }
    
    struct RedemptionQueueAccounting {
        uint128 etherLiabilities;
        uint128 unclaimedFees;
    }
    
    struct RedemptionQueueItem {
        bool hasBeenRedeemed;
        uint64 maturity;
        uint120 amount;
        uint64 earlyExitFee;
    }
    
    function redemptionQueueState() external view returns (uint64, uint64, uint64, uint64);
    function redemptionQueueAccounting() external view returns (uint128 etherLiabilities, uint128 unclaimedFees);
    function nftInformation(uint256 nftId) external view returns (bool, uint64, uint120, uint64);
    function timelockAddress() external view returns (address);
    function operatorAddress() external view returns (address);
    function feeRecipient() external view returns (address);
    function ownerOf(uint256 tokenId) external view returns (address);
    
    function enterRedemptionQueue(address _recipient, uint120 _amountToRedeem) external returns (uint256);
    function burnRedemptionTicketNft(uint256 _nftId, address payable _recipient) external;
    function earlyBurnRedemptionTicketNft(address payable _recipient, uint256 _nftId) external returns (uint120);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract FraxQueueExploitTest is Test {
    address constant FRAX_QUEUE = 0x82bA8da44Cd5261762e629dd5c605b17715727bd;
    address constant FRXETH = 0x5E8422345238F34275888049021821E8E08CAa1f;
    address constant SFRXETH = 0xac3E018457B222d93114458476f3E3416Abbe38F;
    
    IFraxEtherRedemptionQueue queue;
    
    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        queue = IFraxEtherRedemptionQueue(FRAX_QUEUE);
    }
    
    function testQueueState() public view {
        console.log("=== FRAX REDEMPTION QUEUE STATE ===");
        
        // Check ETH balance
        uint256 ethBalance = FRAX_QUEUE.balance;
        console.log("ETH Balance:", ethBalance / 1e18, "ETH");
        
        // Check frxETH balance  
        uint256 frxEthBalance = IERC20(FRXETH).balanceOf(FRAX_QUEUE);
        console.log("frxETH Balance:", frxEthBalance / 1e18);
        
        // Get queue state
        (uint64 nextNftId, uint64 queueLengthSecs, uint64 redemptionFee, uint64 earlyExitFee) = queue.redemptionQueueState();
        console.log("\nQueue State:");
        console.log("  Next NFT ID:", nextNftId);
        console.log("  Queue Length (seconds):", queueLengthSecs);
        console.log("  Queue Length (days):", queueLengthSecs / 86400);
        console.log("  Redemption Fee (bps):", redemptionFee * 10000 / 1e6);
        console.log("  Early Exit Fee (bps):", earlyExitFee * 10000 / 1e6);
        
        // Get accounting
        (uint128 etherLiabilities, uint128 unclaimedFees) = queue.redemptionQueueAccounting();
        console.log("\nAccounting:");
        console.log("  Ether Liabilities:", uint256(etherLiabilities) / 1e18, "ETH");
        console.log("  Unclaimed Fees:", uint256(unclaimedFees) / 1e18, "frxETH");
        
        // Check if solvent
        console.log("\n=== SOLVENCY CHECK ===");
        if (ethBalance >= etherLiabilities) {
            console.log("SOLVENT: ETH balance covers liabilities");
            console.log("Surplus:", (ethBalance - etherLiabilities) / 1e18, "ETH");
        } else {
            console.log("!!! INSOLVENT !!!");
            console.log("Shortfall:", (etherLiabilities - ethBalance) / 1e18, "ETH");
        }
        
        // Check addresses
        console.log("\nAddresses:");
        console.log("  Timelock:", queue.timelockAddress());
        console.log("  Operator:", queue.operatorAddress());
        console.log("  Fee Recipient:", queue.feeRecipient());
    }
    
    function testCheckRecentNFTs() public view {
        console.log("\n=== RECENT NFT ANALYSIS ===");
        
        (uint64 nextNftId,,,) = queue.redemptionQueueState();
        
        // Check the last 10 NFTs
        uint256 startId = nextNftId > 10 ? nextNftId - 10 : 0;
        
        for (uint256 i = startId; i < nextNftId; i++) {
            (bool hasBeenRedeemed, uint64 maturity, uint120 amount,) = queue.nftInformation(i);
            
            if (!hasBeenRedeemed && amount > 0) {
                console.log("\nNFT ID:", i);
                console.log("  Amount:", amount / 1e18, "ETH");
                console.log("  Maturity:", maturity);
                console.log("  Current Time:", block.timestamp);
                
                if (block.timestamp >= maturity) {
                    console.log("  Status: MATURED - can be redeemed");
                } else {
                    console.log("  Status: Not mature yet");
                    console.log("  Time remaining:", (maturity - block.timestamp) / 3600, "hours");
                }
            }
        }
    }
    
    function testArbitrageOpportunity() public view {
        console.log("\n=== ARBITRAGE ANALYSIS ===");
        
        // Get fees
        (, , uint64 redemptionFee, uint64 earlyExitFee) = queue.redemptionQueueState();
        
        // Calculate round-trip cost
        // Enter: pay redemptionFee
        // Early Exit: pay earlyExitFee on remaining amount
        
        uint256 testAmount = 100e18; // 100 frxETH
        uint256 afterRedemptionFee = testAmount * (1e6 - redemptionFee) / 1e6;
        uint256 afterEarlyExitFee = afterRedemptionFee * (1e6 - earlyExitFee) / 1e6;
        
        console.log("Test amount: 100 frxETH");
        console.log("After redemption fee:", afterRedemptionFee / 1e18, "ETH value");
        console.log("After early exit fee:", afterEarlyExitFee / 1e18, "frxETH out");
        console.log("Total loss:", (testAmount - afterEarlyExitFee) / 1e18, "frxETH");
        console.log("Loss percentage:", (testAmount - afterEarlyExitFee) * 100 / testAmount, "%");
        
        if (afterEarlyExitFee > testAmount) {
            console.log("!!! ARBITRAGE OPPORTUNITY: Enter and immediately early exit for profit !!!");
        } else {
            console.log("No arbitrage: round-trip results in loss");
        }
    }
}
