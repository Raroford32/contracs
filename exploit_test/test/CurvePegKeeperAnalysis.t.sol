// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title Curve Peg Keeper V2 Manual Deep Analysis
 * @notice Deep state machine analysis looking for emergent issues, not pattern matching
 *
 * Contract: 0x9201da0d97caaaff53f01b2fb56767c7072de340
 *
 * STATE MACHINE MODEL:
 * - debt: Amount of PEGGED stablecoin deposited by PegKeeper into pool
 * - last_change: Timestamp of last provide/withdraw
 * - action_delay: Minimum time between operations (12 seconds = ~1 block)
 * - caller_share: Portion of profit given to update() caller (out of 10^5)
 * - regulator: External contract controlling allowed amounts
 *
 * INVARIANTS TO TEST:
 * - Profit must increase on any update() call
 * - Debt cannot exceed actual stablecoin balance in pool
 * - LP balance should cover debt at virtual_price
 */
contract CurvePegKeeperAnalysis is Test {

    // Peg Keeper V2 contract
    address constant PEG_KEEPER = 0x9201da0D97CaAAff53f01B2fB56767C7072dE340;

    // Interfaces for Peg Keeper (Vyper contract)
    function pool() external view returns (address) {}
    function pegged() external view returns (address) {}
    function debt() external view returns (uint256) {}
    function last_change() external view returns (uint256) {}
    function action_delay() external view returns (uint256) {}
    function caller_share() external view returns (uint256) {}
    function calc_profit() external view returns (uint256) {}
    function estimate_caller_profit() external view returns (uint256) {}
    function regulator() external view returns (address) {}

    // State
    address poolAddr;
    address peggedToken;
    address regulatorAddr;
    uint256 currentDebt;
    uint256 actionDelay;
    uint256 callerSharePercent;

    function setUp() public {
        // Fork mainnet at recent block
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function test_readPegKeeperState() public {
        // Read all state from the Peg Keeper
        console.log("========== CURVE PEG KEEPER V2 STATE ANALYSIS ==========");
        console.log("Contract:", PEG_KEEPER);

        // Get pool address
        (bool success, bytes memory data) = PEG_KEEPER.staticcall(abi.encodeWithSignature("pool()"));
        if (success && data.length >= 32) {
            poolAddr = abi.decode(data, (address));
            console.log("Pool:", poolAddr);
        }

        // Get pegged token
        (success, data) = PEG_KEEPER.staticcall(abi.encodeWithSignature("pegged()"));
        if (success && data.length >= 32) {
            peggedToken = abi.decode(data, (address));
            console.log("Pegged Token:", peggedToken);
        }

        // Get debt
        (success, data) = PEG_KEEPER.staticcall(abi.encodeWithSignature("debt()"));
        if (success && data.length >= 32) {
            currentDebt = abi.decode(data, (uint256));
            console.log("Current Debt:", currentDebt / 1e18, "tokens");
        }

        // Get last_change
        (success, data) = PEG_KEEPER.staticcall(abi.encodeWithSignature("last_change()"));
        if (success && data.length >= 32) {
            uint256 lastChange = abi.decode(data, (uint256));
            console.log("Last Change:", lastChange);
            console.log("Time Since Last Change:", block.timestamp - lastChange, "seconds");
        }

        // Get action_delay
        (success, data) = PEG_KEEPER.staticcall(abi.encodeWithSignature("action_delay()"));
        if (success && data.length >= 32) {
            actionDelay = abi.decode(data, (uint256));
            console.log("Action Delay:", actionDelay, "seconds");
        }

        // Get caller_share
        (success, data) = PEG_KEEPER.staticcall(abi.encodeWithSignature("caller_share()"));
        if (success && data.length >= 32) {
            callerSharePercent = abi.decode(data, (uint256));
            console.log("Caller Share:", callerSharePercent, "/ 100000");
        }

        // Get regulator
        (success, data) = PEG_KEEPER.staticcall(abi.encodeWithSignature("regulator()"));
        if (success && data.length >= 32) {
            regulatorAddr = abi.decode(data, (address));
            console.log("Regulator:", regulatorAddr);
        }

        // Get current profit in LP tokens
        (success, data) = PEG_KEEPER.staticcall(abi.encodeWithSignature("calc_profit()"));
        if (success && data.length >= 32) {
            uint256 profit = abi.decode(data, (uint256));
            console.log("Current Profit (LP):", profit / 1e18, "LP tokens");
        }

        // Get estimated caller profit
        (success, data) = PEG_KEEPER.staticcall(abi.encodeWithSignature("estimate_caller_profit()"));
        if (success && data.length >= 32) {
            uint256 estProfit = abi.decode(data, (uint256));
            console.log("Est Caller Profit:", estProfit / 1e18, "LP tokens");
        }

        console.log("=======================================================");
    }

    function test_analyzePoolState() public {
        test_readPegKeeperState();

        if (poolAddr == address(0)) {
            console.log("Pool address not available");
            return;
        }

        console.log("");
        console.log("========== POOL STATE ANALYSIS ==========");

        // Get pool balances
        (bool success, bytes memory data) = poolAddr.staticcall(
            abi.encodeWithSignature("balances(uint256)", 0)
        );
        if (success && data.length >= 32) {
            uint256 balance0 = abi.decode(data, (uint256));
            console.log("Pool Balance[0]:", balance0 / 1e18);
        }

        (success, data) = poolAddr.staticcall(
            abi.encodeWithSignature("balances(uint256)", 1)
        );
        if (success && data.length >= 32) {
            uint256 balance1 = abi.decode(data, (uint256));
            console.log("Pool Balance[1]:", balance1 / 1e18);
        }

        // Get virtual price
        (success, data) = poolAddr.staticcall(
            abi.encodeWithSignature("get_virtual_price()")
        );
        if (success && data.length >= 32) {
            uint256 vp = abi.decode(data, (uint256));
            console.log("Virtual Price:", vp);
        }

        // Get LP token balance of Peg Keeper
        (success, data) = poolAddr.staticcall(
            abi.encodeWithSignature("balanceOf(address)", PEG_KEEPER)
        );
        if (success && data.length >= 32) {
            uint256 lpBal = abi.decode(data, (uint256));
            console.log("PegKeeper LP Balance:", lpBal / 1e18);
        }

        console.log("=========================================");
    }

    function test_analyzeRegulator() public {
        test_readPegKeeperState();

        if (regulatorAddr == address(0)) {
            console.log("Regulator not available");
            return;
        }

        console.log("");
        console.log("========== REGULATOR ANALYSIS ==========");

        // Get provide_allowed
        (bool success, bytes memory data) = regulatorAddr.staticcall(
            abi.encodeWithSignature("provide_allowed(address)", PEG_KEEPER)
        );
        if (success && data.length >= 32) {
            uint256 allowed = abi.decode(data, (uint256));
            console.log("Provide Allowed:", allowed / 1e18);
        }

        // Get withdraw_allowed
        (success, data) = regulatorAddr.staticcall(
            abi.encodeWithSignature("withdraw_allowed(address)", PEG_KEEPER)
        );
        if (success && data.length >= 32) {
            uint256 allowed = abi.decode(data, (uint256));
            console.log("Withdraw Allowed:", allowed / 1e18);
        }

        // Get fee_receiver
        (success, data) = regulatorAddr.staticcall(
            abi.encodeWithSignature("fee_receiver()")
        );
        if (success && data.length >= 32) {
            address feeReceiver = abi.decode(data, (address));
            console.log("Fee Receiver:", feeReceiver);
        }

        console.log("=========================================");
    }

    function test_attemptProfitExtraction() public {
        test_readPegKeeperState();

        console.log("");
        console.log("========== PROFIT EXTRACTION ATTEMPT ==========");

        address attacker = address(0xBAD);
        vm.deal(attacker, 1 ether);

        // Check if we can call update
        (bool success, bytes memory data) = PEG_KEEPER.staticcall(
            abi.encodeWithSignature("estimate_caller_profit()")
        );

        if (success && data.length >= 32) {
            uint256 estProfit = abi.decode(data, (uint256));
            console.log("Estimated profit from update():", estProfit);

            if (estProfit > 0) {
                console.log("POTENTIAL: update() could yield profit for caller");

                // Try to call update
                vm.startPrank(attacker);
                (bool updateSuccess,) = PEG_KEEPER.call(
                    abi.encodeWithSignature("update(address)", attacker)
                );
                vm.stopPrank();

                if (updateSuccess) {
                    // Check LP balance of attacker
                    (success, data) = poolAddr.staticcall(
                        abi.encodeWithSignature("balanceOf(address)", attacker)
                    );
                    if (success && data.length >= 32) {
                        uint256 attackerLP = abi.decode(data, (uint256));
                        console.log("Attacker LP after update:", attackerLP);
                    }
                } else {
                    console.log("update() reverted - checking reason");
                }
            } else {
                console.log("No profit available currently");
            }
        }

        console.log("================================================");
    }

    /**
     * @notice Test for emergent issue: What if debt > actual stablecoin deposited?
     *
     * The debt variable tracks how much stablecoin was deposited.
     * But LP tokens received depends on pool state.
     * If LP value drops significantly, profit calculation could be wrong.
     */
    function test_debtVsLPValueMismatch() public {
        test_readPegKeeperState();

        if (poolAddr == address(0) || currentDebt == 0) {
            console.log("Skipping - no debt or pool not found");
            return;
        }

        console.log("");
        console.log("========== DEBT vs LP VALUE ANALYSIS ==========");

        // Get virtual price
        (bool success, bytes memory data) = poolAddr.staticcall(
            abi.encodeWithSignature("get_virtual_price()")
        );
        if (!success) return;
        uint256 virtualPrice = abi.decode(data, (uint256));

        // Get LP balance
        (success, data) = poolAddr.staticcall(
            abi.encodeWithSignature("balanceOf(address)", PEG_KEEPER)
        );
        if (!success) return;
        uint256 lpBalance = abi.decode(data, (uint256));

        // Calculate theoretical LP value for debt
        // From contract: lp_debt = debt * PRECISION / virtual_price
        uint256 lpDebt = currentDebt * 1e18 / virtualPrice;

        console.log("Debt:", currentDebt / 1e18);
        console.log("Virtual Price:", virtualPrice);
        console.log("LP Balance:", lpBalance / 1e18);
        console.log("LP Debt (theoretical):", lpDebt / 1e18);

        if (lpBalance >= lpDebt) {
            console.log("Profit (LP):", (lpBalance - lpDebt) / 1e18);
            console.log("Status: HEALTHY - LP covers debt");
        } else {
            console.log("DEFICIT (LP):", (lpDebt - lpBalance) / 1e18);
            console.log("Status: UNHEALTHY - LP does not cover debt!");
            console.log("");
            console.log("!!! POTENTIAL ISSUE: If virtual price dropped, PegKeeper is underwater");
        }

        console.log("==============================================");
    }

    /**
     * @notice Test for MEV/timing attack on update()
     *
     * Anyone can call update() and get caller_share of profit.
     * With action_delay of only 12 seconds (1 block), there's opportunity
     * for strategic timing of calls.
     */
    function test_updateTimingAnalysis() public {
        test_readPegKeeperState();

        console.log("");
        console.log("========== UPDATE TIMING ANALYSIS ==========");

        // Check time since last change
        (bool success, bytes memory data) = PEG_KEEPER.staticcall(
            abi.encodeWithSignature("last_change()")
        );
        if (!success) return;
        uint256 lastChange = abi.decode(data, (uint256));

        uint256 timeSince = block.timestamp - lastChange;
        console.log("Time since last change:", timeSince, "seconds");
        console.log("Action delay:", actionDelay, "seconds");

        if (timeSince >= actionDelay) {
            console.log("Status: update() IS callable");

            // Check estimated profit
            (success, data) = PEG_KEEPER.staticcall(
                abi.encodeWithSignature("estimate_caller_profit()")
            );
            if (success && data.length >= 32) {
                uint256 estProfit = abi.decode(data, (uint256));
                console.log("Estimated caller profit:", estProfit);

                if (estProfit > 0) {
                    console.log("");
                    console.log("OPPORTUNITY: Anyone can call update() now and profit");
                    console.log("This is expected behavior - PegKeeper incentivizes keepers");
                }
            }
        } else {
            console.log("Status: update() NOT callable yet");
            console.log("Time remaining:", actionDelay - timeSince, "seconds");
        }

        console.log("=============================================");
    }
}
