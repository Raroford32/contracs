// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IActionRegistry {
    function getAddr(bytes4 _id) external view returns (address);
    function owner() external view returns (address);
    function entries(bytes4 _id) external view returns (address contractAddr, bool inContractChange, bool exists);
}

interface IActionExecutor {
    function ACTION_REGISTRY() external view returns (address);
    function executeActions(
        bytes4[] calldata _actionIds,
        bytes[] calldata _actionCallData,
        uint8[][] calldata _paramMapping
    ) external payable;
}

// DSProxy interface (DeFiSaver smart wallet pattern)
interface IDSProxy {
    function execute(address _target, bytes memory _data) external payable returns (bytes memory);
    function execute(bytes memory _code, bytes memory _data) external payable returns (address target, bytes memory response);
    function owner() external view returns (address);
    function setOwner(address _owner) external;
    function setAuthority(address _authority) external;
    function authority() external view returns (address);
}

interface IDSProxyFactory {
    function build() external returns (address proxy);
    function build(address owner) external returns (address proxy);
}

interface IDSAuth {
    function canCall(address src, address dst, bytes4 sig) external view returns (bool);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

contract DelegatecallExploitTest is Test {
    address constant IMPLEMENTATION = 0xb1593193Bcd7CEcc3d19597658003d735D1e9E94;
    address constant REGISTRY = 0x94aF5994EB6841e1D930C95AD0C9F89771c3073F;
    address constant DSPROXY_FACTORY = 0xA26e15C895EFc0616177B7c1e7270A4C7D51C997;

    // Known token addresses
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    // DAI address removed - not used

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    address attacker = address(0xBAD);
    address victim;
    IDSProxy victimProxy;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        victim = makeAddr("victim");

        // Create a DSProxy for victim to simulate real-world scenario
        vm.startPrank(victim);
        IDSProxyFactory factory = IDSProxyFactory(DSPROXY_FACTORY);
        try factory.build() returns (address proxy) {
            victimProxy = IDSProxy(proxy);
            console.log("Created victim DSProxy:", proxy);
        } catch {
            console.log("Failed to create DSProxy");
        }
        vm.stopPrank();

        // Fund victim's proxy with some ETH
        if (address(victimProxy) != address(0)) {
            vm.deal(address(victimProxy), 10 ether);
        }
    }

    function test_AttackVector1_DirectCallToProxy() public {
        console.log("\n=== ATTACK VECTOR 1: Direct Call to DSProxy ===");

        if (address(victimProxy) == address(0)) {
            console.log("No victim proxy - skipping test");
            return;
        }

        // Can an attacker directly call victim's DSProxy.execute()?
        vm.startPrank(attacker);

        // Try to execute ActionExecutor through victim's proxy
        bytes4[] memory actionIds = new bytes4[](0);
        bytes[] memory callDatas = new bytes[](0);
        uint8[][] memory mappings = new uint8[][](0);

        bytes memory payload = abi.encodeWithSelector(
            IActionExecutor.executeActions.selector,
            actionIds,
            callDatas,
            mappings
        );

        // This should fail because attacker is not the owner
        try victimProxy.execute(IMPLEMENTATION, payload) {
            console.log("CRITICAL: Attacker could call victim's proxy!");
        } catch Error(string memory reason) {
            console.log("Expected: Cannot call - ", reason);
        } catch (bytes memory lowLevelData) {
            console.log("Expected: Reverted with low-level data");
            console.logBytes(lowLevelData);
        }

        vm.stopPrank();
    }

    function test_AttackVector2_AuthorityBypass() public {
        console.log("\n=== ATTACK VECTOR 2: Authority Bypass ===");

        if (address(victimProxy) == address(0)) {
            console.log("No victim proxy - skipping test");
            return;
        }

        // Check DSProxy's authority
        try victimProxy.authority() returns (address auth) {
            console.log("DSProxy authority:", auth);

            if (auth != address(0)) {
                // Check if attacker can call through authority
                IDSAuth dsAuth = IDSAuth(auth);
                bytes4 executeSig = bytes4(keccak256("execute(address,bytes)"));

                bool canCall = dsAuth.canCall(attacker, address(victimProxy), executeSig);
                console.log("Can attacker call via authority?", canCall);
            } else {
                console.log("No authority set - only owner can call");
            }
        } catch {
            console.log("Could not check authority");
        }

        // Check owner
        console.log("DSProxy owner:", victimProxy.owner());
        console.log("Expected victim:", victim);
    }

    function test_AttackVector3_ImplementationDirectAttack() public {
        console.log("\n=== ATTACK VECTOR 3: Direct Implementation Attack ===");

        // Can attacking the implementation directly harm users?
        IActionExecutor impl = IActionExecutor(IMPLEMENTATION);

        vm.startPrank(attacker);

        // Try to make the implementation contract do something
        bytes4[] memory actionIds = new bytes4[](0);
        bytes[] memory callDatas = new bytes[](0);
        uint8[][] memory mappings = new uint8[][](0);

        // This succeeds but runs in implementation's context, not any user's
        impl.executeActions(actionIds, callDatas, mappings);
        console.log("Empty executeActions on implementation succeeded");
        console.log("Implementation ETH balance:", IMPLEMENTATION.balance);
        console.log("Implementation has no funds to steal");

        vm.stopPrank();
    }

    function test_AttackVector4_RegistryTrustExploit() public {
        console.log("\n=== ATTACK VECTOR 4: Registry Trust Exploitation ===");

        // The ActionExecutor trusts the registry to return valid action addresses
        // If registry is compromised, malicious actions can be registered

        IActionRegistry registry = IActionRegistry(REGISTRY);

        // Check existing actions for "trust" vulnerabilities
        bytes4 aaveSupply = bytes4(keccak256(abi.encodePacked("AaveV3Supply")));
        address supplyAction = registry.getAddr(aaveSupply);

        if (supplyAction != address(0)) {
            console.log("AaveV3Supply action at:", supplyAction);

            // The action itself cannot be exploited directly
            // because it uses PROTOCOL_CONTROLLER which is also immutable

            console.log("Action uses immutable PROTOCOL_CONTROLLER");
            console.log("Attack requires compromising registry owner");
        }
    }

    function test_AttackVector5_StorageCollision() public {
        console.log("\n=== ATTACK VECTOR 5: Storage Collision Check ===");

        // When DSProxy delegatecalls to ActionExecutor,
        // ActionExecutor's storage layout is mapped to DSProxy's storage

        // But ActionExecutor only uses IMMUTABLE (in bytecode, not storage)
        // So no storage collision possible from ActionExecutor itself

        // Check DSProxy's storage layout
        if (address(victimProxy) == address(0)) {
            console.log("No victim proxy - skipping test");
            return;
        }

        // Slot 0 in DSProxy is typically owner or authority
        bytes32 slot0 = vm.load(address(victimProxy), bytes32(0));
        console.log("DSProxy slot 0:");
        console.logBytes32(slot0);

        bytes32 slot1 = vm.load(address(victimProxy), bytes32(uint256(1)));
        console.log("DSProxy slot 1:");
        console.logBytes32(slot1);

        // ActionExecutor has no storage state (only immutables)
        // So delegatecall from DSProxy is safe in terms of storage collision
        console.log("");
        console.log("CONCLUSION: No storage collision risk");
        console.log("ActionExecutor uses immutables only");
    }

    function test_AttackVector6_ReentrancyViaAction() public {
        console.log("\n=== ATTACK VECTOR 6: Reentrancy via Registered Actions ===");

        // Could a malicious token or lending pool callback reenter the system?

        // The registered actions (Aave/Spark) interact with well-known protocols
        // These protocols are battle-tested against reentrancy

        // However, if an attacker could:
        // 1. Get a malicious token added to Aave/Spark
        // 2. Use that token in an action
        // 3. Have the token callback into the DSProxy

        // This is highly unlikely and would require compromising Aave/Spark listing

        console.log("Reentrancy requires:");
        console.log("1. Malicious token listed on Aave/Spark");
        console.log("2. User interacting with that token");
        console.log("3. Token callbacks into user's proxy");
        console.log("");
        console.log("CONCLUSION: Highly improbable - protocols are audited");
    }

    function test_ExploitScenario_RegistryOwnerCompromise() public {
        console.log("\n=== EXPLOIT SCENARIO: Registry Owner Compromise ===");

        // This is the PRIMARY attack vector that would work

        // If an attacker compromises the registry owner, they can:
        // 1. Register a malicious action
        // 2. Users calling recipes with that action would be exploited
        // 3. All DSProxy wallets interacting with the system are at risk

        address registryOwner = IActionRegistry(REGISTRY).owner();
        console.log("Registry owner:", registryOwner);

        // Simulate registry compromise
        vm.startPrank(registryOwner);

        // Deploy malicious action
        MaliciousAction malicious = new MaliciousAction();

        // Register it
        bytes4 maliciousId = bytes4(keccak256("MaliciousTestAction"));
        // registry.addNewContract(maliciousId, address(malicious));

        console.log("");
        console.log("If registry owner is compromised:");
        console.log("- Attacker registers MaliciousAction");
        console.log("- Any user executing recipes with that action loses funds");
        console.log("");
        console.log("SEVERITY: Critical (but requires registry compromise)");
        console.log("CLASSIFICATION: Centralization risk, not unprivileged vuln");

        vm.stopPrank();
    }

    function test_SearchForUnprotectedDSProxies() public {
        console.log("\n=== SEARCHING FOR VULNERABLE DSPROXYIES ===");

        // Look for DSProxies with significant ETH/tokens that might be vulnerable

        // This would require iterating through all DSProxy addresses
        // which is not practical in a test

        console.log("To find vulnerable DSProxies would require:");
        console.log("1. Indexing all DSProxy creation events");
        console.log("2. Checking each proxy's authority settings");
        console.log("3. Verifying owner security");
        console.log("");
        console.log("Standard DSProxy pattern is secure if:");
        console.log("- Owner is properly set");
        console.log("- Authority is not misconfigured");
    }

    function test_FinalConclusion() public view {
        console.log("\n=== FINAL SECURITY ASSESSMENT ===");
        console.log("");
        console.log("TARGET: ActionExecutor + ActionRegistry");
        console.log("IMPLEMENTATION:", IMPLEMENTATION);
        console.log("");
        console.log("FINDING: NO UNPRIVILEGED VULNERABILITY FOUND");
        console.log("");
        console.log("DESIGN:");
        console.log("1. ActionExecutor uses immutable for registry (no storage collision)");
        console.log("2. DSProxy restricts execute() to owner/authority");
        console.log("3. Registered actions are narrow-scoped DeFi ops");
        console.log("4. No arbitrary call/delegatecall capabilities");
        console.log("");
        console.log("CENTRALIZATION RISKS:");
        console.log("1. Registry owner can add malicious actions");
        console.log("2. PROTOCOL_CONTROLLER controls which pools actions use");
        console.log("");
        console.log("The 'proxy' address 0x60D2D94...9943 has NO CODE.");
        console.log("It was never a proxy - likely a miscommunication.");
        console.log("");
        console.log("STATUS: UNPROVEN - No exploitable vulnerability found");
    }
}

// Malicious action for testing
contract MaliciousAction {
    function executeAction(bytes calldata, uint8[] calldata, bytes32[] calldata) external returns (bytes32) {
        // Would steal owner slot
        assembly {
            sstore(0, caller())
        }
        return bytes32(0);
    }
}
