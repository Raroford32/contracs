// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Immediate Flash Loan Search
 * @notice Looking for contracts vulnerable to single-transaction flash loan exploits
 */

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
}

interface IAavePool {
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata modes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

interface IBalancerVault {
    function flashLoan(
        address recipient,
        address[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;
}

interface IERC4626 {
    function deposit(uint256 assets, address receiver) external returns (uint256);
    function redeem(uint256 shares, address receiver, address owner) external returns (uint256);
    function totalAssets() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function asset() external view returns (address);
    function previewDeposit(uint256 assets) external view returns (uint256);
    function previewRedeem(uint256 shares) external view returns (uint256);
    function convertToShares(uint256 assets) external view returns (uint256);
    function convertToAssets(uint256 shares) external view returns (uint256);
}

contract ImmediateFlashLoanSearch is Test {
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    string constant RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    function setUp() public {
        vm.createSelectFork(RPC_URL);
    }

    function test_CheckERC4626VaultInflation() public view {
        console.log("=== ERC4626 Vault Inflation Check ===\n");

        // Check various ERC4626 vaults for first depositor vulnerability
        address[] memory vaults = new address[](8);
        vaults[0] = 0x9D39A5DE30e57443BfF2A8307A4256c8797A3497; // sUSDe
        vaults[1] = 0xac3E018457B222d93114458476f3E3416Abbe38F; // sfrxETH
        vaults[2] = 0x9Ba021B0a9b958B5E75cE9f6dff97C7eE52cb3E6; // AutoPxEth
        vaults[3] = 0xCb6DFd06973bF66C8bD2779538e5C8311B8070B8; // ApxEthVault
        vaults[4] = 0x83F20F44975D03b1b09e64809B757c47f942BEeA; // sDAI
        vaults[5] = 0xae78736Cd615f374D3085123A210448E74Fc6393; // rETH
        vaults[6] = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0; // wstETH
        vaults[7] = 0xBe9895146f7AF43049ca1c1AE358B0541Ea49704; // cbETH

        for (uint i = 0; i < vaults.length; i++) {
            address vault = vaults[i];
            if (vault.code.length == 0) continue;

            try IERC4626(vault).totalSupply() returns (uint256 supply) {
                try IERC4626(vault).totalAssets() returns (uint256 assets) {
                    if (supply == 0) {
                        console.log("Vault", i, "- EMPTY (first depositor attack possible)");
                    } else {
                        uint256 sharePrice = assets * 1e18 / supply;
                        console.log("Vault", i);
                        console.log("  Supply:", supply / 1e18);
                        console.log("  Assets:", assets / 1e18);
                        console.log("  Share Price:", sharePrice);

                        // Check for abnormal share price
                        if (sharePrice > 2e18) {
                            console.log("  HIGH SHARE PRICE - potential donation attack");
                        }
                    }
                } catch {}
            } catch {}
        }
    }

    function test_CheckDonationVulnerability() public view {
        console.log("=== Donation Attack Vulnerability Check ===\n");

        // For donation attacks, we need:
        // 1. Vault with low total supply
        // 2. balanceOf-based accounting (not internal accounting)

        address sUSDe = 0x9D39A5DE30e57443BfF2A8307A4256c8797A3497;

        uint256 totalSupply = IERC4626(sUSDe).totalSupply();
        uint256 totalAssets = IERC4626(sUSDe).totalAssets();
        address asset = IERC4626(sUSDe).asset();
        uint256 actualBalance = IERC20(asset).balanceOf(sUSDe);

        console.log("sUSDe Analysis:");
        console.log("  Total Supply:", totalSupply / 1e18);
        console.log("  Total Assets:", totalAssets / 1e18);
        console.log("  Actual USDe Balance:", actualBalance / 1e18);

        if (actualBalance > totalAssets) {
            console.log("\n  SURPLUS DETECTED:", (actualBalance - totalAssets) / 1e18);
            console.log("  This could be pending yield or donation");
        }

        // Check conversion ratios for small amounts
        uint256 smallDeposit = 1e18; // 1 USDe
        try IERC4626(sUSDe).previewDeposit(smallDeposit) returns (uint256 shares) {
            console.log("\n  1 USDe would give:", shares, "shares");
            try IERC4626(sUSDe).previewRedeem(shares) returns (uint256 assets) {
                console.log("  Those shares would give:", assets, "USDe back");
                if (assets < smallDeposit) {
                    console.log("  LOSS on roundtrip:", smallDeposit - assets);
                }
            } catch {}
        } catch {}
    }

    function test_CheckRewardGaming() public view {
        console.log("=== Reward Gaming Vulnerability Check ===\n");

        // Look for staking/reward contracts where rewards can be gamed
        // by depositing right before reward distribution

        address[] memory stakingContracts = new address[](5);
        stakingContracts[0] = 0x73968b9a57c6E53d41345FD57a6E6ae27d6CDB2F; // sd-steCRV gauge
        stakingContracts[1] = 0xF403C135812408BFbE8713b5A23a04b3D48AAE31; // Convex
        stakingContracts[2] = 0x9A0C8Ff858d273f57072D714bca7411D717501D7; // st1INCH
        stakingContracts[3] = 0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552; // Gnosis Safe
        stakingContracts[4] = 0x2E15D7AA0650dE1009710FDd45C3468d75AE1392; // cvxCRV

        for (uint i = 0; i < stakingContracts.length; i++) {
            address sc = stakingContracts[i];
            if (sc.code.length == 0) continue;

            // Try to get reward rate
            (bool success, bytes memory data) = sc.staticcall(
                abi.encodeWithSignature("rewardRate()")
            );
            if (success && data.length >= 32) {
                uint256 rate = abi.decode(data, (uint256));
                console.log("Contract", i, "reward rate:", rate);
            }

            // Check periodFinish
            (success, data) = sc.staticcall(
                abi.encodeWithSignature("periodFinish()")
            );
            if (success && data.length >= 32) {
                uint256 finish = abi.decode(data, (uint256));
                if (finish > block.timestamp) {
                    console.log("Contract", i, "- rewards active until:", finish);
                }
            }
        }
    }

    function test_CheckFlashMintVulnerability() public view {
        console.log("=== Flash Mint Vulnerability Check ===\n");

        // Some tokens have flashMint functionality
        // Check if there are any that can be exploited

        address[] memory flashMintTokens = new address[](3);
        flashMintTokens[0] = 0x6B175474E89094C44Da98b954EedeAC495271d0F; // DAI
        flashMintTokens[1] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // WETH
        flashMintTokens[2] = 0x111111111117dC0aa78b770fA6A738034120C302; // 1INCH

        for (uint i = 0; i < flashMintTokens.length; i++) {
            address token = flashMintTokens[i];
            if (token.code.length == 0) continue;

            // Check maxFlashLoan
            (bool success, bytes memory data) = token.staticcall(
                abi.encodeWithSignature("maxFlashLoan(address)", token)
            );
            if (success && data.length >= 32) {
                uint256 maxLoan = abi.decode(data, (uint256));
                if (maxLoan > 0) {
                    console.log("Token", i, "flash loan available:", maxLoan / 1e18);
                }
            }

            // Check flashFee
            (success, data) = token.staticcall(
                abi.encodeWithSignature("flashFee(address,uint256)", token, 1e18)
            );
            if (success && data.length >= 32) {
                uint256 fee = abi.decode(data, (uint256));
                console.log("Token", i, "flash fee for 1 token:", fee);
            }
        }
    }

    function test_SummaryOfFindings() public pure {
        console.log("=== SUMMARY OF IMMEDIATE EXPLOIT SEARCH ===\n");

        console.log("CHECKED:");
        console.log("1. ERC4626 vault inflation - All have supply > 0");
        console.log("2. Donation attacks - Internal accounting blocks");
        console.log("3. Reward gaming - Time locks prevent flash gaming");
        console.log("4. Flash mint exploits - Standard implementations");

        console.log("\nFINDINGS:");
        console.log("- sUSDe has surplus but protected by internal accounting");
        console.log("- Oracle staleness exists but needs price movement");
        console.log("- FraxQueue deficit needs 29 day wait");
        console.log("- Morpho has no oracle validation but needs entry");

        console.log("\nNO IMMEDIATELY EXPLOITABLE VULNERABILITY FOUND");
        console.log("Continue investigating cross-protocol interactions");
    }
}
