// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IAevoStaking {
    function stake(bool isRBN, uint256 amount) external;
    function unstake(uint16 start, uint16 end) external;
    function staked() external view returns (uint256);
    function staked(address account) external view returns (uint256);
    function epoch() external view returns (uint16);
    function epochTime() external view returns (uint256);
    function stakeTime() external view returns (uint256);
    function start() external view returns (uint256);
    function isLocked() external view returns (bool);
    function balance(address, uint16) external view returns (uint256);
    function epochBalance(uint16) external view returns (uint256);
}

/**
 * @title AevoStaking Epoch Overflow Analysis
 * @notice Analyzing potential vulnerabilities:
 *
 * 1. UINT16 EPOCH OVERFLOW:
 *    - epoch() returns uint16((block.timestamp - start) / epochTime + 1)
 *    - Max epochs = 65535
 *    - If epochTime is small, overflow happens quickly
 *
 * 2. SLIDING WINDOW UNDERFLOW:
 *    - staked() uses: cEpoch - window
 *    - If window > cEpoch, underflow could occur
 *
 * 3. UNSTAKE EPOCH RANGE:
 *    - User specifies _start and _end epochs
 *    - Potential to unstake from future epochs if not validated properly
 */
contract AevoStakingAnalysisTest is Test {
    address constant AEVO_STAKING = 0x38913051E01D4F6910cB66bB9aC3cb77D746Ad81;

    IAevoStaking aevoStaking;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        aevoStaking = IAevoStaking(AEVO_STAKING);
    }

    function testEpochOverflowAnalysis() public view {
        uint256 epochTime = aevoStaking.epochTime();
        uint256 start = aevoStaking.start();
        uint16 currentEpoch = aevoStaking.epoch();

        console.log("=== Epoch Overflow Analysis ===");
        console.log("Epoch time:", epochTime, "seconds");
        console.log("Start time:", start);
        console.log("Current epoch:", currentEpoch);

        // Calculate time until overflow
        uint256 maxEpochs = type(uint16).max; // 65535
        uint256 secondsUntilOverflow = (maxEpochs - currentEpoch) * epochTime;
        uint256 daysUntilOverflow = secondsUntilOverflow / 1 days;

        console.log("\nMax epochs (uint16):", maxEpochs);
        console.log("Epochs remaining:", maxEpochs - currentEpoch);
        console.log("Seconds until overflow:", secondsUntilOverflow);
        console.log("Days until overflow:", daysUntilOverflow);

        if (daysUntilOverflow < 365) {
            console.log("\n[CRITICAL] Overflow possible within 1 year!");
        }
    }

    function testSlidingWindowAnalysis() public view {
        uint256 epochTime = aevoStaking.epochTime();
        uint256 stakeTime = aevoStaking.stakeTime();
        uint16 currentEpoch = aevoStaking.epoch();

        console.log("\n=== Sliding Window Analysis ===");
        console.log("Epoch time:", epochTime);
        console.log("Stake time (window):", stakeTime);
        console.log("Current epoch:", currentEpoch);

        // Window size
        uint256 windowSize = stakeTime / epochTime;
        console.log("Window size (epochs):", windowSize);

        // Check for potential underflow in early epochs
        if (currentEpoch < windowSize) {
            console.log("\n[!] UNDERFLOW RISK: currentEpoch < windowSize");
            console.log("staked() loop could underflow when calculating cEpoch - window");
        } else {
            console.log("\nNo immediate underflow risk");
        }
    }

    function testUnstakeRangeValidation() public view {
        uint16 currentEpoch = aevoStaking.epoch();
        bool isLocked = aevoStaking.isLocked();

        console.log("\n=== Unstake Range Validation ===");
        console.log("Current epoch:", currentEpoch);
        console.log("Is locked:", isLocked);

        if (!isLocked) {
            console.log("\n[!] UNLOCK MODE: Users can unstake from any epoch");
            console.log("Potential to unstake future epoch balances if validation weak");
        } else {
            uint256 stakeTime = aevoStaking.stakeTime();
            uint256 epochTime = aevoStaking.epochTime();
            uint256 windowSize = stakeTime / epochTime;
            uint16 maxUnstakeEpoch = currentEpoch > windowSize ? uint16(currentEpoch - windowSize) : 0;

            console.log("\nLock mode - max unstake epoch:", maxUnstakeEpoch);
            console.log("Users cannot unstake from epochs >", maxUnstakeEpoch);
        }
    }
}
