// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

interface IAcceleratingDistributor {
    struct UserDeposit {
        uint256 cumulativeBalance;
        uint256 averageDepositTime;
        uint256 rewardsAccumulatedPerToken;
        uint256 rewardsOutstanding;
    }

    function rewardToken() external view returns (address);
    function stakingTokens(address token) external view returns (
        bool enabled,
        uint256 baseEmissionRate,
        uint256 maxMultiplier,
        uint256 secondsToMaxMultiplier,
        uint256 cumulativeStaked,
        uint256 rewardPerTokenStored,
        uint256 lastUpdateTime
    );
    function getCumulativeStaked(address token) external view returns (uint256);
    function getUserStake(address token, address account) external view returns (UserDeposit memory);
    function baseRewardPerToken(address token) external view returns (uint256);
    function getOutstandingRewards(address token, address account) external view returns (uint256);
    function stake(address token, uint256 amount) external;
    function unstake(address token, uint256 amount) external;
    function withdrawReward(address token) external;
}

contract AcceleratingDistributorExploitTest is Test {
    address constant DISTRIBUTOR = 0x9040e41eF5E8b281535a96D9a48aCb8cfaBD9a48;

    IAcceleratingDistributor distributor;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        distributor = IAcceleratingDistributor(DISTRIBUTOR);
    }

    function testDistributorState() public view {
        console.log("=== ACCELERATING DISTRIBUTOR STATE ===");

        address rewardToken = distributor.rewardToken();
        console.log("Reward token:", rewardToken);

        uint256 rewardBalance = IERC20(rewardToken).balanceOf(DISTRIBUTOR);
        console.log("Reward token balance:", rewardBalance / 1e18);

        // Check some common LP tokens
        address[] memory tokens = new address[](2);
        tokens[0] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // WETH
        tokens[1] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // USDC

        for (uint i = 0; i < tokens.length; i++) {
            try distributor.stakingTokens(tokens[i]) returns (
                bool enabled,
                uint256 baseEmissionRate,
                uint256 maxMultiplier,
                uint256 secondsToMaxMultiplier,
                uint256 cumulativeStaked,
                uint256,
                uint256
            ) {
                if (enabled) {
                    console.log("\nToken", i, "enabled");
                    console.log("  Base emission rate:", baseEmissionRate);
                    console.log("  Max multiplier:", maxMultiplier);
                    console.log("  Seconds to max:", secondsToMaxMultiplier);
                    console.log("  Cumulative staked:", cumulativeStaked);
                }
            } catch {}
        }
    }
}
