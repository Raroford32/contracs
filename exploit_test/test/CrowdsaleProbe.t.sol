// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface ICrowdsale {
    function finalized() external view returns (bool);
    function owner() external view returns (address);
    function startsAt() external view returns (uint);
    function endsAt() external view returns (uint);
    function minimumFundingGoal() external view returns (uint);
    function weiRaised() external view returns (uint);
    function multisigWallet() external view returns (address);
    function isMinimumGoalReached() external view returns (bool);
    function refund() external;
    function loadRefund() external payable;
}

contract CrowdsaleProbeTest is Test {
    address constant TARGET = 0xc9d7bd1Fad7D5621DdA20335818E9575Ae07Ea03;
    
    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testCrowdsaleState() public view {
        ICrowdsale cs = ICrowdsale(TARGET);
        console.log("=== CROWDSALE STATE ===");
        console.log("Balance:", TARGET.balance / 1e18, "ETH");
        
        try cs.finalized() returns (bool fin) {
            console.log("Finalized:", fin);
        } catch {}
        
        try cs.owner() returns (address owner) {
            console.log("Owner:", owner);
        } catch {}
        
        try cs.startsAt() returns (uint start) {
            console.log("StartsAt:", start);
        } catch {}
        
        try cs.endsAt() returns (uint end) {
            console.log("EndsAt:", end);
            console.log("Now:", block.timestamp);
            console.log("Ended?:", block.timestamp > end);
        } catch {}
        
        try cs.minimumFundingGoal() returns (uint goal) {
            console.log("Min goal:", goal);
        } catch {}
        
        try cs.weiRaised() returns (uint raised) {
            console.log("Wei raised:", raised);
        } catch {}
        
        try cs.multisigWallet() returns (address wallet) {
            console.log("Multisig:", wallet);
        } catch {}
        
        try cs.isMinimumGoalReached() returns (bool reached) {
            console.log("Goal reached:", reached);
        } catch {}
    }

    function testTryRefund() public {
        ICrowdsale cs = ICrowdsale(TARGET);
        uint256 balBefore = address(this).balance;
        
        console.log("=== TRYING REFUND ===");
        console.log("Balance before:", balBefore);
        
        try cs.refund() {
            console.log("Refund succeeded!");
        } catch Error(string memory reason) {
            console.log("Refund failed:", reason);
        } catch {
            console.log("Refund failed (no reason)");
        }
        
        uint256 balAfter = address(this).balance;
        if (balAfter > balBefore) {
            console.log("PROFIT:", (balAfter - balBefore) / 1e18, "ETH");
        }
    }

    receive() external payable {}
}
