// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

interface IRedemption {
    function redeem(uint96 amount) external;
    function finalizeRedeem(uint256 index) external;
    function cancelRedeem(uint256 index) external;
    function IAU() external view returns (address);
    function VAULT() external view returns (address);
    function REDEMPTION_CONTROLLER() external view returns (address);
    function waitingPeriod() external view returns (uint32);
}

interface IRedemptionController {
    function redeem(uint256 amount, address to) external;
    function getRedemptionContracts() external view returns (address[] memory);
}

contract RedemptionStorageExploit is Test {
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeRedemptionStorage() public view {
        console.log("=== ANALYZING REDEMPTION STORAGE ===\n");

        // Print first 20 storage slots
        console.log("Redemption 0 storage:");
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(REDEMPTION_0, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // The redemption data should be in a mapping or array
        // Common patterns:
        // - mapping(address => RedemptionRequest[]) userRedemptions
        // - mapping(address => mapping(uint256 => RedemptionRequest)) 

        // Try to find array slot for a user who has redeemed
        // First find any redemption events by checking log data
    }

    function test_SimulateRedemptionFlow() public {
        console.log("=== SIMULATING FULL REDEMPTION FLOW ===\n");

        // Deal IAU tokens to attacker
        deal(IAU, attacker, 1000e18);

        vm.startPrank(attacker);

        console.log("1. Attacker IAU balance:", IERC20(IAU).balanceOf(attacker) / 1e18);

        // Approve Redemption to spend IAU
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        // Start redemption
        console.log("\n2. Starting redemption for 100 IAU...");
        (bool success, bytes memory data) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("   Success:", success);
        if (!success) {
            console.log("   Error selector:");
            console.logBytes4(bytes4(data));
        }

        // Check attacker's pending redemptions
        console.log("\n3. Checking attacker's redemption data...");
        
        // Try getUserRedemptions if it exists
        (success, data) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("getUserRedemptions(address)", attacker)
        );
        if (success && data.length > 0) {
            console.log("   getUserRedemptions returned data");
        }

        // Try getRedemptions
        (success, data) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("getRedemptions(address)", attacker)
        );
        if (success && data.length > 0) {
            console.log("   getRedemptions returned data");
        }

        // Warp past waiting period
        console.log("\n4. Warping 7 days...");
        vm.warp(block.timestamp + 7 days + 1);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstETHBefore = IERC20(wstETH).balanceOf(attacker);
        console.log("   Vault wstETH:", vaultBefore / 1e18);

        // Finalize redemption
        console.log("\n5. Finalizing redemption...");
        (success, data) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("   Success:", success);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstETHAfter = IERC20(wstETH).balanceOf(attacker);

        console.log("\n6. Results:");
        console.log("   Vault wstETH after:", vaultAfter / 1e18);
        console.log("   Attacker wstETH received:", (attackerWstETHAfter - attackerWstETHBefore) / 1e18);

        if (attackerWstETHAfter > attackerWstETHBefore) {
            console.log("\n   *** REDEMPTION SUCCESSFUL! ***");
        }
    }

    function test_FindRedemptionViewFunctions() public view {
        console.log("=== FINDING REDEMPTION VIEW FUNCTIONS ===\n");

        bytes4[] memory viewSelectors = new bytes4[](20);
        viewSelectors[0] = bytes4(keccak256("getUserRedemptions(address)"));
        viewSelectors[1] = bytes4(keccak256("getRedemptions(address)"));
        viewSelectors[2] = bytes4(keccak256("redemptions(address,uint256)"));
        viewSelectors[3] = bytes4(keccak256("userRedemptions(address)"));
        viewSelectors[4] = bytes4(keccak256("pendingRedemptions(address)"));
        viewSelectors[5] = bytes4(keccak256("redemptionCount(address)"));
        viewSelectors[6] = bytes4(keccak256("getUserRedemptionCount(address)"));
        viewSelectors[7] = bytes4(keccak256("getRedemptionAmount(address,uint256)"));
        viewSelectors[8] = bytes4(keccak256("redemptionQueue(uint256)"));
        viewSelectors[9] = bytes4(keccak256("queue(uint256)"));
        viewSelectors[10] = bytes4(keccak256("exchangeRate()"));
        viewSelectors[11] = bytes4(keccak256("getExchangeRate()"));
        viewSelectors[12] = bytes4(keccak256("conversionRate()"));
        viewSelectors[13] = bytes4(keccak256("totalPendingRedemptions()"));
        viewSelectors[14] = bytes4(keccak256("minRedemptionAmount()"));
        viewSelectors[15] = bytes4(keccak256("maxRedemptionAmount()"));
        viewSelectors[16] = bytes4(keccak256("whitelistOnly()"));
        viewSelectors[17] = bytes4(keccak256("isWhitelisted(address)"));
        viewSelectors[18] = bytes4(keccak256("whitelist(address)"));
        viewSelectors[19] = bytes4(keccak256("minAmount()"));

        string[20] memory names = [
            "getUserRedemptions",
            "getRedemptions",
            "redemptions",
            "userRedemptions",
            "pendingRedemptions",
            "redemptionCount",
            "getUserRedemptionCount",
            "getRedemptionAmount",
            "redemptionQueue",
            "queue",
            "exchangeRate",
            "getExchangeRate",
            "conversionRate",
            "totalPendingRedemptions",
            "minRedemptionAmount",
            "maxRedemptionAmount",
            "whitelistOnly",
            "isWhitelisted",
            "whitelist",
            "minAmount"
        ];

        console.log("Testing view functions on Redemption 0:");

        for (uint i = 0; i < viewSelectors.length; i++) {
            bytes memory callData;
            // Functions that take address
            if (i <= 8 || i == 17 || i == 18) {
                callData = abi.encodeWithSelector(viewSelectors[i], attacker);
            } else if (i == 8 || i == 9) {
                callData = abi.encodeWithSelector(viewSelectors[i], uint256(0));
            } else {
                callData = abi.encodeWithSelector(viewSelectors[i]);
            }

            (bool success, bytes memory data) = REDEMPTION_0.staticcall(callData);
            if (success && data.length > 0) {
                console.log("  FOUND:", names[i]);
                if (data.length == 32) {
                    uint256 val = abi.decode(data, (uint256));
                    console.log("    Value:", val);
                }
            }
        }
    }

    function test_BruteForceRedemptionSelectors() public view {
        console.log("=== BRUTE FORCING REDEMPTION SELECTORS ===\n");

        // Found selectors from previous test, let's identify them
        bytes4[] memory selectors = new bytes4[](27);
        selectors[0] = bytes4(0xe30c3978);  // pendingOwner()
        selectors[1] = bytes4(0xed45b661);
        selectors[2] = bytes4(0xeda72134);
        selectors[3] = bytes4(0xf2fde38b);  // transferOwnership(address)
        selectors[4] = bytes4(0xaff6cbf1);  // finalizeRedeem(uint256)
        selectors[5] = bytes4(0xb2118a8d);
        selectors[6] = bytes4(0xcff50c6e);
        selectors[7] = bytes4(0x8da5cb5b);  // owner()
        selectors[8] = bytes4(0x900fd1ed);
        selectors[9] = bytes4(0x9307e802);
        selectors[10] = bytes4(0xa82b69ff);
        selectors[11] = bytes4(0x715018a6);  // renounceOwnership()
        selectors[12] = bytes4(0x7630c4a8);  // redeem(uint96)
        selectors[13] = bytes4(0x79ba5097);  // acceptOwnership()
        selectors[14] = bytes4(0x458f5815);
        selectors[15] = bytes4(0x51cbf345);
        selectors[16] = bytes4(0x5c975abb);  // paused()
        selectors[17] = bytes4(0x5f8b5592);
        selectors[18] = bytes4(0x3a2ef9df);
        selectors[19] = bytes4(0x3f14c193);
        selectors[20] = bytes4(0x411557d1);
        selectors[21] = bytes4(0x196e6b1d);
        selectors[22] = bytes4(0x2ab60045);
        selectors[23] = bytes4(0x38a63183);
        selectors[24] = bytes4(0x04824e70);
        selectors[25] = bytes4(0x1650cf97);
        selectors[26] = bytes4(0x192a8e86);

        // Try unknown selectors with no args
        console.log("Trying unknown selectors as view:");

        bytes4[] memory unknowns = new bytes4[](18);
        unknowns[0] = bytes4(0xed45b661);
        unknowns[1] = bytes4(0xeda72134);
        unknowns[2] = bytes4(0xb2118a8d);
        unknowns[3] = bytes4(0xcff50c6e);
        unknowns[4] = bytes4(0x900fd1ed);
        unknowns[5] = bytes4(0x9307e802);
        unknowns[6] = bytes4(0xa82b69ff);
        unknowns[7] = bytes4(0x458f5815);
        unknowns[8] = bytes4(0x51cbf345);
        unknowns[9] = bytes4(0x5f8b5592);
        unknowns[10] = bytes4(0x3a2ef9df);
        unknowns[11] = bytes4(0x3f14c193);
        unknowns[12] = bytes4(0x411557d1);
        unknowns[13] = bytes4(0x196e6b1d);
        unknowns[14] = bytes4(0x2ab60045);
        unknowns[15] = bytes4(0x38a63183);
        unknowns[16] = bytes4(0x1650cf97);
        unknowns[17] = bytes4(0x192a8e86);

        for (uint i = 0; i < unknowns.length; i++) {
            (bool success, bytes memory data) = REDEMPTION_0.staticcall(
                abi.encodeWithSelector(unknowns[i])
            );
            if (success) {
                console.logBytes4(unknowns[i]);
                console.log("  Success! Data length:", data.length);
                if (data.length == 32) {
                    console.logBytes32(bytes32(data));
                }
            }
        }
    }

    function test_CallKnownViewFunctions() public view {
        console.log("=== CALLING KNOWN VIEW FUNCTIONS ===\n");

        // IAU()
        (bool success, bytes memory data) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("IAU()")
        );
        if (success) {
            address iau = abi.decode(data, (address));
            console.log("IAU():", iau);
        }

        // VAULT()
        (success, data) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("VAULT()")
        );
        if (success) {
            address vault = abi.decode(data, (address));
            console.log("VAULT():", vault);
        }

        // REDEMPTION_CONTROLLER()
        (success, data) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("REDEMPTION_CONTROLLER()")
        );
        if (success) {
            address rc = abi.decode(data, (address));
            console.log("REDEMPTION_CONTROLLER():", rc);
        }

        // waitingPeriod()
        (success, data) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("waitingPeriod()")
        );
        if (success) {
            uint32 period = abi.decode(data, (uint32));
            console.log("waitingPeriod():", period, "seconds"); console.log("  =", period / 86400, "days");
        }

        // Try additional common functions
        console.log("\nTrying additional functions:");

        (success, data) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("wstETH()")
        );
        if (success) {
            console.log("wstETH():", abi.decode(data, (address)));
        }

        (success, data) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("UNDERLYING()")
        );
        if (success) {
            console.log("UNDERLYING():", abi.decode(data, (address)));
        }

        (success, data) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("totalRedeemed()")
        );
        if (success) {
            console.log("totalRedeemed():", abi.decode(data, (uint256)) / 1e18);
        }

        (success, data) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("conversionRateBPS()")
        );
        if (success) {
            console.log("conversionRateBPS():", abi.decode(data, (uint256)));
        }
    }

    function test_ExploreStorageLayout() public view {
        console.log("=== EXPLORING REDEMPTION STORAGE LAYOUT ===\n");

        // Redemption storage slot 3 had:
        // 0x0000000000000000002710000000000000000000000000000000000000000000
        // This is 0x2710 = 10000 which could be conversionRateBPS (100.00%)

        // Slot 4 had:
        // 0x00000005000000350e9ec117defc5dc000093a800000000ad78ebc5ac6200000
        // This looks like packed data

        // Let's decode slot 4:
        bytes32 slot4 = vm.load(REDEMPTION_0, bytes32(uint256(4)));
        console.log("Slot 4 raw:");
        console.logBytes32(slot4);

        // Possible packing:
        // [32 bits][32 bits][96 bits][96 bits] = 256 bits
        // Or:
        // [96 bits = amount1][64 bits = timestamp][96 bits = amount2]

        uint256 slot4Val = uint256(slot4);
        
        // Try extracting different parts
        uint256 part1 = slot4Val >> 224;  // Top 32 bits
        uint256 part2 = (slot4Val >> 192) & 0xFFFFFFFF;  // Next 32 bits
        uint256 part3 = (slot4Val >> 96) & 0xFFFFFFFFFFFFFFFFFFFFFFFF;  // Middle 96 bits
        uint256 part4 = slot4Val & 0xFFFFFFFFFFFFFFFFFFFFFFFF;  // Bottom 96 bits

        console.log("\nDecoded parts:");
        console.log("  Top 32 bits:", part1);
        console.log("  Next 32 bits:", part2);
        console.log("  Middle 96 bits:", part3);
        console.log("  Bottom 96 bits:", part4);

        // Try as amount in wei
        console.log("\nAs amounts (in ETH):");
        console.log("  Part 3 as ETH:", part3 / 1e18);
        console.log("  Part 4 as ETH:", part4 / 1e18);
    }

    function test_CheckWhitelistStatus() public view {
        console.log("=== CHECKING WHITELIST STATUS ===\n");

        // Error 0xa0927dc3 from redeem() - this might be a whitelist check

        // Try isWhitelisted
        (bool success, bytes memory data) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("isWhitelisted(address)", attacker)
        );
        if (success && data.length == 32) {
            bool whitelisted = abi.decode(data, (bool));
            console.log("isWhitelisted(attacker):", whitelisted);
        }

        // Try whitelist mapping
        (success, data) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("whitelist(address)", attacker)
        );
        if (success && data.length == 32) {
            bool inWhitelist = abi.decode(data, (bool));
            console.log("whitelist(attacker):", inWhitelist);
        }

        // Try whitelistEnabled
        (success, data) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("whitelistEnabled()")
        );
        if (success && data.length == 32) {
            bool enabled = abi.decode(data, (bool));
            console.log("whitelistEnabled():", enabled);
        }

        // Try whitelistOnly
        (success, data) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("whitelistOnly()")
        );
        if (success && data.length == 32) {
            bool only = abi.decode(data, (bool));
            console.log("whitelistOnly():", only);
        }

        // Check the owner's whitelist status
        address owner = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;
        (success, data) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("isWhitelisted(address)", owner)
        );
        if (success && data.length == 32) {
            bool ownerWhitelisted = abi.decode(data, (bool));
            console.log("isWhitelisted(owner):", ownerWhitelisted);
        }
    }
}
