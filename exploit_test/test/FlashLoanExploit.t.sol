// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

interface IBalancerVault {
    function flashLoan(
        address recipient,
        address[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;
}

interface IWETH {
    function deposit() external payable;
    function withdraw(uint256) external;
}

interface ICurvePool {
    function get_virtual_price() external view returns (uint256);
    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external payable returns (uint256);
    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount) external payable returns (uint256);
    function remove_liquidity(uint256 _amount, uint256[2] calldata min_amounts) external returns (uint256[2] memory);
}

contract FlashLoanExploit is Test {
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant BALANCER = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address constant CURVE_STETH = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;
    address constant STETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;

    bool inFlashLoan;
    uint256 attackProfit;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testFlashLoanCapabilities() public view {
        console.log("=======================================================");
        console.log("FLASH LOAN CAPABILITIES CHECK");
        console.log("=======================================================");

        // Check Balancer liquidity
        uint256 wethBal = IERC20(WETH).balanceOf(BALANCER);
        uint256 usdcBal = IERC20(USDC).balanceOf(BALANCER);
        uint256 stethBal = IERC20(STETH).balanceOf(BALANCER);

        console.log("Balancer Vault:");
        console.log("  WETH available:", wethBal / 1e18);
        console.log("  USDC available:", usdcBal / 1e6);
        console.log("  stETH available:", stethBal / 1e18);
        console.log("  Fee: FREE (0%)");
    }

    function testCurveReadOnlyReentrancy() public view {
        console.log("=======================================================");
        console.log("CURVE READ-ONLY REENTRANCY CHECK");
        console.log("=======================================================");

        // Get current virtual price
        uint256 vp = ICurvePool(CURVE_STETH).get_virtual_price();
        console.log("Current virtual_price:", vp);
        console.log("Expected ~1.13e18 for stETH/ETH pool");

        // During a remove_liquidity_one_coin callback, virtual_price can be manipulated
        // But this requires finding a protocol that uses get_virtual_price() for pricing
        console.log("\nPotential targets using Curve virtual_price:");
        console.log("- Convex pools");
        console.log("- Yearn strategies");
        console.log("- Various lending protocols");
    }

    function testSearchForCallbackVulnerabilities() public {
        console.log("=======================================================");
        console.log("SEARCHING FOR CALLBACK VULNERABILITIES");
        console.log("=======================================================");

        // Check protocols with callbacks
        address[5] memory callbackTargets = [
            0xF5BCE5077908a1b7370B9ae04AdC565EBd643966, // BentoBox
            0xBA12222222228d8Ba445958a75a0704d566BF2C8, // Balancer
            0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2, // Aave
            0xc3d688B66703497DAA19211EEdff47f25384cdc3, // Compound
            address(0)
        ];

        for (uint i = 0; i < callbackTargets.length; i++) {
            if (callbackTargets[i] == address(0)) continue;

            console.log("\nTarget:", callbackTargets[i]);

            // Check flash loan capability
            (bool hasFlash,) = callbackTargets[i].staticcall(
                abi.encodeWithSignature("flashLoan(address,address[],uint256[],bytes)")
            );
            console.log("  Has flashLoan:", hasFlash ? "possibly" : "no");
        }
    }

    function testSimulateFlashLoan() public {
        console.log("=======================================================");
        console.log("SIMULATING FREE FLASH LOAN");
        console.log("=======================================================");

        uint256 flashAmount = 100 ether; // Borrow 100 WETH

        console.log("Borrowing", flashAmount / 1e18, "WETH from Balancer (FREE)");

        address[] memory tokens = new address[](1);
        tokens[0] = WETH;

        uint256[] memory amounts = new uint256[](1);
        amounts[0] = flashAmount;

        // Execute flash loan
        inFlashLoan = true;
        IBalancerVault(BALANCER).flashLoan(
            address(this),
            tokens,
            amounts,
            abi.encode(1) // Attack type 1
        );
        inFlashLoan = false;

        console.log("Flash loan executed successfully");
        console.log("Net profit:", attackProfit / 1e18, "WETH");
    }

    // Balancer flash loan callback
    function receiveFlashLoan(
        address[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external {
        require(inFlashLoan, "Not in flash loan");
        require(msg.sender == BALANCER, "Not Balancer");

        console.log("In flash loan callback!");
        console.log("Borrowed:", amounts[0] / 1e18, "tokens");
        console.log("Fee:", feeAmounts[0]); // Should be 0

        uint256 attackType = abi.decode(userData, (uint256));

        if (attackType == 1) {
            // Attack type 1: Try to exploit something with borrowed funds
            uint256 balance = IERC20(tokens[0]).balanceOf(address(this));
            console.log("Current balance:", balance / 1e18);

            // Here we would execute the attack
            // For now, just verify we have the funds
            require(balance >= amounts[0], "Insufficient balance");

            // Repay the flash loan
            IERC20(tokens[0]).transfer(BALANCER, amounts[0] + feeAmounts[0]);
        }
    }

    function testFuzzFlashLoanAmount() public {
        console.log("=======================================================");
        console.log("TESTING VARIOUS FLASH LOAN AMOUNTS");
        console.log("=======================================================");

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 1 ether;
        amounts[1] = 100 ether;
        amounts[2] = 1000 ether;
        amounts[3] = 2000 ether; // Near max available
        amounts[4] = 2700 ether; // Max available

        for (uint i = 0; i < amounts.length; i++) {
            uint256 amount = amounts[i];
            uint256 available = IERC20(WETH).balanceOf(BALANCER);

            if (amount > available) {
                console.log("Amount", amount / 1e18, "exceeds available", available / 1e18);
                continue;
            }

            console.log("\nTesting flash loan of", amount / 1e18, "WETH");

            address[] memory tokens = new address[](1);
            tokens[0] = WETH;

            uint256[] memory amountsArr = new uint256[](1);
            amountsArr[0] = amount;

            inFlashLoan = true;
            try IBalancerVault(BALANCER).flashLoan(
                address(this),
                tokens,
                amountsArr,
                abi.encode(1)
            ) {
                console.log("SUCCESS with", amount / 1e18, "WETH");
            } catch {
                console.log("FAILED with", amount / 1e18, "WETH");
            }
            inFlashLoan = false;
        }
    }
}
