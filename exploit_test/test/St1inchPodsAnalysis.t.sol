// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface ISt1inch {
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function hasPod(address account, address pod) external view returns (bool);
    function podsCount(address account) external view returns (uint256);
    function pods(address account) external view returns (address[] memory);
    function podBalanceOf(address pod, address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function addPod(address pod) external;
    function removePod(address pod) external;
    function podsLimit() external view returns (uint256);
    function podCallGasLimit() external view returns (uint256);
}

interface IPod {
    function updateBalances(address from, address to, uint256 amount) external;
}

/**
 * @title st1INCH Pods System Deep Analysis
 * @notice Looking for emergent vulnerabilities in the pod notification system
 *
 * PODS SYSTEM STATE MACHINE:
 * 1. Users can add "pods" - external contracts that track their balances
 * 2. On every transfer, all pods of sender/receiver are notified
 * 3. Pods receive: updateBalances(from, to, amount)
 * 4. Notifications are gas-limited and fire-and-forget (results ignored)
 *
 * POTENTIAL ATTACK VECTORS:
 *
 * 1. RETROACTIVE POD ADDITION:
 *    - When user adds a pod, it's notified with their FULL balance as if newly deposited
 *    - If pod distributes rewards based on "time in", adding pod later could game rewards
 *
 * 2. ORDER-DEPENDENT STATE UPDATES:
 *    - Sender's pods notified first, then receiver's pods
 *    - If pods have interdependencies, order matters
 *
 * 3. GAS-LIMITED INCOMPLETE EXECUTION:
 *    - Pods get limited gas (podCallGasLimit)
 *    - Complex pods might have truncated state updates
 *
 * 4. SILENT FAILURE EXPLOITATION:
 *    - Pod failures are silently ignored
 *    - Attacker could manipulate when pods succeed/fail
 */
contract St1inchPodsAnalysisTest is Test {
    // st1INCH token
    address constant ST1INCH = 0x9A0C8Ff858d273f57072D714bca7411D717501D7;

    ISt1inch st1inch;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        st1inch = ISt1inch(ST1INCH);
    }

    function testReadPodsConfig() public view {
        console.log("=== st1INCH PODS CONFIGURATION ===");
        console.log("Contract:", ST1INCH);
        console.log("");

        uint256 totalSupply = st1inch.totalSupply();
        console.log("Total Supply:", totalSupply / 1e18, "st1INCH");

        try st1inch.podsLimit() returns (uint256 limit) {
            console.log("Pods Limit per user:", limit);
        } catch {
            console.log("Could not get podsLimit");
        }

        try st1inch.podCallGasLimit() returns (uint256 gasLimit) {
            console.log("Pod Call Gas Limit:", gasLimit);
            if (gasLimit < 50000) {
                console.log("!!! WARNING: Very low gas limit - pods may fail silently");
            }
        } catch {
            console.log("Could not get podCallGasLimit");
        }

        console.log("=====================================");
    }

    function testAnalyzeExistingPodUsers() public view {
        console.log("");
        console.log("=== ANALYZING USERS WITH PODS ===");

        // Check some known large holders
        address[] memory testAddresses = new address[](5);
        testAddresses[0] = 0x6D2Beb7f91f4d58bF1A18f46D52bBE8B1b6D4CB5; // Random holder
        testAddresses[1] = 0x7951c7ef839e26F63DA87a42C9a87986507f1c07; // Another holder
        testAddresses[2] = address(0x1);
        testAddresses[3] = ST1INCH; // The contract itself
        testAddresses[4] = address(this);

        for (uint i = 0; i < testAddresses.length; i++) {
            address account = testAddresses[i];
            uint256 balance = st1inch.balanceOf(account);

            if (balance > 0) {
                console.log("Account:", account);
                console.log("  Balance:", balance / 1e18);

                try st1inch.podsCount(account) returns (uint256 count) {
                    console.log("  Pod count:", count);

                    if (count > 0) {
                        address[] memory userPods = st1inch.pods(account);
                        for (uint j = 0; j < userPods.length; j++) {
                            console.log("    Pod:", userPods[j]);
                        }
                    }
                } catch {}

                console.log("");
            }
        }

        console.log("==================================");
    }

    function testGasLimitAttackVector() public view {
        console.log("");
        console.log("=== GAS LIMIT ATTACK ANALYSIS ===");

        uint256 gasLimit;
        try st1inch.podCallGasLimit() returns (uint256 gl) {
            gasLimit = gl;
        } catch {
            console.log("Could not get gas limit");
            return;
        }

        console.log("Pod Call Gas Limit:", gasLimit);
        console.log("");

        // Estimate what operations can be done within gas limit
        // SSTORE ~20000 gas, SLOAD ~2100 gas
        uint256 maxSSTOREs = gasLimit / 20000;
        uint256 maxSLOADs = gasLimit / 2100;

        console.log("Estimated max SSTOREs in pod:", maxSSTOREs);
        console.log("Estimated max SLOADs in pod:", maxSLOADs);
        console.log("");

        if (maxSSTOREs < 2) {
            console.log("!!! CRITICAL: Pods can only do ~1 state update");
            console.log("Complex reward distributions would fail silently!");
        }

        console.log("=================================");
    }

    function testPodNotificationOrder() public view {
        console.log("");
        console.log("=== POD NOTIFICATION ORDER ANALYSIS ===");
        console.log("");
        console.log("Notification order in _afterTokenTransfer:");
        console.log("1. Sender's pods notified FIRST (from=sender, to=0 or receiver)");
        console.log("2. Receiver's pods notified SECOND (from=0 or sender, to=receiver)");
        console.log("");
        console.log("IMPLICATION: If pods share state or have dependencies,");
        console.log("the order could affect correctness of accounting.");
        console.log("");
        console.log("ATTACK SCENARIO:");
        console.log("- Attacker creates two pods: A (on sender) and B (on receiver)");
        console.log("- Pod A updates shared state that Pod B reads");
        console.log("- Due to order, Pod A always runs before Pod B");
        console.log("- Could manipulate reward calculations or voting power");
        console.log("========================================");
    }

    function testRetroactiveAddPodAnalysis() public view {
        console.log("");
        console.log("=== RETROACTIVE ADD POD ANALYSIS ===");
        console.log("");
        console.log("When a user calls addPod(pod):");
        console.log("1. Pod is added to user's pod list");
        console.log("2. If user has balance > 0:");
        console.log("   _updateBalances(pod, address(0), user, balance)");
        console.log("");
        console.log("The pod receives notification as if tokens just entered!");
        console.log("");
        console.log("ATTACK SCENARIO:");
        console.log("- Reward pod distributes based on 'staking time'");
        console.log("- User stakes tokens early but WITHOUT the reward pod");
        console.log("- User waits for rewards to accumulate");
        console.log("- User THEN adds the reward pod");
        console.log("- Pod thinks user just staked - gives fresh rewards");
        console.log("");
        console.log("RESULT: User gets rewards without proper staking duration");
        console.log("========================================");
    }

    /**
     * @notice Simulate what happens when a pod is added retroactively
     */
    function testSimulateRetroactiveAddPod() public {
        console.log("");
        console.log("=== SIMULATING RETROACTIVE POD ADD ===");

        // Find a user with st1INCH but no pods
        address user = 0x7951c7ef839e26F63DA87a42C9a87986507f1c07;
        uint256 balance = st1inch.balanceOf(user);

        if (balance == 0) {
            console.log("Test user has no balance, skipping simulation");
            return;
        }

        console.log("User:", user);
        console.log("Balance:", balance / 1e18);

        try st1inch.podsCount(user) returns (uint256 count) {
            console.log("Current pod count:", count);
        } catch {}

        // Deploy a test pod that logs when it receives notifications
        TestPod testPod = new TestPod();
        console.log("Deployed test pod:", address(testPod));

        // Impersonate user and add the pod
        vm.startPrank(user);

        try st1inch.addPod(address(testPod)) {
            console.log("");
            console.log("Successfully added pod!");
            console.log("Pod received notification about existing balance");

            // Check what the pod received
            (address from, address to, uint256 amount) = testPod.lastNotification();
            console.log("Pod notification:");
            console.log("  from:", from);
            console.log("  to:", to);
            console.log("  amount:", amount / 1e18);

            if (from == address(0) && to == user && amount == balance) {
                console.log("");
                console.log("!!! CONFIRMED: Pod received notification as if fresh deposit!");
                console.log("This could be exploited if pod distributes time-based rewards");
            }
        } catch (bytes memory reason) {
            console.log("Could not add pod - user may have reached limit or other issue");
        }

        vm.stopPrank();

        console.log("========================================");
    }
}

/**
 * @notice Test pod that records notifications
 */
contract TestPod is IPod {
    address public lastFrom;
    address public lastTo;
    uint256 public lastAmount;
    uint256 public callCount;

    function updateBalances(address from, address to, uint256 amount) external override {
        lastFrom = from;
        lastTo = to;
        lastAmount = amount;
        callCount++;
    }

    function lastNotification() external view returns (address, address, uint256) {
        return (lastFrom, lastTo, lastAmount);
    }
}
