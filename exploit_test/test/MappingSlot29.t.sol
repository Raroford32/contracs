// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract MappingSlot29 is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_CheckUserMappingAtSlot29() public view {
        console.log("=== CHECKING USER MAPPING AT SLOT 29 ===\n");

        // If slot 29 is a mapping(address => address), the actual storage is at:
        // keccak256(abi.encode(user, 29))

        bytes32 attackerSlot = keccak256(abi.encode(attacker, uint256(29)));
        bytes32 attackerVal = vm.load(REDEMPTION_0, attackerSlot);
        console.log("Mapping[attacker] at slot 29:");
        console.logBytes32(attackerVal);

        // Try different key encodings
        bytes32 slot2 = keccak256(abi.encode(uint256(29), attacker));
        bytes32 val2 = vm.load(REDEMPTION_0, slot2);
        console.log("\nMapping[29][attacker]:");
        console.logBytes32(val2);

        // Check for known user
        address knownUser = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e; // Timelock
        bytes32 knownSlot = keccak256(abi.encode(knownUser, uint256(29)));
        bytes32 knownVal = vm.load(REDEMPTION_0, knownSlot);
        console.log("\nMapping[timelock] at slot 29:");
        console.logBytes32(knownVal);
    }

    function test_FindUserProxyMechanism() public view {
        console.log("=== FINDING USER PROXY MECHANISM ===\n");

        // Search for where user proxies are stored
        // Check different mapping slots

        for (uint slot = 0; slot < 40; slot++) {
            bytes32 key = keccak256(abi.encode(attacker, slot));
            bytes32 val = vm.load(REDEMPTION_0, key);
            if (val != bytes32(0)) {
                console.log("Non-zero at mapping slot", slot);
                console.logBytes32(val);
            }
        }
    }

    function test_CheckIfRedeemCreatesProxy() public {
        console.log("=== CHECKING IF REDEEM CREATES PROXY ===\n");

        // Maybe calling redeem creates a proxy for the user

        vm.startPrank(attacker);
        deal(TASSET, attacker, 10000e18);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        // Check storage before redeem
        console.log("Checking storage before redeem:");
        for (uint slot = 0; slot < 40; slot++) {
            bytes32 key = keccak256(abi.encode(attacker, slot));
            bytes32 val = vm.load(REDEMPTION_0, key);
            if (val != bytes32(0)) {
                console.log("  Mapping[attacker, slot", slot, "]:");
                console.logBytes32(val);
            }
        }

        // Redeem
        (bool s1,) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("\nredeem:", s1);

        // Check storage after redeem
        console.log("\nChecking storage after redeem:");
        for (uint slot = 0; slot < 40; slot++) {
            bytes32 key = keccak256(abi.encode(attacker, slot));
            bytes32 val = vm.load(REDEMPTION_0, key);
            if (val != bytes32(0)) {
                console.log("  Mapping[attacker, slot", slot, "]:");
                console.logBytes32(val);
                
                address addr = address(uint160(uint256(val)));
                if (addr.code.length > 0) {
                    console.log("    -> Contract:", addr);
                }
            }
        }

        vm.stopPrank();
    }

    function test_TraceFinalizeRedeemCALLs() public {
        console.log("=== TRACING FINALIZEREDEEM CALLS ===\n");

        vm.startPrank(attacker);
        deal(TASSET, attacker, 10000e18);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        // Create redemption
        REDEMPTION_0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        vm.warp(block.timestamp + 7 days);

        // Record calls during finalizeRedeem
        vm.recordLogs();
        
        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("finalizeRedeem:", s1);

        Vm.Log[] memory logs = vm.getRecordedLogs();
        console.log("\nEvents emitted:", logs.length);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_ExamineRedeedMappingStructure() public view {
        console.log("=== EXAMINING REDEMPTION MAPPING STRUCTURE ===\n");

        // Maybe redemptions are stored in a struct at a mapping
        // struct RedemptionRequest { uint256 amount; address recipient; uint256 timestamp; ... }

        // Check slots 5-15 for mapping patterns
        console.log("Checking R0 slots 5-20 for redemption data:");
        for (uint i = 5; i < 20; i++) {
            bytes32 rawSlot = vm.load(REDEMPTION_0, bytes32(i));
            if (rawSlot != bytes32(0)) {
                console.log("Slot", i);
                console.logBytes32(rawSlot);

                // Try as mapping with attacker key
                bytes32 mapKey = keccak256(abi.encode(attacker, i));
                bytes32 mapVal = vm.load(REDEMPTION_0, mapKey);
                if (mapVal != bytes32(0)) {
                    console.log("  Mapping[attacker]:");
                    console.logBytes32(mapVal);
                }
            }
        }
    }
}
