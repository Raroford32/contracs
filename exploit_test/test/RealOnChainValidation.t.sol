// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Real On-Chain Exploit Validation
 * @notice Validate sUSDe/DAI Morpho exploit with REAL numbers
 */

interface IMorphoBlue {
    struct MarketParams {
        address loanToken;
        address collateralToken;
        address oracle;
        address irm;
        uint256 lltv;
    }

    struct Market {
        uint128 totalSupplyAssets;
        uint128 totalSupplyShares;
        uint128 totalBorrowAssets;
        uint128 totalBorrowShares;
        uint128 lastUpdate;
        uint128 fee;
    }

    function market(bytes32 id) external view returns (Market memory);
    function idToMarketParams(bytes32 id) external view returns (MarketParams memory);
}

interface IMorphoOracle {
    function price() external view returns (uint256);
}

interface IChainlinkOracle {
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint256);
}

interface ISUSDe {
    function convertToAssets(uint256 shares) external view returns (uint256);
    function convertToShares(uint256 assets) external view returns (uint256);
    function totalAssets() external view returns (uint256);
}

interface ICurvePoolInt {
    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);
    function coins(uint256 i) external view returns (address);
    function balances(uint256 i) external view returns (uint256);
}

interface ICurvePoolUint {
    function get_dy(uint256 i, uint256 j, uint256 dx) external view returns (uint256);
}

interface IUniswapQuoter {
    function quoteExactInputSingle(
        address tokenIn,
        address tokenOut,
        uint24 fee,
        uint256 amountIn,
        uint160 sqrtPriceLimitX96
    ) external returns (uint256 amountOut);
}

contract RealOnChainValidation is Test {
    // Core addresses
    address constant MORPHO_BLUE = 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb;
    address constant SUSDE = 0x9D39A5DE30e57443BfF2A8307A4256c8797A3497;
    address constant USDE = 0x4c9EDD5852cd905f086C759E8383e09bff1E68B3;
    address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    // Oracles
    address constant USDE_CHAINLINK = 0xa569d910839Ae8865Da8F8e70FfFb0cBA869F961;

    // DEX
    address constant CURVE_USDE_DAI = 0xF36a4BA50C603204c3FC6d2dA8b78A7b69CBC67d;
    address constant CURVE_USDE_USDC = 0x02950460E2b9529D0E00284A5fA2d7bDF3fA4d72;
    address constant UNISWAP_QUOTER = 0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6;

    // Target market
    bytes32 constant MARKET_ID = 0x1247f1c237eceae0602eab1470a5061a6dd8f734ba88c7cdc5d6109fb0026b28;

    // Flash loan sources
    address constant BALANCER = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address constant AAVE_V3 = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    address constant SPARK = 0xC13e21B648A5Ee794902342038FF3aDAB66BE987;

    string constant RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    function setUp() public {
        vm.createSelectFork(RPC_URL);
    }

    function test_RealOracleData() public view {
        console.log("========================================");
        console.log("   REAL ON-CHAIN ORACLE DATA");
        console.log("========================================\n");

        // Get Chainlink USDe/USD
        IChainlinkOracle chainlink = IChainlinkOracle(USDE_CHAINLINK);
        (uint80 roundId, int256 oraclePrice,, uint256 updatedAt,) = chainlink.latestRoundData();

        uint256 staleness = block.timestamp - updatedAt;

        console.log("CHAINLINK USDe/USD ORACLE:");
        console.log("  Address:", USDE_CHAINLINK);
        console.log("  Round ID:", roundId);
        console.log("  Price (8 decimals):", uint256(oraclePrice));
        console.log("  Price in USD: $", uint256(oraclePrice) * 100 / 1e8, "/ 100");
        console.log("  Last Update:", updatedAt);
        console.log("  Current Time:", block.timestamp);
        console.log("  Staleness (seconds):", staleness);
        console.log("  Staleness (minutes):", staleness / 60);
        console.log("  Staleness (hours):", staleness / 3600);
    }

    function test_RealMorphoMarketData() public view {
        console.log("========================================");
        console.log("   REAL MORPHO MARKET DATA");
        console.log("========================================\n");

        IMorphoBlue morpho = IMorphoBlue(MORPHO_BLUE);
        IMorphoBlue.Market memory m = morpho.market(MARKET_ID);
        IMorphoBlue.MarketParams memory params = morpho.idToMarketParams(MARKET_ID);

        console.log("MARKET: sUSDe/DAI");
        console.log("  Market ID:", vm.toString(MARKET_ID));
        console.log("");
        console.log("PARAMETERS:");
        console.log("  Loan Token (DAI):", params.loanToken);
        console.log("  Collateral (sUSDe):", params.collateralToken);
        console.log("  Oracle:", params.oracle);
        console.log("  LLTV (18 decimals):", params.lltv);
        console.log("  LLTV (%):", params.lltv * 100 / 1e18);

        console.log("");
        console.log("LIQUIDITY:");
        console.log("  Total Supply (DAI):", m.totalSupplyAssets);
        console.log("  Total Supply (DAI readable):", m.totalSupplyAssets / 1e18);
        console.log("  Total Borrow (DAI):", m.totalBorrowAssets);
        console.log("  Total Borrow (DAI readable):", m.totalBorrowAssets / 1e18);

        uint256 available = m.totalSupplyAssets - m.totalBorrowAssets;
        console.log("  AVAILABLE TO BORROW:", available / 1e18, "DAI");

        // Get Morpho oracle price
        console.log("");
        console.log("MORPHO ORACLE:");
        try IMorphoOracle(params.oracle).price() returns (uint256 morphoPrice) {
            console.log("  Raw Price (36 decimals):", morphoPrice);
            // Morpho oracle returns price of collateral in loan token terms
            // price = collateral_value / loan_value * 1e36
            console.log("  Implied: 1 sUSDe =", morphoPrice / 1e36, "DAI (approx)");
        } catch {
            console.log("  Could not fetch Morpho oracle price");
        }
    }

    function test_RealSUSDeExchangeRate() public view {
        console.log("========================================");
        console.log("   REAL sUSDe EXCHANGE RATE");
        console.log("========================================\n");

        ISUSDe susde = ISUSDe(SUSDE);

        uint256 totalAssets = susde.totalAssets();
        uint256 totalShares = IERC20(SUSDE).totalSupply();

        console.log("sUSDe VAULT:");
        console.log("  Total Assets (USDe):", totalAssets / 1e18);
        console.log("  Total Shares (sUSDe):", totalShares / 1e18);

        // Exchange rate
        uint256 assetsFor1Share = susde.convertToAssets(1e18);
        console.log("");
        console.log("EXCHANGE RATE:");
        console.log("  1 sUSDe =", assetsFor1Share, "USDe (18 decimals)");
        console.log("  1 sUSDe =", assetsFor1Share * 100 / 1e18, "/ 100 USDe");

        // This means sUSDe is worth MORE than USDe due to yield
        uint256 premiumBps = (assetsFor1Share - 1e18) * 10000 / 1e18;
        console.log("  sUSDe Premium:", premiumBps, "bps over USDe");
    }

    function test_RealDEXPrices() public view {
        console.log("========================================");
        console.log("   REAL DEX PRICES");
        console.log("========================================\n");

        // Try multiple Curve pools
        console.log("Attempting to get real DEX prices...\n");

        // Check USDe/USDC pool
        address[] memory pools = new address[](3);
        pools[0] = 0x02950460E2b9529D0E00284A5fA2d7bDF3fA4d72; // USDe/USDC
        pools[1] = 0xF36a4BA50C603204c3FC6d2dA8b78A7b69CBC67d; // USDe/DAI
        pools[2] = 0x5dc1BF6f1e983C0b21EfB003c105133736fA0743; // Another pool

        for (uint i = 0; i < pools.length; i++) {
            _checkCurvePool(pools[i], i);
        }

        // Check USDe balance in various places to understand liquidity
        console.log("\nUSDe LIQUIDITY LOCATIONS:");
        console.log("  In Morpho Blue:", IERC20(USDE).balanceOf(MORPHO_BLUE) / 1e18);
        console.log("  In Curve Pool 1:", IERC20(USDE).balanceOf(pools[0]) / 1e18);
    }

    function _checkCurvePool(address pool, uint256 index) internal view {
        console.log("Pool", index, ":", pool);

        // Check if pool has USDe
        uint256 usdeBalance = IERC20(USDE).balanceOf(pool);
        if (usdeBalance == 0) {
            console.log("  No USDe in this pool\n");
            return;
        }

        console.log("  USDe Balance:", usdeBalance / 1e18);

        // Try int128 signature (most Curve pools use this)
        try ICurvePoolInt(pool).get_dy(int128(0), int128(1), 1000e18) returns (uint256 out) {
            console.log("  1000 USDe ->", out / 1e6, "USDC");
            console.log("  Implied USDe price: $", out * 1000 / 1000e6, "/ 1000");
        } catch {
            // Try uint256 signature
            try ICurvePoolUint(pool).get_dy(0, 1, 1000e18) returns (uint256 out) {
                console.log("  1000 USDe -> ", out, "of token1");
                console.log("  Implied price: $", out * 1000 / 1000e18, "/ 1000");
            } catch {
                console.log("  Could not query price");
            }
        }
        console.log("");
    }

    function test_RealFlashLoanSources() public view {
        console.log("========================================");
        console.log("   REAL FLASH LOAN SOURCES");
        console.log("========================================\n");

        console.log("sUSDe AVAILABILITY:");
        console.log("  Balancer Vault:", IERC20(SUSDE).balanceOf(BALANCER) / 1e18, "sUSDe");
        console.log("  Morpho Blue:", IERC20(SUSDE).balanceOf(MORPHO_BLUE) / 1e18, "sUSDe");

        console.log("\nUSDe AVAILABILITY:");
        console.log("  Balancer Vault:", IERC20(USDE).balanceOf(BALANCER) / 1e18, "USDe");
        console.log("  Morpho Blue:", IERC20(USDE).balanceOf(MORPHO_BLUE) / 1e18, "USDe");

        console.log("\nDAI AVAILABILITY (for comparison):");
        console.log("  Balancer Vault:", IERC20(DAI).balanceOf(BALANCER) / 1e18, "DAI");

        // Total sUSDe supply
        console.log("\nTOTAL sUSDe SUPPLY:", IERC20(SUSDE).totalSupply() / 1e18);
    }

    function test_ExactExploitCalculation() public view {
        console.log("========================================");
        console.log("   EXACT EXPLOIT PROFIT CALCULATION");
        console.log("========================================\n");

        // Get all real data
        IMorphoBlue morpho = IMorphoBlue(MORPHO_BLUE);
        IMorphoBlue.Market memory m = morpho.market(MARKET_ID);
        IMorphoBlue.MarketParams memory params = morpho.idToMarketParams(MARKET_ID);

        // Get oracle price
        (, int256 chainlinkPrice,, uint256 updatedAt,) = IChainlinkOracle(USDE_CHAINLINK).latestRoundData();
        uint256 staleness = block.timestamp - updatedAt;

        // Get sUSDe exchange rate
        uint256 susdeToUsde = ISUSDe(SUSDE).convertToAssets(1e18);

        // Available liquidity
        uint256 availableDAI = m.totalSupplyAssets - m.totalBorrowAssets;

        console.log("CURRENT STATE:");
        console.log("  Oracle USDe price: $", uint256(chainlinkPrice) * 100 / 1e8, "/ 100");
        console.log("  Oracle staleness:", staleness / 3600, "hours");
        console.log("  sUSDe -> USDe rate:", susdeToUsde * 100 / 1e18, "/ 100");
        console.log("  LLTV:", params.lltv * 100 / 1e18, "%");
        console.log("  Available DAI:", availableDAI / 1e18);

        // Calculate implied sUSDe value according to Morpho
        // 1 sUSDe = susdeToUsde USDe
        // 1 USDe = chainlinkPrice USD (according to oracle)
        uint256 oracleSUSDeValueUSD = susdeToUsde * uint256(chainlinkPrice) / 1e8;

        console.log("\nIMPLIED VALUES (from oracle):");
        console.log("  1 sUSDe = ", oracleSUSDeValueUSD * 100 / 1e18, "/ 100 USD");

        // Calculate max borrow
        // At 91.5% LLTV, for every $1 of collateral, can borrow $0.915
        uint256 lltv = params.lltv;

        console.log("\nEXPLOIT SCENARIOS:");
        console.log("(Assuming we have sUSDe to deposit)\n");

        // Scenario: Deposit $100k worth of sUSDe
        uint256 depositValueUSD = 100_000e18; // $100k

        // sUSDe needed (at oracle valuation)
        uint256 susdeNeeded = depositValueUSD * 1e18 / oracleSUSDeValueUSD;

        // Max borrow at LLTV
        uint256 maxBorrowDAI = depositValueUSD * lltv / 1e18;

        console.log("IF DEPOSIT $100,000 WORTH (at oracle price):");
        console.log("  sUSDe needed:", susdeNeeded / 1e18);
        console.log("  Max borrow (91.5% LLTV):", maxBorrowDAI / 1e18, "DAI");

        // Now calculate at different real price scenarios
        console.log("\nPROFIT AT DIFFERENT REAL PRICES:");
        console.log("(Oracle shows $0.999, what if real price is lower?)\n");

        _calculateProfit(depositValueUSD, susdeNeeded, maxBorrowDAI, 0); // 0% divergence
        _calculateProfit(depositValueUSD, susdeNeeded, maxBorrowDAI, 500); // 5% divergence
        _calculateProfit(depositValueUSD, susdeNeeded, maxBorrowDAI, 800); // 8% divergence
        _calculateProfit(depositValueUSD, susdeNeeded, maxBorrowDAI, 1000); // 10% divergence
        _calculateProfit(depositValueUSD, susdeNeeded, maxBorrowDAI, 1500); // 15% divergence
        _calculateProfit(depositValueUSD, susdeNeeded, maxBorrowDAI, 2000); // 20% divergence
    }

    function _calculateProfit(
        uint256 oracleValueUSD,
        uint256 susdeAmount,
        uint256 borrowedDAI,
        uint256 divergenceBps
    ) internal pure {
        // Real value = oracle value * (1 - divergence)
        uint256 realValueUSD = oracleValueUSD * (10000 - divergenceBps) / 10000;

        // Profit = borrowed - real collateral value
        int256 profit;
        if (borrowedDAI > realValueUSD) {
            profit = int256(borrowedDAI - realValueUSD);
        } else {
            profit = -int256(realValueUSD - borrowedDAI);
        }

        console.log("  At", divergenceBps / 100, "% divergence:");
        console.log("    Real collateral value: $", realValueUSD / 1e18);
        console.log("    Borrowed: $", borrowedDAI / 1e18, "DAI");

        if (profit > 0) {
            console.log("    PROFIT: $", uint256(profit) / 1e18);
        } else {
            console.log("    LOSS: $", uint256(-profit) / 1e18);
        }
        console.log("");
    }

    function test_FinalVerdict() public view {
        console.log("========================================");
        console.log("   FINAL EXPLOIT VERDICT");
        console.log("========================================\n");

        // Get current state
        (, int256 chainlinkPrice,, uint256 updatedAt,) = IChainlinkOracle(USDE_CHAINLINK).latestRoundData();
        uint256 staleness = block.timestamp - updatedAt;

        IMorphoBlue morpho = IMorphoBlue(MORPHO_BLUE);
        IMorphoBlue.Market memory m = morpho.market(MARKET_ID);

        uint256 availableDAI = m.totalSupplyAssets - m.totalBorrowAssets;
        uint256 balancerSUSDe = IERC20(SUSDE).balanceOf(BALANCER);

        console.log("CONDITION CHECK:");
        console.log("");

        // Condition 1: Oracle staleness
        bool staleCond = staleness > 3600;
        console.log("1. Oracle Stale (>1hr)?");
        console.log("   Staleness:", staleness / 3600, "hours");
        console.log("   Status:", staleCond ? "YES - CONDITION MET" : "NO");
        console.log("");

        // Condition 2: Price divergence
        // We'd need to check DEX price, but oracle shows $0.999
        console.log("2. Price Divergence >8%?");
        console.log("   Oracle price: $", uint256(chainlinkPrice) * 100 / 1e8, "/ 100");
        console.log("   Required: DEX price < $0.92");
        console.log("   Status: NEED TO CHECK DEX - oracle hasn't moved");
        console.log("");

        // Condition 3: Liquidity
        bool liqCond = availableDAI > 10000e18;
        console.log("3. Sufficient Target Liquidity?");
        console.log("   Available DAI:", availableDAI / 1e18);
        console.log("   Status:", liqCond ? "YES - CONDITION MET" : "NO");
        console.log("");

        // Condition 4: Flash loan source
        bool flashCond = balancerSUSDe > 100000e18;
        console.log("4. Flash Loan Source Available?");
        console.log("   Balancer sUSDe:", balancerSUSDe / 1e18);
        console.log("   Status:", flashCond ? "YES" : "NO - INSUFFICIENT");
        console.log("");

        console.log("========================================");
        console.log("VERDICT:");
        console.log("");

        if (staleCond && liqCond) {
            console.log("VULNERABILITY EXISTS but NOT YET EXPLOITABLE");
            console.log("");
            console.log("BLOCKING FACTORS:");
            console.log("1. USDe price stable (~$0.999) - no divergence");
            console.log("2. Limited flash loan sources for sUSDe");
            console.log("");
            console.log("WOULD BE EXPLOITABLE IF:");
            console.log("- USDe depegs to <$0.92 while oracle stale");
            console.log("- OR find alternative sUSDe source ($500k+)");
        } else {
            console.log("CONDITIONS NOT MET FOR EXPLOIT");
        }

        console.log("========================================");
    }
}
