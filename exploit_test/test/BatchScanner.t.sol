// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Batch Scanner
 * @notice Scan batch of contracts for high value and exploitable functions
 */
contract BatchScannerTest is Test {

    address WETH;
    address USDC;
    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        WETH = vm.parseAddress("0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2");
        USDC = vm.parseAddress("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48");
        attacker = address(0xBEEF);
        vm.deal(attacker, 10 ether);
    }

    function test_scanBatch400to420() public {
        console.log("=== SCANNING BATCH 400-420 ===");

        address[] memory targets = new address[](20);
        targets[0] = vm.parseAddress("0x4db5d5244721ff3663d03142cfa09b55451be06e");
        targets[1] = vm.parseAddress("0xb548a9d3e8a3fbd821bd52fb915d752bdc8cf679");
        targets[2] = vm.parseAddress("0x90d2af7d622ca3141efa4d8f1f24d86e5974cc8f");
        targets[3] = vm.parseAddress("0x09e8d50ca343c840aa50f573947712501f03d8b8");
        targets[4] = vm.parseAddress("0xa7496763f035e73ec6b56f4c86312cc1874a01e3");
        targets[5] = vm.parseAddress("0xe71d0580fd9bb5fe0cc8e17f689ef9d26a30df3a");
        targets[6] = vm.parseAddress("0x06378717d86b8cd2dba58c87383da1eda92d3495");
        targets[7] = vm.parseAddress("0xb5a58db25eedefeede888f55d6157e13d4b4f4f8");
        targets[8] = vm.parseAddress("0x080b3a41390b357ad7e8097644d1dedf57ad3375");
        targets[9] = vm.parseAddress("0xbcbc8cb4d1e8ed048a6276a5e94a3e952660bcbc");
        targets[10] = vm.parseAddress("0xdcef968d416a41cdac0ed8702fac8128a64241a2");
        targets[11] = vm.parseAddress("0x38e4254bd82ed5ee97cd1c4278faae748d998865");
        targets[12] = vm.parseAddress("0x5a70b1bb9588f5f51a0ea6dc86d72a9c04941a8f");
        targets[13] = vm.parseAddress("0x3ee1bea3a10f7508b76219f109ebe19419b3dd85");
        targets[14] = vm.parseAddress("0xa004dd9439c2cf00794786c9662267bee6d9f723");
        targets[15] = vm.parseAddress("0xa600ec7db69dfcd21f19face5b209a55eab7a7c0");
        targets[16] = vm.parseAddress("0x54945180db7943c0ed0fee7edab2bd24620256bc");
        targets[17] = vm.parseAddress("0xb01bc9679bb5c01ad4900db9cb452f986af367ba");
        targets[18] = vm.parseAddress("0xd7e4b67e735733ac98a88f13d087d8aac670e644");
        targets[19] = vm.parseAddress("0x35009e41121ffebaa412e4c257d5634daf8bf0b1");

        for (uint i = 0; i < targets.length; i++) {
            _scanTarget(targets[i]);
        }
    }

    function test_scanBatch500to520() public {
        console.log("=== SCANNING BATCH 500-520 ===");

        address[] memory targets = new address[](20);
        targets[0] = vm.parseAddress("0x3f69bb14860f7f3348ac8a5f0d445322143f7fee");
        targets[1] = vm.parseAddress("0x2aa5d15eb36e5960d056e8fea6e7bb3e2a06a351");
        targets[2] = vm.parseAddress("0x20e4d327573158743fcf1f624b4df90d1ea2cb04");
        targets[3] = vm.parseAddress("0x3b95bc951ee0f553ba487327278cac44f29715e5");
        targets[4] = vm.parseAddress("0xfe3240995c771f10d2583e8fa95f92ee40e15150");
        targets[5] = vm.parseAddress("0x27d64dd9172e4b59a444817d30f7af8228f174cc");
        targets[6] = vm.parseAddress("0x3d0403c5471c57a723c41140bb4d968331d6e678");
        targets[7] = vm.parseAddress("0x41ee965f5d3ccc914e2e18c5319b75b91577a5fd");
        targets[8] = vm.parseAddress("0xd57d30d06969e5a98516e9f8d009c6f39ec169ee");
        targets[9] = vm.parseAddress("0x8b34b14c7c7123459cf3076b8cb929be097d0c07");
        targets[10] = vm.parseAddress("0x08341befe6428568cdf798d19223821697dcec15");
        targets[11] = vm.parseAddress("0x8a30d684b1d3f8f36b36887a3deca0ef2a36a8e3");
        targets[12] = vm.parseAddress("0x162d38ef490906bfa6d8e5f6fc09326a1d588f49");
        targets[13] = vm.parseAddress("0x330732581d30076137a1159b3ae8780158d902be");
        targets[14] = vm.parseAddress("0xcc9691be0b06f98803585c308d20aa0497dac88c");
        targets[15] = vm.parseAddress("0x66a28b080918184851774a89ab94850a41f6a1e5");
        targets[16] = vm.parseAddress("0x77b2043768d28e9c9ab44e1abfc95944bce57931");
        targets[17] = vm.parseAddress("0x9084b5a98e3b4b257affd82ae4a1753f87906dce");
        targets[18] = vm.parseAddress("0x4f14e88b5037f0ca24348fa707e4a7ee5318d9d5");
        targets[19] = vm.parseAddress("0x4f8ad938eba0cd19155a835f617317a6e788c868");

        for (uint i = 0; i < targets.length; i++) {
            _scanTarget(targets[i]);
        }
    }

    function _scanTarget(address target) internal {
        // Check if has code
        uint256 codeSize;
        assembly {
            codeSize := extcodesize(target)
        }
        if (codeSize == 0) return;

        uint256 ethBal = target.balance;

        // Check WETH
        (bool s, bytes memory d) = WETH.staticcall(
            abi.encodeWithSignature("balanceOf(address)", target)
        );
        uint256 wethBal;
        if (s && d.length >= 32) {
            wethBal = abi.decode(d, (uint256));
        }

        // Check USDC
        (s, d) = USDC.staticcall(
            abi.encodeWithSignature("balanceOf(address)", target)
        );
        uint256 usdcBal;
        if (s && d.length >= 32) {
            usdcBal = abi.decode(d, (uint256));
        }

        // Only report if has value
        if (ethBal > 0.1 ether || wethBal > 0.1 ether || usdcBal > 100e6) {
            console.log("");
            console.log("TARGET:", target);
            if (ethBal > 0) console.log("  ETH:", ethBal / 1e18);
            if (wethBal > 0) console.log("  WETH:", wethBal / 1e18);
            if (usdcBal > 0) console.log("  USDC:", usdcBal / 1e6);

            // Try some exploit functions
            vm.startPrank(attacker);

            (s,) = target.call(abi.encodeWithSignature("withdraw()"));
            if (s) console.log("  withdraw() SUCCEEDED");

            (s,) = target.call(abi.encodeWithSignature("claim()"));
            if (s) console.log("  claim() SUCCEEDED");

            (s,) = target.call(abi.encodeWithSignature("emergencyWithdraw()"));
            if (s) console.log("  emergencyWithdraw() SUCCEEDED");

            vm.stopPrank();
        }
    }

    function test_deepScanCurve() public {
        // 0xdcef968d416a41cdac0ed8702fac8128a64241a2 - potentially Curve related
        address target = vm.parseAddress("0xdcef968d416a41cdac0ed8702fac8128a64241a2");

        console.log("=== CURVE POOL ANALYSIS ===");
        console.log("Target:", target);

        uint256 ethBal = target.balance;
        console.log("ETH:", ethBal / 1e18);

        // Check USDC balance
        (bool s, bytes memory d) = USDC.staticcall(
            abi.encodeWithSignature("balanceOf(address)", target)
        );
        if (s && d.length >= 32) {
            console.log("USDC:", abi.decode(d, (uint256)) / 1e6);
        }

        // Check WETH balance
        (s, d) = WETH.staticcall(
            abi.encodeWithSignature("balanceOf(address)", target)
        );
        if (s && d.length >= 32) {
            console.log("WETH:", abi.decode(d, (uint256)) / 1e18);
        }

        // Try to get coins
        (s, d) = target.staticcall(abi.encodeWithSignature("coins(uint256)", 0));
        if (s && d.length >= 32) {
            address coin0 = abi.decode(d, (address));
            console.log("Coin 0:", coin0);
        }

        (s, d) = target.staticcall(abi.encodeWithSignature("coins(uint256)", 1));
        if (s && d.length >= 32) {
            address coin1 = abi.decode(d, (address));
            console.log("Coin 1:", coin1);
        }
    }
}
