// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

contract TAssetDeepDive is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    // TASSET address - key discovery!
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeTAssetContract() public view {
        console.log("=== ANALYZING TASSET CONTRACT ===\n");

        console.log("TASSET address:", TASSET);
        console.log("Code size:", TASSET.code.length);

        // Dump bytecode
        bytes memory code = TASSET.code;
        console.log("\nTASSET bytecode (first 100 bytes):");

        for (uint i = 0; i < 100 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            string memory opName = "";
            if (op == 0x00) opName = "STOP";
            else if (op == 0x36) opName = "CALLDATASIZE";
            else if (op == 0x37) opName = "CALLDATACOPY";
            else if (op == 0x3d) opName = "RETURNDATASIZE";
            else if (op == 0x3e) opName = "RETURNDATACOPY";
            else if (op == 0x54) opName = "SLOAD";
            else if (op == 0x55) opName = "SSTORE";
            else if (op == 0xf1) opName = "CALL";
            else if (op == 0xf3) opName = "RETURN";
            else if (op == 0xf4) opName = "DELEGATECALL";
            else if (op == 0xfd) opName = "REVERT";
            else if (op == 0x5b) opName = "JUMPDEST";

            if (bytes(opName).length > 0) {
                console.log(i, opName);
            }

            if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                console.log(i, "PUSH val:", val);
                i += size;
            }
        }

        // Check TASSET storage
        console.log("\nTASSET storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(TASSET, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }
    }

    function test_TAssetFunctions() public {
        console.log("=== TRYING TASSET FUNCTIONS ===\n");

        // Try various functions on TASSET

        // Standard ERC20
        (bool s1, bytes memory d1) = TASSET.staticcall(
            abi.encodeWithSignature("name()")
        );
        if (s1) {
            console.log("name():", string(abi.decode(d1, (string))));
        }

        (bool s2, bytes memory d2) = TASSET.staticcall(
            abi.encodeWithSignature("symbol()")
        );
        if (s2) {
            console.log("symbol():", string(abi.decode(d2, (string))));
        }

        (bool s3, bytes memory d3) = TASSET.staticcall(
            abi.encodeWithSignature("decimals()")
        );
        if (s3) {
            console.log("decimals():", abi.decode(d3, (uint8)));
        }

        (bool s4, bytes memory d4) = TASSET.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        if (s4) {
            console.log("totalSupply():", abi.decode(d4, (uint256)));
        }

        // Check if proxy
        (bool s5, bytes memory d5) = TASSET.staticcall(
            abi.encodeWithSignature("implementation()")
        );
        if (s5 && d5.length >= 32) {
            console.log("implementation():", abi.decode(d5, (address)));
        }

        // Owner/admin
        (bool s6, bytes memory d6) = TASSET.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (s6 && d6.length >= 32) {
            console.log("owner():", abi.decode(d6, (address)));
        }

        // Try calling with attacker
        vm.startPrank(attacker);

        console.log("\nTrying functions as attacker:");

        (bool t1,) = TASSET.call(
            abi.encodeWithSignature("mint(address,uint256)", attacker, 1000e18)
        );
        console.log("mint:", t1);

        (bool t2,) = TASSET.call(
            abi.encodeWithSignature("burn(uint256)", 1e18)
        );
        console.log("burn:", t2);

        (bool t3,) = TASSET.call(
            abi.encodeWithSignature("transfer(address,uint256)", attacker, 1e18)
        );
        console.log("transfer:", t3);

        vm.stopPrank();
    }

    function test_TraceRCRedeemRecipient() public view {
        console.log("=== TRACING RC.REDEEM RECIPIENT IN REDEMPTION_0 ===\n");

        // RC.redeem is at offset 5011 in REDEMPTION_0
        // CALL is at offset 5046
        // We need to understand what "to" address is passed

        bytes memory code = REDEMPTION_0.code;

        // Look at bytecode from offset 4950 to 5100
        console.log("Bytecode around RC.redeem call (4950-5100):");

        for (uint i = 4950; i < 5100 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0xf1) console.log(i, "CALL");
            if (op == 0x33) console.log(i, "CALLER");
            if (op == 0x32) console.log(i, "ORIGIN");
            if (op == 0x3d) console.log(i, "RETURNDATASIZE");
            if (op == 0x35) console.log(i, "CALLDATALOAD");
            if (op == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                console.log(i, "PUSH4:");
                console.logBytes4(sel);
            }
            if (op == 0x73) {
                // PUSH20 - hardcoded address
                address addr;
                bytes memory addrBytes = new bytes(20);
                for (uint j = 0; j < 20 && i + 1 + j < code.length; j++) {
                    addrBytes[j] = code[i + 1 + j];
                }
                assembly {
                    addr := mload(add(addrBytes, 20))
                }
                console.log(i, "PUSH20:", addr);
            }
            if (op >= 0x60 && op <= 0x65) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                console.log(i, "PUSH val:", val);
            }
        }
    }

    function test_WhoCalls_FinalizeRedeem() public view {
        console.log("=== FINDING FINALIZE REDEEM CALLER PATH ===\n");

        // The flow is:
        // User -> REDEMPTION.finalizeRedeem(index) -> RC.redeem(amount, TO)
        //
        // What is TO?
        // - Could be msg.sender (the user who called finalizeRedeem)
        // - Could be a storage value (recipient from redeem request)
        // - Could be hardcoded

        bytes memory code = REDEMPTION_0.code;

        // Search for finalizeRedeem selector: 0xaff6cbf1
        bytes4 finalizeSel = bytes4(keccak256("finalizeRedeem(uint256)"));
        console.log("finalizeRedeem selector:");
        console.logBytes4(finalizeSel);

        console.log("\nSearching for finalizeRedeem entry point:");
        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == finalizeSel) {
                    console.log("  Found at offset:", i);

                    // Find the JUMPI after this (branch to function)
                    for (uint j = i; j < i + 30 && j < code.length; j++) {
                        if (uint8(code[j]) == 0x57) { // JUMPI
                            console.log("  JUMPI at:", j);
                            break;
                        }
                    }
                }
            }
        }
    }

    function test_AnalyzeRedemptionRequest() public {
        console.log("=== ANALYZING REDEMPTION REQUEST STRUCTURE ===\n");

        // When user calls redeem(amount), a RedemptionRequest struct is stored
        // Later finalizeRedeem reads this struct

        // The struct probably contains:
        // - amount
        // - timestamp
        // - recipient (THIS IS KEY!)
        // - finalized flag

        // If recipient is user-provided or msg.sender, then
        // the final wstETH goes to the user, not exploitable.

        // BUT if there's a way to:
        // 1. Create a redemption request with OUR address as recipient
        // 2. Have someone else finalize it
        // Then we could drain!

        // Let's try creating a redemption as attacker
        vm.startPrank(attacker);

        // Give attacker IAU tokens to redeem
        deal(IAU, attacker, 1000e18);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        console.log("Attacker IAU balance:", IERC20(IAU).balanceOf(attacker));

        // Try to redeem
        (bool s, bytes memory d) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("redeem(100e18):", s);
        if (!s && d.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(d));
        }

        vm.stopPrank();

        // Check if redemption was created
        (bool s2, bytes memory d2) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("getRedeemLength(address)", attacker)
        );
        if (s2) {
            uint256 len = abi.decode(d2, (uint256));
            console.log("Attacker pending redeems:", len);

            if (len > 0) {
                // Get redemption info
                (bool s3, bytes memory d3) = REDEMPTION_0.staticcall(
                    abi.encodeWithSignature("getRedeemInfo(address,uint256)", attacker, len - 1)
                );
                if (s3) {
                    (uint96 amt, uint64 ts, bool fin) = abi.decode(d3, (uint96, uint64, bool));
                    console.log("  Amount:", amt);
                    console.log("  Timestamp:", ts);
                    console.log("  Finalized:", fin);
                }
            }
        }
    }

    function test_CheckRedemption0ForUserRecipient() public view {
        console.log("=== CHECKING IF USER CAN SET RECIPIENT ===\n");

        // Search for any function that takes (uint96, address) or similar
        // that could set the redemption recipient

        bytes memory code = REDEMPTION_0.code;

        // The key selectors to look for:
        bytes4[] memory sels = new bytes4[](10);
        sels[0] = bytes4(keccak256("redeemTo(uint96,address)"));
        sels[1] = bytes4(keccak256("redeemFor(address,uint96)"));
        sels[2] = bytes4(keccak256("redeem(uint96,address)"));
        sels[3] = bytes4(keccak256("createRedemption(uint96,address)"));
        sels[4] = bytes4(keccak256("requestRedeem(uint96,address)"));
        sels[5] = bytes4(keccak256("initiateRedeem(uint96,address)"));
        sels[6] = bytes4(keccak256("redeemOnBehalfOf(address,uint96)"));
        sels[7] = bytes4(keccak256("redeem(uint256,address)"));
        sels[8] = bytes4(keccak256("redeemTo(uint256,address)"));
        sels[9] = bytes4(keccak256("withdraw(uint256,address)"));

        console.log("Searching for recipient-aware redeem functions:");
        for (uint s = 0; s < sels.length; s++) {
            console.log("Selector:");
            console.logBytes4(sels[s]);

            for (uint i = 0; i + 4 < code.length; i++) {
                if (uint8(code[i]) == 0x63) {
                    bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                    if (sel == sels[s]) {
                        console.log("  FOUND at offset:", i);
                    }
                }
            }
        }
    }

    function test_DumpFunctionSelectors() public view {
        console.log("=== ALL FUNCTION SELECTORS IN REDEMPTION_0 ===\n");

        bytes memory code = REDEMPTION_0.code;

        bytes4[] memory found = new bytes4[](50);
        uint count = 0;

        for (uint i = 0; i + 4 < code.length && count < 50; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));

                // Check if followed by EQ within 15 bytes
                bool isSelector = false;
                for (uint j = i + 5; j < i + 15 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x14) {
                        isSelector = true;
                        break;
                    }
                }

                if (isSelector && sel != bytes4(0) && sel != bytes4(0xffffffff)) {
                    // Check uniqueness
                    bool unique = true;
                    for (uint k = 0; k < count; k++) {
                        if (found[k] == sel) {
                            unique = false;
                            break;
                        }
                    }
                    if (unique) {
                        found[count] = sel;
                        count++;
                        console.logBytes4(sel);
                    }
                }
            }
        }

        console.log("\nTotal unique selectors:", count);
    }
}
