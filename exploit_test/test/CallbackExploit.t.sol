// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

interface IUniswapV3Pool {
    function flash(
        address recipient,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external;
    function token0() external view returns (address);
    function token1() external view returns (address);
    function liquidity() external view returns (uint128);
}

interface IBalancerVault {
    function flashLoan(
        address recipient,
        address[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;
}

interface IAavePool {
    function flashLoanSimple(
        address receiverAddress,
        address asset,
        uint256 amount,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

contract CallbackExploit is Test {
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant BALANCER = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address constant AAVE_V3 = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;

    // Uniswap V3 WETH/USDC pool (0.3% fee)
    address constant UNI_V3_POOL = 0x8ad599c3A0ff1De082011EFDDc58f1908eb6e6D8;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testFlashLoanCallbackAnalysis() public view {
        console.log("=====================================================");
        console.log("FLASH LOAN CALLBACK VULNERABILITY ANALYSIS");
        console.log("=====================================================");

        // Check available flash loan liquidity
        uint256 balancerWeth = IERC20(WETH).balanceOf(BALANCER);
        uint256 balancerUsdc = IERC20(USDC).balanceOf(BALANCER);

        console.log("Balancer WETH:", balancerWeth / 1e18);
        console.log("Balancer USDC:", balancerUsdc / 1e6);
        console.log("Balancer fee: FREE (0%)");

        console.log("\n--- Uniswap V3 Pool ---");
        IUniswapV3Pool pool = IUniswapV3Pool(UNI_V3_POOL);
        uint128 liquidity = pool.liquidity();
        console.log("Pool liquidity:", uint256(liquidity));
        console.log("Uniswap V3 fee: varies by pool (0.01% - 1%)");

        console.log("\n--- Attack Vectors ---");
        console.log("1. Reentrancy during callback");
        console.log("2. State manipulation between borrow and repay");
        console.log("3. Price oracle manipulation");
        console.log("4. Cross-contract reentrancy");
    }

    function testCheckForReentrancyTargets() public view {
        console.log("=====================================================");
        console.log("CHECKING FOR REENTRANCY VULNERABLE TARGETS");
        console.log("=====================================================");

        // Check protocols that might be vulnerable during flash loan callbacks

        // Curve read-only reentrancy target
        address curvePool = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;
        console.log("\nCurve stETH/ETH Pool:", curvePool);

        // Get virtual price (can be manipulated during raw call reentrancy)
        (bool success, bytes memory data) = curvePool.staticcall(
            abi.encodeWithSignature("get_virtual_price()")
        );
        if (success && data.length >= 32) {
            uint256 vp = abi.decode(data, (uint256));
            console.log("Virtual Price:", vp / 1e18);
        }

        // Check for admin balance (read-only reentrancy target)
        (success, data) = curvePool.staticcall(
            abi.encodeWithSignature("admin_balances(uint256)", 0)
        );
        if (success && data.length >= 32) {
            console.log("Admin Balance 0:", abi.decode(data, (uint256)) / 1e18);
        }

        // Check if there are protocols using this price feed
        console.log("\nProtocols depending on Curve virtual_price:");
        console.log("- Yearn vaults");
        console.log("- Convex finance");
        console.log("- Various lending protocols");
    }

    function testSearchForPriceManipulation() public view {
        console.log("=====================================================");
        console.log("SEARCHING FOR PRICE MANIPULATION VECTORS");
        console.log("=====================================================");

        // Check for protocols using spot prices (manipulable)
        // vs time-weighted prices (harder to manipulate)

        // Chainlink is not manipulable (trusted oracle)
        address chainlinkEth = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;
        (bool success, bytes memory data) = chainlinkEth.staticcall(
            abi.encodeWithSignature("latestAnswer()")
        );
        if (success && data.length >= 32) {
            int256 price = abi.decode(data, (int256));
            console.log("Chainlink ETH/USD:", uint256(price) / 1e8);
        }

        // TWAP oracles can be manipulated if window is short
        // Uniswap V3 TWAP manipulation requires holding position across blocks

        console.log("\nManipulable price sources:");
        console.log("1. Spot prices from DEXs");
        console.log("2. Reserve ratios in AMMs");
        console.log("3. Short TWAP windows (< 30 min)");

        console.log("\nNon-manipulable (in single tx):");
        console.log("1. Chainlink oracle");
        console.log("2. Long TWAP windows");
        console.log("3. Time-weighted calculations");
    }

    function testCheckPermit2Vulnerabilities() public view {
        console.log("=====================================================");
        console.log("CHECKING PERMIT2 AND SIGNATURE VULNERABILITIES");
        console.log("=====================================================");

        // Permit2 universal router
        address permit2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;
        console.log("Permit2:", permit2);

        // Check nonces/state (signature replay prevention)
        (bool success, bytes memory data) = permit2.staticcall(
            abi.encodeWithSignature("DOMAIN_SEPARATOR()")
        );
        if (success && data.length >= 32) {
            console.log("Domain separator set (replay protected)");
        }

        // Note: Permit2 itself is well audited
        // But protocols integrating it may have issues

        console.log("\nPotential issues:");
        console.log("1. Missing deadline checks");
        console.log("2. Signature malleability");
        console.log("3. Cross-chain replay");
        console.log("4. Permit front-running");
    }

    function testCalculateFlashLoanProfit() public view {
        console.log("=====================================================");
        console.log("FLASH LOAN PROFIT REQUIREMENTS");
        console.log("=====================================================");

        // For a flash loan attack to be profitable:
        // profit > gas costs + flash loan fees

        // Gas cost estimation (at 50 gwei, 500k gas)
        uint256 gasPrice = 50 gwei;
        uint256 gasUsed = 500000;
        uint256 gasCost = gasPrice * gasUsed;
        console.log("Estimated gas cost:", gasCost / 1e18, "ETH");
        console.log("At $3300/ETH: $", gasCost * 3300 / 1e18);

        // Flash loan costs
        console.log("\nFlash loan costs:");
        console.log("Balancer: FREE");
        console.log("Aave V3: 0.05% = $50 per $100k borrowed");
        console.log("Uniswap V3: 0.3% = $300 per $100k borrowed");

        console.log("\nMinimum profit needed for viable exploit:");
        console.log("Using Balancer: ~$100 (just gas)");
        console.log("Using Aave: ~$150 for $100k loan");
        console.log("Using Uniswap: ~$400 for $100k loan");

        // Available liquidity
        uint256 balancerWeth = IERC20(WETH).balanceOf(BALANCER);
        uint256 balancerUsdc = IERC20(USDC).balanceOf(BALANCER);

        console.log("\nMax flash loan available:");
        console.log("WETH:", balancerWeth / 1e18);
        console.log("USDC:", balancerUsdc / 1e6);
    }
}
