// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

interface IRedemption {
    function redeem(uint96 amount) external;
    function finalizeRedeem(uint256 index) external;
    function cancelRedeem(uint256 index) external;
    function IAU() external view returns (address);
}

interface IAavePool {
    function flashLoanSimple(
        address receiverAddress,
        address asset,
        uint256 amount,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

interface IBalancerVault {
    function flashLoan(
        address recipient,
        address[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;
}

contract CallbackExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant STRATEGY_0 = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_SearchForCallbacks() public view {
        console.log("=== SEARCHING FOR CALLBACKS ===\n");

        // Callback selectors
        bytes4[] memory callbacks = new bytes4[](10);
        callbacks[0] = bytes4(keccak256("executeOperation(address,uint256,uint256,address,bytes)"));
        callbacks[1] = bytes4(keccak256("executeOperation(address[],uint256[],uint256[],address,bytes)"));
        callbacks[2] = bytes4(keccak256("receiveFlashLoan(address[],uint256[],uint256[],bytes)"));
        callbacks[3] = bytes4(keccak256("onFlashLoan(address,address,uint256,uint256,bytes)"));
        callbacks[4] = bytes4(keccak256("uniswapV3FlashCallback(uint256,uint256,bytes)"));
        callbacks[5] = bytes4(keccak256("uniswapV3SwapCallback(int256,int256,bytes)"));
        callbacks[6] = bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"));
        callbacks[7] = bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"));
        callbacks[8] = bytes4(keccak256("tokensReceived(address,address,address,uint256,bytes,bytes)"));
        callbacks[9] = bytes4(keccak256("onTokenTransfer(address,uint256,bytes)"));

        string[10] memory names = [
            "executeOperation(single)",
            "executeOperation(multi)",
            "receiveFlashLoan",
            "onFlashLoan",
            "uniswapV3FlashCallback",
            "uniswapV3SwapCallback",
            "onERC721Received",
            "onERC1155Received",
            "tokensReceived(ERC777)",
            "onTokenTransfer"
        ];

        // Check each contract
        address[] memory contracts = new address[](5);
        contracts[0] = REDEMPTION_0;
        contracts[1] = REDEMPTION_1;
        contracts[2] = REDEMPTION_CONTROLLER;
        contracts[3] = STRATEGY_0;
        contracts[4] = VAULT;

        string[5] memory contractNames = [
            "Redemption0",
            "Redemption1",
            "RedemptionController",
            "Strategy0",
            "Vault"
        ];

        for (uint c = 0; c < contracts.length; c++) {
            console.log("\n===", contractNames[c], "===");

            bytes memory code = contracts[c].code;

            for (uint i = 0; i < callbacks.length; i++) {
                for (uint j = 0; j + 3 < code.length; j++) {
                    bytes4 sel = bytes4(bytes.concat(code[j], code[j+1], code[j+2], code[j+3]));
                    if (sel == callbacks[i]) {
                        console.log("  Found:", names[i]);
                        break;
                    }
                }
            }
        }
    }

    function test_AnalyzeRedemptionDelegatecalls() public view {
        console.log("=== ANALYZING REDEMPTION DELEGATECALLS ===\n");

        // Redemption 0 has 8 DELEGATECALLs
        // Redemption 1 has 7 DELEGATECALLs
        // These might be to upgradeable libraries

        bytes memory code0 = REDEMPTION_0.code;
        bytes memory code1 = REDEMPTION_1.code;

        console.log("Redemption 0:");
        console.log("  Code size:", code0.length);

        // Find all DELEGATECALL positions and context
        uint256 dcCount = 0;
        for (uint i = 0; i < code0.length; i++) {
            if (uint8(code0[i]) == 0xf4) {
                dcCount++;
                console.log("  DELEGATECALL at offset:", i);

                // Look for PUSH20 before it (target address)
                for (uint j = i > 25 ? i - 25 : 0; j < i; j++) {
                    if (uint8(code0[j]) == 0x73) { // PUSH20
                        bytes20 addr;
                        for (uint k = 0; k < 20 && j + 1 + k < code0.length; k++) {
                            addr |= bytes20(bytes1(code0[j + 1 + k])) >> (8 * k);
                        }
                        if (address(addr) != address(0)) {
                            console.log("    Target:", address(addr));
                        }
                    }
                }
            }
        }
        console.log("  Total DELEGATECALLs:", dcCount);

        console.log("\nRedemption 1:");
        console.log("  Code size:", code1.length);

        dcCount = 0;
        for (uint i = 0; i < code1.length; i++) {
            if (uint8(code1[i]) == 0xf4) {
                dcCount++;
            }
        }
        console.log("  Total DELEGATECALLs:", dcCount);
    }

    function test_TryFlashLoanCallback() public {
        console.log("=== TRYING FLASH LOAN CALLBACK ===\n");

        // Deploy attacker contract that will receive the flash loan
        FlashLoanAttacker attackerContract = new FlashLoanAttacker(
            STRATEGY_0,
            VAULT,
            wstETH
        );

        console.log("Attacker contract:", address(attackerContract));
        console.log("Vault wstETH before:", IERC20(wstETH).balanceOf(VAULT) / 1e18);
        console.log("Attacker wstETH before:", IERC20(wstETH).balanceOf(attacker));

        // Try Aave flash loan
        vm.startPrank(attacker);

        console.log("\nAttempting Aave flash loan...");
        try attackerContract.attackViaAave(1e18) {
            console.log("Aave flash loan succeeded!");
        } catch Error(string memory reason) {
            console.log("Aave flash loan failed:", reason);
        } catch {
            console.log("Aave flash loan failed");
        }

        console.log("\nAttempting Balancer flash loan...");
        try attackerContract.attackViaBalancer(1e18) {
            console.log("Balancer flash loan succeeded!");
        } catch Error(string memory reason) {
            console.log("Balancer flash loan failed:", reason);
        } catch {
            console.log("Balancer flash loan failed");
        }

        vm.stopPrank();

        console.log("\nVault wstETH after:", IERC20(wstETH).balanceOf(VAULT) / 1e18);
        console.log("Attacker wstETH after:", IERC20(wstETH).balanceOf(attacker));
    }

    function test_CheckIAUToken() public view {
        console.log("=== CHECKING IAU TOKEN ===\n");

        // IAU is the token needed to redeem
        // Maybe IAU has callbacks or special behavior

        address iau = IRedemption(REDEMPTION_0).IAU();
        console.log("IAU token:", iau);

        bytes memory iauCode = iau.code;
        console.log("IAU code size:", iauCode.length);

        // Check for ERC777 hooks
        bytes4 tokensReceivedSel = bytes4(keccak256("tokensReceived(address,address,address,uint256,bytes,bytes)"));

        bool hasTokensReceived = false;
        for (uint i = 0; i + 3 < iauCode.length; i++) {
            bytes4 sel = bytes4(bytes.concat(iauCode[i], iauCode[i+1], iauCode[i+2], iauCode[i+3]));
            if (sel == tokensReceivedSel) {
                hasTokensReceived = true;
                break;
            }
        }

        console.log("Has tokensReceived:", hasTokensReceived);

        // Check DELEGATECALL count
        uint256 dcCount = 0;
        for (uint i = 0; i < iauCode.length; i++) {
            if (uint8(iauCode[i]) == 0xf4) dcCount++;
        }
        console.log("DELEGATECALL count:", dcCount);
    }

    function test_ReentrancyViaRedeem() public {
        console.log("=== TESTING REENTRANCY VIA REDEEM ===\n");

        // The redeem process might have a reentrancy window
        // When IAU is burned or wstETH is transferred

        // We need IAU tokens to test this
        address iau = IRedemption(REDEMPTION_0).IAU();

        // Check if we can get IAU somehow
        console.log("IAU balance of attacker:", IERC20(iau).balanceOf(attacker));
        console.log("IAU balance of Vault:", IERC20(iau).balanceOf(VAULT));
        console.log("IAU balance of Strategy:", IERC20(iau).balanceOf(STRATEGY_0));

        // IAU might be mintable by depositing wstETH
        // Let's check if there's a deposit function in the system
    }
}

contract FlashLoanAttacker {
    address public strategy;
    address public vault;
    address public wstETH;
    address public owner;

    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

    constructor(address _strategy, address _vault, address _wstETH) {
        strategy = _strategy;
        vault = _vault;
        wstETH = _wstETH;
        owner = msg.sender;
    }

    function attackViaAave(uint256 amount) external {
        IAavePool(AAVE_POOL).flashLoanSimple(
            address(this),
            wstETH,
            amount,
            "",
            0
        );
    }

    function attackViaBalancer(uint256 amount) external {
        address[] memory tokens = new address[](1);
        tokens[0] = wstETH;

        uint256[] memory amounts = new uint256[](1);
        amounts[0] = amount;

        IBalancerVault(BALANCER_VAULT).flashLoan(
            address(this),
            tokens,
            amounts,
            ""
        );
    }

    // Aave callback
    function executeOperation(
        address asset,
        uint256 amount,
        uint256 premium,
        address initiator,
        bytes calldata params
    ) external returns (bool) {
        // We have flash loaned wstETH
        // Try to exploit the system during this callback

        // Attempt: Call Strategy directly (will fail - access control)
        // Attempt: Call Vault directly (will fail - access control)

        // Repay the loan
        uint256 amountOwed = amount + premium;
        IERC20(asset).approve(AAVE_POOL, amountOwed);

        return true;
    }

    // Balancer callback
    function receiveFlashLoan(
        address[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external {
        // We have flash loaned wstETH
        // Try to exploit the system during this callback

        // Repay
        uint256 amountOwed = amounts[0] + feeAmounts[0];
        IERC20(tokens[0]).transfer(BALANCER_VAULT, amountOwed);
    }

    receive() external payable {}
}
