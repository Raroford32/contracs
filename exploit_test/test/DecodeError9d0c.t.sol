// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract DecodeError9d0c is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_DecodeError() public view {
        console.log("=== DECODING ERROR 0x9d0c9ba3 ===\n");

        bytes4 target = bytes4(0x9d0c9ba3);

        string[50] memory errors = [
            "InsufficientLiquidity()",
            "NotEnoughLiquidity()",
            "LiquidityInsufficient()",
            "InsufficientFunds()",
            "NotEnoughFunds()",
            "FundsInsufficient()",
            "InsufficientBalance()",
            "BalanceInsufficient()",
            "VaultInsufficient()",
            "NotReady()",
            "NotYetReady()",
            "TooEarly()",
            "NotFinalized()",
            "CannotFinalize()",
            "FinalizeNotReady()",
            "DelayNotPassed()",
            "WaitPeriodNotOver()",
            "CooldownNotOver()",
            "StillInCooldown()",
            "NotMature()",
            "NotMatured()",
            "RedemptionNotReady()",
            "RedeemNotReady()",
            "RedemptionPending()",
            "StillPending()",
            "NotProcessed()",
            "NotYetProcessed()",
            "ProcessingRequired()",
            "NeedsProcessing()",
            "AwaitingProcessing()",
            "QueueNotProcessed()",
            "EpochNotReady()",
            "EpochPending()",
            "WaitForEpoch()",
            "EpochInProgress()",
            "NotInCurrentEpoch()",
            "InvalidEpoch()",
            "WrongEpoch()",
            "EpochMismatch()",
            "Redemption__NotReady()",
            "Redemption__TooEarly()",
            "Redemption__Pending()",
            "Redemption__NotMature()",
            "RateLimited()",
            "RateLimitExceeded()",
            "TooManyRedemptions()",
            "ExceedsLimit()",
            "LimitExceeded()",
            "OverLimit()",
            "MaxExceeded()"
        ];

        for (uint i = 0; i < errors.length; i++) {
            bytes4 sel = bytes4(keccak256(bytes(errors[i])));
            if (sel == target) {
                console.log("*** MATCH:", errors[i]);
            }
        }
    }

    function test_FindThresholdAmount() public {
        console.log("=== FINDING THRESHOLD AMOUNT ===\n");

        vm.startPrank(attacker);
        deal(TASSET, attacker, 100000e18);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        uint256[] memory amounts = new uint256[](8);
        amounts[0] = 500e18;
        amounts[1] = 1000e18;
        amounts[2] = 1500e18;
        amounts[3] = 2000e18;
        amounts[4] = 2500e18;
        amounts[5] = 3000e18;
        amounts[6] = 3500e18;
        amounts[7] = 4000e18;

        for (uint i = 0; i < amounts.length; i++) {
            uint256 snap = vm.snapshot();

            REDEMPTION_0.call(abi.encodeWithSignature("redeem(uint96)", uint96(amounts[i])));
            vm.warp(block.timestamp + 7 days);

            (bool s2,) = REDEMPTION_0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));

            if (s2) {
                uint256 wst = IERC20(wstETH).balanceOf(attacker);
                console.log("Amount SUCCESS:", amounts[i] / 1e18);
                console.log("  Got wstETH:", wst / 1e18);
            } else {
                console.log("Amount FAILED:", amounts[i] / 1e18);
            }

            vm.revertTo(snap);
        }

        vm.stopPrank();
    }

    function test_CheckEpochOrRateLimit() public view {
        console.log("=== CHECK EPOCH/RATE LIMIT ===\n");

        (bool s1, bytes memory d1) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("currentEpoch()")
        );
        if (s1 && d1.length >= 32) console.log("currentEpoch:", abi.decode(d1, (uint256)));

        (bool s2, bytes memory d2) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("epochCap()")
        );
        if (s2 && d2.length >= 32) console.log("epochCap:", abi.decode(d2, (uint256)) / 1e18);

        (bool s3, bytes memory d3) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("epochRedemptions()")
        );
        if (s3 && d3.length >= 32) console.log("epochRedemptions:", abi.decode(d3, (uint256)) / 1e18);
    }

    function test_MultipleSmallRedemptions() public {
        console.log("=== MULTIPLE SMALL REDEMPTIONS ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        vm.startPrank(attacker);
        deal(TASSET, attacker, 50000e18);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        for (uint i = 0; i < 5; i++) {
            (bool s,) = REDEMPTION_0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
            console.log("redeem", i, ":", s);
        }

        vm.stopPrank();

        vm.warp(block.timestamp + 7 days);

        vm.startPrank(attacker);

        for (uint i = 0; i < 5; i++) {
            uint256 wstBefore = IERC20(wstETH).balanceOf(attacker);
            (bool s,) = REDEMPTION_0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", i));
            uint256 wstAfter = IERC20(wstETH).balanceOf(attacker);
            if (s) {
                console.log("finalize", i, "got:", (wstAfter - wstBefore) / 1e18);
            } else {
                console.log("finalize", i, ": FAILED");
            }
        }

        vm.stopPrank();

        console.log("\nTotal attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }
}
