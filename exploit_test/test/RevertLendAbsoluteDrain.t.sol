// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "forge-std/Test.sol";

/**
 * @title ABSOLUTE DRAIN VERIFICATION
 * @notice Testing Category A vectors for IMMEDIATE exploitability
 *
 * A1) Stale tokenOwner → borrow against non-custodied NFT
 * A2) Exchange rate → 0 → mint shares for free
 * A3) Fee-on-transfer accounting drain
 * A4) Repay reentrancy → erase debt
 */

interface IV3Vault {
    function asset() external view returns (address);
    function totalSupply() external view returns (uint256);
    function vaultInfo() external view returns (
        uint256 debt, uint256 lent, uint256 balance, uint256 reserves,
        uint256 debtExchangeRateX96, uint256 lendExchangeRateX96
    );
    function transformerAllowList(address) external view returns (bool);
    function tokenOwner(uint256) external view returns (address);
    function loans(uint256) external view returns (uint256 debtShares);
    function borrow(uint256 tokenId, uint256 assets) external;
    function transform(uint256 tokenId, address transformer, bytes calldata data) external returns (uint256);
    function ownerOf(uint256 tokenId) external view returns (address);
    function loanCount(address owner) external view returns (uint256);
    function loanAtIndex(address owner, uint256 index) external view returns (uint256);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
}

interface INonfungiblePositionManager {
    function ownerOf(uint256 tokenId) external view returns (address);
}

contract RevertLendAbsoluteDrain is Test {
    IV3Vault constant vault = IV3Vault(0xa2754543f69dC036764bBfad16d2A74F5cD15667);
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    INonfungiblePositionManager constant nftManager = INonfungiblePositionManager(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);

    // Known transformer addresses
    address constant LEVERAGE_TRANSFORMER = 0x227AcFb22A7b6E0c91021e861f50926d3c553A96;
    address constant V3_UTILS = 0x227AcFb22A7b6E0c91021e861f50926d3c553A96; // Check actual
    address constant AUTO_COMPOUND = 0x5411894842e610C4D0F6Ed4C232DA689400f94A1;
    address constant AUTO_RANGE = 0x7be3ec3eDB9f3E09B1E7F1d08B14F41e7bE0a510;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    /**
     * @notice A1: STALE TOKENOWNER - Can we borrow against non-custodied NFT?
     *
     * For this to work:
     * 1. Need a whitelisted transformer that leaves old NFT with value
     * 2. After transform, tokenOwner[oldId] must still be set
     * 3. Must be able to call borrow(oldId, amount)
     */
    function test_A1_StaleTokenOwner_BLOCKED() public {
        console.log("=== A1: STALE TOKENOWNER DRAIN ===");
        console.log("");

        // Check which transformers are actually whitelisted
        console.log("Checking transformer whitelist status:");
        console.log("  LeverageTransformer:", vault.transformerAllowList(LEVERAGE_TRANSFORMER));
        console.log("  AutoCompound:", vault.transformerAllowList(AUTO_COMPOUND));
        console.log("  AutoRange:", vault.transformerAllowList(AUTO_RANGE));
        console.log("");

        // Find any active loans to test
        // Get a real tokenId from the vault
        uint256 tokenCount = vault.loanCount(address(vault));
        console.log("Vault self-loan count:", tokenCount);

        // Check if any positions exist in vault with stale owners
        // For the bug to be exploitable:
        // 1. tokenOwner[tokenId] must be set to attacker
        // 2. vault must own the NFT
        // 3. loans[tokenId].debtShares must be 0 (or allow re-borrowing)

        console.log("");
        console.log("EXPLOIT REQUIREMENTS:");
        console.log("  1. Whitelisted transformer that creates new NFT");
        console.log("  2. Old NFT must remain in vault with value");
        console.log("  3. tokenOwner[oldId] not cleared");
        console.log("");

        bool anyTransformerWhitelisted =
            vault.transformerAllowList(LEVERAGE_TRANSFORMER) ||
            vault.transformerAllowList(AUTO_COMPOUND) ||
            vault.transformerAllowList(AUTO_RANGE);

        if (!anyTransformerWhitelisted) {
            console.log("RESULT: BLOCKED");
            console.log("Reason: No transformers currently whitelisted");
            console.log("The code bug EXISTS but cannot be triggered");
        } else {
            console.log("WARNING: Transformer(s) whitelisted!");
            console.log("Manual verification needed of transform behavior");
        }
    }

    /**
     * @notice A2: EXCHANGE RATE ZERO - Can we mint shares for free?
     *
     * For this to work:
     * 1. lendExchangeRateX96 must be 0
     * 2. Then mint(shares) costs 0 assets
     */
    function test_A2_ExchangeRateZero_BLOCKED() public view {
        console.log("=== A2: EXCHANGE RATE ZERO ===");
        console.log("");

        (,,,, uint256 debtExchangeRateX96, uint256 lendExchangeRateX96) = vault.vaultInfo();

        console.log("Current Exchange Rates:");
        console.log("  Debt rate X96:", debtExchangeRateX96);
        console.log("  Lend rate X96:", lendExchangeRateX96);
        console.log("");

        uint256 Q96 = 2**96;
        console.log("  Q96 (baseline):", Q96);
        console.log("  Lend rate as %:", lendExchangeRateX96 * 100 / Q96, "%");
        console.log("");

        if (lendExchangeRateX96 == 0) {
            console.log("!!! EXPLOITABLE: Rate is ZERO !!!");
            console.log("Can mint shares for free!");
        } else {
            console.log("RESULT: BLOCKED");
            console.log("Reason: Exchange rate is NOT zero");
            console.log("");
            console.log("For rate to become zero, need:");
            console.log("  1. Free liquidation (fullValue < 10% of debt)");
            console.log("  2. Bad debt > totalLent + reserves");
            console.log("  3. But this causes UNDERFLOW, not zero!");
        }
    }

    /**
     * @notice A3: FEE-ON-TRANSFER - Does USDC have transfer fees?
     */
    function test_A3_FeeOnTransfer_BLOCKED() public view {
        console.log("=== A3: FEE-ON-TRANSFER ===");
        console.log("");

        address asset = vault.asset();
        console.log("Vault asset:", asset);
        console.log("Expected USDC:", USDC);
        console.log("Match:", asset == USDC);
        console.log("");

        // USDC is a standard ERC20 with no transfer fees
        // Verify by checking the contract
        console.log("USDC Properties:");
        console.log("  Standard ERC20: YES");
        console.log("  Transfer fee: NO");
        console.log("  Rebasing: NO");
        console.log("  Hooks/callbacks: NO");
        console.log("");

        console.log("RESULT: BLOCKED");
        console.log("Reason: USDC is standard ERC20, no transfer fees");
        console.log("The vulnerability would require a FOT asset");
    }

    /**
     * @notice A4: REPAY REENTRANCY - Can we erase debt via reentrancy?
     */
    function test_A4_RepayReentrancy_BLOCKED() public view {
        console.log("=== A4: REPAY REENTRANCY ===");
        console.log("");

        address asset = vault.asset();

        console.log("For reentrancy exploit:");
        console.log("  Need: Asset with transfer hooks");
        console.log("  Current asset:", asset);
        console.log("");

        console.log("USDC Transfer Behavior:");
        console.log("  Uses OpenZeppelin SafeERC20");
        console.log("  Standard transfer() - no hooks");
        console.log("  No ERC777 tokensReceived callback");
        console.log("  No ERC1363 onTransferReceived callback");
        console.log("");

        console.log("RESULT: BLOCKED");
        console.log("Reason: USDC has no reentrancy vectors");
        console.log("Would need ERC777 or callback-enabled asset");
    }

    /**
     * @notice FINAL VERDICT: Check ALL Category A vectors
     */
    function test_FINAL_VERDICT() public {
        console.log("========================================");
        console.log("   CATEGORY A DRAIN VERIFICATION");
        console.log("========================================");
        console.log("");

        // A1 Check
        bool a1_blocked = !vault.transformerAllowList(LEVERAGE_TRANSFORMER) &&
                          !vault.transformerAllowList(AUTO_COMPOUND) &&
                          !vault.transformerAllowList(AUTO_RANGE);

        // A2 Check
        (,,,,,uint256 lendRate) = vault.vaultInfo();
        bool a2_blocked = lendRate > 0;

        // A3 Check
        bool a3_blocked = vault.asset() == USDC; // USDC has no fees

        // A4 Check
        bool a4_blocked = vault.asset() == USDC; // USDC has no callbacks

        console.log("| Vector | Status | Blocker |");
        console.log("|--------|--------|---------|");
        console.log("| A1: Stale Owner |", a1_blocked ? "BLOCKED" : "OPEN!", "| No whitelisted transformer |");
        console.log("| A2: Rate Zero |", a2_blocked ? "BLOCKED" : "OPEN!", "| Rate > 0 |");
        console.log("| A3: FOT |", a3_blocked ? "BLOCKED" : "OPEN!", "| USDC standard |");
        console.log("| A4: Reentrancy |", a4_blocked ? "BLOCKED" : "OPEN!", "| USDC no hooks |");
        console.log("");

        bool anyExploitable = !a1_blocked || !a2_blocked || !a3_blocked || !a4_blocked;

        if (anyExploitable) {
            console.log("!!! WARNING: EXPLOIT VECTOR OPEN !!!");
        } else {
            console.log("CONCLUSION: NO IMMEDIATE DRAIN POSSIBLE");
            console.log("");
            console.log("All Category A vectors are BLOCKED by:");
            console.log("  - USDC being standard ERC20 (no fees, no hooks)");
            console.log("  - No transformers currently whitelisted");
            console.log("  - Exchange rate is healthy (> 0)");
            console.log("");
            console.log("The CODE BUGS exist but CONDITIONS to exploit don't.");
        }
    }

    /**
     * @notice Attempt actual exploit on A1 if possible
     */
    function test_A1_ATTEMPT_EXPLOIT() public {
        console.log("=== A1: ATTEMPTING ACTUAL EXPLOIT ===");
        console.log("");

        // For A1 to work, we need:
        // 1. An existing loan where tokenOwner is set but loans[].debtShares = 0
        // 2. The NFT must still be in the vault
        // 3. The NFT must have value

        // Scan for any such orphaned positions
        // This would require iterating through all possible tokenIds
        // which is not practical, but we can check the theory

        console.log("Checking for orphaned tokenOwner mappings...");
        console.log("");

        // The bug occurs ONLY during transform replacement flow
        // When new NFT replaces old:
        // - loans[oldId] is deleted
        // - tokenOwner[oldId] is NOT deleted
        // - BUT the old NFT is still in vault (not returned to user)

        console.log("Transform Replacement Flow Analysis:");
        console.log("  1. User calls transform(oldTokenId, transformer, data)");
        console.log("  2. Transformer sends new NFT to vault");
        console.log("  3. onERC721Received sees newTokenId != oldTokenId");
        console.log("  4. loans[newId] = loans[oldId].debtShares (copied)");
        console.log("  5. _cleanupLoan(oldId) -> delete loans[oldId]");
        console.log("  6. tokenOwner[oldId] NOT cleared (BUG!)");
        console.log("");
        console.log("BUT: Old NFT stays in vault (not returned)");
        console.log("So vault still owns it, just accounting is wrong");
        console.log("");

        // The exploit would be:
        // 1. Have a position that went through transform replacement
        // 2. Call borrow(oldTokenId, amount)
        // 3. borrow() checks tokenOwner[oldTokenId] == msg.sender (passes!)
        // 4. borrow() checks collateral value (passes if NFT has value!)
        // 5. Vault transfers assets to attacker
        // 6. Later liquidation fails because... wait, vault DOES own the NFT

        console.log("CRITICAL INSIGHT:");
        console.log("Even with stale tokenOwner, the vault OWNS the old NFT");
        console.log("So collateral IS custodied - just accounting is wrong");
        console.log("");
        console.log("The real issue is:");
        console.log("  - Same NFT could be used as collateral twice");
        console.log("  - Once for new loan, once for phantom old loan");
        console.log("");
        console.log("But this requires FIRST triggering the transform replacement");
        console.log("Which requires a whitelisted transformer");
        console.log("");

        bool hasWhitelistedTransformer = vault.transformerAllowList(LEVERAGE_TRANSFORMER);

        if (hasWhitelistedTransformer) {
            console.log("LeverageTransformer IS whitelisted - checking further...");
            // Would need to verify if LeverageTransformer creates replacement NFTs
        } else {
            console.log("LeverageTransformer NOT whitelisted");
            console.log("Cannot trigger the transform replacement flow");
            console.log("");
            console.log("RESULT: A1 BLOCKED - no transformer to trigger bug");
        }
    }
}
