// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract WhatTriggersCreate2 is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    bytes32 constant INIT_CODE_HASH = 0xa7afdc89189c0997287e337d2577f5aa7f1fa2faecf74ac9e05b6fdc306bfcd6;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeCodePathToCreate2() public view {
        console.log("=== ANALYZING CODE PATH TO CREATE2 AT 5608 ===\n");

        bytes memory code = REDEMPTION_0.code;

        // CREATE2 at 5608 - let's trace backwards to find what calls it

        // Looking at bytecode around 5550-5650
        console.log("Bytecode from 5500-5650:");

        uint i = 5500;
        while (i < 5650 && i < code.length) {
            uint8 op = uint8(code[i]);
            uint skipBytes = 0;

            if (op == 0x5b) console.log(i, "JUMPDEST");
            if (op == 0x56) console.log(i, "JUMP");
            if (op == 0x57) console.log(i, "JUMPI");
            if (op == 0x33) console.log(i, "CALLER");
            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0x55) console.log(i, "SSTORE");
            if (op == 0xf5) console.log(i, "CREATE2");
            if (op == 0x14) console.log(i, "EQ");
            if (op == 0x15) console.log(i, "ISZERO");
            if (op == 0x3b) console.log(i, "EXTCODESIZE");

            if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                if (size == 32) {
                    console.log(i, "PUSH32:");
                    console.logBytes32(bytes32(val));
                } else if (size <= 4 && val < 10000) {
                    console.log(i, "PUSH:", val);
                }
                skipBytes = size;
            }

            i += 1 + skipBytes;
        }
    }

    function test_TryAllSelectorsForCreate2() public {
        console.log("=== TRYING ALL R0 SELECTORS FOR CREATE2 ===\n");

        bytes32 salt = bytes32(uint256(uint160(attacker)));
        address predictedProxy = address(uint160(uint256(keccak256(abi.encodePacked(
            bytes1(0xff),
            REDEMPTION_0,
            salt,
            INIT_CODE_HASH
        )))));

        console.log("Predicted proxy:", predictedProxy);

        // R0 selectors from earlier analysis
        bytes4[] memory sels = new bytes4[](24);
        sels[0] = bytes4(0xe30c3978);
        sels[1] = bytes4(0xed45b661);
        sels[2] = bytes4(0xeda72134);
        sels[3] = bytes4(0xf2fde38b);
        sels[4] = bytes4(0xaff6cbf1); // finalizeRedeem
        sels[5] = bytes4(0xb2118a8d);
        sels[6] = bytes4(0xcff50c6e);
        sels[7] = bytes4(0x8da5cb5b);
        sels[8] = bytes4(0x900fd1ed);
        sels[9] = bytes4(0x9307e802);
        sels[10] = bytes4(0xa82b69ff);
        sels[11] = bytes4(0x715018a6);
        sels[12] = bytes4(0x7630c4a8); // redeem(uint96)
        sels[13] = bytes4(0x79ba5097);
        sels[14] = bytes4(0x458f5815);
        sels[15] = bytes4(0x51cbf345);
        sels[16] = bytes4(0x5c975abb);
        sels[17] = bytes4(0x5f8b5592);
        sels[18] = bytes4(0x3a2ef9df);
        sels[19] = bytes4(0x3f14c193);
        sels[20] = bytes4(0x411557d1);
        sels[21] = bytes4(0x196e6b1d);
        sels[22] = bytes4(0x2ab60045);
        sels[23] = bytes4(0x38a63183);

        deal(TASSET, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        console.log("Testing each selector:");

        for (uint i = 0; i < sels.length; i++) {
            uint256 codeBefore = predictedProxy.code.length;

            // Try with no params
            REDEMPTION_0.call{gas: 500000}(abi.encodeWithSelector(sels[i]));

            // Try with address param
            REDEMPTION_0.call{gas: 500000}(abi.encodeWithSelector(sels[i], attacker));

            // Try with uint param
            REDEMPTION_0.call{gas: 500000}(abi.encodeWithSelector(sels[i], uint256(100e18)));

            uint256 codeAfter = predictedProxy.code.length;

            if (codeAfter > codeBefore) {
                console.log("*** CREATED PROXY! Selector:");
                console.logBytes4(sels[i]);
            }
        }

        vm.stopPrank();

        console.log("\nFinal proxy code:", predictedProxy.code.length);
    }

    function test_MatchUnknownSelectors() public pure {
        console.log("=== MATCHING MORE SELECTORS ===\n");

        // Unknown R0 selectors
        bytes4[] memory unknown = new bytes4[](10);
        unknown[0] = bytes4(0xed45b661);
        unknown[1] = bytes4(0xb2118a8d);
        unknown[2] = bytes4(0xcff50c6e);
        unknown[3] = bytes4(0x900fd1ed);
        unknown[4] = bytes4(0xa82b69ff);
        unknown[5] = bytes4(0x458f5815);
        unknown[6] = bytes4(0x5f8b5592);
        unknown[7] = bytes4(0x3a2ef9df);
        unknown[8] = bytes4(0x3f14c193);
        unknown[9] = bytes4(0x196e6b1d);

        string[60] memory funcs = [
            "claimProxy()",
            "claimProxy(address)",
            "getClaimProxy()",
            "getClaimProxy(address)",
            "createClaimProxy()",
            "deployClaimProxy()",
            "claimable()",
            "claimable(address)",
            "pendingRewards()",
            "pendingRewards(address)",
            "earned()",
            "earned(address)",
            "getReward()",
            "getReward(address)",
            "collectReward()",
            "collectReward(address)",
            "harvestReward()",
            "harvest()",
            "compound()",
            "reinvest()",
            "stake(uint256)",
            "unstake(uint256)",
            "deposit(uint256)",
            "withdraw(uint256)",
            "getDeposits(address)",
            "getWithdrawals(address)",
            "redeemInfo(address)",
            "getRedeemInfo(address,uint256)",
            "getRedeemLength(address)",
            "pendingRedeems(address)",
            "activeRedeems()",
            "totalRedeemed()",
            "totalClaimed()",
            "claimedRewards(address)",
            "unclaimedRewards(address)",
            "rewardRate()",
            "rewardsDuration()",
            "lastUpdateTime()",
            "rewardPerToken()",
            "rewardPerTokenStored()",
            "userRewardPerTokenPaid(address)",
            "rewards(address)",
            "staked(address)",
            "totalStaked()",
            "balanceOf(address)",
            "totalSupply()",
            "lockedBalance(address)",
            "unlockedBalance(address)",
            "availableBalance(address)",
            "minRedemption()",
            "maxRedemption()",
            "redemptionDelay()",
            "cooldown()",
            "cooldownTime()",
            "setCooldown(uint256)",
            "setRedemptionDelay(uint256)",
            "setMinRedemption(uint256)",
            "setMaxRedemption(uint256)",
            "cancelRedeem(uint256)",
            "cancelRedemption(uint256)"
        ];

        for (uint u = 0; u < 10; u++) {
            console.log("\nUnknown selector:");
            console.logBytes4(unknown[u]);

            for (uint f = 0; f < 60; f++) {
                bytes4 sel = bytes4(keccak256(bytes(funcs[f])));
                if (sel == unknown[u]) {
                    console.log("MATCH:", funcs[f]);
                }
            }
        }
    }

    function test_InvestigateSlot5() public view {
        console.log("=== INVESTIGATING SLOT 5 (USED IN CREATE2) ===\n");

        // CREATE2 at 5608 uses SLOAD at 5562, which might load slot 5
        // Let's check what's in slot 5

        bytes32 slot5 = vm.load(REDEMPTION_0, bytes32(uint256(5)));
        console.log("R0 Slot 5:");
        console.logBytes32(slot5);
        console.log("As address:", address(uint160(uint256(slot5))));

        // Check slot 5 in R1 too
        bytes32 slot5R1 = vm.load(REDEMPTION_1, bytes32(uint256(5)));
        console.log("\nR1 Slot 5:");
        console.logBytes32(slot5R1);
        console.log("As address:", address(uint160(uint256(slot5R1))));

        // The implementation address is often in slot 5
        address impl = address(uint160(uint256(slot5)));
        if (impl != address(0) && impl.code.length > 0) {
            console.log("\nSlot 5 is a contract with code size:", impl.code.length);

            // This might be the implementation for the proxy!
            // The CREATE2 might create a minimal proxy pointing to this
        }
    }

    function test_CheckCreate2Context() public view {
        console.log("=== CHECKING CREATE2 CONTEXT MORE DEEPLY ===\n");

        bytes memory code = REDEMPTION_0.code;

        // The CREATE2 at 5608 needs:
        // - value (ETH to send)
        // - offset (memory offset of init code)
        // - size (size of init code)
        // - salt

        // Looking at code before CREATE2
        console.log("Detailed analysis before CREATE2 at 5608:");

        // PUSH32 at 5593 contains init code hash
        // CALLER at 5604
        // Then CREATE2 at 5608

        // But wait - CREATE2 needs init_code, not init_code_hash
        // The hash is used for address prediction only

        // Let's find where the init code actually is
        console.log("\nSearching for CODECOPY that copies init code:");

        for (uint i = 5400; i < 5608 && i < code.length; i++) {
            if (uint8(code[i]) == 0x39) { // CODECOPY
                console.log("CODECOPY at:", i);

                // CODECOPY(destOffset, offset, size) - all from stack
                // Look at what gets pushed before
                uint j = i - 1;
                uint pushCount = 0;
                while (j > i - 30 && j < code.length && pushCount < 5) {
                    uint8 op = uint8(code[j]);
                    if (op >= 0x60 && op <= 0x7f) {
                        uint8 size = op - 0x5f;
                        uint256 val = 0;
                        for (uint k = 0; k < size && j + 1 + k < code.length; k++) {
                            val = val << 8 | uint8(code[j + 1 + k]);
                        }
                        if (val < 10000) {
                            console.log("  PUSH value:", val);
                        }
                        pushCount++;
                    }
                    j--;
                }
            }
        }

        // Actually the PUSH32 might be the keccak256 of init code used for CREATE2
        // The init code itself might be created inline

        // Let's look at what function even reaches this code
        // by checking what jumps to JUMPDEST 5559 (nearest before CREATE2)

        console.log("\nSearching for jumps to JUMPDEST 5559:");

        for (uint i = 0; i < code.length - 3; i++) {
            if (uint8(code[i]) == 0x61) { // PUSH2
                uint16 dest = uint16(uint8(code[i+1])) << 8 | uint8(code[i+2]);
                if (dest == 5559) {
                    console.log("PUSH2 5559 at:", i);

                    // Check what's after - JUMP or JUMPI?
                    for (uint j = i + 3; j < i + 10 && j < code.length; j++) {
                        if (uint8(code[j]) == 0x56) console.log("  -> JUMP at:", j);
                        if (uint8(code[j]) == 0x57) console.log("  -> JUMPI at:", j);
                    }
                }
            }
        }
    }
}
