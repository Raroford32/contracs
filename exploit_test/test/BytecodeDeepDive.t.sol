// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
}

contract BytecodeDeepDive is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
    }

    function test_MapFunctionToOffset() public view {
        console.log("=== MAPPING FUNCTIONS TO BYTECODE OFFSETS ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Find all function selectors and their JUMPDEST locations
        // The pattern is: PUSH4 <selector> EQ PUSH2 <dest> JUMPI

        console.log("Function selector -> JUMPDEST mapping:");

        for (uint i = 0; i + 10 < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 selector = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));

                // Check for EQ after
                for (uint j = i + 5; j < i + 20 && j + 2 < code.length; j++) {
                    if (uint8(code[j]) == 0x14) { // EQ
                        // Look for PUSH2 followed by JUMPI
                        for (uint k = j + 1; k < j + 10 && k + 3 < code.length; k++) {
                            if (uint8(code[k]) == 0x61) { // PUSH2
                                uint16 dest = uint16(uint8(code[k+1])) << 8 | uint16(uint8(code[k+2]));
                                // Check if destination is near 5323 (our target DELEGATECALL)
                                if (dest > 5200 && dest < 5400) {
                                    console.log("\nSelector that jumps near 5323:");
                                    console.logBytes4(selector);
                                    console.log("  Jumps to:", dest);
                                }
                                break;
                            }
                        }
                        break;
                    }
                }
            }
        }
    }

    function test_FindWhichFunctionUsesDelegatecall() public view {
        console.log("=== FINDING FUNCTION THAT USES DELEGATECALL AT 5323 ===\n");

        bytes memory code = REDEMPTION_0.code;

        // The DELEGATECALL is at 5323
        // We need to trace back to find which function selector leads here

        // Look for all JUMPDEST instructions between 5000-5323
        console.log("JUMPDEST locations near 5323:");
        for (uint i = 5000; i < 5323 && i < code.length; i++) {
            if (uint8(code[i]) == 0x5b) { // JUMPDEST
                console.log("  JUMPDEST at:", i);
            }
        }

        // Now find which PUSH2 values match these JUMPDESTs
        console.log("\nSearching for PUSH2 values that could reach these locations:");
        for (uint i = 0; i < 500 && i + 3 < code.length; i++) {
            if (uint8(code[i]) == 0x61) { // PUSH2
                uint16 dest = uint16(uint8(code[i+1])) << 8 | uint16(uint8(code[i+2]));
                if (dest >= 5000 && dest <= 5323) {
                    console.log("  PUSH2 at offset", i, "-> dest:", dest);
                }
            }
        }
    }

    function test_AnalyzeAllDelegatecalls() public view {
        console.log("=== ANALYZING ALL DELEGATECALLS IN REDEMPTION ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Find all DELEGATECALL and analyze their context
        uint256 dcCount = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) { // DELEGATECALL
                dcCount++;
                console.log("\n--- DELEGATECALL ---");
                console.log("  #:", dcCount);
                console.log("  Offset:", i);

                // Check what's 50 bytes before to understand context
                uint start = i > 50 ? i - 50 : 0;

                // Count SLOAD, CALLDATALOAD, PUSH20 before this DELEGATECALL
                uint sloadCount = 0;
                uint cdloadCount = 0;
                uint push20Count = 0;

                for (uint j = start; j < i; j++) {
                    if (uint8(code[j]) == 0x54) sloadCount++;
                    if (uint8(code[j]) == 0x35) cdloadCount++;
                    if (uint8(code[j]) == 0x73) push20Count++;
                }

                console.log("  Context - SLOAD:", sloadCount);
                console.log("  Context - CALLDATALOAD:", cdloadCount);
                console.log("  Context - PUSH20:", push20Count);

                // Check for specific patterns
                if (sloadCount > 0 && cdloadCount == 0 && push20Count == 0) {
                    console.log("  >> INTERESTING: Uses SLOAD without CALLDATALOAD or PUSH20");
                    console.log("  >> This might load an address from storage to delegatecall");
                }
            }
        }

        console.log("\nTotal DELEGATECALLs:", dcCount);
    }

    function test_TraceRedeemFunctionPath() public view {
        console.log("=== TRACING REDEEM FUNCTION PATH ===\n");

        // redeem(uint96) = 0x7630c4a8
        // finalizeRedeem(uint256) = 0xaff6cbf1

        bytes memory code = REDEMPTION_0.code;

        // Find where redeem function is in the bytecode
        bytes4 redeemSel = bytes4(0x7630c4a8);
        bytes4 finalizeSel = bytes4(0xaff6cbf1);

        console.log("Finding redeem(uint96) entry point:");
        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == redeemSel) {
                    console.log("  Found at offset:", i);

                    // Get JUMPDEST
                    for (uint j = i + 5; j < i + 30 && j + 3 < code.length; j++) {
                        if (uint8(code[j]) == 0x61) { // PUSH2
                            uint16 dest = uint16(uint8(code[j+1])) << 8 | uint16(uint8(code[j+2]));
                            console.log("  Jumps to:", dest);
                            break;
                        }
                    }
                }
            }
        }

        console.log("\nFinding finalizeRedeem(uint256) entry point:");
        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == finalizeSel) {
                    console.log("  Found at offset:", i);

                    for (uint j = i + 5; j < i + 30 && j + 3 < code.length; j++) {
                        if (uint8(code[j]) == 0x61) { // PUSH2
                            uint16 dest = uint16(uint8(code[j+1])) << 8 | uint16(uint8(code[j+2]));
                            console.log("  Jumps to:", dest);
                            break;
                        }
                    }
                }
            }
        }
    }

    function test_CheckIfDelegatecallIsInFinalizeRedeem() public view {
        console.log("=== CHECKING IF DELEGATECALL IS IN FINALIZEREDEEM ===\n");

        bytes memory code = REDEMPTION_0.code;

        // The DELEGATECALL at 5323 might be part of finalizeRedeem
        // Let's see if finalizeRedeem jumps somewhere between 5000-5400

        bytes4 finalizeSel = bytes4(0xaff6cbf1);

        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == finalizeSel) {
                    // Find all subsequent PUSH2 that could be internal jumps
                    for (uint j = i + 5; j < i + 100 && j + 3 < code.length; j++) {
                        if (uint8(code[j]) == 0x61) { // PUSH2
                            uint16 dest = uint16(uint8(code[j+1])) << 8 | uint16(uint8(code[j+2]));
                            console.log("finalizeRedeem PUSH2 at", j, "-> dest:", dest);
                        }
                    }
                    break;
                }
            }
        }
    }
}
