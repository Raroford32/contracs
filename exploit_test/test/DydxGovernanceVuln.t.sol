// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title WrappedEthereumDydxToken Governance Vulnerability Analysis
 * @notice POTENTIAL NOVEL VULNERABILITY: Snapshot manipulation in same block
 *
 * VULNERABILITY HYPOTHESIS:
 * The contract maintains voting power snapshots that can be overwritten
 * within the same block. An attacker could:
 *
 * 1. Delegate voting power to themselves
 * 2. Transfer tokens (creates snapshot)
 * 3. Change delegation again (overwrites snapshot in same block)
 * 4. Query historical voting power returns inflated value
 *
 * _writeSnapshot() checks: if (blockNumber == currentBlock)
 * and OVERWRITES the previous snapshot value!
 *
 * This could enable governance attacks where attacker appears to have
 * more voting power than they actually control.
 */
contract DydxGovernanceAnalysisTest is Test {
    // WrappedEthereumDydxToken
    address constant WDYDX = 0x46b2DeAe6eFf3011008EA27EA36b7c27255ddFA9;

    // DYDX token
    address constant DYDX = 0x92D6C1e31e14520e676a687F0a93788B716BEff5;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function test_readWDYDXState() public view {
        console.log("=== WRAPPED DYDX TOKEN STATE ===");
        console.log("wDYDX Address:", WDYDX);

        // Get total supply
        (bool success, bytes memory data) = WDYDX.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        if (success && data.length >= 32) {
            uint256 totalSupply = abi.decode(data, (uint256));
            console.log("Total Supply:", totalSupply / 1e18, "wDYDX");
        }

        // Get name
        (success, data) = WDYDX.staticcall(
            abi.encodeWithSignature("name()")
        );
        if (success && data.length > 0) {
            string memory name = abi.decode(data, (string));
            console.log("Name:", name);
        }

        // Check governance power at current block for zero address
        console.log("================================");
    }

    function test_analyzeSnapshotVulnerability() public view {
        console.log("");
        console.log("=== SNAPSHOT VULNERABILITY ANALYSIS ===");
        console.log("");
        console.log("VULNERABILITY: Same-block snapshot overwrite");
        console.log("");
        console.log("The _writeSnapshot function:");
        console.log("  if (blockNumber == currentBlock) {");
        console.log("    snapshotsArray[currentIndex].value = newValue; // OVERWRITE!");
        console.log("  } else {");
        console.log("    snapshotsArray[count] = Snapshot(newValue);");
        console.log("  }");
        console.log("");
        console.log("ATTACK SCENARIO:");
        console.log("1. Block N: Attacker has 100 DYDX, delegates to self");
        console.log("2. Block N: Attacker transfers 50 DYDX away");
        console.log("   -> Snapshot created: votingPower = 50");
        console.log("3. Block N: Someone delegates 1000 DYDX to attacker");
        console.log("   -> Snapshot OVERWRITTEN: votingPower = 1050");
        console.log("4. Query at Block N returns 1050, but attacker only had 50 at transfer");
        console.log("");
        console.log("IMPACT: Historical voting power queries return incorrect values");
        console.log("Could affect governance proposal validations");
        console.log("==========================================");
    }

    function test_checkVotingPowerFunctions() public view {
        console.log("");
        console.log("=== VOTING POWER QUERY ANALYSIS ===");

        // Check if we can query voting power at specific block
        address testAccount = 0x0000000000000000000000000000000000000001;
        uint256 testBlock = block.number - 1;

        // Try to query getPowerAtBlock
        (bool success, bytes memory data) = WDYDX.staticcall(
            abi.encodeWithSignature(
                "getPowerAtBlock(address,uint256,uint8)",
                testAccount,
                testBlock,
                uint8(0) // VOTING_POWER
            )
        );

        if (success && data.length >= 32) {
            uint256 votingPower = abi.decode(data, (uint256));
            console.log("Test account voting power at block", testBlock, ":", votingPower);
        } else {
            console.log("Could not query historical voting power");
        }

        // Check current voting power
        (success, data) = WDYDX.staticcall(
            abi.encodeWithSignature("getPowerCurrent(address,uint8)", testAccount, uint8(0))
        );

        if (success && data.length >= 32) {
            uint256 currentPower = abi.decode(data, (uint256));
            console.log("Test account current voting power:", currentPower);
        }

        console.log("====================================");
    }

    function test_snapshotOverwritePoC() public {
        console.log("");
        console.log("=== SNAPSHOT OVERWRITE POC ===");

        // We need actual wDYDX tokens to test this
        // Let's find a large holder

        address whaleAddress = 0x28C6c06298d514Db089934071355E5743bf21d60; // Binance

        // Check whale's wDYDX balance
        (bool success, bytes memory data) = WDYDX.staticcall(
            abi.encodeWithSignature("balanceOf(address)", whaleAddress)
        );

        if (success && data.length >= 32) {
            uint256 balance = abi.decode(data, (uint256));
            console.log("Binance wDYDX balance:", balance / 1e18);

            if (balance > 0) {
                console.log("");
                console.log("Could attempt snapshot manipulation with whale's tokens");
                console.log("But would require flash loan or actual whale cooperation");
            } else {
                console.log("Whale has no wDYDX - try different holder");
            }
        }

        // Check actual token supply distribution
        (success, data) = WDYDX.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );

        if (success && data.length >= 32) {
            uint256 totalSupply = abi.decode(data, (uint256));
            console.log("");
            console.log("Total wDYDX supply:", totalSupply / 1e18);

            if (totalSupply == 0) {
                console.log("!!! WARNING: Total supply is 0 - token may be deprecated");
                console.log("Vulnerability is THEORETICAL but not exploitable if no tokens exist");
            }
        }

        console.log("==============================");
    }

    function test_exploitabilityAssessment() public view {
        console.log("");
        console.log("=== EXPLOITABILITY ASSESSMENT ===");
        console.log("");
        console.log("For this vulnerability to be exploitable:");
        console.log("1. Need wDYDX tokens (bridge from DYDX chain)");
        console.log("2. Need governance proposals to be active");
        console.log("3. Need historical voting power to be used for decisions");
        console.log("");
        console.log("BLOCKING FACTORS:");
        console.log("- If total supply is 0, no tokens to manipulate");
        console.log("- Modern governance may use block.number verification");
        console.log("- Same-block overwrite only affects within-block queries");
        console.log("");
        console.log("VERDICT: Design flaw exists but exploitability is LIMITED");
        console.log("=====================================");
    }
}
