// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

contract IAUDelegatecallAnalysis is Test {
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeDelegatecallStorage() public view {
        console.log("=== ANALYZING IAU DELEGATECALL STORAGE ===\n");

        // DELEGATECALL at offset 492 has SLOAD at 471
        // This suggests it reads an address from storage to delegatecall to

        // Let's check various storage slots
        console.log("IAU storage slots 0-20:");
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(IAU, bytes32(i));
            if (slot != bytes32(0)) {
                address addr = address(uint160(uint256(slot)));
                console.log("Slot", i);
                console.logBytes32(slot);
                if (addr.code.length > 0) {
                    console.log("  -> Contract at:", addr);
                    console.log("     Code size:", addr.code.length);
                }
            }
        }
    }

    function test_IdentifyIAUFunctions() public pure {
        console.log("=== IDENTIFYING IAU FUNCTION SELECTORS ===\n");

        // Known selectors
        console.log("Known function selectors:");
        console.log("pendingOwner(): ");
        console.logBytes4(bytes4(keccak256("pendingOwner()")));
        console.log("transferOwnership(address):");
        console.logBytes4(bytes4(keccak256("transferOwnership(address)")));
        console.log("owner():");
        console.logBytes4(bytes4(keccak256("owner()")));
        console.log("symbol():");
        console.logBytes4(bytes4(keccak256("symbol()")));
        console.log("balanceOf(address):");
        console.logBytes4(bytes4(keccak256("balanceOf(address)")));
        console.log("renounceOwnership():");
        console.logBytes4(bytes4(keccak256("renounceOwnership()")));
        console.log("acceptOwnership():");
        console.logBytes4(bytes4(keccak256("acceptOwnership()")));
        console.log("burn(uint256):");
        console.logBytes4(bytes4(keccak256("burn(uint256)")));
        console.log("mint(address,uint256):");
        console.logBytes4(bytes4(keccak256("mint(address,uint256)")));
        console.log("transferFrom(address,address,uint256):");
        console.logBytes4(bytes4(keccak256("transferFrom(address,address,uint256)")));
        console.log("decimals():");
        console.logBytes4(bytes4(keccak256("decimals()")));
        console.log("name():");
        console.logBytes4(bytes4(keccak256("name()")));
        console.log("approve(address,uint256):");
        console.logBytes4(bytes4(keccak256("approve(address,uint256)")));
        console.log("totalSupply():");
        console.logBytes4(bytes4(keccak256("totalSupply()")));
        console.log("transfer(address,uint256):");
        console.logBytes4(bytes4(keccak256("transfer(address,uint256)")));
        console.log("allowance(address,address):");
        console.logBytes4(bytes4(keccak256("allowance(address,address)")));

        // Try to match unknown ones
        console.log("\nTrying to match unknown selectors:");
        console.log("addMinter(address):");
        console.logBytes4(bytes4(keccak256("addMinter(address)")));
        console.log("removeMinter(address):");
        console.logBytes4(bytes4(keccak256("removeMinter(address)")));
        console.log("isMinter(address):");
        console.logBytes4(bytes4(keccak256("isMinter(address)")));
        console.log("burnFrom(address,uint256):");
        console.logBytes4(bytes4(keccak256("burnFrom(address,uint256)")));

        // 0xbdacb303 and 0xd33219b4 are unknown
        console.log("\nSearching for 0xbdacb303 and 0xd33219b4:");
        console.log("setMinter(address):");
        console.logBytes4(bytes4(keccak256("setMinter(address)")));
        console.log("minter():");
        console.logBytes4(bytes4(keccak256("minter()")));
        console.log("setTreasury(address):");
        console.logBytes4(bytes4(keccak256("setTreasury(address)")));
        console.log("treasury():");
        console.logBytes4(bytes4(keccak256("treasury()")));
    }

    function test_TryIAUAdminFunctions() public {
        console.log("=== TRYING IAU ADMIN FUNCTIONS ===\n");

        vm.startPrank(attacker);

        // Try addMinter
        console.log("Trying addMinter(attacker)...");
        (bool success, ) = IAU.call(
            abi.encodeWithSignature("addMinter(address)", attacker)
        );
        console.log("Success:", success);

        // Try setMinter (0x983b2d56 might be addMinter)
        console.log("\nTrying 0x983b2d56(attacker)...");
        (success, ) = IAU.call(
            abi.encodeWithSelector(bytes4(0x983b2d56), attacker)
        );
        console.log("Success:", success);

        // Check if we're a minter
        bytes memory data;
        (success, data) = IAU.staticcall(
            abi.encodeWithSignature("isMinter(address)", attacker)
        );
        if (success && data.length == 32) {
            bool isMinter = abi.decode(data, (bool));
            console.log("\nAttacker is minter:", isMinter);
        }

        // Try 0xaa271e1a (might be isMinter)
        (success, data) = IAU.staticcall(
            abi.encodeWithSelector(bytes4(0xaa271e1a), attacker)
        );
        if (success && data.length == 32) {
            console.log("0xaa271e1a(attacker):", abi.decode(data, (bool)));
        }

        vm.stopPrank();
    }

    function test_AnalyzeIAUBytecodeDeeper() public view {
        console.log("=== DEEPER IAU BYTECODE ANALYSIS ===\n");

        bytes memory code = IAU.code;

        // Look at the specific DELEGATECALL at offset 492
        console.log("Analyzing DELEGATECALL at offset 492:");
        console.log("Bytecode around 470-510:");

        for (uint i = 470; i < 510 && i < code.length; i++) {
            uint8 op = uint8(code[i]);
            string memory opName;

            if (op == 0x54) opName = "SLOAD";
            else if (op == 0x55) opName = "SSTORE";
            else if (op == 0xf4) opName = "DELEGATECALL";
            else if (op == 0xf1) opName = "CALL";
            else if (op == 0xfa) opName = "STATICCALL";
            else if (op == 0x73) opName = "PUSH20";
            else if (op >= 0x60 && op <= 0x7f) opName = "PUSH";
            else if (op == 0x35) opName = "CALLDATALOAD";
            else if (op == 0x36) opName = "CALLDATASIZE";
            else if (op == 0x37) opName = "CALLDATACOPY";
            else opName = "";

            if (bytes(opName).length > 0) {
                console.log(i, opName, op);
            }
        }

        // The SLOAD at 471 might be loading from a specific slot
        // Let's trace what slot it loads from
        console.log("\nLooking for PUSH before SLOAD at 471:");
        for (uint i = 460; i < 471; i++) {
            uint8 op = uint8(code[i]);
            if (op >= 0x60 && op <= 0x7f) {
                uint8 pushSize = op - 0x5f;
                bytes memory value = new bytes(pushSize);
                for (uint j = 0; j < pushSize && i + 1 + j < code.length; j++) {
                    value[j] = code[i + 1 + j];
                }
                console.log("PUSH at", i, "value:");
                console.logBytes(value);
            }
        }
    }

    function test_CheckMintPermissions() public view {
        console.log("=== CHECKING MINT PERMISSIONS ===\n");

        // Check who can mint IAU
        // The Redemption controller might have mint permissions

        // Check if REDEMPTION_0 can mint
        (bool success, bytes memory data) = IAU.staticcall(
            abi.encodeWithSelector(bytes4(0xaa271e1a), REDEMPTION_0)
        );
        if (success && data.length == 32) {
            console.log("REDEMPTION_0 has minter role:", abi.decode(data, (bool)));
        }

        // Check REDEMPTION_CONTROLLER
        (success, data) = IAU.staticcall(
            abi.encodeWithSelector(bytes4(0xaa271e1a), REDEMPTION_CONTROLLER)
        );
        if (success && data.length == 32) {
            console.log("REDEMPTION_CONTROLLER has minter role:", abi.decode(data, (bool)));
        }

        // Check VAULT
        (success, data) = IAU.staticcall(
            abi.encodeWithSelector(bytes4(0xaa271e1a), VAULT)
        );
        if (success && data.length == 32) {
            console.log("VAULT has minter role:", abi.decode(data, (bool)));
        }

        // Check owner
        address owner = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;
        (success, data) = IAU.staticcall(
            abi.encodeWithSelector(bytes4(0xaa271e1a), owner)
        );
        if (success && data.length == 32) {
            console.log("Owner has minter role:", abi.decode(data, (bool)));
        }
    }
}
