// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// ============================================================================
// Balancer V2 WEI-LEVEL EXPLOITATION
// Testing at smallest units to find precision breaks
// Massive batch sizes: 100, 1000, 5000, 10000
// ============================================================================

interface IAsset {}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint256) external;
}

interface IVault {
    enum SwapKind { GIVEN_IN, GIVEN_OUT }
    enum UserBalanceOpKind { DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL }

    struct BatchSwapStep {
        bytes32 poolId;
        uint256 assetInIndex;
        uint256 assetOutIndex;
        uint256 amount;
        bytes userData;
    }

    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address payable recipient;
        bool toInternalBalance;
    }

    struct UserBalanceOp {
        UserBalanceOpKind kind;
        IAsset asset;
        uint256 amount;
        address sender;
        address payable recipient;
    }

    function batchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds, int256[] memory limits, uint256 deadline) external payable returns (int256[] memory);
    function queryBatchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds) external returns (int256[] memory);
    function manageUserBalance(UserBalanceOp[] memory ops) external payable;
    function getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);
}

contract BalancerWeiExploit is Test {
    IVault constant VAULT = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    IWETH constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20 constant BAL = IERC20(0xba100000625a3754423978a60c9317c58a424e3D);
    IAsset constant ETH = IAsset(address(0));

    bytes32 constant BAL_WETH_POOL = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014;

    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        attacker = address(this);
        vm.deal(attacker, 10000 ether);
        WETH.deposit{value: 5000 ether}();
        WETH.approve(address(VAULT), type(uint256).max);
        BAL.approve(address(VAULT), type(uint256).max);
    }

    // ========================================================================
    // TEST 1: Find breaking point in batch swap sizes
    // ========================================================================
    function test_FindBatchSwapBreakingPoint() public {
        console.log("=== FINDING BATCH SWAP BREAKING POINT ===");

        uint256[] memory sizes = new uint256[](10);
        sizes[0] = 10;
        sizes[1] = 50;
        sizes[2] = 100;
        sizes[3] = 200;
        sizes[4] = 500;
        sizes[5] = 1000;
        sizes[6] = 2000;
        sizes[7] = 3000;
        sizes[8] = 5000;
        sizes[9] = 10000;

        uint256 swapAmt = 1e15; // 0.001 ETH per swap

        for (uint256 s = 0; s < sizes.length; s++) {
            uint256 size = sizes[s];
            _testBatchSize(size, swapAmt);
        }
    }

    function _testBatchSize(uint256 size, uint256 swapAmt) internal {
        IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](size);
        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        for (uint256 i = 0; i < size; i++) {
            swaps[i] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: swapAmt,
                userData: ""
            });
        }

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        uint256 gas0 = gasleft();
        try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds) returns (int256[] memory d) {
            uint256 gasUsed = gas0 - gasleft();
            uint256 expected = swapAmt * size;
            uint256 actual = uint256(d[1]);
            console.log("Size", size, "- Gas:", gasUsed);
            if (actual != expected) {
                console.log("  MISMATCH! Expected:", expected, "Got:", actual);
            }
        } catch {
            console.log("Size", size, "- FAILED (gas limit or error)");
        }
    }

    // ========================================================================
    // TEST 2: Wei-level amount testing (1 to 10000 wei)
    // ========================================================================
    function test_WeiLevelAmounts() public {
        console.log("=== WEI-LEVEL AMOUNT TESTING ===");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Test amounts from 1 wei to 10000 wei
        uint256 zeroOutputCount = 0;
        uint256 firstNonZero = 0;

        for (uint256 amt = 1; amt <= 10000; amt++) {
            IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](1);
            swaps[0] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: amt,
                userData: ""
            });

            try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds) returns (int256[] memory d) {
                uint256 balOut = uint256(-d[0]);
                if (balOut == 0) {
                    zeroOutputCount++;
                } else if (firstNonZero == 0) {
                    firstNonZero = amt;
                    console.log("First non-zero output at:", amt, "wei -> BAL:", balOut);
                }
            } catch {
                // Skip failures
            }
        }

        console.log("Zero output count (1-10000 wei):", zeroOutputCount);
        console.log("First non-zero at:", firstNonZero, "wei");
    }

    // ========================================================================
    // TEST 3: Accumulated error over 1000 small swaps
    // ========================================================================
    function test_AccumulatedError1000Swaps() public {
        console.log("=== ACCUMULATED ERROR - 1000 SWAPS ===");

        uint256 numSwaps = 1000;
        uint256 swapAmt = 1e12; // 0.000001 ETH

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Query single swap
        IVault.BatchSwapStep[] memory single = new IVault.BatchSwapStep[](1);
        single[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: swapAmt,
            userData: ""
        });

        int256[] memory singleD = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, single, assets, funds);
        uint256 singleBalOut = uint256(-singleD[0]);

        // Query batch of 1000
        IVault.BatchSwapStep[] memory batch = new IVault.BatchSwapStep[](numSwaps);
        for (uint256 i = 0; i < numSwaps; i++) {
            batch[i] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: swapAmt,
                userData: ""
            });
        }

        int256[] memory batchD = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, batch, assets, funds);
        uint256 batchBalOut = uint256(-batchD[0]);

        uint256 expectedBal = singleBalOut * numSwaps;

        console.log("Single swap BAL out:", singleBalOut);
        console.log("Expected 1000x:", expectedBal);
        console.log("Actual batch BAL out:", batchBalOut);

        if (batchBalOut > expectedBal) {
            console.log("GAIN:", batchBalOut - expectedBal, "wei BAL");
        } else if (batchBalOut < expectedBal) {
            console.log("LOSS:", expectedBal - batchBalOut, "wei BAL");
        } else {
            console.log("EXACT MATCH");
        }
    }

    // ========================================================================
    // TEST 4: Divisibility edge cases (primes, powers of 2, etc)
    // ========================================================================
    function test_DivisibilityEdgeCases() public {
        console.log("=== DIVISIBILITY EDGE CASES ===");

        uint256[] memory testAmts = new uint256[](20);
        testAmts[0] = 1;          // smallest
        testAmts[1] = 2;
        testAmts[2] = 3;
        testAmts[3] = 7;          // prime
        testAmts[4] = 13;         // prime
        testAmts[5] = 17;         // prime
        testAmts[6] = 127;        // Mersenne prime
        testAmts[7] = 255;        // 2^8 - 1
        testAmts[8] = 256;        // 2^8
        testAmts[9] = 257;        // 2^8 + 1
        testAmts[10] = 1023;      // 2^10 - 1
        testAmts[11] = 1024;      // 2^10
        testAmts[12] = 1025;      // 2^10 + 1
        testAmts[13] = 65535;     // 2^16 - 1
        testAmts[14] = 65536;     // 2^16
        testAmts[15] = 16777215;  // 2^24 - 1
        testAmts[16] = 16777216;  // 2^24
        testAmts[17] = 4294967295;// 2^32 - 1
        testAmts[18] = 4294967296;// 2^32
        testAmts[19] = 1e9;       // 1 gwei

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        for (uint256 i = 0; i < testAmts.length; i++) {
            uint256 amt = testAmts[i];
            IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](1);
            swaps[0] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: amt,
                userData: ""
            });

            try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds) returns (int256[] memory d) {
                uint256 balOut = uint256(-d[0]);
                console.log("Amount:", amt, "-> BAL:", balOut);

                // Check ratio
                if (balOut > 0 && amt > 0) {
                    uint256 ratio = balOut * 1e18 / amt;
                    // Log if ratio is unusual
                }
            } catch {
                console.log("Amount:", amt, "-> FAILED");
            }
        }
    }

    // ========================================================================
    // TEST 5: Internal balance deposit/withdraw at wei level (5000 ops)
    // ========================================================================
    function test_InternalBalanceWeiLevel5000() public {
        console.log("=== INTERNAL BALANCE WEI LEVEL - 5000 OPS ===");

        // First deposit some WETH
        IVault.UserBalanceOp[] memory deposit = new IVault.UserBalanceOp[](1);
        deposit[0] = IVault.UserBalanceOp({
            kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
            asset: IAsset(address(WETH)),
            amount: 100 ether,
            sender: attacker,
            recipient: payable(attacker)
        });
        VAULT.manageUserBalance(deposit);

        IERC20[] memory tokens = new IERC20[](1);
        tokens[0] = IERC20(address(WETH));
        uint256 startBal = VAULT.getInternalBalance(attacker, tokens)[0];
        console.log("Starting internal balance:", startBal);

        // Do 5000 withdraw/deposit cycles of 1 wei each
        uint256 cycles = 2500; // 2500 * 2 = 5000 ops
        uint256 amt = 1; // 1 wei

        for (uint256 c = 0; c < cycles; c++) {
            IVault.UserBalanceOp[] memory ops = new IVault.UserBalanceOp[](2);
            ops[0] = IVault.UserBalanceOp({
                kind: IVault.UserBalanceOpKind.WITHDRAW_INTERNAL,
                asset: IAsset(address(WETH)),
                amount: amt,
                sender: attacker,
                recipient: payable(attacker)
            });
            ops[1] = IVault.UserBalanceOp({
                kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
                asset: IAsset(address(WETH)),
                amount: amt,
                sender: attacker,
                recipient: payable(attacker)
            });

            try VAULT.manageUserBalance(ops) {
                // continue
            } catch {
                console.log("Failed at cycle:", c);
                break;
            }

            if (c % 500 == 0 && c > 0) {
                uint256 currentBal = VAULT.getInternalBalance(attacker, tokens)[0];
                console.log("Cycle", c, "- Balance:", currentBal);
            }
        }

        uint256 endBal = VAULT.getInternalBalance(attacker, tokens)[0];
        console.log("Ending internal balance:", endBal);

        if (endBal != startBal) {
            console.log("!!! BALANCE CHANGED !!!");
            if (endBal > startBal) {
                console.log("GAIN:", endBal - startBal, "wei");
            } else {
                console.log("LOSS:", startBal - endBal, "wei");
            }
        }
    }

    // ========================================================================
    // TEST 6: ETH deposit accumulation test (1000 tiny deposits)
    // ========================================================================
    function test_ETHMicroDeposits1000() public {
        console.log("=== ETH MICRO DEPOSITS - 1000 OPS ===");

        uint256 numOps = 1000;
        uint256 amtPerOp = 1e9; // 1 gwei per deposit
        uint256 totalExpected = numOps * amtPerOp;

        IVault.UserBalanceOp[] memory ops = new IVault.UserBalanceOp[](numOps);
        for (uint256 i = 0; i < numOps; i++) {
            ops[i] = IVault.UserBalanceOp({
                kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL,
                asset: ETH,
                amount: amtPerOp,
                sender: attacker,
                recipient: payable(attacker)
            });
        }

        uint256 ethBefore = address(this).balance;

        try VAULT.manageUserBalance{value: totalExpected}(ops) {
            uint256 ethAfter = address(this).balance;
            uint256 ethSpent = ethBefore - ethAfter;

            IERC20[] memory tokens = new IERC20[](1);
            tokens[0] = IERC20(address(WETH));
            uint256 internalBal = VAULT.getInternalBalance(attacker, tokens)[0];

            console.log("Total expected:", totalExpected);
            console.log("ETH spent:", ethSpent);
            console.log("Internal WETH:", internalBal);

            if (internalBal != totalExpected) {
                console.log("!!! DISCREPANCY !!!");
                if (internalBal > totalExpected) {
                    console.log("EXTRA:", internalBal - totalExpected, "wei");
                } else {
                    console.log("MISSING:", totalExpected - internalBal, "wei");
                }
            }
        } catch Error(string memory r) {
            console.log("Failed:", r);
        }
    }

    // ========================================================================
    // TEST 7: Round trip at specific amounts to find exploitable gap
    // ========================================================================
    function test_RoundTripGapSearch() public {
        console.log("=== ROUND TRIP GAP SEARCH ===");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Test various amounts
        uint256[] memory testAmts = new uint256[](10);
        testAmts[0] = 1e15;      // 0.001 ETH
        testAmts[1] = 1e16;      // 0.01 ETH
        testAmts[2] = 1e17;      // 0.1 ETH
        testAmts[3] = 1e18;      // 1 ETH
        testAmts[4] = 5e18;      // 5 ETH
        testAmts[5] = 10e18;     // 10 ETH
        testAmts[6] = 50e18;     // 50 ETH
        testAmts[7] = 100e18;    // 100 ETH
        testAmts[8] = 500e18;    // 500 ETH
        testAmts[9] = 1000e18;   // 1000 ETH

        for (uint256 i = 0; i < testAmts.length; i++) {
            uint256 amt = testAmts[i];
            _checkRoundTrip(amt, assets, funds);
        }
    }

    function _checkRoundTrip(uint256 amt, IAsset[] memory assets, IVault.FundManagement memory funds) internal {
        // WETH -> BAL (GIVEN_IN)
        IVault.BatchSwapStep[] memory swap1 = new IVault.BatchSwapStep[](1);
        swap1[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: amt,
            userData: ""
        });

        try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swap1, assets, funds) returns (int256[] memory d1) {
            uint256 balGot = uint256(-d1[0]);

            // BAL -> WETH (GIVEN_IN)
            IVault.BatchSwapStep[] memory swap2 = new IVault.BatchSwapStep[](1);
            swap2[0] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 0,
                assetOutIndex: 1,
                amount: balGot,
                userData: ""
            });

            try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swap2, assets, funds) returns (int256[] memory d2) {
                uint256 wethBack = uint256(-d2[1]);
                uint256 loss = amt - wethBack;
                uint256 lossPct = loss * 10000 / amt; // basis points

                console.log("Amt (0.001 ETH):", amt / 1e15);
                console.log("  Loss (wei):", loss);
                console.log("  Loss (bps):", lossPct);

                // Now try GIVEN_OUT for second leg
                IVault.BatchSwapStep[] memory swap3 = new IVault.BatchSwapStep[](1);
                swap3[0] = IVault.BatchSwapStep({
                    poolId: BAL_WETH_POOL,
                    assetInIndex: 0,
                    assetOutIndex: 1,
                    amount: amt, // Want exactly amt WETH back
                    userData: ""
                });

                try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_OUT, swap3, assets, funds) returns (int256[] memory d3) {
                    uint256 balNeeded = uint256(d3[0]);
                    if (balGot > balNeeded) {
                        uint256 balProfit = balGot - balNeeded;
                        console.log("  GIVEN_OUT profit:", balProfit, "wei BAL");
                    }
                } catch {}
            } catch {}
        } catch {}
    }

    // ========================================================================
    // TEST 8: Massive sequential small swaps (try to break invariants)
    // ========================================================================
    function test_MassiveSequentialSwaps() public {
        console.log("=== MASSIVE SEQUENTIAL SWAPS (1000) ===");

        uint256 numSwaps = 1000;
        uint256 swapAmt = 1e14; // 0.0001 ETH each

        uint256 wethStart = WETH.balanceOf(attacker);
        uint256 balStart = BAL.balanceOf(attacker);

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        int256[] memory limits = new int256[](2);
        limits[0] = 0;
        limits[1] = int256(swapAmt * numSwaps);

        // Build batch of swaps
        IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](numSwaps);
        for (uint256 i = 0; i < numSwaps; i++) {
            swaps[i] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: swapAmt,
                userData: ""
            });
        }

        try VAULT.batchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds, limits, block.timestamp + 1000) returns (int256[] memory d) {
            uint256 wethEnd = WETH.balanceOf(attacker);
            uint256 balEnd = BAL.balanceOf(attacker);

            uint256 wethSpent = wethStart - wethEnd;
            uint256 balGot = balEnd - balStart;

            console.log("WETH spent:", wethSpent);
            console.log("BAL received:", balGot);

            uint256 expectedWeth = swapAmt * numSwaps;
            if (wethSpent != expectedWeth) {
                console.log("!!! WETH MISMATCH !!!");
                console.log("Expected:", expectedWeth);
            }
        } catch Error(string memory r) {
            console.log("Failed:", r);
        }
    }

    receive() external payable {}
}
