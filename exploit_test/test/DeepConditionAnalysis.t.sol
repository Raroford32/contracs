// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Deep Condition Analysis
 * @notice Investigate exact conditions needed to exploit each finding
 */

interface IChainlinkOracle {
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
    function decimals() external view returns (uint8);
    function description() external view returns (string memory);
}

interface IMorphoBlue {
    struct MarketParams {
        address loanToken;
        address collateralToken;
        address oracle;
        address irm;
        uint256 lltv;
    }

    struct Market {
        uint128 totalSupplyAssets;
        uint128 totalSupplyShares;
        uint128 totalBorrowAssets;
        uint128 totalBorrowShares;
        uint128 lastUpdate;
        uint128 fee;
    }

    function market(bytes32 id) external view returns (Market memory);
    function idToMarketParams(bytes32 id) external view returns (MarketParams memory);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function decimals() external view returns (uint8);
    function symbol() external view returns (string memory);
}

interface IComet {
    function getAssetInfo(uint8 i) external view returns (
        uint8 offset,
        address asset,
        address priceFeed,
        uint64 scale,
        uint64 borrowCollateralFactor,
        uint64 liquidateCollateralFactor,
        uint64 liquidationFactor,
        uint128 supplyCap
    );
    function numAssets() external view returns (uint8);
    function totalsCollateral(address asset) external view returns (uint128 totalSupplyAsset, uint128 _reserved);
    function getPrice(address priceFeed) external view returns (uint256);
    function baseToken() external view returns (address);
    function borrowBalanceOf(address account) external view returns (uint256);
}

interface IPriceFeed {
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
    function priceFeedA() external view returns (address);
    function priceFeedB() external view returns (address);
}

contract DeepConditionAnalysis is Test {
    // Morpho Blue
    address constant MORPHO_BLUE = 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb;

    // sUSDe related
    address constant SUSDE = 0x9D39A5DE30e57443BfF2A8307A4256c8797A3497;
    address constant USDE = 0x4c9EDD5852cd905f086C759E8383e09bff1E68B3;

    // Compound III
    address constant COMET_WETH = 0xA17581A9E3356d9A858b789D68B4d866e593aE94;
    address constant COMET_USDC = 0xc3d688B66703497DAA19211EEdff47f25384cdc3;

    // WBTC feed
    address constant WBTC_MULTIPLICATIVE_FEED = 0xd98Be00b5D27fc98112BdE293e487f8D4cA57d07;

    // Stale oracles found
    address constant USDE_ORACLE = 0xa569d910839Ae8865Da8F8e70FfFb0cBA869F961;
    address constant USDC_ORACLE = 0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6;

    string constant RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    function setUp() public {
        vm.createSelectFork(RPC_URL);
    }

    function test_ExactMultiplicativeFeedExploitThreshold() public view {
        console.log("=== EXACT EXPLOIT THRESHOLD FOR MULTIPLICATIVE FEED ===\n");

        IComet comet = IComet(COMET_WETH);

        // Get WBTC info (index 6)
        (,, address priceFeed,, uint64 borrowCF, uint64 liquidateCF,,) = comet.getAssetInfo(6);

        console.log("WBTC Borrow Collateral Factor:", borrowCF);
        console.log("WBTC Liquidate Collateral Factor:", liquidateCF);

        // borrowCF = 800000000000000000 = 0.8 = 80%
        // liquidateCF = 850000000000000000 = 0.85 = 85%

        // To profit from stale oracle:
        // 1. Oracle shows price P (stale, higher than real)
        // 2. Real price is P' (lower)
        // 3. Attacker deposits 1 WBTC valued at P
        // 4. Borrows 0.8 * P worth of WETH
        // 5. Real value of collateral is P'
        // 6. If P' < 0.8 * P, position is underwater

        // Breakeven: P' = 0.8 * P
        // Price drop needed: (P - P') / P = 1 - 0.8 = 20%

        console.log("\nExact calculation:");
        console.log("- At 80% borrow CF, need >20% oracle overvaluation to profit");
        console.log("- At 85% liquidate CF, position gets liquidated at 15% drop");

        // Get current prices
        IPriceFeed feed = IPriceFeed(priceFeed);
        address feedA = feed.priceFeedA();
        address feedB = feed.priceFeedB();

        (, int256 priceA,, uint256 updatedAtA,) = IChainlinkOracle(feedA).latestRoundData();
        (, int256 priceB,, uint256 updatedAtB,) = IChainlinkOracle(feedB).latestRoundData();

        uint256 stalenessA = block.timestamp - updatedAtA;
        uint256 stalenessB = block.timestamp - updatedAtB;

        console.log("\nCurrent staleness:");
        console.log("  Feed A (WBTC/BTC):", stalenessA / 60, "min");
        console.log("  Feed B (BTC/ETH):", stalenessB / 60, "min");

        // Check historical volatility - BTC can move 5-10% in hours during high vol
        console.log("\nHistorical context:");
        console.log("- BTC typically moves 2-5% per day");
        console.log("- During high volatility: 10-20% swings possible");
        console.log("- 10 hour staleness could mean 5-10% price divergence during vol");

        // Calculate exact profit at different divergence levels
        console.log("\nProfit scenarios (1 WBTC = ~29.5 ETH):");
        uint256 wbtcPriceEth = uint256(priceA) * uint256(priceB) / 1e8; // Combined price

        console.log("  At 5% divergence: Borrower loses (underwater)");
        console.log("  At 10% divergence: Borrower loses (underwater)");
        console.log("  At 15% divergence: Position liquidatable, small loss");
        console.log("  At 20% divergence: BREAKEVEN");
        console.log("  At 25% divergence: ~5% profit on borrowed amount");

        // The key insight: during flash crashes, 20%+ moves happen
        console.log("\n=== CONDITION NEEDED ===");
        console.log("Wait for BTC flash crash >20% while oracle is stale");
        console.log("Then deposit WBTC at stale (high) price, borrow WETH, keep it");
    }

    function test_FindMorphoMarketsWithSUSDe() public view {
        console.log("=== MORPHO BLUE sUSDe MARKET SEARCH ===\n");

        // Known Morpho Blue market IDs with sUSDe
        // These can be found from Morpho's subgraph or event logs

        bytes32[] memory knownMarketIds = new bytes32[](5);
        // Common sUSDe market IDs (from Morpho docs/subgraph)
        knownMarketIds[0] = 0x39d11026eae1c6ec02aa4c0f5e5e4c63b9c5e6d7b8f9c0a1b2c3d4e5f6a7b8c9;
        knownMarketIds[1] = 0xb323495f7e4148be5643a4ea4a8221eef163e4bccfdedc2a6f4696baacbc86cc;
        knownMarketIds[2] = 0xdc5333039bcf15f1237f7f20dbf455f2e0e77e77e77e77e77e77e77e77e77e77;

        console.log("Checking Morpho Blue contract for sUSDe markets...");
        console.log("sUSDe address:", SUSDE);

        // Check sUSDe balance in Morpho
        uint256 morphoSUSDeBalance = IERC20(SUSDE).balanceOf(MORPHO_BLUE);
        console.log("sUSDe in Morpho Blue:", morphoSUSDeBalance / 1e18, "sUSDe");

        // Check if there are significant deposits
        if (morphoSUSDeBalance > 1_000_000e18) {
            console.log("\n*** SIGNIFICANT sUSDe IN MORPHO ***");
            console.log("This creates oracle dependency risk");
        }

        console.log("\nKey insight:");
        console.log("- Morpho Blue markets use external oracles");
        console.log("- If oracle reports stale/wrong price:");
        console.log("  1. Borrow at inflated collateral value");
        console.log("  2. Or liquidate positions unfairly");
    }

    function test_FindProtocolsUsingStaleOracles() public view {
        console.log("=== PROTOCOLS USING STALE ORACLES ===\n");

        // Check USDe oracle staleness
        (, int256 usdePrice,, uint256 usdeUpdatedAt,) = IChainlinkOracle(USDE_ORACLE).latestRoundData();
        uint256 usdeStaleness = block.timestamp - usdeUpdatedAt;

        console.log("USDe Oracle:");
        console.log("  Price:", uint256(usdePrice));
        console.log("  Staleness:", usdeStaleness / 60, "minutes");
        console.log("  Staleness:", usdeStaleness / 3600, "hours");

        // Check USDC oracle
        (, int256 usdcPrice,, uint256 usdcUpdatedAt,) = IChainlinkOracle(USDC_ORACLE).latestRoundData();
        uint256 usdcStaleness = block.timestamp - usdcUpdatedAt;

        console.log("\nUSDC Oracle:");
        console.log("  Price:", uint256(usdcPrice));
        console.log("  Staleness:", usdcStaleness / 60, "minutes");

        // Check Compound III USDC market for stale dependencies
        console.log("\n--- Compound III USDC Market Oracle Analysis ---");
        IComet cometUSDC = IComet(COMET_USDC);
        uint8 numAssets = cometUSDC.numAssets();

        for (uint8 i = 0; i < numAssets; i++) {
            (,address asset, address assetPriceFeed,, uint64 borrowCF,,,) = cometUSDC.getAssetInfo(i);

            try IChainlinkOracle(assetPriceFeed).latestRoundData() returns (
                uint80, int256 price, uint256, uint256 updatedAt, uint80
            ) {
                uint256 staleness = block.timestamp - updatedAt;
                if (staleness > 3600) { // More than 1 hour
                    console.log("\nSTALE ORACLE FOUND in Comet USDC:");
                    console.log("  Asset index:", i);
                    console.log("  Asset:", asset);
                    console.log("  Staleness:", staleness / 3600, "hours");
                    console.log("  Borrow CF:", borrowCF);

                    // Check TVL
                    (uint128 totalSupply,) = cometUSDC.totalsCollateral(asset);
                    if (totalSupply > 0) {
                        console.log("  Total Supply:", totalSupply);
                    }
                }
            } catch {}
        }
    }

    function test_AnalyzeCurvestETHOracleUsers() public view {
        console.log("=== CURVESTETH ORACLE USER SEARCH ===\n");

        // The CurvestETHsdVaultV2 at issue
        address curvestETHOracle = 0x1f426C51F0Ef7655A6f4c3Eb58017d2F1c381bfF;

        console.log("Checking if CurvestETHsdVaultV2 oracle is used...");
        console.log("Oracle address:", curvestETHOracle);

        // Check if Compound III uses it
        console.log("\nChecking Compound III markets...");

        IComet cometWETH = IComet(COMET_WETH);
        uint8 numAssetsWETH = cometWETH.numAssets();

        for (uint8 i = 0; i < numAssetsWETH; i++) {
            (,address asset, address assetPriceFeed,,,,, ) = cometWETH.getAssetInfo(i);
            if (assetPriceFeed == curvestETHOracle) {
                console.log("FOUND: Compound III WETH uses CurvestETH oracle!");
                console.log("  Asset:", asset);
                console.log("  Index:", i);
            }
        }

        IComet cometUSDC = IComet(COMET_USDC);
        uint8 numAssetsUSDC = cometUSDC.numAssets();

        for (uint8 i = 0; i < numAssetsUSDC; i++) {
            (,address asset, address assetPriceFeed,,,,, ) = cometUSDC.getAssetInfo(i);
            if (assetPriceFeed == curvestETHOracle) {
                console.log("FOUND: Compound III USDC uses CurvestETH oracle!");
                console.log("  Asset:", asset);
                console.log("  Index:", i);
            }
        }

        console.log("\nNote: Need to search other protocols (Aave, Morpho, etc.)");
    }

    function test_CalculateExactMorphoExploitConditions() public view {
        console.log("=== MORPHO BLUE EXACT EXPLOIT CONDITIONS ===\n");

        // Morpho Blue uses LLTV (Liquidation Loan-To-Value)
        // Common LLTVs: 77%, 86%, 94.5%, 96.5%

        uint256[] memory lltvsWei = new uint256[](4);
        lltvsWei[0] = 770000000000000000; // 77%
        lltvsWei[1] = 860000000000000000; // 86%
        lltvsWei[2] = 945000000000000000; // 94.5%
        lltvsWei[3] = 965000000000000000; // 96.5%

        console.log("Morpho Blue LLTV Analysis:");
        console.log("(Price divergence needed to profit from stale oracle)\n");

        for (uint i = 0; i < 4; i++) {
            uint256 lltv = lltvsWei[i];
            // Divergence needed = 1 - LLTV
            uint256 divergenceNeeded = 1e18 - lltv;
            uint256 divergencePercent = divergenceNeeded * 100 / 1e18;

            console.log("LLTV:", lltv / 1e16, "%");
            console.log("  Divergence needed:", divergencePercent, "%");

            if (divergencePercent <= 10) {
                console.log("  *** EXPLOITABLE WITH 10% PRICE MOVE ***");
            }
        }

        console.log("\nKey insight:");
        console.log("- 94.5% LLTV market needs only 5.5% divergence!");
        console.log("- 96.5% LLTV market needs only 3.5% divergence!");
        console.log("- These high LLTV markets are MUCH more vulnerable");

        // Check sUSDe balance again for context
        uint256 morphoSUSDeBalance = IERC20(SUSDE).balanceOf(MORPHO_BLUE);
        console.log("\nsUSDe in Morpho:", morphoSUSDeBalance / 1e18);
        console.log("If in high-LLTV market, 5% price discrepancy = exploitable");
    }
}
