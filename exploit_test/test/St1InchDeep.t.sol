// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title St1Inch Deep Analysis
 * @notice withdraw() succeeds - analyze what it does
 */
contract St1InchDeepTest is Test {

    address st1INCH;
    address oneInch;
    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        st1INCH = vm.parseAddress("0x9A0C8Ff858d273f57072D714bca7411D717501D7");
        oneInch = vm.parseAddress("0x111111111117dC0aa78b770fA6A738034120C302");
        attacker = address(0xBEEF);
    }

    function test_withdrawDeep() public {
        console.log("=== ST1INCH WITHDRAW DEEP ANALYSIS ===");

        // Get attacker 1INCH balance before
        (bool s, bytes memory d) = oneInch.staticcall(
            abi.encodeWithSignature("balanceOf(address)", attacker)
        );
        uint256 oneInchBefore;
        if (s && d.length >= 32) {
            oneInchBefore = abi.decode(d, (uint256));
            console.log("Attacker 1INCH before:", oneInchBefore);
        }

        // Get attacker st1INCH balance before
        (s, d) = st1INCH.staticcall(
            abi.encodeWithSignature("balanceOf(address)", attacker)
        );
        uint256 st1InchBefore;
        if (s && d.length >= 32) {
            st1InchBefore = abi.decode(d, (uint256));
            console.log("Attacker st1INCH before:", st1InchBefore);
        }

        // Check st1INCH total 1INCH holdings
        (s, d) = oneInch.staticcall(
            abi.encodeWithSignature("balanceOf(address)", st1INCH)
        );
        if (s && d.length >= 32) {
            uint256 holdings = abi.decode(d, (uint256));
            console.log("st1INCH 1INCH holdings:", holdings / 1e18);
        }

        console.log("");
        console.log("Calling withdraw()...");

        vm.startPrank(attacker);
        (s,) = st1INCH.call(abi.encodeWithSignature("withdraw()"));
        console.log("withdraw result:", s ? "SUCCESS" : "FAILED");
        vm.stopPrank();

        // Get attacker 1INCH balance after
        (s, d) = oneInch.staticcall(
            abi.encodeWithSignature("balanceOf(address)", attacker)
        );
        uint256 oneInchAfter;
        if (s && d.length >= 32) {
            oneInchAfter = abi.decode(d, (uint256));
            console.log("Attacker 1INCH after:", oneInchAfter);
        }

        if (oneInchAfter > oneInchBefore) {
            console.log("!!! PROFIT:", (oneInchAfter - oneInchBefore) / 1e18, "1INCH");
        } else {
            console.log("No 1INCH profit - withdraw() is likely a noop without balance");
        }
    }

    function test_checkWithdrawableAmount() public {
        console.log("=== CHECK WITHDRAWABLE AMOUNTS ===");

        // Check if there's a withdrawable mapping
        (bool s, bytes memory d) = st1INCH.staticcall(
            abi.encodeWithSignature("withdrawable(address)", attacker)
        );
        if (s && d.length >= 32) {
            uint256 withdrawable = abi.decode(d, (uint256));
            console.log("Attacker withdrawable:", withdrawable);
        }

        // Check podVotingPower
        (s, d) = st1INCH.staticcall(
            abi.encodeWithSignature("podVotingPower(address)", attacker)
        );
        if (s && d.length >= 32) {
            uint256 power = abi.decode(d, (uint256));
            console.log("Attacker voting power:", power);
        }

        // Check earlyWithdrawal
        (s, d) = st1INCH.staticcall(
            abi.encodeWithSignature("earlyWithdraw()"));
        console.log("earlyWithdraw call result:", s);
    }

    function test_findStakersWithBalance() public {
        console.log("=== FINDING STAKERS WITH BALANCE ===");

        // Try some known addresses that might have stakes
        address[] memory potentialStakers = new address[](5);
        potentialStakers[0] = vm.parseAddress("0xDEAD000000000000000000000000000000000000");
        potentialStakers[1] = vm.parseAddress("0x2c9B2DBdbA8A9c969Ac24153f5C1c23CB0E63914");
        potentialStakers[2] = vm.parseAddress("0x111111125421cA6dc452d289314280a0f8842A65");
        potentialStakers[3] = vm.parseAddress("0x1111111254EEB25477B68fb85Ed929f73A960582");
        potentialStakers[4] = vm.parseAddress("0x56Eddb7aa87536c09CCc2793473599fD21A8b17F");

        for (uint i = 0; i < potentialStakers.length; i++) {
            address staker = potentialStakers[i];
            (bool s, bytes memory d) = st1INCH.staticcall(
                abi.encodeWithSignature("balanceOf(address)", staker)
            );
            if (s && d.length >= 32) {
                uint256 bal = abi.decode(d, (uint256));
                if (bal > 0) {
                    console.log("Staker", i, "balance:", bal / 1e18);
                }
            }
        }
    }

    function test_analyzeContractFunctions() public {
        console.log("=== ST1INCH CONTRACT ANALYSIS ===");

        // Check locked tokens
        (bool s, bytes memory d) = st1INCH.staticcall(
            abi.encodeWithSignature("lockedTokens(address)", attacker)
        );
        if (s && d.length >= 32) {
            uint256 locked = abi.decode(d, (uint256));
            console.log("Attacker locked tokens:", locked);
        }

        // Check if there's a deposit function that might be exploitable
        vm.startPrank(attacker);
        vm.deal(attacker, 10 ether);

        // Try depositing 0
        (s,) = st1INCH.call(abi.encodeWithSignature("deposit(uint256)", 0));
        console.log("deposit(0):", s ? "SUCCESS" : "FAILED");

        // Try depositing with no prior approval
        (s,) = st1INCH.call(abi.encodeWithSignature("deposit(uint256,uint256)", 1e18, 0));
        console.log("deposit(1e18,0):", s ? "SUCCESS" : "FAILED");

        vm.stopPrank();
    }
}
