// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title USDe Real Price Check
 * @notice Check actual DEX price of USDe vs Oracle
 */

interface ICurvePool {
    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);
    function coins(uint256 i) external view returns (address);
}

interface IUniswapV3Pool {
    function slot0() external view returns (
        uint160 sqrtPriceX96,
        int24 tick,
        uint16 observationIndex,
        uint16 observationCardinality,
        uint16 observationCardinalityNext,
        uint8 feeProtocol,
        bool unlocked
    );
    function token0() external view returns (address);
    function token1() external view returns (address);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function decimals() external view returns (uint8);
}

interface IAavePool {
    struct ReserveData {
        uint256 configuration;
        uint128 liquidityIndex;
        uint128 currentLiquidityRate;
        uint128 variableBorrowIndex;
        uint128 currentVariableBorrowRate;
        uint128 currentStableBorrowRate;
        uint40 lastUpdateTimestamp;
        uint16 id;
        address aTokenAddress;
        address stableDebtTokenAddress;
        address variableDebtTokenAddress;
        address interestRateStrategyAddress;
        uint128 accruedToTreasury;
        uint128 unbacked;
        uint128 isolationModeTotalDebt;
    }
    function getReserveData(address asset) external view returns (ReserveData memory);
}

contract USDeRealPriceCheck is Test {
    // USDe
    address constant USDE = 0x4c9EDD5852cd905f086C759E8383e09bff1E68B3;
    address constant SUSDE = 0x9D39A5DE30e57443BfF2A8307A4256c8797A3497;

    // Stablecoins
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;

    // Curve pools
    address constant CURVE_USDE_USDC = 0x02950460E2b9529D0E00284A5fA2d7bDF3fA4d72;

    // Aave V3
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;

    // Flash loan sources
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

    string constant RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    function setUp() public {
        vm.createSelectFork(RPC_URL);
    }

    function test_CheckCurveUSDePrice() public view {
        console.log("=== CURVE USDe PRICE CHECK ===\n");

        // Check USDe/USDC Curve pool
        ICurvePool pool = ICurvePool(CURVE_USDE_USDC);

        // Get price: how much USDC for 1000 USDe?
        uint256 usdeAmount = 1000e18;

        try pool.get_dy(0, 1, usdeAmount) returns (uint256 usdcOut) {
            console.log("Curve USDe->USDC:");
            console.log("  Input: 1000 USDe");
            console.log("  Output:", usdcOut / 1e6, "USDC");

            // Calculate implied price
            // If 1000 USDe = X USDC, then 1 USDe = X/1000 USDC
            uint256 pricePerUSDe = usdcOut * 1e12 / usdeAmount; // Normalize to 18 decimals
            console.log("  Price: $", pricePerUSDe / 1e14, "/ 10000");

            // Compare with oracle price of $0.999
            // If DEX price < $0.92 (8% below), exploit works
            if (usdcOut < 920e6) {
                console.log("\n*** DEX PRICE >8% BELOW ORACLE - EXPLOITABLE! ***");
            } else {
                console.log("\n  DEX price within normal range");
            }
        } catch {
            console.log("  Failed to query Curve pool");
        }
    }

    function test_CheckFlashLoanSources() public view {
        console.log("=== FLASH LOAN SOURCE CHECK ===\n");

        // Check Balancer
        uint256 balancerSUSDe = IERC20(SUSDE).balanceOf(BALANCER_VAULT);
        uint256 balancerUSDe = IERC20(USDE).balanceOf(BALANCER_VAULT);
        console.log("Balancer Vault:");
        console.log("  sUSDe:", balancerSUSDe / 1e18);
        console.log("  USDe:", balancerUSDe / 1e18);

        // Check Aave V3
        console.log("\nAave V3:");

        try IAavePool(AAVE_POOL).getReserveData(USDE) returns (IAavePool.ReserveData memory data) {
            uint256 aaveUSDe = IERC20(USDE).balanceOf(data.aTokenAddress);
            console.log("  USDe aToken:", data.aTokenAddress);
            console.log("  USDe available:", aaveUSDe / 1e18);
        } catch {
            console.log("  USDe not listed on Aave");
        }

        try IAavePool(AAVE_POOL).getReserveData(SUSDE) returns (IAavePool.ReserveData memory data) {
            uint256 aaveSUSDe = IERC20(SUSDE).balanceOf(data.aTokenAddress);
            console.log("  sUSDe aToken:", data.aTokenAddress);
            console.log("  sUSDe available:", aaveSUSDe / 1e18);
        } catch {
            console.log("  sUSDe not listed on Aave");
        }

        // Check major lending protocols
        console.log("\nNote: Could also check:");
        console.log("- Spark Protocol");
        console.log("- Maker vaults");
        console.log("- Other lending protocols");
    }

    function test_FullExploitViability() public view {
        console.log("=== FULL EXPLOIT VIABILITY CHECK ===\n");

        // 1. Check oracle staleness
        console.log("1. Oracle Status:");
        console.log("   USDe oracle: 13+ hours stale [CONDITION MET]");

        // 2. Check price divergence
        console.log("\n2. Price Divergence:");
        console.log("   Oracle price: $0.999");

        ICurvePool pool = ICurvePool(CURVE_USDE_USDC);
        try pool.get_dy(0, 1, 1000e18) returns (uint256 usdcOut) {
            uint256 dexPrice = usdcOut * 1e12 / 1000e18;
            console.log("   DEX price: ~$", usdcOut / 1e6, "/1000 USDe");

            uint256 oraclePrice = 999e15; // $0.999
            if (dexPrice < oraclePrice * 92 / 100) {
                console.log("   Divergence: >8% [CONDITION MET]");
            } else {
                uint256 divergence = (oraclePrice - dexPrice) * 100 / oraclePrice;
                console.log("   Divergence:", divergence, "% [CONDITION NOT MET]");
            }
        } catch {
            console.log("   Could not check DEX price");
        }

        // 3. Check flash loan availability
        console.log("\n3. Flash Loan Availability:");
        uint256 balancerSUSDe = IERC20(SUSDE).balanceOf(BALANCER_VAULT);
        if (balancerSUSDe > 100000e18) {
            console.log("   sUSDe in Balancer:", balancerSUSDe / 1e18, "[SUFFICIENT]");
        } else {
            console.log("   sUSDe in Balancer:", balancerSUSDe / 1e18, "[INSUFFICIENT]");
            console.log("   Need alternative flash loan source");
        }

        // 4. Check target market liquidity
        console.log("\n4. Target Market Liquidity:");
        console.log("   sUSDe/DAI 91.5% LLTV market");
        console.log("   Available to borrow: $254,460 DAI");

        // 5. Summary
        console.log("\n=== SUMMARY ===");
        console.log("BLOCKERS:");
        console.log("1. USDe has NOT depegged (still at ~$0.999)");
        console.log("2. Limited sUSDe flash loan sources");
        console.log("");
        console.log("EXPLOIT WOULD WORK IF:");
        console.log("- USDe depegs to <$0.92 (>8% from oracle)");
        console.log("- While oracle remains stale");
        console.log("- Flash loan source found");
    }
}
