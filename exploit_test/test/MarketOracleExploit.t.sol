// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";

interface IMarket {
    function deposit(uint256 amount) external;
    function withdraw(uint256 amount) external;
    function borrow(uint256 amount) external;
    function repay(address user, uint256 amount) external;
    function liquidate(address user, uint256 repaidDebt) external;
    function forceReplenish(address user, uint256 amount) external;
    function debts(address) external view returns (uint256);
    function escrows(address) external view returns (address);
    function getCreditLimit(address user) external view returns (uint256);
    function getCollateralValue(address user) external view returns (uint256);
    function oracle() external view returns (address);
    function collateral() external view returns (address);
    function collateralFactorBps() external view returns (uint256);
    function liquidationIncentiveBps() external view returns (uint256);
    function liquidationFactorBps() external view returns (uint256);
    function totalDebt() external view returns (uint256);
    function gov() external view returns (address);
    function dola() external view returns (address);
    function lender() external view returns (address);
}

interface IOracle {
    function getPrice(address token, uint256 collateralFactorBps) external returns (uint256);
    function viewPrice(address token, uint256 collateralFactorBps) external view returns (uint256);
    function feeds(address) external view returns (address);
}

interface IEscrow {
    function balance() external view returns (uint256);
    function pay(address recipient, uint256 amount) external;
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

interface IChainlinkFeed {
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
    function decimals() external view returns (uint8);
}

contract MarketOracleExploit is Test {
    address constant INV_MARKET = 0x63Df5e23Db45a2066508318f172bA45B9CD37035;
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant DOLA = 0x865377367054516e17014CcdED1e7d814EDC9ce4;

    address attacker = makeAddr("attacker");

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testAnalyzeOracleType() public {
        IMarket market = IMarket(INV_MARKET);
        address oracleAddr = market.oracle();

        console.log("=== Oracle Analysis ===");
        console.log("Oracle Address:", oracleAddr);

        IOracle oracle = IOracle(oracleAddr);

        try oracle.feeds(WETH) returns (address feed) {
            console.log("WETH Feed:", feed);

            if (feed != address(0)) {
                IChainlinkFeed chainlinkFeed = IChainlinkFeed(feed);

                try chainlinkFeed.latestRoundData() returns (
                    uint80,
                    int256 answer,
                    uint256,
                    uint256 updatedAt,
                    uint80
                ) {
                    console.log("Feed Price:", uint256(answer));
                    console.log("Age (seconds):", block.timestamp - updatedAt);
                    console.log("Oracle Type: Chainlink - NOT manipulable in single tx");
                } catch {
                    console.log("Not standard Chainlink");
                }
            }
        } catch {
            console.log("feeds() not available");
        }

        uint256 cf = market.collateralFactorBps();
        uint256 price = oracle.viewPrice(WETH, cf);
        console.log("WETH Price:", price);
    }

    function testFindLiquidatablePositions() public {
        IMarket market = IMarket(INV_MARKET);

        console.log("=== Liquidatable Positions Check ===");
        console.log("Total Market Debt:", market.totalDebt());
        console.log("Liquidation Incentive:", market.liquidationIncentiveBps(), "bps");
        console.log("Liquidation Factor:", market.liquidationFactorBps(), "bps");
        console.log("Collateral Factor:", market.collateralFactorBps(), "bps");

        // The market uses Chainlink oracle - not manipulable
        // Liquidations are MEV opportunity but require underwater positions
        console.log("");
        console.log("Liquidation requires naturally underwater positions");
        console.log("Cannot artificially create liquidatable positions");
    }

    function testForceReplenishAnalysis() public {
        console.log("=== ForceReplenish Analysis ===");
        console.log("ForceReplenish adds debt to users with DBR deficit");
        console.log("Caller receives DOLA reward from the debt increase");
        console.log("This is designed behavior - not an exploit");
        console.log("Would need DBR contract bug to exploit");
    }

    function testLiquidationMath() public {
        IMarket market = IMarket(INV_MARKET);
        IOracle oracle = IOracle(market.oracle());

        console.log("=== Liquidation Math Check ===");

        uint256 cf = market.collateralFactorBps();
        uint256 price = oracle.viewPrice(WETH, cf);
        uint256 incentive = market.liquidationIncentiveBps();

        console.log("Collateral Price:", price);
        console.log("Collateral Factor:", cf);
        console.log("Liquidation Incentive:", incentive);

        // liquidatorReward = repaidDebt * 1e18 / price
        // liquidatorReward += liquidatorReward * incentive / 10000

        // Example: repay 1000 DOLA debt
        uint256 repaidDebt = 1000e18;
        uint256 baseReward = (repaidDebt * 1e18) / price;
        uint256 totalReward = baseReward + (baseReward * incentive / 10000);

        console.log("");
        console.log("Example: Repay 1000 DOLA");
        console.log("Base Reward (ETH):", baseReward);
        console.log("Total Reward with incentive:", totalReward);

        // The liquidator profits by the incentive amount
        // But they need the user to actually be underwater first
    }
}
