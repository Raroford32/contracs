// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function decimals() external view returns (uint8);
}

interface IWETH {
    function deposit() external payable;
    function withdraw(uint256) external;
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

interface IBalancerVault {
    function flashLoan(
        address recipient,
        address[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;
}

contract NovelExploitSearch is Test {
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address constant AAVE_V3 = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testBalancerFlashLoanCapability() public view {
        console.log("=====================================================");
        console.log("BALANCER VAULT FLASH LOAN ANALYSIS");
        console.log("=====================================================");

        // Balancer vault holds massive liquidity and has FREE flash loans
        uint256 wethInVault = IERC20(WETH).balanceOf(BALANCER_VAULT);
        console.log("WETH in Balancer Vault:", wethInVault / 1e18);

        address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
        uint256 usdcInVault = IERC20(USDC).balanceOf(BALANCER_VAULT);
        console.log("USDC in Balancer Vault:", usdcInVault / 1e6);

        address DAI = 0x6B175474e89094c44Da98B954eEdEcd73F8F3d85;
        uint256 daiInVault = IERC20(DAI).balanceOf(BALANCER_VAULT);
        console.log("DAI in Balancer Vault:", daiInVault / 1e18);

        console.log("\nBalancer flash loans are FREE (0% fee)!");
    }

    function testSearchForDonationVulnerabilities() public {
        console.log("=====================================================");
        console.log("SEARCHING FOR DONATION ATTACK SURFACES");
        console.log("=====================================================");

        // ERC4626 vaults can be vulnerable to donation attacks
        // if they use balanceOf() instead of internal accounting

        address[5] memory vaults = [
            0xa354F35829Ae975e850e23e9615b11Da1B3dC4DE, // yvUSDC
            0xdA816459F1AB5631232FE5e97a05BBBb94970c95, // yvDAI
            0xB8C3B7A2A618C552C23B1E4701109a9E756Bab67, // Yearn DAI
            0x27b7b1ad7288079A66d12350c828D3C00A6F07d7, // Yearn
            0x378cb52b00F9D0921cb46dFc099CFf73b42419dC  // Yearn LUSD
        ];

        for (uint i = 0; i < vaults.length; i++) {
            address vault = vaults[i];
            if (vault.code.length == 0) continue;

            // Check if vault uses asset() or token()
            (bool s1, bytes memory d1) = vault.staticcall(
                abi.encodeWithSignature("asset()")
            );
            address asset;
            if (s1 && d1.length >= 32) {
                asset = abi.decode(d1, (address));
            } else {
                (s1, d1) = vault.staticcall(
                    abi.encodeWithSignature("token()")
                );
                if (s1 && d1.length >= 32) {
                    asset = abi.decode(d1, (address));
                }
            }

            if (asset == address(0)) continue;

            uint256 assetBalance = IERC20(asset).balanceOf(vault);
            (s1, d1) = vault.staticcall(abi.encodeWithSignature("totalAssets()"));
            uint256 totalAssets = 0;
            if (s1 && d1.length >= 32) {
                totalAssets = abi.decode(d1, (uint256));
            }

            console.log("\n--- Vault:", vault, "---");
            console.log("Asset:", asset);
            console.log("Balance of asset:", assetBalance / 1e18);
            console.log("Total Assets:", totalAssets / 1e18);

            // Check for discrepancy (donation attack possible if balanceOf > totalAssets)
            if (assetBalance > totalAssets + 1e15) {
                console.log("*** DONATION PRESENT ***");
                console.log("Excess:", (assetBalance - totalAssets) / 1e18);
            }
        }
    }

    function testCheckEigenLayerRestaking() public view {
        console.log("=====================================================");
        console.log("EIGENLAYER RESTAKING ANALYSIS");
        console.log("=====================================================");

        // EigenLayer has massive TVL - check for any exploitable patterns
        address eigenStrategy = 0x93c4b944D05dfe6df7645A86cd2206016c51564D; // stETH Strategy
        address eigenManager = 0x858646372CC42E1A627fcE94aa7A7033e7CF075A; // Strategy Manager

        console.log("stETH Strategy:", eigenStrategy);
        console.log("Strategy Manager:", eigenManager);

        // Check strategy balance
        uint256 strategyBalance = eigenStrategy.balance;
        console.log("ETH in Strategy:", strategyBalance / 1e18);

        // Check stETH in strategy
        address STETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;
        uint256 stethBalance = IERC20(STETH).balanceOf(eigenStrategy);
        console.log("stETH in Strategy:", stethBalance / 1e18);

        // Check total shares
        (bool success, bytes memory data) = eigenStrategy.staticcall(
            abi.encodeWithSignature("totalShares()")
        );
        if (success && data.length >= 32) {
            console.log("Total Shares:", abi.decode(data, (uint256)) / 1e18);
        }
    }

    function testSearchMorphoBlueVulns() public view {
        console.log("=====================================================");
        console.log("MORPHO BLUE ANALYSIS");
        console.log("=====================================================");

        // Morpho Blue - new lending protocol
        address morpho = 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb;

        console.log("Morpho Blue:", morpho);

        uint256 wethInMorpho = IERC20(WETH).balanceOf(morpho);
        console.log("WETH in Morpho:", wethInMorpho / 1e18);

        address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
        uint256 usdcInMorpho = IERC20(USDC).balanceOf(morpho);
        console.log("USDC in Morpho:", usdcInMorpho / 1e6);

        // Check for any unusual state
        (bool success, bytes memory data) = morpho.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (success && data.length >= 32) {
            console.log("Owner:", abi.decode(data, (address)));
        }
    }

    function testCompoundV3Vulnerabilities() public view {
        console.log("=====================================================");
        console.log("COMPOUND V3 (COMET) ANALYSIS");
        console.log("=====================================================");

        // Compound V3 cUSDC
        address cometUSDC = 0xc3d688B66703497DAA19211EEdff47f25384cdc3;
        address cometWETH = 0xA17581A9E3356d9A858b789D68B4d866e593aE94;

        console.log("Comet USDC:", cometUSDC);
        console.log("Comet WETH:", cometWETH);

        // Check USDC comet
        (bool success, bytes memory data) = cometUSDC.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        if (success && data.length >= 32) {
            console.log("cUSDC Total Supply:", abi.decode(data, (uint256)) / 1e6);
        }

        (success, data) = cometUSDC.staticcall(
            abi.encodeWithSignature("totalBorrow()")
        );
        if (success && data.length >= 32) {
            console.log("cUSDC Total Borrow:", abi.decode(data, (uint256)) / 1e6);
        }

        // Check utilization (potential interest rate manipulation)
        (success, data) = cometUSDC.staticcall(
            abi.encodeWithSignature("getUtilization()")
        );
        if (success && data.length >= 32) {
            console.log("Utilization:", abi.decode(data, (uint256)));
        }
    }

    function testPendleFinanceAnalysis() public view {
        console.log("=====================================================");
        console.log("PENDLE FINANCE ANALYSIS");
        console.log("=====================================================");

        // Pendle router
        address pendleRouter = 0x00000000005BBB0EF59571E58418F9a4357b68A0;
        address pendleMarket = 0x7d372819240D14fB477f17b964f95F33BeB4c704; // Example market

        console.log("Pendle Router:", pendleRouter);

        // Check ETH in router
        console.log("ETH in Router:", pendleRouter.balance / 1e18);

        // Check market state
        if (pendleMarket.code.length > 0) {
            (bool success, bytes memory data) = pendleMarket.staticcall(
                abi.encodeWithSignature("totalSupply()")
            );
            if (success && data.length >= 32) {
                console.log("Market LP Supply:", abi.decode(data, (uint256)) / 1e18);
            }
        }
    }

    function testFlashLoanProfitCalculation() public {
        console.log("=====================================================");
        console.log("FLASH LOAN PROFIT POTENTIAL");
        console.log("=====================================================");

        // Calculate how much we can flash loan for free from Balancer
        uint256 availableWeth = IERC20(WETH).balanceOf(BALANCER_VAULT);
        console.log("Available WETH for flash loan:", availableWeth / 1e18);

        // If we find a target with 1% profit opportunity
        // Flash loan 1000 ETH = 1000 ETH profit potential at 1%
        console.log("\nProfit scenarios at different rates:");
        console.log("1000 ETH flash @ 0.1% = 1 ETH profit");
        console.log("1000 ETH flash @ 1% = 10 ETH profit");
        console.log("1000 ETH flash @ 10% = 100 ETH profit");

        // Check BAMM for current state
        address BAMM = 0x920623AcBa785ED9a70d33ACab53631e1e834675;
        console.log("\n--- BAMM Current State ---");

        (bool success, bytes memory data) = BAMM.staticcall(
            abi.encodeWithSignature("fetchPrice()")
        );
        if (success && data.length >= 32) {
            console.log("BAMM Price:", abi.decode(data, (uint256)));
        }

        // Check SP balance
        address STABILITY_POOL = 0x97c70a1d3b2B56f768e6A8c4eAFd0feAC30E5e5b;
        if (STABILITY_POOL.code.length > 0) {
            (success, data) = STABILITY_POOL.staticcall(
                abi.encodeWithSignature("getTotalTHUSDDeposits()")
            );
            if (success && data.length >= 32) {
                console.log("THUSD in Stability Pool:", abi.decode(data, (uint256)) / 1e18);
            }
        }
    }

    function testOracleManipulationVectors() public view {
        console.log("=====================================================");
        console.log("ORACLE MANIPULATION ANALYSIS");
        console.log("=====================================================");

        // Check Chainlink feeds
        address ETH_USD = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;
        address BTC_USD = 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c;

        console.log("ETH/USD Oracle:", ETH_USD);
        console.log("BTC/USD Oracle:", BTC_USD);

        // Get current prices
        (bool success, bytes memory data) = ETH_USD.staticcall(
            abi.encodeWithSignature("latestRoundData()")
        );
        if (success && data.length >= 160) {
            (, int256 price,,,) = abi.decode(data, (uint80, int256, uint256, uint256, uint80));
            console.log("ETH Price:", uint256(price) / 1e8);
        }

        // Chainlink can't be manipulated directly
        // But protocols using TWAP oracles can be
        console.log("\nTWAP oracles are vulnerable to manipulation if:");
        console.log("1. Short observation window");
        console.log("2. Low liquidity pools");
        console.log("3. No sanity checks");
    }
}
