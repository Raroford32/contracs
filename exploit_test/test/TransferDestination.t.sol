// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
}

interface IStrategy {
    function vault() external view returns (address);
}

contract TransferDestination is Test {
    address constant TRANSFER_ACTION = 0xc780112305ED959CEEeb0DE692E2407E4145Fc3A;
    address constant VAULT_PULL = 0x313Ca6136521D22A7Ea763B3566Ed0B53F5B3AB9;
    address constant STRATEGY_0 = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeCallPattern() public view {
        console.log("=== ANALYZING CALL PATTERN ===\n");

        bytes memory code = TRANSFER_ACTION.code;

        // The action has 1 CALL opcode - this is likely the transfer call
        // Let's find it and analyze what's pushed on stack before it

        console.log("Looking for CALL opcode (0xf1) context...\n");

        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf1) { // CALL
                console.log("CALL found at offset:", i);

                // Print context: 100 bytes before
                uint256 start = i > 100 ? i - 100 : 0;
                console.log("Context (100 bytes before CALL):");

                // Look for address-loading patterns before CALL
                for (uint j = start; j < i; j++) {
                    uint8 op = uint8(code[j]);

                    // CALLDATALOAD (0x35) - loading from calldata
                    if (op == 0x35) {
                        console.log("  CALLDATALOAD at:", j);
                    }

                    // PUSH20 (0x73) - hardcoded address
                    if (op == 0x73) {
                        console.log("  PUSH20 at:", j);
                        if (j + 21 <= code.length) {
                            bytes20 addr;
                            for (uint k = 0; k < 20; k++) {
                                addr |= bytes20(bytes1(code[j + 1 + k])) >> (8 * k);
                            }
                            console.log("    Address:", address(addr));
                        }
                    }

                    // CALLER (0x33) - msg.sender
                    if (op == 0x33) {
                        console.log("  CALLER at:", j);
                    }

                    // ADDRESS (0x30) - address(this)
                    if (op == 0x30) {
                        console.log("  ADDRESS (this) at:", j);
                    }
                }
            }
        }
    }

    function test_TraceTransferParams() public {
        console.log("=== TRACING TRANSFER PARAMS ===\n");

        // Deploy a mock strategy that returns a controllable vault
        MockStrategy mock = new MockStrategy(attacker); // Set attacker as "vault"

        // Give mock some tokens
        deal(wstETH, address(mock), 10e18);
        console.log("Mock wstETH balance:", IERC20(wstETH).balanceOf(address(mock)) / 1e18);
        console.log("Attacker wstETH before:", IERC20(wstETH).balanceOf(attacker));

        // Have mock delegatecall the action
        // If the action uses msg.sender.vault() and transfers there,
        // tokens should go to attacker (our mock's vault)

        bytes memory params = abi.encode(
            wstETH,  // token
            1e18     // amount
        );

        console.log("\nCalling action via mock with attacker as vault...");

        bool success = mock.callAction(TRANSFER_ACTION, params);
        console.log("Success:", success);

        console.log("\nAfter call:");
        console.log("Mock wstETH balance:", IERC20(wstETH).balanceOf(address(mock)) / 1e18);
        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);

        if (IERC20(wstETH).balanceOf(attacker) > 0) {
            console.log("\n*** CRITICAL: ATTACKER RECEIVED TOKENS! ***");
        }
    }

    function test_TraceWithRealStrategy() public {
        console.log("=== TRACING WITH REAL STRATEGY ===\n");

        // The real Strategy.vault() returns the real Vault
        // So if TRANSFER_ACTION transfers to vault(), tokens go to Vault

        deal(wstETH, STRATEGY_0, 10e18);
        console.log("Strategy wstETH before:", IERC20(wstETH).balanceOf(STRATEGY_0) / 1e18);
        console.log("Vault wstETH before:", IERC20(wstETH).balanceOf(VAULT) / 1e18);

        // Prank as Strategy and delegatecall
        vm.startPrank(STRATEGY_0);

        bytes memory params = abi.encode(wstETH, 1e18);

        (bool success,) = TRANSFER_ACTION.delegatecall(
            abi.encodeWithSignature(
                "executeAction(bytes,uint8[],bytes32[])",
                params,
                new uint8[](0),
                new bytes32[](0)
            )
        );

        vm.stopPrank();

        console.log("\nResult: success =", success);
        console.log("Strategy wstETH after:", IERC20(wstETH).balanceOf(STRATEGY_0) / 1e18);
        console.log("Vault wstETH after:", IERC20(wstETH).balanceOf(VAULT) / 1e18);
    }

    function test_CheckAllThreeUnknownActions() public {
        console.log("=== CHECKING ALL THREE UNKNOWN ACTIONS ===\n");

        // Unknown_3: 0x3e34E0694204e462Deaf8EBbeEE2bE9F887f3C3b
        // Unknown_4: 0x99eAe56224EA5Bcb2c886D0a07154217b7A1E5d1
        // Unknown_5: 0x819Bdb303e224CaC4aC14Da17a1ec13895869b65

        address[] memory actions = new address[](3);
        actions[0] = 0x3e34E0694204e462Deaf8EBbeEE2bE9F887f3C3b;
        actions[1] = 0x99eAe56224EA5Bcb2c886D0a07154217b7A1E5d1;
        actions[2] = 0x819Bdb303e224CaC4aC14Da17a1ec13895869b65;

        for (uint a = 0; a < actions.length; a++) {
            console.log("=== Action ===");
            console.log("Index:", a);
            console.log("Address:", actions[a]);

            // Get action ID
            (bool success, bytes memory data) = actions[a].staticcall(
                abi.encodePacked(bytes4(0x5d1ca631)) // ID getter
            );
            if (success && data.length >= 4) {
                bytes4 actionId = bytes4(data);
                console.log("Action ID:");
                console.logBytes4(actionId);
            }

            // Check if it has transfer selector
            bytes memory code = actions[a].code;
            bool hasTransfer = false;
            for (uint i = 0; i + 3 < code.length; i++) {
                bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
                if (sel == bytes4(0xa9059cbb)) {
                    hasTransfer = true;
                    break;
                }
            }
            console.log("Has transfer:", hasTransfer);

            // Count CALL opcodes
            uint256 callCount = 0;
            for (uint i = 0; i < code.length; i++) {
                if (uint8(code[i]) == 0xf1) callCount++;
            }
            console.log("CALL opcodes:", callCount);
        }
    }

    function test_AnalyzeAction12() public view {
        console.log("=== ANALYZING ACTION 12 (0x4f18b88c) ===\n");

        // Action 12: 0x351dd4581d61BCE7101FDf5f6864D510021c7CaB
        // This one doesn't have transfer selector but might be interesting

        address action12 = 0x351dd4581d61BCE7101FDf5f6864D510021c7CaB;

        // Get action ID
        (bool success, bytes memory data) = action12.staticcall(
            abi.encodePacked(bytes4(0x5d1ca631))
        );
        if (success && data.length >= 4) {
            console.log("Action ID:");
            console.logBytes(data);
        }

        bytes memory code = action12.code;
        console.log("Code size:", code.length);

        // Look for interesting patterns
        uint256 calldataloadCount = 0;
        uint256 callCount = 0;
        uint256 delegatecallCount = 0;

        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0x35) calldataloadCount++;
            if (uint8(code[i]) == 0xf1) callCount++;
            if (uint8(code[i]) == 0xf4) delegatecallCount++;
        }

        console.log("CALLDATALOAD:", calldataloadCount);
        console.log("CALL:", callCount);
        console.log("DELEGATECALL:", delegatecallCount);

        // Check for common function selectors
        bytes4[] memory interestingSelectors = new bytes4[](5);
        interestingSelectors[0] = bytes4(keccak256("withdraw(address,uint256)"));
        interestingSelectors[1] = bytes4(keccak256("redeem(uint256)"));
        interestingSelectors[2] = bytes4(keccak256("claim(address)"));
        interestingSelectors[3] = bytes4(keccak256("harvest()"));
        interestingSelectors[4] = bytes4(keccak256("compound()"));

        string[5] memory names = ["withdraw", "redeem", "claim", "harvest", "compound"];

        console.log("\nSearching for selectors:");
        for (uint s = 0; s < interestingSelectors.length; s++) {
            for (uint i = 0; i + 3 < code.length; i++) {
                bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
                if (sel == interestingSelectors[s]) {
                    console.log("  Found:", names[s]);
                }
            }
        }
    }
}

contract MockStrategy {
    address public vault;

    constructor(address _vault) {
        vault = _vault;
    }

    function callAction(address action, bytes memory params) external returns (bool) {
        (bool success,) = action.delegatecall(
            abi.encodeWithSignature(
                "executeAction(bytes,uint8[],bytes32[])",
                params,
                new uint8[](0),
                new bytes32[](0)
            )
        );
        return success;
    }

    receive() external payable {}
}
