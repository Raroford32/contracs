// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title BitStablePool Analysis
 * @notice Analyzing build/redeem logic for potential arbitrage or rounding exploits
 */

interface IBitStablePool {
    function build(address tokenIn, uint256 amountIn) external;
    function redeem(uint256 amountIn, address tokenOut) external;
    function getBuildAmountOut(address tokenIn, uint256 amountIn) external view returns (uint256 amountOut, uint256 fee);
    function getRedeemAmountOut(uint256 amountIn, address tokenOut) external view returns (uint256 amountOut, uint256 fee);
    function paused() external view returns (bool);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function decimals() external view returns (uint8);
}

contract BitStablePoolExploit is Test {
    // BitStablePool (implementation)
    address constant BIT_STABLE_POOL = 0xaAD39FD6dA73ECE10cd5e909A8f415B555Ea73f9;

    // Common stablecoins
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;

    string constant RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    function setUp() public {
        vm.createSelectFork(RPC_URL);
    }

    function test_AnalyzeBitStablePool() public view {
        console.log("=== BitStablePool Analysis ===\n");

        // Check if contract exists
        if (BIT_STABLE_POOL.code.length == 0) {
            console.log("Contract not deployed at this address");
            return;
        }

        IBitStablePool pool = IBitStablePool(BIT_STABLE_POOL);

        // Check if paused
        try pool.paused() returns (bool isPaused) {
            console.log("Pool paused:", isPaused);
        } catch {
            console.log("Cannot check pause status");
        }

        // Try to get build/redeem amounts
        uint256 testAmount = 1000 * 1e6; // 1000 USDC (6 decimals)

        try pool.getBuildAmountOut(USDC, testAmount) returns (uint256 buildOut, uint256 buildFee) {
            console.log("\nBuild 1000 USDC:");
            console.log("  Output DAII:", buildOut / 1e18);
            console.log("  Fee:", buildFee / 1e6);
        } catch {
            console.log("getBuildAmountOut failed for USDC");
        }

        // Check arbitrage opportunity
        // If build fee < redeem fee, there might be arbitrage
        // If decimal handling is wrong, there might be rounding exploits
    }

    function test_DecimalMismatch() public view {
        console.log("=== Decimal Mismatch Analysis ===\n");

        // USDC has 6 decimals, DAII likely has 18
        // Check if rounding favors user or protocol

        IBitStablePool pool = IBitStablePool(BIT_STABLE_POOL);

        // Test with very small amounts to find rounding issues
        uint256[] memory testAmounts = new uint256[](5);
        testAmounts[0] = 1; // 0.000001 USDC
        testAmounts[1] = 10;
        testAmounts[2] = 100;
        testAmounts[3] = 1000;
        testAmounts[4] = 1e6; // 1 USDC

        for (uint i = 0; i < testAmounts.length; i++) {
            try pool.getBuildAmountOut(USDC, testAmounts[i]) returns (uint256 out, uint256 fee) {
                console.log("Input:", testAmounts[i]);
                console.log("  Output:", out);
                console.log("  Fee:", fee);
            } catch {
                console.log("Failed for amount:", testAmounts[i]);
            }
        }
    }

    function test_RoundtripArbitrage() public view {
        console.log("=== Roundtrip Arbitrage Test ===\n");

        IBitStablePool pool = IBitStablePool(BIT_STABLE_POOL);

        uint256 initialUSDC = 10000 * 1e6; // 10,000 USDC

        // Step 1: Build DAII from USDC
        try pool.getBuildAmountOut(USDC, initialUSDC) returns (uint256 daiiOut, uint256 buildFee) {
            console.log("Step 1: Build DAII");
            console.log("  Input USDC:", initialUSDC / 1e6);
            console.log("  Output DAII:", daiiOut / 1e18);
            console.log("  Build Fee:", buildFee / 1e6);

            // Step 2: Redeem DAII back to USDC
            try pool.getRedeemAmountOut(daiiOut, USDC) returns (uint256 finalUSDC, uint256 redeemFee) {
                console.log("\nStep 2: Redeem DAII");
                console.log("  Input DAII:", daiiOut / 1e18);
                console.log("  Output USDC:", finalUSDC / 1e6);
                console.log("  Redeem Fee:", redeemFee / 1e6);

                // Calculate net result
                console.log("\nNet Result:");
                if (finalUSDC > initialUSDC) {
                    console.log("  PROFIT:", (finalUSDC - initialUSDC) / 1e6, "USDC");
                    console.log("  VULNERABILITY FOUND!");
                } else {
                    console.log("  LOSS:", (initialUSDC - finalUSDC) / 1e6, "USDC");
                }
            } catch {
                console.log("getRedeemAmountOut failed");
            }
        } catch {
            console.log("getBuildAmountOut failed");
        }
    }
}
