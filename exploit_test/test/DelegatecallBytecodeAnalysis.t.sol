// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
}

contract DelegatecallBytecodeAnalysis is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    function setUp() public {
        vm.createSelectFork(RPC_URL);
    }

    function test_DetailedDelegatecallAnalysis() public view {
        console.log("=== DETAILED DELEGATECALL ANALYSIS ===\n");

        bytes memory code = REDEMPTION_1.code;

        // DELEGATECALL takes: gas, addr, argsOffset, argsSize, retOffset, retSize
        // The 'addr' is the 2nd item from top of stack when DELEGATECALL executes

        // Let's trace each DELEGATECALL location
        uint[] memory dcOffsets = new uint[](7);
        dcOffsets[0] = 264;
        dcOffsets[1] = 1045;
        dcOffsets[2] = 1592;
        dcOffsets[3] = 2709;
        dcOffsets[4] = 3027;
        dcOffsets[5] = 3154;
        dcOffsets[6] = 5030;

        for (uint d = 0; d < dcOffsets.length; d++) {
            uint offset = dcOffsets[d];
            console.log("\n--- DELEGATECALL #", d + 1);
            console.log("at offset:", offset, "---");

            // Print 50 bytes before the DELEGATECALL
            uint start = offset > 50 ? offset - 50 : 0;

            console.log("Bytecode before DELEGATECALL:");
            for (uint i = start; i <= offset; i++) {
                uint8 op = uint8(code[i]);

                if (op == 0xf4) {
                    console.log(i, "DELEGATECALL <<<<");
                } else if (op == 0x54) {
                    console.log(i, "SLOAD");
                } else if (op == 0x51) {
                    console.log(i, "MLOAD");
                } else if (op == 0x35) {
                    console.log(i, "CALLDATALOAD");
                } else if (op == 0x5a) {
                    console.log(i, "GAS");
                } else if (op == 0x90) {
                    console.log(i, "SWAP1");
                } else if (op == 0x91) {
                    console.log(i, "SWAP2");
                } else if (op == 0x92) {
                    console.log(i, "SWAP3");
                } else if (op == 0x80) {
                    console.log(i, "DUP1");
                } else if (op == 0x81) {
                    console.log(i, "DUP2");
                } else if (op == 0x82) {
                    console.log(i, "DUP3");
                } else if (op == 0x83) {
                    console.log(i, "DUP4");
                } else if (op == 0x84) {
                    console.log(i, "DUP5");
                } else if (op == 0x85) {
                    console.log(i, "DUP6");
                } else if (op == 0x16) {
                    console.log(i, "AND");
                } else if (op == 0x73) {
                    // PUSH20 - extract address
                    bytes memory addrBytes = new bytes(20);
                    for (uint j = 0; j < 20 && i + 1 + j < code.length; j++) {
                        addrBytes[j] = code[i + 1 + j];
                    }
                    address addr = address(bytes20(addrBytes));
                    console.log(i, "PUSH20:");
                    console.log("  ", addr);
                    i += 20;
                } else if (op >= 0x60 && op <= 0x7f) {
                    uint8 pushSize = op - 0x5f;
                    uint256 val = 0;
                    for (uint j = 0; j < pushSize && i + 1 + j < code.length; j++) {
                        val = val << 8 | uint8(code[i + 1 + j]);
                    }
                    if (pushSize <= 4) {
                        console.log(i, "PUSH value:", val);
                    }
                    i += pushSize;
                }
            }
        }
    }

    function test_AnalyzeRedemption0Delegatecall5323() public view {
        console.log("=== ANALYZING REDEMPTION_0 DELEGATECALL AT 5323 ===\n");

        bytes memory code = REDEMPTION_0.code;

        // This is the DELEGATECALL that loads from storage
        uint offset = 5323;

        console.log("Bytecode around offset 5323:");

        uint start = 5270;
        for (uint i = start; i < 5340 && i < code.length; i++) {
            uint8 op = uint8(code[i]);

            if (op == 0xf4) {
                console.log(i, "DELEGATECALL <<<<");
            } else if (op == 0x54) {
                console.log(i, "SLOAD");
            } else if (op == 0x51) {
                console.log(i, "MLOAD");
            } else if (op == 0x35) {
                console.log(i, "CALLDATALOAD");
            } else if (op == 0x5a) {
                console.log(i, "GAS");
            } else if (op == 0x90) {
                console.log(i, "SWAP1");
            } else if (op == 0x91) {
                console.log(i, "SWAP2");
            } else if (op == 0x92) {
                console.log(i, "SWAP3");
            } else if (op == 0x80) {
                console.log(i, "DUP1");
            } else if (op == 0x81) {
                console.log(i, "DUP2");
            } else if (op == 0x82) {
                console.log(i, "DUP3");
            } else if (op == 0x83) {
                console.log(i, "DUP4");
            } else if (op == 0x16) {
                console.log(i, "AND");
            } else if (op == 0x73) {
                bytes memory addrBytes = new bytes(20);
                for (uint j = 0; j < 20 && i + 1 + j < code.length; j++) {
                    addrBytes[j] = code[i + 1 + j];
                }
                address addr = address(bytes20(addrBytes));
                console.log(i, "PUSH20:");
                console.log("  ", addr);
                i += 20;
            } else if (op >= 0x60 && op <= 0x7f) {
                uint8 pushSize = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < pushSize && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                console.log(i, "PUSH value:", val);
                i += pushSize;
            }
        }
    }

    function test_TraceRedeem0ToRCCall() public view {
        console.log("=== TRACING REDEMPTION_0 TO RC.REDEEM CALL ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Find where RC address appears and what happens after
        bytes memory rcBytes = abi.encodePacked(REDEMPTION_CONTROLLER);

        console.log("Finding RC address and subsequent CALL:");

        for (uint i = 0; i + 20 < code.length; i++) {
            bool match_ = true;
            for (uint j = 0; j < 20; j++) {
                if (code[i + j] != rcBytes[j]) {
                    match_ = false;
                    break;
                }
            }

            if (match_) {
                console.log("\nFound RC at offset:", i);

                // Look for CALL after this
                for (uint k = i; k < i + 200 && k < code.length; k++) {
                    uint8 op = uint8(code[k]);

                    if (op == 0xf1) {
                        console.log("  CALL at:", k);

                        // What's the call signature? Look for PUSH4 before
                        for (uint m = k > 50 ? k - 50 : 0; m < k; m++) {
                            if (uint8(code[m]) == 0x63) {
                                bytes4 sel = bytes4(bytes.concat(code[m+1], code[m+2], code[m+3], code[m+4]));
                                console.log("    Selector at", m, ":");
                                console.logBytes4(sel);
                            }
                        }
                        break;
                    }
                }
            }
        }
    }

    function test_FindHowToParamIsSet() public view {
        console.log("=== FINDING HOW 'TO' PARAM IS SET ===\n");

        // In RC.redeem(amount, to), the 'to' is the recipient
        // We need to find how this is determined in finalizeRedeem

        // redeem(uint256,address) selector = 0xdb006a75... no wait
        // Let's calculate it
        bytes4 redeemSel = bytes4(keccak256("redeem(uint256,address)"));
        console.log("redeem(uint256,address) selector:");
        console.logBytes4(redeemSel);

        bytes memory code = REDEMPTION_0.code;

        // Find where this selector appears
        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == redeemSel) {
                    console.log("\nFound redeem selector at offset:", i);

                    // What comes after? The next 100 bytes might show how args are set
                    console.log("Following opcodes:");
                    for (uint j = i + 5; j < i + 100 && j < code.length; j++) {
                        uint8 op = uint8(code[j]);
                        if (op == 0x33) console.log(j, "CALLER");
                        else if (op == 0x32) console.log(j, "ORIGIN");
                        else if (op == 0x54) console.log(j, "SLOAD");
                        else if (op == 0x35) console.log(j, "CALLDATALOAD");
                        else if (op == 0xf1) {
                            console.log(j, "CALL");
                            break;
                        }
                    }
                }
            }
        }
    }
}
