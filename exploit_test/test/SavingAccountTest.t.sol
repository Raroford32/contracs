// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface ISavingAccount {
    function depositToken(address tokenAddress, uint256 amount) external payable;
    function withdrawToken(address tokenAddress, uint256 amount) external payable;
    function getReward() external;
    function getMarketState() external view returns (address[] memory, int256[] memory);
    function getTokenState(address tokenAddress) external view returns (int256, int256, int256);
    function tokenBalanceOf(address tokenAddress, address account) external view returns (int256);
    function getCoinLength() external view returns (uint256);
    function _startTime() external view returns (uint256);
    function _periodFinish() external view returns (uint256);
    function owner() external view returns (address);
    function _ETH() external view returns (address);
    function _USDT() external view returns (address);
    function _PROS() external view returns (address);
    function _allpool() external view returns (address);
}

interface IAllPool {
    function is_Re(address user) external view returns (bool);
    function get_Address_pool(address user) external view returns (address);
}

contract SavingAccountTest is Test {
    ISavingAccount saving = ISavingAccount(0x6f35A5e6A7301627A090822895e5E7209eD72F77);

    function setUp() public {
        // Fork mainnet at latest
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
    }

    function test_contractState() public view {
        console.log("=== SavingAccount State ===");
        console.log("ETH balance:", address(saving).balance);
        console.log("_startTime:", saving._startTime());
        console.log("_periodFinish:", saving._periodFinish());
        console.log("owner:", saving.owner());
        console.log("coinLength:", saving.getCoinLength());
        console.log("_ETH:", saving._ETH());
        console.log("_USDT:", saving._USDT());
        console.log("_PROS:", saving._PROS());

        (address[] memory addrs, int256[] memory deposits) = saving.getMarketState();
        for (uint i = 0; i < addrs.length; i++) {
            console.log("Token", i);
            console.logAddress(addrs[i]);
            console.logInt(deposits[i]);
        }
    }

    function test_withdrawReverts() public {
        // Try to call withdrawToken as someone who has deposited
        // First, find an active account by checking the totalDeposits
        address ethAddr = saving._ETH();

        // Impersonate an account that has ETH deposited
        // We'll try with a random address first just to test if checkHalve reverts
        address depositor = address(0x1234);
        vm.deal(depositor, 10 ether);
        vm.startPrank(depositor);

        // Try deposit - should revert due to checkHalve overflow
        console.log("Attempting depositToken with 1 ETH...");
        try saving.depositToken{value: 1 ether}(ethAddr, 1 ether) {
            console.log("UNEXPECTED: depositToken SUCCEEDED!");
        } catch Error(string memory reason) {
            console.log("depositToken REVERTED with:", reason);
        } catch (bytes memory lowLevelData) {
            console.log("depositToken REVERTED with low-level error, length:", lowLevelData.length);
        }

        vm.stopPrank();
    }

    function test_withdrawTokenReverts() public {
        address ethAddr = saving._ETH();

        // Try withdraw as random user
        address user = address(0x5678);
        vm.deal(user, 1 ether);
        vm.startPrank(user);

        console.log("Attempting withdrawToken...");
        try saving.withdrawToken(ethAddr, 1 ether) {
            console.log("UNEXPECTED: withdrawToken SUCCEEDED!");
        } catch Error(string memory reason) {
            console.log("withdrawToken REVERTED with:", reason);
        } catch (bytes memory lowLevelData) {
            console.log("withdrawToken REVERTED with low-level error, length:", lowLevelData.length);
        }

        vm.stopPrank();
    }

    function test_getRewardReverts() public {
        address user = address(0x9ABC);
        vm.startPrank(user);

        console.log("Attempting getReward...");
        try saving.getReward() {
            console.log("UNEXPECTED: getReward SUCCEEDED!");
        } catch Error(string memory reason) {
            console.log("getReward REVERTED with:", reason);
        } catch (bytes memory lowLevelData) {
            console.log("getReward REVERTED with low-level error, length:", lowLevelData.length);
        }

        vm.stopPrank();
    }

    function test_allPoolRegistration() public view {
        // Check if AllPool contract is functional
        IAllPool allPool = IAllPool(saving._allpool());

        address testAddr = address(0x1234);
        try allPool.is_Re(testAddr) returns (bool result) {
            console.log("AllPool.is_Re(test):", result);
        } catch {
            console.log("AllPool.is_Re reverted");
        }
    }
}
