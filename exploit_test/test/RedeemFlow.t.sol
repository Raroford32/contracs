// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract RedeemFlow is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_RedeemAndCheck() public {
        console.log("=== REDEEM AND CHECK ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18, "wstETH");

        vm.startPrank(attacker);
        deal(TASSET, attacker, 100000e18);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        console.log("Attacker TASSET:", IERC20(TASSET).balanceOf(attacker) / 1e18);

        // Redeem
        (bool s1,) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("\nredeem(1000e18):", s1);

        console.log("Attacker TASSET after:", IERC20(TASSET).balanceOf(attacker) / 1e18);

        // Check pending
        (bool s2, bytes memory d2) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("totalRedeeming()")
        );
        if (s2) console.log("totalRedeeming:", abi.decode(d2, (uint256)) / 1e18);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault after:", vaultAfter / 1e18, "wstETH");
        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker));
    }

    function test_RedeemWarpFinalize() public {
        console.log("=== REDEEM, WARP, FINALIZE ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);
        deal(TASSET, attacker, 100000e18);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        // Redeem
        (bool s1,) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("redeem:", s1);

        vm.stopPrank();

        // Warp time
        vm.warp(block.timestamp + 7 days);
        console.log("Warped 7 days");

        vm.startPrank(attacker);

        // Try finalize variations
        (bool s2,) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("finalizeRedeem(0):", s2);

        (bool s3,) = REDEMPTION_0.call(
            abi.encodeWithSignature("claim(uint256)", 0)
        );
        console.log("claim(0):", s3);

        (bool s4,) = REDEMPTION_0.call(
            abi.encodeWithSignature("claimRedeem(uint256)", 0)
        );
        console.log("claimRedeem(0):", s4);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWst = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault change:", int256(vaultBefore) - int256(vaultAfter));
        console.log("Attacker wstETH:", attackerWst);
    }

    function test_FindFinalizeFunction() public {
        console.log("=== FINDING FINALIZE FUNCTION ===\n");

        vm.startPrank(attacker);
        deal(TASSET, attacker, 100000e18);
        IERC20(TASSET).approve(REDEMPTION_0, type(uint256).max);

        // Redeem first
        REDEMPTION_0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        console.log("Redeemed 1000 TASSET");

        vm.warp(block.timestamp + 30 days);
        console.log("Warped 30 days");

        // Try all R0 selectors we found
        bytes4[] memory sels = new bytes4[](8);
        sels[0] = bytes4(keccak256("finalizeRedeem(uint256)"));
        sels[1] = bytes4(keccak256("processRedeem(uint256)"));
        sels[2] = bytes4(keccak256("completeRedeem(uint256)"));
        sels[3] = bytes4(keccak256("executeRedeem(uint256)"));
        sels[4] = bytes4(keccak256("settleRedeem(uint256)"));
        sels[5] = bytes4(keccak256("withdrawRedeem(uint256)"));
        sels[6] = bytes4(keccak256("claimRedemption(uint256)"));
        sels[7] = bytes4(keccak256("redeemClaim(uint256)"));

        for (uint i = 0; i < sels.length; i++) {
            (bool s, bytes memory d) = REDEMPTION_0.call(
                abi.encodeWithSelector(sels[i], 0)
            );
            if (s) {
                console.log("SUCCESS:");
                console.logBytes4(sels[i]);
            }
        }

        vm.stopPrank();

        console.log("\nAttacker wstETH:", IERC20(wstETH).balanceOf(attacker));
    }

    function test_AnalyzeR0Bytecode() public view {
        console.log("=== ANALYZING R0 FOR FINALIZE ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Find function selectors
        console.log("R0 function selectors:");
        bytes4[] memory found = new bytes4[](30);
        uint count = 0;

        for (uint i = 0; i + 4 < code.length && count < 30; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                bool isValid = false;
                for (uint j = i + 5; j < i + 15 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x14) {
                        isValid = true;
                        break;
                    }
                }
                if (isValid && sel != bytes4(0) && sel != bytes4(0xffffffff) && uint32(sel) > 0x1000) {
                    bool unique = true;
                    for (uint k = 0; k < count; k++) {
                        if (found[k] == sel) unique = false;
                    }
                    if (unique) {
                        found[count] = sel;
                        count++;
                    }
                }
            }
        }

        for (uint i = 0; i < count; i++) {
            console.logBytes4(found[i]);
        }
    }
}
