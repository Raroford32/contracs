// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function decimals() external view returns (uint8);
}

interface IStakingRewards {
    function stake(uint256 amount) external;
    function withdraw(uint256 amount) external;
    function getReward() external;
    function exit() external;
    function earned(address account) external view returns (uint256);
    function rewardRate() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function periodFinish() external view returns (uint256);
    function rewardsToken() external view returns (address);
    function stakingToken() external view returns (address);
    function rewardPerToken() external view returns (uint256);
}

interface IBalancerVault {
    function flashLoan(
        address recipient,
        address[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;
}

/**
 * @title StakingRewards Flash Loan Analysis
 * @notice Check if flash stake attack is viable
 */
contract StakingRewardsExploitTest is Test {
    address constant STAKING_REWARDS = 0x10ab606B067C9C461d8893c47C7512472E19e2Ce;
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

    IStakingRewards staking;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        staking = IStakingRewards(STAKING_REWARDS);
    }

    function testStakingRewardsState() public view {
        console.log("=== STAKING REWARDS STATE ===");

        address stakingToken = staking.stakingToken();
        address rewardsToken = staking.rewardsToken();
        uint256 totalSupply = staking.totalSupply();
        uint256 rewardRate = staking.rewardRate();
        uint256 periodFinish = staking.periodFinish();
        uint256 rewardPerToken = staking.rewardPerToken();

        console.log("Staking token:", stakingToken);
        console.log("Rewards token:", rewardsToken);
        console.log("Total supply:", totalSupply);
        console.log("Reward rate:", rewardRate);
        console.log("Period finish:", periodFinish);
        console.log("Current time:", block.timestamp);
        console.log("Reward per token:", rewardPerToken);

        // Check rewards token balance in contract
        uint256 rewardsBalance = IERC20(rewardsToken).balanceOf(STAKING_REWARDS);
        console.log("Rewards in contract:", rewardsBalance);

        if (block.timestamp >= periodFinish) {
            console.log("\n[!] REWARD PERIOD ENDED");
            console.log("No active reward distribution");
        } else {
            uint256 remaining = periodFinish - block.timestamp;
            uint256 pendingTotal = rewardRate * remaining;
            console.log("\nRemaining period (seconds):", remaining);
            console.log("Total pending rewards:", pendingTotal);
        }
    }

    function testFlashStakeSimulation() public {
        console.log("\n=== FLASH STAKE SIMULATION ===");

        address stakingToken = staking.stakingToken();
        uint256 totalSupply = staking.totalSupply();
        uint256 rewardRate = staking.rewardRate();
        uint256 periodFinish = staking.periodFinish();

        if (block.timestamp >= periodFinish || rewardRate == 0) {
            console.log("No active rewards - attack not viable");
            return;
        }

        // Check if flash loan available for staking token
        uint256 stakingTokenInBalancer = IERC20(stakingToken).balanceOf(BALANCER_VAULT);
        console.log("Staking token in Balancer:", stakingTokenInBalancer);

        if (stakingTokenInBalancer == 0) {
            console.log("No staking token available for flash loan");
            return;
        }

        // Simulate: what would happen if we flash loan stake?
        // The key is the updateReward modifier sets userRewardPerTokenPaid BEFORE balance update
        // So new stakers don't earn retroactive rewards

        uint256 flashAmount = stakingTokenInBalancer > totalSupply * 10 ? totalSupply * 10 : stakingTokenInBalancer;
        console.log("Flash amount:", flashAmount);

        // Calculate rewards per second for flash staker
        // newRewardPerToken = currentRewardPerToken + (timeElapsed * rewardRate * 1e18) / newTotalSupply
        // In same block, timeElapsed â‰ˆ 0 or very small

        uint256 newTotalSupply = totalSupply + flashAmount;
        // In same block, attacker earns: flashAmount * (0) / 1e18 = 0

        console.log("\nNew total supply:", newTotalSupply);
        console.log("Flash staker share:", flashAmount * 100 / newTotalSupply, "%");
        console.log("\n[!] Standard Synthetix implementation");
        console.log("userRewardPerTokenPaid set BEFORE balance update");
        console.log("Flash stake attack NOT viable - attacker earns ~0 rewards");
    }
}
