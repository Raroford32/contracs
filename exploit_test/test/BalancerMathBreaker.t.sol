// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// ============================================================================
// MATH BREAKER: Finding unexpected large outputs through edge cases
// Goal: Break the AMM math to get way more output than expected
// ============================================================================

interface IAsset {}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint256) external;
}

interface IVault {
    enum SwapKind { GIVEN_IN, GIVEN_OUT }

    struct BatchSwapStep {
        bytes32 poolId;
        uint256 assetInIndex;
        uint256 assetOutIndex;
        uint256 amount;
        bytes userData;
    }

    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address payable recipient;
        bool toInternalBalance;
    }

    function batchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds, int256[] memory limits, uint256 deadline) external payable returns (int256[] memory);
    function queryBatchSwap(SwapKind kind, BatchSwapStep[] memory swaps, IAsset[] memory assets, FundManagement memory funds) external returns (int256[] memory);
    function flashLoan(address recipient, IERC20[] memory tokens, uint256[] memory amounts, bytes memory userData) external;
    function getPoolTokens(bytes32 poolId) external view returns (IERC20[] memory tokens, uint256[] memory balances, uint256 lastChangeBlock);
}

interface IFlashLoanRecipient {
    function receiveFlashLoan(IERC20[] memory tokens, uint256[] memory amounts, uint256[] memory feeAmounts, bytes memory userData) external;
}

contract BalancerMathBreaker is Test, IFlashLoanRecipient {
    IVault constant VAULT = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    IWETH constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20 constant BAL = IERC20(0xba100000625a3754423978a60c9317c58a424e3D);

    bytes32 constant BAL_WETH_POOL = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014;

    address attacker;
    bool inFlashLoan;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        attacker = address(this);
        vm.deal(attacker, 10000 ether);
        WETH.deposit{value: 5000 ether}();
        WETH.approve(address(VAULT), type(uint256).max);
        BAL.approve(address(VAULT), type(uint256).max);
    }

    // ========================================================================
    // TEST: Extreme precision edge cases - looking for overflow/underflow
    // ========================================================================
    function test_ExtremePrecisionEdgeCases() public {
        console.log("=== EXTREME PRECISION EDGE CASES ===");
        console.log("Looking for amounts that break pool math...");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Get pool reserves first
        (IERC20[] memory tokens, uint256[] memory balances,) = VAULT.getPoolTokens(BAL_WETH_POOL);
        console.log("Pool reserves:");
        for (uint i = 0; i < tokens.length; i++) {
            console.log("  Token:", address(tokens[i]));
            console.log("  Balance:", balances[i]);
        }

        // Test extreme amounts near critical boundaries
        uint256[] memory testAmounts = new uint256[](20);
        testAmounts[0] = 1;                          // Smallest
        testAmounts[1] = 2;
        testAmounts[2] = 10;
        testAmounts[3] = 100;
        testAmounts[4] = 1000;
        testAmounts[5] = 10000;
        testAmounts[6] = 100000;
        testAmounts[7] = 1000000;
        testAmounts[8] = type(uint112).max;          // 112-bit max (packed balance)
        testAmounts[9] = type(uint112).max - 1;
        testAmounts[10] = type(uint112).max / 2;
        testAmounts[11] = type(uint128).max;         // 128-bit max
        testAmounts[12] = type(uint128).max - 1;
        testAmounts[13] = type(uint256).max;         // Max uint256
        testAmounts[14] = type(uint256).max - 1;
        testAmounts[15] = type(uint256).max / 2;
        testAmounts[16] = balances[1];               // Exact pool balance
        testAmounts[17] = balances[1] - 1;           // Just under pool balance
        testAmounts[18] = balances[1] + 1;           // Just over pool balance
        testAmounts[19] = balances[1] * 2;           // Double pool balance

        for (uint i = 0; i < testAmounts.length; i++) {
            uint256 amt = testAmounts[i];

            IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](1);
            swaps[0] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,  // WETH in
                assetOutIndex: 0, // BAL out
                amount: amt,
                userData: ""
            });

            try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds) returns (int256[] memory deltas) {
                uint256 balOut = uint256(-deltas[0]);
                uint256 wethIn = uint256(deltas[1]);

                // Check if output is unexpectedly large
                // Normal rate is ~10000 BAL per WETH
                uint256 normalRate = 10500; // BAL per WETH
                uint256 expectedOut = (amt * normalRate) / 1e18;

                if (balOut > expectedOut * 100) {
                    console.log("!!! ANOMALY FOUND !!!");
                    console.log("  Amount:", amt);
                    console.log("  BAL out:", balOut);
                    console.log("  Expected ~:", expectedOut);
                }
            } catch {
                // Expected for extreme values
            }
        }
        console.log("Edge case scan complete.");
    }

    // ========================================================================
    // TEST: Chained swap state confusion
    // ========================================================================
    function test_ChainedSwapStateConfusion() public {
        console.log("=== CHAINED SWAP STATE CONFUSION ===");
        console.log("Testing if chained swaps confuse pool state...");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Create long chain of swaps in same transaction
        // Back and forth, trying to confuse state
        uint256 numSwaps = 50;
        uint256 baseAmount = 1 ether;

        IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](numSwaps);

        for (uint i = 0; i < numSwaps; i++) {
            if (i % 2 == 0) {
                // WETH -> BAL
                swaps[i] = IVault.BatchSwapStep({
                    poolId: BAL_WETH_POOL,
                    assetInIndex: 1,
                    assetOutIndex: 0,
                    amount: i == 0 ? baseAmount : 0, // First swap has amount, rest use output
                    userData: ""
                });
            } else {
                // BAL -> WETH
                swaps[i] = IVault.BatchSwapStep({
                    poolId: BAL_WETH_POOL,
                    assetInIndex: 0,
                    assetOutIndex: 1,
                    amount: 0, // Use output from previous
                    userData: ""
                });
            }
        }

        console.log("Testing", numSwaps, "chained swaps...");

        try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds) returns (int256[] memory deltas) {
            console.log("Chain completed!");
            console.log("  Net WETH delta:", deltas[1]);
            console.log("  Net BAL delta:", deltas[0]);

            // If we ended up with more than we started...
            if (deltas[1] < 0) {
                console.log("  NET WETH OUT:", uint256(-deltas[1]));
            }
            if (deltas[0] < 0) {
                console.log("  NET BAL OUT:", uint256(-deltas[0]));
            }
        } catch Error(string memory reason) {
            console.log("Chain failed:", reason);
        } catch {
            console.log("Chain failed (no reason)");
        }
    }

    // ========================================================================
    // TEST: Flash loan during batch - can we manipulate pool state?
    // ========================================================================
    function test_FlashLoanPoolManipulation() public {
        console.log("=== FLASH LOAN POOL MANIPULATION ===");

        // Get pool state before
        (IERC20[] memory tokensBefore, uint256[] memory balancesBefore,) = VAULT.getPoolTokens(BAL_WETH_POOL);
        console.log("Pool state before:");
        console.log("  BAL:", balancesBefore[0]);
        console.log("  WETH:", balancesBefore[1]);

        // Flash loan a massive amount
        uint256 flashAmount = 10000 ether;

        IERC20[] memory tokens = new IERC20[](1);
        tokens[0] = IERC20(address(WETH));

        uint256[] memory amounts = new uint256[](1);
        amounts[0] = flashAmount;

        inFlashLoan = true;

        try VAULT.flashLoan(address(this), tokens, amounts, abi.encode(flashAmount)) {
            console.log("Flash loan completed");
        } catch Error(string memory reason) {
            console.log("Flash loan failed:", reason);
        } catch {
            console.log("Flash loan failed");
        }

        inFlashLoan = false;

        // Check pool state after
        (IERC20[] memory tokensAfter, uint256[] memory balancesAfter,) = VAULT.getPoolTokens(BAL_WETH_POOL);
        console.log("Pool state after:");
        console.log("  BAL:", balancesAfter[0]);
        console.log("  WETH:", balancesAfter[1]);
    }

    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external {
        require(msg.sender == address(VAULT), "Not vault");
        require(inFlashLoan, "Not in flash loan");

        uint256 loanAmount = abi.decode(userData, (uint256));
        console.log("  In flash loan with:", loanAmount / 1e18, "WETH");

        // During flash loan, try a swap that might use stale pool state
        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: address(this),
            fromInternalBalance: false,
            recipient: payable(address(this)),
            toInternalBalance: false
        });

        // Try to swap using the flash loaned amount
        uint256 swapAmount = 100 ether;

        IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](1);
        swaps[0] = IVault.BatchSwapStep({
            poolId: BAL_WETH_POOL,
            assetInIndex: 1,
            assetOutIndex: 0,
            amount: swapAmount,
            userData: ""
        });

        int256[] memory limits = new int256[](2);
        limits[0] = 0;
        limits[1] = int256(swapAmount);

        try VAULT.batchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds, limits, block.timestamp + 1000) returns (int256[] memory deltas) {
            console.log("  Swap during flash loan succeeded!");
            console.log("  BAL received:", uint256(-deltas[0]));

            // Swap BAL back to WETH
            uint256 balReceived = uint256(-deltas[0]);

            IVault.BatchSwapStep[] memory backSwaps = new IVault.BatchSwapStep[](1);
            backSwaps[0] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 0,
                assetOutIndex: 1,
                amount: balReceived,
                userData: ""
            });

            int256[] memory backLimits = new int256[](2);
            backLimits[0] = int256(balReceived);
            backLimits[1] = 0;

            VAULT.batchSwap(IVault.SwapKind.GIVEN_IN, backSwaps, assets, funds, backLimits, block.timestamp + 1000);
        } catch {
            console.log("  Swap during flash loan failed");
        }

        // Repay flash loan
        uint256 totalOwed = amounts[0] + feeAmounts[0];
        tokens[0].transfer(address(VAULT), totalOwed);
    }

    // ========================================================================
    // TEST: GIVEN_OUT with extreme amounts
    // ========================================================================
    function test_GivenOutExtremeAmounts() public {
        console.log("=== GIVEN_OUT EXTREME AMOUNTS ===");
        console.log("Testing if requesting extreme output breaks math...");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Get pool reserves
        (IERC20[] memory tokens, uint256[] memory balances,) = VAULT.getPoolTokens(BAL_WETH_POOL);
        uint256 poolBal = balances[0];
        uint256 poolWeth = balances[1];

        console.log("Pool BAL:", poolBal);
        console.log("Pool WETH:", poolWeth);

        // Test requesting extreme BAL amounts via GIVEN_OUT
        uint256[] memory requestAmounts = new uint256[](10);
        requestAmounts[0] = poolBal / 1000;      // 0.1% of pool
        requestAmounts[1] = poolBal / 100;       // 1% of pool
        requestAmounts[2] = poolBal / 10;        // 10% of pool
        requestAmounts[3] = poolBal / 4;         // 25% of pool
        requestAmounts[4] = poolBal / 2;         // 50% of pool
        requestAmounts[5] = poolBal * 3 / 4;     // 75% of pool
        requestAmounts[6] = poolBal * 9 / 10;    // 90% of pool
        requestAmounts[7] = poolBal * 99 / 100;  // 99% of pool
        requestAmounts[8] = poolBal - 1;         // Almost all
        requestAmounts[9] = poolBal;             // All of pool

        for (uint i = 0; i < requestAmounts.length; i++) {
            uint256 requestBal = requestAmounts[i];

            IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](1);
            swaps[0] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,  // WETH in
                assetOutIndex: 0, // BAL out
                amount: requestBal, // Amount of BAL we WANT
                userData: ""
            });

            try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_OUT, swaps, assets, funds) returns (int256[] memory deltas) {
                uint256 wethNeeded = uint256(deltas[1]);
                uint256 balOut = requestBal;

                // Calculate effective rate
                if (wethNeeded > 0) {
                    uint256 rate = balOut * 1e18 / wethNeeded;
                    console.log("Request", requestBal * 100 / poolBal, "% of pool BAL");
                    console.log("  WETH needed:", wethNeeded);
                    console.log("  Rate (BAL/WETH):", rate);

                    // Check for anomalous rates
                    if (rate > 20000 * 1e18) {
                        console.log("  !!! ANOMALY: Rate too high !!!");
                    }
                }
            } catch {
                console.log("Request", requestBal * 100 / poolBal, "% of pool -> FAILED");
            }
        }
    }

    // ========================================================================
    // TEST: Massive batch trying to drain pool in single tx
    // ========================================================================
    function test_MassiveBatchPoolDrain() public {
        console.log("=== MASSIVE BATCH POOL DRAIN ATTEMPT ===");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Create 1000 swaps of 1 ETH each - trying to move pool massively
        uint256 numSwaps = 500;
        uint256 amtPerSwap = 1 ether;

        IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](numSwaps);
        for (uint i = 0; i < numSwaps; i++) {
            swaps[i] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: amtPerSwap,
                userData: ""
            });
        }

        console.log("Testing swaps - count:", numSwaps);
        console.log("Total ETH:", numSwaps * amtPerSwap / 1e18);

        try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds) returns (int256[] memory deltas) {
            uint256 totalWethIn = uint256(deltas[1]);
            uint256 totalBalOut = uint256(-deltas[0]);

            console.log("Results:");
            console.log("  Total WETH in:", totalWethIn / 1e18);
            console.log("  Total BAL out:", totalBalOut);

            // Check effective rate
            uint256 rate = totalBalOut * 1e18 / totalWethIn;
            console.log("  Effective rate:", rate, "BAL/WETH");

            // Compare to single swap of same amount
            IVault.BatchSwapStep[] memory singleSwap = new IVault.BatchSwapStep[](1);
            singleSwap[0] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: numSwaps * amtPerSwap,
                userData: ""
            });

            try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, singleSwap, assets, funds) returns (int256[] memory singleDeltas) {
                uint256 singleBalOut = uint256(-singleDeltas[0]);
                console.log("\nSingle swap comparison:");
                console.log("  BAL from single swap:", singleBalOut);
                console.log("  BAL from batch:", totalBalOut);

                if (totalBalOut > singleBalOut) {
                    console.log("  !!! BATCH GIVES MORE !!!");
                    console.log("  Difference:", totalBalOut - singleBalOut);
                }
            } catch {
                console.log("Single large swap failed (pool limit?)");
            }
        } catch {
            console.log("Massive batch failed");
        }
    }

    // ========================================================================
    // TEST: Negative/wraparound amount tests
    // ========================================================================
    function test_AmountBoundaryTests() public {
        console.log("=== AMOUNT BOUNDARY TESTS ===");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(BAL));
        assets[1] = IAsset(address(WETH));

        IVault.FundManagement memory funds = IVault.FundManagement({
            sender: attacker,
            fromInternalBalance: false,
            recipient: payable(attacker),
            toInternalBalance: false
        });

        // Test amounts near type boundaries that might cause issues
        uint256[] memory boundaryAmounts = new uint256[](15);
        boundaryAmounts[0] = 0;
        boundaryAmounts[1] = 1;
        boundaryAmounts[2] = type(uint8).max;
        boundaryAmounts[3] = type(uint16).max;
        boundaryAmounts[4] = type(uint32).max;
        boundaryAmounts[5] = type(uint64).max;
        boundaryAmounts[6] = type(uint64).max + 1;
        boundaryAmounts[7] = type(uint112).max;      // Balancer uses 112-bit for packed balances
        boundaryAmounts[8] = type(uint112).max + 1;
        boundaryAmounts[9] = type(uint128).max;
        boundaryAmounts[10] = type(uint128).max + 1;
        boundaryAmounts[11] = type(uint256).max / 2;
        boundaryAmounts[12] = type(uint256).max / 2 + 1;
        boundaryAmounts[13] = type(uint256).max - 1;
        boundaryAmounts[14] = type(uint256).max;

        for (uint i = 0; i < boundaryAmounts.length; i++) {
            uint256 amt = boundaryAmounts[i];

            IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](1);
            swaps[0] = IVault.BatchSwapStep({
                poolId: BAL_WETH_POOL,
                assetInIndex: 1,
                assetOutIndex: 0,
                amount: amt,
                userData: ""
            });

            try VAULT.queryBatchSwap(IVault.SwapKind.GIVEN_IN, swaps, assets, funds) returns (int256[] memory deltas) {
                console.log("Amount:", amt);
                console.log("  SUCCESS, BAL out:", uint256(-deltas[0]));
            } catch {
                // Expected for extreme values
            }
        }
    }

    receive() external payable {}
}
