// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Morpho Blue sUSDe Oracle Exploit Analysis
 * @notice Analyzing if stale oracle can be exploited in Morpho sUSDe markets
 *
 * Key Finding: Morpho Blue has NO oracle validation
 * - No staleness checks
 * - No price range checks
 * - Single oracle dependency
 * - $38M+ in sUSDe
 */

interface IMorphoBlue {
    struct MarketParams {
        address loanToken;
        address collateralToken;
        address oracle;
        address irm;
        uint256 lltv;
    }

    struct Market {
        uint128 totalSupplyAssets;
        uint128 totalSupplyShares;
        uint128 totalBorrowAssets;
        uint128 totalBorrowShares;
        uint128 lastUpdate;
        uint128 fee;
    }

    struct Position {
        uint256 supplyShares;
        uint128 borrowShares;
        uint128 collateral;
    }

    function market(bytes32 id) external view returns (Market memory);
    function position(bytes32 id, address user) external view returns (Position memory);
    function idToMarketParams(bytes32 id) external view returns (MarketParams memory);
}

interface IOracle {
    function price() external view returns (uint256);
}

interface IChainlinkOracle {
    function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80);
    function latestAnswer() external view returns (int256);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function decimals() external view returns (uint8);
    function symbol() external view returns (string memory);
}

contract MorphoSUSDeExploit is Test {
    address constant MORPHO_BLUE = 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb;
    address constant SUSDE = 0x9D39A5DE30e57443BfF2A8307A4256c8797A3497;
    address constant USDE = 0x4c9EDD5852cd905f086C759E8383e09bff1E68B3;
    address constant USDE_USD_ORACLE = 0xa569d910839Ae8865Da8F8e70FfFb0cBA869F961;

    // Known Morpho sUSDe market IDs (need to find these)
    bytes32[] public marketIds;

    string constant RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    function setUp() public {
        vm.createSelectFork(RPC_URL);
    }

    function test_FindSUSDeMarkets() public view {
        console.log("=== Finding sUSDe Markets in Morpho Blue ===\n");

        // Known Morpho sUSDe market parameters
        // We need to find markets where sUSDe is collateral

        IMorphoBlue morpho = IMorphoBlue(MORPHO_BLUE);

        // Try some known market IDs for sUSDe
        // Market ID is keccak256 of packed market params

        console.log("Morpho Blue contract:", MORPHO_BLUE);
        console.log("sUSDe address:", SUSDE);
        console.log("sUSDe in Morpho:", IERC20(SUSDE).balanceOf(MORPHO_BLUE) / 1e18);

        // To find market IDs, we'd need to look at events or known deployments
        // For now, let's check the oracle staleness issue

        IChainlinkOracle usdeOracle = IChainlinkOracle(USDE_USD_ORACLE);
        (, int256 price,, uint256 updatedAt,) = usdeOracle.latestRoundData();

        console.log("\nUSDe Oracle Status:");
        console.log("  Price:", uint256(price));
        console.log("  Staleness:", block.timestamp - updatedAt, "seconds");
        console.log("           =", (block.timestamp - updatedAt) / 3600, "hours");
    }

    function test_AnalyzeOracleExploit() public view {
        console.log("=== Oracle Exploit Analysis ===\n");

        // Get current USDe oracle price
        IChainlinkOracle usdeOracle = IChainlinkOracle(USDE_USD_ORACLE);
        (, int256 oraclePrice,, uint256 updatedAt,) = usdeOracle.latestRoundData();

        uint256 staleness = block.timestamp - updatedAt;
        uint256 oraclePriceNorm = uint256(oraclePrice);

        console.log("Oracle Analysis:");
        console.log("  Current oracle price:", oraclePriceNorm);
        console.log("  (100000000 = $1.00)");
        console.log("  Staleness:", staleness / 3600, "hours");

        // Calculate potential arbitrage
        // If Morpho uses this oracle and it's stale:

        // Scenario 1: Oracle says $0.999, real price is $0.990
        // - Deposit sUSDe valued at $0.999 by oracle
        // - Borrow more than collateral is really worth
        // - Default, keep the borrowed assets
        // - Profit = borrowed - (real collateral value + gas)

        uint256 collateralAmount = 1_000_000e18; // 1M sUSDe
        uint256 sUsdeSharePrice = 1.217e18; // From earlier test
        uint256 usdeValue = collateralAmount * sUsdeSharePrice / 1e18;

        console.log("\nHypothetical Attack (1M sUSDe):");
        console.log("  sUSDe deposited:", collateralAmount / 1e18);
        console.log("  USDe value:", usdeValue / 1e18);

        // At 80% LLTV (typical)
        uint256 maxBorrow80 = usdeValue * 80 / 100;
        console.log("  Max borrow (80% LLTV):", maxBorrow80 / 1e18);

        // If real price is 1% lower than oracle
        uint256 realValue = usdeValue * 99 / 100;
        console.log("  If real price 1% lower:", realValue / 1e18);

        // Profit = maxBorrow - realValue
        if (maxBorrow80 > realValue) {
            uint256 profit = maxBorrow80 - realValue;
            console.log("\n  POTENTIAL PROFIT:", profit / 1e18);
        } else {
            console.log("\n  No immediate profit at 1% discrepancy");
            console.log("  Would need larger price movement");
        }
    }

    function test_CheckMorphoOracleType() public view {
        console.log("=== Checking Morpho Oracle Types ===\n");

        // Morpho uses custom oracle adapters that wrap Chainlink
        // Let's check if there are any sUSDe-related oracles

        // Known Morpho oracle addresses to check
        address[] memory potentialOracles = new address[](5);
        potentialOracles[0] = 0xa569d910839Ae8865Da8F8e70FfFb0cBA869F961; // USDe/USD
        potentialOracles[1] = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419; // ETH/USD
        potentialOracles[2] = 0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6; // USDC/USD
        potentialOracles[3] = 0x3E7d1eAB13ad0104d2750B8863b489D65364e32D; // USDT/USD
        potentialOracles[4] = 0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9; // DAI/USD

        for (uint i = 0; i < potentialOracles.length; i++) {
            if (potentialOracles[i].code.length == 0) continue;

            try IChainlinkOracle(potentialOracles[i]).latestRoundData() returns (
                uint80, int256 price, uint256, uint256 updatedAt, uint80
            ) {
                uint256 staleness = block.timestamp - updatedAt;
                console.log("Oracle", i);
                console.log("  Price:", uint256(price));
                console.log("  Staleness:", staleness / 3600, "hours");
            } catch {
                console.log("Oracle", i, "- failed to read");
            }
        }
    }

    function test_AttackVector() public view {
        console.log("=== Attack Vector Summary ===\n");

        console.log("VULNERABILITY:");
        console.log("1. Morpho Blue accepts oracle prices without validation");
        console.log("2. USDe oracle is stale (10+ hours)");
        console.log("3. $38M+ sUSDe in Morpho markets");

        console.log("\nATTACK REQUIREMENTS:");
        console.log("1. Find Morpho market using stale USDe oracle");
        console.log("2. Wait for significant price movement");
        console.log("3. Deposit sUSDe, borrow against stale price");
        console.log("4. Default on loan if profitable");

        console.log("\nBLOCKERS:");
        console.log("1. Need to find specific market ID and oracle");
        console.log("2. Morpho oracles might have additional wrappers");
        console.log("3. Price movement needed (>20% for 80% LLTV profit)");

        console.log("\nSTATUS: NEEDS MORE INVESTIGATION");
        console.log("- Must find exact Morpho sUSDe market configuration");
        console.log("- Must verify oracle adapter chain");
    }
}
