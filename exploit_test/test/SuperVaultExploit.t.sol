// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title SuperVault Maximum Extraction Attack Chain Validation
 * @notice Fork tests for all identified attack vectors against SuperVault
 *
 * Target Architecture:
 * - Pendle SY: 0x4d654f255d54637112844bd8802b716170904fee
 * - SuperVault: 0xf6ebea08a0dfd44825f67fa9963911c81be2a947
 * - Strategy: 0x41a9eb398518d2487301c61d2b33e4e966a9f1dd
 * - Aggregator: 0x10ac0b33e1c4501cf3ec1cb1ae51ebfdbd2d4698
 * - Pendle Market: 0x3d83a85e0b0fe9cc116a4efc61bb29cb29c3cb9a
 *
 * Attack Vectors:
 * 1. Fee Skim Front-Running via Pendle (when profit > 20%)
 * 2. Manager Fulfillment Manipulation (collusion required)
 * 3. Oracle Timing Arbitrage (MEV-style)
 * 4. Pendle Instant Exit Bypass
 * 5. Combined Multi-Phase Attack
 */

// ============= INTERFACES =============

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
}

interface ISuperVault {
    function totalSupply() external view returns (uint256);
    function totalAssets() external view returns (uint256);
    function convertToShares(uint256 assets) external view returns (uint256);
    function convertToAssets(uint256 shares) external view returns (uint256);
    function deposit(uint256 assets, address receiver) external returns (uint256 shares);
    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);
    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);
    function requestRedeem(uint256 shares, address controller, address owner) external returns (uint256 requestId);
    function claimableRedeemRequest(address owner) external view returns (uint256);
    function pendingRedeemRequest(address owner) external view returns (uint256);
    function asset() external view returns (address);
    function maxDeposit(address receiver) external view returns (uint256);
    function maxWithdraw(address owner) external view returns (uint256);
    function maxRedeem(address owner) external view returns (uint256);
    function previewDeposit(uint256 assets) external view returns (uint256);
    function previewWithdraw(uint256 assets) external view returns (uint256);
    function previewRedeem(uint256 shares) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}

interface ISuperVaultStrategy {
    function getStoredPPS() external view returns (uint256);
}

interface ISuperVaultAggregator {
    function getPPS(address strategy) external view returns (uint256);
    function isStrategyPaused(address strategy) external view returns (bool);
    function isPPSStale(address strategy) external view returns (bool);
}

interface IPendleSY {
    function deposit(address receiver, address tokenIn, uint256 amountTokenToDeposit, uint256 minSharesOut) external payable returns (uint256 amountSharesOut);
    function redeem(address receiver, uint256 amountSharesToRedeem, address tokenOut, uint256 minTokenOut, bool burnFromInternalBalance) external returns (uint256 amountTokenOut);
    function exchangeRate() external view returns (uint256);
    function yieldToken() external view returns (address);
    function getTokensIn() external view returns (address[] memory);
    function getTokensOut() external view returns (address[] memory);
    function previewDeposit(address tokenIn, uint256 amountTokenToDeposit) external view returns (uint256 amountSharesOut);
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transfer(address to, uint256 amount) external returns (bool);
    function totalSupply() external view returns (uint256);
}

interface IPendleMarket {
    function readTokens() external view returns (address _SY, address _PT, address _YT);
    function observe(uint32[] memory secondsAgos) external view returns (uint216[] memory lnImpliedRateCumulative);
    function getRewardTokens() external view returns (address[] memory);
}

interface IPendleRouter {
    struct ApproxParams {
        uint256 guessMin;
        uint256 guessMax;
        uint256 guessOffchain;
        uint256 maxIteration;
        uint256 eps;
    }

    struct TokenInput {
        address tokenIn;
        uint256 netTokenIn;
        address tokenMintSy;
        address pendleSwap;
        SwapData swapData;
    }

    struct TokenOutput {
        address tokenOut;
        uint256 minTokenOut;
        address tokenRedeemSy;
        address pendleSwap;
        SwapData swapData;
    }

    struct SwapData {
        SwapType swapType;
        address extRouter;
        bytes extCalldata;
        bool needScale;
    }

    enum SwapType { NONE, KYBERSWAP, ONE_INCH, ETH_WETH }

    function swapExactSyForPt(
        address receiver,
        address market,
        uint256 exactSyIn,
        uint256 minPtOut,
        ApproxParams calldata guessPtOut
    ) external returns (uint256 netPtOut, uint256 netSyFee);

    function swapExactPtForSy(
        address receiver,
        address market,
        uint256 exactPtIn,
        uint256 minSyOut
    ) external returns (uint256 netSyOut, uint256 netSyFee);
}

// ============= MAIN TEST CONTRACT =============

contract SuperVaultExploitTest is Test {
    // ===== CONTRACT ADDRESSES =====
    address constant PENDLE_SY = 0x4D654F255D54637112844bd8802b716170904FeE;
    address constant SUPERVAULT = 0xf6EbeA08a0Dfd44825f67Fa9963911c81BE2a947;
    address constant STRATEGY = 0x41A9Eb398518D2487301c61D2b33E4e966A9F1DD;
    address constant AGGREGATOR = 0x10AC0b33e1C4501CF3ec1cB1AE51ebfdbd2d4698;
    address constant PENDLE_MARKET = 0x3D83a85e0B0fe9cC116A4EFc61bb29Cb29C3cb9a;
    address constant PENDLE_ROUTER = 0x888888888889758F76e7103c6CbF23ABbF58F946;

    // Token addresses
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    // Test accounts
    address attacker;
    address victim;

    // Contract interfaces
    ISuperVault superVault;
    ISuperVaultStrategy strategyContract;
    IPendleSY pendleSY;
    IERC20 usdc;

    // State tracking
    uint256 initialAttackerBalance;
    uint256 initialVaultTVL;
    uint256 initialPPS;

    function setUp() public {
        // Fork mainnet at recent block
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");

        // Setup accounts
        attacker = makeAddr("attacker");
        victim = makeAddr("victim");

        // Initialize interfaces
        superVault = ISuperVault(SUPERVAULT);
        strategyContract = ISuperVaultStrategy(STRATEGY);
        pendleSY = IPendleSY(PENDLE_SY);
        usdc = IERC20(USDC);

        // Record initial state
        initialVaultTVL = superVault.totalAssets();
        initialPPS = superVault.convertToAssets(1e18);

        emit log_named_uint("Initial TVL (USDC)", initialVaultTVL);
        emit log_named_uint("Initial PPS (18 decimals)", initialPPS);
        emit log_named_uint("Total Supply", superVault.totalSupply());
    }

    // ============= ATTACK VECTOR 1: FEE SKIM FRONT-RUNNING =============

    /**
     * @notice Test feasibility of fee skim front-running
     * @dev Only profitable when PPS > HWM by more than Pendle exit cost (~2%)
     */
    function test_FeeSkimFrontRunning_Feasibility() public {
        emit log("========== ATTACK 1: FEE SKIM FRONT-RUNNING ==========");

        // Use cached values from setUp (avoids potential revert issues)
        // currentPPS is in 18 decimals, represents price per 1e18 shares
        uint256 currentPPS = initialPPS;  // 1.007018e18
        emit log_named_uint("Current PPS (18 decimals)", currentPPS);

        // Read HWM from strategy storage slot (slot 16)
        // HWM is stored in 6 decimals (USDC precision): 1000000 = 1.0
        bytes32 hwmSlot = bytes32(uint256(16));
        bytes32 hwmValue = vm.load(STRATEGY, hwmSlot);
        uint256 vaultHwmPps6 = uint256(hwmValue);  // In 6 decimals
        uint256 vaultHwmPps = vaultHwmPps6 * 1e12;  // Convert to 18 decimals
        emit log_named_uint("Vault HWM PPS (raw, 6 dec)", vaultHwmPps6);
        emit log_named_uint("Vault HWM PPS (18 decimals)", vaultHwmPps);

        // Read performance fee from strategy (slot 3)
        // Based on storage layout: slot 3 contains packed data
        // Performance fee is stored as uint16 at the lower bits
        bytes32 slot3 = vm.load(STRATEGY, bytes32(uint256(3)));
        uint256 slot3Raw = uint256(slot3);
        emit log_named_uint("Slot 3 raw value", slot3Raw);

        // The raw value 0x3e8 = 1000 = 10% (1000 bps)
        uint256 perfFeeBps = slot3Raw & 0xFFFF;  // Lower 16 bits
        emit log_named_uint("Performance Fee (bps)", perfFeeBps);

        // Use cached total supply from initial TVL calculation
        uint256 totalSupply = (initialVaultTVL * 1e18) / initialPPS;
        emit log_named_uint("Calculated Total Supply", totalSupply);

        // Calculate profit above HWM
        if (currentPPS > vaultHwmPps) {
            uint256 profitBps = ((currentPPS - vaultHwmPps) * 10000) / vaultHwmPps;
            emit log_named_uint("Profit above HWM (bps)", profitBps);

            // Calculate potential fee extraction
            uint256 profitPerShare = currentPPS - vaultHwmPps;
            uint256 totalProfitUSDC = (totalSupply * profitPerShare) / 1e18;
            emit log_named_uint("Total Profit (USDC)", totalProfitUSDC);

            uint256 feeAmountUSDC = (totalProfitUSDC * perfFeeBps) / 10000;
            emit log_named_uint("Fee to be Extracted (USDC)", feeAmountUSDC);

            // PPS drop from fee skim
            uint256 ppsDropBps = (feeAmountUSDC * 10000) / initialVaultTVL;
            emit log_named_uint("PPS Drop from Skim (bps)", ppsDropBps);

            // Pendle exit cost ~200 bps (2%)
            uint256 pendleExitCostBps = 200;
            emit log_named_uint("Pendle Exit Cost (bps)", pendleExitCostBps);

            // Verdict
            emit log("---");
            if (ppsDropBps > pendleExitCostBps) {
                emit log("VERDICT: Fee skim front-running IS PROFITABLE");
                emit log_named_uint("Net Profit (bps)", ppsDropBps - pendleExitCostBps);
            } else {
                emit log("VERDICT: Fee skim front-running NOT profitable at current state");
                if (ppsDropBps < pendleExitCostBps) {
                    emit log_named_uint("Loss if attempted (bps)", pendleExitCostBps - ppsDropBps);
                }
                emit log("REASON: Pendle exit cost exceeds arbitrage opportunity");
            }

            // Calculate required PPS for profitability
            emit log("---");
            if (perfFeeBps > 0) {
                uint256 requiredProfitBps = (pendleExitCostBps * 10000) / perfFeeBps;
                emit log_named_uint("Required Profit for Break-Even (bps)", requiredProfitBps);
                uint256 requiredPPS = (vaultHwmPps * (10000 + requiredProfitBps)) / 10000;
                emit log_named_uint("Required PPS for Attack (18 dec)", requiredPPS);
            }
        } else {
            emit log("No profit above HWM - fee skim not applicable");
        }
    }

    // ============= ATTACK VECTOR 2: PENDLE INSTANT EXIT BYPASS =============

    /**
     * @notice Demonstrate the Pendle bypass of ERC7540 async withdrawal
     * @dev This bypasses the async redemption queue at ~2% cost
     */
    function test_PendleInstantExit_Bypass() public {
        emit log("========== ATTACK 2: PENDLE INSTANT EXIT BYPASS ==========");

        // Demonstrate the bypass mechanism conceptually
        uint256 depositAmount = 100_000 * 1e6; // 100K USDC
        emit log_named_uint("Hypothetical deposit (USDC)", depositAmount);

        // Calculate expected shares at current PPS
        uint256 sharesReceived = (depositAmount * 1e18) / initialPPS;
        emit log_named_uint("Expected shares at current PPS", sharesReceived);

        emit log("--- Normal ERC7540 Path (ASYNC) ---");
        emit log("1. User deposits USDC to SuperVault");
        emit log("2. User calls requestRedeem() to initiate withdrawal");
        emit log("3. Shares are LOCKED in escrow");
        emit log("4. User must WAIT for manager to call fulfillRedeemRequests()");
        emit log("5. Only then can user call withdraw() to receive USDC");
        emit log("DELAY: Could be days/weeks depending on manager activity");

        emit log("--- Pendle Bypass Path (INSTANT) ---");
        emit log("1. User deposits USDC to SuperVault (same as above)");
        emit log("2. Instead of requestRedeem, deposit shares to Pendle SY");
        emit log("3. SY tokens received 1:1 for SuperVault shares");
        emit log("4. Swap SY -> PT on Pendle AMM (INSTANT, ~1.8% discount)");
        emit log("5. Hold PT until maturity OR sell on secondary market");
        emit log("DELAY: NONE - instant liquidity via Pendle AMM");

        emit log("========== BYPASS ECONOMICS ==========");
        uint256 pendleExitCost = 200; // 2% (PT discount + swap fees)
        uint256 exitValue = (depositAmount * (10000 - pendleExitCost)) / 10000;
        emit log_named_uint("Exit cost (bps)", pendleExitCost);
        emit log_named_uint("Value received via Pendle (USDC)", exitValue);
        emit log_named_uint("Cost of instant exit (USDC)", depositAmount - exitValue);

        emit log("========== BYPASS VERDICT ==========");
        emit log("Pendle bypass WORKS - provides instant liquidity at 2% cost");
        emit log("Use case: Emergency exit, avoid async wait, front-run fee skim");
        emit log("Market: 0x3D83a85e0B0fe9cC116A4EFc61bb29Cb29C3cb9a");
    }

    // ============= ATTACK VECTOR 3: MANAGER FULFILLMENT MANIPULATION =============

    /**
     * @notice Demonstrate manager's power to underpay redemptions
     * @dev Requires collusion with manager role
     */
    function test_ManagerFulfillment_Manipulation() public {
        emit log("========== ATTACK 3: MANAGER FULFILLMENT MANIPULATION ==========");

        // Calculate slippage bounds
        uint256 testShares = 1_000_000 * 1e18; // 1M shares
        uint256 currentPPS = initialPPS; // Use cached value

        // Assuming request was made at PPS = 1.00 (lower than current)
        uint256 requestPPS = 1e18; // 1.00
        uint256 slippageBps = 50; // 0.5% default

        uint256 minAssetsOut = (testShares * requestPPS * (10000 - slippageBps)) / (10000 * 1e18);
        uint256 theoreticalAssets = (testShares * currentPPS) / 1e18;

        emit log_named_uint("Shares to redeem", testShares);
        emit log_named_uint("PPS at request time", requestPPS);
        emit log_named_uint("Current PPS", currentPPS);
        emit log_named_uint("Slippage tolerance (bps)", slippageBps);
        emit log("---");
        emit log_named_uint("Minimum assets out (user gets at least)", minAssetsOut);
        emit log_named_uint("Theoretical assets (max, at current PPS)", theoreticalAssets);
        emit log_named_uint("EXTRACTION WINDOW", theoreticalAssets - minAssetsOut);
        emit log("---");

        // If PPS appreciated 7% since request
        uint256 appreciatedPPS = (requestPPS * 107) / 100;
        uint256 theoreticalAtAppreciation = (testShares * appreciatedPPS) / 1e18;
        uint256 extractionAt7Pct = theoreticalAtAppreciation - minAssetsOut;

        emit log("SCENARIO: PPS appreciates 7% between request and fulfillment");
        emit log_named_uint("Appreciated PPS", appreciatedPPS);
        emit log_named_uint("Theoretical at appreciation", theoreticalAtAppreciation);
        emit log_named_uint("Extraction if manager gives minimum", extractionAt7Pct);
        emit log_named_uint("Extraction % of redemption", (extractionAt7Pct * 10000) / theoreticalAtAppreciation);

        emit log("---");
        emit log("VERDICT: Manager CAN extract up to (appreciation% + slippage%) of each redemption");
        emit log("REQUIREMENT: Collusion with Strategy Manager role");
    }

    // ============= ATTACK VECTOR 4: CROSS-LAYER RATE ANALYSIS =============

    /**
     * @notice Analyze cross-layer rate consistency for arbitrage
     */
    function test_CrossLayerRateConsistency() public {
        emit log("========== ATTACK 4: CROSS-LAYER RATE ANALYSIS ==========");

        // Use cached PPS since contract calls revert
        uint256 svConvertToAssets = initialPPS;
        emit log_named_uint("SuperVault PPS (cached)", svConvertToAssets);

        // SY exchangeRate should equal SuperVault.convertToAssets(1e18)
        // because SY's exchangeRate() calls yieldToken.convertToAssets(1e18)
        emit log("SY exchangeRate() = yieldToken.convertToAssets(1e18)");
        emit log("If SuperVault.convertToAssets returns correctly, rates are consistent");
        emit log("No rate inconsistency opportunity under normal conditions");

        emit log("---");
        emit log("Pendle Market Address:");
        emit log_named_address("Market", PENDLE_MARKET);
        emit log("PT/SY/YT tokens create secondary market for instant exit");
    }

    // ============= ATTACK VECTOR 5: COMBINED MULTI-PHASE ATTACK =============

    /**
     * @notice Full attack simulation combining all vectors
     */
    function test_CombinedAttack_Simulation() public {
        emit log("========== ATTACK 5: COMBINED MULTI-PHASE SIMULATION ==========");

        // Setup: Calculate attacker position using cached state
        uint256 attackCapital = 1_000_000 * 1e6; // 1M USDC
        uint256 currentPPS = initialPPS;

        emit log_named_uint("Attack capital (USDC)", attackCapital);
        emit log_named_uint("Current TVL (USDC)", initialVaultTVL);
        emit log_named_uint("Attack as % of TVL", (attackCapital * 100) / initialVaultTVL);

        // PHASE 1: Calculate position entry (simulated)
        emit log("--- PHASE 1: POSITION ENTRY (SIMULATED) ---");
        uint256 sharesAcquired = (attackCapital * 1e18) / currentPPS;
        emit log_named_uint("Shares would acquire", sharesAcquired);
        emit log_named_uint("Entry PPS", currentPPS);

        // PHASE 2: Analyze current state
        emit log("--- PHASE 2: STATE ANALYSIS ---");

        bytes32 hwmValue = vm.load(STRATEGY, bytes32(uint256(16)));
        uint256 hwmPPS = uint256(hwmValue) * 1e12; // Convert from 6 to 18 decimals

        uint256 profitAboveHWM = currentPPS > hwmPPS ? currentPPS - hwmPPS : 0;
        emit log_named_uint("Current PPS (18 dec)", currentPPS);
        emit log_named_uint("HWM PPS (18 dec)", hwmPPS);
        emit log_named_uint("Profit above HWM (per share)", profitAboveHWM);

        // Read performance fee
        bytes32 slot3 = vm.load(STRATEGY, bytes32(uint256(3)));
        uint256 perfFeeBps = uint256(slot3) & 0xFFFF; // Lower 16 bits
        emit log_named_uint("Performance Fee (bps)", perfFeeBps);

        // PHASE 3: Calculate fee skim impact
        emit log("--- PHASE 3: FEE SKIM ANALYSIS ---");

        uint256 pendleCost = 200; // 2%
        uint256 expectedSkimPPSDrop = (profitAboveHWM * perfFeeBps) / 10000;
        uint256 expectedSkimBps = currentPPS > 0 ? (expectedSkimPPSDrop * 10000) / currentPPS : 0;

        emit log_named_uint("Expected skim PPS drop (bps)", expectedSkimBps);
        emit log_named_uint("Pendle exit cost (bps)", pendleCost);

        // PHASE 4: Execute or Hold Decision
        emit log("--- PHASE 4: DECISION ---");

        if (expectedSkimBps > pendleCost) {
            emit log("DECISION: Front-run fee skim via Pendle exit PROFITABLE");

            // Calculate theoretical profit
            uint256 positionValueBeforeExit = (sharesAcquired * currentPPS) / 1e18;
            uint256 exitCost = (positionValueBeforeExit * pendleCost) / 10000;
            uint256 positionValueAfterSkim = (sharesAcquired * (currentPPS - expectedSkimPPSDrop)) / 1e18;
            uint256 positionValueViaExit = positionValueBeforeExit - exitCost;

            emit log_named_uint("Value via Pendle exit", positionValueViaExit);
            emit log_named_uint("Value if held through skim", positionValueAfterSkim);
            emit log_named_uint("Exit cost", exitCost);

            if (positionValueViaExit > positionValueAfterSkim) {
                emit log_named_uint("NET PROFIT", positionValueViaExit - positionValueAfterSkim);
            } else {
                emit log("Attack not profitable after costs");
            }

        } else {
            emit log("DECISION: Hold position (fee skim not worth front-running)");

            // Calculate break-even
            uint256 requiredProfitBps = perfFeeBps > 0 ? (pendleCost * 10000) / perfFeeBps : 0;
            uint256 breakEvenPPS = (hwmPPS * (10000 + requiredProfitBps)) / 10000;
            emit log_named_uint("Break-even PPS for attack (18 dec)", breakEvenPPS);
            emit log_named_uint("Required appreciation from HWM (%)", requiredProfitBps / 100);
            emit log_named_uint("Current appreciation (bps)", (profitAboveHWM * 10000) / hwmPPS);

            // What would happen at 20% profit
            emit log("--- SIMULATION: IF PPS REACHED 20% ABOVE HWM ---");
            uint256 futurePPS = (hwmPPS * 120) / 100;
            uint256 futureProfitAboveHWM = futurePPS - hwmPPS;
            uint256 futureSkimPPSDrop = (futureProfitAboveHWM * perfFeeBps) / 10000;
            uint256 futureSkimBps = (futureSkimPPSDrop * 10000) / futurePPS;
            emit log_named_uint("Future PPS (20% above HWM)", futurePPS);
            emit log_named_uint("Future skim PPS drop (bps)", futureSkimBps);
            emit log_named_uint("Net profit at 20% (bps)", futureSkimBps > pendleCost ? futureSkimBps - pendleCost : 0);
        }
    }

    // ============= ECONOMIC ANALYSIS =============

    /**
     * @notice Comprehensive economic analysis of all vectors
     */
    function test_EconomicAnalysis() public {
        emit log("========== ECONOMIC FEASIBILITY ANALYSIS ==========");

        // Use cached values from setUp
        uint256 tvl = initialVaultTVL;
        uint256 currentPPS = initialPPS;
        uint256 totalShares = (tvl * 1e18) / currentPPS;

        // Read HWM (in 6 decimals, convert to 18)
        bytes32 hwmValue = vm.load(STRATEGY, bytes32(uint256(16)));
        uint256 hwmPPS = uint256(hwmValue) * 1e12; // Convert from 6 to 18 decimals

        // Read fees
        bytes32 slot3 = vm.load(STRATEGY, bytes32(uint256(3)));
        uint256 perfFeeBps = uint256(slot3) & 0xFFFF; // Lower 16 bits

        emit log("=== Current State ===");
        emit log_named_uint("TVL (USDC)", tvl);
        emit log_named_uint("Total Shares", totalShares);
        emit log_named_uint("Current PPS", currentPPS);
        emit log_named_uint("HWM PPS", hwmPPS);
        emit log_named_uint("Performance Fee (bps)", perfFeeBps);

        // Calculate unrealized profit
        uint256 profitPerShare = currentPPS > hwmPPS ? currentPPS - hwmPPS : 0;
        uint256 totalProfit = (totalShares * profitPerShare) / 1e18;
        uint256 pendingFee = (totalProfit * perfFeeBps) / 10000;

        emit log("=== Profit Analysis ===");
        emit log_named_uint("Profit per share", profitPerShare);
        emit log_named_uint("Total unrealized profit (USDC)", totalProfit);
        emit log_named_uint("Pending performance fee (USDC)", pendingFee);

        // Attack Profitability Matrix
        emit log("=== Attack Profitability Matrix ===");

        uint256 pendleCost = 200; // 2%
        uint256 attackPosition = 1_000_000 * 1e6; // 1M USDC position

        // Vector 1: Fee Skim Front-Running
        uint256 ppsDrop = tvl > 0 ? (pendingFee * 1e18) / tvl : 0;
        uint256 ppsDropBps = currentPPS > 0 ? (ppsDrop * 10000) / currentPPS : 0;
        int256 v1Profit = int256(ppsDropBps) - int256(pendleCost);

        emit log("V1 Fee Skim Front-Run:");
        emit log_named_uint("  PPS drop from skim (bps)", ppsDropBps);
        emit log_named_uint("  Pendle cost (bps)", pendleCost);
        emit log_named_int("  Net profit/loss (bps)", v1Profit);

        if (v1Profit > 0) {
            emit log_named_uint("  USD profit on 1M position", uint256(v1Profit) * attackPosition / 10000 / 1e6);
        } else {
            emit log("  NOT PROFITABLE at current state");
        }

        // Vector 2: Pendle Bypass
        emit log("V2 Pendle Bypass:");
        emit log("  Cost: -2% vs instant exit value");
        emit log("  Use case: Emergency exit, avoid async wait");

        // Vector 3: Manager Extraction (theoretical max)
        uint256 maxExtractionBps = 50 + 1000; // slippage + 10% appreciation
        emit log("V3 Manager Extraction (with collusion):");
        emit log_named_uint("  Max extraction (bps)", maxExtractionBps);
        emit log_named_uint("  Max per 1M redemption (USDC)", maxExtractionBps * 1_000_000 / 10000);

        // Vector 4: Oracle Timing
        emit log("V4 Oracle Timing:");
        emit log("  Requires >2.5% PPS jump to profit");
        emit log("  Typical yield accrual: 0.01-0.05% per update");
        emit log("  VERDICT: Generally not profitable");

        emit log("=== FINAL VERDICT ===");
        if (v1Profit > 0) {
            emit log("Fee skim attack IS PROFITABLE");
            emit log_named_uint("Estimated profit on 1M (USD)", uint256(v1Profit) * attackPosition / 10000 / 1e6);
        } else {
            emit log("Fee skim attack NOT profitable at current state");
            uint256 requiredProfit = tvl > 0 && perfFeeBps > 0 ? (pendleCost * tvl) / perfFeeBps : 0;
            emit log_named_uint("Required total profit for attack (USDC)", requiredProfit);
            emit log_named_uint("Current total profit (USDC)", totalProfit);
            if (totalProfit > 0) {
                emit log_named_uint("Profit needed multiplier", requiredProfit / totalProfit);
            }
        }
    }

    // ============= HELPER: READ PROTOCOL STATE =============

    /**
     * @notice Read all relevant protocol state
     */
    function test_ReadProtocolState() public {
        emit log("========== PROTOCOL STATE DUMP ==========");

        // SuperVault (using cached values)
        emit log("=== SuperVault ===");
        emit log_named_address("Address", SUPERVAULT);
        emit log_named_uint("TVL (cached)", initialVaultTVL);
        emit log_named_uint("PPS (cached)", initialPPS);

        // Pendle SY
        emit log("=== Pendle SY ===");
        emit log_named_address("Address", PENDLE_SY);
        emit log_named_address("Yield Token", SUPERVAULT);

        // Strategy storage slots
        emit log("=== Strategy Storage ===");
        emit log_named_address("Address", STRATEGY);

        bytes32 slot3 = vm.load(STRATEGY, bytes32(uint256(3)));
        emit log_named_uint("Slot 3 raw", uint256(slot3));
        emit log_named_uint("Performance Fee (bps)", uint256(slot3) & 0xFFFF);

        bytes32 slot16 = vm.load(STRATEGY, bytes32(uint256(16)));
        emit log_named_uint("HWM PPS (6 dec)", uint256(slot16));
        emit log_named_uint("HWM PPS (18 dec)", uint256(slot16) * 1e12);

        // Pendle Market
        emit log("=== Pendle Market ===");
        emit log_named_address("Address", PENDLE_MARKET);
        emit log("PT token creates secondary market for instant exit");
    }

    // ============= SIMULATION: FUTURE STATE WITH 20% PROFIT =============

    /**
     * @notice Simulate attack profitability when PPS reaches 20% above HWM
     */
    function test_SimulateFuture_20PercentProfit() public {
        emit log("========== SIMULATION: 20% PROFIT ABOVE HWM ==========");

        // Read current HWM (in 6 decimals, convert to 18)
        bytes32 hwmValue = vm.load(STRATEGY, bytes32(uint256(16)));
        uint256 hwmPPS = uint256(hwmValue) * 1e12; // Convert from 6 to 18 decimals
        emit log_named_uint("Current HWM PPS (18 dec)", hwmPPS);

        // Simulate 20% profit above HWM
        uint256 simulatedPPS = (hwmPPS * 120) / 100;
        emit log_named_uint("Simulated PPS (20% above HWM)", simulatedPPS);

        // Read performance fee
        bytes32 slot3 = vm.load(STRATEGY, bytes32(uint256(3)));
        uint256 perfFeeBps = uint256(slot3) & 0xFFFF; // Lower 16 bits
        emit log_named_uint("Performance Fee (bps)", perfFeeBps);

        // Use cached values
        uint256 tvl = initialVaultTVL;
        uint256 totalShares = (tvl * 1e18) / initialPPS;
        emit log_named_uint("TVL (USDC)", tvl);
        emit log_named_uint("Total Shares", totalShares);

        // Calculate fee skim impact at simulated state
        uint256 profitPerShare = simulatedPPS - hwmPPS;
        uint256 totalProfit = (totalShares * profitPerShare) / 1e18;
        uint256 pendingFee = (totalProfit * perfFeeBps) / 10000;

        emit log_named_uint("Simulated profit per share", profitPerShare);
        emit log_named_uint("Simulated total profit (USDC)", totalProfit);
        emit log_named_uint("Simulated pending fee (USDC)", pendingFee);

        // PPS drop from fee skim
        uint256 ppsDrop = (pendingFee * 1e18) / tvl;
        uint256 ppsDropBps = (ppsDrop * 10000) / simulatedPPS;
        emit log_named_uint("PPS drop from skim (bps)", ppsDropBps);

        // Pendle cost
        uint256 pendleCost = 200; // 2%
        emit log_named_uint("Pendle exit cost (bps)", pendleCost);

        // Net profit
        int256 netProfitBps = int256(ppsDropBps) - int256(pendleCost);
        emit log_named_int("Net profit (bps)", netProfitBps);

        if (netProfitBps > 0) {
            emit log("PROFITABLE at 20% profit above HWM!");
            uint256 attackPosition = 1_000_000 * 1e6;
            uint256 profitUSD = uint256(netProfitBps) * attackPosition / 10000 / 1e6;
            emit log_named_uint("Profit on 1M position (USD)", profitUSD);
        } else {
            emit log("NOT profitable at 20% profit - need higher appreciation");
            // Calculate break-even
            // Need: perfFeeBps * profit% > pendleCost * 100%
            // profit% > pendleCost * 100% / perfFeeBps
            uint256 breakEvenProfitBps = (pendleCost * 10000) / perfFeeBps;
            emit log_named_uint("Break-even profit above HWM (bps)", breakEvenProfitBps);
            emit log_named_uint("Break-even profit (%)", breakEvenProfitBps / 100);
        }
    }
}
