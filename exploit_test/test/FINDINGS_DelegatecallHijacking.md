# Delegatecall Hijacking Investigation Report

## Target Contracts
- **Strategy Contract**: `0x60d2D94aCB969CA54e781007eE89F04c1A2e5943` (Treehouse Protocol)
- **StrategyStorage**: `0x97c03F52244E60BB18511Cbf03f890D5886f1F47`
- **StrategyExecutor**: `0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e`
- **ActionExecutor**: `0xb1593193Bcd7CEcc3d19597658003d735D1e9E94` (DeFiSaver)
- **Vault**: `0x551d155760ae96050439AD24Ae98A96c765d761B`

## Executive Summary

**FINDING: NO UNPRIVILEGED VULNERABILITY PROVEN**

Extensive multi-step analysis performed on Treehouse Protocol. All access controls are functioning correctly.

### Funds at Risk (if owner compromised)
| Contract | wstETH Balance | USD Value |
|----------|---------------|-----------|
| Vault | ~3,658 wstETH | ~$8.5M |
| Strategy 1 | ~21,353 wei | Dust |
| Strategy 2 | ~84,594 wei | Dust |

### Access Control Verified:
| Attack Vector | Result |
|--------------|--------|
| Direct callExecute | BLOCKED - requires strategyExecutor |
| Direct execute | BLOCKED - requires self-call |
| executeOnStrategy (non-executor) | BLOCKED - requires whitelist |
| Executor registration | BLOCKED - requires owner |
| Vault approval exploitation | BLOCKED - spender access controlled |
| Flash loan attack | NO VULNERABLE PATH |
| Callback/reentrancy | NO CALLBACKS FOUND |
| Storage collision | NOT POSSIBLE (immutables only) |

---

## Architecture Analysis

### Execution Flow
```
User -> StrategyExecutor.executeOnStrategy()
     -> Strategy.callExecute(ActionExecutor, data)
     -> Strategy.execute() [self-call]
     -> delegatecall(ActionExecutor)
     -> ActionExecutor.executeActions()
     -> delegatecall(RegisteredAction)
```

### Strategy Contract (0x60d2D94aCB969CA54e781007eE89F04c1A2e5943)
```solidity
function callExecute(address _target, bytes memory _data) external payable returns (bytes32) {
    if (msg.sender != strategyStorage.strategyExecutor()) revert Unauthorized();  // CHECK 1
    _response = IStrategy(address(this)).execute{ value: msg.value }(_target, _data);
}

function execute(address _target, bytes memory _data) external payable returns (bytes32) {
    if (msg.sender != address(this)) revert Unauthorized();  // CHECK 2
    // delegatecall to _target
}
```

### Configuration
- **strategyStorage**: 0x97c03F52244E60BB18511Cbf03f890D5886f1F47
- **vault**: 0x551d155760ae96050439AD24Ae98A96c765d761B
- **Owner**: 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e (CONTRACT - 7866 bytes)

---

## Deep Analysis: Vault Approval

**CRITICAL OBSERVATION**: Vault has approved `0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510` for MAX wstETH.

**Analysis Result**: NOT EXPLOITABLE
- Spender contract owner: Same as Vault owner (0x2225DAbFfC7F862c99477381E971E8B1FDaB467e)
- Spender has no public functions to trigger transferFrom with arbitrary receiver
- Spender is access-controlled vault/controller

---

## Whitelisted Actions (13 total)

| Action ID | Address | Purpose |
|-----------|---------|---------|
| 0xd7e40b2d | 0xbdFb29cCD82dB3ccf462F3CB600892b2E6f185C7 | LidoStake |
| 0x43142355 | 0x160F1f3a512Fa7cCefA0eb08f881282c05d6eb0f | LidoWrap |
| 0xacd039ef | 0xb8cD2bA2A0Ada353aE15398618Fafb1d7BD558C5 | Custom |
| 0x2161dd34 | 0x3e34E0694204e462Deaf8EBbeEE2bE9F887f3C3b | Custom |
| 0x245077a0 | 0x99eAe56224EA5Bcb2c886D0a07154217b7A1E5d1 | Custom |
| 0x3d35d254 | 0x819Bdb303e224CaC4aC14Da17a1ec13895869b65 | Custom |
| 0xfc33bf00 | 0x3503152722beeE269E9B4E0921F2c3D44C90d2b5 | AaveV3Supply |
| 0x9e9290b1 | 0xEE1F8dc0135EE9dC2e00fac3817b9C530d34B6ba | AaveV3Borrow |
| 0x17683e81 | 0x71f4d0A74b7F1BB07cc767dC2f4b436E907476DC | AaveV3Payback |
| 0x72a6498a | 0x0039d822156FF2FD28ac6e19A518660890fcD2E0 | AaveV3Withdraw |
| 0xfebcb52a | 0x313Ca6136521D22A7Ea763B3566Ed0B53F5B3AB9 | Unknown |
| 0x19713586 | 0xc780112305ED959CEEeb0DE692E2407E4145Fc3A | Unknown |
| 0x4f18b88c | 0x351dd4581d61BCE7101FDf5f6864D510021c7CaB | Unknown |

All custom actions have delegatecall but require executor access.

---

## Attack Vectors Tested

### Vector 1: Direct Strategy Calls
- `callExecute()` - BLOCKED (requires strategyExecutor)
- `execute()` - BLOCKED (requires self-call)

### Vector 2: StrategyExecutor Access
- `executeOnStrategy()` - BLOCKED (requires executor whitelist)
- `updateExecutor()` - BLOCKED (onlyOwner)

### Vector 3: Vault Exploitation
- Direct function calls - BLOCKED (no public withdraw functions)
- Approval exploitation - BLOCKED (spender access-controlled)

### Vector 4: Action Vulnerabilities
- LidoStake/LidoWrap analyzed - No exploitable paths without executor access
- Parameter injection - Requires executor access first

### Vector 5: Flash Loan / Reentrancy
- No executeOperation callback found
- No reentrancy entry points

### Vector 6: Storage Collision
- Strategy uses only immutables
- ActionExecutor uses only immutables
- No collision possible

---

## Centralization Risks (NOT Unprivileged Vulnerabilities)

1. **Owner Compromise**: Owner can add malicious executors/actions
2. **Vault Approval**: Spender has MAX approval but is access-controlled
3. **Single Multisig**: All contracts share same owner

---

## Conclusion

**STATUS: UNPROVEN - No unprivileged vulnerability found**

Extensive testing of:
- 8 different attack vectors
- 13 whitelisted actions
- Vault approval chain
- Flash loan possibilities
- Callback/reentrancy paths
- Storage collision

All access controls are functioning correctly. ~$8.5M in wstETH is secure unless owner multisig is compromised.

---

## Reproduction Commands

```bash
forge test --match-contract TreehouseStrategyExploitTest -vvv
forge test --match-contract DeepExploitTest -vvv
forge test --match-contract VaultExploitTest -vvv
forge test --match-contract SpenderExploitTest -vvv
forge test --match-contract FinalExploitTest -vvv
```

---

## Files Created

- `test/TreehouseStrategyExploit.t.sol` - Treehouse Protocol analysis
- `test/DeepExploit.t.sol` - Deep vulnerability analysis
- `test/VaultExploit.t.sol` - Vault analysis
- `test/SpenderExploit.t.sol` - Spender approval analysis
- `test/FinalExploit.t.sol` - Final comprehensive tests
- `test/DelegatecallHijack.t.sol` - Initial proxy analysis
- `test/DelegatecallHijackDeep.t.sol` - Deep DeFiSaver analysis
- `test/DelegatecallExploit.t.sol` - Attack vector testing
- `test/NovelExploit.t.sol` - Function selector analysis
- `test/CustomActionAnalysis.t.sol` - Custom action bytecode analysis
- `test/StrategyStorageExploit.t.sol` - StrategyStorage manipulation attempts
- `test/SelectorExploit.t.sol` - Selector collision testing
- `test/InitializeExploit.t.sol` - Re-initialization attempts
- `test/ProxySearchExploit.t.sol` - DSProxy pattern analysis
- `test/FINDINGS_DelegatecallHijacking.md` - This report

---

## Additional Deep Analysis

### Source Code Analysis
Retrieved and analyzed verified source code for:
- Strategy.sol - Uses immutables only, no storage manipulation possible
- StrategyExecutor.sol - onlyOwner for updateExecutor, executor whitelist check
- ActionExecutor.sol - Uses registry lookup, delegatecalls to registered actions
- StrategyStorage.sol - All mutations are onlyOwner
- ActionRegistry.sol - All registration is onlyOwner

### Custom Actions Analyzed
| Action | Name | External Calls |
|--------|------|----------------|
| 0xb8cD2bA2A0Ada353aE15398618Fafb1d7BD558C5 | LidoUnwrap | wstETH.unwrap() |
| 0x313Ca6136521D22A7Ea763B3566Ed0B53F5B3AB9 | VaultPull | vault.withdraw() |

VaultPull calls `IVaultWithdrawer(IStrategy(msg.sender).vault()).withdraw()` but runs in Strategy context via delegatecall, so it's calling Vault's withdraw with Strategy as the caller - this is authorized.

### Selector Collision Analysis
Found that `updateExecutor(address,bool)` and `mintFeeForTierTwo(uint256)` both hash to 0x34b85e74, but the actual implementation is access-controlled with onlyOwner.

### Proxy Pattern Analysis
- Strategy is NOT a DSProxy (doesn't have owner/authority)
- Strategy is NOT an EIP-1967 proxy (no implementation slot)
- Vault is NOT an EIP-1967 proxy (no implementation slot)

### DSProxy Exploitation
Created test showing DSProxy + ActionExecutor works for attacker-owned proxies, but cannot drain other contracts.

---

## Investigation Status

**ONGOING** - User confirms unprivileged vulnerability exists but is a novel pattern. Continue investigating non-standard attack vectors.

---

## Latest Deep Analysis (Session 2)

### Critical Findings

#### 1. Vault Token Approval
- **Vault (0x551d155760ae96050439AD24Ae98A96c765d761B)** has approved **RedemptionController (0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510)** for MAX wstETH
- This approval allows RedemptionController to call `transferFrom(Vault, receiver, amount)` for any amount

#### 2. Vault.withdraw() Access Control
- Vault has custom `withdraw(address _asset, uint _amount)` function (selector: 0xf3fef3a3)
- **CONFIRMED**: Strategy 0 CAN call Vault.withdraw() successfully (via prank test)
- Random attacker CANNOT call it (fails with error 0x4e236e9a)
- Access control checks if caller is registered Strategy

#### 3. Strategy aWstETH Holdings
- Strategy 0 holds ~33,709 aWstETH (~$77.5M)
- Can be withdrawn via Aave's `pool.withdraw(wstETH, amount, address(this))`
- AaveV3Withdraw action always sends to `address(this)` (Strategy), not controllable

#### 4. VaultPull Action Behavior
```solidity
function _pullToken(Params memory _inputData) internal {
    IVaultWithdrawer(IStrategy(msg.sender).vault()).withdraw(_inputData.token, _inputData.amount);
}
```
- Uses `msg.sender` to get vault (not `address(this)`)
- In delegatecall chain: msg.sender = Strategy
- So VaultPull calls Vault.withdraw() with Strategy as caller → AUTHORIZED

#### 5. RedemptionController Analysis
- Contract: 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510 (4751 bytes)
- Has 4 DELEGATECALL opcodes
- Owner: 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e (same as all other contracts)
- Functions: `redeem()`, `rescueERC20()`, `addRedemption()` - all access controlled

#### 6. Redemption Mechanism
- Two redemption contracts: 0xcd63... and 0x8295...
- 7-day waiting period for redemptions
- Min redeem: 200 wstETH
- Currently ~978 wstETH in redemption queue

### Attack Vector Analysis

#### Vector A: Attacker Proxy + ActionExecutor
- Attacker deploys proxy with `vault()` returning real Vault
- Calls ActionExecutor via delegatecall
- **BLOCKED**: Vault.withdraw() fails because attacker's proxy is not a registered Strategy

#### Vector B: Direct RedemptionController
- All functions (`redeem`, `rescueERC20`, `addRedemption`) are access controlled
- Cannot register malicious redemption contract (onlyOwner)

#### Vector C: Strategy Execution with Attacker Params
- AaveV3Withdraw: `to` parameter is hardcoded to `address(this)` → NOT CONTROLLABLE
- Need to find action that allows controllable destination

### Key Insight from User
> "so cant after it combine with other functions, acts for chainnig and extract asset to proxy and extract from proxy that attacker owned to attacker?"

This suggests a multi-step attack:
1. Use action chaining to extract assets to attacker's proxy
2. Extract from proxy to attacker

### Remaining Investigation Areas
1. Find action with controllable `to` parameter
2. Investigate param mapping exploitation
3. Check if any action does `transferFrom` with controllable source
4. Analyze if delegatecall context can be exploited for identity confusion

### Contracts Source Retrieved
- Strategy.sol - Confirmed access control
- StrategyStorage.sol - All mutations onlyOwner
- VaultPull.sol - Uses msg.sender for vault lookup
- AaveV3Withdraw.sol - No controllable `to` param (always address(this))
