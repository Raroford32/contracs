# Delegatecall Hijacking Investigation Report

## Target Contracts
- **Strategy Contract**: `0x60d2D94aCB969CA54e781007eE89F04c1A2e5943` (Treehouse Protocol)
- **StrategyStorage**: `0x97c03F52244E60BB18511Cbf03f890D5886f1F47`
- **StrategyExecutor**: `0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e`
- **ActionExecutor**: `0xb1593193Bcd7CEcc3d19597658003d735D1e9E94` (DeFiSaver)
- **Vault**: `0x551d155760ae96050439AD24Ae98A96c765d761B`

## Executive Summary

**FINDING: NO UNPRIVILEGED VULNERABILITY PROVEN**

Extensive multi-step analysis performed on Treehouse Protocol. All access controls are functioning correctly.

### Funds at Risk (if owner compromised)
| Contract | wstETH Balance | USD Value |
|----------|---------------|-----------|
| Vault | ~3,658 wstETH | ~$8.5M |
| Strategy 1 | ~21,353 wei | Dust |
| Strategy 2 | ~84,594 wei | Dust |

### Access Control Verified:
| Attack Vector | Result |
|--------------|--------|
| Direct callExecute | BLOCKED - requires strategyExecutor |
| Direct execute | BLOCKED - requires self-call |
| executeOnStrategy (non-executor) | BLOCKED - requires whitelist |
| Executor registration | BLOCKED - requires owner |
| Vault approval exploitation | BLOCKED - spender access controlled |
| Flash loan attack | NO VULNERABLE PATH |
| Callback/reentrancy | NO CALLBACKS FOUND |
| Storage collision | NOT POSSIBLE (immutables only) |

---

## Architecture Analysis

### Execution Flow
```
User -> StrategyExecutor.executeOnStrategy()
     -> Strategy.callExecute(ActionExecutor, data)
     -> Strategy.execute() [self-call]
     -> delegatecall(ActionExecutor)
     -> ActionExecutor.executeActions()
     -> delegatecall(RegisteredAction)
```

### Strategy Contract (0x60d2D94aCB969CA54e781007eE89F04c1A2e5943)
```solidity
function callExecute(address _target, bytes memory _data) external payable returns (bytes32) {
    if (msg.sender != strategyStorage.strategyExecutor()) revert Unauthorized();  // CHECK 1
    _response = IStrategy(address(this)).execute{ value: msg.value }(_target, _data);
}

function execute(address _target, bytes memory _data) external payable returns (bytes32) {
    if (msg.sender != address(this)) revert Unauthorized();  // CHECK 2
    // delegatecall to _target
}
```

### Configuration
- **strategyStorage**: 0x97c03F52244E60BB18511Cbf03f890D5886f1F47
- **vault**: 0x551d155760ae96050439AD24Ae98A96c765d761B
- **Owner**: 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e (CONTRACT - 7866 bytes)

---

## Deep Analysis: Vault Approval

**CRITICAL OBSERVATION**: Vault has approved `0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510` for MAX wstETH.

**Analysis Result**: NOT EXPLOITABLE
- Spender contract owner: Same as Vault owner (0x2225DAbFfC7F862c99477381E971E8B1FDaB467e)
- Spender has no public functions to trigger transferFrom with arbitrary receiver
- Spender is access-controlled vault/controller

---

## Whitelisted Actions (13 total)

| Action ID | Address | Purpose |
|-----------|---------|---------|
| 0xd7e40b2d | 0xbdFb29cCD82dB3ccf462F3CB600892b2E6f185C7 | LidoStake |
| 0x43142355 | 0x160F1f3a512Fa7cCefA0eb08f881282c05d6eb0f | LidoWrap |
| 0xacd039ef | 0xb8cD2bA2A0Ada353aE15398618Fafb1d7BD558C5 | Custom |
| 0x2161dd34 | 0x3e34E0694204e462Deaf8EBbeEE2bE9F887f3C3b | Custom |
| 0x245077a0 | 0x99eAe56224EA5Bcb2c886D0a07154217b7A1E5d1 | Custom |
| 0x3d35d254 | 0x819Bdb303e224CaC4aC14Da17a1ec13895869b65 | Custom |
| 0xfc33bf00 | 0x3503152722beeE269E9B4E0921F2c3D44C90d2b5 | AaveV3Supply |
| 0x9e9290b1 | 0xEE1F8dc0135EE9dC2e00fac3817b9C530d34B6ba | AaveV3Borrow |
| 0x17683e81 | 0x71f4d0A74b7F1BB07cc767dC2f4b436E907476DC | AaveV3Payback |
| 0x72a6498a | 0x0039d822156FF2FD28ac6e19A518660890fcD2E0 | AaveV3Withdraw |
| 0xfebcb52a | 0x313Ca6136521D22A7Ea763B3566Ed0B53F5B3AB9 | Unknown |
| 0x19713586 | 0xc780112305ED959CEEeb0DE692E2407E4145Fc3A | Unknown |
| 0x4f18b88c | 0x351dd4581d61BCE7101FDf5f6864D510021c7CaB | Unknown |

All custom actions have delegatecall but require executor access.

---

## Attack Vectors Tested

### Vector 1: Direct Strategy Calls
- `callExecute()` - BLOCKED (requires strategyExecutor)
- `execute()` - BLOCKED (requires self-call)

### Vector 2: StrategyExecutor Access
- `executeOnStrategy()` - BLOCKED (requires executor whitelist)
- `updateExecutor()` - BLOCKED (onlyOwner)

### Vector 3: Vault Exploitation
- Direct function calls - BLOCKED (no public withdraw functions)
- Approval exploitation - BLOCKED (spender access-controlled)

### Vector 4: Action Vulnerabilities
- LidoStake/LidoWrap analyzed - No exploitable paths without executor access
- Parameter injection - Requires executor access first

### Vector 5: Flash Loan / Reentrancy
- No executeOperation callback found
- No reentrancy entry points

### Vector 6: Storage Collision
- Strategy uses only immutables
- ActionExecutor uses only immutables
- No collision possible

---

## Centralization Risks (NOT Unprivileged Vulnerabilities)

1. **Owner Compromise**: Owner can add malicious executors/actions
2. **Vault Approval**: Spender has MAX approval but is access-controlled
3. **Single Multisig**: All contracts share same owner

---

## Conclusion

**STATUS: UNPROVEN - No unprivileged vulnerability found**

Extensive testing of:
- 8 different attack vectors
- 13 whitelisted actions
- Vault approval chain
- Flash loan possibilities
- Callback/reentrancy paths
- Storage collision

All access controls are functioning correctly. ~$8.5M in wstETH is secure unless owner multisig is compromised.

---

## Reproduction Commands

```bash
forge test --match-contract TreehouseStrategyExploitTest -vvv
forge test --match-contract DeepExploitTest -vvv
forge test --match-contract VaultExploitTest -vvv
forge test --match-contract SpenderExploitTest -vvv
forge test --match-contract FinalExploitTest -vvv
```

---

## Files Created

- `test/TreehouseStrategyExploit.t.sol` - Treehouse Protocol analysis
- `test/DeepExploit.t.sol` - Deep vulnerability analysis
- `test/VaultExploit.t.sol` - Vault analysis
- `test/SpenderExploit.t.sol` - Spender approval analysis
- `test/FinalExploit.t.sol` - Final comprehensive tests
- `test/DelegatecallHijack.t.sol` - Initial proxy analysis
- `test/DelegatecallHijackDeep.t.sol` - Deep DeFiSaver analysis
- `test/DelegatecallExploit.t.sol` - Attack vector testing
- `test/NovelExploit.t.sol` - Function selector analysis
- `test/CustomActionAnalysis.t.sol` - Custom action bytecode analysis
- `test/StrategyStorageExploit.t.sol` - StrategyStorage manipulation attempts
- `test/SelectorExploit.t.sol` - Selector collision testing
- `test/InitializeExploit.t.sol` - Re-initialization attempts
- `test/ProxySearchExploit.t.sol` - DSProxy pattern analysis
- `test/FINDINGS_DelegatecallHijacking.md` - This report

---

## Additional Deep Analysis

### Source Code Analysis
Retrieved and analyzed verified source code for:
- Strategy.sol - Uses immutables only, no storage manipulation possible
- StrategyExecutor.sol - onlyOwner for updateExecutor, executor whitelist check
- ActionExecutor.sol - Uses registry lookup, delegatecalls to registered actions
- StrategyStorage.sol - All mutations are onlyOwner
- ActionRegistry.sol - All registration is onlyOwner

### Custom Actions Analyzed
| Action | Name | External Calls |
|--------|------|----------------|
| 0xb8cD2bA2A0Ada353aE15398618Fafb1d7BD558C5 | LidoUnwrap | wstETH.unwrap() |
| 0x313Ca6136521D22A7Ea763B3566Ed0B53F5B3AB9 | VaultPull | vault.withdraw() |

VaultPull calls `IVaultWithdrawer(IStrategy(msg.sender).vault()).withdraw()` but runs in Strategy context via delegatecall, so it's calling Vault's withdraw with Strategy as the caller - this is authorized.

### Selector Collision Analysis
Found that `updateExecutor(address,bool)` and `mintFeeForTierTwo(uint256)` both hash to 0x34b85e74, but the actual implementation is access-controlled with onlyOwner.

### Proxy Pattern Analysis
- Strategy is NOT a DSProxy (doesn't have owner/authority)
- Strategy is NOT an EIP-1967 proxy (no implementation slot)
- Vault is NOT an EIP-1967 proxy (no implementation slot)

### DSProxy Exploitation
Created test showing DSProxy + ActionExecutor works for attacker-owned proxies, but cannot drain other contracts.

---

## Investigation Status

**ONGOING** - User confirms unprivileged vulnerability exists but is a novel pattern. Continue investigating non-standard attack vectors.

---

## Latest Deep Analysis (Session 2)

### Critical Findings

#### 1. Vault Token Approval
- **Vault (0x551d155760ae96050439AD24Ae98A96c765d761B)** has approved **RedemptionController (0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510)** for MAX wstETH
- This approval allows RedemptionController to call `transferFrom(Vault, receiver, amount)` for any amount

#### 2. Vault.withdraw() Access Control
- Vault has custom `withdraw(address _asset, uint _amount)` function (selector: 0xf3fef3a3)
- **CONFIRMED**: Strategy 0 CAN call Vault.withdraw() successfully (via prank test)
- Random attacker CANNOT call it (fails with error 0x4e236e9a)
- Access control checks if caller is registered Strategy

#### 3. Strategy aWstETH Holdings
- Strategy 0 holds ~33,709 aWstETH (~$77.5M)
- Can be withdrawn via Aave's `pool.withdraw(wstETH, amount, address(this))`
- AaveV3Withdraw action always sends to `address(this)` (Strategy), not controllable

#### 4. VaultPull Action Behavior
```solidity
function _pullToken(Params memory _inputData) internal {
    IVaultWithdrawer(IStrategy(msg.sender).vault()).withdraw(_inputData.token, _inputData.amount);
}
```
- Uses `msg.sender` to get vault (not `address(this)`)
- In delegatecall chain: msg.sender = Strategy
- So VaultPull calls Vault.withdraw() with Strategy as caller → AUTHORIZED

#### 5. RedemptionController Analysis
- Contract: 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510 (4751 bytes)
- Has 4 DELEGATECALL opcodes
- Owner: 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e (same as all other contracts)
- Functions: `redeem()`, `rescueERC20()`, `addRedemption()` - all access controlled

#### 6. Redemption Mechanism
- Two redemption contracts: 0xcd63... and 0x8295...
- 7-day waiting period for redemptions
- Min redeem: 200 wstETH
- Currently ~978 wstETH in redemption queue

### Attack Vector Analysis

#### Vector A: Attacker Proxy + ActionExecutor
- Attacker deploys proxy with `vault()` returning real Vault
- Calls ActionExecutor via delegatecall
- **BLOCKED**: Vault.withdraw() fails because attacker's proxy is not a registered Strategy

#### Vector B: Direct RedemptionController
- All functions (`redeem`, `rescueERC20`, `addRedemption`) are access controlled
- Cannot register malicious redemption contract (onlyOwner)

#### Vector C: Strategy Execution with Attacker Params
- AaveV3Withdraw: `to` parameter is hardcoded to `address(this)` → NOT CONTROLLABLE
- Need to find action that allows controllable destination

### Key Insight from User
> "so cant after it combine with other functions, acts for chainnig and extract asset to proxy and extract from proxy that attacker owned to attacker?"

This suggests a multi-step attack:
1. Use action chaining to extract assets to attacker's proxy
2. Extract from proxy to attacker

### Remaining Investigation Areas
1. Find action with controllable `to` parameter
2. Investigate param mapping exploitation
3. Check if any action does `transferFrom` with controllable source
4. Analyze if delegatecall context can be exploited for identity confusion

### Contracts Source Retrieved
- Strategy.sol - Confirmed access control
- StrategyStorage.sol - All mutations onlyOwner
- VaultPull.sol - Uses msg.sender for vault lookup
- AaveV3Withdraw.sol - No controllable `to` param (always address(this))

---

## Session 3 - Deep Analysis (Continued)

### Critical Discovery: RedemptionController transferFrom

**CRITICAL FINDING**: RedemptionController at offset 2433 has `transferFrom` selector (0x23b872dd).
- Vault has approved RedemptionController for essentially MAX wstETH (~115792089237316195423570985008687907853269984665640563923991)
- If RC calls `wstETH.transferFrom(Vault, receiver, amount)` with attacker-controlled params, Vault can be drained

### Action Analysis (Complete)

| Action ID | Address | Size | Has Transfer | Has vault() | Name |
|-----------|---------|------|--------------|-------------|------|
| 0xd7e40b2d | 0xbdFb29cCD82dB3ccf462F3CB600892b2E6f185C7 | 2938 | No | - | LidoStake |
| 0x43142355 | 0x160F1f3a512Fa7cCefA0eb08f881282c05d6eb0f | 4367 | No | - | LidoWrap |
| 0xacd039ef | 0xb8cD2bA2A0Ada353aE15398618Fafb1d7BD558C5 | 2264 | No | - | LidoUnwrap |
| 0x2161dd34 | 0x3e34E0694204e462Deaf8EBbeEE2bE9F887f3C3b | 4116 | No | - | Custom |
| 0x245077a0 | 0x99eAe56224EA5Bcb2c886D0a07154217b7A1E5d1 | 2736 | No | - | Custom |
| 0x3d35d254 | 0x819Bdb303e224CaC4aC14Da17a1ec13895869b65 | 2270 | No | - | Custom |
| 0xfc33bf00 | 0x3503152722beeE269E9B4E0921F2c3D44C90d2b5 | 4495 | No | - | AaveV3Supply |
| 0x9e9290b1 | 0xEE1F8dc0135EE9dC2e00fac3817b9C530d34B6ba | 2860 | No | - | AaveV3Borrow |
| 0x17683e81 | 0x71f4d0A74b7F1BB07cc767dC2f4b436E907476DC | 5075 | No | - | AaveV3Payback |
| 0x72a6498a | 0x0039d822156FF2FD28ac6e19A518660890fcD2E0 | 2892 | No | - | AaveV3Withdraw |
| 0xfebcb52a | 0x313Ca6136521D22A7Ea763B3566Ed0B53F5B3AB9 | 2159 | No | Yes | VaultPull |
| **0x19713586** | **0xc780112305ED959CEEeb0DE692E2407E4145Fc3A** | **3175** | **YES** | **Yes** | **TRANSFER_ACTION** |
| 0x4f18b88c | 0x351dd4581d61BCE7101FDf5f6864D510021c7CaB | 2722 | No | - | Unknown |

### TRANSFER_ACTION (0x19713586) Analysis

**Address**: 0xc780112305ED959CEEeb0DE692E2407E4145Fc3A

**Key Findings**:
- Code size: 3175 bytes
- Contains `transfer` selector (0xa9059cbb) at offset 1345
- Contains `vault()` selector (0xfbfa77cf) at offset 972
- Has hardcoded 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF (ETH placeholder) before CALL
- Structure identical to VaultPull (same selector set)
- Uses msg.sender.vault() pattern

**Function Selectors**:
- 0x8fca9153 = executeAction(bytes,uint8[],bytes32[])
- 0x9093410d = parseInputs(bytes)
- 0x5d1ca631 = ID() returns 0x19713586
- 0x8bcb6216 = actionType() returns 1 (STANDARD_ACTION)

**Opcode Analysis**:
- CALL: 1
- DELEGATECALL: 1
- STATICCALL: 3
- CALLDATALOAD: 12
- SSTORE: 0 (no storage modification)

### TASSET (tETH) Analysis

- Address: 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8
- Type: EIP-1967 Proxy (176 bytes)
- Implementation: 0xD1A622566F277AA76c3C47A30469432AAec95E38 (14383 bytes)
- Name: "Treehouse ETH" (tETH)
- Total Supply: ~52,172 tETH

### IAU (Internal Accounting Unit) Analysis

- Address: 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92
- Code size: 5477 bytes
- Name: "InternalAccountingUnit_Wrapped liquid staked Ether 2.0"
- Symbol: IAU_wstETH
- Total Supply: ~52,493 IAU
- Owner: 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e
- DELEGATECALL opcodes: 5

### Redemption Contract Analysis

**Redemption 0** (0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85):
- Code size: 9439 bytes
- DELEGATECALL opcodes: 8
- DELEGATECALLs to 0xFFfF...fFfF (SafeTransferLib pattern)

**Redemption 1** (0x829525417Cd78CBa0f99A8736426fC299506C0d6):
- Code size: 6202 bytes
- DELEGATECALL opcodes: 7

### Callback/Reentrancy Search Results

Searched for callbacks in all main contracts:
- executeOperation (Aave) - NOT FOUND
- receiveFlashLoan (Balancer) - NOT FOUND
- onFlashLoan - NOT FOUND
- uniswapV3 callbacks - NOT FOUND
- ERC777/ERC721/ERC1155 hooks - NOT FOUND

### Entry Points Tested

| Contract | Function | Result |
|----------|----------|--------|
| Strategy | receive() | SUCCESS (accepts ETH) |
| Strategy | fallback() | FAILED (no fallback) |
| ActionExecutor | executeAction | FAILED (access control) |
| RedemptionController | redeem() | FAILED (access control) |
| Vault | deposit() | FAILED |
| Vault | mint() | FAILED |

### DeFiSaver SendToken Comparison

DeFiSaver official SendToken addresses (NOT registered in Treehouse):
- SendToken: 0x5c19aF6F5de91209c3bc2Ba447b1f5eb53c50759
- SendTokens: 0x7d05c0ABeF6d91300a237026507c4a2631ddAdEa
- PullToken: 0x29Bb266A72E585C661e292F7D8CA7C4581a0AF72

**None of these match Treehouse's registered actions** - Treehouse uses custom actions.

### Hypothesis: TRANSFER_ACTION as VaultPush

The TRANSFER_ACTION might be a "VaultPush" action that:
1. Gets vault from msg.sender.vault()
2. Transfers tokens TO the vault (opposite of VaultPull)

If this is the case, it doesn't help with draining unless the destination is controllable.

### Investigation Priorities

1. **RedemptionController transferFrom** - Highest priority
   - How is it triggered?
   - Can params be controlled?

2. **TRANSFER_ACTION destination** - Medium priority
   - Is the `to` address controllable via params?
   - Or is it always vault()?

3. **Param Mapping Exploitation** - Lower priority
   - Can return values from one action become addresses for another?

### Files Created This Session

- `test/RedemptionDelegatecall.t.sol` - UUPS proxy analysis
- `test/RedemptionDeepExploit.t.sol` - Deep redemption analysis
- `test/TAssetExploit.t.sol` - TASSET/tETH analysis
- `test/TAssetProxyExploit.t.sol` - TASSET proxy analysis
- `test/ActionChainExploit.t.sol` - Action chaining analysis
- `test/SendTokenExploit.t.sol` - SendToken action search
- `test/TreehouseActionRegistry.t.sol` - ActionRegistry analysis
- `test/CustomTransferAction.t.sol` - Transfer action comparison
- `test/BytecodeAnalysis.t.sol` - Bytecode decompilation
- `test/SelectorLookup.t.sol` - Selector identification
- `test/TransferDestination.t.sol` - Transfer destination analysis
- `test/CallbackExploit.t.sol` - Callback search
- `test/VaultDepositExploit.t.sol` - Vault function analysis
