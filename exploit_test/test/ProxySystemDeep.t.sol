// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract ProxySystemDeep is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant IMPL = 0x434B68B11bBE8FD3074089397cA3d275801d6354;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_MatchSelectorSignatures() public view {
        console.log("=== MATCHING SELECTORS TO SIGNATURES ===\n");

        // Check matches
        console.log("Known function selectors:");
        console.log("owner():");
        console.logBytes4(bytes4(keccak256("owner()")));
        console.log("transferOwnership(address):");
        console.logBytes4(bytes4(keccak256("transferOwnership(address)")));
        console.log("acceptOwnership():");
        console.logBytes4(bytes4(keccak256("acceptOwnership()")));
        console.log("renounceOwnership():");
        console.logBytes4(bytes4(keccak256("renounceOwnership()")));
        console.log("pendingOwner():");
        console.logBytes4(bytes4(keccak256("pendingOwner()")));
        console.log("paused():");
        console.logBytes4(bytes4(keccak256("paused()")));
        console.log("treasury():");
        console.logBytes4(bytes4(keccak256("treasury()")));

        // Redemption functions
        console.log("\nRedemption functions:");
        console.log("redeem(uint256):");
        console.logBytes4(bytes4(keccak256("redeem(uint256)")));
        console.log("requestRedeem(uint256):");
        console.logBytes4(bytes4(keccak256("requestRedeem(uint256)")));
        console.log("getUserProxy(address):");
        console.logBytes4(bytes4(keccak256("getUserProxy(address)")));
        console.log("userProxy(address):");
        console.logBytes4(bytes4(keccak256("userProxy(address)")));
        console.log("proxyOf(address):");
        console.logBytes4(bytes4(keccak256("proxyOf(address)")));
        console.log("getProxy(address):");
        console.logBytes4(bytes4(keccak256("getProxy(address)")));
    }

    function test_CallViewFunctions() public view {
        console.log("=== CALLING VIEW FUNCTIONS ===\n");

        // Try view calls
        (bool s1, bytes memory d1) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0xeda72134))
        );
        if (s1 && d1.length >= 32) {
            console.log("0xeda72134() = tAsset:", abi.decode(d1, (address)));
        }

        (bool s2, bytes memory d2) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0xfd424ea8))
        );
        if (s2 && d2.length >= 32) {
            console.log("0xfd424ea8():", abi.decode(d2, (address)));
        }

        (bool s3, bytes memory d3) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0xc5d664c6))
        );
        if (s3 && d3.length >= 32) {
            console.log("0xc5d664c6() = wstETH:", abi.decode(d3, (address)));
        }

        (bool s4, bytes memory d4) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0x9307e802))
        );
        if (s4 && d4.length >= 32) {
            console.log("0x9307e802() = IAU:", abi.decode(d4, (address)));
        }

        (bool s5, bytes memory d5) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0x61d027b3))
        );
        if (s5 && d5.length >= 32) {
            console.log("0x61d027b3() = treasury:", abi.decode(d5, (address)));
        }

        (bool s6, bytes memory d6) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0x38a63183))
        );
        if (s6 && d6.length >= 32) {
            console.log("0x38a63183() = RC:", abi.decode(d6, (address)));
        }

        // Try with attacker address
        (bool s7, bytes memory d7) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0x578063ed), attacker)
        );
        if (s7 && d7.length >= 32) {
            address r = abi.decode(d7, (address));
            console.log("0x578063ed(attacker):", r);
        }

        (bool s8, bytes memory d8) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0x778d364f), attacker)
        );
        if (s8 && d8.length >= 32) {
            address r = abi.decode(d8, (address));
            console.log("0x778d364f(attacker):", r);
            if (r != address(0)) {
                console.log("  *** THIS MIGHT BE USER PROXY GETTER ***");
            }
        }

        // Try 0x51cbf345 with address
        (bool s9, bytes memory d9) = REDEMPTION_1.staticcall(
            abi.encodeWithSelector(bytes4(0x51cbf345), attacker)
        );
        if (s9 && d9.length >= 32) {
            console.log("0x51cbf345(attacker):", abi.decode(d9, (address)));
        }
    }

    function test_TryAllSelectors() public {
        console.log("=== TRYING ALL REDEMPTION_1 SELECTORS ===\n");

        vm.startPrank(attacker);
        deal(IAU, attacker, 100000e18);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        // Try each selector with common argument patterns
        bytes4[] memory sels = new bytes4[](10);
        sels[0] = bytes4(0xcff50c6e);
        sels[1] = bytes4(0x42dbe168);
        sels[2] = bytes4(0x458f5815);
        sels[3] = bytes4(0x252c50f3);
        sels[4] = bytes4(0x2ab60045);
        sels[5] = bytes4(0x04824e70);
        sels[6] = bytes4(0x06e29712);
        sels[7] = bytes4(0x1650cf97);
        sels[8] = bytes4(0x411557d1);
        sels[9] = bytes4(0xb2118a8d);

        console.log("Trying selectors with uint256 argument:");
        for (uint i = 0; i < sels.length; i++) {
            (bool s, bytes memory d) = REDEMPTION_1.call(
                abi.encodeWithSelector(sels[i], 1000e18)
            );
            if (s) {
                console.log("SUCCESS:");
                console.logBytes4(sels[i]);
            } else if (d.length >= 4) {
                console.log("FAIL:");
                console.logBytes4(sels[i]);
                console.log("  Error:");
                console.logBytes4(bytes4(d));
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker wstETH:", attackerBal);
    }

    function test_InvestigateUserProxyPattern() public {
        console.log("=== INVESTIGATING USER PROXY PATTERN ===\n");

        // First check implementation's functions
        console.log("Implementation selectors:");
        bytes memory implCode = IMPL.code;

        bytes4[] memory found = new bytes4[](20);
        uint count = 0;

        for (uint i = 0; i + 4 < implCode.length && count < 20; i++) {
            if (uint8(implCode[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(implCode[i+1], implCode[i+2], implCode[i+3], implCode[i+4]));
                bool isValid = false;
                for (uint j = i + 5; j < i + 15 && j < implCode.length; j++) {
                    if (uint8(implCode[j]) == 0x14) {
                        isValid = true;
                        break;
                    }
                }
                if (isValid && sel != bytes4(0) && sel != bytes4(0xffffffff) && uint32(sel) > 0x1000) {
                    bool unique = true;
                    for (uint k = 0; k < count; k++) {
                        if (found[k] == sel) unique = false;
                    }
                    if (unique) {
                        found[count] = sel;
                        count++;
                    }
                }
            }
        }

        for (uint i = 0; i < count; i++) {
            console.logBytes4(found[i]);
        }

        // Check if proxies call the implementation
        vm.startPrank(attacker);
        deal(IAU, attacker, 100000e18);
        IERC20(IAU).approve(IMPL, type(uint256).max);

        // Try calling implementation directly
        console.log("\nTrying implementation functions:");

        (bool s1, bytes memory d1) = IMPL.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("impl.redeem(uint96):", s1);
        if (!s1 && d1.length >= 4) console.logBytes4(bytes4(d1));

        vm.stopPrank();
    }

    function test_FindExistingUserProxies() public view {
        console.log("=== FINDING EXISTING USER PROXIES ===\n");

        // Check for any users who have created proxies
        // by examining known addresses

        address[5] memory knownUsers = [
            0x0000000000000000000000000000000000000001,
            0x2225DAbFfC7F862c99477381E971E8B1FDaB467e, // Timelock/owner
            0xB38f2aCb7B562475908c0C6E80a045Deb4023f70, // Treasury
            address(0x1234567890123456789012345678901234567890),
            address(0xdead)
        ];

        for (uint i = 0; i < knownUsers.length; i++) {
            (bool s, bytes memory d) = REDEMPTION_1.staticcall(
                abi.encodeWithSelector(bytes4(0x778d364f), knownUsers[i])
            );
            if (s && d.length >= 32) {
                address proxy = abi.decode(d, (address));
                if (proxy != address(0)) {
                    console.log("User:", knownUsers[i]);
                    console.log("  Proxy:", proxy);
                    console.log("  Has code:", proxy.code.length > 0);
                }
            }
        }
    }
}
