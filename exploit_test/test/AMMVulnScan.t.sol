// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
    function approve(address, uint256) external returns (bool);
}

interface IUniswapV2Pair {
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112, uint112, uint32);
    function swap(uint256, uint256, address, bytes calldata) external;
    function sync() external;
    function skim(address) external;
}

contract AMMVulnScan is Test {
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testScanLidoQueue() public view {
        console.log("=====================================================");
        console.log("LIDO WITHDRAWAL QUEUE ANALYSIS");
        console.log("=====================================================");

        // Lido WithdrawalQueue has significant ETH
        address lidoQueue = 0x889edC2eDab5f40e902b864aD4d7AdE8E412F9B1;

        console.log("Contract:", lidoQueue);
        console.log("ETH Balance:", lidoQueue.balance / 1e18);

        // Check for common withdrawal queue functions
        _checkFunction(lidoQueue, "unfinalizedStETH()");
        _checkFunction(lidoQueue, "getWithdrawalStatus(uint256[])");
        _checkFunction(lidoQueue, "requestWithdrawals(uint256[],address)");
        _checkFunction(lidoQueue, "claimWithdrawals(uint256[],uint256[])");
    }

    function _checkFunction(address target, string memory sig) internal view {
        (bool success, bytes memory data) = target.staticcall(abi.encodeWithSignature(sig));
        if (success) {
            console.log("Has:", sig);
            if (data.length >= 32) {
                uint256 val = abi.decode(data, (uint256));
                if (val > 0) {
                    console.log("  Value:", val);
                }
            }
        }
    }

    function testScanEarlyAdopterPool() public {
        console.log("=====================================================");
        console.log("EARLY ADOPTER POOL ANALYSIS");
        console.log("=====================================================");

        // EarlyAdopterPool from contracts.txt
        address pool = 0xeC6e6c0841A2bA474E92BF42BAF76BC79039996F;

        console.log("Contract:", pool);
        console.log("ETH Balance:", pool.balance / 1e18);

        // Read storage
        console.log("\n--- Storage ---");
        for (uint256 i = 0; i < 10; i++) {
            bytes32 slot = vm.load(pool, bytes32(i));
            uint256 value = uint256(slot);
            if (value > 0) {
                console.log("Slot", i, ":", value);
            }
        }

        // Try common functions
        _checkFunction(pool, "totalDeposits()");
        _checkFunction(pool, "totalSupply()");
        _checkFunction(pool, "owner()");
    }

    function testAnalyzeBentoBox() public {
        console.log("=====================================================");
        console.log("BENTOBOX ANALYSIS");
        console.log("=====================================================");

        // BentoBox has flash loan capabilities
        address bento = 0xF5BCE5077908a1b7370B9ae04AdC565EBd643966;

        console.log("Contract:", bento);

        uint256 wethBal = IERC20(WETH).balanceOf(bento);
        console.log("WETH Balance:", wethBal / 1e18);

        // Check flash loan functions
        (bool success,) = bento.staticcall(
            abi.encodeWithSignature("flashLoan(address,address,address,uint256,bytes)")
        );
        if (success) {
            console.log("flashLoan() is callable");
        }

        // Check totals for tokens
        (success,) = bento.staticcall(
            abi.encodeWithSignature("totals(address)", WETH)
        );
        if (success) {
            console.log("Has totals() mapping");
        }
    }

    function testAnalyzeSynthetixStaking() public {
        console.log("=====================================================");
        console.log("SYNTHETIX-STYLE STAKING ANALYSIS");
        console.log("=====================================================");

        // StakingRewards contract from earlier
        address staking = 0x4F48031B0EF8acCea3052Af00A3279fbA31b50D8;

        console.log("Contract:", staking);

        _checkFunction(staking, "stakingToken()");
        _checkFunction(staking, "rewardsToken()");
        _checkFunction(staking, "totalSupply()");
        _checkFunction(staking, "rewardRate()");
        _checkFunction(staking, "periodFinish()");
        _checkFunction(staking, "rewardPerToken()");
        _checkFunction(staking, "lastUpdateTime()");

        // Check if rewards have expired
        (bool success, bytes memory data) = staking.staticcall(
            abi.encodeWithSignature("periodFinish()")
        );
        if (success && data.length >= 32) {
            uint256 periodFinish = abi.decode(data, (uint256));
            console.log("\nPeriod Finish:", periodFinish);
            console.log("Current Time:", block.timestamp);
            if (block.timestamp > periodFinish) {
                console.log("*** REWARDS EXPIRED ***");
            }
        }
    }

    function testCheckCurvePools() public view {
        console.log("=====================================================");
        console.log("CURVE-STYLE POOL ANALYSIS");
        console.log("=====================================================");

        // Check for any Curve pools in contracts.txt
        // Curve pools use get_dy, exchange functions

        // steCRV pool
        address steCrv = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;

        console.log("stETH/ETH Pool:", steCrv);
        console.log("ETH Balance:", steCrv.balance / 1e18);

        // Try Curve functions
        (bool success, bytes memory data) = steCrv.staticcall(
            abi.encodeWithSignature("A()")
        );
        if (success && data.length >= 32) {
            console.log("A parameter:", abi.decode(data, (uint256)));
        }

        // Check virtual price
        (success, data) = steCrv.staticcall(
            abi.encodeWithSignature("get_virtual_price()")
        );
        if (success && data.length >= 32) {
            console.log("Virtual Price:", abi.decode(data, (uint256)) / 1e18);
        }

        // Check for reentrancy vulnerability (read-only reentrancy)
        // This was exploited in Curve pools before
        (success, data) = steCrv.staticcall(
            abi.encodeWithSignature("balances(uint256)", 0)
        );
        if (success && data.length >= 32) {
            console.log("Balance[0]:", abi.decode(data, (uint256)) / 1e18);
        }

        (success, data) = steCrv.staticcall(
            abi.encodeWithSignature("balances(uint256)", 1)
        );
        if (success && data.length >= 32) {
            console.log("Balance[1]:", abi.decode(data, (uint256)) / 1e18);
        }
    }

    function testSearchForSkimVulnerability() public {
        console.log("=====================================================");
        console.log("SEARCHING FOR SKIM/SYNC VULNERABILITIES");
        console.log("=====================================================");

        // Uniswap V2 pairs have skim() which can be exploited if
        // tokens are sent directly to the pair

        // Check a few LP contracts
        address[3] memory pairs = [
            0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc, // USDC/ETH
            0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852, // ETH/USDT
            0xBb2b8038a1640196FbE3e38816F3e67Cba72D940  // WBTC/ETH
        ];

        for (uint i = 0; i < pairs.length; i++) {
            address pair = pairs[i];
            console.log("\n--- Pair:", pair, "---");

            try IUniswapV2Pair(pair).getReserves() returns (uint112 r0, uint112 r1, uint32) {
                console.log("Reserve0:", uint256(r0) / 1e18);
                console.log("Reserve1:", uint256(r1) / 1e18);

                address token0 = IUniswapV2Pair(pair).token0();
                address token1 = IUniswapV2Pair(pair).token1();

                uint256 actual0 = IERC20(token0).balanceOf(pair);
                uint256 actual1 = IERC20(token1).balanceOf(pair);

                console.log("Actual Balance0:", actual0 / 1e18);
                console.log("Actual Balance1:", actual1 / 1e18);

                // Check for discrepancy (skim opportunity)
                if (actual0 > uint256(r0) + 1e15) {
                    console.log("*** SKIM OPPORTUNITY: Token0 excess ***");
                }
                if (actual1 > uint256(r1) + 1e15) {
                    console.log("*** SKIM OPPORTUNITY: Token1 excess ***");
                }
            } catch {}
        }
    }
}
