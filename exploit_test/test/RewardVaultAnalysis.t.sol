// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IRewardVault {
    function getTotalUnvestedRewards() external view returns (uint256);
    function getReward(address staker) external view returns (uint256);
    function getStoredReward(address staker) external view returns (uint112);
    function getRewardBuckets() external view returns (
        uint80 communityPoolEmission,
        uint80 operatorPoolEmission,
        uint80 delegatedPoolEmission
    );
    function getCommunityStakingPool() external view returns (address);
    function getOperatorStakingPool() external view returns (address);
    function getMultiplier(address staker) external view returns (uint256);
    function isPaused() external view returns (bool);
    function s_rewardDurationEndsAt() external view returns (uint256);
    function hasRewarderRole(address) external view returns (bool);
    function owner() external view returns (address);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
}

interface IStakingPool {
    function getTotalPrincipal() external view returns (uint256);
    function getStakerPrincipal(address) external view returns (uint256);
    function getTotalStakedAmount() external view returns (uint256);
}

/**
 * @title Chainlink RewardVault Deep Analysis
 * @notice Analyzing for emergent vulnerabilities in reward distribution logic
 *
 * KEY INVARIANTS TO TEST:
 * 1. LINK balance >= sum of unvested rewards
 * 2. Sum of all stakers' rewards <= available rewards
 * 3. Zero emission bucket has zero rewards
 * 4. Stakers' multipliers within valid range
 *
 * ATTACK VECTORS TO EXPLORE:
 * 1. Rounding in reward calculation leading to free rewards
 * 2. Multiplier manipulation affecting reward distribution
 * 3. Race conditions between claiming and emission updates
 * 4. Cross-pool reward confusion (community vs operator)
 */
contract RewardVaultAnalysisTest is Test {
    address constant REWARD_VAULT = 0x996913c8c08472f584ab8834e925b06D0eb1D813;
    address constant LINK = 0x514910771AF9Ca656af840dff83E8264EcF986CA;

    IRewardVault rewardVault;
    IERC20 link;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        rewardVault = IRewardVault(REWARD_VAULT);
        link = IERC20(LINK);
    }

    function testReadVaultState() public view {
        console.log("=== CHAINLINK REWARDVAULT STATE ANALYSIS ===");
        console.log("Contract:", REWARD_VAULT);
        console.log("");

        // Get LINK balance
        uint256 linkBalance = link.balanceOf(REWARD_VAULT);
        console.log("LINK Balance:", linkBalance / 1e18);

        // Get unvested rewards
        try rewardVault.getTotalUnvestedRewards() returns (uint256 unvested) {
            console.log("Total Unvested Rewards:", unvested / 1e18);
            console.log("");

            // Check invariant 1: balance >= unvested
            if (linkBalance < unvested) {
                console.log("!!! CRITICAL: LINK balance < unvested rewards!");
                console.log("Shortfall:", (unvested - linkBalance) / 1e18, "LINK");
            } else {
                console.log("Invariant OK: LINK balance covers unvested");
            }
        } catch {
            console.log("getTotalUnvestedRewards() reverted");
        }

        // Get staking pools
        try rewardVault.getCommunityStakingPool() returns (address communityPool) {
            console.log("");
            console.log("Community Staking Pool:", communityPool);

            try IStakingPool(communityPool).getTotalPrincipal() returns (uint256 principal) {
                console.log("  Total Principal:", principal / 1e18, "LINK");
            } catch {}

            try IStakingPool(communityPool).getTotalStakedAmount() returns (uint256 staked) {
                console.log("  Total Staked:", staked / 1e18, "LINK");
            } catch {}
        } catch {
            console.log("getCommunityStakingPool() reverted");
        }

        try rewardVault.getOperatorStakingPool() returns (address operatorPool) {
            console.log("");
            console.log("Operator Staking Pool:", operatorPool);

            try IStakingPool(operatorPool).getTotalPrincipal() returns (uint256 principal) {
                console.log("  Total Principal:", principal / 1e18, "LINK");
            } catch {}
        } catch {
            console.log("getOperatorStakingPool() reverted");
        }

        // Get emission rates
        try rewardVault.getRewardBuckets() returns (
            uint80 communityEmission,
            uint80 operatorEmission,
            uint80 delegatedEmission
        ) {
            console.log("");
            console.log("=== EMISSION RATES ===");
            console.log("Community Pool Emission:", communityEmission);
            console.log("Operator Pool Emission:", operatorEmission);
            console.log("Delegated Pool Emission:", delegatedEmission);
        } catch {
            console.log("getRewardBuckets() reverted");
        }

        // Check pause state
        try rewardVault.isPaused() returns (bool paused) {
            console.log("");
            console.log("Is Paused:", paused);
        } catch {}

        console.log("");
        console.log("=============================================");
    }

    function testRewardDistributionAnalysis() public view {
        console.log("");
        console.log("=== REWARD DISTRIBUTION ANALYSIS ===");

        address communityPool;
        address operatorPool;

        try rewardVault.getCommunityStakingPool() returns (address cp) {
            communityPool = cp;
        } catch {
            console.log("Could not get community pool");
            return;
        }

        try rewardVault.getOperatorStakingPool() returns (address op) {
            operatorPool = op;
        } catch {
            console.log("Could not get operator pool");
            return;
        }

        uint256 totalUnvested;
        try rewardVault.getTotalUnvestedRewards() returns (uint256 u) {
            totalUnvested = u;
        } catch {
            console.log("Could not get unvested");
            return;
        }

        uint256 totalPrincipalCommunity;
        uint256 totalPrincipalOperator;

        try IStakingPool(communityPool).getTotalPrincipal() returns (uint256 p) {
            totalPrincipalCommunity = p;
        } catch {}

        try IStakingPool(operatorPool).getTotalPrincipal() returns (uint256 p) {
            totalPrincipalOperator = p;
        } catch {}

        console.log("Community Total Principal:", totalPrincipalCommunity / 1e18);
        console.log("Operator Total Principal:", totalPrincipalOperator / 1e18);
        console.log("Total Unvested Rewards:", totalUnvested / 1e18);

        uint256 totalStaked = totalPrincipalCommunity + totalPrincipalOperator;
        if (totalStaked > 0 && totalUnvested > 0) {
            // Calculate implied reward per token
            uint256 rewardPerToken = (totalUnvested * 1e18) / totalStaked;
            console.log("Implied Reward Per Token:", rewardPerToken);

            // Check for potential precision loss issues
            if (rewardPerToken < 1e12) {
                console.log("!!! LOW: Reward per token very small - precision loss risk");
            }
        }

        console.log("=====================================");
    }

    function testMultiplierAnalysis() public view {
        console.log("");
        console.log("=== MULTIPLIER ANALYSIS ===");

        // Test with some known addresses
        address[] memory testAddresses = new address[](5);
        testAddresses[0] = address(0x1);
        testAddresses[1] = address(0x1000);
        testAddresses[2] = address(0xdead);
        testAddresses[3] = REWARD_VAULT;
        testAddresses[4] = address(this);

        for (uint i = 0; i < testAddresses.length; i++) {
            try rewardVault.getMultiplier(testAddresses[i]) returns (uint256 mult) {
                if (mult > 0) {
                    console.log("Address", i, "has multiplier:", mult);
                }
            } catch {}
        }

        console.log("============================");
    }

    function testAccessControlAnalysis() public view {
        console.log("");
        console.log("=== ACCESS CONTROL ANALYSIS ===");

        // Check owner
        try rewardVault.owner() returns (address owner) {
            console.log("Owner:", owner);
        } catch {
            console.log("No owner() function");
        }

        // Check if common addresses have rewarder role
        address[] memory testAddresses = new address[](3);
        testAddresses[0] = address(0);
        testAddresses[1] = address(this);
        testAddresses[2] = REWARD_VAULT;

        for (uint i = 0; i < testAddresses.length; i++) {
            try rewardVault.hasRewarderRole(testAddresses[i]) returns (bool hasRole) {
                if (hasRole) {
                    console.log("Address", i, "HAS rewarder role!");
                }
            } catch {}
        }

        console.log("================================");
    }
}
