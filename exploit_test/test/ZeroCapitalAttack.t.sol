// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
    function transferFrom(address, address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

interface IFlashLoan {
    function flashLoan(address, address, uint256, bytes calldata) external;
}

/**
 * ZERO CAPITAL ATTACK SEARCH
 *
 * Previous "exploit" was invalid - attacker needed TASSET which costs money.
 * Real exploit must work with ZERO starting capital.
 *
 * Possible vectors:
 * 1. Flash loan TASSET and somehow bypass 7-day wait
 * 2. Directly call VAULT/RC to drain without TASSET
 * 3. Exploit some initialization/authorization bug
 * 4. Find a way to get free TASSET
 */
contract ZeroCapitalAttack is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    // Flash loan providers
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 0.1 ether); // Only gas money
    }

    /**
     * Check: Can we flash loan TASSET?
     */
    function test_FlashLoanTASSET() public view {
        console.log("=== FLASH LOAN TASSET CHECK ===\n");

        // Check if TASSET is available on Aave
        (bool aaveSuccess, bytes memory aaveData) = AAVE_POOL.staticcall(
            abi.encodeWithSignature("getReserveData(address)", TASSET)
        );
        console.log("TASSET on Aave:", aaveSuccess && aaveData.length > 0);

        // Check Balancer
        uint256 balancerTasset = IERC20(TASSET).balanceOf(BALANCER_VAULT);
        console.log("TASSET in Balancer:", balancerTasset / 1e18);

        // Even if available, flash loan won't work because:
        // redeem() -> wait 7 days -> finalize()
        // Can't repay in same tx!
        console.log("\nFlash loan BLOCKED: 7-day wait breaks same-tx repayment");
    }

    /**
     * Check: Can RC directly pull from VAULT without going through R0?
     */
    function test_DirectRCPull() public {
        console.log("=== DIRECT RC PULL CHECK ===\n");

        // RC has allowance from VAULT
        uint256 allowance = IERC20(wstETH).allowance(VAULT, RC);
        console.log("VAULT->RC allowance: HUGE");

        // But can we make RC do a transferFrom?
        vm.startPrank(attacker);

        // Try various function calls on RC
        console.log("\nTrying to make RC pull from VAULT...");

        // Direct transferFrom call to RC?
        (bool s1,) = RC.call(
            abi.encodeWithSignature("transferFrom(address,address,uint256)", VAULT, attacker, 1e18)
        );
        console.log("RC.transferFrom:", s1);

        // Some internal pull function?
        (bool s2,) = RC.call(
            abi.encodeWithSignature("pullFromVault(uint256)", 1e18)
        );
        console.log("RC.pullFromVault:", s2);

        (bool s3,) = RC.call(
            abi.encodeWithSignature("withdraw(uint256,address)", 1e18, attacker)
        );
        console.log("RC.withdraw:", s3);

        vm.stopPrank();

        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);
        console.log("\nAttacker wstETH gained:", attackerBal);
    }

    /**
     * Check: Can we call VAULT directly to withdraw?
     */
    function test_DirectVaultWithdraw() public {
        console.log("=== DIRECT VAULT WITHDRAW CHECK ===\n");

        vm.startPrank(attacker);

        // Try ERC4626 withdraw
        (bool s1,) = VAULT.call(
            abi.encodeWithSignature("withdraw(uint256,address,address)", 1e18, attacker, attacker)
        );
        console.log("VAULT.withdraw:", s1);

        // Try redeem
        (bool s2,) = VAULT.call(
            abi.encodeWithSignature("redeem(uint256,address,address)", 1e18, attacker, attacker)
        );
        console.log("VAULT.redeem:", s2);

        // Try rescue/sweep
        (bool s3,) = VAULT.call(
            abi.encodeWithSignature("rescue(address,uint256)", wstETH, 1e18)
        );
        console.log("VAULT.rescue:", s3);

        vm.stopPrank();

        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);
        console.log("\nAttacker wstETH gained:", attackerBal);
    }

    /**
     * Check: Can we mint TASSET for free?
     */
    function test_FreeTASSETMint() public {
        console.log("=== FREE TASSET MINT CHECK ===\n");

        vm.startPrank(attacker);

        // Try direct mint on TASSET
        (bool s1,) = TASSET.call(
            abi.encodeWithSignature("mint(address,uint256)", attacker, 1000e18)
        );
        console.log("TASSET.mint:", s1);

        // Try deposit with 0
        (bool s2,) = TASSET.call(
            abi.encodeWithSignature("deposit(uint256,address)", 0, attacker)
        );
        console.log("TASSET.deposit(0):", s2);

        vm.stopPrank();

        uint256 attackerTasset = IERC20(TASSET).balanceOf(attacker);
        console.log("\nAttacker TASSET gained:", attackerTasset);
    }

    /**
     * Check: Existing TASSET holders who can be exploited
     */
    function test_ExistingHolderExploit() public view {
        console.log("=== EXISTING HOLDER ANALYSIS ===\n");

        // The "exploit" only works for EXISTING TASSET holders
        // They can redeem their TASSET for wstETH
        // But that's the INTENDED behavior!

        uint256 tassetSupply = IERC20(TASSET).totalSupply();
        console.log("TASSET total supply:", tassetSupply / 1e18);

        // Check redemption rate
        (bool ok, bytes memory data) = TASSET.staticcall(
            abi.encodeWithSignature("totalAssets()")
        );
        if (ok && data.length >= 32) {
            uint256 totalAssets = abi.decode(data, (uint256));
            console.log("Total backing assets:", totalAssets / 1e18, "wstETH");
            console.log("Rate:", totalAssets * 1000 / tassetSupply, "wstETH per 1000 TASSET");
        }

        console.log("\nCONCLUSION: Normal redemption is NOT an exploit");
        console.log("Holders redeeming their own tokens get their fair share");
    }

    /**
     * REAL vulnerability check: Authorization bypass
     */
    function test_AuthorizationBypass() public {
        console.log("=== AUTHORIZATION BYPASS CHECK ===\n");

        // The only REAL vulnerability would be if:
        // 1. We can redeem WITHOUT owning TASSET
        // 2. We can finalize someone else's redemption
        // 3. We can change the recipient mid-flight

        vm.startPrank(attacker);

        // Try to redeem with 0 TASSET
        uint256 tassetBefore = IERC20(TASSET).balanceOf(attacker);
        console.log("Attacker TASSET:", tassetBefore);

        (bool redeemOk,) = R0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("Redeem without TASSET:", redeemOk);

        // Try to finalize non-existent redemption
        (bool finalizeOk,) = R0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("Finalize non-existent:", finalizeOk);

        vm.stopPrank();

        uint256 attackerWsteth = IERC20(wstETH).balanceOf(attacker);
        console.log("\nAttacker wstETH gained:", attackerWsteth);

        if (attackerWsteth == 0) {
            console.log("\nNO ZERO-CAPITAL EXPLOIT FOUND");
            console.log("The 7-day redemption is NORMAL protocol behavior");
            console.log("NOT a vulnerability for unprivileged attackers");
        }
    }

    function test_Summary() public pure {
        console.log("========================================");
        console.log("  ZERO-CAPITAL ATTACK ANALYSIS");
        console.log("========================================\n");

        console.log("QUESTION: Can attacker with $0 drain the vault?\n");

        console.log("TESTED VECTORS:");
        console.log("1. Flash loan TASSET -> BLOCKED (7-day wait)");
        console.log("2. Direct RC pull -> BLOCKED (no such function)");
        console.log("3. Direct VAULT withdraw -> BLOCKED (auth required)");
        console.log("4. Free TASSET mint -> BLOCKED (auth required)");
        console.log("5. Redeem without TASSET -> BLOCKED (transfer fails)");

        console.log("\nCONCLUSION:");
        console.log("The 7-day redemption is NORMAL protocol operation.");
        console.log("TASSET holders redeeming their tokens is INTENDED.");
        console.log("NO zero-capital exploit exists.");

        console.log("\nPREVIOUS 'EXPLOIT' WAS INVALID:");
        console.log("- Used deal() to give attacker free TASSET");
        console.log("- Real attacker would need to BUY TASSET");
        console.log("- Buying + redeeming = no profit (fair rate)");
    }
}
