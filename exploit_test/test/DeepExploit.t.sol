// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IStrategy {
    function execute(address _target, bytes memory _data) external payable returns (bytes32);
    function callExecute(address _target, bytes memory _data) external payable returns (bytes32);
    function vault() external view returns (address);
    function strategyStorage() external view returns (address);
}

interface IStrategyStorage {
    function strategyExecutor() external view returns (address);
    function owner() external view returns (address);
    function isActionWhitelisted(address _strategy, bytes4 _actionId) external view returns (bool);
    function isAssetWhitelisted(address _strategy, address _asset) external view returns (bool);
    function getStrategyInfo(uint _strategyId) external view returns (
        address _strategyAddress,
        bool _isActive,
        bytes32[] memory _allowedActions,
        address[] memory _allowedAssets
    );
}

interface IStrategyExecutor {
    function executors(address) external view returns (bool);
    function owner() external view returns (address);
    function STRATEGY_STORAGE() external view returns (address);
    function ACTION_EXECUTOR() external view returns (address);
    function executeOnStrategy(
        uint _strategyId,
        bytes4[] calldata _actionIds,
        bytes[] calldata _actionCalldata,
        uint8[][] memory _paramMapping
    ) external payable;
}

interface IActionRegistry {
    function getAddr(bytes4 _id) external view returns (address);
    function owner() external view returns (address);
}

interface IActionExecutor {
    function ACTION_REGISTRY() external view returns (address);
    function executeActions(
        bytes4[] calldata _actionIds,
        bytes[] calldata _actionCallData,
        uint8[][] calldata _paramMapping
    ) external payable;
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

// Interface for Aave V3 Pool for callback analysis
interface IPool {
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata interestRateModes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

contract DeepExploitTest is Test {
    address constant STRATEGY = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant STRATEGY_STORAGE = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;
    address constant STRATEGY_EXECUTOR = 0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e;
    address constant ACTION_EXECUTOR = 0xb1593193Bcd7CEcc3d19597658003d735D1e9E94;
    address constant ACTION_REGISTRY = 0x94aF5994EB6841e1D930C95AD0C9F89771c3073F;

    // Aave V3 Pool for flash loan tests
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;

    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
    }

    function test_FindAllWhitelistedActionAddresses() public view {
        console.log("=== FINDING ALL WHITELISTED ACTION ADDRESSES ===\n");

        IActionRegistry registry = IActionRegistry(ACTION_REGISTRY);

        // Known whitelisted action IDs from previous test
        bytes4[13] memory actionIds = [
            bytes4(0xd7e40b2d),
            bytes4(0x43142355),
            bytes4(0xacd039ef),
            bytes4(0x2161dd34),
            bytes4(0x245077a0),
            bytes4(0x3d35d254),
            bytes4(0xfc33bf00),
            bytes4(0x9e9290b1),
            bytes4(0x17683e81),
            bytes4(0x72a6498a),
            bytes4(0xfebcb52a),
            bytes4(0x19713586),
            bytes4(0x4f18b88c)
        ];

        for (uint i = 0; i < actionIds.length; i++) {
            address actionAddr = registry.getAddr(actionIds[i]);
            console.log("Action ID:", vm.toString(bytes32(actionIds[i])));
            console.log("  Address:", actionAddr);

            if (actionAddr != address(0)) {
                uint256 codeSize;
                assembly {
                    codeSize := extcodesize(actionAddr)
                }
                console.log("  Code size:", codeSize);
            }
            console.log("");
        }
    }

    function test_AnalyzeExecutorContract() public view {
        console.log("=== DEEP ANALYSIS OF STRATEGY EXECUTOR ===\n");

        IStrategyExecutor executor = IStrategyExecutor(STRATEGY_EXECUTOR);

        // Check if there are any other public functions we can call
        console.log("StrategyExecutor at:", STRATEGY_EXECUTOR);
        console.log("Owner:", executor.owner());
        console.log("STRATEGY_STORAGE:", executor.STRATEGY_STORAGE());
        console.log("ACTION_EXECUTOR:", executor.ACTION_EXECUTOR());

        // Check the executor's storage for any additional state
        console.log("\nStorage analysis:");
        for (uint i = 0; i < 5; i++) {
            bytes32 slot = vm.load(STRATEGY_EXECUTOR, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":", vm.toString(slot));
            }
        }
    }

    function test_CheckForOpenExecutors() public view {
        console.log("=== CHECKING FOR OPEN EXECUTOR ADDRESSES ===\n");

        IStrategyExecutor executor = IStrategyExecutor(STRATEGY_EXECUTOR);

        // Check common addresses that might be executors
        address[] memory potentialExecutors = new address[](10);
        potentialExecutors[0] = address(0);
        potentialExecutors[1] = address(1);
        potentialExecutors[2] = STRATEGY;
        potentialExecutors[3] = STRATEGY_STORAGE;
        potentialExecutors[4] = ACTION_EXECUTOR;
        potentialExecutors[5] = ACTION_REGISTRY;
        potentialExecutors[6] = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e; // Owner
        potentialExecutors[7] = AAVE_POOL;
        potentialExecutors[8] = WETH;
        potentialExecutors[9] = wstETH;

        for (uint i = 0; i < potentialExecutors.length; i++) {
            bool isExecutor = executor.executors(potentialExecutors[i]);
            if (isExecutor) {
                console.log("FOUND EXECUTOR:", potentialExecutors[i]);
            }
        }

        // Scan executor mapping storage slot for any entries
        // executors mapping is at slot 2 (after owner at 0 and pendingOwner at 1)
        console.log("\nScanning executor mapping...");
    }

    function test_AnalyzeCallExecuteBypass() public {
        console.log("=== ATTEMPTING CALLEXECUTE BYPASS ===\n");

        IStrategy strategy = IStrategy(STRATEGY);
        IStrategyStorage storage_ = IStrategyStorage(STRATEGY_STORAGE);

        address strategyExecutorAddr = storage_.strategyExecutor();
        console.log("Required strategyExecutor:", strategyExecutorAddr);

        // Vector 1: What if we call from strategyExecutor's code context?
        // This would require finding a way to execute code as strategyExecutor

        // Vector 2: What if strategyExecutor has a callback vulnerability?
        // Need to check StrategyExecutor's code for callbacks

        // Vector 3: Can we manipulate strategyStorage to return our address?
        // This would require storage manipulation

        vm.startPrank(attacker);

        // Try calling directly - expected to fail
        try strategy.callExecute(ACTION_EXECUTOR, "") {
            console.log("CRITICAL: Direct callExecute succeeded!");
        } catch {
            console.log("Direct call blocked as expected");
        }

        // Try calling from a contract that mimics strategyExecutor
        MimicExecutor mimic = new MimicExecutor();
        try mimic.tryCallExecute(strategy) {
            console.log("Mimic call result recorded");
        } catch {
            console.log("Mimic call blocked");
        }

        vm.stopPrank();
    }

    function test_FlashLoanCallbackVector() public {
        console.log("=== FLASH LOAN CALLBACK ANALYSIS ===\n");

        // When Aave executes a flash loan, it calls back executeOperation
        // If the Strategy or any action has this callback, could it be exploited?

        // Check if Strategy implements any callback interfaces
        bytes4 executeOperationSig = bytes4(keccak256("executeOperation(address[],uint256[],uint256[],address,bytes)"));

        (bool success,) = STRATEGY.staticcall(
            abi.encodeWithSelector(executeOperationSig, new address[](0), new uint256[](0), new uint256[](0), address(0), "")
        );
        console.log("Strategy has executeOperation?", success);

        // Check ActionExecutor
        (success,) = ACTION_EXECUTOR.staticcall(
            abi.encodeWithSelector(executeOperationSig, new address[](0), new uint256[](0), new uint256[](0), address(0), "")
        );
        console.log("ActionExecutor has executeOperation?", success);
    }

    function test_DoubleDelegatecallStorageCollision() public {
        console.log("=== DOUBLE DELEGATECALL STORAGE ANALYSIS ===\n");

        // Flow: Strategy -> delegatecall -> ActionExecutor -> delegatecall -> Action
        // Both delegatecalls use Strategy's storage

        // ActionExecutor's storage layout:
        // - ACTION_REGISTRY is immutable (in bytecode)
        // - EXECUTE_ACTION_SELECTOR is constant
        // => NO storage used by ActionExecutor

        // But what about Actions?
        // Actions might read/write storage that collides with Strategy

        console.log("Strategy storage layout:");
        // Strategy has:
        // - vault (immutable)
        // - strategyStorage (immutable)
        // => NO storage used by Strategy either!

        console.log("Both Strategy and ActionExecutor use only immutables");
        console.log("No storage collision possible between them");

        // But actions might have storage...
        // Let's check if any action writes to slot 0 or 1
        // which could overwrite critical data if Strategy had storage there
    }

    function test_ActionParameterInjection() public {
        console.log("=== ACTION PARAMETER INJECTION ANALYSIS ===\n");

        // The ActionExecutor uses paramMapping to inject return values
        // from previous actions into subsequent action parameters

        // Could an attacker craft parameters that cause unexpected behavior?

        // The paramMapping system:
        // - paramMapping[i] = 0: use original value
        // - paramMapping[i] = 1-255: use returnValues[paramMapping[i]-1]

        // Attack vector: If action A returns attacker-controlled data,
        // and action B uses that data as an address or amount...

        console.log("paramMapping allows injecting return values from previous actions");
        console.log("This is by design for recipe chaining");
        console.log("But requires executor access to exploit");
    }

    function test_StrategyInitializationState() public view {
        console.log("=== STRATEGY INITIALIZATION ANALYSIS ===\n");

        // Is there an initialize function that wasn't called?
        // Or that can be called again?

        // Check common initialization patterns
        bytes4 initializeSig = bytes4(keccak256("initialize()"));
        bytes4 initializeWithParamSig = bytes4(keccak256("initialize(address)"));

        (bool success,) = STRATEGY.staticcall(abi.encodeWithSelector(initializeSig));
        console.log("Strategy.initialize() callable?", success);

        // Check if there's an initializable slot
        bytes32 initSlot = vm.load(STRATEGY, bytes32(uint256(0)));
        console.log("Slot 0:", vm.toString(initSlot));

        // Strategy uses immutables set in constructor, no initialize function
        console.log("\nStrategy uses constructor, not initializer pattern");
    }

    function test_FindExecutorViaEvents() public view {
        console.log("=== ANALYZING EXECUTOR EVENTS ===\n");

        // The StrategyExecutor emits events when executors are updated
        // We could find actual executors by looking at these events

        // Event: event ExecutorUpdated(address executor, bool isActive);
        // But we can't query events in a view function

        console.log("Would need to query ExecutorUpdated events off-chain");
        console.log("to find all registered executors");
    }

    function test_VaultInteraction() public view {
        console.log("=== VAULT ANALYSIS ===\n");

        address vault = IStrategy(STRATEGY).vault();
        console.log("Vault address:", vault);

        // Check vault's code and balance
        uint256 vaultCodeSize;
        assembly {
            vaultCodeSize := extcodesize(vault)
        }
        console.log("Vault code size:", vaultCodeSize);
        console.log("Vault ETH balance:", vault.balance);

        // Check vault for common token balances
        try IERC20(wstETH).balanceOf(vault) returns (uint256 bal) {
            console.log("Vault wstETH balance:", bal);
        } catch {}

        try IERC20(WETH).balanceOf(vault) returns (uint256 bal) {
            console.log("Vault WETH balance:", bal);
        } catch {}
    }

    function test_AnalyzeStrategyExecutorForVulns() public view {
        console.log("=== STRATEGY EXECUTOR VULNERABILITY SCAN ===\n");

        // The StrategyExecutor:
        // 1. Checks if msg.sender is in executors mapping
        // 2. Gets strategy address from StrategyStorage
        // 3. Checks if strategy is active
        // 4. Checks if actions are whitelisted
        // 5. Calls strategy.callExecute()

        // Potential vulnerabilities:
        // 1. Integer overflow in loops? (Solidity 0.8+ has built-in checks)
        // 2. Reentrancy? (CEI pattern should be checked)
        // 3. Access control bypass? (We tested, blocked)

        console.log("StrategyExecutor checks:");
        console.log("1. executors[msg.sender] == true");
        console.log("2. Strategy exists and is active");
        console.log("3. All actions are whitelisted");
        console.log("4. Assets are whitelisted (if applicable)");
    }

    function test_CheckForSelfDestruct() public view {
        console.log("=== SELFDESTRUCT ANALYSIS ===\n");

        // If any component can be selfdestructed, it could break the system

        // Check for SELFDESTRUCT opcode (0xFF) in bytecode
        bytes memory strategyCode = STRATEGY.code;
        bytes memory executorCode = STRATEGY_EXECUTOR.code;
        bytes memory actionExecCode = ACTION_EXECUTOR.code;

        bool strategyHasSelfdestruct = containsOpcode(strategyCode, 0xff);
        bool executorHasSelfdestruct = containsOpcode(executorCode, 0xff);
        bool actionExecHasSelfdestruct = containsOpcode(actionExecCode, 0xff);

        console.log("Strategy has SELFDESTRUCT?", strategyHasSelfdestruct);
        console.log("StrategyExecutor has SELFDESTRUCT?", executorHasSelfdestruct);
        console.log("ActionExecutor has SELFDESTRUCT?", actionExecHasSelfdestruct);
    }

    function containsOpcode(bytes memory code, uint8 opcode) internal pure returns (bool) {
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == opcode) {
                return true;
            }
        }
        return false;
    }

    function test_CrossStrategyAttack() public view {
        console.log("=== CROSS-STRATEGY ATTACK ANALYSIS ===\n");

        // There are 4 strategies total. Could one strategy attack another?

        IStrategyStorage storage_ = IStrategyStorage(STRATEGY_STORAGE);

        for (uint i = 0; i < 4; i++) {
            (
                address stratAddr,
                bool isActive,
                bytes32[] memory allowedActions,
                address[] memory allowedAssets
            ) = storage_.getStrategyInfo(i);

            console.log("Strategy", i, ":", stratAddr);
            console.log("  Active:", isActive);
            console.log("  Actions:", allowedActions.length);
            console.log("  Assets:", allowedAssets.length);

            // Check balances
            console.log("  ETH balance:", stratAddr.balance);
            try IERC20(wstETH).balanceOf(stratAddr) returns (uint256 bal) {
                if (bal > 0) {
                    console.log("  wstETH balance:", bal);
                }
            } catch {}
            console.log("");
        }
    }

    function test_DirectActionExecution() public {
        console.log("=== DIRECT ACTION EXECUTION TEST ===\n");

        // Can we call actions directly without going through the executor chain?

        IActionRegistry registry = IActionRegistry(ACTION_REGISTRY);

        // Get AaveV3Supply action address
        bytes4 aaveSupplyId = bytes4(0xfc33bf00);
        address aaveSupply = registry.getAddr(aaveSupplyId);
        console.log("AaveV3Supply action:", aaveSupply);

        if (aaveSupply != address(0)) {
            vm.startPrank(attacker);

            // Try calling executeAction directly
            // This runs in the action's context, not Strategy's
            bytes memory callData = abi.encode(uint256(1 ether), uint16(0), uint16(0));
            uint8[] memory paramMapping = new uint8[](3);
            bytes32[] memory returnValues = new bytes32[](0);

            try IAction(aaveSupply).executeAction(callData, paramMapping, returnValues) {
                console.log("Direct action call succeeded!");
                // But this runs in action's context, not useful
            } catch {
                console.log("Direct action call failed (expected)");
            }

            vm.stopPrank();
        }
    }

    function test_AnalyzeUnknownActions() public view {
        console.log("=== ANALYZING UNKNOWN TREEHOUSE ACTIONS ===\n");

        IActionRegistry registry = IActionRegistry(ACTION_REGISTRY);

        // Unknown action IDs that might be custom Treehouse actions
        bytes4[6] memory unknownIds = [
            bytes4(0xd7e40b2d),
            bytes4(0x43142355),
            bytes4(0xacd039ef),
            bytes4(0x2161dd34),
            bytes4(0x245077a0),
            bytes4(0x3d35d254)
        ];

        for (uint i = 0; i < unknownIds.length; i++) {
            address actionAddr = registry.getAddr(unknownIds[i]);
            if (actionAddr != address(0)) {
                console.log("Unknown action", vm.toString(bytes32(unknownIds[i])));
                console.log("  Address:", actionAddr);

                // Try to identify what it does by checking its bytecode
                bytes memory code = actionAddr.code;
                console.log("  Code length:", code.length);

                // Check for common patterns
                bool hasTransfer = containsSelector(code, bytes4(0xa9059cbb)); // transfer
                bool hasApprove = containsSelector(code, bytes4(0x095ea7b3)); // approve
                bool hasDelegatecall = containsOpcode(code, 0xf4);

                console.log("  Has transfer?", hasTransfer);
                console.log("  Has approve?", hasApprove);
                console.log("  Has delegatecall?", hasDelegatecall);
                console.log("");
            }
        }
    }

    function containsSelector(bytes memory code, bytes4 selector) internal pure returns (bool) {
        bytes4 sel = selector;
        for (uint i = 0; i + 4 <= code.length; i++) {
            bytes4 found;
            assembly {
                found := mload(add(add(code, 0x20), i))
            }
            if (found == sel) {
                return true;
            }
        }
        return false;
    }

    function test_GasgriefingAttack() public view {
        console.log("=== GAS GRIEFING ANALYSIS ===\n");

        // Could an attacker cause legitimate users to waste gas?
        // Or cause transactions to fail in unexpected ways?

        console.log("Potential gas griefing vectors:");
        console.log("1. Front-running executor transactions");
        console.log("2. Manipulating external contract state");
        console.log("3. DoS via storage bloat (requires owner)");
    }
}

interface IAction {
    function executeAction(
        bytes calldata _callData,
        uint8[] memory _paramMapping,
        bytes32[] memory _returnValues
    ) external payable returns (bytes32);
}

// Helper contract to try calling as a different address
contract MimicExecutor {
    function tryCallExecute(IStrategy strategy) external returns (bool) {
        try strategy.callExecute(address(0), "") returns (bytes32) {
            return true;
        } catch {
            return false;
        }
    }
}
