// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

interface IBentoBox {
    function flashLoan(
        address borrower,
        address receiver,
        address token,
        uint256 amount,
        bytes calldata data
    ) external;

    function balanceOf(address token, address account) external view returns (uint256);
    function totals(address token) external view returns (uint128 elastic, uint128 base);
    function deposit(address token, address from, address to, uint256 amount, uint256 share) external payable returns (uint256, uint256);
    function withdraw(address token, address from, address to, uint256 amount, uint256 share) external returns (uint256, uint256);
    function toShare(address token, uint256 amount, bool roundUp) external view returns (uint256);
    function toAmount(address token, uint256 share, bool roundUp) external view returns (uint256);
    function registerProtocol() external;
    function setMasterContractApproval(address user, address masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) external;
}

interface IWETH {
    function deposit() external payable;
    function withdraw(uint256) external;
    function approve(address, uint256) external returns (bool);
    function balanceOf(address) external view returns (uint256);
}

contract BentoBoxExploit is Test {
    address constant BENTO = 0xF5BCE5077908a1b7370B9ae04AdC565EBd643966;
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address constant MIM = 0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3;

    IBentoBox bento;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        bento = IBentoBox(BENTO);
    }

    function testBentoBoxShareAnalysis() public view {
        console.log("=====================================================");
        console.log("BENTOBOX SHARE PRECISION ANALYSIS");
        console.log("=====================================================");

        // Check multiple tokens for share/amount discrepancies
        address[4] memory tokens = [WETH, USDC, USDT, MIM];
        string[4] memory names = ["WETH", "USDC", "USDT", "MIM"];

        for (uint i = 0; i < tokens.length; i++) {
            (uint128 elastic, uint128 base) = bento.totals(tokens[i]);

            if (elastic == 0 && base == 0) continue;

            console.log("\n===", names[i], "===");
            console.log("Elastic (real tokens):", uint256(elastic));
            console.log("Base (shares):", uint256(base));

            if (base > 0) {
                // Check for rounding exploitation
                uint256 ratio = uint256(elastic) * 1e18 / uint256(base);
                console.log("Elastic/Base ratio:", ratio);

                // If elastic > base, each share is worth more than 1 token
                // This can be exploited through rounding if the gap is large enough
                if (elastic > base) {
                    uint256 gap = uint256(elastic) - uint256(base);
                    console.log("Gap (elastic - base):", gap);
                }

                // Test small conversions for rounding profit
                testSmallConversions(tokens[i], names[i]);
            }
        }
    }

    function testSmallConversions(address token, string memory name) internal view {
        console.log("\n--- Testing conversions for", name, "---");

        // Test converting small amounts
        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 1;
        amounts[1] = 10;
        amounts[2] = 100;
        amounts[3] = 1000;
        amounts[4] = 10000;

        for (uint i = 0; i < amounts.length; i++) {
            // Convert amount to share
            uint256 share = bento.toShare(token, amounts[i], false);
            // Convert back to amount
            uint256 amountBack = bento.toAmount(token, share, false);

            if (amountBack > amounts[i]) {
                console.log("*** ROUNDING PROFIT ***");
                console.log("Input:", amounts[i]);
                console.log("Output:", amountBack);
                console.log("Profit:", amountBack - amounts[i]);
            }

            // Try round up
            uint256 shareRoundUp = bento.toShare(token, amounts[i], true);
            uint256 amountRoundUp = bento.toAmount(token, shareRoundUp, true);

            if (amountRoundUp > amounts[i] + 1) {
                console.log("*** ROUND UP PROFIT ***");
                console.log("Input:", amounts[i]);
                console.log("Output (roundUp):", amountRoundUp);
            }
        }
    }

    function testFlashLoanArbitrage() public {
        console.log("=====================================================");
        console.log("BENTOBOX FLASH LOAN ARBITRAGE TEST");
        console.log("=====================================================");

        // Check available liquidity for flash loan
        uint256 wethAvailable = IERC20(WETH).balanceOf(BENTO);
        console.log("WETH available for flash loan:", wethAvailable / 1e18);

        uint256 mimAvailable = IERC20(MIM).balanceOf(BENTO);
        console.log("MIM available for flash loan:", mimAvailable / 1e18);

        // BentoBox flash loan fee
        console.log("\nBentoBox flash loan fee: 0.05%");

        // Calculate potential arbitrage needed
        if (wethAvailable > 0) {
            uint256 flashFee = wethAvailable * 5 / 10000;
            console.log("Flash fee for max WETH:", flashFee / 1e18, "WETH");
            console.log("Need profit > fee to be profitable");
        }
    }

    function testDepositWithdrawCycle() public {
        console.log("=====================================================");
        console.log("DEPOSIT/WITHDRAW CYCLE TEST");
        console.log("=====================================================");

        // Setup attacker
        address attacker = makeAddr("attacker");
        deal(WETH, attacker, 100 ether);

        vm.startPrank(attacker);
        IERC20(WETH).approve(BENTO, type(uint256).max);

        uint256 balanceBefore = IERC20(WETH).balanceOf(attacker);
        console.log("WETH before:", balanceBefore / 1e18);

        // Get current totals
        (uint128 elasticBefore, uint128 baseBefore) = bento.totals(WETH);
        console.log("Elastic before:", uint256(elasticBefore));
        console.log("Base before:", uint256(baseBefore));

        // Deposit
        (uint256 amountOut, uint256 shareOut) = bento.deposit(WETH, attacker, attacker, 10 ether, 0);
        console.log("\nDeposit 10 WETH:");
        console.log("Amount deposited:", amountOut / 1e18);
        console.log("Shares received:", shareOut / 1e18);

        // Check shares balance
        uint256 shares = bento.balanceOf(WETH, attacker);
        console.log("Shares in BentoBox:", shares / 1e18);

        // Withdraw all
        (amountOut, shareOut) = bento.withdraw(WETH, attacker, attacker, 0, shares);
        console.log("\nWithdraw all shares:");
        console.log("Amount received:", amountOut / 1e18);
        console.log("Shares burned:", shareOut / 1e18);

        uint256 balanceAfter = IERC20(WETH).balanceOf(attacker);
        console.log("\nWETH after:", balanceAfter / 1e18);

        if (balanceAfter > balanceBefore) {
            console.log("*** PROFIT ***:", (balanceAfter - balanceBefore) / 1e18, "WETH");
        } else if (balanceAfter < balanceBefore) {
            console.log("Loss:", (balanceBefore - balanceAfter) / 1e18, "WETH");
        } else {
            console.log("Break even");
        }

        vm.stopPrank();
    }

    function testMIMAnalysis() public view {
        console.log("=====================================================");
        console.log("MIM IN BENTOBOX ANALYSIS");
        console.log("=====================================================");

        // MIM is used by Abracadabra cauldrons
        (uint128 elastic, uint128 base) = bento.totals(MIM);

        console.log("MIM Elastic:", uint256(elastic) / 1e18);
        console.log("MIM Base:", uint256(base) / 1e18);

        if (base > 0) {
            uint256 ratio = uint256(elastic) * 1e18 / uint256(base);
            console.log("Ratio (1e18 scale):", ratio);

            // Check for significant deviation from 1:1
            if (ratio > 1.01e18) {
                console.log("*** MIM elastic > base by >1% ***");
                uint256 profitPotential = (uint256(elastic) - uint256(base)) * 100 / uint256(base);
                console.log("Potential profit %:", profitPotential);
            }
        }

        // Check MIM balance vs elastic
        uint256 actualMIM = IERC20(MIM).balanceOf(BENTO);
        console.log("\nActual MIM balance:", actualMIM / 1e18);
        console.log("Elastic:", uint256(elastic) / 1e18);

        if (actualMIM > elastic) {
            console.log("*** EXCESS MIM ***:", (actualMIM - elastic) / 1e18);
        }
    }
}
