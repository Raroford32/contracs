// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract Slot4Create2Deep is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant TREASURY_SAFE = 0xB38f2aCb7B562475908c0C6E80a045Deb4023f70;

    bytes32 constant INIT_CODE_HASH = 0xa7afdc89189c0997287e337d2577f5aa7f1fa2faecf74ac9e05b6fdc306bfcd6;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_CheckSlot4InR0() public view {
        console.log("=== CHECKING SLOT 4 IN R0 ===\n");

        bytes32 slot4 = vm.load(REDEMPTION_0, bytes32(uint256(4)));
        console.log("R0 Slot 4:");
        console.logBytes32(slot4);

        address addr4 = address(uint160(uint256(slot4)));
        console.log("As address:", addr4);

        if (addr4 == TREASURY_SAFE) {
            console.log("*** SLOT 4 IS TREASURY SAFE! ***");
        }

        // Check all slots 0-10
        console.log("\nR0 storage layout:");
        for (uint i = 0; i <= 10; i++) {
            bytes32 slot = vm.load(REDEMPTION_0, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
                console.log("  As address:", address(uint160(uint256(slot))));
            }
        }
    }

    function test_Create2WithTreasurySalt() public view {
        console.log("=== CREATE2 WITH TREASURY AS SALT ===\n");

        // If CREATE2 uses slot4 (Treasury) as part of salt:
        bytes32 treasurySalt = bytes32(uint256(uint160(TREASURY_SAFE)));
        console.log("Treasury salt:");
        console.logBytes32(treasurySalt);

        // Predict address if Treasury is deployer:
        address predictedFromTreasury = address(uint160(uint256(keccak256(abi.encodePacked(
            bytes1(0xff),
            TREASURY_SAFE,
            treasurySalt,
            INIT_CODE_HASH
        )))));
        console.log("Predicted (Treasury as deployer):", predictedFromTreasury);
        console.log("Code:", predictedFromTreasury.code.length);

        // Predict if R0 deploys with Treasury as salt:
        address predictedFromR0 = address(uint160(uint256(keccak256(abi.encodePacked(
            bytes1(0xff),
            REDEMPTION_0,
            treasurySalt,
            INIT_CODE_HASH
        )))));
        console.log("\nPredicted (R0 deployer, Treasury salt):", predictedFromR0);
        console.log("Code:", predictedFromR0.code.length);

        // What if CALLER is XOR'd with Treasury?
        bytes32 xorSalt = bytes32(uint256(uint160(attacker)) ^ uint256(uint160(TREASURY_SAFE)));
        address predictedXor = address(uint160(uint256(keccak256(abi.encodePacked(
            bytes1(0xff),
            REDEMPTION_0,
            xorSalt,
            INIT_CODE_HASH
        )))));
        console.log("\nPredicted (XOR salt):", predictedXor);
    }

    function test_TraceCreate2StackOps() public view {
        console.log("=== TRACING CREATE2 STACK OPERATIONS ===\n");

        bytes memory code = REDEMPTION_0.code;

        // CREATE2 is at 5608 (bytecode offset)
        // Actually looking at the output, the sequence is:
        // 5560 PUSH: 4
        // 5562 SLOAD (loads slot 4 = Treasury)
        // 5593 PUSH32: init_code_hash

        // Let's trace the exact sequence
        console.log("Detailed trace from 5555 to 5650:");

        uint i = 5555;
        while (i < 5700 && i < code.length) {
            uint8 op = uint8(code[i]);
            uint skipBytes = 0;

            string memory opName = "";
            if (op == 0x00) opName = "STOP";
            if (op == 0x01) opName = "ADD";
            if (op == 0x02) opName = "MUL";
            if (op == 0x03) opName = "SUB";
            if (op == 0x04) opName = "DIV";
            if (op == 0x10) opName = "LT";
            if (op == 0x11) opName = "GT";
            if (op == 0x14) opName = "EQ";
            if (op == 0x15) opName = "ISZERO";
            if (op == 0x16) opName = "AND";
            if (op == 0x17) opName = "OR";
            if (op == 0x18) opName = "XOR";
            if (op == 0x19) opName = "NOT";
            if (op == 0x1a) opName = "BYTE";
            if (op == 0x1b) opName = "SHL";
            if (op == 0x1c) opName = "SHR";
            if (op == 0x20) opName = "SHA3";
            if (op == 0x30) opName = "ADDRESS";
            if (op == 0x33) opName = "CALLER";
            if (op == 0x34) opName = "CALLVALUE";
            if (op == 0x35) opName = "CALLDATALOAD";
            if (op == 0x36) opName = "CALLDATASIZE";
            if (op == 0x39) opName = "CODECOPY";
            if (op == 0x3b) opName = "EXTCODESIZE";
            if (op == 0x51) opName = "MLOAD";
            if (op == 0x52) opName = "MSTORE";
            if (op == 0x54) opName = "SLOAD";
            if (op == 0x55) opName = "SSTORE";
            if (op == 0x56) opName = "JUMP";
            if (op == 0x57) opName = "JUMPI";
            if (op == 0x5b) opName = "JUMPDEST";
            if (op >= 0x80 && op <= 0x8f) opName = "DUP";
            if (op >= 0x90 && op <= 0x9f) opName = "SWAP";
            if (op == 0xf0) opName = "CREATE";
            if (op == 0xf1) opName = "CALL";
            if (op == 0xf3) opName = "RETURN";
            if (op == 0xf4) opName = "DELEGATECALL";
            if (op == 0xf5) opName = "CREATE2";
            if (op == 0xfd) opName = "REVERT";
            if (op == 0xfe) opName = "INVALID";

            if (bytes(opName).length > 0) {
                console.log(i, opName);
            }

            if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                if (size == 32) {
                    console.log(i, "PUSH32:");
                    console.logBytes32(bytes32(val));
                } else if (size <= 4 && val < 100000) {
                    console.log(i, "PUSH:", val);
                } else if (size == 20) {
                    console.log(i, "PUSH20:", address(uint160(val)));
                }
                skipBytes = size;
            }

            i += 1 + skipBytes;
        }
    }

    function test_WhereIsCreate2Exactly() public view {
        console.log("=== FINDING EXACT CREATE2 OPCODE ===\n");

        bytes memory code = REDEMPTION_0.code;

        console.log("All CREATE2 opcodes (0xf5) in R0:");
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf5) {
                console.log("CREATE2 at:", i);
            }
        }

        // The CREATE2 at offset 5608 from earlier - but that might be in decoded form
        // In raw bytecode it might be different

        // Let's also check for CREATE (0xf0)
        console.log("\nAll CREATE opcodes (0xf0) in R0:");
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf0) {
                console.log("CREATE at:", i);
            }
        }
    }

    function test_TryTreasuryFunctions() public {
        console.log("=== TRYING FUNCTIONS AS TREASURY ===\n");

        // If Treasury can call functions that trigger CREATE2...

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        vm.startPrank(TREASURY_SAFE);

        // Try various functions
        bytes4[] memory sels = new bytes4[](10);
        sels[0] = bytes4(0xed45b661);
        sels[1] = bytes4(0xb2118a8d);
        sels[2] = bytes4(0xcff50c6e);
        sels[3] = bytes4(0x900fd1ed);
        sels[4] = bytes4(0xa82b69ff);
        sels[5] = bytes4(0x458f5815);
        sels[6] = bytes4(0x5f8b5592);
        sels[7] = bytes4(0x3a2ef9df);
        sels[8] = bytes4(0x3f14c193);
        sels[9] = bytes4(0x38a63183);

        console.log("Trying unknown selectors as Treasury:");
        for (uint i = 0; i < sels.length; i++) {
            (bool s, bytes memory d) = REDEMPTION_0.call{gas: 500000}(
                abi.encodeWithSelector(sels[i])
            );
            if (s) {
                console.log("SUCCESS:");
                console.logBytes4(sels[i]);
                if (d.length == 32) {
                    console.log("  Returns:", abi.decode(d, (uint256)));
                }
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault change:", int256(vaultAfter) - int256(vaultBefore));
    }

    function test_Create2InternalFunctionLocator() public view {
        console.log("=== LOCATING INTERNAL CREATE2 FUNCTION ===\n");

        bytes memory code = REDEMPTION_0.code;

        // The bytecode showed CREATE2 is called after:
        // 5555 PUSH: 6002
        // 5558 JUMP

        // This means CREATE2 is in a subroutine at 6002!
        // Let's look at that code

        console.log("Code at offset 6002 (CREATE2 subroutine):");

        uint i = 5990;
        while (i < 6200 && i < code.length) {
            uint8 op = uint8(code[i]);
            uint skipBytes = 0;

            if (op == 0x5b) console.log(i, "JUMPDEST");
            if (op == 0x33) console.log(i, "CALLER");
            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0xf5) console.log(i, "*** CREATE2 ***");
            if (op == 0x20) console.log(i, "SHA3/KECCAK256");
            if (op == 0x39) console.log(i, "CODECOPY");

            if (op >= 0x60 && op <= 0x7f) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                if (size == 32) {
                    console.log(i, "PUSH32:");
                    console.logBytes32(bytes32(val));
                } else if (val < 10000) {
                    console.log(i, "PUSH:", val);
                }
                skipBytes = size;
            }

            i += 1 + skipBytes;
        }
    }
}
