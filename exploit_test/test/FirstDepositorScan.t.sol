// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

interface IERC4626 {
    function totalAssets() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function deposit(uint256 assets, address receiver) external returns (uint256 shares);
    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);
    function asset() external view returns (address);
    function previewDeposit(uint256 assets) external view returns (uint256);
    function previewRedeem(uint256 shares) external view returns (uint256);
}

contract FirstDepositorScan is Test {
    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    function testScanForFirstDepositorVulnerability() public view {
        console.log("=====================================================");
        console.log("SCANNING FOR FIRST DEPOSITOR VULNERABILITIES");
        console.log("=====================================================");

        // Known ERC4626 vaults and similar contracts
        address[15] memory vaults = [
            0xa354F35829Ae975e850e23e9615b11Da1B3dC4DE, // Yearn USDC vault
            0xa258C4606Ca8206D8aA700cE2143D7db854D168c, // Yearn WETH vault
            0xdA816459F1AB5631232FE5e97a05BBBb94970c95, // Yearn DAI vault
            0x27b7b1ad7288079A66d12350c828D3C00A6F07d7, // Yearn vault
            0x378cb52b00F9D0921cb46dFc099CFf73b42419dC, // Yearn LUSD vault
            0x5f18C75AbDAe578b483E5F43f12a39cF75b973a9, // Yearn
            0x7Da96a3891Add058AdA2E826306D812C638D87a7, // Yearn USDT
            0xB8C3B7A2A618C552C23B1E4701109a9E756Bab67, // Yearn
            0xc5bDdf9843308380375a611c18B50Fb9341f502A, // Yearn
            // Morpho vaults
            0x78Fc2c2eD1A4cDb5402365934aE5648aDAd094d0, // Morpho
            0x8eB67A509616cd6A7c1B3c8C21D48FF57df3d458, // Morpho
            0xBEEF01735c132Ada46AA9aA4c54623cAA92A64CB, // Steakhouse
            0x2371e134e3455e0593363cBF89d3b6cf53740618, // Gauntlet
            // Other ERC4626
            0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb, // Morpho Blue
            address(0)
        ];

        for (uint i = 0; i < vaults.length; i++) {
            if (vaults[i] == address(0)) continue;
            if (vaults[i].code.length == 0) continue;

            console.log("\n--- Checking:", vaults[i], "---");

            // Try ERC4626 interface
            (bool s1, bytes memory d1) = vaults[i].staticcall(
                abi.encodeWithSignature("totalSupply()")
            );
            uint256 totalSupply = 0;
            if (s1 && d1.length >= 32) {
                totalSupply = abi.decode(d1, (uint256));
                console.log("Total Supply:", totalSupply);
            }

            (bool s2, bytes memory d2) = vaults[i].staticcall(
                abi.encodeWithSignature("totalAssets()")
            );
            uint256 totalAssets = 0;
            if (s2 && d2.length >= 32) {
                totalAssets = abi.decode(d2, (uint256));
                console.log("Total Assets:", totalAssets);
            }

            // Check asset
            (bool s3, bytes memory d3) = vaults[i].staticcall(
                abi.encodeWithSignature("asset()")
            );
            address asset = address(0);
            if (s3 && d3.length >= 32) {
                asset = abi.decode(d3, (address));
                console.log("Asset:", asset);
            }

            // CRITICAL CHECK: Empty vault with no supply
            if (totalSupply == 0) {
                console.log("*** EMPTY VAULT - FIRST DEPOSITOR ATTACK POSSIBLE ***");

                // Check if there's any donated assets
                if (asset != address(0)) {
                    uint256 assetBalance = IERC20(asset).balanceOf(vaults[i]);
                    if (assetBalance > 0) {
                        console.log("*** DONATED ASSETS PRESENT ***:", assetBalance);
                        console.log("*** IMMEDIATE EXPLOIT POSSIBLE ***");
                    }
                }
            } else if (totalSupply > 0 && totalAssets > 0) {
                // Check for inflated share price (potential previous inflation attack)
                uint256 pricePerShare = totalAssets * 1e18 / totalSupply;
                if (pricePerShare > 1.5e18) {
                    console.log("*** HIGH SHARE PRICE ***:", pricePerShare / 1e18);
                }
            }
        }
    }

    function testCheckMorphoMarkets() public view {
        console.log("=====================================================");
        console.log("CHECKING MORPHO BLUE MARKETS");
        console.log("=====================================================");

        address morpho = 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb;

        console.log("Morpho Blue:", morpho);

        // Check for interesting storage patterns
        console.log("\n--- Storage Analysis ---");
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(morpho, bytes32(i));
            uint256 value = uint256(slot);
            if (value > 0 && value < 1e30) {
                if (value < type(uint160).max && value > 1e10) {
                    address addr = address(uint160(value));
                    if (addr.code.length > 0) {
                        console.log("Slot", i, "= Address:", addr);
                    } else {
                        console.log("Slot", i, "=", value);
                    }
                } else {
                    console.log("Slot", i, "=", value);
                }
            }
        }

        // Check feeRecipient
        (bool success, bytes memory data) = morpho.staticcall(
            abi.encodeWithSignature("feeRecipient()")
        );
        if (success && data.length >= 32) {
            console.log("\nFee Recipient:", abi.decode(data, (address)));
        }

        // Check owner
        (success, data) = morpho.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (success && data.length >= 32) {
            console.log("Owner:", abi.decode(data, (address)));
        }
    }

    function testCheckRebaseTokens() public view {
        console.log("=====================================================");
        console.log("CHECKING REBASE TOKENS FOR ANOMALIES");
        console.log("=====================================================");

        // stETH is a rebasing token
        address stETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;

        uint256 totalSupply = IERC20(stETH).totalSupply();
        console.log("stETH Total Supply:", totalSupply / 1e18);

        // Check Lido for any interesting state
        (bool success, bytes memory data) = stETH.staticcall(
            abi.encodeWithSignature("getTotalPooledEther()")
        );
        if (success && data.length >= 32) {
            uint256 pooledEther = abi.decode(data, (uint256));
            console.log("Total Pooled ETH:", pooledEther / 1e18);

            // Check ratio
            if (totalSupply > 0) {
                uint256 ratio = pooledEther * 1e18 / totalSupply;
                console.log("Pooled/Supply ratio:", ratio);

                // Should be close to 1:1
                if (ratio < 0.99e18 || ratio > 1.01e18) {
                    console.log("*** RATIO ANOMALY ***");
                }
            }
        }

        // Check buffer
        (success, data) = stETH.staticcall(
            abi.encodeWithSignature("getBufferedEther()")
        );
        if (success && data.length >= 32) {
            uint256 buffered = abi.decode(data, (uint256));
            console.log("Buffered ETH:", buffered / 1e18);
        }
    }

    function testSearchForUnusualShareRatios() public view {
        console.log("=====================================================");
        console.log("SEARCHING FOR UNUSUAL SHARE RATIOS");
        console.log("=====================================================");

        // Check contracts that might have share/amount imbalances
        // These could indicate donation attacks or other exploits in progress

        // Convex finance vaults
        address[5] memory convexVaults = [
            0xF403C135812408BFbE8713b5A23a04b3D48AAE31, // Convex Booster
            0x72a19342e8F1838460eBFCCEf09F6585e32db86E, // cvxCRV
            0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e, // cvxFXS
            0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B, // CVX
            address(0)
        ];

        for (uint i = 0; i < convexVaults.length; i++) {
            if (convexVaults[i] == address(0)) continue;
            if (convexVaults[i].code.length == 0) continue;

            console.log("\n--- Convex:", convexVaults[i], "---");

            uint256 balance = convexVaults[i].balance;
            console.log("ETH Balance:", balance / 1e18);

            (bool s1, bytes memory d1) = convexVaults[i].staticcall(
                abi.encodeWithSignature("totalSupply()")
            );
            if (s1 && d1.length >= 32) {
                console.log("Total Supply:", abi.decode(d1, (uint256)) / 1e18);
            }
        }
    }
}
