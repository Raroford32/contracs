// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract Redemption0Implementation is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_FindRedemption0DelegatecallTargets() public view {
        console.log("=== FINDING REDEMPTION_0 DELEGATECALL TARGETS ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Known DELEGATECALL offsets: 1262, 2450, 2681, 3821, 4171, 5323, 6592, 7669
        // DELEGATECALLs at 2450, 2681, 3821, 6592 use PUSH20 (hardcoded)
        // DELEGATECALLs at 1262, 4171, 5323, 7669 use SLOAD (storage-based)

        console.log("Analyzing SLOAD-based DELEGATECALLs:\n");

        // DELEGATECALL at 1262 - SLOAD at 1193
        console.log("=== DELEGATECALL at 1262 ===");
        for (uint i = 1180; i < 1280 && i < code.length; i++) {
            uint8 op = uint8(code[i]);
            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0xf4) console.log(i, "DELEGATECALL");
            if (op >= 0x60 && op <= 0x65) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                console.log(i, "PUSH:", val);
            }
        }

        // DELEGATECALL at 4171 - find SLOAD before it
        console.log("\n=== DELEGATECALL at 4171 ===");
        for (uint i = 4100; i < 4200 && i < code.length; i++) {
            uint8 op = uint8(code[i]);
            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0xf4) console.log(i, "DELEGATECALL");
            if (op >= 0x60 && op <= 0x65) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                console.log(i, "PUSH:", val);
            }
        }

        // DELEGATECALL at 5323 - SLOAD at 5298
        console.log("\n=== DELEGATECALL at 5323 ===");
        for (uint i = 5280; i < 5350 && i < code.length; i++) {
            uint8 op = uint8(code[i]);
            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0xf4) console.log(i, "DELEGATECALL");
            if (op >= 0x60 && op <= 0x65) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                console.log(i, "PUSH:", val);
            }
        }

        // DELEGATECALL at 7669
        console.log("\n=== DELEGATECALL at 7669 ===");
        for (uint i = 7600; i < 7700 && i < code.length; i++) {
            uint8 op = uint8(code[i]);
            if (op == 0x54) console.log(i, "SLOAD");
            if (op == 0xf4) console.log(i, "DELEGATECALL");
            if (op >= 0x60 && op <= 0x65) {
                uint8 size = op - 0x5f;
                uint256 val = 0;
                for (uint j = 0; j < size && i + 1 + j < code.length; j++) {
                    val = val << 8 | uint8(code[i + 1 + j]);
                }
                console.log(i, "PUSH:", val);
            }
        }
    }

    function test_DumpRedemption0StorageSlots() public view {
        console.log("=== DUMPING REDEMPTION_0 STORAGE ===\n");

        // Check slots that might be used as delegatecall targets
        console.log("Storage slots 0-20:");
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(REDEMPTION_0, bytes32(i));
            if (slot != bytes32(0)) {
                address addr = address(uint160(uint256(slot)));
                console.log("Slot", i, ":");
                console.logBytes32(slot);
                if (addr.code.length > 0) {
                    console.log("  -> Contract code size:", addr.code.length);
                }
            }
        }

        // Check EIP-1967 slots
        bytes32 eip1967 = vm.load(REDEMPTION_0, bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));
        if (eip1967 != bytes32(0)) {
            console.log("\nEIP-1967 implementation:");
            console.logBytes32(eip1967);
        }
    }

    function test_AnalyzeHardcodedAddresses() public view {
        console.log("=== ANALYZING HARDCODED ADDRESSES IN REDEMPTION_0 ===\n");

        bytes memory code = REDEMPTION_0.code;

        // Find all PUSH20 operations
        console.log("All PUSH20 (hardcoded addresses):");

        address[] memory found = new address[](20);
        uint foundCount = 0;

        for (uint i = 0; i + 21 < code.length; i++) {
            if (uint8(code[i]) == 0x73) { // PUSH20
                address addr;
                bytes memory addrBytes = new bytes(20);
                for (uint j = 0; j < 20; j++) {
                    addrBytes[j] = code[i + 1 + j];
                }
                assembly {
                    addr := mload(add(addrBytes, 20))
                }

                if (addr != address(0) && addr.code.length > 0) {
                    bool isNew = true;
                    for (uint k = 0; k < foundCount; k++) {
                        if (found[k] == addr) {
                            isNew = false;
                            break;
                        }
                    }
                    if (isNew && foundCount < 20) {
                        found[foundCount] = addr;
                        foundCount++;
                        console.log("At offset", i, ":");
                        console.log("  ", addr);
                        console.log("  Code size:", addr.code.length);
                    }
                }
            }
        }
    }

    function test_InvestigateRedemption1Implementation() public view {
        console.log("=== INVESTIGATING REDEMPTION_1 IMPLEMENTATION ===\n");

        // REDEMPTION_1 has slot 5 = implementation
        bytes32 slot5 = vm.load(REDEMPTION_1, bytes32(uint256(5)));
        address impl = address(uint160(uint256(slot5)));

        console.log("REDEMPTION_1 slot 5 (implementation):");
        console.log(impl);
        console.log("Code size:", impl.code.length);

        if (impl.code.length > 0) {
            // Analyze the implementation
            bytes memory implCode = impl.code;

            // Check if implementation has any exploitable patterns
            console.log("\nImplementation analysis:");

            // Count DELEGATECALLs in implementation
            uint dcCount = 0;
            for (uint i = 0; i < implCode.length; i++) {
                if (uint8(implCode[i]) == 0xf4) dcCount++;
            }
            console.log("DELEGATECALL count:", dcCount);

            // Count CALLs
            uint callCount = 0;
            for (uint i = 0; i < implCode.length; i++) {
                if (uint8(implCode[i]) == 0xf1) callCount++;
            }
            console.log("CALL count:", callCount);

            // Find selectors
            console.log("\nFunction selectors in implementation:");
            for (uint i = 0; i + 4 < implCode.length; i++) {
                if (uint8(implCode[i]) == 0x63) { // PUSH4
                    bytes4 sel = bytes4(bytes.concat(
                        implCode[i+1], implCode[i+2], implCode[i+3], implCode[i+4]
                    ));
                    if (sel != bytes4(0) && sel != bytes4(0xffffffff) && uint32(sel) > 0x1000) {
                        console.logBytes4(sel);
                    }
                }
            }
        }
    }

    function test_TryCallImplementationDirectly() public {
        console.log("=== TRYING TO CALL IMPLEMENTATION DIRECTLY ===\n");

        // REDEMPTION_1's implementation
        bytes32 slot5 = vm.load(REDEMPTION_1, bytes32(uint256(5)));
        address impl = address(uint160(uint256(slot5)));

        console.log("REDEMPTION_1 implementation:", impl);

        // Check implementation's storage
        console.log("\nImplementation storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(impl, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // Try calling functions on implementation directly
        vm.startPrank(attacker);

        // Try initialize
        (bool s1, bytes memory d1) = impl.call(
            abi.encodeWithSignature("initialize(address)", attacker)
        );
        console.log("\ninitialize:", s1);
        if (!s1 && d1.length >= 4) console.logBytes4(bytes4(d1));

        // Try redeem
        (bool s2, bytes memory d2) = impl.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("redeem:", s2);
        if (!s2 && d2.length >= 4) console.logBytes4(bytes4(d2));

        // Try finalizeRedeem
        (bool s3, bytes memory d3) = impl.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("finalizeRedeem:", s3);
        if (!s3 && d3.length >= 4) console.logBytes4(bytes4(d3));

        vm.stopPrank();
    }

    function test_CheckImplementationInitialized() public view {
        console.log("=== CHECKING IF IMPLEMENTATION IS INITIALIZED ===\n");

        // REDEMPTION_1's implementation
        bytes32 slot5 = vm.load(REDEMPTION_1, bytes32(uint256(5)));
        address impl = address(uint160(uint256(slot5)));

        console.log("Implementation:", impl);

        // Check common initialized slots
        bytes32 initSlot = vm.load(impl, bytes32(uint256(0)));
        console.log("Slot 0:");
        console.logBytes32(initSlot);

        // OpenZeppelin Initializable uses a specific slot
        bytes32 ozInitSlot = vm.load(impl, bytes32(uint256(keccak256("eip1967.proxy.initialized"))));
        console.log("\nOZ initialized slot:");
        console.logBytes32(ozInitSlot);

        // Check owner
        (bool s, bytes memory d) = impl.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (s && d.length >= 32) {
            address owner = abi.decode(d, (address));
            console.log("\nImplementation owner:", owner);
        }
    }

    function test_FindRCRedeemCallPath() public view {
        console.log("=== FINDING RC.REDEEM CALL PATH IN REDEMPTION_0 ===\n");

        bytes memory code = REDEMPTION_0.code;

        // RC.redeem selector = 0x7bde82f2
        bytes4 rcRedeem = bytes4(0x7bde82f2);

        console.log("Searching for RC.redeem selector (0x7bde82f2):");

        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(
                    code[i+1], code[i+2], code[i+3], code[i+4]
                ));
                if (sel == rcRedeem) {
                    console.log("Found at offset:", i);

                    // Look for CALL or DELEGATECALL after
                    console.log("Looking for call pattern:");
                    for (uint j = i; j < i + 100 && j < code.length; j++) {
                        if (uint8(code[j]) == 0xf1) {
                            console.log("  CALL at:", j);
                            break;
                        }
                        if (uint8(code[j]) == 0xf4) {
                            console.log("  DELEGATECALL at:", j);
                            break;
                        }
                    }

                    // Look for what function uses this
                    console.log("Looking for function selector before:");
                    for (uint k = i > 500 ? i - 500 : 0; k < i; k++) {
                        if (uint8(code[k]) == 0x63) {
                            bytes4 fnSel = bytes4(bytes.concat(
                                code[k+1], code[k+2], code[k+3], code[k+4]
                            ));
                            if (fnSel != bytes4(0) && fnSel != bytes4(0xffffffff) && uint32(fnSel) > 0x1000) {
                                console.log("  Potential function selector at", k, ":");
                                console.logBytes4(fnSel);
                            }
                        }
                    }
                }
            }
        }
    }

    function test_CheckRedemption0Functions() public {
        console.log("=== CHECKING REDEMPTION_0 FUNCTIONS ===\n");

        // Try to call various functions to understand the contract
        (bool s1, bytes memory d1) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("rc()")
        );
        if (s1 && d1.length >= 32) {
            console.log("rc():", abi.decode(d1, (address)));
        }

        (bool s2, bytes memory d2) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("vault()")
        );
        if (s2 && d2.length >= 32) {
            console.log("vault():", abi.decode(d2, (address)));
        }

        (bool s3, bytes memory d3) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("iau()")
        );
        if (s3 && d3.length >= 32) {
            console.log("iau():", abi.decode(d3, (address)));
        }

        (bool s4, bytes memory d4) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("redemptionController()")
        );
        if (s4 && d4.length >= 32) {
            console.log("redemptionController():", abi.decode(d4, (address)));
        }

        (bool s5, bytes memory d5) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("asset()")
        );
        if (s5 && d5.length >= 32) {
            console.log("asset():", abi.decode(d5, (address)));
        }

        // Check epoch/period info
        (bool s6, bytes memory d6) = REDEMPTION_0.staticcall(
            abi.encodeWithSignature("currentEpoch()")
        );
        if (s6 && d6.length >= 32) {
            console.log("currentEpoch():", abi.decode(d6, (uint256)));
        }
    }
}
