// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
    function symbol() external view returns (string memory);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

interface ICauldron {
    function cook(uint8[] calldata actions, uint256[] calldata values, bytes[] calldata datas) external payable returns (uint256, uint256);
    function accrue() external;
    function totalBorrow() external view returns (uint128 elastic, uint128 base);
    function userBorrowPart(address) external view returns (uint256);
    function userCollateralShare(address) external view returns (uint256);
    function bentoBox() external view returns (address);
    function collateral() external view returns (address);
    function oracle() external view returns (address);
    function oracleData() external view returns (bytes memory);
    function exchangeRate() external view returns (uint256);
    function updateExchangeRate() external returns (bool updated, uint256 rate);
    function COLLATERIZATION_RATE() external view returns (uint256);
    function LIQUIDATION_MULTIPLIER() external view returns (uint256);
    function totalCollateralShare() external view returns (uint256);
    function feeTo() external view returns (address);
    function masterContract() external view returns (address);
}

interface IStabilityPool {
    function provideToSP(uint256 _amount) external;
    function withdrawFromSP(uint256 _amount) external;
    function getDepositorCollateralGain(address _depositor) external view returns (uint256);
    function getCompoundedTHUSDDeposit(address _depositor) external view returns (uint256);
    function getTotalTHUSDDeposits() external view returns (uint256);
    function P() external view returns (uint256);
    function currentScale() external view returns (uint128);
    function currentEpoch() external view returns (uint128);
    function collToken() external view returns (address);
    function thusdToken() external view returns (address);
}

interface IAcceleratingDistributor {
    function stake(address stakedToken, uint256 amount) external;
    function unstake(address stakedToken, uint256 amount) external;
    function withdrawReward(address stakedToken) external;
    function getOutstandingRewards(address stakedToken, address account) external view returns (uint256);
    function getUserStake(address stakedToken, address account) external view returns (uint256 cumulativeBalance, uint256 averageDepositTime, uint256 rewardsAccumulatedPerToken, uint256 rewardsOutstanding);
    function stakingTokens(address) external view returns (bool enabled, uint256 baseEmissionRate, uint256 maxMultiplier, uint256 secondsToMaxMultiplier, uint256 cumulativeStaked, uint256 rewardPerTokenStored, uint256 lastUpdateTime);
    function rewardToken() external view returns (address);
}

interface IBentoBox {
    function balanceOf(address token, address user) external view returns (uint256);
    function toAmount(address token, uint256 share, bool roundUp) external view returns (uint256);
    function toShare(address token, uint256 amount, bool roundUp) external view returns (uint256);
    function totals(address token) external view returns (uint128 elastic, uint128 base);
}

contract NovelVulnSearch is Test {
    // Cauldrons (Abracadabra-style)
    address constant CAULDRON_V3 = 0x7Ce7D9ED62B9A6c5aCe1c6Ec9aeb115FA3064757;

    // Stability Pools (Liquity-style)
    address constant STABILITY_POOL = 0xF6374AEfb1e69a21ee516ea4B803b2eA96d06f29;

    // Accelerating Distributor
    address constant ACCEL_DISTRIBUTOR = 0x9040e41eF5E8b281535a96D9a48aCb8cfaBD9a48;

    // Common tokens
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant MIM = 0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3;
    address constant ACX = 0x44108f0223A3C3028F5Fe7AEC7f9bb2E66beF82F;

    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    /*//////////////////////////////////////////////////////////////
                    CAULDRON V3 DEEP ANALYSIS
    //////////////////////////////////////////////////////////////*/

    function testCauldronV3Analysis() public {
        console.log("==============================================");
        console.log("CAULDRON V3 (ABRACADABRA-STYLE) DEEP ANALYSIS");
        console.log("==============================================");

        ICauldron cauldron = ICauldron(CAULDRON_V3);

        // Check if contract exists and has funds
        console.log("\n--- Contract State ---");

        address bentoBox = cauldron.bentoBox();
        console.log("BentoBox:", bentoBox);

        address collateral = cauldron.collateral();
        console.log("Collateral Token:", collateral);

        (uint128 elastic, uint128 base) = cauldron.totalBorrow();
        console.log("Total Borrow Elastic:", elastic);
        console.log("Total Borrow Base:", base);

        uint256 totalCollateral = cauldron.totalCollateralShare();
        console.log("Total Collateral Share:", totalCollateral);

        // Check BentoBox balance
        if (bentoBox != address(0) && collateral != address(0)) {
            uint256 bentoBalance = IBentoBox(bentoBox).balanceOf(collateral, CAULDRON_V3);
            console.log("Collateral in BentoBox:", bentoBalance);

            if (bentoBalance > 0) {
                uint256 actualAmount = IBentoBox(bentoBox).toAmount(collateral, bentoBalance, false);
                console.log("Collateral Amount:", actualAmount);
            }
        }

        // Check exchange rate
        console.log("\n--- Exchange Rate Analysis ---");
        address oracle = cauldron.oracle();
        console.log("Oracle:", oracle);

        try cauldron.exchangeRate() returns (uint256 rate) {
            console.log("Current Exchange Rate:", rate);
        } catch {
            console.log("Exchange rate call failed");
        }

        // Check collateralization
        uint256 collRate = cauldron.COLLATERIZATION_RATE();
        uint256 liqMult = cauldron.LIQUIDATION_MULTIPLIER();
        console.log("Collaterization Rate:", collRate);
        console.log("Liquidation Multiplier:", liqMult);

        // Try cook() with various actions
        console.log("\n--- cook() Attack Surface ---");
        console.log("Actions available:");
        console.log("  1 = Add Collateral");
        console.log("  2 = Remove Collateral");
        console.log("  3 = Borrow");
        console.log("  4 = Repay");
        console.log(" 10 = BentoBox Deposit");
        console.log(" 11 = BentoBox Withdraw");
        console.log(" 30 = Call External Contract");

        // The vulnerability in Abracadabra was:
        // 1. Multiple borrows in same cook() before solvency check
        // 2. Exchange rate manipulation between actions
        console.log("\nAbracadabra-style attack requires:");
        console.log("  - Solvency check only at END of cook()");
        console.log("  - Ability to manipulate exchange rate mid-cook()");
        console.log("  - Sufficient liquidity to borrow against");
    }

    function testCauldronV3CookExploit() public {
        console.log("=== CauldronV3 cook() Exploit Attempt ===");

        ICauldron cauldron = ICauldron(CAULDRON_V3);

        // Check total borrow - if 0, contract is empty
        (uint128 elastic,) = cauldron.totalBorrow();

        if (elastic == 0) {
            console.log("RESULT: Contract has no borrows - no funds to steal");
            return;
        }

        address bentoBox = cauldron.bentoBox();
        address collateral = cauldron.collateral();

        // Check actual liquidity
        uint256 mimBalance = IERC20(MIM).balanceOf(bentoBox);
        console.log("MIM in BentoBox:", mimBalance);

        vm.startPrank(attacker);

        // The attack would be:
        // 1. Deposit minimal collateral via cook()
        // 2. Borrow maximum via cook()
        // 3. Use ACTION_CALL to manipulate exchange rate
        // 4. Borrow more before solvency check
        // 5. Exit with more than collateral worth

        console.log("\nAttempting cook() attack...");

        uint8[] memory actions = new uint8[](1);
        uint256[] memory values = new uint256[](1);
        bytes[] memory datas = new bytes[](1);

        // Try to call accrue first
        try cauldron.accrue() {
            console.log("accrue() succeeded");
        } catch {
            console.log("accrue() failed");
        }

        vm.stopPrank();
    }

    /*//////////////////////////////////////////////////////////////
                    STABILITY POOL DEEP ANALYSIS
    //////////////////////////////////////////////////////////////*/

    function testStabilityPoolAnalysis() public {
        console.log("==============================================");
        console.log("STABILITY POOL (LIQUITY-STYLE) DEEP ANALYSIS");
        console.log("==============================================");

        IStabilityPool sp = IStabilityPool(STABILITY_POOL);

        console.log("\n--- Pool State ---");

        uint256 totalDeposits = sp.getTotalTHUSDDeposits();
        console.log("Total THUSD Deposits:", totalDeposits);

        uint256 P = sp.P();
        console.log("Product Factor P:", P);

        uint128 scale = sp.currentScale();
        uint128 epoch = sp.currentEpoch();
        console.log("Current Scale:", scale);
        console.log("Current Epoch:", epoch);

        address collToken = sp.collToken();
        address thusdToken = sp.thusdToken();
        console.log("Collateral Token:", collToken);
        console.log("THUSD Token:", thusdToken);

        // Check pool balances
        if (collToken != address(0)) {
            uint256 collBalance = IERC20(collToken).balanceOf(STABILITY_POOL);
            console.log("Collateral Balance:", collBalance);
        }

        console.log("\n--- Epoch/Scale Attack Surface ---");
        console.log("Liquity-style pools have known edge cases:");
        console.log("  - Scale changes when P underflows");
        console.log("  - Epoch resets when pool empties");
        console.log("  - Deposits from old epochs considered depleted");

        // The attack would be:
        // 1. Deposit to become only depositor
        // 2. Trigger scale change to zero out others
        // 3. Claim all collateral rewards

        if (P == 0) {
            console.log("\nCRITICAL: P = 0, pool may be in vulnerable state!");
        }

        if (epoch > 0) {
            console.log("\nEpoch > 0: Pool has been emptied before");
        }
    }

    /*//////////////////////////////////////////////////////////////
                    ACCELERATING DISTRIBUTOR ANALYSIS
    //////////////////////////////////////////////////////////////*/

    function testAcceleratingDistributorAnalysis() public {
        console.log("==============================================");
        console.log("ACCELERATING DISTRIBUTOR DEEP ANALYSIS");
        console.log("==============================================");

        IAcceleratingDistributor dist = IAcceleratingDistributor(ACCEL_DISTRIBUTOR);

        console.log("\n--- Contract State ---");

        address rewardToken = dist.rewardToken();
        console.log("Reward Token:", rewardToken);

        uint256 rewardBalance = IERC20(rewardToken).balanceOf(ACCEL_DISTRIBUTOR);
        console.log("Reward Token Balance:", rewardBalance);

        // Check ACX staking config
        console.log("\n--- ACX Staking Config ---");
        try dist.stakingTokens(ACX) returns (
            bool enabled,
            uint256 baseEmissionRate,
            uint256 maxMultiplier,
            uint256 secondsToMaxMultiplier,
            uint256 cumulativeStaked,
            uint256 rewardPerTokenStored,
            uint256 lastUpdateTime
        ) {
            console.log("Enabled:", enabled);
            console.log("Base Emission Rate:", baseEmissionRate);
            console.log("Max Multiplier:", maxMultiplier);
            console.log("Seconds to Max:", secondsToMaxMultiplier);
            console.log("Cumulative Staked:", cumulativeStaked);
            console.log("Reward Per Token:", rewardPerTokenStored);

            // The vulnerability would be:
            // 1. When cumulativeStaked = 0, rewardPerTokenStored could be manipulated
            // 2. averageDepositTime edge cases when balance = 0

            if (cumulativeStaked == 0) {
                console.log("\nWARNING: cumulativeStaked = 0");
                console.log("First depositor could potentially inflate rewards");
            }
        } catch {
            console.log("Failed to get staking token config");
        }

        console.log("\n--- Multiplier Attack Surface ---");
        console.log("Multiplier math: 1e18 + (fraction * (max - 1e18)) / 1e18");
        console.log("Potential overflow if maxMultiplier >= 1e36");
        console.log("averageDepositTime = 0 when balance = 0 creates edge case");
    }

    /*//////////////////////////////////////////////////////////////
                    SEARCH MORE CONTRACTS
    //////////////////////////////////////////////////////////////*/

    function testScanContractsForValue() public view {
        console.log("==============================================");
        console.log("SCANNING CONTRACTS FOR EXPLOITABLE VALUE");
        console.log("==============================================");

        // Check multiple contracts for balance
        address[10] memory contracts = [
            0x7Ce7D9ED62B9A6c5aCe1c6Ec9aeb115FA3064757, // CauldronV3
            0xF6374AEfb1e69a21ee516ea4B803b2eA96d06f29, // StabilityPool
            0x9040e41eF5E8b281535a96D9a48aCb8cfaBD9a48, // AcceleratingDistributor
            0x73feaa1eE314F8c655E354234017bE2193C9E24E, // PancakeSwap?
            0x5954aB967Bc958940b7EB73ee84797Dc8a2AFbb9, // ApeCoinStaking
            0xc186fA914353c44b2E33eBE05f21846F1048bEda, // HubPool
            0x996913c8c08472f584ab8834e925b06D0eb1D813, // RewardVault
            0x9A0C8Ff858d273f57072D714bca7411D717501D7, // st1inch
            0x889edC2eDab5f40e902b864aD4d7AdE8E412F9B1, // Lido Queue
            0x097f1ee62E63aCFC3Bf64c1a61d96B3771dd06cB  // BAMM
        ];

        for (uint i = 0; i < contracts.length; i++) {
            address c = contracts[i];
            uint256 ethBal = c.balance;

            // Check WETH balance
            uint256 wethBal = IERC20(WETH).balanceOf(c);

            if (ethBal > 0 || wethBal > 0) {
                console.log("\nContract:", c);
                console.log("  ETH:", ethBal);
                console.log("  WETH:", wethBal);
            }
        }
    }
}
