// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external;
}

interface ICurveNG {
    function get_dy(uint256 i, uint256 j, uint256 dx) external view returns (uint256);
    function get_virtual_price() external view returns (uint256);
}

interface IChainlinkOracle {
    function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80);
}

contract AccurateUSDePrice is Test {
    address constant USDE = 0x4c9EDD5852cd905f086C759E8383e09bff1E68B3;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant CURVE_POOL = 0x02950460E2b9529D0E00284A5fA2d7bDF3fA4d72;
    address constant USDE_ORACLE = 0xa569d910839Ae8865Da8F8e70FfFb0cBA869F961;
    
    string constant RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    
    function setUp() public {
        vm.createSelectFork(RPC_URL);
    }
    
    function test_GetExactDEXPrice() public view {
        console.log("=== ACCURATE USDe PRICE CHECK ===\n");
        
        ICurveNG pool = ICurveNG(CURVE_POOL);
        
        // Try to get quote: 1000 USDe -> USDC
        // Curve NG pools use uint256 indices
        uint256 usdeAmount = 1000e18;
        
        console.log("Attempting to quote swap...");
        
        try pool.get_dy(0, 1, usdeAmount) returns (uint256 usdcOut) {
            console.log("SUCCESS with (0,1):");
            console.log("  Input: 1000 USDe");
            console.log("  Output:", usdcOut / 1e6, "USDC");
            
            // Calculate implied price
            // 1000 USDe = X USDC means 1 USDe = X/1000 USDC
            uint256 priceInCents = usdcOut * 100 / 1000e6;
            console.log("  Implied USDe price: $", priceInCents, "/ 100");
        } catch {
            console.log("Failed (0,1), trying (1,0)...");
            
            try pool.get_dy(1, 0, usdeAmount) returns (uint256 usdcOut) {
                console.log("SUCCESS with (1,0):");
                console.log("  Output:", usdcOut / 1e6, "USDC");
            } catch {
                console.log("Both failed");
            }
        }
        
        // Also check with smaller amount
        console.log("\nTrying smaller amount (100 USDe)...");
        try pool.get_dy(0, 1, 100e18) returns (uint256 usdcOut) {
            console.log("  100 USDe ->", usdcOut / 1e6, "USDC");
            console.log("  Price: $", usdcOut * 100 / 100e6, "/ 100");
        } catch {}
        
        // Get oracle price for comparison
        console.log("\n--- ORACLE COMPARISON ---");
        (, int256 oraclePrice,, uint256 updatedAt,) = IChainlinkOracle(USDE_ORACLE).latestRoundData();
        console.log("Oracle USDe/USD:", uint256(oraclePrice));
        console.log("Oracle staleness:", (block.timestamp - updatedAt) / 3600, "hours");
    }
    
    function test_GetPoolInfo() public view {
        console.log("=== POOL DETAILED INFO ===\n");
        
        // Check what functions the pool has
        address pool = CURVE_POOL;
        
        // Try to get coins
        (bool success, bytes memory data) = pool.staticcall(abi.encodeWithSignature("coins(uint256)", 0));
        if (success && data.length >= 32) {
            address coin0 = abi.decode(data, (address));
            console.log("Coin 0:", coin0);
        }
        
        (success, data) = pool.staticcall(abi.encodeWithSignature("coins(uint256)", 1));
        if (success && data.length >= 32) {
            address coin1 = abi.decode(data, (address));
            console.log("Coin 1:", coin1);
        }
        
        // Try balances
        (success, data) = pool.staticcall(abi.encodeWithSignature("balances(uint256)", 0));
        if (success && data.length >= 32) {
            uint256 bal0 = abi.decode(data, (uint256));
            console.log("Balance 0:", bal0 / 1e18);
        }
        
        (success, data) = pool.staticcall(abi.encodeWithSignature("balances(uint256)", 1));
        if (success && data.length >= 32) {
            uint256 bal1 = abi.decode(data, (uint256));
            console.log("Balance 1:", bal1 / 1e6);
        }
    }
}
