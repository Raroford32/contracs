// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IStrategy {
    function execute(address _target, bytes memory _data) external payable returns (bytes32 _response);
    function callExecute(address _target, bytes memory _data) external payable returns (bytes32 _response);
    function vault() external view returns (address);
    function strategyStorage() external view returns (address);
}

interface IStrategyStorage {
    function strategyExecutor() external view returns (address);
    function owner() external view returns (address);
    function getStrategyAddress(uint _strategyId) external view returns (address);
    function isActiveStrategy(address _strategy) external view returns (bool);
    function isActionWhitelisted(address _strategy, bytes4 _actionId) external view returns (bool);
    function isAssetWhitelisted(address _strategy, address _asset) external view returns (bool);
    function getStrategyCount() external view returns (uint);
    function getStrategyInfo(uint _strategyId) external view returns (
        address _strategyAddress,
        bool _isActive,
        bytes32[] memory _allowedActions,
        address[] memory _allowedAssets
    );
}

interface IStrategyExecutor {
    function executors(address) external view returns (bool);
    function owner() external view returns (address);
    function STRATEGY_STORAGE() external view returns (address);
    function ACTION_EXECUTOR() external view returns (address);
    function executeOnStrategy(
        uint _strategyId,
        bytes4[] calldata _actionIds,
        bytes[] calldata _actionCalldata,
        uint8[][] memory _paramMapping
    ) external payable;
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
}

contract TreehouseStrategyExploitTest is Test {
    // Treehouse Protocol addresses
    address constant STRATEGY = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant STRATEGY_STORAGE = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;
    address constant STRATEGY_EXECUTOR = 0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant ACTION_EXECUTOR = 0xb1593193Bcd7CEcc3d19597658003d735D1e9E94;

    // Common token addresses
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    // stETH address removed - not needed for tests

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
    }

    function test_AnalyzeTreehouseArchitecture() public view {
        console.log("=== TREEHOUSE PROTOCOL ARCHITECTURE ===");
        console.log("");
        console.log("Strategy:", STRATEGY);
        console.log("StrategyStorage:", STRATEGY_STORAGE);
        console.log("StrategyExecutor:", STRATEGY_EXECUTOR);
        console.log("Vault:", VAULT);
        console.log("ActionExecutor (DeFiSaver):", ACTION_EXECUTOR);
        console.log("");

        // Check Strategy configuration
        IStrategy strategy = IStrategy(STRATEGY);
        console.log("Strategy.vault():", strategy.vault());
        console.log("Strategy.strategyStorage():", strategy.strategyStorage());

        // Check StrategyStorage
        IStrategyStorage storage_ = IStrategyStorage(STRATEGY_STORAGE);
        console.log("StrategyStorage.owner():", storage_.owner());
        console.log("StrategyStorage.strategyExecutor():", storage_.strategyExecutor());

        // Check StrategyExecutor
        IStrategyExecutor executor = IStrategyExecutor(STRATEGY_EXECUTOR);
        console.log("StrategyExecutor.owner():", executor.owner());
        console.log("StrategyExecutor.STRATEGY_STORAGE():", executor.STRATEGY_STORAGE());
        console.log("StrategyExecutor.ACTION_EXECUTOR():", executor.ACTION_EXECUTOR());
    }

    function test_CheckStrategyBalances() public view {
        console.log("\n=== STRATEGY BALANCES ===");

        console.log("ETH balance:", STRATEGY.balance);

        // Check common token balances
        try IERC20(WETH).balanceOf(STRATEGY) returns (uint256 bal) {
            console.log("WETH balance:", bal);
        } catch {}

        try IERC20(USDC).balanceOf(STRATEGY) returns (uint256 bal) {
            console.log("USDC balance:", bal);
        } catch {}

        try IERC20(USDT).balanceOf(STRATEGY) returns (uint256 bal) {
            console.log("USDT balance:", bal);
        } catch {}
    }

    function test_CheckVaultBalances() public view {
        console.log("\n=== VAULT BALANCES ===");

        console.log("Vault ETH balance:", VAULT.balance);

        try IERC20(WETH).balanceOf(VAULT) returns (uint256 bal) {
            console.log("Vault WETH balance:", bal);
        } catch {}

        try IERC20(USDC).balanceOf(VAULT) returns (uint256 bal) {
            console.log("Vault USDC balance:", bal);
        } catch {}
    }

    function test_CheckExecutorsAndAccessControl() public view {
        console.log("\n=== ACCESS CONTROL ANALYSIS ===");

        IStrategyExecutor executor = IStrategyExecutor(STRATEGY_EXECUTOR);

        // Check if attacker is an executor
        bool attackerIsExecutor = executor.executors(attacker);
        console.log("Is attacker an executor?", attackerIsExecutor);

        // Check owner
        address owner = executor.owner();
        console.log("StrategyExecutor owner:", owner);

        // Check owner's code size (is it a multisig?)
        uint256 codeSize;
        assembly {
            codeSize := extcodesize(owner)
        }
        console.log("Owner code size:", codeSize);

        if (codeSize > 0) {
            console.log("Owner is a CONTRACT");
        } else {
            console.log("WARNING: Owner is an EOA!");
        }
    }

    function test_AttackVector_DirectCallExecute() public {
        console.log("\n=== ATTACK: Direct callExecute ===");

        vm.startPrank(attacker);

        IStrategy strategy = IStrategy(STRATEGY);

        // Try to call callExecute directly - should fail
        try strategy.callExecute(address(0x1234), "") {
            console.log("CRITICAL: Direct callExecute succeeded!");
        } catch {
            console.log("Expected: callExecute reverted (not strategyExecutor)");
        }

        vm.stopPrank();
    }

    function test_AttackVector_DirectExecute() public {
        console.log("\n=== ATTACK: Direct execute ===");

        vm.startPrank(attacker);

        IStrategy strategy = IStrategy(STRATEGY);

        // Try to call execute directly - should fail
        try strategy.execute(address(0x1234), "") {
            console.log("CRITICAL: Direct execute succeeded!");
        } catch {
            console.log("Expected: execute reverted (not address(this))");
        }

        vm.stopPrank();
    }

    function test_AttackVector_FakeExecutor() public {
        console.log("\n=== ATTACK: Fake Executor Registration ===");

        IStrategyExecutor executor = IStrategyExecutor(STRATEGY_EXECUTOR);

        // Can attacker register themselves?
        vm.startPrank(attacker);

        // This should fail - only owner can updateExecutor
        // We can't call it without being owner
        console.log("Cannot register as executor - onlyOwner");

        vm.stopPrank();
    }

    function test_AttackVector_ExecuteOnStrategy() public {
        console.log("\n=== ATTACK: executeOnStrategy as non-executor ===");

        IStrategyExecutor executor = IStrategyExecutor(STRATEGY_EXECUTOR);

        vm.startPrank(attacker);

        bytes4[] memory actionIds = new bytes4[](0);
        bytes[] memory callDatas = new bytes[](0);
        uint8[][] memory paramMappings = new uint8[][](0);

        // This should fail - attacker is not an executor
        try executor.executeOnStrategy(0, actionIds, callDatas, paramMappings) {
            console.log("CRITICAL: executeOnStrategy succeeded for non-executor!");
        } catch {
            console.log("Expected: Reverted (not an executor)");
        }

        vm.stopPrank();
    }

    function test_CheckWhitelistedActions() public view {
        console.log("\n=== WHITELISTED ACTIONS FOR STRATEGY ===");

        IStrategyStorage storage_ = IStrategyStorage(STRATEGY_STORAGE);

        // Get strategy count
        uint256 strategyCount = storage_.getStrategyCount();
        console.log("Total strategies:", strategyCount);

        // Find our strategy's ID
        for (uint i = 0; i < strategyCount && i < 10; i++) {
            address stratAddr = storage_.getStrategyAddress(i);
            if (stratAddr == STRATEGY) {
                console.log("Found strategy at index:", i);

                (
                    address addr,
                    bool isActive,
                    bytes32[] memory allowedActions,
                    address[] memory allowedAssets
                ) = storage_.getStrategyInfo(i);

                console.log("Strategy address:", addr);
                console.log("Is active:", isActive);
                console.log("Allowed actions count:", allowedActions.length);
                console.log("Allowed assets count:", allowedAssets.length);

                for (uint j = 0; j < allowedActions.length; j++) {
                    console.log("Action", j, ":");
                    console.logBytes32(allowedActions[j]);
                }

                for (uint j = 0; j < allowedAssets.length; j++) {
                    console.log("Asset", j, ":", allowedAssets[j]);
                }
            }
        }
    }

    function test_SimulateExecutorCompromise() public {
        console.log("\n=== SIMULATING EXECUTOR COMPROMISE ===");

        IStrategyExecutor executor = IStrategyExecutor(STRATEGY_EXECUTOR);
        address owner = executor.owner();

        // Simulate owner adding attacker as executor
        vm.startPrank(owner);

        // Note: We would need the actual function signature
        // executor.updateExecutor(attacker, true);

        console.log("If executor owner is compromised:");
        console.log("1. Attacker gets registered as executor");
        console.log("2. Attacker can call executeOnStrategy");
        console.log("3. Attacker can execute whitelisted actions");
        console.log("4. Actions run in Strategy context via delegatecall");
        console.log("");
        console.log("IMPACT: Depends on whitelisted actions");
        console.log("If SendToken/transfer is whitelisted -> CRITICAL");

        vm.stopPrank();
    }

    function test_FinalSecurityAssessment() public view {
        console.log("\n=== FINAL SECURITY ASSESSMENT ===");
        console.log("");
        console.log("ARCHITECTURE:");
        console.log("User -> StrategyExecutor.executeOnStrategy()");
        console.log("       -> Strategy.callExecute(ActionExecutor, data)");
        console.log("       -> Strategy.execute() [self-call]");
        console.log("       -> delegatecall(ActionExecutor)");
        console.log("       -> ActionExecutor.executeActions()");
        console.log("       -> delegatecall(RegisteredAction)");
        console.log("");
        console.log("ACCESS CONTROLS:");
        console.log("1. executeOnStrategy requires executor whitelist");
        console.log("2. callExecute requires msg.sender == strategyExecutor");
        console.log("3. execute requires msg.sender == address(this)");
        console.log("4. Actions must be whitelisted in StrategyStorage");
        console.log("");
        console.log("CONCLUSION:");
        console.log("No UNPRIVILEGED attack vector found.");
        console.log("Exploitation requires:");
        console.log("  - StrategyExecutor owner compromise, OR");
        console.log("  - StrategyStorage owner compromise");
        console.log("");
        console.log("STATUS: UNPROVEN for unprivileged attacker");
    }
}
