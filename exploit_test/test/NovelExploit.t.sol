// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IStrategy {
    function execute(address _target, bytes memory _data) external payable returns (bytes32);
    function callExecute(address _target, bytes memory _data) external payable returns (bytes32);
    function vault() external view returns (address);
    function strategyStorage() external view returns (address);
}

interface IStrategyStorage {
    function strategyExecutor() external view returns (address);
    function owner() external view returns (address);
}

interface IActionExecutor {
    function executeActions(
        bytes4[] calldata _actionIds,
        bytes[] calldata _actionCalldata,
        uint8[][] calldata _paramMapping
    ) external payable;
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

contract NovelExploitTest is Test {
    address constant STRATEGY = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;
    address constant STRATEGY_STORAGE = 0x97c03F52244E60BB18511Cbf03f890D5886f1F47;
    address constant STRATEGY_EXECUTOR = 0x89f57D3617F6a9FF877fEa34Dd0688b2840Ef50e;
    address constant ACTION_EXECUTOR = 0xb1593193Bcd7CEcc3d19597658003d735D1e9E94;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    
    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_CheckAllFunctionSelectors() public view {
        console.log("=== SCANNING STRATEGY FUNCTION SELECTORS ===\n");
        
        bytes memory code = STRATEGY.code;
        console.log("Strategy code size:", code.length);
        
        // Look for PUSH4 opcodes (0x63) which indicate function selectors
        for (uint i = 0; i < code.length - 4; i++) {
            if (code[i] == 0x63) { // PUSH4
                bytes4 selector = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                console.log("Found selector:");
                console.logBytes4(selector);
            }
        }
    }

    function test_DirectActionExecutorCall() public {
        console.log("=== DIRECT ACTION EXECUTOR CALL ===\n");
        
        // What if we call ActionExecutor directly, not through Strategy?
        // ActionExecutor.executeActions might not check caller
        
        vm.startPrank(attacker);
        
        bytes4[] memory actionIds = new bytes4[](1);
        bytes[] memory calldata_ = new bytes[](1);
        uint8[][] memory paramMapping = new uint8[][](1);
        
        // Try calling ActionExecutor directly
        try IActionExecutor(ACTION_EXECUTOR).executeActions(actionIds, calldata_, paramMapping) {
            console.log("CRITICAL: Direct ActionExecutor call succeeded!");
        } catch Error(string memory reason) {
            console.log("ActionExecutor failed:", reason);
        } catch {
            console.log("ActionExecutor failed (unknown)");
        }
        
        vm.stopPrank();
    }

    function test_StorageSlotAnalysis() public view {
        console.log("=== DEEP STORAGE ANALYSIS ===\n");
        
        // Check Strategy storage for any mutable state
        console.log("Strategy Storage:");
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(STRATEGY, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i);
                console.logBytes32(slot);
            }
        }
        
        console.log("\nStrategyStorage contract:");
        for (uint i = 0; i < 20; i++) {
            bytes32 slot = vm.load(STRATEGY_STORAGE, bytes32(i));
            if (slot != bytes32(0)) {
                console.log("Slot", i);
                console.logBytes32(slot);
            }
        }
    }
}
