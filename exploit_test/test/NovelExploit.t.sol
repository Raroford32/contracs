// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

/**
 * @title Novel Protocol-Level Exploit Search
 * @notice Searching for complex multi-step vulnerabilities in heavily audited contracts
 * @dev Focus: Cross-contract state corruption, economic invariant violations, emergent behavior
 */

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
}

interface IDBR {
    function mint(address, uint) external;
    function balanceOf(address) external view returns (uint256);
}

interface IDolaSavings {
    function stake(uint amount, address recipient) external;
    function unstake(uint amount) external;
    function claim(address to) external;
    function claimable(address user) external view returns (uint);
    function balanceOf(address) external view returns (uint);
    function totalSupply() external view returns (uint);
    function rewardIndexMantissa() external view returns (uint);
    function yearlyRewardBudget() external view returns (uint);
    function maxRewardPerDolaMantissa() external view returns (uint);
    function lastUpdate() external view returns (uint);
    function stakerIndexMantissa(address) external view returns (uint);
    function accruedRewards(address) external view returns (uint);
    function dbr() external view returns (address);
    function dola() external view returns (address);
}

interface IFraxRedemptionQueue {
    function enterRedemptionQueue(uint120 _amountToRedeem, address _recipient) external returns (uint256);
    function burnRedemptionTicketNft(uint256 _nftId, address payable _recipient) external;
    function redemptionQueueState() external view returns (uint64, uint64, uint64, uint32);
    function redemptionQueueAccounting() external view returns (uint128, uint128);
    function nftInformation(uint256) external view returns (bool, uint64, uint64, uint120, address);
}

interface IChainlinkRewardVault {
    function claimReward() external returns (uint256);
    function getReward(address staker) external view returns (uint256);
    function getBaseReward(address staker) external view returns (uint256);
    function getDelegationReward(address staker) external view returns (uint256);
}

interface IEthenaMinting {
    function usde() external view returns (address);
    function delegatedSigner(address, address) external view returns (uint8);
    function totalPerBlock(uint256) external view returns (uint128, uint128);
    function globalConfig() external view returns (uint128, uint128);
    function stablesDeltaLimit() external view returns (uint128);
}

interface IEthenaLPStaking {
    function stake(address token, uint104 amount) external;
    function unstake(address token, uint104 amount) external;
    function withdraw(address token, uint104 amount) external;
    function stakes(address, address) external view returns (uint256, uint152, uint104);
    function stakeParametersByToken(address) external view returns (uint8, uint248, uint104, uint104, uint48);
    function currentEpoch() external view returns (uint8);
}

contract NovelExploitTest is Test {
    // Key contract addresses
    address constant DOLA_SAVINGS = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4;
    address constant FRAX_QUEUE = 0x82bA8da44Cd5261762e629dd5c605b17715727bd;
    address constant CHAINLINK_REWARD_VAULT = 0x996913c8c08472f584ab8834e925b06D0eb1D813;
    address constant ETHENA_MINTING = 0xe3490297a08d6fC8Da46Edb7B6142E4F461b62D3;
    address constant ETHENA_LP_STAKING = 0x8707f238936c12c309bfc2B9959C35828AcFc512;

    // Token addresses
    address constant DOLA = 0x865377367054516e17014CcdED1e7d814EDC9ce4;
    address constant DBR = 0xAD038Eb671c44b853887A7E32528FaB35dC5D710;
    address constant FRXETH = 0x5E8422345238F34275888049021821E8E08CAa1f;
    address constant USDE = 0x4c9EDD5852cd905f086C759E8383e09bff1E68B3;
    address constant SUSDE = 0x9D39A5DE30e57443BfF2A8307A4256c8797A3497;
    address constant LINK = 0x514910771AF9Ca656af840dff83E8264EcF986CA;

    // Attacker address
    address attacker = makeAddr("attacker");

    string constant RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";

    function setUp() public {
        // Fork mainnet at recent block
        vm.createSelectFork(RPC_URL);
    }

    /**
     * @notice HYPOTHESIS 1: DolaSavings Precision Loss Accumulation
     * @dev Test if repeated stake/unstake cycles with specific amounts can lead to
     *      permanent reward loss or reward extraction through rounding errors
     */
    function test_DolaSavings_PrecisionExploit() public {
        console.log("=== DolaSavings Precision Loss Analysis ===");

        IDolaSavings ds = IDolaSavings(DOLA_SAVINGS);
        IERC20 dola = IERC20(DOLA);
        IERC20 dbr = IERC20(DBR);

        // Get current state
        uint256 totalSupply = ds.totalSupply();
        uint256 rewardIndex = ds.rewardIndexMantissa();
        uint256 yearlyBudget = ds.yearlyRewardBudget();
        uint256 maxRewardPerDola = ds.maxRewardPerDolaMantissa();
        uint256 lastUpdate = ds.lastUpdate();

        console.log("Total staked DOLA:", totalSupply / 1e18);
        console.log("Reward index mantissa:", rewardIndex);
        console.log("Yearly budget:", yearlyBudget / 1e18);
        console.log("Max reward per DOLA:", maxRewardPerDola);
        console.log("Last update:", lastUpdate);
        console.log("Current time:", block.timestamp);

        // Calculate pending rewards for the system
        uint256 deltaT = block.timestamp - lastUpdate;
        console.log("Time since last update:", deltaT, "seconds");

        if (totalSupply > 0 && yearlyBudget > 0) {
            uint256 maxBudget = maxRewardPerDola * totalSupply / 1e18;
            uint256 effectiveBudget = yearlyBudget > maxBudget ? maxBudget : yearlyBudget;
            uint256 rewardsAccrued = deltaT * effectiveBudget * 1e18 / 365 days;
            uint256 indexDelta = rewardsAccrued / totalSupply;

            console.log("Effective budget:", effectiveBudget / 1e18);
            console.log("Rewards accrued:", rewardsAccrued / 1e18);
            console.log("Index delta:", indexDelta);

            // Check if index delta rounds to zero (precision loss scenario)
            if (indexDelta == 0 && rewardsAccrued > 0) {
                console.log("POTENTIAL VULNERABILITY: Index rounds to 0 but rewards accrued!");
                console.log("Lost rewards per second:", rewardsAccrued / deltaT);
            }
        }

        // Test attack: Large stake to dilute rewards
        uint256 largeAmount = 100_000_000 * 1e18; // 100M DOLA
        deal(DOLA, attacker, largeAmount);

        vm.startPrank(attacker);
        dola.approve(DOLA_SAVINGS, largeAmount);

        // Record state before
        uint256 attackerClaimableBefore = ds.claimable(attacker);

        // Stake large amount
        ds.stake(largeAmount, attacker);

        // Advance time to accumulate rewards
        vm.warp(block.timestamp + 1 days);

        uint256 attackerClaimableAfter = ds.claimable(attacker);
        console.log("Attacker claimable after 1 day:", attackerClaimableAfter / 1e18, "DBR");

        // Calculate expected vs actual
        uint256 attackerShare = largeAmount * 1e18 / (totalSupply + largeAmount);
        console.log("Attacker share of pool:", attackerShare * 100 / 1e18, "%");

        // Unstake and check for any anomalies
        ds.unstake(largeAmount);

        vm.stopPrank();
    }

    /**
     * @notice HYPOTHESIS 2: FraxQueue NFT Redemption Race Condition
     * @dev Test if there's a way to redeem more ETH than deposited through
     *      timing between NFT maturity and ETH availability updates
     */
    function test_FraxQueue_RedemptionInvariant() public {
        console.log("=== FraxQueue Redemption Invariant Analysis ===");

        IFraxRedemptionQueue queue = IFraxRedemptionQueue(FRAX_QUEUE);

        // Get redemption queue state
        (uint64 nextNftId, uint64 queueLengthSecs, uint64 redemptionFee, uint32 earlyExitFee) = queue.redemptionQueueState();
        (uint128 etherLiabilities, uint128 unclaimedFees) = queue.redemptionQueueAccounting();

        console.log("Next NFT ID:", nextNftId);
        console.log("Queue length (seconds):", queueLengthSecs);
        console.log("Redemption fee (bps):", redemptionFee);
        console.log("Early exit fee (bps):", earlyExitFee);
        console.log("Ether liabilities:", etherLiabilities / 1e18, "ETH");
        console.log("Unclaimed fees:", unclaimedFees / 1e18, "ETH");

        // Check contract ETH balance vs liabilities
        uint256 contractBalance = address(FRAX_QUEUE).balance;
        console.log("Contract ETH balance:", contractBalance / 1e18, "ETH");

        // CRITICAL CHECK: Is there a deficit?
        if (contractBalance < etherLiabilities) {
            console.log("POTENTIAL ISSUE: ETH balance < liabilities!");
            console.log("Deficit:", (etherLiabilities - contractBalance) / 1e18, "ETH");
        }

        // Check a sample of NFTs for maturity status
        for (uint256 nftId = 1; nftId < 10 && nftId < nextNftId; nftId++) {
            try queue.nftInformation(nftId) returns (
                bool hasBeenRedeemed,
                uint64 maturity,
                uint64 redemptionTime,
                uint120 amount,
                address recipient
            ) {
                if (!hasBeenRedeemed && maturity <= block.timestamp) {
                    console.log("NFT", nftId, "is mature and unredeemed");
                    console.log("  Amount:", amount / 1e18, "frxETH");
                    console.log("  Maturity:", maturity);
                }
            } catch {
                // NFT doesn't exist or was burned
            }
        }
    }

    /**
     * @notice HYPOTHESIS 3: EthenaMinting Delegated Signer State Confusion
     * @dev Test for edge cases in delegated signer state machine that could
     *      allow unauthorized minting or signature replay
     */
    function test_EthenaMinting_DelegatedSignerAnalysis() public {
        console.log("=== EthenaMinting Delegated Signer Analysis ===");

        IEthenaMinting minting = IEthenaMinting(ETHENA_MINTING);

        address usde = minting.usde();
        console.log("USDe address:", usde);

        // Get global config
        (uint128 globalMaxMint, uint128 globalMaxRedeem) = minting.globalConfig();
        console.log("Global max mint per block:", globalMaxMint / 1e18);
        console.log("Global max redeem per block:", globalMaxRedeem / 1e18);

        uint128 stablesDelta = minting.stablesDeltaLimit();
        console.log("Stables delta limit (bps):", stablesDelta);

        // Check this block's usage
        (uint128 mintedThisBlock, uint128 redeemedThisBlock) = minting.totalPerBlock(block.number);
        console.log("Minted this block:", mintedThisBlock / 1e18);
        console.log("Redeemed this block:", redeemedThisBlock / 1e18);

        // Test delegated signer state transitions
        address testSigner = makeAddr("testSigner");
        address testBenefactor = makeAddr("testBenefactor");

        // Check initial state
        uint8 status = minting.delegatedSigner(testSigner, testBenefactor);
        console.log("Initial delegated signer status:", status);
        // 0 = NONE, 1 = PENDING, 2 = ACCEPTED, 3 = REJECTED
    }

    /**
     * @notice HYPOTHESIS 4: Cross-Protocol Flash Loan Attack
     * @dev Test if flash loaning large amounts can manipulate reward calculations
     *      across multiple protocols in a single transaction
     */
    function test_CrossProtocol_FlashLoanAttack() public {
        console.log("=== Cross-Protocol Flash Loan Analysis ===");

        // Check DOLA balances across different protocols
        IERC20 dola = IERC20(DOLA);

        uint256 dolaTotalSupply = dola.totalSupply();
        uint256 dolaInSavings = dola.balanceOf(DOLA_SAVINGS);

        console.log("DOLA total supply:", dolaTotalSupply / 1e18);
        console.log("DOLA in DolaSavings:", dolaInSavings / 1e18);

        // Calculate what percentage of DOLA supply is in savings
        uint256 savingsShare = dolaInSavings * 100 / dolaTotalSupply;
        console.log("% of DOLA in savings:", savingsShare);

        // Check USDe ecosystem
        IERC20 usde = IERC20(USDE);
        IERC20 susde = IERC20(SUSDE);

        uint256 usdeTotalSupply = usde.totalSupply();
        uint256 usdeInStaking = usde.balanceOf(SUSDE);

        console.log("USDe total supply:", usdeTotalSupply / 1e18);
        console.log("USDe in sUSDe staking:", usdeInStaking / 1e18);

        // sUSDe share ratio
        uint256 susdeSupply = susde.totalSupply();
        if (susdeSupply > 0) {
            uint256 shareRatio = usdeInStaking * 1e18 / susdeSupply;
            console.log("sUSDe share ratio (USDe per sUSDe):", shareRatio / 1e15, "/ 1000");
        }
    }

    /**
     * @notice HYPOTHESIS 5: EthenaLPStaking Epoch Transition Exploit
     * @dev Test if epoch transitions can be exploited to bypass cooldown or stake limits
     */
    function test_EthenaLPStaking_EpochExploit() public {
        console.log("=== EthenaLPStaking Epoch Analysis ===");

        IEthenaLPStaking staking = IEthenaLPStaking(ETHENA_LP_STAKING);

        uint8 currentEpoch = staking.currentEpoch();
        console.log("Current epoch:", currentEpoch);

        // Check some LP token parameters
        address[] memory lpTokens = new address[](3);
        lpTokens[0] = 0x02950460E2b9529D0E00284A5fA2d7bDF3fA4d72; // Example LP
        lpTokens[1] = USDE;
        lpTokens[2] = SUSDE;

        for (uint i = 0; i < lpTokens.length; i++) {
            try staking.stakeParametersByToken(lpTokens[i]) returns (
                uint8 epoch,
                uint248 stakeLimit,
                uint104 totalStaked,
                uint104 totalCoolingDown,
                uint48 cooldown
            ) {
                if (stakeLimit > 0) {
                    console.log("LP Token:", lpTokens[i]);
                    console.log("  Epoch:", epoch);
                    console.log("  Stake limit:", stakeLimit / 1e18);
                    console.log("  Total staked:", totalStaked / 1e18);
                    console.log("  Total cooling down:", totalCoolingDown / 1e18);
                    console.log("  Cooldown:", cooldown, "seconds");
                }
            } catch {}
        }
    }

    /**
     * @notice HYPOTHESIS 6: Chainlink RewardVault Multiplier Manipulation
     * @dev Test if multiplier calculation has edge cases that can be exploited
     */
    function test_ChainlinkRewardVault_MultiplierAnalysis() public {
        console.log("=== Chainlink RewardVault Analysis ===");

        // Check LINK balance in reward vault
        IERC20 link = IERC20(LINK);
        uint256 vaultLinkBalance = link.balanceOf(CHAINLINK_REWARD_VAULT);
        console.log("LINK in RewardVault:", vaultLinkBalance / 1e18);

        // Get vault's total supply info by checking some known stakers
        // This would require knowing actual staker addresses
    }

    /**
     * @notice HYPOTHESIS 7: Time-Weighted Average Price Manipulation
     * @dev Test if there's a way to manipulate time-weighted calculations
     *      by strategic timing of transactions
     */
    function test_TimeWeightedManipulation() public {
        console.log("=== Time-Weighted Manipulation Analysis ===");

        IDolaSavings ds = IDolaSavings(DOLA_SAVINGS);
        IERC20 dola = IERC20(DOLA);

        uint256 totalSupplyBefore = ds.totalSupply();
        uint256 rewardIndexBefore = ds.rewardIndexMantissa();

        // Simulate attacker behavior: stake right before reward distribution
        uint256 stakeAmount = 1_000_000 * 1e18;
        deal(DOLA, attacker, stakeAmount);

        vm.startPrank(attacker);
        dola.approve(DOLA_SAVINGS, stakeAmount);

        // Stake at T=0
        ds.stake(stakeAmount, attacker);

        // Simulate time passing
        uint256[] memory checkpoints = new uint256[](5);
        checkpoints[0] = 1 hours;
        checkpoints[1] = 6 hours;
        checkpoints[2] = 1 days;
        checkpoints[3] = 7 days;
        checkpoints[4] = 30 days;

        for (uint i = 0; i < checkpoints.length; i++) {
            vm.warp(block.timestamp + checkpoints[i]);

            uint256 claimable = ds.claimable(attacker);
            uint256 totalSupplyNow = ds.totalSupply();

            console.log("After", checkpoints[i] / 1 hours, "hours:");
            console.log("  Claimable:", claimable / 1e18, "DBR");
            console.log("  Total supply:", totalSupplyNow / 1e18, "DOLA");

            // Calculate expected rewards
            if (i == 4) { // 30 days
                // Claim and check actual vs expected
                uint256 dbrBalanceBefore = IERC20(DBR).balanceOf(attacker);
                ds.claim(attacker);
                uint256 dbrBalanceAfter = IERC20(DBR).balanceOf(attacker);
                uint256 claimed = dbrBalanceAfter - dbrBalanceBefore;
                console.log("Actually claimed:", claimed / 1e18, "DBR");
            }
        }

        // Unstake
        ds.unstake(stakeAmount);

        vm.stopPrank();
    }

    /**
     * @notice HYPOTHESIS 8: Integer Overflow in Packed Storage
     * @dev Some contracts pack multiple values into single storage slots
     *      Test if there are overflow scenarios in packed arithmetic
     */
    function test_PackedStorage_OverflowAnalysis() public {
        console.log("=== Packed Storage Overflow Analysis ===");

        // EthenaMinting uses packed timestamps and totals
        IEthenaMinting minting = IEthenaMinting(ETHENA_MINTING);

        // Test max values scenario
        // uint128 max is 2^128 - 1 â‰ˆ 3.4e38
        // If mint amounts approach this, could overflow

        (uint128 globalMaxMint, uint128 globalMaxRedeem) = minting.globalConfig();

        console.log("Max uint128:", type(uint128).max);
        console.log("Global max mint:", globalMaxMint);
        console.log("Global max redeem:", globalMaxRedeem);

        // Check if limits are close to max
        if (globalMaxMint > type(uint128).max / 2) {
            console.log("WARNING: Global max mint > half of uint128 max");
        }
    }

    /**
     * @notice Summary function to run all analyses
     */
    function test_RunAllAnalyses() public {
        console.log("\n========================================");
        console.log("     NOVEL EXPLOIT SEARCH SUMMARY");
        console.log("========================================\n");

        test_DolaSavings_PrecisionExploit();
        console.log("\n----------------------------------------\n");

        test_FraxQueue_RedemptionInvariant();
        console.log("\n----------------------------------------\n");

        test_EthenaMinting_DelegatedSignerAnalysis();
        console.log("\n----------------------------------------\n");

        test_CrossProtocol_FlashLoanAttack();
        console.log("\n----------------------------------------\n");

        test_EthenaLPStaking_EpochExploit();
        console.log("\n----------------------------------------\n");

        test_ChainlinkRewardVault_MultiplierAnalysis();
        console.log("\n----------------------------------------\n");

        test_TimeWeightedManipulation();
        console.log("\n----------------------------------------\n");

        test_PackedStorage_OverflowAnalysis();

        console.log("\n========================================");
        console.log("         ANALYSIS COMPLETE");
        console.log("========================================\n");
    }
}
