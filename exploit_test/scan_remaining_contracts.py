#!/usr/bin/env python3
"""
Scan contracts 800-1568 for cross-protocol vulnerabilities.
Focus on: reward distribution timing, semantic mismatches, bridge interactions.
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import time
import json

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        result = resp.json()
        if 'error' in result:
            return None
        return result.get("result", "0x")
    except:
        return None

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def get_code(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getCode",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return resp.json().get("result", "0x")
    except:
        return "0x"

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def analyze_contract_for_vulnerabilities(address, source_code, contract_name):
    """Analyze source code for specific vulnerability patterns"""
    lower = source_code.lower()

    findings = []

    # Cross-protocol patterns
    if 'curve' in lower and ('balancer' in lower or 'aave' in lower or 'compound' in lower):
        findings.append("CROSS_PROTOCOL: Uses multiple DeFi protocols")

    # Reward timing issues
    if 'rewardrate' in lower and 'duration' in lower:
        if 'lastupdatetime' not in lower and 'rewardpetoken' not in lower:
            findings.append("REWARD_TIMING: May have instant reward distribution")

    # Oracle without staleness check
    if 'latestrounddata' in lower or 'latestanswer' in lower:
        if 'updatedat' not in lower and 'stale' not in lower:
            findings.append("ORACLE_STALENESS: Uses oracle without staleness check")

    # Rebasing token handling
    if 'steth' in lower or 'rebas' in lower:
        if 'shares' not in lower and 'wsteth' not in lower:
            findings.append("REBASE_TOKEN: May mishandle rebasing tokens")

    # Bridge patterns
    if 'l2' in lower or 'bridge' in lower or 'messenger' in lower:
        if 'finalize' in lower and 'withdrawal' in lower:
            findings.append("BRIDGE: Has finalization logic")

    # Flash loan callbacks without reentrancy protection
    if ('flashloan' in lower or 'callback' in lower) and 'nonreentrant' not in lower:
        if 'reentrancyguard' not in lower:
            findings.append("FLASHLOAN_CALLBACK: Callback without reentrancy guard")

    # Accounting patterns
    if 'totalsupply' in lower and 'balanceof' in lower:
        if 'shares' in lower and 'assets' in lower:
            # Vault-like contract
            if 'virtual' not in lower and 'dead' not in lower:
                findings.append("VAULT_ACCOUNTING: May have first depositor issue")

    # Permit/signature replay
    if 'permit' in lower or 'ecrecover' in lower:
        if 'nonce' not in lower:
            findings.append("SIGNATURE: May be vulnerable to replay")

    # Delegatecall patterns
    if 'delegatecall' in lower:
        if 'implementation' in lower:
            findings.append("PROXY: Uses delegatecall proxy pattern")

    # Time-based unlocks
    if 'unlock' in lower and ('timestamp' in lower or 'block.number' in lower):
        findings.append("TIME_UNLOCK: Has time-based unlock mechanism")

    # Liquidation mechanics
    if 'liquidat' in lower:
        if 'health' in lower or 'collateral' in lower:
            findings.append("LIQUIDATION: Has liquidation mechanics")

    return findings

def main():
    print("=" * 70)
    print("SCANNING CONTRACTS 800-1568 FOR CROSS-PROTOCOL VULNERABILITIES")
    print("=" * 70)

    # Read contracts
    with open('/home/user/contracs/contracts.txt', 'r') as f:
        all_contracts = [line.strip() for line in f if line.strip().startswith('0x')]

    # Focus on contracts 800-1200 first
    contracts = all_contracts[800:1200]

    high_value_targets = []
    interesting_contracts = []

    print(f"\nAnalyzing {len(contracts)} contracts...")

    for i, address in enumerate(contracts):
        if i % 50 == 0:
            print(f"\nProgress: {i}/{len(contracts)}")

        # Get ETH balance
        eth_bal = get_eth_balance(address)
        eth_value = eth_bal / 1e18

        # Skip low value unless interesting
        if eth_value < 10:
            continue

        # Get source code
        source_data = get_contract_source(address)
        time.sleep(0.25)  # Rate limit

        if not source_data:
            if eth_value > 100:
                high_value_targets.append({
                    'address': address,
                    'eth': eth_value,
                    'verified': False
                })
            continue

        source_code = source_data.get('SourceCode', '')
        contract_name = source_data.get('ContractName', 'Unknown')

        if not source_code:
            continue

        # Analyze for vulnerabilities
        findings = analyze_contract_for_vulnerabilities(address, source_code, contract_name)

        if findings or eth_value > 50:
            interesting_contracts.append({
                'address': address,
                'name': contract_name,
                'eth': eth_value,
                'usd_value': eth_value * 2279,
                'findings': findings
            })
            print(f"\n{contract_name} ({address[:10]}...)")
            print(f"  ETH: {eth_value:.2f} (${eth_value * 2279:,.0f})")
            if findings:
                for f in findings:
                    print(f"  -> {f}")

    # Sort by value
    interesting_contracts.sort(key=lambda x: x['eth'], reverse=True)
    high_value_targets.sort(key=lambda x: x['eth'], reverse=True)

    # Summary
    print("\n" + "=" * 70)
    print("SUMMARY")
    print("=" * 70)

    print(f"\nHigh-value unverified contracts: {len(high_value_targets)}")
    for c in high_value_targets[:10]:
        print(f"  {c['address']}: {c['eth']:.2f} ETH (${c['eth'] * 2279:,.0f})")

    print(f"\nInteresting verified contracts: {len(interesting_contracts)}")
    for c in interesting_contracts[:20]:
        print(f"\n  {c['name']} ({c['address'][:10]}...)")
        print(f"    ETH: {c['eth']:.2f} (${c['usd_value']:,.0f})")
        if c['findings']:
            for f in c['findings']:
                print(f"    - {f}")

    # Save results
    with open('remaining_scan_results.json', 'w') as f:
        json.dump({
            'high_value_unverified': high_value_targets,
            'interesting_verified': interesting_contracts
        }, f, indent=2)

    print("\nResults saved to remaining_scan_results.json")

if __name__ == "__main__":
    main()
