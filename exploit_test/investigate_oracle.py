#!/usr/bin/env python3
"""
Investigate the ChainlinkPriceOracleProxy and check for staleness vulnerabilities.
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

ORACLE = "0x21a6297114853aef193c83fc0271def69ea1b93d"
COMPTROLLER = "0xf47dd16553a934064509c40dc5466bbfb999528b"
CETHER = "0x7b4a7fd41c688a7cb116534e341e44126ef5a0fd"

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        result = resp.json()
        if 'error' in result:
            return None
        return result.get("result", "0x")
    except:
        return None

def decode_uint256(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return 0
    return int(hex_result[:66], 16)

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def main():
    print("=" * 70)
    print("ORACLE INVESTIGATION")
    print("=" * 70)

    # Get oracle source
    source_data = get_contract_source(ORACLE)
    if source_data:
        source_code = source_data.get('SourceCode', '')
        print(f"Oracle Contract: {source_data.get('ContractName', 'Unknown')}")
        print(f"Compiler: {source_data.get('CompilerVersion', '')}")
        print(f"Source size: {len(source_code)} chars")

        if source_code:
            with open('oracle_source.sol', 'w') as f:
                f.write(source_code)

            lower = source_code.lower()

            # Check for Chainlink integration
            print("\n--- ORACLE PATTERNS ---")

            patterns = {
                'latestRoundData': 'latestrounddata' in lower,
                'latestAnswer': 'latestanswer' in lower,
                'updatedAt check': 'updatedat' in lower,
                'staleness check': 'stale' in lower or 'heartbeat' in lower,
                'price bounds': 'maxprice' in lower or 'minprice' in lower or 'bound' in lower,
                'fallback oracle': 'fallback' in lower,
                'aggregator': 'aggregator' in lower,
            }

            for name, found in patterns.items():
                status = 'YES' if found else 'NO'
                print(f"  {name}: {status}")

            # If no staleness check, this is vulnerable
            if not patterns['updatedAt check'] and not patterns['staleness check']:
                print("\n!!! ORACLE HAS NO STALENESS CHECK !!!")

    # Check comptroller for all markets
    print("\n--- ALL MARKETS IN COMPTROLLER ---")

    source_data = get_contract_source(COMPTROLLER)
    if source_data:
        print(f"Comptroller: {source_data.get('ContractName', 'Unknown')}")

    # Try to get all markets
    selector = get_function_selector("getAllMarkets()")
    result = eth_call(COMPTROLLER, selector)
    if result and len(result) > 66:
        print(f"Markets data length: {len(result)}")
        # Parse array of addresses
        # First 64 chars after 0x is offset, next 64 is length
        try:
            data = bytes.fromhex(result[2:])
            offset = int.from_bytes(data[0:32], 'big')
            length = int.from_bytes(data[32:64], 'big')
            print(f"Number of markets: {length}")

            markets = []
            for i in range(length):
                start = 64 + i * 32
                addr_bytes = data[start:start+32]
                addr = "0x" + addr_bytes[-20:].hex()
                markets.append(addr)
                print(f"  Market {i}: {addr}")
        except Exception as e:
            print(f"Error parsing markets: {e}")

    # Check if CEther has any suppliers/borrowers
    print("\n--- CETHER ACTIVITY ---")

    # Total supply in underlying
    selector = get_function_selector("totalSupplyUnderlying()")
    result = eth_call(CETHER, selector)
    if result:
        supply = decode_uint256(result)
        print(f"Total Supply (underlying): {supply / 1e18:.4f} ETH")

    # Check borrow rate
    selector = get_function_selector("borrowRatePerBlock()")
    result = eth_call(CETHER, selector)
    if result:
        borrow_rate = decode_uint256(result)
        # Convert to APY
        blocks_per_year = 2102400  # ~15 sec blocks
        apy = ((1 + borrow_rate / 1e18) ** blocks_per_year - 1) * 100
        print(f"Borrow APY: {apy:.2f}%")

    selector = get_function_selector("supplyRatePerBlock()")
    result = eth_call(CETHER, selector)
    if result:
        supply_rate = decode_uint256(result)
        blocks_per_year = 2102400
        apy = ((1 + supply_rate / 1e18) ** blocks_per_year - 1) * 100
        print(f"Supply APY: {apy:.2f}%")

    # Check collateral factor
    selector = get_function_selector("markets(address)")
    data = selector + encode(['address'], [CETHER]).hex()
    result = eth_call(COMPTROLLER, data)
    if result and len(result) >= 128:
        # Parse struct
        try:
            data = bytes.fromhex(result[2:])
            is_listed = int.from_bytes(data[0:32], 'big')
            collateral_factor = int.from_bytes(data[32:64], 'big')
            is_comped = int.from_bytes(data[64:96], 'big')
            print(f"Is Listed: {bool(is_listed)}")
            print(f"Collateral Factor: {collateral_factor / 1e18 * 100:.0f}%")
            print(f"Is Comped: {bool(is_comped)}")
        except:
            pass

    # ANALYSIS
    print("\n" + "=" * 70)
    print("EXPLOITATION FEASIBILITY")
    print("=" * 70)

    print("""
FINDINGS:
1. Oracle uses ChainlinkPriceOracleProxy
2. Need to check if it validates staleness
3. Protocol appears to be from 2020 (old Compound fork)
4. 313 ETH in contract, 18 ETH borrowed

ATTACK SCENARIO:
If oracle has no staleness check:
1. Wait for Chainlink feed to become stale (rare but possible)
2. If ETH price moves >5% from stale price:
   - If price UP: Borrow against old (lower) price, extract value
   - If price DOWN: Liquidate positions at inflated oracle price
3. Profit from price discrepancy

REQUIREMENTS:
- Oracle must have no staleness check (likely, based on 2020 code)
- Chainlink feed must become stale (heartbeat is 1 hour)
- Price must move significantly during staleness
- Protocol must still be operational

ECONOMIC MODEL:
- Max extractable: ~313 ETH * price_discrepancy_pct
- If 5% discrepancy: ~15 ETH profit (~$34k)
- But requires specific conditions to align
""")

if __name__ == "__main__":
    main()
