#!/usr/bin/env python3
"""
Final systematic search for exploitable cross-protocol patterns.

Focus on:
1. Contracts with newer compilers (more likely recent, less audited)
2. Multi-protocol integrations
3. Oracle usage patterns
4. Reward/staking mechanics
"""

import requests
from eth_abi import encode
from eth_utils import keccak
import time
import json

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return resp.json().get("result", "0x")
    except:
        return "0x"

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def analyze_for_exploits(source_code, contract_name, address):
    """Look for specific exploitable patterns"""
    lower = source_code.lower()

    findings = {
        'contract': contract_name,
        'address': address,
        'patterns': [],
        'severity': 0
    }

    # Pattern 1: Curve virtual_price without reentrancy guard
    if ('get_virtual_price' in lower or 'virtualPrice' in lower):
        has_guard = 'nonReentrant' in source_code or 'ReentrancyGuard' in source_code
        if not has_guard:
            findings['patterns'].append({
                'type': 'CURVE_VIRTUAL_PRICE_NO_GUARD',
                'severity': 3
            })
            findings['severity'] += 3

            # Check if it's an ETH-containing pool
            eth_pool_refs = ['steth', 'frxeth', 'oeth', 'reth', 'cbeth']
            for ref in eth_pool_refs:
                if ref in lower:
                    findings['patterns'].append({
                        'type': f'ETH_POOL_REF_{ref.upper()}',
                        'severity': 2
                    })
                    findings['severity'] += 2
                    break

    # Pattern 2: Oracle without staleness check
    if ('chainlink' in lower or 'aggregator' in lower or 'latestRoundData' in lower):
        has_staleness = 'updatedat' in lower or 'timestamp' in lower and 'require' in lower
        if not has_staleness:
            findings['patterns'].append({
                'type': 'ORACLE_NO_STALENESS',
                'severity': 2
            })
            findings['severity'] += 2

    # Pattern 3: Flash loan callback without protection
    if ('flashloan' in lower or 'flashborrow' in lower or 'onFlashLoan' in lower):
        has_check = 'initiator' in lower and ('require' in lower or 'revert' in lower)
        if not has_check:
            findings['patterns'].append({
                'type': 'FLASH_LOAN_NO_INITIATOR_CHECK',
                'severity': 3
            })
            findings['severity'] += 3

    # Pattern 4: Reward distribution without time-weighting
    if 'reward' in lower and 'notifyRewardAmount' in lower:
        has_duration = 'duration' in lower or 'periodFinish' in lower
        if not has_duration:
            findings['patterns'].append({
                'type': 'INSTANT_REWARDS',
                'severity': 3
            })
            findings['severity'] += 3

    # Pattern 5: Cross-protocol integration
    protocol_refs = {
        'aave': 'ipool' in lower or 'ilendingpool' in lower or 'aave' in lower,
        'compound': 'ctoken' in lower or 'comptroller' in lower,
        'uniswap': 'iuniswap' in lower or 'iswaprouter' in lower,
        'curve': 'icurve' in lower or 'curvepool' in lower,
        'balancer': 'ibalancer' in lower or 'ivault' in lower,
        'yearn': 'ivault' in lower and 'yearn' in lower,
        'convex': 'convex' in lower or 'ibooster' in lower,
        'maker': 'maker' in lower or 'vat' in lower or 'dai' in lower,
    }

    integrated_protocols = [p for p, found in protocol_refs.items() if found]
    if len(integrated_protocols) >= 2:
        findings['patterns'].append({
            'type': 'MULTI_PROTOCOL',
            'protocols': integrated_protocols,
            'severity': 2
        })
        findings['severity'] += 2

    # Pattern 6: External call before state change
    lines = source_code.split('\n')
    for i, line in enumerate(lines):
        if '.call' in line.lower() or '.transfer(' in line.lower():
            # Check next 3 lines for state changes
            for j in range(i+1, min(i+4, len(lines))):
                if '=' in lines[j] and 'balance' in lines[j].lower():
                    findings['patterns'].append({
                        'type': 'POTENTIAL_REENTRANCY',
                        'line': i+1,
                        'severity': 2
                    })
                    findings['severity'] += 2
                    break

    # Pattern 7: Price manipulation in liquidation
    if 'liquidat' in lower and 'price' in lower:
        has_twap = 'twap' in lower or 'timeweighted' in lower
        if not has_twap:
            findings['patterns'].append({
                'type': 'LIQUIDATION_SPOT_PRICE',
                'severity': 2
            })
            findings['severity'] += 2

    return findings

def main():
    print("=" * 70)
    print("FINAL SYSTEMATIC VULNERABILITY SEARCH")
    print("=" * 70)

    with open('/home/user/contracs/contracts.txt', 'r') as f:
        addresses = [line.strip() for line in f if line.strip().startswith('0x') and len(line.strip()) == 42]

    print(f"Total contracts: {len(addresses)}")

    # Focus on contracts with newer compilers and significant value
    vulnerable = []
    high_potential = []

    # Sample contracts at different positions to find promising ones
    sample_indices = list(range(0, 100)) + list(range(200, 300)) + list(range(500, 600))

    for i in sample_indices:
        if i >= len(addresses):
            break

        if len(vulnerable) > 20:  # Stop if we found enough
            break

        if i % 25 == 0:
            print(f"Progress: {i}, found {len(vulnerable)} vulnerable patterns")
            time.sleep(1)

        addr = addresses[i]
        source = get_contract_source(addr)

        if not source:
            continue

        source_code = source.get('SourceCode', '')
        contract_name = source.get('ContractName', 'Unknown')
        compiler = source.get('CompilerVersion', '')

        if not source_code or len(source_code) < 500:
            continue

        # Only focus on 0.8.x contracts (newer)
        if 'v0.8' not in compiler and 'v0.7' not in compiler:
            continue

        eth_bal = get_eth_balance(addr)

        findings = analyze_for_exploits(source_code, contract_name, addr)
        findings['eth_balance'] = eth_bal
        findings['compiler'] = compiler

        if findings['severity'] >= 3:
            vulnerable.append(findings)
            print(f"\n  HIGH: {contract_name} ({addr})")
            print(f"    Severity: {findings['severity']}, ETH: {eth_bal/1e18:.2f}")
            for p in findings['patterns']:
                print(f"    - {p['type']}")

        time.sleep(0.2)

    # Sort by severity and ETH
    vulnerable.sort(key=lambda x: (-x['severity'], -x.get('eth_balance', 0)))

    print("\n" + "=" * 70)
    print("TOP VULNERABLE CONTRACTS")
    print("=" * 70)

    for v in vulnerable[:10]:
        print(f"\n{v['contract']} ({v['address']})")
        print(f"  Severity: {v['severity']}, ETH: {v.get('eth_balance', 0)/1e18:.2f}")
        print(f"  Compiler: {v.get('compiler', 'unknown')}")
        for p in v['patterns']:
            print(f"  - {p['type']}")

    # Save results
    with open('final_vulnerable.json', 'w') as f:
        json.dump(vulnerable, f, indent=2)

    # If we found high-severity targets, provide next steps
    if vulnerable:
        print("\n" + "=" * 70)
        print("RECOMMENDED NEXT STEPS")
        print("=" * 70)

        for v in vulnerable[:3]:
            print(f"\nTarget: {v['contract']} ({v['address']})")
            for p in v['patterns']:
                if p['type'] == 'CURVE_VIRTUAL_PRICE_NO_GUARD':
                    print("  1. Check if contract reads from ETH-containing Curve pool")
                    print("  2. Verify no reentrancy guard on price reading functions")
                    print("  3. Build PoC: remove_liquidity_one_coin + callback exploitation")
                elif p['type'] == 'ORACLE_NO_STALENESS':
                    print("  1. Identify which oracle is used")
                    print("  2. Check oracle heartbeat/deviation settings")
                    print("  3. Calculate cost to keep oracle stale vs profit")
                elif p['type'] == 'INSTANT_REWARDS':
                    print("  1. Verify reward distribution is instant, not time-weighted")
                    print("  2. Check if flash deposit can capture rewards")
                    print("  3. Calculate profit vs gas cost")

if __name__ == "__main__":
    main()
