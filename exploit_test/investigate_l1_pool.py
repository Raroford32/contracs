#!/usr/bin/env python3
"""
Investigate Proxy__L1LiquidityPoolArguments for L1<->L2 bridge vulnerabilities.
This contract has 113.92 ETH and may have cross-chain exploit potential.
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import time

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

L1_POOL = "0x1a26ef6575b7bbb864d984d9255c069f6c361a14"

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        result = resp.json()
        if 'error' in result:
            return None
        return result.get("result", "0x")
    except:
        return None

def get_storage_at(address, slot):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getStorageAt",
        "params": [address, hex(slot), "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return resp.json().get("result", "0x")
    except:
        return "0x"

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def decode_address(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return None
    return "0x" + hex_result[-40:]

def decode_uint256(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return 0
    return int(hex_result[:66], 16)

def main():
    print("=" * 70)
    print("L1 LIQUIDITY POOL PROXY INVESTIGATION")
    print("=" * 70)

    address = L1_POOL
    print(f"\nAddress: {address}")

    # Get balance
    eth_bal = get_eth_balance(address)
    print(f"ETH Balance: {eth_bal / 1e18:.4f} ETH (${eth_bal / 1e18 * 2279:,.0f})")

    # Get source
    source_data = get_contract_source(address)
    if not source_data:
        print("No verified source on Etherscan")
    else:
        source_code = source_data.get('SourceCode', '')
        contract_name = source_data.get('ContractName', 'Unknown')
        print(f"Contract: {contract_name}")
        print(f"Compiler: {source_data.get('CompilerVersion', '')}")

        if source_code:
            with open('l1_pool_source.sol', 'w') as f:
                f.write(source_code)
            print("Source saved to l1_pool_source.sol")

            lower = source_code.lower()

            print("\n--- BRIDGE PATTERNS ---")

            patterns = {
                'L2 messaging': 'l2' in lower or 'layer2' in lower,
                'Cross domain': 'crossdomain' in lower,
                'Message relay': 'relay' in lower and 'message' in lower,
                'Finalize withdrawal': 'finalize' in lower and 'withdraw' in lower,
                'Optimism': 'optimism' in lower or 'ovm' in lower,
                'Arbitrum': 'arbitrum' in lower,
                'Boba Network': 'boba' in lower,
                'L1 to L2': 'l1tol2' in lower or 'depositto' in lower,
                'L2 to L1': 'l2tol1' in lower or 'withdrawfrom' in lower,
            }

            for p_name, found in patterns.items():
                print(f"  {p_name}: {'YES' if found else 'NO'}")

            # Check for liquidity pool patterns
            print("\n--- LIQUIDITY POOL PATTERNS ---")

            lp_patterns = {
                'Add liquidity': 'addliquidity' in lower,
                'Remove liquidity': 'removeliquidity' in lower,
                'Client deposit': 'clientdeposit' in lower,
                'Client payment': 'clientpayment' in lower,
                'Owner withdrawal': 'ownerwithdraw' in lower,
                'Balance check': 'balanceof' in lower,
                'Minimum liquidity': 'minimumliquidity' in lower,
                'Pool ratio': 'ratio' in lower,
            }

            for p_name, found in lp_patterns.items():
                print(f"  {p_name}: {'YES' if found else 'NO'}")

    # Check proxy storage slots
    print("\n--- PROXY STORAGE ---")

    # EIP-1967 implementation slot
    IMPL_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc
    impl_addr = get_storage_at(address, IMPL_SLOT)
    if impl_addr != "0x" + "0" * 64:
        impl = "0x" + impl_addr[-40:]
        print(f"Implementation (EIP-1967): {impl}")

        # Get implementation source
        impl_source = get_contract_source(impl)
        if impl_source:
            print(f"Implementation name: {impl_source.get('ContractName', 'Unknown')}")
            impl_code = impl_source.get('SourceCode', '')
            if impl_code:
                with open('l1_pool_impl_source.sol', 'w') as f:
                    f.write(impl_code)
                print("Implementation source saved")

    # Admin slot
    ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103
    admin_addr = get_storage_at(address, ADMIN_SLOT)
    if admin_addr != "0x" + "0" * 64:
        admin = "0x" + admin_addr[-40:]
        print(f"Admin (EIP-1967): {admin}")

    # Try common proxy selectors
    print("\n--- PROXY FUNCTIONS ---")

    functions_to_try = [
        ("owner()", "owner"),
        ("admin()", "admin"),
        ("implementation()", "implementation"),
        ("l2Pool()", "l2Pool"),
        ("l1Messenger()", "l1Messenger"),
        ("poolFee()", "poolFee"),
        ("paused()", "paused"),
    ]

    for sig, desc in functions_to_try:
        selector = get_function_selector(sig)
        result = eth_call(address, selector)
        if result and result != "0x" and len(result) > 10:
            if any(x in sig.lower() for x in ['address', 'owner', 'admin', 'pool', 'messenger']):
                addr = decode_address(result)
                if addr and addr != "0x" + "0" * 40:
                    print(f"  {desc}: {addr}")
            else:
                value = decode_uint256(result)
                print(f"  {desc}: {value}")

    print("\n--- VULNERABILITY ANALYSIS ---")
    print("""
L1<->L2 bridge vulnerabilities to check:
1. Message replay (cross-domain message without nonce)
2. Withdrawal finalization without proof
3. Liquidity ratio manipulation
4. Oracle discrepancy between L1 and L2
5. Race condition on liquidity removal

For Boba Network (if this is Boba):
- Check if message verification is complete
- Check for timing windows during L2 sequencer downtime
- Check for ratio manipulation attacks
""")

    # Check what L2 this connects to
    print("\n--- IDENTIFYING L2 NETWORK ---")

    # Try Boba-specific calls
    boba_selectors = [
        ("poolTokens()", "poolTokens"),
        ("ownerRewardFeeRate()", "ownerRewardFeeRate"),
        ("userRewardFeeRate()", "userRewardFeeRate"),
    ]

    for sig, desc in boba_selectors:
        selector = get_function_selector(sig)
        result = eth_call(address, selector)
        if result and result != "0x" and len(result) > 10:
            value = decode_uint256(result)
            print(f"  {desc}: {value}")

    print("\n" + "=" * 70)
    print("CONCLUSION")
    print("=" * 70)
    print("""
L1 Liquidity Pool proxies are typically well-audited.
For exploitation to be viable:
1. Must find message validation bypass
2. Or find ratio manipulation via flash loan
3. Or find withdrawal without proper L2 proof

This likely requires L2 interaction which is out of scope for L1-only attacks.
""")

if __name__ == "__main__":
    main()
