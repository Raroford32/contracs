#!/usr/bin/env python3
"""
Investigate IDOLvsETHBoxExchange - 82.77 ETH with spot price usage
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

TARGET = "0x767696e13ff990d09954c7a36a49e2c4a1c804bd"

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        result = resp.json()
        if 'error' in result:
            return None
        return result.get("result", "0x")
    except:
        return None

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def decode_address(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return None
    return "0x" + hex_result[-40:]

def decode_uint256(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return 0
    return int(hex_result[:66], 16)

def main():
    print("=" * 70)
    print("IDOLvsETHBoxExchange INVESTIGATION")
    print("=" * 70)

    address = TARGET
    print(f"\nAddress: {address}")

    # Get balance
    eth_bal = get_eth_balance(address)
    print(f"\n*** ETH Balance: {eth_bal / 1e18:.4f} ETH (${eth_bal / 1e18 * 2279:,.0f}) ***")

    # Get source
    source_data = get_contract_source(address)
    if not source_data:
        print("No verified source!")
        return

    source_code = source_data.get('SourceCode', '')
    contract_name = source_data.get('ContractName', 'Unknown')
    compiler = source_data.get('CompilerVersion', '')
    print(f"\nContract: {contract_name}")
    print(f"Compiler: {compiler}")

    if not source_code:
        print("Empty source")
        return

    # Save source
    with open('idol_exchange_source.sol', 'w') as f:
        f.write(source_code)
    print(f"Source saved ({len(source_code)} chars)")

    lower = source_code.lower()

    # Key patterns
    print("\n--- KEY PATTERNS ---")

    patterns = {
        'ReentrancyGuard': 'reentrancyguard' in lower or 'nonreentrant' in lower,
        'getReserves actual call': '_getreserves()' in lower,
        'reserve0/reserve1': 'reserve0' in lower and 'reserve1' in lower,
        'TWAP': 'twap' in lower or 'timeaverage' in lower,
        'withdraw': 'withdraw' in lower,
        'swap': 'swap' in lower,
        'exchange': 'exchange' in lower,
    }

    for name, found in patterns.items():
        print(f"  {name}: {'YES' if found else 'NO'}")

    # Find the _getReserves function and how it's used
    print("\n--- _getReserves USAGE ---")

    lines = source_code.split('\n')
    for i, line in enumerate(lines):
        if '_getreserves' in line.lower():
            print(f"\n  Line {i}:")
            for j in range(max(0, i-3), min(len(lines), i+5)):
                print(f"    {j}: {lines[j][:100]}")

    # Find functions that use reserves for calculations
    print("\n--- PRICE CALCULATIONS ---")

    for i, line in enumerate(lines):
        if 'reserve' in line.lower() and ('/' in line or '*' in line or 'div' in line.lower() or 'mul' in line.lower()):
            print(f"  {i}: {line.strip()[:100]}")

    # Query contract state
    print("\n--- CONTRACT STATE ---")

    selectors = [
        ("getReserves()", "getReserves"),
        ("token0()", "token0"),
        ("token1()", "token1"),
        ("totalSupply()", "totalSupply"),
        ("owner()", "owner"),
        ("factory()", "factory"),
        ("getSpotPrice()", "getSpotPrice"),
    ]

    for sig, desc in selectors:
        selector = get_function_selector(sig)
        result = eth_call(address, selector)
        if result and result != "0x" and len(result) > 10:
            if 'token' in sig.lower() or 'owner' in sig.lower() or 'factory' in sig.lower():
                addr = decode_address(result)
                if addr:
                    print(f"  {desc}: {addr}")
            else:
                value = decode_uint256(result)
                print(f"  {desc}: {value}")

    # Find value extraction functions
    print("\n--- VALUE EXTRACTION FUNCTIONS ---")

    for i, line in enumerate(lines):
        if any(x in line.lower() for x in ['function exchange', 'function swap', 'function withdraw', 'function redeem']):
            print(f"\n  Line {i}: {line.strip()[:80]}")
            for j in range(i+1, min(len(lines), i+20)):
                print(f"    {j}: {lines[j][:100]}")
                if lines[j].strip().startswith('}'):
                    break

    print("\n" + "=" * 70)
    print("ECONOMIC ANALYSIS")
    print("=" * 70)
    print(f"""
Contract ETH balance: {eth_bal / 1e18:.2f} ETH (${eth_bal / 1e18 * 2279:,.0f})

If spot price manipulation is possible:
1. Flash loan to manipulate reserves
2. Exchange at manipulated price
3. Extract extra ETH
4. Repay flash loan

For 10% price manipulation:
- Potential profit: ~8 ETH (~$18K)
- Flash loan fees: ~$1-2K
- Net potential: ~$16K
""")

if __name__ == "__main__":
    main()
