#!/usr/bin/env python3
"""
Investigate The DAO (0xbb9bc244...) - the famous 2016 hack target.
Still has 57.84 ETH locked. Check if there's any way to extract.
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

THE_DAO = "0xbb9bc244d798123fde783fcc1c72d3bb8c189413"

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        result = resp.json()
        if 'error' in result:
            return None
        return result.get("result", "0x")
    except:
        return None

def get_storage_at(address, slot):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getStorageAt",
        "params": [address, hex(slot), "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return resp.json().get("result", "0x")
    except:
        return "0x"

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def get_code(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getCode",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return resp.json().get("result", "0x")
    except:
        return "0x"

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def decode_uint256(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return 0
    return int(hex_result[:66], 16)

def main():
    print("=" * 70)
    print("THE DAO INVESTIGATION")
    print("=" * 70)

    address = THE_DAO
    print(f"\nAddress: {address}")

    # Get balance
    eth_bal = get_eth_balance(address)
    print(f"ETH Balance: {eth_bal / 1e18:.4f} ETH (${eth_bal / 1e18 * 2279:,.0f})")

    # Get code size
    code = get_code(address)
    print(f"Code size: {len(code) // 2 - 1} bytes")

    # Get source
    source_data = get_contract_source(address)
    if source_data:
        print(f"Contract Name: {source_data.get('ContractName', 'Unknown')}")
        print(f"Compiler: {source_data.get('CompilerVersion', '')}")

    # Check DAO state
    print("\n--- DAO STATE ---")

    selectors = [
        ("totalSupply()", "totalSupply"),
        ("proposalDeposit()", "proposalDeposit"),
        ("lastTimeMinQuorumMet()", "lastTimeMinQuorumMet"),
        ("minQuorumDivisor()", "minQuorumDivisor"),
        ("closingTime()", "closingTime"),
        ("curator()", "curator"),
        ("daoCreator()", "daoCreator"),
        ("numberOfProposals()", "numberOfProposals"),
        ("extraBalance()", "extraBalance"),
    ]

    for sig, desc in selectors:
        selector = get_function_selector(sig)
        result = eth_call(address, selector)
        if result and result != "0x":
            value = decode_uint256(result)
            if 'address' in sig.lower() or 'curator' in sig.lower() or 'creator' in sig.lower():
                print(f"  {desc}: 0x{result[-40:]}")
            elif 'time' in sig.lower():
                print(f"  {desc}: {value} (timestamp)")
            else:
                print(f"  {desc}: {value}")

    # Check storage slots
    print("\n--- STORAGE SLOTS ---")
    for slot in range(10):
        value = get_storage_at(address, slot)
        if value and value != "0x" + "0" * 64:
            print(f"  Slot {slot}: {value}")

    # Check if withdrawal is possible
    print("\n--- WITHDRAWAL ANALYSIS ---")

    # The DAO's withdraw function
    # function withdraw(address _account) returns (bool success);
    selector = get_function_selector("withdraw(address)")
    test_addr = "0x0000000000000000000000000000000000000001"
    data = selector + encode(['address'], [test_addr]).hex()
    result = eth_call(address, data)
    print(f"withdraw() call result: {result}")

    # The DAO's retrieveDAOReward function
    selector = get_function_selector("retrieveDAOReward(bool)")
    data = selector + encode(['bool'], [True]).hex()
    result = eth_call(address, data)
    print(f"retrieveDAOReward() call result: {result}")

    print("\n" + "=" * 70)
    print("CONCLUSION")
    print("=" * 70)
    print("""
The DAO was the target of the famous June 2016 hack that led to the
Ethereum hard fork. The contract at this address is the original DAO.

Historical context:
1. The hack exploited reentrancy in splitDAO function
2. Ethereum hard forked to reverse the hack (ETH vs ETC split)
3. On ETH chain, the hack was reversed
4. Remaining funds are likely from:
   - Unclaimed DAO token refunds
   - Child DAO balances
   - Orphaned funds from complex DAO mechanics

The DAO has been in "post-fork" state since 2016:
- proposalDeposit is set high to prevent new proposals
- Most governance is locked
- Remaining ETH is effectively frozen unless:
  1. You hold DAO tokens from before the fork
  2. You have unclaimed refund rights

NOT EXPLOITABLE: This is historical frozen funds, not a vulnerability.
""")

if __name__ == "__main__":
    main()
