#!/usr/bin/env python3
"""
Deep manual analysis of specific contracts.
Focus on finding real cross-protocol semantic mismatches.
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import time
import json

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return resp.json().get("result", "0x")
    except:
        return "0x"

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def decode_uint256(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return 0
    return int(hex_result[:66], 16)

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def deep_analyze_contract(address, name="Unknown"):
    """Deep manual analysis of a single contract"""
    print(f"\n{'=' * 70}")
    print(f"DEEP ANALYSIS: {name}")
    print(f"Address: {address}")
    print("=" * 70)

    # Get balance
    eth_bal = get_eth_balance(address)
    print(f"ETH Balance: {eth_bal / 1e18:.4f} ETH (${eth_bal / 1e18 * 2279:,.0f})")

    # Get source
    source_data = get_contract_source(address)
    if not source_data:
        print("No verified source code")
        return None

    source_code = source_data.get('SourceCode', '')
    contract_name = source_data.get('ContractName', 'Unknown')
    compiler = source_data.get('CompilerVersion', '')

    if not source_code:
        print("Empty source code")
        return None

    print(f"Contract: {contract_name}")
    print(f"Compiler: {compiler}")
    print(f"Source size: {len(source_code)} chars")

    lower = source_code.lower()

    # Detailed analysis
    analysis = {
        'address': address,
        'name': contract_name,
        'eth_balance': eth_bal,
        'compiler': compiler,
        'vulnerabilities': []
    }

    # Check for specific vulnerability patterns
    print("\n--- VULNERABILITY PATTERNS ---")

    # 1. Oracle usage patterns
    if 'oracle' in lower or 'getprice' in lower or 'latestRoundData' in lower:
        print("Uses oracles")

        # Check for staleness
        has_staleness = any(x in lower for x in ['updatedat', 'staleness', 'heartbeat', 'timestamp'])
        if not has_staleness:
            print("  !!! NO STALENESS CHECK !!!")
            analysis['vulnerabilities'].append('ORACLE_NO_STALENESS')

        # Check for price deviation
        has_deviation = 'deviation' in lower or 'delta' in lower
        if not has_deviation:
            print("  No price deviation check")

    # 2. Flash loan handling
    if 'flashloan' in lower or 'onFlashLoan' in lower:
        print("Has flash loan functionality")

        has_initiator_check = 'initiator' in lower and 'require' in lower
        if not has_initiator_check:
            print("  !!! NO INITIATOR CHECK !!!")
            analysis['vulnerabilities'].append('FLASH_LOAN_NO_INITIATOR')

    # 3. Token handling for rebasing/fee-on-transfer
    if 'transfer' in lower:
        uses_balance_diff = 'balanceof' in lower and 'before' in lower and 'after' in lower
        if not uses_balance_diff and ('steth' in lower or 'rebase' in lower):
            print("  !!! May not handle rebasing tokens correctly !!!")
            analysis['vulnerabilities'].append('REBASE_NOT_HANDLED')

    # 4. Governance without snapshots
    if 'vote' in lower or 'propose' in lower:
        print("Has governance")

        has_snapshot = 'snapshot' in lower or 'checkpoint' in lower or 'getPriorVotes' in lower
        if not has_snapshot:
            print("  !!! NO SNAPSHOT VOTING !!!")
            analysis['vulnerabilities'].append('GOVERNANCE_NO_SNAPSHOT')

    # 5. Liquidation mechanics
    if 'liquidat' in lower:
        print("Has liquidation")

        # Check if uses spot price
        uses_twap = 'twap' in lower or 'time-weighted' in lower
        if not uses_twap:
            print("  Uses spot price for liquidation")

            # Check if oracle can be manipulated
            uses_uniswap = 'uniswap' in lower and 'getAmountsOut' in lower
            if uses_uniswap:
                print("  !!! USES MANIPULABLE UNISWAP PRICE !!!")
                analysis['vulnerabilities'].append('LIQUIDATION_SPOT_PRICE')

    # 6. Reentrancy in specific patterns
    if 'withdraw' in lower or 'redeem' in lower:
        has_guard = 'nonReentrant' in source_code or 'ReentrancyGuard' in source_code
        has_cei = False  # Check if CEI pattern

        # Look for external calls before state changes
        lines = source_code.split('\n')
        in_function = False
        state_after_call = False

        for i, line in enumerate(lines):
            if 'function withdraw' in line.lower() or 'function redeem' in line.lower():
                in_function = True
            if in_function:
                if '.call' in line.lower() or '.transfer(' in line.lower():
                    for j in range(i+1, min(i+5, len(lines))):
                        if '=' in lines[j] and ('balance' in lines[j].lower() or 'amount' in lines[j].lower()):
                            state_after_call = True
                            break
                if '}' in line:
                    in_function = False

        if state_after_call and not has_guard:
            print("  !!! STATE CHANGE AFTER EXTERNAL CALL !!!")
            analysis['vulnerabilities'].append('REENTRANCY_RISK')

    # 7. Cross-protocol integration risks
    protocols_integrated = []
    protocol_patterns = {
        'aave': ['ipool', 'ilendingpool', 'aave'],
        'compound': ['ctoken', 'comptroller', 'compound'],
        'uniswap': ['iuniswap', 'iswaprouter', 'uniswapv2', 'uniswapv3'],
        'curve': ['icurve', 'curvepool', 'curve'],
        'balancer': ['ibalancer', 'ivault', 'balancer'],
        'maker': ['vat', 'cdpmanager', 'maker', 'dai'],
        'yearn': ['ivault', 'strategy', 'yearn'],
        'convex': ['ibooster', 'convex', 'cvx'],
        'lido': ['steth', 'wsteth', 'lido'],
    }

    for protocol, patterns in protocol_patterns.items():
        if any(p in lower for p in patterns):
            protocols_integrated.append(protocol)

    if len(protocols_integrated) >= 2:
        print(f"Integrates with multiple protocols: {protocols_integrated}")
        analysis['protocols'] = protocols_integrated

        # Specific cross-protocol risks
        if 'curve' in protocols_integrated and 'lido' in protocols_integrated:
            print("  Risk: Curve+Lido read-only reentrancy")
        if 'aave' in protocols_integrated and 'maker' in protocols_integrated:
            print("  Risk: Different collateral valuation")

    # 8. Privileged function access
    if 'onlyOwner' in source_code or 'onlyAdmin' in source_code:
        # Check if owner can rug
        if 'setFee' in lower and 'withdraw' in lower:
            print("  Owner can set fees and withdraw - potential rug")

    # Summary
    if analysis['vulnerabilities']:
        print(f"\n!!! FOUND {len(analysis['vulnerabilities'])} POTENTIAL VULNERABILITIES !!!")
        for v in analysis['vulnerabilities']:
            print(f"  - {v}")
    else:
        print("\nNo obvious vulnerabilities found")

    return analysis

def main():
    print("=" * 70)
    print("DEEP MANUAL CONTRACT ANALYSIS")
    print("=" * 70)

    # Load contracts
    with open('/home/user/contracs/contracts.txt', 'r') as f:
        addresses = [line.strip() for line in f if line.strip().startswith('0x') and len(line.strip()) == 42]

    print(f"Total contracts: {len(addresses)}")

    # Focus on range 500-800 (unexplored)
    vulnerable_contracts = []

    for i in range(500, 800):
        if i >= len(addresses):
            break

        if i % 50 == 0:
            print(f"\n--- Progress: {i}/800 ---")
            time.sleep(2)

        addr = addresses[i]
        analysis = deep_analyze_contract(addr)

        if analysis and analysis.get('vulnerabilities'):
            vulnerable_contracts.append(analysis)

            # If we found something interesting with good TVL, print it
            if analysis['eth_balance'] > 10**17:  # > 0.1 ETH
                print(f"\n*** HIGH PRIORITY: {analysis['name']} ({addr}) ***")
                print(f"ETH: {analysis['eth_balance'] / 1e18:.4f}")
                print(f"Vulns: {analysis['vulnerabilities']}")

        time.sleep(0.3)

    # Save results
    with open('deep_analysis_results.json', 'w') as f:
        json.dump(vulnerable_contracts, f, indent=2)

    print("\n" + "=" * 70)
    print(f"FOUND {len(vulnerable_contracts)} CONTRACTS WITH VULNERABILITIES")
    print("=" * 70)

    for v in vulnerable_contracts:
        if v['eth_balance'] > 10**16:
            print(f"\n{v['name']} ({v['address']})")
            print(f"  ETH: {v['eth_balance'] / 1e18:.4f}")
            print(f"  Vulns: {v['vulnerabilities']}")

if __name__ == "__main__":
    main()
