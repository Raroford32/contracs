#!/usr/bin/env python3
"""
Analyze stETH rebasing across different protocols for semantic mismatches.

stETH is a rebasing token - balances automatically increase as staking rewards accrue.
Some protocols don't handle this correctly, leading to:
1. Accounting errors (balance changes between transactions)
2. Share calculation errors
3. Liquidation threshold miscalculations

Looking for protocols that:
1. Use stETH as collateral without wrapping (wstETH)
2. Cache stETH balances across transactions
3. Calculate shares incorrectly for rebasing tokens
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import time

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

# Key stETH-related addresses
STETH = "0xae7ab96520de3a18e5e111b5eaab095312d7fe84"
WSTETH = "0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0"
CURVE_STETH_POOL = "0xdc24316b9ae028f1497c275eb9192a3ea0f67022"

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return resp.json().get("result", "0x")
    except:
        return "0x"

def decode_uint256(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return 0
    return int(hex_result[:66], 16)

def format_ether(wei):
    return f"{wei / 1e18:.6f}"

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def main():
    print("=" * 70)
    print("stETH SEMANTIC MISMATCH ANALYSIS")
    print("=" * 70)

    # Get current stETH state
    print("\n--- stETH CURRENT STATE ---")

    # Get total supply
    selector = get_function_selector("totalSupply()")
    result = eth_call(STETH, selector)
    steth_supply = decode_uint256(result)
    print(f"stETH Total Supply: {format_ether(steth_supply)}")

    # Get total shares
    selector = get_function_selector("getTotalShares()")
    result = eth_call(STETH, selector)
    total_shares = decode_uint256(result)
    print(f"stETH Total Shares: {format_ether(total_shares)}")

    # Calculate share ratio
    if total_shares > 0:
        share_ratio = steth_supply / total_shares
        print(f"stETH per Share: {share_ratio:.10f}")

    # Get wstETH exchange rate
    print("\n--- wstETH STATE ---")

    selector = get_function_selector("stEthPerToken()")
    result = eth_call(WSTETH, selector)
    steth_per_wsteth = decode_uint256(result)
    print(f"stETH per wstETH: {format_ether(steth_per_wsteth)}")

    selector = get_function_selector("tokensPerStEth()")
    result = eth_call(WSTETH, selector)
    wsteth_per_steth = decode_uint256(result)
    print(f"wstETH per stETH: {format_ether(wsteth_per_steth)}")

    # Protocols that use stETH
    print("\n--- PROTOCOLS USING stETH ---")

    protocols_with_steth = [
        # Aave V3 stETH market
        ("Aave V3 stETH", "0x0b925ed163218f6662a35e0f0371ac234f9e9371"),
        # Maker stETH vaults (if any)
        ("MakerDAO", "0x65c79fcb50ca1594b025960e539ed7a9a6d434a3"),
        # Curve stETH pool
        ("Curve stETH/ETH", CURVE_STETH_POOL),
        # Lido
        ("Lido stETH", STETH),
        # Instadapp
        ("Instadapp", "0x1b12f3a3c0df8f5ed42d5f6ae38b5bb7b1f53e44"),
    ]

    for name, addr in protocols_with_steth:
        print(f"\n--- {name} ({addr}) ---")

        source_data = get_contract_source(addr)
        if not source_data:
            print("  No source code")
            continue

        source_code = source_data.get('SourceCode', '')
        contract_name = source_data.get('ContractName', 'Unknown')

        if not source_code:
            print("  No source code")
            continue

        lower = source_code.lower()

        # Check stETH handling
        checks = {
            'Uses stETH directly': 'steth' in lower and 'wsteth' not in lower,
            'Uses wstETH (wrapped)': 'wsteth' in lower,
            'Caches balance': 'balanceof' in lower and ('_cached' in lower or 'lastbalance' in lower),
            'Share calculation': 'getsharesby' in lower or 'shares' in lower,
            'Rebase handling': 'rebase' in lower or 'tokenspereth' in lower,
        }

        for check, found in checks.items():
            if found:
                print(f"  {check}: YES")

        # Specific vulnerability patterns
        if checks['Uses stETH directly'] and not checks['Uses wstETH (wrapped)']:
            print("  !!! POTENTIAL ISSUE: Uses stETH without wrapping !!!")

        if checks['Caches balance'] and checks['Uses stETH directly']:
            print("  !!! POTENTIAL ISSUE: Caches stETH balance (rebase-unsafe) !!!")

        time.sleep(1)

    # Check Curve pool for price divergence
    print("\n" + "=" * 70)
    print("CURVE stETH/ETH PRICE ANALYSIS")
    print("=" * 70)

    # Get pool balances
    selector = get_function_selector("balances(uint256)")

    for i in range(2):
        data = selector + encode(['uint256'], [i]).hex()
        result = eth_call(CURVE_STETH_POOL, data)
        bal = decode_uint256(result)
        token = "ETH" if i == 0 else "stETH"
        print(f"Pool Balance[{i}] ({token}): {format_ether(bal)}")

    # Get virtual price
    selector = get_function_selector("get_virtual_price()")
    result = eth_call(CURVE_STETH_POOL, selector)
    vp = decode_uint256(result)
    print(f"Virtual Price: {format_ether(vp)}")

    # Calculate implied price
    # get_dy(0, 1, 1e18) = how much stETH for 1 ETH
    selector = get_function_selector("get_dy(int128,int128,uint256)")
    data = selector + encode(['int128', 'int128', 'uint256'], [0, 1, 10**18]).hex()
    result = eth_call(CURVE_STETH_POOL, data)
    steth_for_1_eth = decode_uint256(result)
    print(f"stETH for 1 ETH: {format_ether(steth_for_1_eth)}")

    eth_steth_rate = steth_for_1_eth / 10**18
    print(f"ETH/stETH rate: {eth_steth_rate:.6f}")

    # Analysis
    print("\n" + "=" * 70)
    print("SEMANTIC MISMATCH ANALYSIS")
    print("=" * 70)

    print("""
stETH REBASING MECHANICS:
- stETH balance increases daily as staking rewards accrue
- Share-to-token ratio increases over time
- Current ratio: 1 share = {:.6f} stETH

POTENTIAL SEMANTIC MISMATCHES:

1. BALANCE CACHING:
   - If a protocol caches stETH balance between txs
   - Balance increases due to rebase
   - Protocol thinks user has old (lower) balance
   - User can withdraw more than deposited

2. SHARE CALCULATION:
   - If protocol uses balanceOf() instead of sharesOf()
   - Share calculations become incorrect over time
   - Could lead to accounting errors

3. COLLATERAL VALUATION:
   - If protocol values stETH at 1:1 with ETH
   - But market price diverges (currently 1 ETH = {:.6f} stETH)
   - Could create liquidation opportunities

4. CURVE POOL INTEGRATION:
   - If protocol reads Curve stETH/ETH virtual_price
   - During remove_liquidity_one_coin callback, price is manipulable
   - Could exploit via read-only reentrancy

CONCLUSION:
Most major protocols now use wstETH (wrapped) which doesn't rebase.
Protocols still using raw stETH are rare and usually well-audited.
The Curve stETH/ETH pool read-only reentrancy vector has been patched
in most integrations.
""".format(share_ratio, eth_steth_rate))

if __name__ == "__main__":
    main()
