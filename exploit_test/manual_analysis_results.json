{
  "EtherDelta": {
    "address": "0x8d12a197cb00d4747a1fe03395095ce2a5cc6819",
    "source": "pragma solidity ^0.4.9;\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) throw;\r\n  }\r\n}\r\n\r\ncontract Token {\r\n  /// @return total amount of tokens\r\n  function totalSupply() constant returns (uint256 supply) {}\r\n\r\n  /// @param _owner The address from which the balance will be retrieved\r\n  /// @return The balance\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n  /// @notice send `_value` token to `_to` from `msg.sender`\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Wheth..."
  },
  "Exchange": {
    "address": "0x2a0c0dbecc7e4d658f48e01e3fa353f44050c208",
    "source": "pragma solidity ^0.4.16;\r\n\r\ncontract Token {\r\n    bytes32 public standard;\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public totalSupply;\r\n    uint8 public decimals;\r\n    bool public allowTransactions;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n}\r\n\r\ncontract Exchange {\r\n  function assert(bool assertion) {\r\n    if (!assertion) throw;\r\n  }\r\n  function safeMul(uint a, uint b) returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) returns (uint) {\r\n    assert(b..."
  },
  "Acid": {
    "address": "0x23ea10cc1e6ebdb499d24e45369a35f43627062f",
    "source": "pragma solidity 0.5.16;\r\n\r\ncontract DGDInterface {\r\n\r\n  string public constant name = \"DigixDAO\";\r\n  string public constant symbol = \"DGD\";\r\n  uint8 public constant decimals = 9;\r\n\r\n  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n  event Transfer(address indexed from, address indexed to, uint tokens);\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  mapping(address => mapping (address => uint256)) allowed;\r\n\r\n  uint256 public totalSupply;\r\n\r\n  function balanceOf(address tokenOwner) public view returns (uint) {}\r\n\r\n  function transfer(address receiver, uint numTokens) public returns (bool) {}\r\n\r\n  function approve(address delegate, uint numTokens) public returns (bool) {}\r\n\r\n  function allowance(address owner, address delegate) public view returns (uint) {}\r\n\r\n  function transferFrom(address owner, address buyer, uint numTokens) public returns (bool _success) {}\r\n}\r\n\r\ncontract Acid {\r\n\r\n  event Refund(address indexed user, uint256 indexed dgds, uint25..."
  }
}