#!/usr/bin/env python3
"""
Search for protocols vulnerable to stETH/ETH pool read-only reentrancy.

The stETH/ETH pool (0xDC24316b9AE028F1497c275EB9192a3Ea0f67022) has native ETH.
During remove_liquidity_one_coin with ETH, the virtual_price can be manipulated.

We need to find protocols that:
1. Read stETH pool's virtual_price
2. Allow actions based on that price during a callback
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import time
import json

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

# Curve stETH/ETH pool
STETH_POOL = "0xDC24316b9AE028F1497c275EB9192a3Ea0f67022"
STETH_LP = "0x06325440D014e39736583c165C2963BA99fAf14E"  # steCRV

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": "0x" + data if not data.startswith("0x") else data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return resp.json().get("result", "0x")
    except:
        return "0x"

def decode_uint256(hex_result):
    if hex_result == "0x" or not hex_result:
        return 0
    return int(hex_result, 16)

def format_ether(wei):
    return f"{wei / 1e18:.4f}"

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def search_for_steth_integration(source_code):
    """Check if source code references stETH pool"""
    lower = source_code.lower()

    patterns = {
        'steth_pool': '0xdc24316b9ae028f1497c275eb9192a3ea0f67022' in lower,
        'stecrv': '0x06325440d014e39736583c165c2963ba99faf14e' in lower,
        'virtual_price': 'get_virtual_price' in lower or 'virtualPrice' in lower,
        'steth': 'steth' in lower,
        'lido': 'lido' in lower,
        'curve_steth': 'curve' in lower and 'steth' in lower,
    }

    return patterns

def main():
    print("=" * 70)
    print("stETH/ETH READ-ONLY REENTRANCY VULNERABILITY SEARCH")
    print("=" * 70)

    # Check stETH pool state
    print(f"\nstETH/ETH Pool: {STETH_POOL}")

    # Get virtual price
    selector = get_function_selector("get_virtual_price()")
    result = eth_call(STETH_POOL, selector)
    vp = decode_uint256(result)
    print(f"Current virtual_price: {format_ether(vp)}")

    # Get balances
    for i in range(2):
        selector = get_function_selector("balances(uint256)")
        data = selector + encode(['uint256'], [i]).hex()
        result = eth_call(STETH_POOL, data)
        bal = decode_uint256(result)
        print(f"Balance[{i}]: {format_ether(bal)}")

    # Known protocols that might use stETH LP
    known_protocols = [
        # Lending protocols
        ('Aave V2 stETH', '0x1982b2F5814301d4e9a8b0201555376e62F82428'),
        ('Compound cstETH', '0x3c000c0AD3A6dC3439a77E7b7F3a4C1F10A9F4AF'),

        # Yearn vaults
        ('Yearn yvsteCRV', '0xdCD90C7f6324cfa40d7169ef80b12031770B4325'),

        # Convex
        ('Convex steCRV', '0x0A760466E1B4621579a82a39CB56Dda2F4E70f03'),

        # Abracadabra
        ('MIM yvstETH', '0x6Ff9061bB8f97d948942cEF376d98b51fA38B91f'),

        # Other lending
        ('Euler Finance', '0x27182842E098f60e3D576794A5bFFb0777E025d3'),
    ]

    print("\n" + "=" * 70)
    print("CHECKING KNOWN PROTOCOLS")
    print("=" * 70)

    vulnerable = []

    for name, address in known_protocols:
        print(f"\n--- {name} ({address}) ---")

        source = get_contract_source(address)
        if not source:
            print("  No source code found")
            continue

        source_code = source.get('SourceCode', '')
        contract_name = source.get('ContractName', 'Unknown')

        if not source_code:
            print("  Source code empty")
            continue

        print(f"  Contract: {contract_name}")

        patterns = search_for_steth_integration(source_code)
        matches = [k for k, v in patterns.items() if v]

        if matches:
            print(f"  stETH patterns: {matches}")

            # Check for reentrancy protection
            has_guard = 'nonReentrant' in source_code or 'ReentrancyGuard' in source_code
            print(f"  Reentrancy guard: {has_guard}")

            if patterns['virtual_price'] and not has_guard:
                print(f"  !!! VULNERABLE: Reads virtual_price without reentrancy guard !!!")
                vulnerable.append({
                    'name': name,
                    'address': address,
                    'patterns': matches
                })

    # Search contracts.txt
    print("\n" + "=" * 70)
    print("SEARCHING CONTRACTS.TXT FOR stETH INTEGRATION")
    print("=" * 70)

    with open('/home/user/contracs/contracts.txt', 'r') as f:
        addresses = [line.strip() for line in f if line.strip().startswith('0x') and len(line.strip()) == 42]

    checked = 0
    for i, addr in enumerate(addresses):
        if i > 300:  # Limit for API rate
            break

        if i % 50 == 0:
            print(f"Progress: {i}/300, found {len(vulnerable)} vulnerable")
            time.sleep(1)

        source = get_contract_source(addr)
        if not source:
            continue

        source_code = source.get('SourceCode', '')
        if not source_code:
            continue

        checked += 1

        patterns = search_for_steth_integration(source_code)

        # Only interested if it reads virtual_price from stETH-related
        if patterns['virtual_price'] and (patterns['steth'] or patterns['steth_pool'] or patterns['stecrv']):
            contract_name = source.get('ContractName', 'Unknown')
            has_guard = 'nonReentrant' in source_code or 'ReentrancyGuard' in source_code

            if not has_guard:
                print(f"\n  FOUND: {contract_name} ({addr})")
                print(f"    Patterns: {[k for k, v in patterns.items() if v]}")
                vulnerable.append({
                    'name': contract_name,
                    'address': addr,
                    'patterns': [k for k, v in patterns.items() if v]
                })

    print("\n" + "=" * 70)
    print("SEARCH COMPLETE")
    print("=" * 70)
    print(f"Checked {checked} contracts")
    print(f"Found {len(vulnerable)} potentially vulnerable")

    if vulnerable:
        print("\nVULNERABLE CONTRACTS:")
        for v in vulnerable:
            print(f"  - {v['name']} ({v['address']})")
            print(f"    Patterns: {v['patterns']}")

    # Save results
    with open('steth_vulnerable.json', 'w') as f:
        json.dump(vulnerable, f, indent=2)

if __name__ == "__main__":
    main()
