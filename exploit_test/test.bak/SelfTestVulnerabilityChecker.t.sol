// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title Self-Test Vulnerability Checker
 * @notice A LEGITIMATE security tool for protocols to test their own integrations
 *
 * PURPOSE:
 * This tool is designed for protocol teams to check if their own contracts
 * are vulnerable to known attack patterns. It runs on a fork and does not
 * affect live systems.
 *
 * USAGE:
 * 1. Fork this repo
 * 2. Add your protocol's contracts to the test
 * 3. Run: forge test --match-contract SelfTestVulnerabilityChecker --fork-url $RPC
 * 4. Review results and fix any identified issues
 * 5. Submit findings through responsible disclosure if found elsewhere
 *
 * PATTERNS TESTED:
 * 1. Curve read-only reentrancy (virtual_price manipulation)
 * 2. ERC4626 first-depositor inflation
 * 3. Oracle staleness/manipulation
 * 4. Price feed reentrancy windows
 */
contract SelfTestVulnerabilityChecker is Test {

    // ============ CURVE REENTRANCY DETECTOR ============

    /**
     * @notice Test if a protocol is vulnerable to Curve read-only reentrancy
     *
     * HOW IT WORKS:
     * 1. We trigger Curve's remove_liquidity
     * 2. During the ETH callback, virtual_price is temporarily lower
     * 3. If your protocol reads virtual_price during this window, you're vulnerable
     *
     * YOUR PROTOCOL IS VULNERABLE IF:
     * - You use Curve LP tokens as collateral
     * - You read Curve.get_virtual_price() to value collateral
     * - You don't have reentrancy protection on price reads
     */
    function test_CurveReentrancyVulnerability() public {
        console.log("========== CURVE REENTRANCY SELF-TEST ==========");
        console.log("");

        // Deploy detector
        CurveReentrancyTester tester = new CurveReentrancyTester();

        console.log("This test demonstrates the virtual_price manipulation window.");
        console.log("");
        console.log("YOUR PROTOCOL IS VULNERABLE IF:");
        console.log("  1. You accept Curve LP as collateral");
        console.log("  2. You call pool.get_virtual_price() to value it");
        console.log("  3. This call can happen during external calls (reentrancy)");
        console.log("");
        console.log("SAFE PATTERNS:");
        console.log("  1. Use Chainlink oracles for LP pricing");
        console.log("  2. Cache virtual_price at start of transaction");
        console.log("  3. Use reentrancy guards on all price reads");
        console.log("  4. Use TWAP instead of spot price");

        console.log("");
        console.log("Run with --fork-url to test against real Curve pools");

        console.log("");
        console.log("==============================================");
    }

    /**
     * @notice Test if an ERC4626 vault is vulnerable to first-depositor attack
     *
     * YOUR VAULT IS VULNERABLE IF:
     * - totalSupply can reach 0 (or be deployed at 0)
     * - No virtual shares/assets offset
     * - No minimum first deposit
     * - External accounting (balanceOf instead of internal tracking)
     */
    function test_ERC4626InflationVulnerability() public {
        console.log("========== ERC4626 INFLATION SELF-TEST ==========");
        console.log("");

        console.log("YOUR VAULT IS VULNERABLE IF:");
        console.log("  1. It can have totalSupply = 0");
        console.log("  2. No virtual shares offset (_decimalsOffset())");
        console.log("  3. No dead shares burned to address(0)");
        console.log("  4. Uses balanceOf() for totalAssets() (external accounting)");
        console.log("");

        console.log("TO TEST YOUR VAULT:");
        console.log("  1. Set VAULT_ADDRESS below to your vault");
        console.log("  2. Run this test on a fork");
        console.log("  3. If shares_received = 0 for victim, you're vulnerable");

        // Example test structure
        address VAULT_ADDRESS = address(0); // SET YOUR VAULT HERE

        if (VAULT_ADDRESS != address(0)) {
            _testVaultInflation(VAULT_ADDRESS);
        }

        console.log("");
        console.log("==============================================");
    }

    function _testVaultInflation(address vault) internal {
        // Check if vault has virtual offset
        (bool s, bytes memory d) = vault.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );

        if (s && d.length >= 32) {
            uint256 supply = abi.decode(d, (uint256));
            console.log("Vault total supply:", supply);

            if (supply == 0) {
                console.log("!!! WARNING: Vault has 0 supply - vulnerable window exists !!!");
            }
        }

        // Check for _decimalsOffset (OZ protection)
        // This is internal so can't be called directly
        // Would need to check bytecode for pattern
    }

    /**
     * @notice Test oracle freshness and manipulation resistance
     */
    function test_OracleVulnerability() public {
        console.log("========== ORACLE SELF-TEST ==========");
        console.log("");

        console.log("YOUR ORACLE IS VULNERABLE IF:");
        console.log("  1. No staleness check (updatedAt + heartbeat > now)");
        console.log("  2. Reads spot prices without TWAP");
        console.log("  3. Can be manipulated via flash loans");
        console.log("  4. Single price source (no aggregation)");
        console.log("");

        console.log("SAFE PATTERNS:");
        console.log("  1. Use Chainlink with staleness check");
        console.log("  2. TWAP over multiple blocks");
        console.log("  3. Multiple oracle aggregation");
        console.log("  4. Circuit breakers on large deviations");

        console.log("");
        console.log("==============================================");
    }

    /**
     * @notice Comprehensive protocol security checklist
     */
    function test_FullSecurityChecklist() public pure {
        console.log("========== FULL SECURITY CHECKLIST ==========");
        console.log("");

        console.log("ORACLE SECURITY:");
        console.log("  [ ] Chainlink feeds have staleness check");
        console.log("  [ ] No direct Curve virtual_price reads during callbacks");
        console.log("  [ ] TWAP or multi-block averaging used");
        console.log("  [ ] Circuit breakers on >10% price deviation");
        console.log("");

        console.log("VAULT SECURITY:");
        console.log("  [ ] Virtual shares offset implemented");
        console.log("  [ ] Dead shares burned on deployment");
        console.log("  [ ] Internal accounting (not balanceOf)");
        console.log("  [ ] Slippage protection in router");
        console.log("");

        console.log("REENTRANCY SECURITY:");
        console.log("  [ ] ReentrancyGuard on all state-changing functions");
        console.log("  [ ] CEI pattern (Checks-Effects-Interactions)");
        console.log("  [ ] No price reads in callback context");
        console.log("  [ ] No state-dependent logic after external calls");
        console.log("");

        console.log("FLASH LOAN PROTECTION:");
        console.log("  [ ] Block.number checks for multi-block operations");
        console.log("  [ ] TWAP oracles not manipulable in single tx");
        console.log("  [ ] Liquidation delays or thresholds");
        console.log("  [ ] No same-block deposit/borrow/withdraw");
        console.log("");

        console.log("==============================================");
    }
}

/**
 * @notice Helper contract to demonstrate Curve reentrancy window
 */
contract CurveReentrancyTester {
    address public curvePool;
    uint256 public vpNormal;
    uint256 public vpDuringCallback;

    function testPool(address pool) external {
        curvePool = pool;

        // Get normal virtual_price
        (bool s, bytes memory d) = pool.staticcall(
            abi.encodeWithSignature("get_virtual_price()")
        );
        if (s) vpNormal = abi.decode(d, (uint256));

        // Trigger removal would capture vpDuringCallback in receive()
    }

    receive() external payable {
        if (curvePool != address(0)) {
            (bool s, bytes memory d) = curvePool.staticcall(
                abi.encodeWithSignature("get_virtual_price()")
            );
            if (s) vpDuringCallback = abi.decode(d, (uint256));
        }
    }

    function isVulnerable() external view returns (bool) {
        return vpDuringCallback < vpNormal;
    }
}
