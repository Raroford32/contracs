// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title Contract-Specific Deep Analysis
 * @notice Analyze EACH contract individually for NOVEL vulnerabilities
 * Not generic patterns - specific edges in specific contracts
 */
contract ContractSpecificDeepAnalysis is Test {

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/demo");
    }

    // ============================================================
    // CONTRACT 1: Sablier v1.0 - Payment Streaming
    // Address: 0xa4fc358455febe425536fd1878be67ffdbdec59a
    // TVL: ~$1.5M
    // ============================================================

    /**
     * @notice Analyze Sablier for novel edges
     *
     * Key functions:
     * - createStream: deposit % duration == 0 (enforced)
     * - withdrawFromStream: amount <= balance (enforced)
     * - cancelStream: splits remaining between sender/recipient
     *
     * NOVEL EDGE HUNTING:
     * 1. What if a stream's token gets paused?
     * 2. What if token has transfer fees?
     * 3. What happens at exact stopTime block?
     * 4. Can we manipulate block.timestamp?
     */
    function test_SablierDeepAnalysis() public {
        address sablier = 0xa4fc358455febe425536fd1878be67ffdbdec59a;

        console.log("========== SABLIER DEEP ANALYSIS ==========");

        // Get next stream ID to know how many streams exist
        (bool s, bytes memory d) = sablier.staticcall(
            abi.encodeWithSignature("nextStreamId()")
        );
        if (s && d.length >= 32) {
            uint256 nextId = abi.decode(d, (uint256));
            console.log("Next stream ID:", nextId);
            console.log("Streams created:", nextId - 100000);
        }

        // Check a random stream to understand state
        uint256 testStreamId = 100001;
        _analyzeStream(sablier, testStreamId);

        // NOVEL EDGE 1: Token with transfer fees
        console.log("");
        console.log("NOVEL EDGE: Fee-on-transfer tokens");
        console.log("If stream uses token with transfer fee:");
        console.log("  - deposit() transfers X tokens");
        console.log("  - Contract receives X - fee");
        console.log("  - But stream.deposit = X");
        console.log("  - recipient cannot withdraw full amount!");

        // NOVEL EDGE 2: Rebasing tokens
        console.log("");
        console.log("NOVEL EDGE: Rebasing tokens (stETH)");
        console.log("If stream uses rebasing token:");
        console.log("  - Stream created with 100 stETH");
        console.log("  - stETH rebases +1%");
        console.log("  - Contract now holds 101 stETH");
        console.log("  - But stream.deposit = 100");
        console.log("  - 1 stETH is stuck forever!");

        console.log("");
        console.log("===========================================");
    }

    function _analyzeStream(address sablier, uint256 streamId) internal view {
        (bool s, bytes memory d) = sablier.staticcall(
            abi.encodeWithSignature("getStream(uint256)", streamId)
        );
        if (s && d.length >= 256) {
            console.log("Stream", streamId, "exists");
            // Decode stream struct
        } else {
            console.log("Stream", streamId, "does not exist or ended");
        }
    }

    // ============================================================
    // CONTRACT 2: Curve GUSD Gauge
    // Address: 0xc5cfada84e902ad92dd40194f0883ad49639b023
    // TVL: CRV rewards
    // ============================================================

    /**
     * @notice Analyze Curve Gauge for novel edges
     *
     * Key mechanics:
     * - working_balances: boosted balance based on veCRV
     * - integrate_fraction: reward accumulation
     * - kick(): reduce someone's boost
     *
     * NOVEL EDGE HUNTING:
     * 1. Kick timing attack - kick before their checkpoint?
     * 2. veCRV flash loan (not possible - time-locked)
     * 3. Checkpoint race conditions?
     */
    function test_CurveGaugeDeepAnalysis() public {
        address gauge = 0xc5cfada84e902ad92dd40194f0883ad49639b023;

        console.log("========== CURVE GAUGE DEEP ANALYSIS ==========");

        // Get working supply and total supply
        (bool s, bytes memory d) = gauge.staticcall(
            abi.encodeWithSignature("working_supply()")
        );
        if (s && d.length >= 32) {
            uint256 workingSupply = abi.decode(d, (uint256));
            console.log("Working supply:", workingSupply / 1e18);
        }

        (s, d) = gauge.staticcall(abi.encodeWithSignature("totalSupply()"));
        if (s && d.length >= 32) {
            uint256 totalSupply = abi.decode(d, (uint256));
            console.log("Total supply:", totalSupply / 1e18);
        }

        // NOVEL EDGE: Check if anyone can be kicked
        console.log("");
        console.log("NOVEL EDGE: Kick attack vector");
        console.log("kick(addr) can be called if:");
        console.log("  - User's veCRV decreased since last checkpoint");
        console.log("  - Their working_balance > limit from new veCRV");
        console.log("Attack: Find users with expired veCRV locks");
        console.log("  - Their boost is now invalid");
        console.log("  - kick() reduces their working_balance");
        console.log("  - Other stakers get MORE rewards");

        // Find the voting escrow
        (s, d) = gauge.staticcall(
            abi.encodeWithSignature("voting_escrow()")
        );
        if (s && d.length >= 32) {
            address ve = abi.decode(d, (address));
            console.log("Voting Escrow:", ve);

            // Check voting escrow total supply
            (s, d) = ve.staticcall(abi.encodeWithSignature("totalSupply()"));
            if (s && d.length >= 32) {
                uint256 veTotal = abi.decode(d, (uint256));
                console.log("veCRV total:", veTotal / 1e18);
            }
        }

        console.log("");
        console.log("==============================================");
    }

    // ============================================================
    // CONTRACT 3: CEther (Compound)
    // Address: 0x7b4a7fd41c688a7cb116534e341e44126ef5a0fd
    // TVL: ~$700K ETH
    // ============================================================

    /**
     * @notice Analyze CEther for novel edges
     *
     * Key mechanics:
     * - exchangeRate = (cash + borrows - reserves) / totalSupply
     * - mint: cTokens = mintAmount / exchangeRate
     * - redeem: underlying = cTokens * exchangeRate
     *
     * NOVEL EDGE HUNTING:
     * 1. First depositor attack (if totalSupply = 0)
     * 2. Exchange rate manipulation via donation
     * 3. Interest rate jump manipulation
     */
    function test_CEtherDeepAnalysis() public {
        address cEther = 0x7b4a7fd41c688a7cb116534e341e44126ef5a0fd;

        console.log("========== CETHER DEEP ANALYSIS ==========");

        // Get exchange rate
        (bool s, bytes memory d) = cEther.staticcall(
            abi.encodeWithSignature("exchangeRateStored()")
        );
        if (s && d.length >= 32) {
            uint256 rate = abi.decode(d, (uint256));
            console.log("Exchange rate:", rate);
            console.log("Rate (normalized):", rate / 1e18);
        }

        // Get total supply
        (s, d) = cEther.staticcall(abi.encodeWithSignature("totalSupply()"));
        if (s && d.length >= 32) {
            uint256 supply = abi.decode(d, (uint256));
            console.log("cETH supply:", supply / 1e8);
        }

        // Get cash
        (s, d) = cEther.staticcall(abi.encodeWithSignature("getCash()"));
        if (s && d.length >= 32) {
            uint256 cash = abi.decode(d, (uint256));
            console.log("Cash (ETH):", cash / 1e18);
        }

        // Get total borrows
        (s, d) = cEther.staticcall(
            abi.encodeWithSignature("totalBorrows()")
        );
        if (s && d.length >= 32) {
            uint256 borrows = abi.decode(d, (uint256));
            console.log("Total borrows:", borrows / 1e18);
        }

        // NOVEL EDGE: Check if can manipulate exchange rate
        console.log("");
        console.log("NOVEL EDGE: Exchange rate manipulation");
        console.log("exchangeRate = (cash + borrows - reserves) / supply");
        console.log("");
        console.log("If we donate ETH directly to contract:");
        console.log("  - cash increases");
        console.log("  - exchangeRate increases");
        console.log("  - But we get nothing (no cTokens minted)");
        console.log("  - LOSS for donator, GAIN for cToken holders");
        console.log("");
        console.log("REVERSE: First depositor attack");
        console.log("  - If totalSupply = 0, exchangeRate = initial");
        console.log("  - Deposit 1 wei, get 1 cToken");
        console.log("  - Donate X ETH");
        console.log("  - exchangeRate = X");
        console.log("  - Next depositor: cTokens = deposit / X");
        console.log("  - If deposit < X, they get 0 cTokens!");

        console.log("");
        console.log("===========================================");
    }

    // ============================================================
    // CONTRACT 4: Uniswap V3 Staker
    // Address: 0x1f98407aab862cddef78ed252d6f557aa5b0f00d
    // TVL: Variable
    // ============================================================

    /**
     * @notice Analyze V3 Staker for novel edges
     *
     * KNOWN: v1.0.0 has vulnerability where anyone can unstake after end
     *
     * NOVEL EDGE HUNTING:
     * 1. Incentive creation timing manipulation
     * 2. Reward calculation precision issues
     * 3. secondsInside manipulation via pool state
     */
    function test_UniswapV3StakerDeepAnalysis() public {
        address staker = 0x1f98407aab862cddef78ed252d6f557aa5b0f00d;

        console.log("========== UNISWAP V3 STAKER DEEP ANALYSIS ==========");

        // Check for active incentives by querying a known pool
        console.log("Analyzing reward calculation edge cases...");

        console.log("");
        console.log("NOVEL EDGE: Incentive exhaustion attack");
        console.log("If incentive has small reward amount:");
        console.log("  - Many positions stake");
        console.log("  - Each gets tiny reward");
        console.log("  - Gas cost > reward");
        console.log("  - Rewards stuck in contract");
        console.log("");
        console.log("NOVEL EDGE: Last-man-standing (v1.0.0)");
        console.log("After incentive ends:");
        console.log("  - Anyone can call unstake");
        console.log("  - If no one unstakes, rewards accumulate");
        console.log("  - Last unstaker gets all remaining rewards");

        // Check contract version
        (bool s, bytes memory d) = staker.staticcall(
            abi.encodeWithSignature("maxIncentiveStartLeadTime()")
        );
        if (s && d.length >= 32) {
            uint256 lead = abi.decode(d, (uint256));
            console.log("");
            console.log("Max lead time:", lead / 86400, "days");
        }

        console.log("");
        console.log("================================================");
    }

    // ============================================================
    // CONTRACT 5: BasicStakingContract (CRO)
    // Address: 0x4f2bc163c8758d7f88771496f7b0afde767045f3
    // TVL: ~$768K
    // ============================================================

    /**
     * @notice Analyze CRO staking for novel edges
     *
     * ERC-900 staking with lock-in period
     *
     * NOVEL EDGE HUNTING:
     * 1. Lock period bypass
     * 2. Stake/unstake timing
     * 3. Admin key compromise
     */
    function test_CROStakingDeepAnalysis() public {
        address staking = 0x4f2bc163c8758d7f88771496f7b0afde767045f3;

        console.log("========== CRO STAKING DEEP ANALYSIS ==========");

        // Get total staked
        (bool s, bytes memory d) = staking.staticcall(
            abi.encodeWithSignature("totalStaked()")
        );
        if (s && d.length >= 32) {
            uint256 total = abi.decode(d, (uint256));
            console.log("Total staked:", total / 1e8, "CRO");
        }

        // Get lock in duration
        (s, d) = staking.staticcall(
            abi.encodeWithSignature("lockInDuration()")
        );
        if (s && d.length >= 32) {
            uint256 duration = abi.decode(d, (uint256));
            console.log("Lock duration:", duration / 86400, "days");
        }

        // Get owner/admin
        (s, d) = staking.staticcall(abi.encodeWithSignature("owner()"));
        if (s && d.length >= 32) {
            address owner = abi.decode(d, (address));
            console.log("Owner:", owner);

            // Check if owner is EOA or contract
            uint256 codeSize;
            assembly { codeSize := extcodesize(owner) }
            if (codeSize == 0) {
                console.log("!!! Owner is EOA - centralization risk");
            } else {
                console.log("Owner is contract (likely multisig)");
            }
        }

        console.log("");
        console.log("NOVEL EDGE: Lock period calculation");
        console.log("Check if unlock time can overflow");
        console.log("Check if block.timestamp manipulation helps");

        console.log("");
        console.log("=============================================");
    }

    // ============================================================
    // CROSS-CONTRACT CHAINING ANALYSIS
    // ============================================================

    /**
     * @notice Find multi-step exploit paths across contracts
     */
    function test_CrossContractChaining() public {
        console.log("========== CROSS-CONTRACT CHAINING ==========");
        console.log("");

        console.log("CHAIN 1: Flash Loan -> Curve Gauge -> Kick");
        console.log("  1. Flash loan CRV");
        console.log("  2. Lock in veCRV (not possible - time lock)");
        console.log("  3. BLOCKED: veCRV requires time lock");
        console.log("");

        console.log("CHAIN 2: Sablier + Rebasing Token");
        console.log("  1. Create stream with stETH");
        console.log("  2. Wait for Lido rebase");
        console.log("  3. Contract balance > stream.deposit");
        console.log("  4. Cancel stream");
        console.log("  5. Excess stETH stuck in contract");
        console.log("  RESULT: Griefing, not profit");
        console.log("");

        console.log("CHAIN 3: CEther Donation Attack");
        console.log("  1. If CEther totalSupply = 0 (unlikely)");
        console.log("  2. Mint 1 cToken with 1 wei");
        console.log("  3. Donate ETH to contract");
        console.log("  4. Exchange rate = donated_amount");
        console.log("  5. Victim mints, gets 0 cTokens");
        console.log("  6. Redeem your 1 cToken for all ETH");
        console.log("  BLOCKED: CEther likely has supply > 0");
        console.log("");

        // Check CEther total supply
        address cEther = 0x7b4a7fd41c688a7cb116534e341e44126ef5a0fd;
        (bool s, bytes memory d) = cEther.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        if (s && d.length >= 32) {
            uint256 supply = abi.decode(d, (uint256));
            if (supply == 0) {
                console.log("!!! CEther totalSupply = 0 - VULNERABLE !!!");
            } else {
                console.log("CEther supply:", supply, "- attack blocked");
            }
        }

        console.log("");
        console.log("=============================================");
    }
}
