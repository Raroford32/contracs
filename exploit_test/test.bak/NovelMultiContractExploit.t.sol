// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title Novel Multi-Contract Exploit Discovery
 * @notice Deep analysis targeting UNIQUE vulnerabilities in each contract
 *
 * METHODOLOGY:
 * 1. Analyze state machine transitions specific to each contract
 * 2. Find cross-contract dependencies that amplify issues
 * 3. Chain sequences that leverage timing/ordering
 * 4. Test until we find a profitable path
 */
contract NovelMultiContractExploit is Test {

    // Contracts from contracts.txt with potential novel edges
    address constant MERKLE_DISTRIBUTOR_1INCH = 0xe295ad71242373c37c5fda7b57f26f9ea1088afe;
    address constant UNISWAP_V3_STAKER = 0x1f98407aab862cddef78ed252d6f557aa5b0f00d;
    address constant BUSD_TOKEN = 0x4Fabb145d64652a948d72533023f6E7A623C7C53;
    address constant ENS_RESOLVER = 0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41;
    address constant SCROLL_L1_MESSENGER = 0x6774Bcbd5ceCeF1336b5300fb5186a12DDD8b367;

    // Token addresses
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant INCH_TOKEN = 0x111111111117dC0aa78b770fA6A738034120C302;

    // Flash loan sources
    address constant AAVE_V3_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/demo");
    }

    // ============================================================
    // NOVEL EDGE 1: MerkleDistributor Claim Race Condition
    // ============================================================

    /**
     * @notice MerkleDistributor potential vulnerabilities:
     *
     * 1. CLAIM-DURING-MIGRATION:
     *    - If contract has unclaimed tokens and migration is triggered
     *    - Check if there's a window where claims work differently
     *
     * 2. PROOF VERIFICATION EDGE:
     *    - Find proofs that verify for multiple indices
     *    - Hash collision in merkle tree (unlikely but check)
     *
     * 3. CUMULATIVE CLAIM ACCOUNTING:
     *    - cumulativeClaimed[account][index] tracks claims
     *    - Check if overflow/underflow possible in accounting
     */
    function test_MerkleDistributorAnalysis() public {
        console.log("========== MERKLE DISTRIBUTOR DEEP ANALYSIS ==========");
        console.log("");

        address distributor = MERKLE_DISTRIBUTOR_1INCH;

        // Check contract state
        uint256 codeSize;
        assembly { codeSize := extcodesize(distributor) }
        if (codeSize == 0) {
            console.log("Contract not deployed at this address");
            return;
        }

        // Get token balance
        (bool s, bytes memory d) = INCH_TOKEN.staticcall(
            abi.encodeWithSignature("balanceOf(address)", distributor)
        );
        if (s && d.length >= 32) {
            uint256 bal = abi.decode(d, (uint256));
            console.log("1INCH balance in distributor:", bal / 1e18);
        }

        // Check merkle root
        (s, d) = distributor.staticcall(
            abi.encodeWithSignature("merkleRoot()")
        );
        if (s && d.length >= 32) {
            bytes32 root = abi.decode(d, (bytes32));
            console.log("Merkle root set:", root != bytes32(0));
        }

        // NOVEL EDGE: Check if there's an owner who can change merkle root
        (s, d) = distributor.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (s && d.length >= 32) {
            address owner = abi.decode(d, (address));
            console.log("Owner:", owner);

            // Check if owner is multisig or EOA
            assembly { codeSize := extcodesize(owner) }
            console.log("Owner is contract:", codeSize > 0);

            if (codeSize == 0) {
                console.log("!!! CENTRALIZATION RISK: Owner is EOA !!!");
            }
        }

        // NOVEL EDGE: Check for emergency functions
        bytes4[] memory emergencyFuncs = new bytes4[](5);
        emergencyFuncs[0] = bytes4(keccak256("pause()"));
        emergencyFuncs[1] = bytes4(keccak256("emergencyWithdraw()"));
        emergencyFuncs[2] = bytes4(keccak256("setMerkleRoot(bytes32)"));
        emergencyFuncs[3] = bytes4(keccak256("sweep(address)"));
        emergencyFuncs[4] = bytes4(keccak256("recoverTokens(address,uint256)"));

        for (uint i = 0; i < emergencyFuncs.length; i++) {
            (s,) = distributor.staticcall(
                abi.encodeWithSelector(emergencyFuncs[i])
            );
            // Just checking if function exists
        }

        console.log("");
        console.log("NOVEL ATTACK VECTORS:");
        console.log("1. Front-run merkle root update to claim old + new");
        console.log("2. Find users who haven't claimed and claim for them (if permitted)");
        console.log("3. Check if claim() has any callback potential (reentrancy)");

        console.log("");
        console.log("=====================================================");
    }

    // ============================================================
    // NOVEL EDGE 2: UniswapV3Staker Incentive Exhaustion
    // ============================================================

    /**
     * @notice UniswapV3Staker v1.0.0 has KNOWN vulnerability:
     * - After endTime, anyone can call unstakeToken for any position
     *
     * NOVEL EXTENSIONS:
     * 1. LAST-MAN-STANDING: If multiple positions staked, last unstaker
     *    gets disproportionate rewards due to rounding
     *
     * 2. INCENTIVE DUST ATTACK: Create many tiny incentives that
     *    make gas cost > reward, trapping tokens
     *
     * 3. LIQUIDITY-SECONDS MANIPULATION: Positions earn based on
     *    liquidity * time. Can we manipulate this calculation?
     */
    function test_UniswapV3StakerNovelEdges() public {
        console.log("========== UNISWAP V3 STAKER NOVEL ANALYSIS ==========");
        console.log("");

        address staker = UNISWAP_V3_STAKER;

        // Check staker parameters
        (bool s, bytes memory d) = staker.staticcall(
            abi.encodeWithSignature("maxIncentiveStartLeadTime()")
        );
        if (s && d.length >= 32) {
            uint256 lead = abi.decode(d, (uint256));
            console.log("Max incentive lead time:", lead / 86400, "days");
        }

        (s, d) = staker.staticcall(
            abi.encodeWithSignature("maxIncentiveDuration()")
        );
        if (s && d.length >= 32) {
            uint256 dur = abi.decode(d, (uint256));
            console.log("Max incentive duration:", dur / 86400, "days");
        }

        // Check factory
        (s, d) = staker.staticcall(
            abi.encodeWithSignature("factory()")
        );
        if (s && d.length >= 32) {
            address factory = abi.decode(d, (address));
            console.log("Factory:", factory);
        }

        // NOVEL EDGE: Calculate minimum profitable incentive
        console.log("");
        console.log("NOVEL: DUST INCENTIVE ATTACK");
        console.log("If incentive has small reward:");
        console.log("  - Gas to unstake ~100k gas = 0.02 ETH @ 200 gwei");
        console.log("  - If reward < gas cost, tokens are trapped");
        console.log("  - Create N incentives with reward = 0.01 ETH each");
        console.log("  - Positions are locked, gas to claim exceeds reward");

        console.log("");
        console.log("NOVEL: LIQUIDITY-SECONDS GAMING");
        console.log("Rewards = stakingSeconds * liquidity / totalLiquiditySeconds");
        console.log("Attack: Add massive liquidity right before incentive ends");
        console.log("  - Your liquiditySeconds spikes");
        console.log("  - Others' share diluted");
        console.log("  - Requires capital but extracts existing rewards");

        console.log("");
        console.log("======================================================");
    }

    // ============================================================
    // NOVEL EDGE 3: Cross-Protocol Oracle Dependency
    // ============================================================

    /**
     * @notice Find protocols that DEPEND on other protocols' state
     * These create attack surfaces where manipulating one affects another
     */
    function test_CrossProtocolDependencies() public {
        console.log("========== CROSS-PROTOCOL DEPENDENCY ANALYSIS ==========");
        console.log("");

        // Pattern: Protocol A reads price from Protocol B
        // If we can manipulate B's price during A's calculation...

        address curveSteth = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;

        // Get Curve stETH pool virtual_price
        (bool s, bytes memory d) = curveSteth.staticcall(
            abi.encodeWithSignature("get_virtual_price()")
        );
        uint256 virtualPrice;
        if (s && d.length >= 32) {
            virtualPrice = abi.decode(d, (uint256));
            console.log("Curve stETH virtual_price:", virtualPrice);
        }

        // Find protocols that read this virtual_price for collateral valuation
        // Known consumers: Abracadabra, Inverse Finance, Fraxlend

        console.log("");
        console.log("PROTOCOLS READING CURVE VIRTUAL_PRICE:");
        console.log("1. Abracadabra Cauldrons - LP collateral");
        console.log("2. Fraxlend pairs - stETH collateral");
        console.log("3. Various yield aggregators");

        console.log("");
        console.log("ATTACK CHAIN:");
        console.log("1. Flash loan ETH from Balancer (0% fee)");
        console.log("2. Add imbalanced liquidity to Curve");
        console.log("3. Trigger remove_liquidity (sends ETH)");
        console.log("4. During ETH callback, virtual_price is deflated");
        console.log("5. Call liquidation on victim protocol");
        console.log("6. Restore Curve balance, repay flash loan");
        console.log("7. Profit = liquidation bonus - gas");

        // Calculate required capital
        (s, d) = curveSteth.staticcall(
            abi.encodeWithSignature("balances(uint256)", 0)
        );
        uint256 ethBalance;
        if (s && d.length >= 32) {
            ethBalance = abi.decode(d, (uint256));
            console.log("");
            console.log("Curve pool ETH:", ethBalance / 1e18);
            console.log("10% manipulation requires:", ethBalance / 10 / 1e18, "ETH");
        }

        console.log("");
        console.log("=========================================================");
    }

    // ============================================================
    // NOVEL EDGE 4: Token Approval Dangling References
    // ============================================================

    /**
     * @notice Find contracts with:
     * 1. Leftover token approvals to defunct/compromised contracts
     * 2. Infinite approvals to external protocols
     * 3. Approval patterns that can be exploited
     */
    function test_ApprovalDanglingReferences() public {
        console.log("========== APPROVAL DANGLING REFERENCE ANALYSIS ==========");
        console.log("");

        // Check if any contract from contracts.txt has approvals to vulnerable contracts
        address[] memory targets = new address[](10);
        targets[0] = 0xa4fc358455febe425536fd1878be67ffdbdec59a; // Sablier
        targets[1] = 0x7623e9DC0DA6FF821ddb9EbABA794054E078f8c4; // EarlyAdopterPool
        targets[2] = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4; // DolaSavings
        targets[3] = 0x4f2bc163c8758d7f88771496f7b0afde767045f3; // BasicStakingCRO
        targets[4] = 0x996913c8c08472f584ab8834e925b06D0eb1D813; // RewardVault
        targets[5] = 0x82bA8da44Cd5261762e629dd5c605b17715727bd; // FraxQueue
        targets[6] = 0x9A0C8Ff858d273f57072D714bca7411D717501D7; // st1INCH
        targets[7] = 0x16de59092dae5ccf4a1e6439d611fd0653f0bd01; // yDAI
        targets[8] = 0x93054188d876f558f4a66b2ef1d97d16edf0895b; // Curve renBTC
        targets[9] = 0xc5cfada84e902ad92dd40194f0883ad49639b023; // Curve Gauge

        // Check major token approvals from these contracts
        address[] memory tokens = new address[](5);
        tokens[0] = WETH;
        tokens[1] = USDC;
        tokens[2] = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // USDT
        tokens[3] = 0x6B175474E89094C44Da98b954EedeAC495271d0F; // DAI
        tokens[4] = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599; // WBTC

        console.log("Checking approval patterns...");
        console.log("(Would need event logs to fully enumerate)");

        console.log("");
        console.log("NOVEL ATTACK VECTOR:");
        console.log("1. Find contracts with old approvals to deprecated spenders");
        console.log("2. If spender contract is upgradeable/compromised");
        console.log("3. New implementation can drain approved tokens");
        console.log("4. This requires finding such approvals via Transfer events");

        console.log("");
        console.log("===========================================================");
    }

    // ============================================================
    // NOVEL EDGE 5: Governance Timelock Race Conditions
    // ============================================================

    /**
     * @notice Timelock controllers have race conditions:
     * 1. Between queueing and execution, state can change
     * 2. Predecessor dependencies can be front-run
     * 3. Batch operations have ordering requirements
     */
    function test_GovernanceTimelockEdges() public {
        console.log("========== GOVERNANCE TIMELOCK ANALYSIS ==========");
        console.log("");

        // Known timelocks from contracts.txt
        address[] memory timelocks = new address[](3);
        timelocks[0] = 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb; // Example
        timelocks[1] = 0x0000000000000000000000000000000000000000; // Placeholder
        timelocks[2] = 0x0000000000000000000000000000000000000000; // Placeholder

        console.log("TIMELOCK RACE CONDITION PATTERNS:");
        console.log("");
        console.log("1. PARAMETER CHANGE FRONT-RUN:");
        console.log("   - Timelock queues setFee(newFee)");
        console.log("   - Before execution, attacker front-runs with operations");
        console.log("   - Profit from knowing fee will change");
        console.log("");
        console.log("2. PREDECESSOR DEPENDENCY MANIPULATION:");
        console.log("   - Operation B requires Operation A complete first");
        console.log("   - If A can be blocked or delayed...");
        console.log("   - B becomes stuck, potentially freezing funds");
        console.log("");
        console.log("3. BATCH OPERATION ORDERING:");
        console.log("   - executeBatch() executes in order");
        console.log("   - If earlier operation changes state for later one");
        console.log("   - Entire batch may fail or have unexpected results");

        console.log("");
        console.log("=================================================");
    }

    // ============================================================
    // NOVEL EDGE 6: Staking Reward Calculation Precision
    // ============================================================

    /**
     * @notice Many staking contracts have precision issues:
     * 1. rewardPerToken calculation loses precision
     * 2. First staker / last staker advantages
     * 3. Reward rate changes create arbitrage windows
     */
    function test_StakingRewardPrecision() public {
        console.log("========== STAKING REWARD PRECISION ANALYSIS ==========");
        console.log("");

        // Check DolaSavings precision
        address dolaSavings = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4;

        (bool s, bytes memory d) = dolaSavings.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        uint256 totalSupply;
        if (s && d.length >= 32) {
            totalSupply = abi.decode(d, (uint256));
            console.log("DolaSavings total supply:", totalSupply / 1e18);
        }

        (s, d) = dolaSavings.staticcall(
            abi.encodeWithSignature("yearlyRewardBudget()")
        );
        uint256 yearlyBudget;
        if (s && d.length >= 32) {
            yearlyBudget = abi.decode(d, (uint256));
            console.log("Yearly reward budget:", yearlyBudget / 1e18);
        }

        (s, d) = dolaSavings.staticcall(
            abi.encodeWithSignature("lastUpdate()")
        );
        uint256 lastUpdate;
        if (s && d.length >= 32) {
            lastUpdate = abi.decode(d, (uint256));
            uint256 timeSince = block.timestamp - lastUpdate;
            console.log("Time since last update:", timeSince, "seconds");

            // Calculate accumulated rewards
            if (yearlyBudget > 0 && totalSupply > 0) {
                uint256 pendingRewards = (timeSince * yearlyBudget * 1e18) / 365 days;
                console.log("Pending rewards (mantissa):", pendingRewards);

                // If pending < totalSupply, rounding causes loss
                if (pendingRewards < totalSupply) {
                    console.log("!!! PRECISION LOSS: pending < totalSupply");
                    console.log("Index increase will be 0 - rewards lost!");
                }
            }
        }

        console.log("");
        console.log("PRECISION ATTACK VECTORS:");
        console.log("1. Flash stake right before update - dilute others");
        console.log("2. Trigger many small updates - lose rewards to rounding");
        console.log("3. Wait for accumulated rewards, flash stake to capture");

        console.log("");
        console.log("======================================================");
    }

    // ============================================================
    // COMPREHENSIVE SCAN: Run all analyses
    // ============================================================

    function test_runAllAnalyses() public {
        console.log("########################################################");
        console.log("#          COMPREHENSIVE NOVEL EDGE SCANNER            #");
        console.log("########################################################");
        console.log("");

        test_MerkleDistributorAnalysis();
        test_UniswapV3StakerNovelEdges();
        test_CrossProtocolDependencies();
        test_StakingRewardPrecision();

        console.log("");
        console.log("########################################################");
        console.log("#                    SUMMARY                           #");
        console.log("########################################################");
        console.log("");
        console.log("Most promising attack vectors:");
        console.log("1. Cross-protocol oracle manipulation (Curve -> Lending)");
        console.log("2. Staking precision attacks (DolaSavings flash stake)");
        console.log("3. V3 Staker incentive exhaustion");
        console.log("4. Merkle distributor timing attacks");
    }
}
