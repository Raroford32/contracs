// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title Unexplored Contracts Deep Dive
 * @notice Analyze contracts from contracts.txt that haven't been fully explored
 *
 * APPROACH:
 * 1. For each contract, read its state
 * 2. Identify its function signatures
 * 3. Find unique edges based on its specific logic
 * 4. Test for exploitability
 */
contract UnexploredContractsDeepDive is Test {

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/demo");
    }

    // ============================================================
    // BATCH 1: High-potential unexplored contracts
    // ============================================================

    /**
     * @notice Analyze 0x4618c019a0ed3b1b560ebc3cc80ee4eb52c96230
     * First contract in contracts.txt
     */
    function test_analyzeContract_0x4618() public {
        address target = 0x4618c019a0ed3b1b560ebc3cc80ee4eb52c96230;
        console.log("========== ANALYZING 0x4618... ==========");

        _fullContractAnalysis(target);
    }

    /**
     * @notice Analyze 0xa32ff8ca08036337fabf50fa029812361cd176c8
     */
    function test_analyzeContract_0xa32f() public {
        address target = 0xa32ff8ca08036337fabf50fa029812361cd176c8;
        console.log("========== ANALYZING 0xa32f... ==========");

        _fullContractAnalysis(target);
    }

    /**
     * @notice Analyze 0x8fb1a35bb6fb9c47fb5065be5062cb8dc1687669
     */
    function test_analyzeContract_0x8fb1() public {
        address target = 0x8fb1a35bb6fb9c47fb5065be5062cb8dc1687669;
        console.log("========== ANALYZING 0x8fb1... ==========");

        _fullContractAnalysis(target);
    }

    /**
     * @notice Analyze 0xd46df541148932690b81092f600f35208afd4325
     */
    function test_analyzeContract_0xd46d() public {
        address target = 0xd46df541148932690b81092f600f35208afd4325;
        console.log("========== ANALYZING 0xd46d... ==========");

        _fullContractAnalysis(target);
    }

    /**
     * @notice Analyze 0x5a0748f8d40b7884e182fc4994d8d4a115a8cbf7
     */
    function test_analyzeContract_0x5a07() public {
        address target = 0x5a0748f8d40b7884e182fc4994d8d4a115a8cbf7;
        console.log("========== ANALYZING 0x5a07... ==========");

        _fullContractAnalysis(target);
    }

    /**
     * @notice Full analysis of a contract
     */
    function _fullContractAnalysis(address target) internal {
        console.log("Target:", target);

        // Check code exists
        uint256 codeSize;
        assembly { codeSize := extcodesize(target) }
        console.log("Code size:", codeSize);

        if (codeSize == 0) {
            console.log("Contract has no code - may be EOA or self-destructed");
            return;
        }

        // Check ETH balance
        console.log("ETH balance:", target.balance / 1e18, "ETH");

        // Common function signatures to probe
        bytes4[] memory sigs = new bytes4[](30);
        sigs[0] = bytes4(keccak256("owner()"));
        sigs[1] = bytes4(keccak256("admin()"));
        sigs[2] = bytes4(keccak256("totalSupply()"));
        sigs[3] = bytes4(keccak256("balanceOf(address)"));
        sigs[4] = bytes4(keccak256("name()"));
        sigs[5] = bytes4(keccak256("symbol()"));
        sigs[6] = bytes4(keccak256("decimals()"));
        sigs[7] = bytes4(keccak256("paused()"));
        sigs[8] = bytes4(keccak256("token()"));
        sigs[9] = bytes4(keccak256("underlying()"));
        sigs[10] = bytes4(keccak256("oracle()"));
        sigs[11] = bytes4(keccak256("pendingOwner()"));
        sigs[12] = bytes4(keccak256("implementation()"));
        sigs[13] = bytes4(keccak256("getOwner()"));
        sigs[14] = bytes4(keccak256("governance()"));
        sigs[15] = bytes4(keccak256("controller()"));
        sigs[16] = bytes4(keccak256("factory()"));
        sigs[17] = bytes4(keccak256("router()"));
        sigs[18] = bytes4(keccak256("version()"));
        sigs[19] = bytes4(keccak256("initialized()"));
        sigs[20] = bytes4(keccak256("poolLength()"));
        sigs[21] = bytes4(keccak256("rewardToken()"));
        sigs[22] = bytes4(keccak256("stakingToken()"));
        sigs[23] = bytes4(keccak256("rewardRate()"));
        sigs[24] = bytes4(keccak256("periodFinish()"));
        sigs[25] = bytes4(keccak256("lastUpdateTime()"));
        sigs[26] = bytes4(keccak256("rewardPerTokenStored()"));
        sigs[27] = bytes4(keccak256("totalStaked()"));
        sigs[28] = bytes4(keccak256("exchangeRate()"));
        sigs[29] = bytes4(keccak256("exchangeRateStored()"));

        console.log("");
        console.log("Probing function signatures...");

        for (uint i = 0; i < sigs.length; i++) {
            (bool success, bytes memory data) = target.staticcall(
                abi.encodeWithSelector(sigs[i])
            );

            if (success && data.length > 0) {
                _logFunctionResult(sigs[i], data);
            }
        }

        // Check for common vulnerabilities
        console.log("");
        console.log("=== VULNERABILITY PROBES ===");

        // 1. Check for unprotected functions
        _probeUnprotectedFunctions(target);

        // 2. Check for proxy patterns
        _probeProxyPattern(target);

        // 3. Check for reward calculation issues
        _probeRewardIssues(target);

        console.log("");
        console.log("========================================");
    }

    function _logFunctionResult(bytes4 sig, bytes memory data) internal pure {
        // Try to decode common return types
        if (data.length >= 32) {
            // Could be address, uint256, or bool
            if (data.length == 32) {
                uint256 val = abi.decode(data, (uint256));
                if (val > 0 && val < 1e9) {
                    console.log("  Sig", uint32(sig), "-> uint:", val);
                } else if (val > 1e9 && val < 1e30) {
                    console.log("  Sig", uint32(sig), "-> wei:", val / 1e18);
                } else {
                    // Could be address
                    address addr = address(uint160(val));
                    console.log("  Sig", uint32(sig), "-> addr:", addr);
                }
            }
        }
    }

    function _probeUnprotectedFunctions(address target) internal {
        address attacker = makeAddr("attacker");

        // Try calling potentially dangerous functions
        bytes4[] memory dangerousFuncs = new bytes4[](15);
        dangerousFuncs[0] = bytes4(keccak256("withdraw()"));
        dangerousFuncs[1] = bytes4(keccak256("emergencyWithdraw()"));
        dangerousFuncs[2] = bytes4(keccak256("sweep(address)"));
        dangerousFuncs[3] = bytes4(keccak256("drain()"));
        dangerousFuncs[4] = bytes4(keccak256("skim(address)"));
        dangerousFuncs[5] = bytes4(keccak256("collect()"));
        dangerousFuncs[6] = bytes4(keccak256("claim()"));
        dangerousFuncs[7] = bytes4(keccak256("harvest()"));
        dangerousFuncs[8] = bytes4(keccak256("exit()"));
        dangerousFuncs[9] = bytes4(keccak256("rescueFunds(address)"));
        dangerousFuncs[10] = bytes4(keccak256("recoverTokens(address)"));
        dangerousFuncs[11] = bytes4(keccak256("withdrawAll()"));
        dangerousFuncs[12] = bytes4(keccak256("withdrawETH()"));
        dangerousFuncs[13] = bytes4(keccak256("claimRewards()"));
        dangerousFuncs[14] = bytes4(keccak256("getReward()"));

        uint256 targetBalanceBefore = target.balance;

        for (uint i = 0; i < dangerousFuncs.length; i++) {
            vm.prank(attacker);
            (bool success,) = target.call(
                abi.encodeWithSelector(dangerousFuncs[i])
            );

            if (success) {
                uint256 targetBalanceAfter = target.balance;
                if (targetBalanceAfter < targetBalanceBefore) {
                    console.log("!!! FOUND UNPROTECTED FUNCTION:", uint32(dangerousFuncs[i]));
                    console.log("    ETH extracted:", (targetBalanceBefore - targetBalanceAfter) / 1e18);
                }
            }
        }
    }

    function _probeProxyPattern(address target) internal view {
        // Check for proxy patterns
        (bool s, bytes memory d) = target.staticcall(
            abi.encodeWithSignature("implementation()")
        );

        if (s && d.length >= 32) {
            address impl = abi.decode(d, (address));
            console.log("  PROXY DETECTED - implementation:", impl);

            // Check if implementation is set
            if (impl == address(0)) {
                console.log("  !!! UNINITIALIZED PROXY - implementation is zero !!!");
            }

            // Check implementation code
            uint256 implCodeSize;
            assembly { implCodeSize := extcodesize(impl) }
            if (implCodeSize == 0) {
                console.log("  !!! IMPLEMENTATION HAS NO CODE !!!");
            }
        }

        // Check for UUPS pattern
        bytes32 IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
        bytes32 slotValue;
        assembly {
            slotValue := sload(IMPLEMENTATION_SLOT)
        }

        // This won't work with staticcall, just checking the pattern exists
    }

    function _probeRewardIssues(address target) internal view {
        // Check for staking/reward patterns that might have precision issues
        (bool s, bytes memory d) = target.staticcall(
            abi.encodeWithSignature("rewardRate()")
        );
        uint256 rewardRate;
        if (s && d.length >= 32) {
            rewardRate = abi.decode(d, (uint256));
            console.log("  Reward rate:", rewardRate);
        }

        (s, d) = target.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        uint256 totalSupply;
        if (s && d.length >= 32) {
            totalSupply = abi.decode(d, (uint256));
        }

        if (rewardRate > 0 && totalSupply > 0) {
            // Check for precision loss
            uint256 rewardPerToken = rewardRate * 1e18 / totalSupply;
            if (rewardPerToken == 0) {
                console.log("  !!! PRECISION LOSS: rewardRate too small for totalSupply");
            }
        }
    }

    // ============================================================
    // BATCH 2: Scan for specific vulnerability patterns
    // ============================================================

    /**
     * @notice Scan all contracts for uninitialized proxies
     */
    function test_scanForUninitializedProxies() public {
        console.log("========== UNINITIALIZED PROXY SCANNER ==========");
        console.log("");

        // Sample contracts from contracts.txt
        address[] memory targets = new address[](20);
        targets[0] = 0x4618c019a0ed3b1b560ebc3cc80ee4eb52c96230;
        targets[1] = 0xa32ff8ca08036337fabf50fa029812361cd176c8;
        targets[2] = 0x8fb1a35bb6fb9c47fb5065be5062cb8dc1687669;
        targets[3] = 0xc5cfada84e902ad92dd40194f0883ad49639b023;
        targets[4] = 0xd46df541148932690b81092f600f35208afd4325;
        targets[5] = 0x5a0748f8d40b7884e182fc4994d8d4a115a8cbf7;
        targets[6] = 0xa08c1134cdd73ad41889f7f914ecc4d3b30c1333;
        targets[7] = 0xc32050abac7dbfef4fc8dc7b96d9617394cb4e1b;
        targets[8] = 0x7100c7ce94607ef68983f133cfd59cc1833a115d;
        targets[9] = 0x08a90fe0741b7def03fb290cc7b273f1855767d8;
        targets[10] = 0xa4fc358455febe425536fd1878be67ffdbdec59a;
        targets[11] = 0x4f2bc163c8758d7f88771496f7b0afde767045f3;
        targets[12] = 0x77b53b6f45592f5e88cecec4ff2cd968e1c46bee;
        targets[13] = 0x2f9f02f2ba99ff5c750f95cf27d25352f71cd6a9;
        targets[14] = 0xa919341942c858290b95e2d1dc6a6f6f36c23266;
        targets[15] = 0x83eb2094072f6ed9f57d3f19f54820ee0bae6084;
        targets[16] = 0xa1a111bc074c9cfa781f0c38e63bd51c91b8af00;
        targets[17] = 0x142fdef3d4b26d7152ef808c3b147754216ccb36;
        targets[18] = 0xe3412d2751f6cfa117a4c5eb71e84aa63a5ee5ff;
        targets[19] = 0x897c03a77039c31df13f3c632b7e46191839bbac;

        uint256 proxyCount = 0;
        uint256 vulnerableCount = 0;

        for (uint i = 0; i < targets.length; i++) {
            address target = targets[i];

            uint256 codeSize;
            assembly { codeSize := extcodesize(target) }
            if (codeSize == 0) continue;

            // Check for implementation
            (bool s, bytes memory d) = target.staticcall(
                abi.encodeWithSignature("implementation()")
            );

            if (s && d.length >= 32) {
                proxyCount++;
                address impl = abi.decode(d, (address));

                if (impl == address(0)) {
                    vulnerableCount++;
                    console.log("!!! VULNERABLE: Uninitialized proxy at", target);
                }

                uint256 implCodeSize;
                assembly { implCodeSize := extcodesize(impl) }
                if (implCodeSize == 0 && impl != address(0)) {
                    vulnerableCount++;
                    console.log("!!! VULNERABLE: Implementation has no code", target);
                }
            }
        }

        console.log("");
        console.log("Proxies found:", proxyCount);
        console.log("Vulnerable:", vulnerableCount);

        console.log("");
        console.log("=================================================");
    }

    /**
     * @notice Scan for zero totalSupply vaults (first depositor attack)
     */
    function test_scanForEmptyVaults() public {
        console.log("========== EMPTY VAULT SCANNER ==========");
        console.log("");

        address[] memory targets = new address[](30);
        targets[0] = 0x16de59092dae5ccf4a1e6439d611fd0653f0bd01;
        targets[1] = 0x7b4a7fd41c688a7cb116534e341e44126ef5a0fd;
        targets[2] = 0xFAce851a4921ce59e912d19329929CE6da6EB0c7;
        targets[3] = 0x4f6a43ad7cba042606decaca730d4ce0a57ac62e;
        targets[4] = 0x93054188d876f558f4a66b2ef1d97d16edf0895b;
        targets[5] = 0xb1f2cdec61db658f091671f5f199635aef202cac;
        targets[6] = 0x5f465e9fcffc217c5849906216581a657cd60605;
        targets[7] = 0x4e840aadd28da189b9906674b4afcb77c128d9ea;
        targets[8] = 0xa61beb4a3d02decb01039e378237032b351125b4;
        targets[9] = 0xab73ec65a1ef5a2e5b56d5d6f36bee4b2a1d3ffb;
        targets[10] = 0xf74bf048138a2b8f825eccabed9e02e481a0f6c0;
        targets[11] = 0x0f30c808069315b3b7dfbfe149c87448b50c6d8b;
        targets[12] = 0xf35a92585ceee7251388e14f268d9065f5206207;
        targets[13] = 0x9de9773a77a9b51330736e73429622cc32f51926;
        targets[14] = 0xdbfb513d25df56b4c3f5258d477a395d4b735824;
        targets[15] = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4;
        targets[16] = 0x996913c8c08472f584ab8834e925b06D0eb1D813;
        targets[17] = 0x82bA8da44Cd5261762e629dd5c605b17715727bd;
        targets[18] = 0x9A0C8Ff858d273f57072D714bca7411D717501D7;
        targets[19] = 0xc5cfada84e902ad92dd40194f0883ad49639b023;
        targets[20] = 0xa4fc358455febe425536fd1878be67ffdbdec59a;
        targets[21] = 0x7623e9DC0DA6FF821ddb9EbABA794054E078f8c4;
        targets[22] = 0x4f2bc163c8758d7f88771496f7b0afde767045f3;
        targets[23] = 0x83eb2094072f6ed9f57d3f19f54820ee0bae6084;
        targets[24] = 0xe295ad71242373c37c5fda7b57f26f9ea1088afe;
        targets[25] = 0x1f98407aab862cddef78ed252d6f557aa5b0f00d;
        targets[26] = 0x10e6593cdda8c58a1d0f14c5164b376352a55f2f;
        targets[27] = 0xaedcfcdd80573c2a312d15d6bb9d921a01e4fb0f;
        targets[28] = 0x394d8b3c5de759b8258376fde9b394c8f237d8c4;
        targets[29] = 0x8b5876f5b0bf64056a89aa7e97511644758c3e8c;

        uint256 emptyCount = 0;
        uint256 lowSupplyCount = 0;

        for (uint i = 0; i < targets.length; i++) {
            address target = targets[i];

            uint256 codeSize;
            assembly { codeSize := extcodesize(target) }
            if (codeSize == 0) continue;

            (bool s, bytes memory d) = target.staticcall(
                abi.encodeWithSignature("totalSupply()")
            );

            if (s && d.length >= 32) {
                uint256 supply = abi.decode(d, (uint256));

                if (supply == 0) {
                    emptyCount++;
                    console.log("!!! EMPTY VAULT:", target);
                    console.log("    Potential first-depositor attack target");

                    // Check balance
                    uint256 bal = target.balance;
                    if (bal > 0) {
                        console.log("    ETH balance:", bal / 1e18);
                    }
                } else if (supply < 1e12) {
                    // Very low supply - might be vulnerable to manipulation
                    lowSupplyCount++;
                    console.log("LOW SUPPLY:", target, "supply:", supply);
                }
            }
        }

        console.log("");
        console.log("Empty vaults:", emptyCount);
        console.log("Low supply vaults:", lowSupplyCount);

        console.log("");
        console.log("==========================================");
    }

    /**
     * @notice Scan for precision loss in reward calculations
     */
    function test_scanForPrecisionLoss() public {
        console.log("========== PRECISION LOSS SCANNER ==========");
        console.log("");

        address[] memory targets = new address[](10);
        targets[0] = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4; // DolaSavings
        targets[1] = 0x996913c8c08472f584ab8834e925b06D0eb1D813; // RewardVault
        targets[2] = 0x4f2bc163c8758d7f88771496f7b0afde767045f3; // BasicStakingCRO
        targets[3] = 0x5f465e9fcffc217c5849906216581a657cd60605; // Convex
        targets[4] = 0xc5cfada84e902ad92dd40194f0883ad49639b023; // Curve Gauge
        targets[5] = 0xb1f2cdec61db658f091671f5f199635aef202cac; // Curve Gauge 2
        targets[6] = 0x9A0C8Ff858d273f57072D714bca7411D717501D7; // st1INCH
        targets[7] = 0x1f98407aab862cddef78ed252d6f557aa5b0f00d; // V3 Staker
        targets[8] = 0x83eb2094072f6ed9f57d3f19f54820ee0bae6084; // Parachute Tellor
        targets[9] = 0xe295ad71242373c37c5fda7b57f26f9ea1088afe; // MerkleDistributor

        for (uint i = 0; i < targets.length; i++) {
            address target = targets[i];

            uint256 codeSize;
            assembly { codeSize := extcodesize(target) }
            if (codeSize == 0) continue;

            console.log("Analyzing:", target);

            // Get total supply
            (bool s, bytes memory d) = target.staticcall(
                abi.encodeWithSignature("totalSupply()")
            );
            uint256 totalSupply;
            if (s && d.length >= 32) {
                totalSupply = abi.decode(d, (uint256));
                console.log("  Total supply:", totalSupply);
            }

            // Get reward rate
            (s, d) = target.staticcall(
                abi.encodeWithSignature("rewardRate()")
            );
            uint256 rewardRate;
            if (s && d.length >= 32) {
                rewardRate = abi.decode(d, (uint256));
                console.log("  Reward rate:", rewardRate);
            }

            // Get yearly budget (for DolaSavings style)
            (s, d) = target.staticcall(
                abi.encodeWithSignature("yearlyRewardBudget()")
            );
            uint256 yearlyBudget;
            if (s && d.length >= 32) {
                yearlyBudget = abi.decode(d, (uint256));
                console.log("  Yearly budget:", yearlyBudget);
            }

            // Check for precision issues
            if (totalSupply > 0) {
                if (rewardRate > 0) {
                    uint256 rewardPerToken = rewardRate * 1e18 / totalSupply;
                    if (rewardPerToken == 0) {
                        console.log("  !!! PRECISION LOSS: rewardRate/totalSupply = 0");
                    }
                }

                if (yearlyBudget > 0) {
                    // Calculate per-second reward
                    uint256 perSecond = yearlyBudget / 365 days;
                    uint256 perSecondPerToken = perSecond * 1e18 / totalSupply;
                    if (perSecondPerToken == 0) {
                        console.log("  !!! PRECISION LOSS: perSecond reward too small");
                    }
                }
            }

            console.log("");
        }

        console.log("=============================================");
    }

    // ============================================================
    // COMPREHENSIVE BATCH SCAN
    // ============================================================

    function test_comprehensiveBatchScan() public {
        console.log("############################################################");
        console.log("#          COMPREHENSIVE CONTRACT BATCH SCAN               #");
        console.log("############################################################");
        console.log("");

        test_scanForUninitializedProxies();
        test_scanForEmptyVaults();
        test_scanForPrecisionLoss();

        console.log("");
        console.log("############################################################");
    }
}
