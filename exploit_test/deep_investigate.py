#!/usr/bin/env python3
"""
Deep investigation of high-value interesting contracts
"""

import json
import requests
from eth_abi import decode, encode
from eth_utils import keccak

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=30)
        return resp.json().get("result", "0x")
    except:
        return "0x"

def get_code(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getCode",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=30)
        return resp.json().get("result", "0x")
    except:
        return "0x"

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=30)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def decode_uint256(hex_result):
    if hex_result == "0x" or not hex_result:
        return 0
    return int(hex_result, 16)

def format_ether(wei):
    return f"{wei / 1e18:.4f}"

def probe_common_functions(address):
    """Try calling common functions to understand contract type"""
    functions = [
        ("owner()", "owner"),
        ("totalSupply()", "totalSupply"),
        ("paused()", "paused"),
        ("getOwner()", "getOwner"),
        ("admin()", "admin"),
        ("pendingOwner()", "pendingOwner"),
        ("implementation()", "implementation"),
        ("getImplementation()", "getImplementation"),
        ("withdraw()", "withdraw"),
        ("withdrawAll()", "withdrawAll"),
        ("balance()", "balance"),
        ("getBalance()", "getBalance"),
    ]

    results = {}
    for sig, name in functions:
        selector = get_function_selector(sig)
        result = eth_call(address, selector)
        if result and result != "0x" and len(result) > 2:
            results[name] = result
    return results

def analyze_contract(address, name):
    print(f"\n{'=' * 60}")
    print(f"ANALYZING: {name}")
    print(f"Address: {address}")
    print('=' * 60)

    # Get balance
    balance = get_eth_balance(address)
    print(f"\nETH Balance: {format_ether(balance)} ETH (${balance / 1e18 * 2279:,.0f})")

    # Get code
    code = get_code(address)
    code_size = (len(code) - 2) // 2 if code.startswith("0x") else 0
    print(f"Code Size: {code_size} bytes")

    # Check for proxy pattern
    is_proxy = False
    if code_size < 100:
        # Very small code, likely minimal proxy
        print("  NOTE: Very small bytecode - could be minimal proxy")
        is_proxy = True
    elif "363d3d373d3d3d363d73" in code:
        print("  NOTE: Contains EIP-1167 clone pattern")
        is_proxy = True
    elif "5155" in code[:20]:
        print("  NOTE: Potential DELEGATECALL pattern")
        is_proxy = True

    # Probe functions
    print("\nProbing common functions...")
    results = probe_common_functions(address)

    if results:
        for name, value in results.items():
            if name in ['owner', 'admin', 'getOwner', 'pendingOwner']:
                # Try to decode as address
                if len(value) >= 66:
                    addr = "0x" + value[-40:]
                    print(f"  {name}: {addr}")
            elif name in ['implementation', 'getImplementation']:
                if len(value) >= 66:
                    impl = "0x" + value[-40:]
                    print(f"  {name}: {impl}")
            elif name in ['paused']:
                val = decode_uint256(value)
                print(f"  {name}: {val == 1}")
            elif name in ['totalSupply', 'balance', 'getBalance']:
                val = decode_uint256(value)
                print(f"  {name}: {format_ether(val)}")
            else:
                print(f"  {name}: {value[:66]}...")

    # Check for common withdrawal patterns
    print("\nChecking withdrawal functions...")

    withdrawal_functions = [
        ("withdraw(uint256)", [10**18]),  # Try withdrawing 1 ETH
        ("withdrawETH()", []),
        ("withdrawEther()", []),
        ("claim()", []),
        ("claimRewards()", []),
        ("exit()", []),
    ]

    for sig, args in withdrawal_functions:
        try:
            selector = get_function_selector(sig)
            if args:
                data = selector + encode(['uint256'], args).hex()
            else:
                data = selector
            result = eth_call(address, data)
            if result and result != "0x":
                print(f"  {sig}: Response received (may revert on execution)")
        except:
            pass

    return {
        'balance': balance,
        'code_size': code_size,
        'is_proxy': is_proxy,
        'functions': results
    }

def main():
    print("=" * 60)
    print("DEEP INVESTIGATION OF HIGH-VALUE TARGETS")
    print("=" * 60)

    # Interesting contracts from scan
    targets = [
        # Unverified high-value contracts
        ("0x795cbc7a670d06e56cd2197d4ca175e081a416ad", "Unverified $3.6M"),
        ("0x976ecc7c22c4917f93f351d712365f42d06dd1be", "Unverified $3.5M"),
        ("0xbb44e3349c23cc430cae6ebbaf0256c9f2a1872f", "Unverified $3.5M"),
        ("0xcddf488f1c826160ee832d4f1492f00cf8557ff6", "Unverified $3.4M"),
        ("0xe4657676423c9fcf899818b8e50195a0e3b2d3e3", "Unverified $2.8M"),
        ("0x8d15971781e935b07a84b9c888a1ad72628a30f1", "Unverified $2.3M"),

        # Named contracts of interest
        ("0x755cdba6ae4f479f7164792b318b2a06c759833b", "WithdrawDAO $3M"),
        ("0xa62142888aba8370742be823c1782d17a0389da1", "FoMo3Dlong $2.5M"),
        ("0x9fa8fa61a10ff892e4ebceb7f4e0fc684c2ce0a9", "HONG $2.3M"),
    ]

    results = []
    for address, name in targets:
        result = analyze_contract(address, name)
        result['address'] = address
        result['name'] = name
        results.append(result)

    print("\n" + "=" * 60)
    print("INVESTIGATION SUMMARY")
    print("=" * 60)

    for r in results:
        print(f"\n{r['name']}:")
        print(f"  Balance: {format_ether(r['balance'])} ETH")
        print(f"  Code Size: {r['code_size']} bytes")
        print(f"  Likely Proxy: {r['is_proxy']}")

        if r['functions']:
            interesting = []
            for fname, val in r['functions'].items():
                if fname in ['owner', 'admin', 'implementation']:
                    interesting.append(fname)
            if interesting:
                print(f"  Has: {', '.join(interesting)}")

    print("\n" + "=" * 60)
    print("RECOMMENDATIONS")
    print("=" * 60)
    print("""
1. Unverified contracts likely require reverse engineering
2. Most "Wallet" contracts are multisigs - require owner signatures
3. WithdrawDAO may be related to TheDAO hack recovery
4. FoMo3Dlong is an old Ponzi game - funds are user deposits
5. Need to check if any have permissionless withdrawal functions
""")

if __name__ == "__main__":
    main()
