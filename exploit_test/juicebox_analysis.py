#!/usr/bin/env python3
"""
Deep analysis of Juicebox TerminalV1 for exploit opportunities.

Juicebox is a programmable funding protocol where:
- Projects can receive contributions
- Projects configure funding cycles with rules
- Contributors receive project tokens
- Projects can have overflow (excess funds) that contributors can redeem

Looking for:
1. Flash loan + redemption attacks
2. Funding cycle timing exploits
3. Token minting/burning exploits
4. Price feed manipulation
5. Cross-protocol composition issues
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import json
import time

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

# Juicebox contracts
TERMINAL_V1 = "0xd569d3cce55b71a8a3f3c418c329a66e5f714431"

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        result = resp.json()
        if 'error' in result:
            return None
        return result.get("result", "0x")
    except:
        return None

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def decode_uint256(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return 0
    return int(hex_result[:66], 16)

def format_ether(wei):
    return f"{wei / 1e18:.4f}"

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def main():
    print("=" * 70)
    print("JUICEBOX TERMINALV1 DEEP ANALYSIS")
    print("=" * 70)

    # Get balance
    eth_bal = get_eth_balance(TERMINAL_V1)
    print(f"\nTerminalV1 ETH Balance: {format_ether(eth_bal)} ETH (${eth_bal / 1e18 * 2279:,.0f})")

    # Get source code
    source_data = get_contract_source(TERMINAL_V1)
    if source_data:
        source_code = source_data.get('SourceCode', '')
        print(f"Contract Name: {source_data.get('ContractName', 'Unknown')}")
        print(f"Compiler: {source_data.get('CompilerVersion', 'Unknown')}")
        print(f"Source length: {len(source_code)} chars")

        # Save source for analysis
        with open('juicebox_terminalv1.sol', 'w') as f:
            f.write(source_code)
        print("Source saved to juicebox_terminalv1.sol")

    # Check key state variables
    print("\n--- TERMINAL STATE ---")

    # Get Projects contract
    selector = get_function_selector("projects()")
    result = eth_call(TERMINAL_V1, selector)
    if result and len(result) >= 42:
        projects = "0x" + result[-40:]
        print(f"Projects: {projects}")

    # Get FundingCycles contract
    selector = get_function_selector("fundingCycles()")
    result = eth_call(TERMINAL_V1, selector)
    if result and len(result) >= 42:
        funding_cycles = "0x" + result[-40:]
        print(f"FundingCycles: {funding_cycles}")

    # Get TicketBooth contract
    selector = get_function_selector("ticketBooth()")
    result = eth_call(TERMINAL_V1, selector)
    if result and len(result) >= 42:
        ticket_booth = "0x" + result[-40:]
        print(f"TicketBooth: {ticket_booth}")

    # Get Directory
    selector = get_function_selector("directory()")
    result = eth_call(TERMINAL_V1, selector)
    if result and len(result) >= 42:
        directory = "0x" + result[-40:]
        print(f"Directory: {directory}")

    # Get Prices
    selector = get_function_selector("prices()")
    result = eth_call(TERMINAL_V1, selector)
    if result and len(result) >= 42:
        prices = "0x" + result[-40:]
        print(f"Prices: {prices}")

    # Analyze source code for vulnerabilities
    print("\n--- SOURCE CODE ANALYSIS ---")

    if source_code:
        # Look for key functions
        functions_of_interest = [
            'pay',
            'redeem',
            'tap',
            'configure',
            'printTickets',
            'migrate',
            '_recordPayment',
            '_recordRedemption'
        ]

        for func in functions_of_interest:
            if func in source_code:
                print(f"Function found: {func}")

        # Check for reentrancy guards
        has_nonreentrant = 'nonReentrant' in source_code
        has_reentrancy_guard = 'ReentrancyGuard' in source_code
        print(f"\nReentrancy protection: nonReentrant={has_nonreentrant}, ReentrancyGuard={has_reentrancy_guard}")

        # Check for oracle usage
        has_oracle = 'price' in source_code.lower() or 'oracle' in source_code.lower()
        has_chainlink = 'chainlink' in source_code.lower() or 'aggregator' in source_code.lower()
        print(f"Price feed: oracle={has_oracle}, chainlink={has_chainlink}")

        # Check for external calls before state changes
        print("\n--- CHECKING FOR VULNERABLE PATTERNS ---")

        lines = source_code.split('\n')
        for i, line in enumerate(lines):
            # Look for external calls
            if '.call' in line.lower() or 'transfer(' in line.lower() or 'send(' in line.lower():
                if not 'safeTransfer' in line:
                    print(f"Line {i+1}: External call - {line.strip()[:80]}")

            # Look for balance checks after transfers
            if 'balance' in line.lower() and i > 0:
                prev_line = lines[i-1]
                if 'transfer' in prev_line.lower() or 'call' in prev_line.lower():
                    print(f"Line {i+1}: Balance check after transfer - {line.strip()[:80]}")

    # VULNERABILITY HYPOTHESIS
    print("\n" + "=" * 70)
    print("VULNERABILITY HYPOTHESES")
    print("=" * 70)

    hypotheses = """
JUICEBOX V1 POTENTIAL ATTACK VECTORS:

1. FLASH LOAN + REDEMPTION
   - Deposit large amount to a project
   - Get tokens minted
   - If overflow calculation is wrong, redeem for more than deposited
   - Requires: token minting rate != redemption rate

2. FUNDING CYCLE TIMING
   - Projects have funding cycles with different rules
   - If cycle transition is not atomic, might be exploitable
   - Flash deposit at cycle boundary

3. PRICE FEED MANIPULATION (if used)
   - Juicebox might use external price feeds
   - Manipulate price, then interact with protocol
   - Need to check if Prices contract is actually used

4. CROSS-PROJECT MIGRATION
   - migrate() function moves funds between terminals
   - If source/destination terminals have different accounting...
   - Could create value out of thin air

5. TICKET PRINTING PRIVILEGES
   - printTickets() might allow privileged minting
   - Check if there's a way to get print privileges

6. OVERFLOW CALCULATION
   - overflow = total - target
   - If target can be manipulated during cycle
   - Might create artificial overflow

NEXT STEPS:
1. Read full source code for pay/redeem/tap functions
2. Check FundingCycles contract for timing windows
3. Analyze overflow calculation logic
4. Test on fork
"""
    print(hypotheses)

    # Check specific project balances
    print("\n" + "=" * 70)
    print("CHECKING ACTIVE PROJECTS")
    print("=" * 70)

    # Get balance of specific projects (would need to iterate)
    # For now, just check total

    print(f"Total ETH in TerminalV1: {format_ether(eth_bal)} ETH")

if __name__ == "__main__":
    main()
