#!/usr/bin/env python3
"""
Investigate the MarketingMiningDelegator implementation contract
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import json

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

IMPLEMENTATION = "0xab2cc3ab140e7596c5de18d1269ac39c53bd0db0"
PROXY = "0x0feccb11c5b61b3922c511d0f002c0b72d770dce"

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        result = resp.json()
        if 'error' in result:
            return None
        return result.get("result", "0x")
    except:
        return None

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def decode_address(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return None
    return "0x" + hex_result[-40:]

def decode_uint256(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return 0
    return int(hex_result[:66], 16)

def main():
    print("=" * 70)
    print("IMPLEMENTATION CONTRACT ANALYSIS")
    print("=" * 70)

    # Get implementation source
    source_data = get_contract_source(IMPLEMENTATION)
    if not source_data:
        print("No verified source for implementation!")
        return

    source_code = source_data.get('SourceCode', '')
    contract_name = source_data.get('ContractName', 'Unknown')
    print(f"Implementation: {contract_name}")

    if not source_code:
        print("Empty source")
        return

    with open('implementation_source.sol', 'w') as f:
        f.write(source_code)
    print(f"Source saved ({len(source_code)} chars)")

    lower = source_code.lower()

    # Find how getReserves is used
    print("\n--- getReserves USAGE ---")

    lines = source_code.split('\n')
    for i, line in enumerate(lines):
        if 'getreserves' in line.lower() and 'interface' not in lines[max(0,i-5):i+1].__str__().lower():
            print(f"\nLine {i}:")
            for j in range(max(0, i-5), min(len(lines), i+10)):
                print(f"  {j}: {lines[j][:100]}")

    # Find functions that have price calculations
    print("\n--- PRICE CALCULATIONS ---")

    for i, line in enumerate(lines):
        if 'price' in line.lower() and ('function' in line.lower() or 'return' in line.lower() or '=' in line):
            print(f"  {i}: {line.strip()[:100]}")

    # Find withdraw/extraction functions
    print("\n--- VALUE EXTRACTION FUNCTIONS ---")

    for i, line in enumerate(lines):
        if any(x in line.lower() for x in ['withdraw', 'claim', 'redeem', 'harvest']) and 'function' in line.lower():
            print(f"\n  Line {i}: {line.strip()}")
            # Get function body
            for j in range(i+1, min(len(lines), i+30)):
                print(f"    {j}: {lines[j][:100]}")
                if lines[j].strip() == '}' and lines[j].count('}') > lines[j].count('{'):
                    break

    # Check proxy state
    print("\n--- PROXY STATE ---")

    selectors = [
        ("miningToken()", "miningToken"),
        ("lpToken()", "lpToken"),
        ("rewardPerBlock()", "rewardPerBlock"),
        ("totalStaked()", "totalStaked"),
        ("pendingReward(address)", "pendingReward"),
        ("getPrice()", "getPrice"),
        ("uniswapPair()", "uniswapPair"),
        ("marketCap()", "marketCap"),
    ]

    for sig, desc in selectors:
        selector = get_function_selector(sig)
        # Call on proxy (uses delegatecall to implementation)
        if '(' in sig and sig.endswith('()'):
            result = eth_call(PROXY, selector)
        elif 'address' in sig:
            # Use zero address for view calls
            data = selector + encode(['address'], ["0x0000000000000000000000000000000000000001"]).hex()
            result = eth_call(PROXY, data)
        else:
            result = eth_call(PROXY, selector)

        if result and result != "0x" and len(result) > 10:
            if any(x in sig.lower() for x in ['token', 'pair']):
                addr = decode_address(result)
                if addr and addr != "0x" + "0" * 40:
                    print(f"  {desc}: {addr}")
            else:
                value = decode_uint256(result)
                if value > 0 or 'price' in desc.lower():
                    print(f"  {desc}: {value}")

    print("\n" + "=" * 70)
    print("EXPLOIT ANALYSIS")
    print("=" * 70)

if __name__ == "__main__":
    main()
