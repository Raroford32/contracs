#!/usr/bin/env python3
"""
Advanced search for cross-protocol composition vulnerabilities.

Focus areas:
1. Accounting divergence patterns (share/debt accounting)
2. Oracle staleness exploitation windows
3. Reward timing manipulation
4. Flash loan governance attacks
5. Liquidation mechanics exploitation
6. Rebasing token handling errors
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import time
import json
import re

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return resp.json().get("result", "0x")
    except:
        return "0x"

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def decode_uint256(hex_result):
    if hex_result == "0x" or not hex_result:
        return 0
    return int(hex_result, 16)

def format_ether(wei):
    return f"{wei / 1e18:.4f}"

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def analyze_for_vulnerabilities(source_code, contract_name):
    """Deep analysis for specific vulnerability patterns"""
    lower = source_code.lower()

    findings = {
        'contract': contract_name,
        'issues': [],
        'severity': 0
    }

    # 1. Check for accounting without reentrancy guard
    has_balance_update = 'balance' in lower and ('=' in source_code or '+=' in source_code or '-=' in source_code)
    has_shares = 'shares' in lower or 'totalshares' in lower
    has_external_call = '.call' in lower or '.transfer' in lower or 'safetransfer' in lower
    has_reentrancy = 'nonreentrant' in lower or 'reentrancyguard' in lower

    if has_balance_update and has_external_call and not has_reentrancy:
        findings['issues'].append({
            'type': 'ACCOUNTING_WITHOUT_GUARD',
            'desc': 'Balance/shares updated with external calls but no reentrancy guard',
            'severity': 2
        })
        findings['severity'] += 2

    # 2. Check for oracle usage without staleness check
    has_oracle = 'oracle' in lower or 'pricefeed' in lower or 'getprice' in lower
    has_chainlink = 'chainlink' in lower or 'aggregator' in lower or 'latestrounddata' in lower
    has_staleness_check = 'updatedat' in lower or 'timestamp' in lower and 'revert' in lower

    if has_oracle and has_chainlink and not has_staleness_check:
        findings['issues'].append({
            'type': 'ORACLE_NO_STALENESS',
            'desc': 'Oracle usage without apparent staleness check',
            'severity': 2
        })
        findings['severity'] += 2

    # 3. Check for flash loan vulnerabilities in governance
    has_governance = 'vote' in lower or 'proposal' in lower or 'delegate' in lower
    has_snapshot = 'snapshot' in lower or 'checkpoint' in lower or 'getpriorbalo' in lower
    has_block_check = 'block.number' in lower

    if has_governance and not has_snapshot and not has_block_check:
        findings['issues'].append({
            'type': 'GOVERNANCE_NO_SNAPSHOT',
            'desc': 'Governance without snapshot/block-based voting power',
            'severity': 3
        })
        findings['severity'] += 3

    # 4. Check for liquidation without proper checks
    has_liquidation = 'liquidat' in lower
    has_health_check = 'healthfactor' in lower or 'collateralratio' in lower or 'issolvent' in lower

    if has_liquidation and not has_health_check:
        findings['issues'].append({
            'type': 'LIQUIDATION_NO_HEALTH',
            'desc': 'Liquidation function without clear health check',
            'severity': 2
        })
        findings['severity'] += 2

    # 5. Check for reward distribution timing issues
    has_rewards = 'reward' in lower
    has_duration = 'duration' in lower or 'periodfinish' in lower or 'rewardrate' in lower
    has_timestamp = 'block.timestamp' in lower

    # Synthetix-style rewards with potential issues
    if has_rewards and 'rewardpershare' in lower:
        # Check for instant reward distribution (flash loan risk)
        if 'notifyrewardamount' in lower and 'duration' not in lower:
            findings['issues'].append({
                'type': 'INSTANT_REWARDS',
                'desc': 'Reward notification without duration period',
                'severity': 2
            })
            findings['severity'] += 2

    # 6. Check for unchecked return values on transfers
    has_transfer = 'transfer(' in lower or 'transferfrom(' in lower
    has_safeTransfer = 'safetransfer' in lower

    if has_transfer and not has_safeTransfer and 'require' not in lower:
        findings['issues'].append({
            'type': 'UNCHECKED_TRANSFER',
            'desc': 'Transfer calls without checking return value',
            'severity': 1
        })
        findings['severity'] += 1

    # 7. Check for rebasing token handling
    has_rebase = 'rebase' in lower or 'steth' in lower or 'atoken' in lower
    has_wrap = 'wrap' in lower or 'unwrap' in lower

    if has_rebase and not has_wrap:
        # May not handle rebasing correctly
        findings['issues'].append({
            'type': 'REBASE_NO_WRAP',
            'desc': 'Rebasing token used without wrapping mechanism',
            'severity': 1
        })
        findings['severity'] += 1

    # 8. Check for cross-protocol calls without validation
    cross_protocol_patterns = [
        ('aave', 'ipool' in lower or 'ilendingpool' in lower),
        ('compound', 'ictoken' in lower or 'comptroller' in lower),
        ('uniswap', 'iuniswap' in lower or 'iswaprouter' in lower),
        ('curve', 'icurve' in lower or 'curvepool' in lower),
        ('balancer', 'ibalancer' in lower or 'ivault' in lower),
    ]

    cross_protocol_count = sum(1 for _, found in cross_protocol_patterns if found)

    if cross_protocol_count >= 2:
        findings['issues'].append({
            'type': 'MULTI_PROTOCOL_INTEGRATION',
            'desc': f'Integrates with {cross_protocol_count} protocols - check for semantic mismatches',
            'severity': 2
        })
        findings['severity'] += 2

    # 9. Check for delegate call patterns (potential proxy issues)
    has_delegatecall = 'delegatecall' in lower
    has_proxy = 'proxy' in lower or 'implementation' in lower

    if has_delegatecall and not has_proxy:
        findings['issues'].append({
            'type': 'DELEGATECALL_NO_PROXY',
            'desc': 'Delegatecall without clear proxy pattern',
            'severity': 2
        })
        findings['severity'] += 2

    # 10. Check for withdrawal patterns with potential timing issues
    has_withdraw = 'withdraw' in lower
    has_cooldown = 'cooldown' in lower or 'delay' in lower or 'timelock' in lower

    if has_withdraw and has_shares and not has_cooldown and not has_reentrancy:
        findings['issues'].append({
            'type': 'INSTANT_WITHDRAWAL',
            'desc': 'Withdrawal without cooldown or reentrancy guard',
            'severity': 2
        })
        findings['severity'] += 2

    return findings

def main():
    print("=" * 70)
    print("ADVANCED CROSS-PROTOCOL COMPOSITION VULNERABILITY SEARCH")
    print("=" * 70)

    with open('/home/user/contracs/contracts.txt', 'r') as f:
        addresses = [line.strip() for line in f if line.strip().startswith('0x') and len(line.strip()) == 42]

    print(f"Total contracts: {len(addresses)}")

    # Focus on first 500 contracts (higher TVL)
    start_idx = 0
    end_idx = 500

    print(f"Analyzing contracts {start_idx}-{end_idx}")

    all_findings = []
    high_severity = []

    for i, addr in enumerate(addresses[start_idx:end_idx], start=start_idx):
        if i % 25 == 0:
            print(f"Progress: {i}/{end_idx}, found {len(high_severity)} high-severity")
            time.sleep(1)

        source = get_contract_source(addr)
        if not source:
            continue

        source_code = source.get('SourceCode', '')
        contract_name = source.get('ContractName', 'Unknown')

        if not source_code or len(source_code) < 500:
            continue

        findings = analyze_for_vulnerabilities(source_code, contract_name)
        findings['address'] = addr

        if findings['severity'] >= 2:
            all_findings.append(findings)

            # Get balance for context
            eth_bal = get_eth_balance(addr)

            if findings['severity'] >= 4 or (findings['severity'] >= 2 and eth_bal > 10**18):
                print(f"\n  HIGH SEVERITY: {contract_name} ({addr})")
                print(f"    ETH Balance: {format_ether(eth_bal)}")
                print(f"    Total Severity: {findings['severity']}")
                for issue in findings['issues']:
                    print(f"    - {issue['type']}: {issue['desc']}")

                findings['eth_balance'] = eth_bal
                high_severity.append(findings)

        time.sleep(0.2)

    print("\n" + "=" * 70)
    print("ANALYSIS COMPLETE")
    print("=" * 70)
    print(f"Analyzed {end_idx - start_idx} contracts")
    print(f"Found {len(all_findings)} with issues (severity >= 2)")
    print(f"Found {len(high_severity)} high severity")

    # Sort by severity
    high_severity.sort(key=lambda x: x['severity'], reverse=True)

    print("\n" + "=" * 70)
    print("TOP HIGH-SEVERITY FINDINGS")
    print("=" * 70)

    for f in high_severity[:20]:
        print(f"\n{f['contract']} ({f['address']})")
        print(f"  Severity: {f['severity']}, ETH: {format_ether(f.get('eth_balance', 0))}")
        for issue in f['issues']:
            print(f"  - {issue['type']}: {issue['desc']}")

    # Save results
    with open('advanced_findings.json', 'w') as f:
        json.dump({
            'all_findings': all_findings,
            'high_severity': high_severity
        }, f, indent=2)

    # Deep dive on most promising
    if high_severity:
        print("\n" + "=" * 70)
        print("DEEP DIVE ON MOST PROMISING TARGETS")
        print("=" * 70)

        for target in high_severity[:5]:
            print(f"\nAnalyzing: {target['contract']} ({target['address']})")

            # Check for specific exploitation paths
            source = get_contract_source(target['address'])
            if not source:
                continue

            source_code = source.get('SourceCode', '')

            # Look for specific patterns
            patterns_to_check = {
                'Flash loan entry': 'flashloan' in source_code.lower() or 'flashborrow' in source_code.lower(),
                'Callback function': 'callback' in source_code.lower() or 'hook' in source_code.lower(),
                'External price': 'getprice' in source_code.lower() or 'price()' in source_code.lower(),
                'Mint/Burn': 'mint' in source_code.lower() and 'burn' in source_code.lower(),
                'Swap function': 'swap' in source_code.lower(),
                'Deposit/Withdraw': 'deposit' in source_code.lower() and 'withdraw' in source_code.lower(),
            }

            for pattern, found in patterns_to_check.items():
                if found:
                    print(f"  {pattern}: YES")

if __name__ == "__main__":
    main()
