#!/usr/bin/env python3
"""
Deep probe of high-value unverified contracts.
Try to find permissionless withdrawal or extraction functions.
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import time

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"

# High-value unverified contracts from identification
UNVERIFIED_HIGH_VALUE = [
    ("0x4c766def136f59f6494f0969b1355882080cf8e0", 29879.63),
    ("0x111cff45948819988857bbf1966a0399e0d1141e", 20397.33),
    ("0x36eed1a4dd70f0731dd20ef76c32345185a8a042", 14810.21),
    ("0x10abe2494e4525f8cd2bac772671f0e1a44c6975", 10060.02),
    ("0x741a816aec3b183d29117bad0906f1f15233c360", 9811.30),
    ("0x88aa042c4aae423e0f1bb48542b473d1dd20a807", 9383.00),
    ("0x78f1dbb372cdd95d3a0dda99cf369e02e717f4f4", 9222.73),
    ("0xe4c00cfd4aa493ad890ef83ad9d643a788b17bd9", 7504.66),
    ("0x8e3a4a7208aa489cc0a1c7290070811b07e60c87", 5361.57),
    ("0x729488d15a1b397cbd96cc02e2803af64390f44c", 5241.24),
]

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data, sender=None):
    call_params = {"to": to, "data": data}
    if sender:
        call_params["from"] = sender

    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [call_params, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        result = resp.json()
        return result
    except Exception as e:
        return {"error": str(e)}

def get_code(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getCode",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return resp.json().get("result", "0x")
    except:
        return "0x"

def extract_selectors_from_bytecode(bytecode):
    """Extract 4-byte selectors from bytecode"""
    selectors = set()
    bytecode = bytecode.lower()

    # Look for PUSH4 (0x63) followed by 4 bytes
    i = 0
    while i < len(bytecode) - 10:
        if bytecode[i:i+2] == "63":
            selector = bytecode[i+2:i+10]
            if len(selector) == 8:
                selectors.add(selector)
        i += 2

    return selectors

# Common function signatures to probe
PROBE_FUNCTIONS = [
    # Ownership
    ("owner()", None),
    ("getOwner()", None),
    ("admin()", None),

    # Withdrawal - no params
    ("withdraw()", None),
    ("withdrawAll()", None),
    ("withdrawETH()", None),
    ("withdrawFunds()", None),
    ("claim()", None),
    ("claimAll()", None),
    ("exit()", None),
    ("drain()", None),
    ("emergencyWithdraw()", None),

    # With amount
    ("withdraw(uint256)", [10**18]),  # Try 1 ETH
    ("withdrawETH(uint256)", [10**18]),

    # With address
    ("withdraw(address)", ["0x0000000000000000000000000000000000000001"]),
    ("withdrawTo(address)", ["0x0000000000000000000000000000000000000001"]),

    # Proxy/Admin
    ("implementation()", None),
    ("pendingAdmin()", None),
    ("acceptAdmin()", None),

    # Balance
    ("balance()", None),
    ("getBalance()", None),
    ("balanceOf(address)", ["0x0000000000000000000000000000000000000001"]),

    # State
    ("paused()", None),
    ("active()", None),
    ("locked()", None),

    # Fallback test
    ("", None),  # Empty call
]

def probe_contract(address, eth_balance):
    """Deeply probe an unverified contract"""
    print(f"\n{'=' * 70}")
    print(f"PROBING: {address}")
    print(f"ETH Balance: {eth_balance:.2f} ETH (${eth_balance * 2279:,.0f})")
    print("=" * 70)

    # Get bytecode
    code = get_code(address)
    code_size = (len(code) - 2) // 2 if code.startswith("0x") else 0
    print(f"Code size: {code_size} bytes")

    if code_size == 0:
        print("No code at address (likely EOA or self-destructed)")
        return

    # Extract selectors from bytecode
    selectors = extract_selectors_from_bytecode(code[2:])
    print(f"Found {len(selectors)} potential selectors in bytecode")

    # Probe each function
    print("\n--- FUNCTION PROBING ---")

    found_functions = []

    for sig, params in PROBE_FUNCTIONS:
        selector = get_function_selector(sig) if sig else "0x"

        if params:
            if len(params) == 1 and isinstance(params[0], int):
                data = selector + encode(['uint256'], params).hex()
            elif len(params) == 1 and isinstance(params[0], str):
                data = selector + encode(['address'], [params[0]]).hex()
            else:
                data = selector
        else:
            data = selector

        result = eth_call(address, data)

        if 'error' not in result or result.get('result', '0x') != '0x':
            ret = result.get('result', 'error')
            if ret and ret != '0x' and len(ret) > 2:
                found_functions.append((sig, ret[:66] if len(ret) > 66 else ret))

                # Decode if possible
                if 'owner' in sig.lower() or 'admin' in sig.lower():
                    if len(ret) >= 66:
                        addr = "0x" + ret[-40:]
                        print(f"  {sig}: {addr}")
                elif 'balance' in sig.lower():
                    try:
                        val = int(ret, 16)
                        print(f"  {sig}: {val / 1e18:.4f}")
                    except:
                        print(f"  {sig}: {ret[:66]}")
                else:
                    print(f"  {sig}: responds (length={len(ret)})")

    # Try calling withdraw with different senders
    print("\n--- WITHDRAWAL PROBE ---")

    # Test addresses
    test_senders = [
        "0x0000000000000000000000000000000000000000",  # Zero address
        "0x0000000000000000000000000000000000000001",  # Address 1
        "0xdead000000000000000000000000000000000000",  # Dead address
    ]

    withdraw_functions = [
        ("withdraw()", None),
        ("withdrawAll()", None),
        ("claim()", None),
    ]

    for sig, params in withdraw_functions:
        selector = get_function_selector(sig)

        for sender in test_senders:
            result = eth_call(address, selector, sender=sender)

            if 'result' in result:
                ret = result['result']
                if ret and ret != '0x':
                    print(f"  {sig} from {sender[:10]}...: RESPONDS - {ret[:40]}")
            elif 'error' in result:
                err = result.get('error', {})
                if isinstance(err, dict):
                    msg = err.get('message', str(err))
                else:
                    msg = str(err)
                if 'revert' not in msg.lower():
                    print(f"  {sig} from {sender[:10]}...: {msg[:50]}")

    # Check for specific patterns in bytecode
    print("\n--- BYTECODE ANALYSIS ---")

    code_lower = code.lower()

    patterns = {
        'SELFDESTRUCT': 'ff' in code[-4:],  # SELFDESTRUCT opcode at end
        'DELEGATECALL': 'f4' in code_lower,  # DELEGATECALL opcode
        'CALL with value': 'f1' in code_lower,  # CALL opcode
        'SLOAD': '54' in code_lower,  # Storage read
        'SSTORE': '55' in code_lower,  # Storage write
    }

    for pattern, found in patterns.items():
        if found:
            print(f"  Contains {pattern}")

    # Return findings
    return {
        'address': address,
        'eth_balance': eth_balance,
        'code_size': code_size,
        'selectors': list(selectors)[:20],  # First 20
        'found_functions': found_functions
    }

def main():
    print("=" * 70)
    print("UNVERIFIED CONTRACT DEEP PROBE")
    print("=" * 70)

    results = []

    for address, eth_balance in UNVERIFIED_HIGH_VALUE:
        result = probe_contract(address, eth_balance)
        if result:
            results.append(result)
        time.sleep(1)

    # Summary
    print("\n" + "=" * 70)
    print("SUMMARY")
    print("=" * 70)

    for r in results:
        if r and r.get('found_functions'):
            print(f"\n{r['address']} ({r['eth_balance']:.2f} ETH):")
            for func, ret in r['found_functions'][:5]:
                print(f"  - {func}: {ret[:40]}...")

    print("""

ANALYSIS:
Most unverified high-value contracts are:
1. Multisig wallets (require multiple signatures)
2. Old ICO contracts (time-locked or claimed)
3. Exchange hot wallets (owner-controlled)
4. Abandoned/stuck contracts

Without source code, exploitation requires:
1. Finding permissionless withdrawal functions
2. Or finding bugs in the bytecode logic

These contracts are generally not exploitable without
privileged access (owner keys, multisig signers, etc.)
""")

if __name__ == "__main__":
    main()
