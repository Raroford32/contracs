#!/usr/bin/env python3
"""
Search for protocols vulnerable to frxETH/OETH pool read-only reentrancy.

These pools contain native ETH and could be exploited via read-only reentrancy
if protocols read virtual_price during a callback without protection.

Target pools:
- frxETH/ETH (0xa1F8A6807c402E4A15ef4EBa36528A3FED24E577)
- OETH/ETH (0x94B17476A93b3262d87B9a326965D1E91f9C13E7)
- ETH/stETH (0xDC24316b9AE028F1497c275EB9192a3Ea0f67022) - already checked
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import time
import json

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

# Curve pools with native ETH
ETH_POOLS = {
    'frxETH/ETH': '0xa1F8A6807c402E4A15ef4EBa36528A3FED24E577',
    'OETH/ETH': '0x94B17476A93b3262d87B9a326965D1E91f9C13E7',
    'stETH/ETH': '0xDC24316b9AE028F1497c275EB9192a3Ea0f67022',
    'cbETH/ETH': '0x5FAE7E604FC3e24fd43A72867ceBaC94c65b404A',
    'rETH/ETH': '0x0f3159811670c117c372428D4E69AC32325e4D0F',
    'ETH/sETH': '0xc5424B857f758E906013F3555Dad202e4bdB4567',
}

# LP tokens for these pools
LP_TOKENS = {
    'frxETH/ETH': '0xf43211935C781D5ca1a41d2041F397B8A7366C7A',  # frxETH-f
    'OETH/ETH': '0x94B17476A93b3262d87B9a326965D1E91f9C13E7',  # Same as pool (factory)
    'stETH/ETH': '0x06325440D014e39736583c165C2963BA99fAf14E',  # steCRV
}

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": "0x" + data if not data.startswith("0x") else data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return resp.json().get("result", "0x")
    except:
        return "0x"

def decode_uint256(hex_result):
    if hex_result == "0x" or not hex_result:
        return 0
    return int(hex_result, 16)

def format_ether(wei):
    return f"{wei / 1e18:.4f}"

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def check_pool_state(pool_name, pool_address):
    """Check current state of ETH pool"""
    print(f"\n--- {pool_name} ({pool_address}) ---")

    # Get ETH balance
    eth_bal = get_eth_balance(pool_address)
    print(f"  ETH Balance: {format_ether(eth_bal)} ETH (${eth_bal / 1e18 * 2279:,.0f})")

    # Get virtual price
    selector = get_function_selector("get_virtual_price()")
    result = eth_call(pool_address, selector)
    vp = decode_uint256(result)
    print(f"  Virtual Price: {format_ether(vp)}")

    # Get balances
    for i in range(2):
        selector = get_function_selector("balances(uint256)")
        data = selector[2:] + encode(['uint256'], [i]).hex()
        result = eth_call(pool_address, data)
        bal = decode_uint256(result)
        print(f"  Balance[{i}]: {format_ether(bal)}")

    return {
        'name': pool_name,
        'address': pool_address,
        'eth_balance': eth_bal,
        'virtual_price': vp
    }

def search_for_pool_integration(source_code, pool_addresses):
    """Check if source code references any ETH-containing pool"""
    lower = source_code.lower()

    results = {}
    for name, addr in pool_addresses.items():
        addr_lower = addr.lower()
        results[name] = {
            'direct_reference': addr_lower in lower,
            'virtual_price': 'get_virtual_price' in lower,
            'curve': 'curve' in lower or 'ICurve' in lower,
            'frxeth': 'frxeth' in lower,
            'oeth': 'oeth' in lower,
            'reth': 'reth' in lower,
            'cbeth': 'cbeth' in lower,
            'reentrancy_guard': 'nonReentrant' in source_code or 'ReentrancyGuard' in source_code,
        }

    return results

def main():
    print("=" * 70)
    print("frxETH/OETH/rETH POOL READ-ONLY REENTRANCY SEARCH")
    print("=" * 70)

    # Check all ETH-containing pools
    print("\n" + "=" * 70)
    print("CHECKING ETH-CONTAINING CURVE POOLS")
    print("=" * 70)

    pool_states = []
    for name, addr in ETH_POOLS.items():
        state = check_pool_state(name, addr)
        pool_states.append(state)
        time.sleep(0.5)

    # Sort by TVL
    pool_states.sort(key=lambda x: x['eth_balance'], reverse=True)

    print("\n" + "=" * 70)
    print("POOLS RANKED BY ETH TVL")
    print("=" * 70)
    for p in pool_states:
        print(f"  {p['name']}: {format_ether(p['eth_balance'])} ETH (${p['eth_balance'] / 1e18 * 2279:,.0f})")

    # Known protocols that might integrate with these pools
    known_protocols = [
        # Frax ecosystem
        ('Frax Finance', '0xB1748C79709f4Ba2Dd82834B8c82D4a505003f27'),
        ('Frax Ferry', '0x5E8422345238F34275888049021821E8E08CAa1f'),

        # Origin protocol (OETH)
        ('Origin OETH Vault', '0x39254033945AA2E4809Cc2977E7087BEE48bd7Ab'),
        ('Origin Harvester', '0x21Fb5812D70B3396880D30e90D9e5C1202266c89'),

        # Convex (likely has guards but check)
        ('Convex frxETH', '0x4659d5fF63A1E1EDD6D5DD9CC315e063c95947d0'),
        ('Convex OETH', '0x24b65DC1cf053A8D96872c323d29e86ec43eB33A'),

        # Yearn
        ('Yearn frxETH', '0xa258C4606Ca8206D8aA700cE2143D7db854D168c'),

        # Lending protocols
        ('Silo Finance', '0x6543ee07Cf5Dd7Ad17AeECF22ba75860ef3bBBa8'),
        ('Sturdy Finance', '0xA422CA380bd70EeF876292839222159E41AAEe17'),

        # Other DeFi
        ('Prisma Finance', '0x3de3dFF14E75c093649F6e8F846b2D6b23fEB85a'),
        ('Morpho', '0x9D03bb2092270648d7480049d0E58d2FcF0E5123'),
    ]

    print("\n" + "=" * 70)
    print("CHECKING KNOWN PROTOCOL INTEGRATIONS")
    print("=" * 70)

    vulnerable = []

    for name, address in known_protocols:
        print(f"\n--- {name} ({address}) ---")

        source = get_contract_source(address)
        if not source:
            print("  No source code found")
            continue

        source_code = source.get('SourceCode', '')
        contract_name = source.get('ContractName', 'Unknown')

        if not source_code:
            print("  Source code empty")
            continue

        print(f"  Contract: {contract_name}")

        # Check for pool integrations
        integrations = search_for_pool_integration(source_code, ETH_POOLS)

        has_integration = False
        for pool_name, checks in integrations.items():
            if checks['direct_reference'] or (checks['virtual_price'] and any([
                checks['frxeth'], checks['oeth'], checks['reth'], checks['cbeth']
            ])):
                has_integration = True
                print(f"  Integrates with: {pool_name}")
                print(f"    Reads virtual_price: {checks['virtual_price']}")
                print(f"    Has reentrancy guard: {checks['reentrancy_guard']}")

                if checks['virtual_price'] and not checks['reentrancy_guard']:
                    print(f"  !!! POTENTIALLY VULNERABLE !!!")
                    vulnerable.append({
                        'protocol': name,
                        'address': address,
                        'contract': contract_name,
                        'pool': pool_name
                    })

        if not has_integration:
            print("  No direct pool integration found")

        time.sleep(1)  # Rate limit

    # Search contracts.txt
    print("\n" + "=" * 70)
    print("SEARCHING CONTRACTS.TXT FOR ETH POOL INTEGRATIONS")
    print("=" * 70)

    with open('/home/user/contracs/contracts.txt', 'r') as f:
        addresses = [line.strip() for line in f if line.strip().startswith('0x') and len(line.strip()) == 42]

    # Focus on contracts 1200-1568 (not yet checked)
    start_idx = 1200
    end_idx = min(1568, len(addresses))

    print(f"Checking contracts {start_idx}-{end_idx}")

    checked = 0
    for i, addr in enumerate(addresses[start_idx:end_idx], start=start_idx):
        if i % 50 == 0:
            print(f"Progress: {i}/{end_idx}, found {len(vulnerable)} potentially vulnerable")
            time.sleep(1)

        source = get_contract_source(addr)
        if not source:
            continue

        source_code = source.get('SourceCode', '')
        if not source_code:
            continue

        checked += 1

        # Check for ETH pool patterns
        lower = source_code.lower()

        has_virtual_price = 'get_virtual_price' in lower
        has_eth_pool_ref = any(pool_addr.lower() in lower for pool_addr in ETH_POOLS.values())
        has_lsd_ref = any(x in lower for x in ['frxeth', 'oeth', 'reth', 'cbeth', 'steth'])
        has_reentrancy_guard = 'nonReentrant' in source_code or 'ReentrancyGuard' in source_code

        if has_virtual_price and (has_eth_pool_ref or has_lsd_ref):
            contract_name = source.get('ContractName', 'Unknown')

            if not has_reentrancy_guard:
                print(f"\n  FOUND: {contract_name} ({addr})")
                print(f"    Virtual price: {has_virtual_price}")
                print(f"    ETH pool ref: {has_eth_pool_ref}")
                print(f"    LSD ref: {has_lsd_ref}")
                print(f"    Reentrancy guard: {has_reentrancy_guard}")

                vulnerable.append({
                    'protocol': contract_name,
                    'address': addr,
                    'contract': contract_name,
                    'pool': 'Unknown ETH pool'
                })

        time.sleep(0.2)  # Rate limit

    print("\n" + "=" * 70)
    print("SEARCH COMPLETE")
    print("=" * 70)
    print(f"Checked {checked} contracts from index {start_idx}-{end_idx}")
    print(f"Found {len(vulnerable)} potentially vulnerable")

    if vulnerable:
        print("\nPOTENTIALLY VULNERABLE CONTRACTS:")
        for v in vulnerable:
            print(f"  - {v['protocol']} ({v['address']})")
            print(f"    Pool: {v['pool']}")

    # Save results
    with open('frxeth_oeth_vulnerable.json', 'w') as f:
        json.dump(vulnerable, f, indent=2)

    print("""

EXPLOITATION THEORY FOR ETH-CONTAINING POOLS:

1. Attacker has LP tokens in ETH-containing Curve pool
2. Attacker calls remove_liquidity_one_coin(amt, 0, min) to withdraw ETH
3. During ETH transfer (receive() callback), state is inconsistent:
   - total_supply reduced
   - balances NOT yet reduced
   - virtual_price = sum(balances) / total_supply is INFLATED
4. In callback, attacker interacts with vulnerable protocol
5. Protocol reads inflated virtual_price
6. Attacker gets more value (borrow more, liquidate positions, etc.)
7. Transaction completes, state normalizes

REQUIREMENTS:
1. Protocol MUST read virtual_price from an ETH-containing pool
2. Protocol MUST NOT have reentrancy protection
3. Protocol MUST allow meaningful action based on price
4. Profit > gas + flash loan fees
""")

if __name__ == "__main__":
    main()
