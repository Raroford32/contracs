#!/usr/bin/env python3
"""
Scan contracts 1200-1568 for high-value and vulnerable contracts.
Focus on: newer protocols, cross-protocol interactions, unusual patterns.
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import time
import json

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        result = resp.json()
        if 'error' in result:
            return None
        return result.get("result", "0x")
    except:
        return None

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def analyze_for_advanced_vulns(source_code, contract_name):
    """Look for advanced vulnerability patterns"""
    lower = source_code.lower()
    findings = []

    # Cross-protocol composition
    protocols = ['uniswap', 'aave', 'compound', 'curve', 'balancer', 'maker', 'chainlink']
    found_protocols = [p for p in protocols if p in lower]
    if len(found_protocols) >= 2:
        findings.append(f"MULTI_PROTOCOL: Uses {', '.join(found_protocols)}")

    # Flash loan callbacks
    if 'flashloan' in lower or 'flash' in lower:
        if 'callback' in lower or 'receive' in lower:
            findings.append("FLASH_CALLBACK: Has flash loan callback")

    # Price manipulation vectors
    if 'getreserves' in lower and 'swap' in lower:
        findings.append("RESERVE_READ: Reads reserves and swaps (potential manipulation)")

    # Cross-chain patterns
    if 'bridge' in lower or 'l2' in lower or 'arbitrum' in lower or 'optimism' in lower:
        findings.append("CROSS_CHAIN: Has cross-chain functionality")

    # Reward/incentive timing
    if 'reward' in lower and ('rate' in lower or 'duration' in lower):
        if 'pertoken' not in lower and 'rewardpetoken' not in lower:
            findings.append("REWARD_TIMING: May have reward timing issues")

    # Custom oracle
    if 'oracle' in lower and 'update' in lower:
        if 'chainlink' not in lower:
            findings.append("CUSTOM_ORACLE: Uses custom oracle (not Chainlink)")

    # Governance without timelock
    if 'governance' in lower or 'proposal' in lower or 'vote' in lower:
        if 'timelock' not in lower and 'delay' not in lower:
            findings.append("GOV_NO_TIMELOCK: Governance without timelock")

    # Permit signatures
    if 'permit' in lower and 'deadline' in lower:
        if 'nonces' not in lower:
            findings.append("PERMIT_NO_NONCE: Permit without nonce tracking")

    # Delegate call patterns
    if 'delegatecall' in lower:
        if 'implementation' in lower and 'upgrade' in lower:
            findings.append("UPGRADEABLE: Upgradeable proxy pattern")

    # Emergency functions
    if 'emergency' in lower and ('withdraw' in lower or 'rescue' in lower):
        findings.append("EMERGENCY: Has emergency withdrawal")

    # Merkle proofs (airdrops, claims)
    if 'merkle' in lower and 'proof' in lower:
        findings.append("MERKLE: Uses Merkle proofs (airdrop/claim)")

    return findings

def main():
    print("=" * 70)
    print("SCANNING CONTRACTS 1200-1568 FOR ADVANCED VULNERABILITIES")
    print("=" * 70)

    # Read contracts
    with open('/home/user/contracs/contracts.txt', 'r') as f:
        all_contracts = [line.strip() for line in f if line.strip().startswith('0x')]

    # Focus on contracts 1200-1568
    contracts = all_contracts[1200:1568]

    high_value = []
    vulnerable = []

    print(f"\nAnalyzing {len(contracts)} contracts...")

    for i, address in enumerate(contracts):
        if i % 50 == 0:
            print(f"\nProgress: {i}/{len(contracts)}")

        # Get ETH balance
        eth_bal = get_eth_balance(address)
        eth_value = eth_bal / 1e18

        # Skip very low value unless we want to find patterns
        if eth_value < 5:
            continue

        # Track high value
        if eth_value > 50:
            high_value.append({'address': address, 'eth': eth_value})
            print(f"  HIGH VALUE: {address[:10]}... - {eth_value:.2f} ETH")

        # Get source code
        source_data = get_contract_source(address)
        time.sleep(0.25)

        if not source_data:
            continue

        source_code = source_data.get('SourceCode', '')
        contract_name = source_data.get('ContractName', 'Unknown')

        if not source_code:
            continue

        # Analyze for vulnerabilities
        findings = analyze_for_advanced_vulns(source_code, contract_name)

        if findings:
            vulnerable.append({
                'address': address,
                'name': contract_name,
                'eth': eth_value,
                'findings': findings
            })
            print(f"\n{contract_name} ({address[:10]}...)")
            print(f"  ETH: {eth_value:.2f} (${eth_value * 2279:,.0f})")
            for f in findings:
                print(f"  -> {f}")

    # Summary
    print("\n" + "=" * 70)
    print("SUMMARY")
    print("=" * 70)

    print(f"\nHigh-value contracts (>50 ETH): {len(high_value)}")
    high_value.sort(key=lambda x: x['eth'], reverse=True)
    for c in high_value[:15]:
        print(f"  {c['address']}: {c['eth']:.2f} ETH")

    print(f"\nContracts with potential vulnerabilities: {len(vulnerable)}")
    vulnerable.sort(key=lambda x: x['eth'], reverse=True)
    for c in vulnerable[:20]:
        print(f"\n  {c['name']} ({c['address'][:10]}...)")
        print(f"    ETH: {c['eth']:.2f}")
        for f in c['findings']:
            print(f"    - {f}")

    # Save
    with open('scan_1200_1568_results.json', 'w') as f:
        json.dump({
            'high_value': high_value,
            'vulnerable': vulnerable
        }, f, indent=2)

    print("\nResults saved to scan_1200_1568_results.json")

if __name__ == "__main__":
    main()
