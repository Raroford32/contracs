#!/usr/bin/env python3
"""
Bytecode analysis of unverified high-value contract
"""

import requests
from eth_utils import keccak

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"

def get_code(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getCode",
        "params": [address, "latest"],
        "id": 1
    }
    resp = requests.post(RPC_URL, json=payload, timeout=30)
    return resp.json().get("result", "0x")

def get_function_selector(sig):
    return keccak(text=sig).hex()[:8]

# Common function signatures to search for
FUNCTION_SIGS = {
    # Ownership
    "owner()": "8da5cb5b",
    "getOwner()": "893d20e8",
    "transferOwnership(address)": "f2fde38b",
    "renounceOwnership()": "715018a6",

    # Withdrawal
    "withdraw()": "3ccfd60b",
    "withdraw(uint256)": "2e1a7d4d",
    "withdraw(address,uint256)": "f3fef3a3",
    "withdrawETH()": "690d8320",
    "withdrawAll()": "853828b6",
    "withdrawFunds()": "24600fc3",
    "claimFunds()": "0b0f7c0b",
    "emergencyWithdraw()": "db2e21bc",
    "emergencyWithdraw(address)": "5312ea8e",

    # ERC20 related
    "transfer(address,uint256)": "a9059cbb",
    "balanceOf(address)": "70a08231",
    "totalSupply()": "18160ddd",

    # Admin/Pause
    "pause()": "8456cb59",
    "unpause()": "3f4ba83a",
    "paused()": "5c975abb",

    # Proxy
    "implementation()": "5c60da1b",
    "upgradeTo(address)": "3659cfe6",

    # Multisig
    "submitTransaction(address,uint256,bytes)": "c6427474",
    "confirmTransaction(uint256)": "c01a8c84",
    "executeTransaction(uint256)": "ee22610b",
    "owners(uint256)": "025e7c27",
    "required()": "dc8452cd",

    # Fallback related
    "receive()": "",  # No selector
    "fallback()": "",  # No selector

    # Storage reading
    "getBalance()": "12065fe0",
    "balance()": "b69ef8a8",

    # Other common
    "initialize()": "8129fc1c",
    "init()": "e1c7392a",
    "setup()": "b95d9a9f",
    "kill()": "41c0e1b5",
    "destroy()": "83197ef0",
    "selfdestruct(address)": "ff",  # Special opcode

    # Deposit
    "deposit()": "d0e30db0",
    "depositETH()": "f6326fb3",
}

def extract_selectors_from_bytecode(bytecode):
    """Extract potential function selectors from bytecode"""
    # Look for PUSH4 (0x63) followed by 4 bytes
    selectors = set()
    bytecode = bytecode.lower()

    i = 0
    while i < len(bytecode) - 10:
        # Look for common patterns that indicate function selector matching
        # EQ (14) after PUSH4 (63) indicates comparison
        if bytecode[i:i+2] == "63":
            # PUSH4 found, extract next 4 bytes
            selector = bytecode[i+2:i+10]
            if len(selector) == 8:
                selectors.add(selector)
        i += 2

    return selectors

def match_selectors(found_selectors, known_sigs):
    """Match found selectors against known function signatures"""
    matches = []
    for sig, selector in known_sigs.items():
        if selector and selector in found_selectors:
            matches.append((sig, selector))
    return matches

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": "0x" + data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=30)
        return resp.json().get("result", "0x")
    except:
        return "0x"

def main():
    # Target: Unverified contract with owner() function and $3.5M
    TARGET = "0xbb44e3349c23cc430cae6ebbaf0256c9f2a1872f"

    print("=" * 60)
    print("BYTECODE ANALYSIS")
    print(f"Target: {TARGET}")
    print("=" * 60)

    # Get bytecode
    bytecode = get_code(TARGET)
    print(f"\nBytecode length: {len(bytecode)} chars ({(len(bytecode)-2)//2} bytes)")

    # Extract selectors
    selectors = extract_selectors_from_bytecode(bytecode[2:])  # Remove 0x prefix
    print(f"Found {len(selectors)} potential selectors")

    # Match against known signatures
    matches = match_selectors(selectors, FUNCTION_SIGS)

    if matches:
        print("\nMatched function signatures:")
        for sig, selector in matches:
            print(f"  0x{selector}: {sig}")
    else:
        print("\nNo exact matches found in known signatures")

    # Print all found selectors
    print("\nAll found selectors:")
    for sel in sorted(selectors):
        # Try to identify
        name = "Unknown"
        for sig, known_sel in FUNCTION_SIGS.items():
            if known_sel == sel:
                name = sig
                break
        print(f"  0x{sel}: {name}")

    # Try calling interesting functions
    print("\n" + "=" * 60)
    print("FUNCTION PROBING")
    print("=" * 60)

    # Try known selectors
    test_selectors = [
        ("owner()", "8da5cb5b"),
        ("withdraw()", "3ccfd60b"),
        ("withdrawAll()", "853828b6"),
        ("paused()", "5c975abb"),
        ("required()", "dc8452cd"),
        ("getBalance()", "12065fe0"),
        ("balance()", "b69ef8a8"),
        ("owners(uint256)", "025e7c27"),  # owners(0)
    ]

    for sig, selector in test_selectors:
        data = selector
        if "uint256" in sig:
            data += "0" * 64  # Add parameter = 0

        result = eth_call(TARGET, data)
        if result and result != "0x":
            print(f"\n{sig}:")
            print(f"  Result: {result}")

            # Try to decode
            if len(result) >= 66:
                if "address" in sig.lower() or sig == "owner()":
                    addr = "0x" + result[-40:]
                    print(f"  Decoded: {addr}")
                else:
                    val = int(result, 16)
                    print(f"  Decoded: {val}")

    # Check for dangerous functions that might be callable
    print("\n" + "=" * 60)
    print("DANGER ZONE - Testing withdrawal functions")
    print("=" * 60)
    print("(Using eth_call only - won't actually execute)")

    danger_funcs = [
        ("withdraw()", "3ccfd60b"),
        ("emergencyWithdraw()", "db2e21bc"),
        ("kill()", "41c0e1b5"),
        ("destroy()", "83197ef0"),
    ]

    for sig, selector in danger_funcs:
        result = eth_call(TARGET, selector)
        if result and result != "0x":
            print(f"\n{sig} returned: {result}")
            if result == "0x0000000000000000000000000000000000000000000000000000000000000001":
                print("  WARNING: Function may be callable!")
        elif result == "0x":
            # Check if it reverts with message
            print(f"\n{sig}: Reverted (likely access controlled)")

if __name__ == "__main__":
    main()
