#!/usr/bin/env python3
"""
Deep analysis of Abracadabra (MIM) protocol for Curve LP collateral exploitation.

Abracadabra allows borrowing MIM against various collateral types including Curve LP tokens.
If a cauldron uses Curve LP as collateral and reads virtual_price for valuation,
it could be exploited via read-only reentrancy.
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import json

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

# Known Abracadabra cauldrons with Curve LP collateral
CAULDRONS = [
    ('yvCRV-stETH', '0x6Ff9061bB8f97d948942cEF376d98b51fA38B91f'),
    ('yvCRV-3Crypto', '0x7b7473a76D6ae86CE19f7352A1E89F6C9dc39020'),
    ('yvCRV-MIM', '0x551a7CfF4de931F32893c928bBc3D25bF1Fc5147'),
    ('cvx3pool', '0x806e16ec797c69afa8590A55723CE4CC1b54050E'),
    ('cvxTricrypto2', '0x4EAeD76C3A388f4a841E9c765560BBe7B3E4B3A0'),
    ('cvxRenWBTC', '0x35a0Dd182E4bCa59d5931eae13D0A2332fA30321'),
    ('MIM-3LP3CRV', '0x9D3a8dFec6eA0FF8A0c4f1a31E22E4De45a7e2aA'),
]

# DegenBox (BentoBox fork used by Abracadabra)
DEGENBOX = '0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce'

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": "0x" + data if not data.startswith("0x") else data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return resp.json().get("result", "0x")
    except:
        return "0x"

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def get_function_selector(sig):
    return keccak(text=sig).hex()[:8]

def decode_uint256(hex_result):
    if hex_result == "0x" or not hex_result:
        return 0
    try:
        return int(hex_result, 16)
    except:
        return 0

def format_ether(wei):
    return f"{wei / 1e18:.4f}"

def get_token_balance(token, account):
    selector = get_function_selector("balanceOf(address)")
    data = selector + encode(['address'], [account]).hex()
    result = eth_call(token, data)
    return decode_uint256(result)

def analyze_cauldron(name, address):
    """Deep analyze a cauldron for exploit potential"""
    print(f"\n{'=' * 60}")
    print(f"ANALYZING: {name}")
    print(f"Address: {address}")
    print('=' * 60)

    # Get collateral token
    selector = get_function_selector("collateral()")
    result = eth_call(address, selector)
    collateral = "0x" + result[-40:] if result and len(result) >= 42 else None
    print(f"\nCollateral: {collateral}")

    if collateral:
        # Get collateral balance in DegenBox
        selector = get_function_selector("balanceOf(address,address)")
        data = selector + encode(['address', 'address'], [collateral, address]).hex()
        result = eth_call(DEGENBOX, data)
        collateral_bal = decode_uint256(result)
        print(f"Collateral in DegenBox: {format_ether(collateral_bal)}")

    # Get MIM token address
    selector = get_function_selector("magicInternetMoney()")
    result = eth_call(address, selector)
    mim = "0x" + result[-40:] if result and len(result) >= 42 else None
    print(f"MIM Token: {mim}")

    # Get oracle
    selector = get_function_selector("oracle()")
    result = eth_call(address, selector)
    oracle = "0x" + result[-40:] if result and len(result) >= 42 else None
    print(f"Oracle: {oracle}")

    if oracle:
        # Try to get price from oracle
        selector = get_function_selector("peekSpot(bytes)")
        data = selector + encode(['bytes'], [b'']).hex()
        result = eth_call(oracle, data)
        if result and result != "0x":
            price = decode_uint256(result)
            print(f"Oracle Spot Price: {format_ether(price)}")

    # Get total borrowed
    selector = get_function_selector("totalBorrow()")
    result = eth_call(address, selector)
    if result and len(result) >= 130:
        try:
            decoded = decode(['uint128', 'uint128'], bytes.fromhex(result[2:]))
            elastic = decoded[0]
            base = decoded[1]
            print(f"Total Borrow Elastic: {format_ether(elastic)} MIM")
            print(f"Total Borrow Base: {format_ether(base)}")
        except:
            pass

    # Get exchange rate (used for collateral valuation)
    selector = get_function_selector("exchangeRate()")
    result = eth_call(address, selector)
    if result and result != "0x":
        exchange_rate = decode_uint256(result)
        print(f"Exchange Rate: {exchange_rate}")

    # Check if accrueInfo is available
    selector = get_function_selector("accrueInfo()")
    result = eth_call(address, selector)
    if result and result != "0x" and len(result) >= 130:
        try:
            decoded = decode(['uint64', 'uint128', 'uint64'], bytes.fromhex(result[2:]))
            interest_per_second = decoded[0]
            last_accrue = decoded[1]
            fees_earned = decoded[2]
            print(f"Interest Per Second: {interest_per_second}")
            print(f"Last Accrue: {last_accrue}")
            print(f"Fees Earned: {fees_earned}")
        except:
            pass

    # Check liquidation parameters
    selector = get_function_selector("LIQUIDATION_MULTIPLIER()")
    result = eth_call(address, selector)
    if result and result != "0x":
        liq_mult = decode_uint256(result)
        print(f"Liquidation Multiplier: {liq_mult}")

    selector = get_function_selector("COLLATERIZATION_RATE()")
    result = eth_call(address, selector)
    if result and result != "0x":
        collat_rate = decode_uint256(result)
        print(f"Collateralization Rate: {collat_rate}")

    return {
        'name': name,
        'address': address,
        'collateral': collateral,
        'oracle': oracle,
    }

def check_oracle_for_curve_dependency(oracle_address):
    """Check if oracle reads from Curve"""
    print(f"\n  Checking oracle {oracle_address} for Curve dependency...")

    # Get oracle source
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={oracle_address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            source = data['result'][0].get('SourceCode', '')
            name = data['result'][0].get('ContractName', 'Unknown')
            print(f"  Oracle Contract: {name}")

            # Check for Curve patterns
            patterns = {
                'virtual_price': 'get_virtual_price' in source.lower() or 'virtualPrice' in source,
                'curve': 'curve' in source.lower() or 'ICurve' in source,
                'reentrancy_guard': 'nonReentrant' in source or 'ReentrancyGuard' in source,
            }

            for pattern, found in patterns.items():
                print(f"    {pattern}: {found}")

            if patterns['virtual_price'] and not patterns['reentrancy_guard']:
                print(f"  !!! POTENTIAL VULNERABILITY: Oracle reads virtual_price without reentrancy guard !!!")
                return True
    except Exception as e:
        print(f"  Error checking oracle: {e}")

    return False

def main():
    print("=" * 70)
    print("ABRACADABRA PROTOCOL DEEP ANALYSIS")
    print("Searching for Curve LP read-only reentrancy exploitation")
    print("=" * 70)

    # Check DegenBox balance
    degenbox_bal = get_eth_balance(DEGENBOX)
    print(f"\nDegenBox ETH Balance: {format_ether(degenbox_bal)} ETH")

    # Analyze each cauldron
    vulnerable_cauldrons = []

    for name, address in CAULDRONS:
        info = analyze_cauldron(name, address)

        if info['oracle']:
            is_vulnerable = check_oracle_for_curve_dependency(info['oracle'])
            if is_vulnerable:
                vulnerable_cauldrons.append(info)

    print("\n" + "=" * 70)
    print("ANALYSIS SUMMARY")
    print("=" * 70)

    if vulnerable_cauldrons:
        print(f"\nFound {len(vulnerable_cauldrons)} potentially vulnerable cauldrons:")
        for v in vulnerable_cauldrons:
            print(f"  - {v['name']} ({v['address']})")
    else:
        print("\nNo vulnerable cauldrons found with Curve dependency in oracles")

    print("""
EXPLOITATION REQUIREMENTS:
1. Cauldron uses Curve LP as collateral
2. Oracle reads Curve virtual_price without reentrancy protection
3. Sufficient liquidity in the cauldron to borrow against
4. Price manipulation through remove_liquidity_one_coin callback

NEXT STEPS:
1. If vulnerable oracle found, build Foundry PoC
2. Calculate manipulation cost vs profit
3. Execute on fork
""")

if __name__ == "__main__":
    main()
