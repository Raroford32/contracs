#!/usr/bin/env python3
"""
Reward Timing Analysis
Checks for flash stake opportunities in Convex pools
"""

import json
import requests
from eth_abi import decode, encode
from eth_utils import keccak, to_checksum_address
import time

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"

CONVEX_BOOSTER = "0xF403C135812408BFbE8713b5A23a04b3D48AAE31"

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    resp = requests.post(RPC_URL, json=payload, timeout=30)
    return resp.json().get("result", "0x")

def get_block_number():
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_blockNumber",
        "params": [],
        "id": 1
    }
    resp = requests.post(RPC_URL, json=payload, timeout=30)
    return int(resp.json().get("result", "0x0"), 16)

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def decode_uint256(hex_result):
    if hex_result == "0x" or not hex_result:
        return 0
    return int(hex_result, 16)

def query_pool_info(pool_id):
    selector = get_function_selector("poolInfo(uint256)")
    data = selector + encode(['uint256'], [pool_id]).hex()
    result = eth_call(CONVEX_BOOSTER, data)
    if result == "0x" or len(result) < 130:
        return None
    try:
        decoded = decode(['address', 'address', 'address', 'address', 'address', 'bool'], bytes.fromhex(result[2:]))
        return {
            'lptoken': decoded[0],
            'token': decoded[1],
            'gauge': decoded[2],
            'crvRewards': decoded[3],
            'stash': decoded[4],
            'shutdown': decoded[5]
        }
    except:
        return None

def query_reward_pool_detailed(reward_pool):
    """Query detailed reward pool state"""
    info = {}

    queries = {
        'periodFinish': 'periodFinish()',
        'rewardRate': 'rewardRate()',
        'queuedRewards': 'queuedRewards()',
        'currentRewards': 'currentRewards()',
        'historicalRewards': 'historicalRewards()',
        'totalSupply': 'totalSupply()',
        'lastUpdateTime': 'lastUpdateTime()',
        'rewardPerTokenStored': 'rewardPerTokenStored()',
        'duration': 'duration()',
        'extraRewardsLength': 'extraRewardsLength()'
    }

    for name, sig in queries.items():
        selector = get_function_selector(sig)
        result = eth_call(reward_pool, selector)
        info[name] = decode_uint256(result)

    return info

def format_ether(wei):
    return f"{wei / 1e18:.4f}"

def main():
    print("=" * 60)
    print("REWARD TIMING ANALYSIS - Flash Stake Opportunities")
    print("=" * 60)

    current_block = get_block_number()
    print(f"Current block: {current_block}")

    # High-value pools identified from previous analysis
    high_value_pools = [40, 64, 106, 144, 169]

    print("\n--- ANALYZING HIGH-VALUE POOLS ---")

    for pool_id in high_value_pools:
        pool = query_pool_info(pool_id)
        if not pool or pool['shutdown']:
            continue

        crv_rewards = pool['crvRewards']
        if crv_rewards == "0x0000000000000000000000000000000000000000":
            continue

        print(f"\n=== POOL {pool_id} ===")
        print(f"LP Token: {pool['lptoken']}")
        print(f"Reward Pool: {crv_rewards}")

        info = query_reward_pool_detailed(crv_rewards)

        print(f"\nReward State:")
        print(f"  Total Staked: {format_ether(info['totalSupply'])} LP")
        print(f"  Queued Rewards: {format_ether(info['queuedRewards'])} CRV")
        print(f"  Current Rewards: {format_ether(info['currentRewards'])} CRV")
        print(f"  Historical Rewards: {format_ether(info['historicalRewards'])} CRV")
        print(f"  Reward Rate: {format_ether(info['rewardRate'])} CRV/sec")
        print(f"  Duration: {info['duration']} seconds ({info['duration'] / 86400:.1f} days)")
        print(f"  Period Finish: {info['periodFinish']}")
        print(f"  Last Update: {info['lastUpdateTime']}")
        print(f"  Extra Rewards: {info['extraRewardsLength']}")

        # Calculate time remaining in reward period
        if info['periodFinish'] > 0:
            current_timestamp = int(time.time())
            time_remaining = info['periodFinish'] - current_timestamp

            if time_remaining > 0:
                print(f"\n  Time remaining in period: {time_remaining / 3600:.2f} hours")
                remaining_rewards = info['rewardRate'] * time_remaining
                print(f"  Rewards to distribute: {format_ether(remaining_rewards)} CRV")
            else:
                print(f"\n  Period EXPIRED {-time_remaining / 3600:.2f} hours ago")
                print(f"  Queued rewards waiting: {format_ether(info['queuedRewards'])} CRV")

        # Flash stake analysis
        print("\n  FLASH STAKE ANALYSIS:")
        if info['queuedRewards'] > 0 and info['totalSupply'] > 0:
            # If someone flash stakes X% of total supply and triggers reward distribution
            # They would get X% of newly distributed rewards
            # But rewards are distributed over duration period

            # Calculate minimum stake to be profitable
            # Need: stake_rewards - gas_cost > 0
            # stake_rewards = (stake / total_supply) * (queued_rewards / duration) * stake_time
            # For flash stake, stake_time = 1 block (12 seconds)

            flash_stake_time = 12  # seconds
            daily_rewards = info['rewardRate'] * 86400

            # If we stake 10x current total supply
            flash_stake_ratio = 10
            new_total = info['totalSupply'] * (flash_stake_ratio + 1)
            our_share = flash_stake_ratio / (flash_stake_ratio + 1)

            # Rewards earned in flash stake time
            rewards_in_period = info['rewardRate'] * flash_stake_time
            our_rewards = rewards_in_period * our_share

            print(f"    If flash stake 10x current supply:")
            print(f"    Our share: {our_share * 100:.1f}%")
            print(f"    Rewards in 12 seconds: {format_ether(rewards_in_period)} CRV")
            print(f"    Our rewards: {format_ether(our_rewards)} CRV (${our_rewards * 0.5 / 1e18:.2f})")

            # NOT profitable because rewards are distributed over time
            # Flash stake doesn't help capture queued rewards
            print(f"    VERDICT: NOT exploitable - rewards distributed over time, not instantly")

        # Check for epoch-based rewards
        if info['periodFinish'] > 0 and info['queuedRewards'] > 0:
            current_timestamp = int(time.time())
            if current_timestamp > info['periodFinish']:
                # Period has expired, queued rewards will be distributed when earmark called
                print(f"\n  TIMING WINDOW:")
                print(f"    Period expired, {format_ether(info['queuedRewards'])} CRV queued")
                print(f"    Next earmarkRewards() will start new period")
                print(f"    But rewards still distributed over {info['duration']} seconds")
                print(f"    NOT instant capture opportunity")

if __name__ == "__main__":
    main()
