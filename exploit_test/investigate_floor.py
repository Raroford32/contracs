#!/usr/bin/env python3
"""
URGENT: Deep investigation of Floor contract - HIGH VALUE TARGET
336 ETH ($766K) with flash loan callback and price manipulation potential
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import json

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

FLOOR_ADDRESS = "0x40ed3699c2ffe43939ecf2f3d11f633b522820ad"

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        result = resp.json()
        if 'error' in result:
            return None
        return result.get("result", "0x")
    except:
        return None

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def decode_address(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return None
    return "0x" + hex_result[-40:]

def decode_uint256(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return 0
    return int(hex_result[:66], 16)

def main():
    print("=" * 70)
    print("FLOOR CONTRACT DEEP INVESTIGATION")
    print("=" * 70)

    address = FLOOR_ADDRESS
    print(f"\nAddress: {address}")

    # Get balance
    eth_bal = get_eth_balance(address)
    print(f"ETH Balance: {eth_bal / 1e18:.4f} ETH (${eth_bal / 1e18 * 2279:,.0f})")

    # Get source
    source_data = get_contract_source(address)
    if not source_data:
        print("No verified source!")
        return

    source_code = source_data.get('SourceCode', '')
    contract_name = source_data.get('ContractName', 'Unknown')
    compiler = source_data.get('CompilerVersion', '')
    print(f"Contract: {contract_name}")
    print(f"Compiler: {compiler}")

    if not source_code:
        print("Empty source")
        return

    # Save source
    with open('floor_source.sol', 'w') as f:
        f.write(source_code)
    print(f"Source saved to floor_source.sol ({len(source_code)} chars)")

    lower = source_code.lower()

    # Key patterns
    print("\n--- KEY VULNERABILITY PATTERNS ---")

    patterns = {
        'uniswapV2Call': 'uniswapv2call' in lower,
        'getReserves': 'getreserves' in lower,
        'getAmountOut': 'getamountout' in lower,
        'swap': 'swap' in lower,
        'msg.sender in callback': 'uniswapv2call' in lower and 'msg.sender' in lower,
        'reentrancyGuard': 'reentrancyguard' in lower or 'nonreentrant' in lower,
        'onlyOwner': 'onlyowner' in lower,
    }

    for name, found in patterns.items():
        status = "YES" if found else "NO"
        if name == 'reentrancyGuard' and not found:
            status = "NO (VULNERABLE!)"
        print(f"  {name}: {status}")

    # Query contract state
    print("\n--- CONTRACT STATE ---")

    selectors = [
        ("owner()", "owner"),
        ("admin()", "admin"),
        ("paused()", "paused"),
        ("totalSupply()", "totalSupply"),
        ("balance()", "balance"),
        ("uniswapPair()", "uniswapPair"),
        ("router()", "router"),
        ("WETH()", "WETH"),
        ("token()", "token"),
        ("floorPrice()", "floorPrice"),
        ("ceiling()", "ceiling"),
        ("floor()", "floor"),
    ]

    for sig, desc in selectors:
        selector = get_function_selector(sig)
        result = eth_call(address, selector)
        if result and result != "0x" and len(result) > 10:
            if any(x in sig.lower() for x in ['address', 'owner', 'admin', 'router', 'pair', 'weth', 'token']):
                addr = decode_address(result)
                if addr and addr != "0x" + "0" * 40:
                    print(f"  {desc}: {addr}")
            else:
                value = decode_uint256(result)
                if value > 0:
                    print(f"  {desc}: {value}")

    # Check token balances
    print("\n--- TOKEN BALANCES ---")

    WETH = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"
    selector = get_function_selector("balanceOf(address)")
    data = selector + encode(['address'], [address]).hex()
    result = eth_call(WETH, data)
    if result:
        weth_bal = decode_uint256(result)
        print(f"  WETH: {weth_bal / 1e18:.4f}")

    # Look for the flash loan callback
    print("\n--- FLASH LOAN CALLBACK ANALYSIS ---")

    if 'uniswapv2call' in lower:
        print("  Found uniswapV2Call - this enables flash swaps!")

        # Check if callback validates sender
        lines = source_code.split('\n')
        in_callback = False
        callback_lines = []

        for line in lines:
            if 'uniswapv2call' in line.lower() and 'function' in line.lower():
                in_callback = True
            if in_callback:
                callback_lines.append(line)
                if line.strip().startswith('}') and len([c for c in line if c == '}']) > len([c for c in line if c == '{']):
                    break

        if callback_lines:
            print("\n  Callback function:")
            for line in callback_lines[:20]:
                print(f"    {line.strip()}")

    # Vulnerability assessment
    print("\n" + "=" * 70)
    print("VULNERABILITY ASSESSMENT")
    print("=" * 70)

    vulnerability_found = False

    if 'uniswapv2call' in lower and ('getreserves' in lower or 'getamountout' in lower):
        if 'reentrancyguard' not in lower and 'nonreentrant' not in lower:
            print("""
!!! POTENTIAL HIGH SEVERITY VULNERABILITY !!!

The contract has:
1. uniswapV2Call callback (enables flash swaps)
2. Uses getReserves/getAmountOut for pricing
3. NO ReentrancyGuard protection

ATTACK VECTOR:
1. Initiate flash swap from Uniswap pair
2. In callback, manipulate reserves (via large swap)
3. Trigger contract function that reads getReserves()
4. Extract value at manipulated price
5. Repay flash swap

This is the classic Oracle Manipulation via Flash Swap attack!
""")
            vulnerability_found = True

    if not vulnerability_found:
        print("No obvious flash loan attack vector found")

    print("\n--- ECONOMIC MODEL ---")
    print(f"Contract ETH balance: {eth_bal / 1e18:.2f} ETH (${eth_bal / 1e18 * 2279:,.0f})")
    print(f"""
For attack to be viable:
1. Manipulation cost < extractable value
2. Flash loan fees (~0.05%) must be covered
3. Gas costs (~500k gas * 50 gwei = ~0.025 ETH)

If price can be manipulated by X%:
- Extractable = balance * X% = {eth_bal / 1e18:.2f} * X%
- For 10% manipulation: ~33 ETH (~$75K) extractable
""")

if __name__ == "__main__":
    main()
