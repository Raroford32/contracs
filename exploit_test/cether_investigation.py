#!/usr/bin/env python3
"""
Deep investigation of CEther contract with oracle staleness vulnerability.

Address: 0x7b4a7fd41c688a7cb116534e341e44126ef5a0fd
TVL: 313.7 ETH (~$715k)

This appears to be a Compound fork. If oracle doesn't check staleness,
we could potentially:
1. Wait for oracle to become stale during high volatility
2. Exploit the price difference for profitable liquidations
3. Or manipulate positions during staleness window
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import time

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

CETHER = "0x7b4a7fd41c688a7cb116534e341e44126ef5a0fd"

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return resp.json().get("result", "0x")
    except:
        return "0x"

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def decode_uint256(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return 0
    return int(hex_result[:66], 16)

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def main():
    print("=" * 70)
    print("CEther DEEP INVESTIGATION")
    print(f"Address: {CETHER}")
    print("=" * 70)

    # Get balance
    eth_bal = get_eth_balance(CETHER)
    print(f"\nETH Balance: {eth_bal / 1e18:.4f} ETH (${eth_bal / 1e18 * 2279:,.0f})")

    # Get contract details
    print("\n--- CONTRACT STATE ---")

    # Comptroller
    selector = get_function_selector("comptroller()")
    result = eth_call(CETHER, selector)
    if result and len(result) >= 42:
        comptroller = "0x" + result[-40:]
        print(f"Comptroller: {comptroller}")

        # Get oracle from comptroller
        selector = get_function_selector("oracle()")
        result = eth_call(comptroller, selector)
        if result and len(result) >= 42:
            oracle = "0x" + result[-40:]
            print(f"Oracle: {oracle}")

            # Check oracle type and get price
            selector = get_function_selector("getUnderlyingPrice(address)")
            data = selector + encode(['address'], [CETHER]).hex()
            result = eth_call(oracle, data)
            if result:
                price = decode_uint256(result)
                print(f"ETH Price from Oracle: ${price / 1e18:.2f}")

            # Check if oracle has staleness check
            oracle_source = get_contract_source(oracle)
            if oracle_source:
                oracle_code = oracle_source.get('SourceCode', '')
                print(f"Oracle Contract: {oracle_source.get('ContractName', 'Unknown')}")

                if 'latestRoundData' in oracle_code.lower():
                    print("Uses Chainlink-style oracle")
                    if 'updatedAt' not in oracle_code.lower():
                        print("!!! NO STALENESS CHECK IN ORACLE !!!")
                else:
                    print("Custom oracle implementation")

    # Interest rate model
    selector = get_function_selector("interestRateModel()")
    result = eth_call(CETHER, selector)
    if result and len(result) >= 42:
        irm = "0x" + result[-40:]
        print(f"Interest Rate Model: {irm}")

    # Admin
    selector = get_function_selector("admin()")
    result = eth_call(CETHER, selector)
    if result and len(result) >= 42:
        admin = "0x" + result[-40:]
        print(f"Admin: {admin}")

    # Total supply and borrows
    selector = get_function_selector("totalSupply()")
    result = eth_call(CETHER, selector)
    if result:
        total_supply = decode_uint256(result)
        print(f"Total cToken Supply: {total_supply / 1e8:.4f}")

    selector = get_function_selector("totalBorrows()")
    result = eth_call(CETHER, selector)
    if result:
        total_borrows = decode_uint256(result)
        print(f"Total Borrows: {total_borrows / 1e18:.4f} ETH")

    selector = get_function_selector("totalReserves()")
    result = eth_call(CETHER, selector)
    if result:
        total_reserves = decode_uint256(result)
        print(f"Total Reserves: {total_reserves / 1e18:.4f} ETH")

    # Exchange rate
    selector = get_function_selector("exchangeRateStored()")
    result = eth_call(CETHER, selector)
    if result:
        exchange_rate = decode_uint256(result)
        print(f"Exchange Rate: {exchange_rate / 1e18:.10f}")

    # Collateral factor from comptroller
    if 'comptroller' in dir():
        selector = get_function_selector("markets(address)")
        data = selector + encode(['address'], [CETHER]).hex()
        result = eth_call(comptroller, data)
        if result and len(result) >= 128:
            # markets returns (isListed, collateralFactorMantissa, isComped)
            # Actually it's a struct, let's try to decode
            print(f"Markets data: {result[:130]}")

    # Check source for vulnerability patterns
    print("\n--- SOURCE CODE ANALYSIS ---")

    source_data = get_contract_source(CETHER)
    if source_data:
        source_code = source_data.get('SourceCode', '')

        # Save for manual review
        with open('cether_source.sol', 'w') as f:
            f.write(source_code)
        print(f"Source saved to cether_source.sol ({len(source_code)} chars)")

        # Look for specific patterns
        lower = source_code.lower()

        patterns = {
            'Uses Chainlink': 'chainlink' in lower or 'aggregator' in lower,
            'Oracle staleness': 'updatedat' in lower or 'staleness' in lower,
            'Price bounds': 'maxprice' in lower or 'minprice' in lower,
            'Liquidation': 'liquidateborrow' in lower,
            'Flash loan': 'flashloan' in lower,
            'Reentrancy guard': 'nonreentrant' in lower or 'reentrancyguard' in lower,
        }

        for name, found in patterns.items():
            print(f"  {name}: {'YES' if found else 'NO'}")

    # EXPLOIT ANALYSIS
    print("\n" + "=" * 70)
    print("EXPLOIT ANALYSIS")
    print("=" * 70)

    print("""
POTENTIAL ATTACK VECTORS:

1. ORACLE STALENESS EXPLOITATION:
   - If oracle doesn't check staleness, and Chainlink feed goes stale
   - During high volatility, oracle reports old price
   - Attacker can:
     a) Borrow more than should be allowed (if price goes up)
     b) Avoid liquidation when should be liquidated (if price goes down)
     c) Liquidate positions that shouldn't be liquidatable (if price moves opposite)

2. REQUIREMENTS FOR EXPLOITATION:
   - Oracle must become stale (Chainlink heartbeat violation)
   - Actual price must diverge from stale price by significant amount
   - Attacker must have or obtain positions in the protocol
   - Profit must exceed gas costs

3. ECONOMIC MODEL:
   - TVL: ~$715,000
   - If oracle is stale by 5%, attacker could extract ~$35,000
   - But requires specific conditions (oracle staleness + volatility)
   - Chainlink ETH/USD feed updates frequently (1h heartbeat, 0.5% deviation)

4. FEASIBILITY:
   - Compound-style protocol with 313 ETH
   - If this is a smaller fork, oracle may be less reliable
   - Need to identify exact oracle used and its reliability

NEXT STEPS:
1. Identify the exact oracle contract and its update frequency
2. Check historical staleness events
3. Model the economic opportunity
4. Build PoC if viable
""")

    # Check if there are any borrowers
    print("\n--- CHECKING MARKET ACTIVITY ---")

    selector = get_function_selector("getCash()")
    result = eth_call(CETHER, selector)
    if result:
        cash = decode_uint256(result)
        print(f"Available Cash: {cash / 1e18:.4f} ETH")

    # Check accrual block
    selector = get_function_selector("accrualBlockNumber()")
    result = eth_call(CETHER, selector)
    if result:
        accrual_block = decode_uint256(result)
        print(f"Last Accrual Block: {accrual_block}")

if __name__ == "__main__":
    main()
