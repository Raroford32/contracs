#!/usr/bin/env python3
"""
Find contracts with vulnerable oracle patterns:
1. Uses spot price (getReserves) for value calculations
2. Uses Chainlink without staleness check
3. Uses custom oracle without proper validation
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import time
import json

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def check_oracle_vulnerability(source_code):
    """Check for oracle vulnerabilities"""
    lower = source_code.lower()
    findings = []
    severity = 0

    # Check for spot price usage
    if 'getreserves' in lower:
        # Check if it's used for value/price calculations, not just info
        if any(x in lower for x in ['borrow', 'liquidat', 'collateral', 'mint', 'redeem', 'deposit', 'withdraw']):
            if 'twap' not in lower and 'average' not in lower:
                findings.append("SPOT_PRICE: Uses getReserves for value calculations without TWAP")
                severity += 4

    # Check for Chainlink without staleness
    if 'latestrounddata' in lower or 'latestanswer' in lower:
        if 'updatedat' not in lower and 'stale' not in lower and 'heartbeat' not in lower:
            # Check if the oracle result is used for important calculations
            if any(x in lower for x in ['borrow', 'liquidat', 'collateral', 'mint', 'redeem']):
                findings.append("CHAINLINK_NO_STALENESS: Uses Chainlink without checking updatedAt")
                severity += 3

    # Check for custom oracle
    if 'setprice' in lower or 'updateprice' in lower:
        if 'owner' in lower or 'admin' in lower:
            findings.append("CUSTOM_ORACLE: Has admin-controllable price")
            severity += 2

    # Check for lending/borrowing with price dependency
    if 'liquidat' in lower:
        if 'getreserves' in lower or ('latestanswer' in lower and 'updatedat' not in lower):
            findings.append("LIQUIDATION_ORACLE: Liquidation depends on potentially stale oracle")
            severity += 5

    # Check for price-gated functions without protection
    if 'require' in lower and 'price' in lower:
        if 'getreserves' in lower:
            findings.append("PRICE_GATE: Has price-gated require using spot price")
            severity += 3

    return findings, severity

def main():
    print("=" * 70)
    print("ORACLE VULNERABILITY SEARCH")
    print("=" * 70)

    # Read all contracts
    with open('/home/user/contracs/contracts.txt', 'r') as f:
        all_contracts = [line.strip() for line in f if line.strip().startswith('0x')]

    targets = []

    # Focus on contracts 0-800 (first part of list)
    for i, address in enumerate(all_contracts[:800]):
        if i % 50 == 0:
            print(f"\nProgress: {i}/800")

        # Get balance
        eth_bal = get_eth_balance(address)
        eth_value = eth_bal / 1e18

        # Skip very low value
        if eth_value < 10:
            continue

        # Get source
        source_data = get_contract_source(address)
        time.sleep(0.25)

        if not source_data:
            continue

        source_code = source_data.get('SourceCode', '')
        contract_name = source_data.get('ContractName', 'Unknown')

        if not source_code:
            continue

        # Check for oracle vulnerabilities
        findings, severity = check_oracle_vulnerability(source_code)

        if findings and severity >= 3:
            target = {
                'address': address,
                'name': contract_name,
                'eth': eth_value,
                'severity': severity,
                'findings': findings
            }
            targets.append(target)

            print(f"\n  *** ORACLE VULN: {contract_name} ({address[:10]}...)")
            print(f"      ETH: {eth_value:.2f} | Severity: {severity}")
            for f in findings:
                print(f"      - {f}")

    # Sort by severity and value
    targets.sort(key=lambda x: (x['severity'], x['eth']), reverse=True)

    # Summary
    print("\n" + "=" * 70)
    print("TOP ORACLE VULNERABLE TARGETS")
    print("=" * 70)

    for i, target in enumerate(targets[:20]):
        print(f"\n{i+1}. {target['name']} ({target['address'][:10]}...)")
        print(f"   ETH: {target['eth']:.2f} | Severity: {target['severity']}")
        for f in target['findings']:
            print(f"   - {f}")

    # Save
    with open('oracle_vulnerable_targets.json', 'w') as f:
        json.dump(targets, f, indent=2)

    print(f"\nFound {len(targets)} potential oracle vulnerable targets")

if __name__ == "__main__":
    main()
