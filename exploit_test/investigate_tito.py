#!/usr/bin/env python3
"""
Deep investigation of Tito contract - multi-protocol with flash loan callback.
Flagged: MULTI_PROTOCOL (uniswap, aave, compound), FLASH_CALLBACK, RESERVE_READ
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import json

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

# Find the actual Tito address
def find_tito_address():
    # Read scan results
    try:
        with open('scan_1200_1568_results.json', 'r') as f:
            data = json.load(f)
            for c in data.get('vulnerable', []):
                if c['name'] == 'Tito':
                    return c['address']
    except:
        pass
    return None

TITO_ADDRESS = find_tito_address()

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        result = resp.json()
        if 'error' in result:
            return None
        return result.get("result", "0x")
    except:
        return None

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def decode_address(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return None
    return "0x" + hex_result[-40:]

def decode_uint256(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return 0
    return int(hex_result[:66], 16)

def main():
    print("=" * 70)
    print("TITO CONTRACT DEEP INVESTIGATION")
    print("=" * 70)

    if not TITO_ADDRESS:
        print("Could not find Tito address from scan results")
        # Try to find it manually in the contracts list
        with open('/home/user/contracs/contracts.txt', 'r') as f:
            lines = [l.strip() for l in f if l.strip().startswith('0x')]

        print("Searching for contract named Tito in range 1200-1400...")
        found_addr = None
        for addr in lines[1200:1400]:
            source = get_contract_source(addr)
            if source and source.get('ContractName') == 'Tito':
                print(f"Found Tito at: {addr}")
                found_addr = addr
                break

        if not found_addr:
            print("Could not find Tito contract")
            return

    address = TITO_ADDRESS if TITO_ADDRESS else found_addr
    print(f"\nAddress: {address}")

    # Get balance
    eth_bal = get_eth_balance(address)
    print(f"ETH Balance: {eth_bal / 1e18:.4f} ETH (${eth_bal / 1e18 * 2279:,.0f})")

    # Get source
    source_data = get_contract_source(address)
    if not source_data:
        print("No verified source")
        return

    source_code = source_data.get('SourceCode', '')
    contract_name = source_data.get('ContractName', 'Unknown')
    compiler = source_data.get('CompilerVersion', '')
    print(f"Contract: {contract_name}")
    print(f"Compiler: {compiler}")

    if not source_code:
        print("Empty source")
        return

    # Save source
    with open('tito_source.sol', 'w') as f:
        f.write(source_code)
    print("Source saved to tito_source.sol")
    print(f"Source length: {len(source_code)} chars")

    lower = source_code.lower()

    # Analyze protocol integrations
    print("\n--- PROTOCOL INTEGRATIONS ---")

    integrations = {
        'Uniswap': 'uniswap' in lower,
        'UniswapV2': 'uniswapv2' in lower or 'iuniswapv2' in lower,
        'UniswapV3': 'uniswapv3' in lower or 'iuniswapv3' in lower,
        'Aave': 'aave' in lower or 'iaave' in lower,
        'Aave V2': 'lendingpool' in lower,
        'Aave V3': 'pool.sol' in lower or 'ipool' in lower,
        'Compound': 'compound' in lower or 'ctoken' in lower,
        'Curve': 'curve' in lower,
        'Balancer': 'balancer' in lower,
        'SushiSwap': 'sushiswap' in lower or 'sushi' in lower,
    }

    for name, found in integrations.items():
        if found:
            print(f"  {name}: YES")

    # Flash loan patterns
    print("\n--- FLASH LOAN PATTERNS ---")

    flash_patterns = {
        'Aave Flash Loan': 'flashloan' in lower and 'aave' in lower,
        'executeOperation': 'executeoperation' in lower,
        'Uniswap Flash Swap': 'uniswapv2call' in lower,
        'Balancer Flash Loan': 'flashloan' in lower and 'balancer' in lower,
        'Generic Flash': 'flash' in lower,
        'Callback': 'callback' in lower,
    }

    for name, found in flash_patterns.items():
        if found:
            print(f"  {name}: YES")

    # Reserve/Price patterns
    print("\n--- PRICE/RESERVE PATTERNS ---")

    price_patterns = {
        'getReserves': 'getreserves' in lower,
        'getAmountOut': 'getamountout' in lower,
        'swapExact': 'swapexact' in lower,
        'swap': lower.count('swap'),
        'oracle': 'oracle' in lower,
        'price': lower.count('price'),
    }

    for name, value in price_patterns.items():
        if isinstance(value, bool):
            if value:
                print(f"  {name}: YES")
        elif value > 0:
            print(f"  {name}: {value} occurrences")

    # Query contract state
    print("\n--- CONTRACT STATE ---")

    selectors = [
        ("owner()", "owner"),
        ("admin()", "admin"),
        ("paused()", "paused"),
        ("totalSupply()", "totalSupply"),
        ("uniswapRouter()", "uniswapRouter"),
        ("factory()", "factory"),
        ("WETH()", "WETH"),
    ]

    for sig, desc in selectors:
        selector = get_function_selector(sig)
        result = eth_call(address, selector)
        if result and result != "0x" and len(result) > 10:
            if 'address' in sig.lower() or 'owner' in sig.lower() or 'admin' in sig.lower() or 'router' in sig.lower() or 'factory' in sig.lower() or 'weth' in sig.lower():
                addr = decode_address(result)
                if addr and addr != "0x" + "0" * 40:
                    print(f"  {desc}: {addr}")
            else:
                value = decode_uint256(result)
                print(f"  {desc}: {value}")

    # Look for exploitable functions
    print("\n--- EXPLOITABLE FUNCTIONS ---")

    exploitable = ['withdraw', 'emergencywithdraw', 'rescue', 'sweep', 'transfer', 'execute']

    for func in exploitable:
        if func in lower:
            # Find function definitions
            lines = source_code.split('\n')
            for i, line in enumerate(lines):
                if func in line.lower() and 'function' in line.lower():
                    print(f"  {line.strip()[:80]}")

    # Security analysis
    print("\n--- SECURITY ANALYSIS ---")

    security = {
        'ReentrancyGuard': 'reentrancyguard' in lower or 'nonreentrant' in lower,
        'Ownable': 'ownable' in lower or 'onlyowner' in lower,
        'Pausable': 'pausable' in lower or 'paused' in lower,
        'SafeERC20': 'safeerc20' in lower or 'safetransfer' in lower,
        'SafeMath': 'safemath' in lower,
    }

    for name, found in security.items():
        print(f"  {name}: {'YES' if found else 'NO'}")

    # Check token balances
    print("\n--- TOKEN BALANCES ---")

    tokens = [
        ("WETH", "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"),
        ("USDC", "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"),
        ("USDT", "0xdAC17F958D2ee523a2206206994597C13D831ec7"),
        ("DAI", "0x6B175474E89094C44Da98b954EescdeCB5"),
    ]

    selector = get_function_selector("balanceOf(address)")
    for name, token_addr in tokens:
        try:
            data = selector + encode(['address'], [address]).hex()
            result = eth_call(token_addr, data)
            if result:
                bal = decode_uint256(result)
                if bal > 0:
                    decimals = 18 if name in ['WETH', 'DAI'] else 6
                    print(f"  {name}: {bal / 10**decimals:.4f}")
        except:
            pass

    # Vulnerability assessment
    print("\n" + "=" * 70)
    print("VULNERABILITY ASSESSMENT")
    print("=" * 70)

    print("""
MULTI-PROTOCOL FLASH LOAN ATTACK VECTORS:

1. Reserve Manipulation Attack:
   - Flash loan large amount
   - Use to manipulate Uniswap reserves
   - Trigger contract function that reads getReserves()
   - Profit from price discrepancy

2. Flash Swap Arbitrage:
   - If contract has Uniswap V2 callback
   - May allow extracting value via callback manipulation

3. Aave Flash Loan + Compound:
   - Flash loan from Aave
   - Use in Compound for leverage
   - If interest rate calculations are off, profit

4. Cross-Protocol State Confusion:
   - Different protocols may have different views of state
   - Attack window during cross-protocol calls

REQUIREMENTS FOR EXPLOITATION:
1. Contract must use price from manipulable source
2. Contract must have extractable value
3. Attack cost < extractable value
4. No reentrancy protection on critical functions
""")

if __name__ == "__main__":
    main()
