#!/usr/bin/env python3
"""
Investigate governance contracts without snapshots.
If voting power is not snapshotted, flash loan attacks may be possible.
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import time

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

# Targets with governance but no snapshot
TARGETS = [
    ("0xb9fbe1315824a466d05df4882ffac592ce9c009a", "InstantListingV2", 200),
    ("0x7cd5e2d0056a7a7f09cbb86e540ef4f6dccc97dd", "xSNXAdminProxy", 175),
    ("0xe0b7927c4af23765cb51314a0e0521a9645f0e2a", "Token", 25),
]

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return resp.json().get("result", "0x")
    except:
        return "0x"

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def decode_uint256(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return 0
    return int(hex_result[:66], 16)

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def analyze_governance_contract(address, name, expected_eth):
    """Analyze a governance contract for flash loan attack potential"""
    print(f"\n{'=' * 70}")
    print(f"ANALYZING: {name}")
    print(f"Address: {address}")
    print("=" * 70)

    # Get actual balance
    eth_bal = get_eth_balance(address)
    print(f"ETH Balance: {eth_bal / 1e18:.4f} ETH (${eth_bal / 1e18 * 2279:,.0f})")

    # Get source
    source_data = get_contract_source(address)
    if not source_data:
        print("No verified source")
        return None

    source_code = source_data.get('SourceCode', '')
    contract_name = source_data.get('ContractName', 'Unknown')
    print(f"Contract: {contract_name}")

    if not source_code:
        print("Empty source")
        return None

    lower = source_code.lower()

    # Check governance patterns
    print("\n--- GOVERNANCE PATTERNS ---")

    patterns = {
        'Has voting': 'vote' in lower,
        'Has proposals': 'proposal' in lower,
        'Snapshot voting': 'snapshot' in lower or 'checkpoint' in lower or 'getpriorvotes' in lower,
        'Block-based': 'block.number' in lower and 'vote' in lower,
        'Token-based voting': 'balanceof' in lower and 'vote' in lower,
        'Timelock': 'timelock' in lower or 'delay' in lower,
        'Quorum': 'quorum' in lower,
        'Can propose': 'propose' in lower,
    }

    for name_p, found in patterns.items():
        print(f"  {name_p}: {'YES' if found else 'NO'}")

    # Vulnerability assessment
    print("\n--- VULNERABILITY ASSESSMENT ---")

    is_vulnerable = False
    vulnerabilities = []

    # Check for flash loan attack potential
    if patterns['Has voting'] and not patterns['Snapshot voting'] and not patterns['Block-based']:
        vulnerabilities.append("NO_SNAPSHOT: Voting power might be instantly usable")
        is_vulnerable = True

    if patterns['Token-based voting'] and not patterns['Snapshot voting']:
        vulnerabilities.append("FLASH_LOAN_RISK: Token balance is used for voting without snapshot")
        is_vulnerable = True

    if patterns['Can propose'] and not patterns['Timelock']:
        vulnerabilities.append("NO_TIMELOCK: Proposals can execute immediately")

    if vulnerabilities:
        print("!!! POTENTIAL VULNERABILITIES FOUND !!!")
        for v in vulnerabilities:
            print(f"  - {v}")
    else:
        print("No obvious governance vulnerabilities")

    # Look for specific exploitable functions
    print("\n--- EXPLOITABLE FUNCTIONS ---")

    # Search for functions that might allow extraction
    exploitable_functions = [
        'withdraw',
        'transfer',
        'execute',
        'emergencyWithdraw',
        'drain',
        'sweepToken',
    ]

    for func in exploitable_functions:
        if func.lower() in lower:
            # Check if it requires governance
            lines = source_code.split('\n')
            for i, line in enumerate(lines):
                if func.lower() in line.lower() and 'function' in line.lower():
                    print(f"  Found: {line.strip()[:80]}")

    # Check what the governance can do
    print("\n--- GOVERNANCE CAPABILITIES ---")

    capabilities = {
        'Can withdraw ETH': 'withdraw' in lower and ('eth' in lower or 'transfer(msg.sender' in lower),
        'Can change admin': 'setadmin' in lower or 'changeadmin' in lower or 'transferownership' in lower,
        'Can upgrade': 'upgrade' in lower or 'setimplementation' in lower,
        'Can pause': 'pause' in lower,
        'Can mint tokens': 'mint' in lower,
    }

    for cap, found in capabilities.items():
        if found:
            print(f"  {cap}")

    # ECONOMIC ANALYSIS
    print("\n--- ECONOMIC ANALYSIS ---")

    if eth_bal > 0:
        print(f"Extractable value: {eth_bal / 1e18:.4f} ETH (${eth_bal / 1e18 * 2279:,.0f})")

        if is_vulnerable:
            print("\nATTACK SCENARIO:")
            print("1. Flash loan governance tokens")
            print("2. Vote for malicious proposal (if no snapshot)")
            print("3. Execute proposal to withdraw funds")
            print("4. Repay flash loan")
            print(f"5. Profit: ~{eth_bal / 1e18:.2f} ETH minus gas")
        else:
            print("No viable flash loan governance attack")

    return {
        'address': address,
        'name': contract_name,
        'eth_balance': eth_bal,
        'vulnerable': is_vulnerable,
        'vulnerabilities': vulnerabilities
    }

def main():
    print("=" * 70)
    print("GOVERNANCE VULNERABILITY INVESTIGATION")
    print("=" * 70)

    results = []

    for address, name, expected_eth in TARGETS:
        result = analyze_governance_contract(address, name, expected_eth)
        if result:
            results.append(result)
        time.sleep(1)

    # Summary
    print("\n" + "=" * 70)
    print("SUMMARY")
    print("=" * 70)

    vulnerable = [r for r in results if r and r.get('vulnerable')]

    if vulnerable:
        print(f"\nFOUND {len(vulnerable)} POTENTIALLY VULNERABLE CONTRACTS:")
        for r in vulnerable:
            print(f"\n{r['name']} ({r['address']})")
            print(f"  ETH: {r['eth_balance'] / 1e18:.4f}")
            print(f"  Vulnerabilities: {r['vulnerabilities']}")
    else:
        print("\nNo vulnerable governance contracts found")

    print("""

GOVERNANCE FLASH LOAN ATTACK REQUIREMENTS:
1. Voting power must NOT use snapshots (getPriorVotes)
2. Proposal execution must be instant OR attackable timelock
3. Must be able to create proposals OR vote on existing one
4. Governance must control valuable assets
5. Flash loan must be available for governance tokens

MOST PROTOCOLS PROTECT AGAINST THIS BY:
- Using block.number-based snapshots (Compound style)
- Requiring holding tokens for N blocks before voting
- Using timelocks on execution
- Requiring separate proposal and voting periods
""")

if __name__ == "__main__":
    main()
