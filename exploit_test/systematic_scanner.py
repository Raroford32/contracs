#!/usr/bin/env python3
"""
Systematic vulnerability scanner - checks ALL contracts for specific patterns
"""

import json
import requests
from eth_abi import decode, encode
from eth_utils import keccak
import time

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return resp.json().get("result", "0x")
    except:
        return "0x"

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def decode_uint256(hex_result):
    if hex_result == "0x" or not hex_result:
        return 0
    return int(hex_result, 16)

def format_ether(wei):
    return f"{wei / 1e18:.4f}"

def check_reward_vulnerability(address):
    """Check for reward distribution vulnerabilities"""
    vulnerabilities = []

    # Check if this is a reward contract
    selectors = {
        'earned': get_function_selector("earned(address)"),
        'rewardRate': get_function_selector("rewardRate()"),
        'rewardPerToken': get_function_selector("rewardPerToken()"),
        'totalSupply': get_function_selector("totalSupply()"),
        'periodFinish': get_function_selector("periodFinish()"),
        'lastUpdateTime': get_function_selector("lastUpdateTime()"),
        'rewardsDuration': get_function_selector("rewardsDuration()"),
        'getReward': get_function_selector("getReward()"),
        'stake': get_function_selector("stake(uint256)"),
    }

    reward_rate = eth_call(address, selectors['rewardRate'])
    total_supply = eth_call(address, selectors['totalSupply'])
    period_finish = eth_call(address, selectors['periodFinish'])

    if reward_rate != "0x" and total_supply != "0x":
        rate = decode_uint256(reward_rate)
        supply = decode_uint256(total_supply)
        finish = decode_uint256(period_finish)

        if rate > 0 and supply > 0:
            # Check for potential issues
            current_time = int(time.time())

            # Issue 1: Reward period expired but rewards still distributing
            if finish > 0 and current_time > finish and rate > 0:
                vulnerabilities.append({
                    'type': 'EXPIRED_PERIOD_WITH_REWARDS',
                    'details': f'Period finished {(current_time - finish) / 3600:.1f}h ago but rate={rate}'
                })

            # Issue 2: Very low total supply with high rewards (flash stake opportunity)
            if supply < 1e18 and rate > 1e15:  # < 1 token staked, high rewards
                vulnerabilities.append({
                    'type': 'LOW_SUPPLY_HIGH_REWARDS',
                    'details': f'Supply={format_ether(supply)}, Rate={format_ether(rate)}/s'
                })

            # Issue 3: Check rewardPerToken for potential overflow/precision issues
            rpt = eth_call(address, selectors['rewardPerToken'])
            if rpt != "0x":
                rpt_val = decode_uint256(rpt)
                if rpt_val > 1e30:  # Very high rewardPerToken
                    vulnerabilities.append({
                        'type': 'HIGH_REWARD_PER_TOKEN',
                        'details': f'RewardPerToken={rpt_val}'
                    })

    return vulnerabilities

def check_vault_vulnerability(address):
    """Check for vault share price manipulation"""
    vulnerabilities = []

    selectors = {
        'totalAssets': get_function_selector("totalAssets()"),
        'totalSupply': get_function_selector("totalSupply()"),
        'pricePerShare': get_function_selector("pricePerShare()"),
        'getPricePerFullShare': get_function_selector("getPricePerFullShare()"),
        'convertToAssets': get_function_selector("convertToAssets(uint256)"),
        'convertToShares': get_function_selector("convertToShares(uint256)"),
    }

    total_assets = eth_call(address, selectors['totalAssets'])
    total_supply = eth_call(address, selectors['totalSupply'])

    if total_assets != "0x" and total_supply != "0x":
        assets = decode_uint256(total_assets)
        supply = decode_uint256(total_supply)

        if assets > 0 and supply > 0:
            # Check for share price anomalies
            share_price = assets / supply

            # Issue 1: Very high share price (potential inflation attack success)
            if share_price > 1e10:
                vulnerabilities.append({
                    'type': 'HIGH_SHARE_PRICE',
                    'details': f'SharePrice={share_price:.2e}, Assets={assets}, Supply={supply}'
                })

            # Issue 2: Very low supply with assets (first depositor style, but check if exploitable)
            if supply < 1e6 and assets > 1e18:
                vulnerabilities.append({
                    'type': 'LOW_SUPPLY_HIGH_ASSETS',
                    'details': f'Supply={supply}, Assets={format_ether(assets)}'
                })

    return vulnerabilities

def check_staking_vulnerability(address):
    """Check for staking contract vulnerabilities"""
    vulnerabilities = []

    selectors = {
        'totalStaked': get_function_selector("totalStaked()"),
        'stakingToken': get_function_selector("stakingToken()"),
        'rewardsToken': get_function_selector("rewardsToken()"),
        'accRewardPerShare': get_function_selector("accRewardPerShare()"),
        'pendingReward': get_function_selector("pendingReward(address)"),
        'rewardPerBlock': get_function_selector("rewardPerBlock()"),
        'lastRewardBlock': get_function_selector("lastRewardBlock()"),
        'bonusEndBlock': get_function_selector("bonusEndBlock()"),
    }

    total_staked = eth_call(address, selectors['totalStaked'])
    acc_reward = eth_call(address, selectors['accRewardPerShare'])
    reward_per_block = eth_call(address, selectors['rewardPerBlock'])

    if total_staked != "0x" and reward_per_block != "0x":
        staked = decode_uint256(total_staked)
        rpb = decode_uint256(reward_per_block)

        if staked > 0 and rpb > 0:
            # Check for MasterChef-style precision issues
            if acc_reward != "0x":
                acc = decode_uint256(acc_reward)
                if acc > 1e30:  # Very high accumulated reward
                    vulnerabilities.append({
                        'type': 'HIGH_ACC_REWARD',
                        'details': f'AccRewardPerShare={acc:.2e}'
                    })

            # Low stake with high rewards
            if staked < 1e15 and rpb > 1e15:
                vulnerabilities.append({
                    'type': 'LOW_STAKE_HIGH_REWARD',
                    'details': f'Staked={format_ether(staked)}, RPB={format_ether(rpb)}'
                })

    return vulnerabilities

def check_liquidity_vulnerability(address):
    """Check for liquidity pool vulnerabilities"""
    vulnerabilities = []

    selectors = {
        'getReserves': get_function_selector("getReserves()"),
        'token0': get_function_selector("token0()"),
        'token1': get_function_selector("token1()"),
        'price0CumulativeLast': get_function_selector("price0CumulativeLast()"),
        'price1CumulativeLast': get_function_selector("price1CumulativeLast()"),
        'kLast': get_function_selector("kLast()"),
    }

    reserves = eth_call(address, selectors['getReserves'])

    if reserves != "0x" and len(reserves) >= 130:
        try:
            decoded = decode(['uint112', 'uint112', 'uint32'], bytes.fromhex(reserves[2:]))
            reserve0 = decoded[0]
            reserve1 = decoded[1]

            # Check for extreme imbalance
            if reserve0 > 0 and reserve1 > 0:
                ratio = max(reserve0, reserve1) / min(reserve0, reserve1)
                if ratio > 1000:  # 1000:1 ratio
                    vulnerabilities.append({
                        'type': 'EXTREME_IMBALANCE',
                        'details': f'Ratio={ratio:.0f}:1, R0={reserve0}, R1={reserve1}'
                    })

            # Check for very low liquidity
            if reserve0 < 1e12 or reserve1 < 1e12:
                vulnerabilities.append({
                    'type': 'LOW_LIQUIDITY',
                    'details': f'R0={reserve0}, R1={reserve1}'
                })
        except:
            pass

    return vulnerabilities

def main():
    print("=" * 70)
    print("SYSTEMATIC VULNERABILITY SCANNER")
    print("Scanning ALL contracts for exploitable patterns")
    print("=" * 70)

    # Load contracts
    with open('/home/user/contracs/contracts.txt', 'r') as f:
        addresses = [line.strip() for line in f if line.strip().startswith('0x') and len(line.strip()) == 42]

    print(f"\nLoaded {len(addresses)} contracts")
    print("\nScanning for vulnerabilities...")

    findings = []
    scanned = 0

    for i, address in enumerate(addresses):
        if i % 100 == 0:
            print(f"\nProgress: {i}/{len(addresses)} contracts scanned, {len(findings)} findings so far")

        # Check ETH balance first
        balance = get_eth_balance(address)

        # Only deep scan contracts with > 10 ETH
        if balance < 10 * 1e18:
            continue

        scanned += 1

        # Run all vulnerability checks
        reward_vulns = check_reward_vulnerability(address)
        vault_vulns = check_vault_vulnerability(address)
        staking_vulns = check_staking_vulnerability(address)
        liquidity_vulns = check_liquidity_vulnerability(address)

        all_vulns = reward_vulns + vault_vulns + staking_vulns + liquidity_vulns

        if all_vulns:
            finding = {
                'address': address,
                'balance': balance,
                'balance_eth': format_ether(balance),
                'balance_usd': balance / 1e18 * 2279,
                'vulnerabilities': all_vulns
            }
            findings.append(finding)

            print(f"\n{'!' * 50}")
            print(f"POTENTIAL VULNERABILITY FOUND!")
            print(f"Address: {address}")
            print(f"Balance: {format_ether(balance)} ETH (${finding['balance_usd']:,.0f})")
            for vuln in all_vulns:
                print(f"  - {vuln['type']}: {vuln['details']}")
            print(f"{'!' * 50}")

        # Rate limiting
        if scanned % 20 == 0:
            time.sleep(0.5)

    print("\n" + "=" * 70)
    print("SCAN COMPLETE")
    print("=" * 70)
    print(f"Total contracts: {len(addresses)}")
    print(f"Deep scanned (>10 ETH): {scanned}")
    print(f"Findings: {len(findings)}")

    if findings:
        print("\n" + "=" * 70)
        print("ALL FINDINGS SUMMARY")
        print("=" * 70)

        # Sort by balance
        findings.sort(key=lambda x: x['balance'], reverse=True)

        for f in findings:
            print(f"\n{f['address']}")
            print(f"  Balance: {f['balance_eth']} ETH (${f['balance_usd']:,.0f})")
            for v in f['vulnerabilities']:
                print(f"  [{v['type']}] {v['details']}")

    # Save findings to file
    with open('vulnerability_findings.json', 'w') as f:
        json.dump(findings, f, indent=2, default=str)

    print("\nFindings saved to vulnerability_findings.json")

if __name__ == "__main__":
    main()
