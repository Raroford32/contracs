// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title EtherscanFetcher
 * @notice Utilities for fetching and analyzing contract data from Etherscan
 * @dev Uses Etherscan API v2 for multi-chain support
 */
contract EtherscanFetcher is Test {

    // API Configuration
    string constant ETHERSCAN_API_BASE = "https://api.etherscan.io/v2/api";
    string constant API_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K";

    // Chain IDs
    uint256 constant MAINNET = 1;
    uint256 constant BSC = 56;
    uint256 constant POLYGON = 137;
    uint256 constant ARBITRUM = 42161;
    uint256 constant OPTIMISM = 10;

    struct ContractInfo {
        address addr;
        string name;
        string compilerVersion;
        bool isProxy;
        address implementation;
        bool sourceVerified;
        uint256 chainId;
    }

    struct ProxyInfo {
        bool isProxy;
        address implementation;
        string proxyType; // EIP1967, EIP1822, Custom
    }

    // ============ PROXY DETECTION ============

    /**
     * @notice Detect if contract is a proxy and get implementation
     */
    function detectProxy(address target) public view returns (ProxyInfo memory info) {
        // EIP-1967 Implementation Slot
        bytes32 eip1967Slot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
        bytes32 implValue = vm.load(target, eip1967Slot);

        if (implValue != bytes32(0) && uint256(implValue) > 0x1000) {
            info.isProxy = true;
            info.implementation = address(uint160(uint256(implValue)));
            info.proxyType = "EIP1967";
            return info;
        }

        // EIP-1967 Beacon Slot
        bytes32 beaconSlot = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;
        bytes32 beaconValue = vm.load(target, beaconSlot);

        if (beaconValue != bytes32(0) && uint256(beaconValue) > 0x1000) {
            address beacon = address(uint160(uint256(beaconValue)));
            // Get implementation from beacon
            (bool success, bytes memory data) = beacon.staticcall(
                abi.encodeWithSignature("implementation()")
            );
            if (success && data.length >= 32) {
                info.isProxy = true;
                info.implementation = abi.decode(data, (address));
                info.proxyType = "Beacon";
                return info;
            }
        }

        // EIP-1822 UUPS
        bytes32 uupsSlot = keccak256("PROXIABLE");
        bytes32 uupsValue = vm.load(target, uupsSlot);

        if (uupsValue != bytes32(0)) {
            info.isProxy = true;
            info.implementation = address(uint160(uint256(uupsValue)));
            info.proxyType = "UUPS";
            return info;
        }

        // Try implementation() call directly
        (bool success, bytes memory data) = target.staticcall(
            abi.encodeWithSignature("implementation()")
        );
        if (success && data.length >= 32) {
            address impl = abi.decode(data, (address));
            if (impl != address(0) && impl != target && impl.code.length > 0) {
                info.isProxy = true;
                info.implementation = impl;
                info.proxyType = "Custom";
                return info;
            }
        }

        // OpenZeppelin TransparentProxy admin slot
        bytes32 adminSlot = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
        bytes32 adminValue = vm.load(target, adminSlot);

        if (adminValue != bytes32(0)) {
            // Has admin, likely a transparent proxy
            // Implementation is in EIP1967 slot, already checked above
            info.proxyType = "Transparent";
        }

        return info;
    }

    /**
     * @notice Check if implementation is uninitialized (common vuln)
     */
    function checkUninitialized(address implementation) public view returns (bool uninitialized, uint8 initVersion) {
        // OpenZeppelin Initializable stores version in first slot's first byte
        bytes32 slot0 = vm.load(implementation, bytes32(0));
        initVersion = uint8(uint256(slot0));

        // If version is 0, likely uninitialized
        // But could also be a different storage layout
        uninitialized = initVersion == 0;

        // Additional check: try calling initialize()
        // Would need to actually call in non-view context
    }

    /**
     * @notice Get all storage slots that might contain addresses
     */
    function scanStorageForAddresses(
        address target,
        uint256 numSlots
    ) public view returns (address[] memory found) {
        address[] memory temp = new address[](numSlots);
        uint256 count = 0;

        for (uint256 i = 0; i < numSlots; i++) {
            bytes32 value = vm.load(target, bytes32(i));
            uint256 valueUint = uint256(value);

            // Check if value looks like an address
            if (valueUint > 0x1000 && valueUint < type(uint160).max) {
                address potentialAddr = address(uint160(valueUint));
                if (potentialAddr.code.length > 0) {
                    temp[count++] = potentialAddr;
                }
            }
        }

        // Resize
        found = new address[](count);
        for (uint256 i = 0; i < count; i++) {
            found[i] = temp[i];
        }
    }

    /**
     * @notice Get common role/access control storage values
     */
    function getAccessControlInfo(address target) public view returns (
        address owner,
        address admin,
        address pendingOwner,
        bool paused
    ) {
        // Try owner()
        (bool success, bytes memory data) = target.staticcall(
            abi.encodeWithSignature("owner()")
        );
        if (success && data.length >= 32) {
            owner = abi.decode(data, (address));
        }

        // Try admin()
        (success, data) = target.staticcall(
            abi.encodeWithSignature("admin()")
        );
        if (success && data.length >= 32) {
            admin = abi.decode(data, (address));
        }

        // Try pendingOwner()
        (success, data) = target.staticcall(
            abi.encodeWithSignature("pendingOwner()")
        );
        if (success && data.length >= 32) {
            pendingOwner = abi.decode(data, (address));
        }

        // Try paused()
        (success, data) = target.staticcall(
            abi.encodeWithSignature("paused()")
        );
        if (success && data.length >= 32) {
            paused = abi.decode(data, (bool));
        }
    }

    /**
     * @notice Build URL for Etherscan API call
     */
    function buildApiUrl(
        uint256 chainId,
        string memory module,
        string memory action,
        address target
    ) public pure returns (string memory) {
        return string(abi.encodePacked(
            ETHERSCAN_API_BASE,
            "?chainid=", vm.toString(chainId),
            "&module=", module,
            "&action=", action,
            "&address=", vm.toString(target),
            "&apikey=", API_KEY
        ));
    }

    // ============ HELPER FUNCTIONS ============

    /**
     * @notice Check if address is a contract
     */
    function isContract(address addr) public view returns (bool) {
        return addr.code.length > 0;
    }

    /**
     * @notice Get code hash for comparison
     */
    function getCodeHash(address addr) public view returns (bytes32) {
        return keccak256(addr.code);
    }

    /**
     * @notice Check if two contracts have the same code
     */
    function sameCode(address a, address b) public view returns (bool) {
        return getCodeHash(a) == getCodeHash(b);
    }

    /**
     * @notice Print contract info
     */
    function printContractInfo(address target) public view {
        console.log("=== Contract Info ===");
        console.log("Address:", target);
        console.log("Code Size:", target.code.length);
        console.log("ETH Balance:", target.balance);

        ProxyInfo memory proxyInfo = detectProxy(target);
        console.log("Is Proxy:", proxyInfo.isProxy);
        if (proxyInfo.isProxy) {
            console.log("Implementation:", proxyInfo.implementation);
            console.log("Proxy Type:", proxyInfo.proxyType);
        }

        (address owner, address admin, address pendingOwner, bool paused) = getAccessControlInfo(target);
        console.log("Owner:", owner);
        console.log("Admin:", admin);
        console.log("Pending Owner:", pendingOwner);
        console.log("Paused:", paused);
    }
}
