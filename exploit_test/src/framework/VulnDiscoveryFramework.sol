// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title VulnDiscoveryFramework
 * @notice Process-based novel unprivileged vulnerability discovery at scale
 * @dev Core infrastructure for systematic attack-surface enumeration, invariant testing,
 *      adversarial input generation, and automated monitoring
 */
abstract contract VulnDiscoveryFramework is Test {

    // ============ CONSTANTS ============
    uint256 constant DUST_AMOUNT = 1;
    uint256 constant SMALL_AMOUNT = 1e6;
    uint256 constant MEDIUM_AMOUNT = 1e18;
    uint256 constant LARGE_AMOUNT = 1e24;
    uint256 constant WHALE_AMOUNT = 1e30;

    // Flash loan sources
    address constant AAVE_V3_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address constant UNISWAP_V3_FACTORY = 0x1F98431c8aD98523631AE4a59f267346ea31F984;

    // Common tokens
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address constant DAI = 0x6B175474E89094C44Da98b954EesC36e8eE4f0e6;

    // ============ STATE VARIABLES ============

    struct FunctionInfo {
        bytes4 selector;
        string name;
        FunctionCategory category;
        bool isPayable;
        bool hasCallback;
        uint8 paramCount;
    }

    struct ContractAnalysis {
        address target;
        bool isProxy;
        address implementation;
        uint256 totalFunctions;
        uint256 privilegedFunctions;
        uint256 fundsMovementFunctions;
        uint256 externalCallFunctions;
    }

    struct InvariantResult {
        string name;
        bool violated;
        uint256 valueBefore;
        uint256 valueAfter;
        int256 delta;
    }

    struct ExploitAttempt {
        string name;
        bool success;
        uint256 profitWei;
        uint256 profitUSD;
        bytes callData;
        string trace;
    }

    enum FunctionCategory {
        FUNDS_MOVEMENT,      // deposit, withdraw, transfer, swap
        ORACLE_READ,         // getPrice, latestAnswer, consult
        ORACLE_WRITE,        // setPrice, updatePrice, push
        STATE_SETTLEMENT,    // settle, finalize, execute
        EXTERNAL_CALL,       // call, delegatecall, staticcall
        SHARE_MINT_BURN,     // mint, burn, issue, redeem
        INDEX_UPDATE,        // updateIndex, accrue, sync
        ADMIN_CONTROL,       // setOwner, grantRole, pause
        BRIDGE_ASSET,        // bridge, sendMessage, relay
        UNKNOWN
    }

    mapping(address => ContractAnalysis) public analyses;
    mapping(address => FunctionInfo[]) public functionInventory;
    InvariantResult[] public invariantResults;
    ExploitAttempt[] public exploitAttempts;

    address[] public attackerAddresses;
    address public currentAttacker;

    // ============ MODIFIERS ============

    modifier asAttacker() {
        currentAttacker = makeAddr("attacker");
        vm.startPrank(currentAttacker);
        _;
        vm.stopPrank();
    }

    modifier withFlashLoan(address token, uint256 amount) {
        // Record pre-state
        uint256 preBalance = IERC20Minimal(token).balanceOf(currentAttacker);

        // Execute flash loan context
        deal(token, currentAttacker, amount);
        _;

        // Verify profit
        uint256 postBalance = IERC20Minimal(token).balanceOf(currentAttacker);
        console.log("Flash loan profit:", postBalance > amount ? postBalance - amount : 0);
    }

    // ============ SETUP ============

    function setupAttackers(uint256 count) internal {
        for (uint256 i = 0; i < count; i++) {
            address attacker = makeAddr(string(abi.encodePacked("attacker", i)));
            attackerAddresses.push(attacker);
            vm.deal(attacker, 100 ether);
        }
        currentAttacker = attackerAddresses[0];
    }

    // ============ ATTACK SURFACE ENUMERATION ============

    function enumerateSelectors(address target) internal view returns (bytes4[] memory) {
        // Common function selectors to probe
        bytes4[] memory common = new bytes4[](50);
        common[0] = bytes4(keccak256("deposit(uint256)"));
        common[1] = bytes4(keccak256("withdraw(uint256)"));
        common[2] = bytes4(keccak256("transfer(address,uint256)"));
        common[3] = bytes4(keccak256("approve(address,uint256)"));
        common[4] = bytes4(keccak256("mint(address,uint256)"));
        common[5] = bytes4(keccak256("burn(uint256)"));
        common[6] = bytes4(keccak256("swap(uint256,uint256,address,bytes)"));
        common[7] = bytes4(keccak256("flash(address,uint256,uint256,bytes)"));
        common[8] = bytes4(keccak256("execute(address,bytes)"));
        common[9] = bytes4(keccak256("multicall(bytes[])"));
        common[10] = bytes4(keccak256("setOwner(address)"));
        common[11] = bytes4(keccak256("transferOwnership(address)"));
        common[12] = bytes4(keccak256("grantRole(bytes32,address)"));
        common[13] = bytes4(keccak256("setPrice(uint256)"));
        common[14] = bytes4(keccak256("updatePrice(address,uint256)"));
        common[15] = bytes4(keccak256("setOracle(address)"));
        common[16] = bytes4(keccak256("setPriceFeed(address)"));
        common[17] = bytes4(keccak256("claim(uint256)"));
        common[18] = bytes4(keccak256("claimRewards()"));
        common[19] = bytes4(keccak256("harvest()"));
        common[20] = bytes4(keccak256("compound()"));
        common[21] = bytes4(keccak256("stake(uint256)"));
        common[22] = bytes4(keccak256("unstake(uint256)"));
        common[23] = bytes4(keccak256("redeem(uint256)"));
        common[24] = bytes4(keccak256("borrow(uint256)"));
        common[25] = bytes4(keccak256("repay(uint256)"));
        common[26] = bytes4(keccak256("liquidate(address,uint256)"));
        common[27] = bytes4(keccak256("flashLoan(address,uint256,bytes)"));
        common[28] = bytes4(keccak256("callback(bytes)"));
        common[29] = bytes4(keccak256("onFlashLoan(address,address,uint256,uint256,bytes)"));
        common[30] = bytes4(keccak256("uniswapV3SwapCallback(int256,int256,bytes)"));
        common[31] = bytes4(keccak256("pancakeV3SwapCallback(int256,int256,bytes)"));
        common[32] = bytes4(keccak256("upgradeTo(address)"));
        common[33] = bytes4(keccak256("upgradeToAndCall(address,bytes)"));
        common[34] = bytes4(keccak256("initialize()"));
        common[35] = bytes4(keccak256("initialize(address)"));
        common[36] = bytes4(keccak256("init(bytes)"));
        common[37] = bytes4(keccak256("setup(bytes)"));
        common[38] = bytes4(keccak256("emergencyWithdraw()"));
        common[39] = bytes4(keccak256("rescue(address,uint256)"));
        common[40] = bytes4(keccak256("sweep(address)"));
        common[41] = bytes4(keccak256("skim(address)"));
        common[42] = bytes4(keccak256("sync()"));
        common[43] = bytes4(keccak256("updateAccounting()"));
        common[44] = bytes4(keccak256("accrueInterest()"));
        common[45] = bytes4(keccak256("rebase()"));
        common[46] = bytes4(keccak256("distribute()"));
        common[47] = bytes4(keccak256("setFee(uint256)"));
        common[48] = bytes4(keccak256("setTreasury(address)"));
        common[49] = bytes4(keccak256("pause()"));

        return common;
    }

    function classifyFunction(bytes4 selector) internal pure returns (FunctionCategory) {
        // Funds movement
        if (selector == bytes4(keccak256("deposit(uint256)")) ||
            selector == bytes4(keccak256("withdraw(uint256)")) ||
            selector == bytes4(keccak256("transfer(address,uint256)")) ||
            selector == bytes4(keccak256("swap(uint256,uint256,address,bytes)"))) {
            return FunctionCategory.FUNDS_MOVEMENT;
        }

        // Oracle operations
        if (selector == bytes4(keccak256("getPrice(address)")) ||
            selector == bytes4(keccak256("latestAnswer()"))) {
            return FunctionCategory.ORACLE_READ;
        }

        if (selector == bytes4(keccak256("setPrice(uint256)")) ||
            selector == bytes4(keccak256("updatePrice(address,uint256)"))) {
            return FunctionCategory.ORACLE_WRITE;
        }

        // Share operations
        if (selector == bytes4(keccak256("mint(address,uint256)")) ||
            selector == bytes4(keccak256("burn(uint256)"))) {
            return FunctionCategory.SHARE_MINT_BURN;
        }

        // Admin
        if (selector == bytes4(keccak256("setOwner(address)")) ||
            selector == bytes4(keccak256("grantRole(bytes32,address)"))) {
            return FunctionCategory.ADMIN_CONTROL;
        }

        return FunctionCategory.UNKNOWN;
    }

    function probeFunction(address target, bytes4 selector) internal returns (bool exists) {
        (bool success,) = target.staticcall(abi.encodeWithSelector(selector));
        return success;
    }

    function isProxy(address target) internal view returns (bool, address) {
        // Check EIP-1967 implementation slot
        bytes32 implSlot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
        bytes32 impl = vm.load(target, implSlot);

        if (impl != bytes32(0) && uint256(impl) > 0x1000) {
            return (true, address(uint160(uint256(impl))));
        }

        // Check EIP-1967 beacon slot
        bytes32 beaconSlot = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;
        bytes32 beacon = vm.load(target, beaconSlot);

        if (beacon != bytes32(0) && uint256(beacon) > 0x1000) {
            return (true, address(uint160(uint256(beacon))));
        }

        return (false, address(0));
    }

    function checkInitialized(address target) internal view returns (bool, uint8) {
        // Common initialization slot patterns
        bytes32 slot0 = vm.load(target, bytes32(0));

        // OpenZeppelin Initializable uses slot 0 with _initialized flag
        uint8 initialized = uint8(uint256(slot0));

        return (initialized > 0, initialized);
    }

    // ============ INVARIANT CHECKING ============

    function checkConservation(
        address target,
        address token,
        uint256 expectedTotal
    ) internal view returns (bool valid, int256 diff) {
        uint256 actual = IERC20Minimal(token).balanceOf(target);
        diff = int256(actual) - int256(expectedTotal);
        valid = diff >= 0; // Should never have less than expected
    }

    function checkSharePriceMonotonicity(
        address vault,
        uint256 previousPrice
    ) internal returns (bool valid, uint256 currentPrice) {
        // Try common share price getters
        try IVaultLike(vault).getPricePerFullShare() returns (uint256 price) {
            currentPrice = price;
        } catch {
            try IVaultLike(vault).pricePerShare() returns (uint256 price) {
                currentPrice = price;
            } catch {
                try IVaultLike(vault).exchangeRate() returns (uint256 price) {
                    currentPrice = price;
                } catch {
                    return (true, previousPrice); // Can't determine
                }
            }
        }

        valid = currentPrice >= previousPrice;
    }

    function recordInvariant(
        string memory name,
        uint256 before,
        uint256 after_
    ) internal {
        invariantResults.push(InvariantResult({
            name: name,
            violated: after_ < before,
            valueBefore: before,
            valueAfter: after_,
            delta: int256(after_) - int256(before)
        }));
    }

    // ============ ADVERSARIAL INPUT GENERATION ============

    function generateAdversarialAmounts() internal pure returns (uint256[] memory) {
        uint256[] memory amounts = new uint256[](12);
        amounts[0] = 0;
        amounts[1] = 1;
        amounts[2] = 2;
        amounts[3] = type(uint256).max;
        amounts[4] = type(uint256).max - 1;
        amounts[5] = type(uint128).max;
        amounts[6] = 1e6;  // USDC decimals
        amounts[7] = 1e8;  // BTC decimals
        amounts[8] = 1e18; // ETH decimals
        amounts[9] = 1e27; // RAY
        amounts[10] = 1e45; // WAD squared
        amounts[11] = 115792089237316195423570985008687907853269984665640564039457584007913129639935; // max - 1
        return amounts;
    }

    function generateAdversarialAddresses() internal returns (address[] memory) {
        address[] memory addrs = new address[](10);
        addrs[0] = address(0);
        addrs[1] = address(1);
        addrs[2] = address(this);
        addrs[3] = currentAttacker;
        addrs[4] = address(uint160(uint256(keccak256("malicious"))));
        addrs[5] = WETH;
        addrs[6] = USDC;
        addrs[7] = address(0xdead);
        addrs[8] = address(0xbeef);
        addrs[9] = makeAddr("victim");
        return addrs;
    }

    function generateMaliciousCalldata() internal pure returns (bytes[] memory) {
        bytes[] memory data = new bytes[](8);
        data[0] = "";
        data[1] = hex"00";
        data[2] = hex"deadbeef";
        data[3] = abi.encodeWithSignature("attack()");
        data[4] = abi.encodeWithSignature("initialize()");
        data[5] = abi.encodeWithSignature("transferOwnership(address)", address(1));
        data[6] = new bytes(1000); // Large calldata
        data[7] = abi.encodePacked(bytes4(0xffffffff)); // Invalid selector
        return data;
    }

    // ============ ORACLE MANIPULATION DETECTION ============

    function checkOracleManipulability(
        address oracle,
        address token
    ) internal returns (bool manipulable, uint256 priceImpact) {
        // Get current price
        uint256 priceBefore;
        try IOracleLike(oracle).getPrice(token) returns (uint256 price) {
            priceBefore = price;
        } catch {
            try IOracleLike(oracle).latestAnswer() returns (int256 price) {
                priceBefore = uint256(price);
            } catch {
                return (false, 0);
            }
        }

        // Try to manipulate via DEX if it's a spot oracle
        // This would require actual swap simulation

        return (false, 0);
    }

    function checkPriceDeviation(
        uint256 oraclePrice,
        uint256 spotPrice,
        uint256 maxDeviationBps
    ) internal pure returns (bool valid) {
        if (oraclePrice == 0 || spotPrice == 0) return false;

        uint256 diff = oraclePrice > spotPrice
            ? oraclePrice - spotPrice
            : spotPrice - oraclePrice;

        uint256 deviationBps = (diff * 10000) / oraclePrice;
        return deviationBps <= maxDeviationBps;
    }

    // ============ REENTRANCY DETECTION ============

    uint256 private _reentrancyDepth;
    uint256 private constant MAX_REENTRANCY_DEPTH = 1;

    function trackReentrancy() internal {
        _reentrancyDepth++;
        require(_reentrancyDepth <= MAX_REENTRANCY_DEPTH, "REENTRANCY_DETECTED");
    }

    function clearReentrancy() internal {
        _reentrancyDepth = 0;
    }

    function checkExternalCallBeforeStateUpdate(
        address target,
        bytes4 selector
    ) internal pure returns (bool vulnerable) {
        // This would require bytecode analysis
        // Placeholder for static analysis integration
        return false;
    }

    // ============ ARITHMETIC PRECISION AUDITING ============

    function checkRoundingExploit(
        uint256 numerator,
        uint256 denominator,
        uint256 iterations
    ) internal pure returns (bool exploitable, uint256 driftAmount) {
        if (denominator == 0) return (true, type(uint256).max);

        uint256 accumulated = 0;
        uint256 expected = (numerator * iterations) / denominator;

        for (uint256 i = 0; i < iterations; i++) {
            accumulated += numerator / denominator;
        }

        driftAmount = expected > accumulated ? expected - accumulated : accumulated - expected;
        exploitable = driftAmount > iterations; // More than 1 wei drift per iteration is suspicious
    }

    function checkOverflowUnderflow(
        uint256 a,
        uint256 b,
        bool isAddition
    ) internal pure returns (bool safe) {
        if (isAddition) {
            return a <= type(uint256).max - b;
        } else {
            return a >= b;
        }
    }

    // ============ EXPLOIT EXECUTION ============

    function executeExploit(
        string memory name,
        address target,
        bytes memory callData,
        uint256 value
    ) internal returns (bool success, bytes memory result) {
        uint256 balanceBefore = currentAttacker.balance;

        vm.startPrank(currentAttacker);
        (success, result) = target.call{value: value}(callData);
        vm.stopPrank();

        uint256 balanceAfter = currentAttacker.balance;
        uint256 profit = balanceAfter > balanceBefore ? balanceAfter - balanceBefore : 0;

        exploitAttempts.push(ExploitAttempt({
            name: name,
            success: success && profit > 0,
            profitWei: profit,
            profitUSD: 0, // Would need oracle integration
            callData: callData,
            trace: ""
        }));
    }

    function executeFlashLoanExploit(
        string memory name,
        address flashLoanProvider,
        address token,
        uint256 amount,
        bytes memory exploitCalldata
    ) internal returns (bool success, uint256 profit) {
        uint256 balanceBefore = IERC20Minimal(token).balanceOf(currentAttacker);

        // Simulate flash loan
        deal(token, currentAttacker, amount);

        vm.startPrank(currentAttacker);
        (success,) = address(this).call(exploitCalldata);
        vm.stopPrank();

        uint256 balanceAfter = IERC20Minimal(token).balanceOf(currentAttacker);

        // Must repay flash loan
        if (balanceAfter >= amount) {
            profit = balanceAfter - amount;
            success = profit > 0;
        } else {
            profit = 0;
            success = false;
        }

        exploitAttempts.push(ExploitAttempt({
            name: name,
            success: success,
            profitWei: profit,
            profitUSD: 0,
            callData: exploitCalldata,
            trace: ""
        }));
    }

    // ============ REPORTING ============

    function printAnalysis(address target) internal view {
        ContractAnalysis memory analysis = analyses[target];
        console.log("=== Contract Analysis ===");
        console.log("Target:", target);
        console.log("Is Proxy:", analysis.isProxy);
        if (analysis.isProxy) {
            console.log("Implementation:", analysis.implementation);
        }
        console.log("Total Functions:", analysis.totalFunctions);
        console.log("Privileged Functions:", analysis.privilegedFunctions);
        console.log("Funds Movement Functions:", analysis.fundsMovementFunctions);
        console.log("External Call Functions:", analysis.externalCallFunctions);
    }

    function printInvariantResults() internal view {
        console.log("=== Invariant Results ===");
        for (uint256 i = 0; i < invariantResults.length; i++) {
            InvariantResult memory result = invariantResults[i];
            console.log("Invariant:", result.name);
            console.log("Violated:", result.violated);
            console.log("Before:", result.valueBefore);
            console.log("After:", result.valueAfter);
            console.logInt(result.delta);
            console.log("---");
        }
    }

    function printExploitResults() internal view {
        console.log("=== Exploit Results ===");
        for (uint256 i = 0; i < exploitAttempts.length; i++) {
            ExploitAttempt memory attempt = exploitAttempts[i];
            console.log("Exploit:", attempt.name);
            console.log("Success:", attempt.success);
            console.log("Profit (wei):", attempt.profitWei);
            console.log("---");
        }
    }
}

// ============ INTERFACES ============

interface IERC20Minimal {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function totalSupply() external view returns (uint256);
}

interface IVaultLike {
    function getPricePerFullShare() external view returns (uint256);
    function pricePerShare() external view returns (uint256);
    function exchangeRate() external view returns (uint256);
    function totalAssets() external view returns (uint256);
    function totalSupply() external view returns (uint256);
}

interface IOracleLike {
    function getPrice(address) external view returns (uint256);
    function latestAnswer() external view returns (int256);
    function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80);
}

interface IFlashLoanReceiver {
    function onFlashLoan(
        address initiator,
        address token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external returns (bytes32);
}
