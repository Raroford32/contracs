// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title ArithmeticPrecisionAudit
 * @notice Detects arithmetic precision vulnerabilities
 * @dev Covers rounding exploits, overflow/underflow, precision drift, and mixed decimals
 */
contract ArithmeticPrecisionAudit is Test {

    // ============ CONSTANTS ============

    uint256 constant WAD = 1e18;
    uint256 constant RAY = 1e27;
    uint256 constant RAD = 1e45;

    uint256 constant MAX_ITERATIONS = 1000;
    uint256 constant PROFIT_THRESHOLD = 100; // Wei threshold for profitable exploit

    // ============ STRUCTS ============

    struct PrecisionAnalysis {
        address target;
        bytes4 selector;
        bool hasRoundingVuln;
        bool hasOverflowRisk;
        bool hasUnderflowRisk;
        bool hasPrecisionDrift;
        bool hasMixedDecimals;
        uint256 roundingProfit;
        uint256 driftPerIteration;
        uint256 iterationsToExploit;
        string[] vulnerabilities;
    }

    struct RoundingTest {
        uint256 inputAmount;
        uint256 expectedOutput;
        uint256 actualOutput;
        int256 roundingError;
        bool favorable;
    }

    struct DriftTest {
        uint256 initialValue;
        uint256 finalValue;
        uint256 iterations;
        int256 totalDrift;
        uint256 profitPotential;
    }

    mapping(address => mapping(bytes4 => PrecisionAnalysis)) public analyses;

    // ============ MAIN ANALYSIS FUNCTIONS ============

    function analyzePrecision(
        address target,
        bytes4 selector,
        uint256[] memory testAmounts
    ) public returns (PrecisionAnalysis memory analysis) {
        analysis.target = target;
        analysis.selector = selector;
        analysis.vulnerabilities = new string[](10);
        uint256 vulnCount = 0;

        // Test rounding vulnerabilities
        (analysis.hasRoundingVuln, analysis.roundingProfit) = testRoundingExploits(
            target, selector, testAmounts
        );
        if (analysis.hasRoundingVuln) {
            analysis.vulnerabilities[vulnCount++] = "ROUNDING_EXPLOIT";
        }

        // Test overflow risks
        analysis.hasOverflowRisk = testOverflowRisks(target, selector);
        if (analysis.hasOverflowRisk) {
            analysis.vulnerabilities[vulnCount++] = "OVERFLOW_RISK";
        }

        // Test underflow risks
        analysis.hasUnderflowRisk = testUnderflowRisks(target, selector);
        if (analysis.hasUnderflowRisk) {
            analysis.vulnerabilities[vulnCount++] = "UNDERFLOW_RISK";
        }

        // Test precision drift
        (analysis.hasPrecisionDrift, analysis.driftPerIteration, analysis.iterationsToExploit) =
            testPrecisionDrift(target, selector);
        if (analysis.hasPrecisionDrift) {
            analysis.vulnerabilities[vulnCount++] = "PRECISION_DRIFT";
        }

        // Test mixed decimals
        analysis.hasMixedDecimals = testMixedDecimals(target, selector);
        if (analysis.hasMixedDecimals) {
            analysis.vulnerabilities[vulnCount++] = "MIXED_DECIMAL_PRECISION";
        }

        // Store analysis
        analyses[target][selector] = analysis;
    }

    // ============ ROUNDING EXPLOIT DETECTION ============

    function testRoundingExploits(
        address target,
        bytes4 selector,
        uint256[] memory testAmounts
    ) public returns (bool hasVuln, uint256 maxProfit) {
        maxProfit = 0;

        for (uint256 i = 0; i < testAmounts.length; i++) {
            RoundingTest memory result = testSingleRounding(target, selector, testAmounts[i]);

            if (result.favorable && uint256(result.roundingError > 0 ? result.roundingError : -result.roundingError) > maxProfit) {
                maxProfit = uint256(result.roundingError > 0 ? result.roundingError : -result.roundingError);
            }
        }

        // Test specific rounding attack patterns
        uint256 dustProfit = testDustRoundingAttack(target, selector);
        if (dustProfit > maxProfit) maxProfit = dustProfit;

        uint256 firstDepositorProfit = testFirstDepositorAttack(target, selector);
        if (firstDepositorProfit > maxProfit) maxProfit = firstDepositorProfit;

        hasVuln = maxProfit >= PROFIT_THRESHOLD;
    }

    function testSingleRounding(
        address target,
        bytes4 selector,
        uint256 amount
    ) public returns (RoundingTest memory result) {
        result.inputAmount = amount;

        // Try to call the function and get output
        (bool success, bytes memory returnData) = target.staticcall(
            abi.encodeWithSelector(selector, amount)
        );

        if (success && returnData.length >= 32) {
            result.actualOutput = abi.decode(returnData, (uint256));

            // Calculate expected output (assuming 1:1 for simplicity)
            // In practice, would need function-specific logic
            result.expectedOutput = amount;

            result.roundingError = int256(result.actualOutput) - int256(result.expectedOutput);
            result.favorable = result.roundingError > 0; // Attacker gains
        }
    }

    function testDustRoundingAttack(
        address target,
        bytes4 selector
    ) public returns (uint256 profit) {
        // Test if depositing dust amounts repeatedly can accumulate rounding errors

        uint256[] memory dustAmounts = new uint256[](5);
        dustAmounts[0] = 1;
        dustAmounts[1] = 2;
        dustAmounts[2] = 3;
        dustAmounts[3] = WAD - 1;
        dustAmounts[4] = WAD + 1;

        uint256 totalInput = 0;
        uint256 totalOutput = 0;

        for (uint256 i = 0; i < dustAmounts.length; i++) {
            (bool success, bytes memory returnData) = target.staticcall(
                abi.encodeWithSelector(selector, dustAmounts[i])
            );

            if (success && returnData.length >= 32) {
                totalInput += dustAmounts[i];
                totalOutput += abi.decode(returnData, (uint256));
            }
        }

        // Check if output exceeds input (attacker profit)
        if (totalOutput > totalInput) {
            profit = totalOutput - totalInput;
        }
    }

    function testFirstDepositorAttack(
        address target,
        bytes4 selector
    ) public returns (uint256 profit) {
        // Simulate first depositor inflation attack
        // Pattern: deposit 1 wei, donate large amount, subsequent depositors get rounded down

        // This is a complex attack that requires multiple calls
        // Simplified check for share price manipulation potential

        // Check if pricePerShare can be manipulated
        bytes4 priceSelector = bytes4(keccak256("pricePerShare()"));
        (bool success1, bytes memory data1) = target.staticcall(abi.encodeWithSelector(priceSelector));

        if (!success1) {
            priceSelector = bytes4(keccak256("convertToAssets(uint256)"));
            (success1, data1) = target.staticcall(abi.encodeWithSelector(priceSelector, WAD));
        }

        if (success1 && data1.length >= 32) {
            uint256 initialPrice = abi.decode(data1, (uint256));

            // If price can be > 1e18 per share, first depositor attack might be possible
            if (initialPrice > WAD * 2) {
                profit = initialPrice - WAD; // Potential profit per share
            }
        }
    }

    // ============ OVERFLOW/UNDERFLOW DETECTION ============

    function testOverflowRisks(
        address target,
        bytes4 selector
    ) public returns (bool hasRisk) {
        // Test with max values
        uint256[] memory overflowTests = new uint256[](5);
        overflowTests[0] = type(uint256).max;
        overflowTests[1] = type(uint256).max - 1;
        overflowTests[2] = type(uint128).max;
        overflowTests[3] = type(uint128).max + 1;
        overflowTests[4] = type(uint256).max / 2;

        for (uint256 i = 0; i < overflowTests.length; i++) {
            // Try calling with extreme values
            (bool success,) = target.staticcall(
                abi.encodeWithSelector(selector, overflowTests[i])
            );

            // If call succeeds with max values, might indicate unchecked arithmetic
            // In Solidity 0.8+, this would revert, but older contracts might wrap
            if (success) {
                // Check if result wraps around
                (, bytes memory data) = target.staticcall(
                    abi.encodeWithSelector(selector, overflowTests[i])
                );

                if (data.length >= 32) {
                    uint256 result = abi.decode(data, (uint256));
                    // If result is smaller than input for multiplication-based functions
                    // it might indicate wrapping
                    if (result < overflowTests[i] / 2) {
                        hasRisk = true;
                        break;
                    }
                }
            }
        }
    }

    function testUnderflowRisks(
        address target,
        bytes4 selector
    ) public returns (bool hasRisk) {
        // Test with values that might cause underflow
        uint256[] memory underflowTests = new uint256[](3);
        underflowTests[0] = 0;
        underflowTests[1] = 1;
        underflowTests[2] = type(uint256).max; // Could cause underflow in subtraction

        for (uint256 i = 0; i < underflowTests.length; i++) {
            (bool success, bytes memory data) = target.staticcall(
                abi.encodeWithSelector(selector, underflowTests[i])
            );

            if (success && data.length >= 32) {
                uint256 result = abi.decode(data, (uint256));

                // Check for suspicious large results from small inputs
                // (might indicate underflow wrapping)
                if (underflowTests[i] <= 1 && result > WAD * 1000) {
                    hasRisk = true;
                    break;
                }
            }
        }
    }

    // ============ PRECISION DRIFT DETECTION ============

    function testPrecisionDrift(
        address target,
        bytes4 selector
    ) public returns (bool hasDrift, uint256 driftPerIter, uint256 itersToExploit) {
        // Test if repeated operations accumulate rounding errors

        uint256 testAmount = WAD;
        int256 totalDrift = 0;

        // Simulate repeated deposit/withdraw cycle
        for (uint256 i = 0; i < 100; i++) {
            (bool success1, bytes memory data1) = target.staticcall(
                abi.encodeWithSelector(selector, testAmount)
            );

            if (success1 && data1.length >= 32) {
                uint256 output = abi.decode(data1, (uint256));
                int256 iterDrift = int256(output) - int256(testAmount);
                totalDrift += iterDrift;
            }
        }

        // Calculate average drift
        driftPerIter = totalDrift >= 0 ? uint256(totalDrift) / 100 : uint256(-totalDrift) / 100;

        // Calculate iterations needed to accumulate significant drift
        if (driftPerIter > 0) {
            itersToExploit = WAD / driftPerIter;
            hasDrift = itersToExploit < MAX_ITERATIONS;
        }
    }

    // ============ MIXED DECIMALS DETECTION ============

    function testMixedDecimals(
        address target,
        bytes4 selector
    ) public returns (bool hasMixed) {
        // Test if function handles different decimal tokens correctly

        // Common decimal values
        uint256[] memory decimalTests = new uint256[](4);
        decimalTests[0] = 1e6;  // USDC/USDT (6 decimals)
        decimalTests[1] = 1e8;  // WBTC (8 decimals)
        decimalTests[2] = 1e18; // Most tokens (18 decimals)
        decimalTests[3] = 1e27; // RAY precision

        uint256 baseResult;
        (bool success, bytes memory data) = target.staticcall(
            abi.encodeWithSelector(selector, decimalTests[2]) // Base: 18 decimals
        );

        if (success && data.length >= 32) {
            baseResult = abi.decode(data, (uint256));
        } else {
            return false;
        }

        // Check if other decimal inputs produce proportionally correct results
        for (uint256 i = 0; i < decimalTests.length; i++) {
            if (i == 2) continue; // Skip base

            (success, data) = target.staticcall(
                abi.encodeWithSelector(selector, decimalTests[i])
            );

            if (success && data.length >= 32) {
                uint256 result = abi.decode(data, (uint256));

                // Calculate expected result based on decimal ratio
                uint256 expectedRatio;
                if (decimalTests[i] > decimalTests[2]) {
                    expectedRatio = decimalTests[i] / decimalTests[2];
                } else {
                    expectedRatio = decimalTests[2] / decimalTests[i];
                }

                uint256 actualRatio;
                if (result > baseResult) {
                    actualRatio = result / baseResult;
                } else if (result > 0) {
                    actualRatio = baseResult / result;
                } else {
                    continue;
                }

                // If ratio differs significantly, might indicate decimal handling issue
                if (actualRatio > expectedRatio * 2 || actualRatio < expectedRatio / 2) {
                    hasMixed = true;
                    break;
                }
            }
        }
    }

    // ============ SPECIFIC EXPLOIT PATTERNS ============

    /**
     * @notice Test share inflation attack (vault donation attack)
     */
    function testShareInflationAttack(
        address vault
    ) public returns (bool vulnerable, uint256 maxProfit) {
        // Pattern:
        // 1. Attacker deposits 1 wei, gets 1 share
        // 2. Attacker donates large amount directly to vault
        // 3. Victim deposits, gets rounded down due to inflated share price
        // 4. Attacker withdraws, taking victim's rounded amount

        // Check initial share price
        bytes4 convertSelector = bytes4(keccak256("convertToShares(uint256)"));
        (bool success, bytes memory data) = vault.staticcall(
            abi.encodeWithSelector(convertSelector, WAD)
        );

        if (!success || data.length < 32) return (false, 0);

        uint256 initialShares = abi.decode(data, (uint256));

        // Simulate donation by checking if direct transfer affects share price
        // In practice, would need to actually transfer and recheck

        // For now, check if totalAssets can be inflated
        bytes4 assetsSelector = bytes4(keccak256("totalAssets()"));
        (success, data) = vault.staticcall(abi.encodeWithSelector(assetsSelector));

        if (success && data.length >= 32) {
            uint256 totalAssets = abi.decode(data, (uint256));

            // If totalAssets is small and shares are being issued, vulnerable
            if (totalAssets < WAD && initialShares > 0) {
                vulnerable = true;
                // Potential profit depends on donation size vs victim deposit
                maxProfit = WAD; // Rough estimate
            }
        }
    }

    /**
     * @notice Test reward accumulator rounding attack
     */
    function testRewardAccumulatorAttack(
        address staking
    ) public returns (bool vulnerable, uint256 profitPerClaim) {
        // Pattern: Claim rewards many times with dust amounts to accumulate rounding

        bytes4 earnedSelector = bytes4(keccak256("earned(address)"));
        bytes4 claimSelector = bytes4(keccak256("claim()"));

        // Check if earned amount can be manipulated through repeated small claims
        address attacker = makeAddr("attacker");

        (bool success, bytes memory data) = staking.staticcall(
            abi.encodeWithSelector(earnedSelector, attacker)
        );

        if (!success) return (false, 0);

        // Simplified check - real test would need state manipulation
        vulnerable = false;
        profitPerClaim = 0;
    }

    // ============ UTILITY FUNCTIONS ============

    function mulDivDown(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256) {
        return (x * y) / denominator;
    }

    function mulDivUp(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256) {
        return (x * y + denominator - 1) / denominator;
    }

    function checkRoundingDirection(
        uint256 input,
        uint256 output,
        bool shouldRoundDown
    ) internal pure returns (bool correct) {
        uint256 expected = input; // Simplified
        if (shouldRoundDown) {
            correct = output <= expected;
        } else {
            correct = output >= expected;
        }
    }

    // ============ REPORTING ============

    function printAnalysis(address target, bytes4 selector) public view {
        PrecisionAnalysis storage analysis = analyses[target][selector];

        console.log("=== Arithmetic Precision Analysis ===");
        console.log("Target:", target);
        console.log("Selector:", uint32(selector));
        console.log("Has Rounding Vuln:", analysis.hasRoundingVuln);
        console.log("Rounding Profit (wei):", analysis.roundingProfit);
        console.log("Has Overflow Risk:", analysis.hasOverflowRisk);
        console.log("Has Underflow Risk:", analysis.hasUnderflowRisk);
        console.log("Has Precision Drift:", analysis.hasPrecisionDrift);
        console.log("Drift Per Iteration:", analysis.driftPerIteration);
        console.log("Iterations to Exploit:", analysis.iterationsToExploit);
        console.log("Has Mixed Decimals:", analysis.hasMixedDecimals);

        console.log("Vulnerabilities:");
        for (uint256 i = 0; i < analysis.vulnerabilities.length; i++) {
            if (bytes(analysis.vulnerabilities[i]).length > 0) {
                console.log("  -", analysis.vulnerabilities[i]);
            }
        }
    }

    function generateRoundingExploitPOC(
        address target,
        bytes4 selector,
        uint256 exploitAmount
    ) public pure returns (bytes memory poc) {
        // Generate proof-of-concept calldata
        poc = abi.encodeWithSelector(selector, exploitAmount);
    }
}
