# Deep Analysis: 0x5050e08626c499411B5D0E0b5AF0E83d3fD82EDF

**Analysis Date:** 2026-01-24
**Contract Type:** DSProxy variant with UniswapV3 callback integration
**Verification Status:** Unverified (bytecode analysis only)
**Chain:** Ethereum Mainnet

---

## Executive Summary

This is a **DSProxy-style execution proxy** with integrated Uniswap V3 swap callback handling. The contract holds significant value (~6.25 ETH + ~603,836 USDC + ~100 USDT) and is controlled by a **hardcoded whitelist of ~50 EOA addresses** plus a dynamic `wards` mapping.

### Key Findings

| Finding | Severity | Exploitable | Description |
|---------|----------|-------------|-------------|
| Hardcoded Whitelist | INFO | No* | 50 EOA addresses permanently authorized |
| Irrevocable Access | MEDIUM | Depends | Hardcoded addresses cannot be revoked by contract |
| Delegatecall Execution | HIGH (if compromised) | Requires key | Full contract takeover possible with any whitelist key |
| Pool Verification Solid | INFO | No | CREATE2 verification is cryptographically sound |

*Not exploitable without private key compromise of a whitelisted address

---

## Contract Architecture

### Function Selectors

| Selector | Function | Access Control |
|----------|----------|----------------|
| `0x1cff79cd` | `execute(address,bytes)` | Requires `isAuth()` |
| `0x1f6a1eb9` | `execute(bytes,bytes)` | Requires `isAuth()` |
| `0x78e111f6` | `execute(address,bytes) returns (bytes)` | Requires `isAuth()` |
| `0xa90e8731` | `execute(bytes,bytes) returns (bytes)` | Requires `isAuth()` |
| `0x65fae35e` | `rely(address)` | Requires `isAuth()` |
| `0x9c52a7f1` | `deny(address)` | Requires `isAuth()` |
| `0x97645e37` | `rely(address[])` | Requires `isAuth()` |
| `0xc9892a5f` | `deny(address[])` | Requires `isAuth()` |
| `0x948f5076` | `setCache(address)` | Requires `isAuth()` |
| `0x60c7d295` | `cache()` | Public view |
| `0xbf353dbb` | `wards(address)` | Public view |
| `0xfa461e33` | `uniswapV3SwapCallback(...)` | Pool caller verification |

### Storage Layout

| Slot | Content | Current Value |
|------|---------|---------------|
| 0 | `wards` mapping base | 0x0 (no dynamic wards set) |
| 1 | `cache` address | 0x0 (no cache set) |

---

## Authorization Mechanism

### Dual-Layer Auth

The `isAuth()` function at bytecode offset ~0x0a39 implements:

1. **Hardcoded Whitelist** (~50 addresses): Binary search tree structure checking if `msg.sender` matches any of ~50 EOA addresses
2. **Dynamic Wards Mapping**: `wards[msg.sender] == 1`

Returns `true` if EITHER condition is satisfied.

### Hardcoded Whitelist Addresses (Sample)

```
0x8edfcca52d5c9116ff67e58b85c7eb0d98e2e989
0x36d63e35446baf55893a710cfe6dbdd300ece496
0x24affae9c683b7615d4130300288e348e4b5d091
0x1335d0a7cba7e5742399b0c94305136e8f4bc2a8
0x079c8d8fd8731ce2a284ef149d32e8e61cf21470
... (50 total)
```

All sampled addresses are **EOAs** (not contracts), meaning they cannot be exploited through contract vulnerabilities.

---

## Uniswap V3 Callback Analysis

### Callback Handler (Fallback at 0x00e1)

The contract handles `uniswapV3SwapCallback(int256,int256,bytes)` in its fallback:

1. **Selector Check**: Verifies `msg.sig == 0xfa461e33`
2. **Pool Verification**: Computes expected pool via CREATE2
   - Factory: `0x1f98431c8ad98523631ae4a59f267346ea31f984`
   - Salt: First 32 bytes of callback data
   - Init Hash: `0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54`
3. **Amount Validation**: At least one delta must be positive
4. **Transfer Mode**: Based on flag at calldata offset 0xa4
   - `flag == address(this)`: Skip transfer (recipient mode)
   - `flag == 1`: Direct `transfer()`
   - Otherwise: `transferFrom()`

### Expected Callback Data Format

```solidity
bytes memory data = abi.encodePacked(
    bytes32(poolKey),      // keccak256(token0, token1, fee)
    address(recipient),    // offset 0xa4-0xb7
    address(tokenToTransfer) // offset 0xc4-0xd7
);
```

### Security Assessment

- **Pool Verification**: Cryptographically sound; CREATE2 collision is computationally infeasible
- **Transfer Mode Bypass**: Not exploitable; requires being called by a valid Uniswap pool
- **Callback Data Manipulation**: Only controllable by swap initiator (requires `execute()` access)

---

## Exploit Primitive Analysis

### Capability Statements Evaluated

| Capability | Feasible | Blockers |
|------------|----------|----------|
| User can call `execute()` without authorization | No | `isAuth()` check, all whitelist are EOAs |
| User can become authorized via `rely()` | No | `rely()` requires `isAuth()` |
| User can spoof pool caller in callback | No | CREATE2 verification is sound |
| User can manipulate callback transfer mode | No | Requires pool caller status |
| User can exploit cache mechanism | No | Cache is unset (address 0) |
| User can front-run authorized tx | No | Auth check and execution are atomic |

### Residual Risk: Key Compromise

**If ANY of the 50 hardcoded whitelist addresses is compromised:**

1. Attacker gains full `execute()` access
2. Can `delegatecall` to malicious contract
3. Can drain all ETH, USDC, USDT via:
   ```solidity
   function drain() external {
       payable(msg.sender).transfer(address(this).balance);
       IERC20(USDC).transfer(msg.sender, IERC20(USDC).balanceOf(address(this)));
       IERC20(USDT).transfer(msg.sender, IERC20(USDT).balanceOf(address(this)));
   }
   ```

**Impact**: Complete loss of ~$610,000+ (at current prices)

---

## Invariant Violations Found

### FINDING 1: Irrevocable Hardcoded Access (MEDIUM)

**Broken Assumption**: "Contract owner can revoke all access"

**Reality**: The ~50 hardcoded addresses have **permanent, irrevocable access**. Even if `deny()` is called, the hardcoded whitelist check occurs BEFORE the `wards` mapping check.

**Capability Statement**: "Contract deployer cannot fully revoke access from hardcoded addresses, creating permanent trust dependency on 50 separate key holders"

**Risk**: If operational security degrades over time (key rotation failures, personnel changes, etc.), risk accumulates without mitigation capability.

### FINDING 2: No Rate Limiting on Execute (LOW)

**Broken Assumption**: "Value extraction is bounded"

**Reality**: A compromised key can drain the entire balance in a single transaction with no rate limits, pause mechanisms, or withdrawal delays.

**Capability Statement**: "An authorized user can extract all value in a single atomic transaction"

---

## Recommendations

1. **Multi-sig Migration**: Move funds to a contract with proper multi-sig governance
2. **Time-locks**: Implement withdrawal delays for large amounts
3. **Circuit Breakers**: Add pause functionality and rate limits
4. **Key Rotation**: Implement dynamic authorization that doesn't rely on hardcoded addresses

---

## Test Contract

A comprehensive test suite has been created at:
`test/DSProxyV3Analysis.t.sol`

This tests:
- Authorization bypass attempts
- Callback manipulation
- Invariant preservation under attack
- Compromised key scenarios

---

## Conclusion

The contract is **well-designed for its purpose** (DSProxy with UniswapV3 integration) with sound cryptographic verification in the callback handler. However, the **hardcoded whitelist creates an irreducible trust surface** across 50 EOA addresses.

**No permissionless exploit primitive was identified.** The primary risk is key compromise of any whitelisted address, which would enable complete fund drainage.

**Evidence Discipline**: All findings are based on bytecode analysis. No execution traces were obtained due to Foundry unavailability. Recommend running fork tests to verify findings.
