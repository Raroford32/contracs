#!/usr/bin/env python3
"""
Investigate KyberFeeHandler and KatanaFeeHandler for oracle staleness issues.
These contracts flagged ORACLE_STALENESS - they may use oracles without checking freshness.
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import time

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

TARGETS = [
    ("0xd3d2b5643e506c6d9b7099e9116d7aaa941114fe", "KyberFeeHandler", 88.93),
    ("0x9fb131efba31b63e3cbd8a9ae9d197fbe927ab80", "KatanaFeeHandler", 63.68),
]

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        result = resp.json()
        if 'error' in result:
            return None
        return result.get("result", "0x")
    except:
        return None

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def decode_address(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return None
    return "0x" + hex_result[-40:]

def decode_uint256(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return 0
    return int(hex_result[:66], 16)

def analyze_fee_handler(address, name, expected_eth):
    print(f"\n{'=' * 70}")
    print(f"ANALYZING: {name}")
    print(f"Address: {address}")
    print("=" * 70)

    # Get balance
    eth_bal = get_eth_balance(address)
    print(f"ETH Balance: {eth_bal / 1e18:.4f} ETH (${eth_bal / 1e18 * 2279:,.0f})")

    # Get source
    source_data = get_contract_source(address)
    if not source_data:
        print("No verified source")
        return

    source_code = source_data.get('SourceCode', '')
    contract_name = source_data.get('ContractName', 'Unknown')
    print(f"Contract: {contract_name}")

    if not source_code:
        print("Empty source")
        return

    # Save source for analysis
    with open(f'{name.lower()}_source.sol', 'w') as f:
        f.write(source_code)
    print(f"Source saved to {name.lower()}_source.sol")

    lower = source_code.lower()

    # Check for oracle patterns
    print("\n--- ORACLE USAGE ANALYSIS ---")

    patterns = {
        'latestRoundData': 'latestrounddata' in lower,
        'latestAnswer': 'latestanswer' in lower,
        'getPrice': 'getprice' in lower,
        'price oracle': 'oracle' in lower and 'price' in lower,
        'updatedAt check': 'updatedat' in lower,
        'staleness check': 'stale' in lower or 'heartbeat' in lower,
        'Chainlink': 'chainlink' in lower or 'aggregator' in lower,
        'Kyber oracle': 'kyberoracle' in lower or 'kybernetwork' in lower,
    }

    for p_name, found in patterns.items():
        print(f"  {p_name}: {'YES' if found else 'NO'}")

    # Look for specific oracle functions
    print("\n--- ORACLE FUNCTIONS ---")

    # Common price functions
    selectors_to_try = [
        ("owner()", "owner"),
        ("admin()", "admin"),
        ("kyberNetwork()", "kyberNetwork"),
        ("kyberDao()", "kyberDao"),
        ("knc()", "knc token"),
        ("rewardsPerEpoch()", "rewardsPerEpoch"),
        ("currentEpoch()", "currentEpoch"),
        ("feePool()", "feePool"),
    ]

    for sig, desc in selectors_to_try:
        selector = get_function_selector(sig)
        result = eth_call(address, selector)
        if result and result != "0x" and len(result) > 10:
            if 'address' in sig.lower() or 'owner' in sig.lower() or 'admin' in sig.lower() or sig.endswith("()"):
                addr = decode_address(result)
                if addr:
                    print(f"  {desc}: {addr}")
            else:
                value = decode_uint256(result)
                print(f"  {desc}: {value}")

    # Check exploitability
    print("\n--- EXPLOITABILITY ANALYSIS ---")

    # Look for extractable value
    extractable_functions = [
        'claimReward',
        'handleFees',
        'burnKnc',
        'withdraw',
    ]

    for func in extractable_functions:
        if func.lower() in lower:
            # Find the function definition
            lines = source_code.split('\n')
            for i, line in enumerate(lines):
                if func.lower() in line.lower() and 'function' in line.lower():
                    print(f"  Found: {line.strip()[:80]}")

    # Check for KNC token
    print("\n--- KNC TOKEN CHECK ---")

    # KNC token address
    KNC_TOKEN = "0xdeFA4e8a7bcBA345F687a2f1456F5Edd9CE97202"

    # Check KNC balance
    selector = get_function_selector("balanceOf(address)")
    data = selector + encode(['address'], [address]).hex()
    result = eth_call(KNC_TOKEN, data)
    if result:
        knc_bal = decode_uint256(result)
        print(f"  KNC Balance: {knc_bal / 1e18:.4f} KNC")

    # Economic analysis
    print("\n--- ECONOMIC ANALYSIS ---")

    # If no staleness check and uses oracle
    if not patterns['updatedAt check'] and not patterns['staleness check']:
        if patterns['latestRoundData'] or patterns['latestAnswer'] or patterns['Chainlink']:
            print("!!! POTENTIAL ORACLE STALENESS VULNERABILITY !!!")
            print("Contract uses oracle without checking timestamp")
            print("\nATTACK SCENARIO:")
            print("1. Wait for Chainlink feed staleness")
            print("2. Execute fee handling with stale price")
            print("3. Extract value if price has moved significantly")
        else:
            print("Uses non-Chainlink oracle - needs further analysis")
    else:
        print("Has staleness protection - not vulnerable")

    return {
        'address': address,
        'name': contract_name,
        'eth_balance': eth_bal,
        'has_staleness_check': patterns['updatedAt check'] or patterns['staleness check']
    }

def main():
    print("=" * 70)
    print("KYBER/KATANA FEE HANDLER ORACLE INVESTIGATION")
    print("=" * 70)

    for address, name, expected_eth in TARGETS:
        analyze_fee_handler(address, name, expected_eth)
        time.sleep(1)

    print("\n" + "=" * 70)
    print("CONCLUSION")
    print("=" * 70)
    print("""
For oracle staleness attacks to be viable:
1. Oracle must have no staleness check
2. Price must be used for value extraction (not just logging)
3. Function must be callable by attacker
4. Profit must exceed gas costs

Kyber uses time-weighted rewards and epochs, which may limit attack window.
""")

if __name__ == "__main__":
    main()
