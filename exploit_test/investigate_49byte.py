#!/usr/bin/env python3
"""
Deep investigation of 49-byte contracts that respond to all calls.
These could be:
1. Minimal proxies (EIP-1167)
2. Echo contracts
3. Misconfigured contracts
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"

TARGETS = [
    "0x10abe2494e4525f8cd2bac772671f0e1a44c6975",  # 10060 ETH
    "0x88aa042c4aae423e0f1bb48542b473d1dd20a807",  # 9383 ETH
]

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data, value=None, sender=None):
    call_params = {"to": to, "data": data}
    if sender:
        call_params["from"] = sender
    if value:
        call_params["value"] = hex(value)

    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [call_params, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return resp.json()
    except Exception as e:
        return {"error": str(e)}

def get_code(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getCode",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return resp.json().get("result", "0x")
    except:
        return "0x"

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def analyze_bytecode(code):
    """Analyze what a 49-byte contract does"""
    print(f"\nBytecode: {code}")
    print(f"Length: {len(code)} chars ({(len(code)-2)//2} bytes)")

    # Common patterns
    if code.startswith("0x363d3d373d3d3d363d73"):
        # EIP-1167 Minimal Proxy
        impl = "0x" + code[22:62]
        print(f"EIP-1167 Minimal Proxy -> Implementation: {impl}")
        return "proxy", impl
    elif code.startswith("0x36600080376000806000"):
        print("Appears to be a forwarding contract")
        return "forward", None
    else:
        # Disassemble manually
        bytecode = code[2:]  # Remove 0x
        print("\nOpcodes:")
        i = 0
        opcodes = []
        while i < len(bytecode):
            op = int(bytecode[i:i+2], 16)
            opname = get_opcode_name(op)
            opcodes.append((i//2, opname, bytecode[i:i+2]))

            if op >= 0x60 and op <= 0x7f:
                # PUSH1-PUSH32
                n = op - 0x5f
                data = bytecode[i+2:i+2+n*2]
                print(f"  {i//2:4}: {opname} 0x{data}")
                i += 2 + n*2
            else:
                print(f"  {i//2:4}: {opname}")
                i += 2

        return "unknown", opcodes

def get_opcode_name(op):
    opcodes = {
        0x00: "STOP", 0x01: "ADD", 0x02: "MUL", 0x03: "SUB",
        0x04: "DIV", 0x05: "SDIV", 0x06: "MOD", 0x07: "SMOD",
        0x10: "LT", 0x11: "GT", 0x14: "EQ", 0x15: "ISZERO",
        0x16: "AND", 0x17: "OR", 0x18: "XOR", 0x19: "NOT",
        0x20: "SHA3", 0x30: "ADDRESS", 0x31: "BALANCE",
        0x32: "ORIGIN", 0x33: "CALLER", 0x34: "CALLVALUE",
        0x35: "CALLDATALOAD", 0x36: "CALLDATASIZE",
        0x37: "CALLDATACOPY", 0x38: "CODESIZE",
        0x39: "CODECOPY", 0x3a: "GASPRICE",
        0x3b: "EXTCODESIZE", 0x3c: "EXTCODECOPY",
        0x3d: "RETURNDATASIZE", 0x3e: "RETURNDATACOPY",
        0x40: "BLOCKHASH", 0x41: "COINBASE",
        0x42: "TIMESTAMP", 0x43: "NUMBER",
        0x44: "DIFFICULTY", 0x45: "GASLIMIT",
        0x50: "POP", 0x51: "MLOAD", 0x52: "MSTORE",
        0x53: "MSTORE8", 0x54: "SLOAD", 0x55: "SSTORE",
        0x56: "JUMP", 0x57: "JUMPI", 0x58: "PC",
        0x59: "MSIZE", 0x5a: "GAS", 0x5b: "JUMPDEST",
        0x60: "PUSH1", 0x61: "PUSH2", 0x62: "PUSH3",
        0x63: "PUSH4", 0x64: "PUSH5", 0x65: "PUSH6",
        0x73: "PUSH20",
        0x80: "DUP1", 0x81: "DUP2", 0x82: "DUP3",
        0x90: "SWAP1", 0x91: "SWAP2",
        0xf0: "CREATE", 0xf1: "CALL", 0xf2: "CALLCODE",
        0xf3: "RETURN", 0xf4: "DELEGATECALL",
        0xf5: "CREATE2", 0xfa: "STATICCALL",
        0xfd: "REVERT", 0xfe: "INVALID", 0xff: "SELFDESTRUCT",
    }
    return opcodes.get(op, f"UNKNOWN({hex(op)})")

def main():
    print("=" * 70)
    print("49-BYTE CONTRACT INVESTIGATION")
    print("=" * 70)

    for target in TARGETS:
        print(f"\n{'=' * 70}")
        print(f"TARGET: {target}")
        print("=" * 70)

        balance = get_eth_balance(target)
        print(f"ETH Balance: {balance / 1e18:.2f} ETH (${balance / 1e18 * 2279:,.0f})")

        code = get_code(target)
        contract_type, impl = analyze_bytecode(code)

        if contract_type == "proxy" and impl:
            print(f"\n--- CHECKING IMPLEMENTATION: {impl} ---")

            impl_code = get_code(impl)
            impl_size = (len(impl_code) - 2) // 2
            print(f"Implementation code size: {impl_size} bytes")

            if impl_size > 0:
                # Try to get more info about implementation
                selector = get_function_selector("owner()")
                result = eth_call(impl, selector)
                if 'result' in result and len(result['result']) >= 42:
                    owner = "0x" + result['result'][-40:]
                    print(f"Implementation owner: {owner}")

        # Test actual withdrawal
        print("\n--- TESTING WITHDRAWAL ---")

        # Try sending a transaction (via eth_call to see result)
        selector = get_function_selector("withdraw()")
        result = eth_call(target, selector)
        print(f"withdraw() call result: {result}")

        # The response is just echoing the selector back
        # This is a CONTRACT THAT RETURNS ITS INPUT
        if 'result' in result:
            ret = result['result']
            if ret.startswith(selector[2:]) or ret.startswith("0x" + selector[2:]):
                print("!!! CONTRACT ECHOES INPUT - THIS IS UNUSUAL !!!")

        # Try calling with value
        print("\n--- TESTING FALLBACK WITH VALUE ---")
        result = eth_call(target, "0x", value=10**18)  # 1 ETH
        print(f"Fallback with 1 ETH result: {result}")

    print("\n" + "=" * 70)
    print("ANALYSIS")
    print("=" * 70)
    print("""
These 49-byte contracts appear to be IDENTITY contracts that
simply return their input (calldata). This is what the EVM's
built-in identity precompile at 0x04 does.

The high ETH balance is likely from:
1. People sending ETH expecting some action
2. ETH being stuck because there's no way to withdraw

These contracts are NOT exploitable because:
1. They have no logic to move ETH
2. They just echo back whatever data is sent
3. The ETH is permanently stuck

The bytecode is likely:
CALLDATASIZE
PUSH1 0x00
DUP1
CALLDATACOPY
CALLDATASIZE
PUSH1 0x00
RETURN

This copies calldata to memory and returns it.
""")

if __name__ == "__main__":
    main()
