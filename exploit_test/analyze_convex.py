#!/usr/bin/env python3
"""
Cross-Protocol Analysis Script
Analyzes Convex + Curve for semantic mismatches and exploitable conditions
"""

import json
import requests
from eth_abi import decode, encode
from eth_utils import keccak, to_checksum_address

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"

# Contract addresses
CONVEX_BOOSTER = "0xF403C135812408BFbE8713b5A23a04b3D48AAE31"
CONVEX_STAKER = "0x989AEb4d175e16225E39E87d0D97A3360524AD80"
CRV_TOKEN = "0xD533a949740bb3306d119CC777fa900bA034cd52"
CVX_TOKEN = "0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B"

def eth_call(to, data):
    """Make an eth_call to the RPC"""
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    resp = requests.post(RPC_URL, json=payload)
    result = resp.json().get("result", "0x")
    return result

def get_function_selector(sig):
    """Get 4-byte function selector from signature"""
    return "0x" + keccak(text=sig).hex()[:8]

def decode_uint256(hex_result):
    """Decode a hex string to uint256"""
    if hex_result == "0x" or not hex_result:
        return 0
    return int(hex_result, 16)

def query_pool_length():
    """Get number of Convex pools"""
    selector = get_function_selector("poolLength()")
    result = eth_call(CONVEX_BOOSTER, selector)
    return decode_uint256(result)

def query_pool_info(pool_id):
    """Get pool info from Convex Booster"""
    selector = get_function_selector("poolInfo(uint256)")
    data = selector + encode(['uint256'], [pool_id]).hex()
    result = eth_call(CONVEX_BOOSTER, data)

    if result == "0x" or len(result) < 130:
        return None

    try:
        # Decode: address lptoken, address token, address gauge, address crvRewards, address stash, bool shutdown
        decoded = decode(['address', 'address', 'address', 'address', 'address', 'bool'], bytes.fromhex(result[2:]))
        return {
            'lptoken': decoded[0],
            'token': decoded[1],
            'gauge': decoded[2],
            'crvRewards': decoded[3],
            'stash': decoded[4],
            'shutdown': decoded[5]
        }
    except Exception as e:
        print(f"Error decoding pool {pool_id}: {e}")
        return None

def query_balance_of(token, account):
    """Query ERC20 balanceOf"""
    selector = get_function_selector("balanceOf(address)")
    data = selector + encode(['address'], [account]).hex()
    result = eth_call(token, data)
    return decode_uint256(result)

def query_total_supply(token):
    """Query ERC20 totalSupply"""
    selector = get_function_selector("totalSupply()")
    result = eth_call(token, selector)
    return decode_uint256(result)

def query_reward_info(reward_pool):
    """Query reward pool state"""
    info = {}

    # periodFinish
    selector = get_function_selector("periodFinish()")
    result = eth_call(reward_pool, selector)
    info['periodFinish'] = decode_uint256(result)

    # rewardRate
    selector = get_function_selector("rewardRate()")
    result = eth_call(reward_pool, selector)
    info['rewardRate'] = decode_uint256(result)

    # queuedRewards
    selector = get_function_selector("queuedRewards()")
    result = eth_call(reward_pool, selector)
    info['queuedRewards'] = decode_uint256(result)

    # totalSupply
    selector = get_function_selector("totalSupply()")
    result = eth_call(reward_pool, selector)
    info['totalSupply'] = decode_uint256(result)

    return info

def query_claimable_tokens(gauge, account):
    """Query claimable CRV from gauge (this is a state-modifying call, need to handle differently)"""
    # claimable_tokens is actually a mutative function in Curve, but we can try eth_call
    selector = get_function_selector("claimable_tokens(address)")
    data = selector + encode(['address'], [account]).hex()
    result = eth_call(gauge, data)
    return decode_uint256(result)

def query_gauge_balance(gauge, account):
    """Query gauge balance"""
    selector = get_function_selector("balanceOf(address)")
    data = selector + encode(['address'], [account]).hex()
    result = eth_call(gauge, data)
    return decode_uint256(result)

def query_staker_balance_of_pool(gauge):
    """Query Convex staker's recorded balance in pool"""
    selector = get_function_selector("balanceOfPool(address)")
    data = selector + encode(['address'], [gauge]).hex()
    result = eth_call(CONVEX_STAKER, data)
    return decode_uint256(result)

def query_fee_info():
    """Query Convex fee structure"""
    fees = {}

    selectors = {
        'lockIncentive': 'lockIncentive()',
        'stakerIncentive': 'stakerIncentive()',
        'earmarkIncentive': 'earmarkIncentive()',
        'platformFee': 'platformFee()',
        'FEE_DENOMINATOR': 'FEE_DENOMINATOR()'
    }

    for name, sig in selectors.items():
        selector = get_function_selector(sig)
        result = eth_call(CONVEX_BOOSTER, selector)
        fees[name] = decode_uint256(result)

    return fees

def format_ether(wei):
    """Format wei to ether with 4 decimals"""
    return f"{wei / 1e18:.4f}"

def main():
    print("=" * 60)
    print("CROSS-PROTOCOL ANALYSIS: Convex + Curve")
    print("=" * 60)

    # Get pool length
    pool_length = query_pool_length()
    print(f"\nTotal Convex pools: {pool_length}")

    # Get fee structure
    print("\n--- FEE STRUCTURE ---")
    fees = query_fee_info()
    print(f"Lock Incentive: {fees['lockIncentive']} / {fees['FEE_DENOMINATOR']}")
    print(f"Staker Incentive: {fees['stakerIncentive']} / {fees['FEE_DENOMINATOR']}")
    print(f"Earmark Incentive: {fees['earmarkIncentive']} / {fees['FEE_DENOMINATOR']}")
    print(f"Platform Fee: {fees['platformFee']} / {fees['FEE_DENOMINATOR']}")

    # Analyze pools for opportunities
    print("\n--- ANALYZING POOLS FOR OPPORTUNITIES ---")

    total_pending_crv = 0
    divergent_pools = []
    opportunity_pools = []

    # Analyze ALL pools for maximum opportunity discovery
    for i in range(pool_length):
        pool = query_pool_info(i)
        if not pool or pool['shutdown']:
            continue

        gauge = pool['gauge']
        crv_rewards = pool['crvRewards']

        if gauge == "0x0000000000000000000000000000000000000000":
            continue

        # Check accounting divergence
        staker_recorded = query_staker_balance_of_pool(gauge)
        gauge_actual = query_gauge_balance(gauge, CONVEX_STAKER)

        if staker_recorded != gauge_actual and staker_recorded > 0:
            diff = abs(staker_recorded - gauge_actual)
            if diff > staker_recorded / 1000:  # > 0.1% difference
                divergent_pools.append({
                    'pool': i,
                    'recorded': staker_recorded,
                    'actual': gauge_actual,
                    'diff': diff
                })

        # Check pending CRV (this might not work via eth_call)
        try:
            pending = query_claimable_tokens(gauge, CONVEX_STAKER)
            if pending > 0:
                total_pending_crv += pending
                if pending > 1e20:  # > 100 CRV
                    earmark_bonus = (pending * fees['earmarkIncentive']) // fees['FEE_DENOMINATOR']
                    opportunity_pools.append({
                        'pool': i,
                        'pending_crv': pending,
                        'earmark_bonus': earmark_bonus,
                        'gauge': gauge
                    })
        except:
            pass

        # Check reward pool state
        if crv_rewards != "0x0000000000000000000000000000000000000000":
            reward_info = query_reward_info(crv_rewards)
            if reward_info['queuedRewards'] > 1e19:  # > 10 tokens
                queued_value_usd = (reward_info['queuedRewards'] * 50) / (100 * 1e18)
                print(f"Pool {i}: Queued rewards = {format_ether(reward_info['queuedRewards'])} CRV (${queued_value_usd:.2f})")
                if reward_info['queuedRewards'] > 1e22:  # > 10,000 CRV
                    opportunity_pools.append({
                        'pool': i,
                        'type': 'queued_rewards',
                        'value': reward_info['queuedRewards'],
                        'usd_value': queued_value_usd
                    })

    print("\n--- ACCOUNTING DIVERGENCE ANALYSIS ---")
    if divergent_pools:
        for dp in divergent_pools:
            print(f"Pool {dp['pool']}: DIVERGENCE FOUND")
            print(f"  Recorded: {format_ether(dp['recorded'])}")
            print(f"  Actual:   {format_ether(dp['actual'])}")
            print(f"  Diff:     {format_ether(dp['diff'])}")
    else:
        print("No significant accounting divergence found")

    print("\n--- EARMARK OPPORTUNITIES ---")
    if opportunity_pools:
        for op in sorted(opportunity_pools, key=lambda x: x['earmark_bonus'], reverse=True):
            print(f"Pool {op['pool']}:")
            print(f"  Pending CRV: {format_ether(op['pending_crv'])} CRV")
            print(f"  Earmark Bonus: {format_ether(op['earmark_bonus'])} CRV")
            # CRV ~ $0.50
            usd_value = (op['earmark_bonus'] * 50) / (100 * 1e18)
            print(f"  USD Value: ~${usd_value:.2f}")
    else:
        print("No significant earmark opportunities found (claimable_tokens may need simulation)")

    print("\n--- SUMMARY ---")
    print(f"Total pools analyzed: {min(50, pool_length)}")
    print(f"Divergent pools: {len(divergent_pools)}")
    print(f"Earmark opportunity pools: {len(opportunity_pools)}")
    print(f"Total pending CRV found: {format_ether(total_pending_crv)} CRV")

if __name__ == "__main__":
    main()
