#!/usr/bin/env python3
"""
Deep analysis of Liquity protocol contracts.

Liquity has:
- StabilityPool: Users deposit LUSD to earn ETH from liquidations + LQTY rewards
- TroveManager: Manages borrowing positions
- Active/DefaultPool: Hold ETH collateral
- LQTY staking: Stake LQTY to earn LUSD fees

Looking for:
1. Flash loan attack vectors on liquidations
2. Reward timing exploits
3. Price oracle mismatches
4. Cross-protocol semantic differences
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import json
import time

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

# Liquity contracts
LIQUITY = {
    'StabilityPool': '0x66017d22b0f8556afdd19fc67041899eb65a21bb',
    'TroveManager': '0xa39739ef8b0231dbfa0dcda07d7e29faabcf4bb2',
    'ActivePool': '0xdf9eb223bafbe5c5271415c75aecd68c21fe3d7f',
    'DefaultPool': '0x896a3f03176f05cfbb4f006bfcd8723f2b0d741c',
    'CollSurplusPool': '0x3d32e8b97ed5881324241cf03b2da5e2ebce5521',
    'LQTYStaking': '0x4f9fbb3f1e99b56e0fe2892e623ed36a76fc605d',
    'PriceFeed': '0x4c517d4e2c851ca76d7ec94b805269df0f2201de',
    'SortedTroves': '0x8fdd3fbfeb32b28fb73555518f8b361bcea741a6',
    'HintHelpers': '0xe39739ef8b0231dbfa0dcda07d7e29faabcf4bb2',
    'BorrowerOperations': '0x24179cd81c9e782a4096035f7ec97fb8b783e007',
    'LUSD': '0x5f98805a4e8be255a32880fdec7f6728c6568ba0',
    'LQTY': '0x6dea81c8171d0ba574754ef6f8b412f2ed88c54d',
}

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        result = resp.json()
        if 'error' in result:
            return None
        return result.get("result", "0x")
    except:
        return None

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def decode_uint256(hex_result):
    if hex_result == "0x" or not hex_result:
        return 0
    return int(hex_result, 16)

def format_ether(wei):
    return f"{wei / 1e18:.4f}"

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def main():
    print("=" * 70)
    print("LIQUITY PROTOCOL DEEP ANALYSIS")
    print("=" * 70)

    # Check TVL in each pool
    print("\n--- LIQUITY TVL ---")
    total_eth = 0

    for name, addr in LIQUITY.items():
        eth_bal = get_eth_balance(addr)
        if eth_bal > 0:
            print(f"{name}: {format_ether(eth_bal)} ETH (${eth_bal / 1e18 * 2279:,.0f})")
            total_eth += eth_bal

    print(f"\nTotal ETH in Liquity: {format_ether(total_eth)} (${total_eth / 1e18 * 2279:,.0f})")

    # Analyze StabilityPool mechanics
    print("\n" + "=" * 70)
    print("STABILITY POOL ANALYSIS")
    print("=" * 70)

    sp_addr = LIQUITY['StabilityPool']

    # Get total LUSD deposits
    selector = get_function_selector("getTotalLUSDDeposits()")
    result = eth_call(sp_addr, selector)
    if result:
        total_lusd = decode_uint256(result)
        print(f"Total LUSD Deposits: {format_ether(total_lusd)} (${total_lusd / 1e18:,.0f})")

    # Get ETH in stability pool
    sp_eth = get_eth_balance(sp_addr)
    print(f"ETH from liquidations: {format_ether(sp_eth)} (${sp_eth / 1e18 * 2279:,.0f})")

    # Check reward snapshots
    selector = get_function_selector("P()")
    result = eth_call(sp_addr, selector)
    if result:
        P = decode_uint256(result)
        print(f"P (product factor): {P}")

    selector = get_function_selector("currentScale()")
    result = eth_call(sp_addr, selector)
    if result:
        scale = decode_uint256(result)
        print(f"Current Scale: {scale}")

    selector = get_function_selector("currentEpoch()")
    result = eth_call(sp_addr, selector)
    if result:
        epoch = decode_uint256(result)
        print(f"Current Epoch: {epoch}")

    # Check LQTY issuance
    selector = get_function_selector("communityIssuance()")
    result = eth_call(sp_addr, selector)
    if result and len(result) >= 42:
        community_issuance = "0x" + result[-40:]
        print(f"Community Issuance: {community_issuance}")

    # Analyze TroveManager
    print("\n" + "=" * 70)
    print("TROVE MANAGER ANALYSIS")
    print("=" * 70)

    tm_addr = LIQUITY['TroveManager']

    # Get total stakes and collateral
    selector = get_function_selector("totalStakes()")
    result = eth_call(tm_addr, selector)
    if result:
        stakes = decode_uint256(result)
        print(f"Total Stakes: {format_ether(stakes)}")

    selector = get_function_selector("totalCollateralSnapshot()")
    result = eth_call(tm_addr, selector)
    if result:
        coll = decode_uint256(result)
        print(f"Total Collateral Snapshot: {format_ether(coll)}")

    selector = get_function_selector("L_ETH()")
    result = eth_call(tm_addr, selector)
    if result:
        l_eth = decode_uint256(result)
        print(f"L_ETH: {l_eth}")

    selector = get_function_selector("L_LUSDDebt()")
    result = eth_call(tm_addr, selector)
    if result:
        l_lusd = decode_uint256(result)
        print(f"L_LUSDDebt: {l_lusd}")

    # Get redemption rate
    selector = get_function_selector("baseRate()")
    result = eth_call(tm_addr, selector)
    if result:
        base_rate = decode_uint256(result)
        print(f"Base Rate: {base_rate / 1e18 * 100:.4f}%")

    # Check last fee operation time
    selector = get_function_selector("lastFeeOperationTime()")
    result = eth_call(tm_addr, selector)
    if result:
        last_fee_time = decode_uint256(result)
        print(f"Last Fee Op Time: {last_fee_time}")

    # Analyze Price Feed
    print("\n" + "=" * 70)
    print("PRICE FEED ANALYSIS")
    print("=" * 70)

    pf_addr = LIQUITY['PriceFeed']

    # Get last good price
    selector = get_function_selector("lastGoodPrice()")
    result = eth_call(pf_addr, selector)
    if result:
        price = decode_uint256(result)
        print(f"Last Good Price: ${format_ether(price)}")

    # Check status
    selector = get_function_selector("status()")
    result = eth_call(pf_addr, selector)
    if result:
        status = decode_uint256(result)
        statuses = ["chainlinkWorking", "usingTellorChainlinkUntrusted", "bothOraclesUntrusted", "usingTellorChainlinkFrozen", "usingChainlinkTellorUntrusted"]
        print(f"Oracle Status: {statuses[status] if status < len(statuses) else status}")

    # Check Chainlink oracle
    selector = get_function_selector("priceAggregator()")
    result = eth_call(pf_addr, selector)
    if result and len(result) >= 42:
        chainlink = "0x" + result[-40:]
        print(f"Chainlink Aggregator: {chainlink}")

    # Check Tellor oracle
    selector = get_function_selector("tellorCaller()")
    result = eth_call(pf_addr, selector)
    if result and len(result) >= 42:
        tellor = "0x" + result[-40:]
        print(f"Tellor Caller: {tellor}")

    # LQTY Staking Analysis
    print("\n" + "=" * 70)
    print("LQTY STAKING ANALYSIS")
    print("=" * 70)

    lqty_staking = LIQUITY['LQTYStaking']

    # Get total staked
    selector = get_function_selector("totalLQTYStaked()")
    result = eth_call(lqty_staking, selector)
    if result:
        total_staked = decode_uint256(result)
        print(f"Total LQTY Staked: {format_ether(total_staked)}")

    # Check pending rewards
    lqty_eth = get_eth_balance(lqty_staking)
    print(f"ETH in staking: {format_ether(lqty_eth)}")

    # Get fee per unit
    selector = get_function_selector("F_ETH()")
    result = eth_call(lqty_staking, selector)
    if result:
        f_eth = decode_uint256(result)
        print(f"F_ETH (fee per unit): {f_eth}")

    selector = get_function_selector("F_LUSD()")
    result = eth_call(lqty_staking, selector)
    if result:
        f_lusd = decode_uint256(result)
        print(f"F_LUSD (fee per unit): {f_lusd}")

    # Get source code of StabilityPool
    print("\n" + "=" * 70)
    print("ANALYZING STABILITY POOL SOURCE CODE")
    print("=" * 70)

    source_data = get_contract_source(sp_addr)
    if source_data:
        source_code = source_data.get('SourceCode', '')
        print(f"Source length: {len(source_code)} chars")

        # Look for potential issues
        issues_found = []

        # Check for flash loan protection
        if 'nonReentrant' not in source_code and 'ReentrancyGuard' not in source_code:
            issues_found.append("No explicit reentrancy guard")

        # Check for oracle staleness handling
        if 'staleness' not in source_code.lower() and 'heartbeat' not in source_code.lower():
            issues_found.append("No oracle staleness check found")

        # Check reward calculation
        if 'getDepositorLQTYGain' in source_code:
            print("\nLQTY reward calculation exists - checking mechanics...")

        # Check for epoch/scale resets
        if 'epochToScaleToSum' in source_code:
            print("Uses epoch/scale system for tracking gains")

        # Look at withdrawal mechanics
        if 'withdrawFromSP' in source_code:
            print("Withdraw function found - checking for issues...")

            # Extract the withdraw function
            lines = source_code.split('\n')
            for i, line in enumerate(lines):
                if 'function withdrawFromSP' in line or 'function _withdrawFromSP' in line:
                    print(f"\nWithdraw function at line {i+1}:")
                    for j in range(i, min(i+30, len(lines))):
                        print(f"  {lines[j]}")
                    break

        print(f"\nPotential issues: {issues_found if issues_found else 'None obvious'}")

    # EXPLOITATION BRAINSTORMING
    print("\n" + "=" * 70)
    print("EXPLOITATION BRAINSTORMING")
    print("=" * 70)

    print("""
LIQUITY POTENTIAL ATTACK VECTORS:

1. ORACLE MANIPULATION:
   - Liquity uses Chainlink + Tellor as backup
   - Tellor has a dispute mechanism - could be exploited?
   - Check if oracle fallback creates price discrepancy window

2. LIQUIDATION TIMING:
   - Liquidations can be called by anyone
   - Liquidator gets gas compensation + 0.5% of collateral
   - Can we front-run liquidations profitably?

3. REDEMPTION ARBITRAGE:
   - Redemptions burn LUSD for ETH at face value
   - Base rate increases with redemptions
   - Can we exploit the rate decay mechanism?

4. STABILITY POOL REWARDS:
   - Depositors get proportional ETH from liquidations
   - LQTY rewards are distributed over time
   - Flash deposit to capture ETH from large liquidation?

5. CROSS-PROTOCOL COMPOSITION:
   - LUSD is used in Curve pools
   - If LUSD depegs, can we profit across protocols?
   - Check if any protocols read LUSD at $1 when it's not

6. TROVE MANIPULATION:
   - Minimum collateral ratio is 110%
   - Recovery mode kicks in at 150% TCR
   - Can we trigger recovery mode and liquidate healthy troves?

NEXT STEPS:
1. Check Tellor oracle dispute timing
2. Analyze liquidation profitability
3. Check for LUSD depeg opportunities
4. Test redemption rate arbitrage
""")

if __name__ == "__main__":
    main()
