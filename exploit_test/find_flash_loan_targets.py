#!/usr/bin/env python3
"""
Find contracts with flash loan callbacks that could be exploitable.
Focus on contracts that:
1. Have flash loan callbacks
2. Make price-dependent decisions
3. Have extractable value
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import time
import json

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        result = resp.json()
        if 'error' in result:
            return None
        return result.get("result", "0x")
    except:
        return None

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def analyze_flash_loan_vulnerability(source_code, contract_name):
    """Check for exploitable flash loan patterns"""
    lower = source_code.lower()
    findings = []
    severity = 0  # 0-10 scale

    # Flash loan callbacks
    callbacks = {
        'executeOperation': ('aave flash', 3),
        'uniswapV2Call': ('uniswap v2 flash', 3),
        'uniswapV3FlashCallback': ('uniswap v3 flash', 3),
        'onFlashLoan': ('eip-3156 flash', 3),
        'flashLoanSimple': ('aave v3 flash', 3),
    }

    has_callback = False
    for cb, (desc, sev) in callbacks.items():
        if cb.lower() in lower:
            findings.append(f"FLASH_CALLBACK: {desc}")
            severity += sev
            has_callback = True

    if not has_callback:
        return [], 0

    # Price-dependent decisions
    price_patterns = {
        'getReserves': ('Uniswap reserves', 2),
        'latestAnswer': ('Chainlink oracle', 1),
        'getAmountOut': ('Uniswap pricing', 2),
        'getPrice': ('Generic pricing', 2),
        'exchangeRate': ('Exchange rate', 2),
        'spot': ('Spot price', 2),
    }

    for pattern, (desc, sev) in price_patterns.items():
        if pattern.lower() in lower:
            findings.append(f"PRICE_DEP: Uses {desc}")
            severity += sev

    # Extractable value patterns
    value_patterns = {
        'withdraw': ('Has withdraw', 1),
        'transfer(': ('Can transfer', 1),
        'emergencyWithdraw': ('Emergency withdraw', 2),
        'sweep': ('Token sweep', 2),
        'liquidate': ('Liquidation', 3),
        'redeem': ('Redemption', 2),
    }

    for pattern, (desc, sev) in value_patterns.items():
        if pattern.lower() in lower:
            findings.append(f"VALUE: {desc}")
            severity += sev

    # Missing protections
    if 'nonreentrant' not in lower and 'reentrancyguard' not in lower:
        findings.append("NO_PROTECTION: Missing reentrancy guard")
        severity += 3

    # Dangerous patterns
    if 'delegatecall' in lower and has_callback:
        findings.append("DANGEROUS: delegatecall in callback context")
        severity += 4

    if 'msg.sender' in lower and 'require' not in lower.split('msg.sender')[0][-100:]:
        findings.append("DANGEROUS: Unchecked msg.sender")
        severity += 2

    return findings, severity

def main():
    print("=" * 70)
    print("FLASH LOAN VULNERABILITY SEARCH")
    print("=" * 70)

    # Read all contracts
    with open('/home/user/contracs/contracts.txt', 'r') as f:
        all_contracts = [line.strip() for line in f if line.strip().startswith('0x')]

    # Sample from different ranges
    # Focus on contracts 0-500 and 500-1000 which might have newer protocols
    sample_ranges = [
        (0, 200, "First 200"),
        (200, 400, "200-400"),
        (400, 600, "400-600"),
    ]

    all_targets = []

    for start, end, name in sample_ranges:
        print(f"\n--- Scanning {name} ---")
        contracts = all_contracts[start:end]

        for i, address in enumerate(contracts):
            if i % 30 == 0:
                print(f"  Progress: {i}/{len(contracts)}")

            # Get balance
            eth_bal = get_eth_balance(address)
            eth_value = eth_bal / 1e18

            # Skip very low value
            if eth_value < 5:
                continue

            # Get source
            source_data = get_contract_source(address)
            time.sleep(0.25)

            if not source_data:
                continue

            source_code = source_data.get('SourceCode', '')
            contract_name = source_data.get('ContractName', 'Unknown')

            if not source_code:
                continue

            # Analyze for flash loan vulnerabilities
            findings, severity = analyze_flash_loan_vulnerability(source_code, contract_name)

            if findings and severity >= 5:
                target = {
                    'address': address,
                    'name': contract_name,
                    'eth': eth_value,
                    'severity': severity,
                    'findings': findings
                }
                all_targets.append(target)

                print(f"\n  *** HIGH SEVERITY: {contract_name} ({address[:10]}...)")
                print(f"      ETH: {eth_value:.2f} | Severity: {severity}")
                for f in findings:
                    print(f"      - {f}")

    # Sort by severity
    all_targets.sort(key=lambda x: (x['severity'], x['eth']), reverse=True)

    # Summary
    print("\n" + "=" * 70)
    print("TOP FLASH LOAN TARGETS")
    print("=" * 70)

    for i, target in enumerate(all_targets[:15]):
        print(f"\n{i+1}. {target['name']} ({target['address'][:10]}...)")
        print(f"   ETH: {target['eth']:.2f} | Severity: {target['severity']}")
        for f in target['findings']:
            print(f"   - {f}")

    # Save results
    with open('flash_loan_targets.json', 'w') as f:
        json.dump(all_targets, f, indent=2)

    print(f"\nFound {len(all_targets)} potential flash loan targets")
    print("Results saved to flash_loan_targets.json")

if __name__ == "__main__":
    main()
