#!/usr/bin/env python3
"""
CRITICAL INVESTIGATION: MarketingMiningDelegator
1523.41 ETH ($3.47M) - Uses spot price without TWAP
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import json

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

# Full address from the scan
def find_full_address():
    with open('/home/user/contracs/contracts.txt', 'r') as f:
        for line in f:
            if line.strip().lower().startswith('0x0feccb11'):
                return line.strip()
    return None

TARGET_ADDRESS = find_full_address()

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        result = resp.json()
        if 'error' in result:
            return None
        return result.get("result", "0x")
    except:
        return None

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def decode_address(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return None
    return "0x" + hex_result[-40:]

def decode_uint256(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return 0
    return int(hex_result[:66], 16)

def main():
    print("=" * 70)
    print("CRITICAL: MarketingMiningDelegator INVESTIGATION")
    print("=" * 70)

    if not TARGET_ADDRESS:
        print("Could not find full address!")
        return

    address = TARGET_ADDRESS
    print(f"\nAddress: {address}")

    # Get balance
    eth_bal = get_eth_balance(address)
    print(f"\n*** ETH Balance: {eth_bal / 1e18:.4f} ETH (${eth_bal / 1e18 * 2279:,.0f}) ***")

    # Get source
    source_data = get_contract_source(address)
    if not source_data:
        print("No verified source!")
        return

    source_code = source_data.get('SourceCode', '')
    contract_name = source_data.get('ContractName', 'Unknown')
    compiler = source_data.get('CompilerVersion', '')
    print(f"\nContract: {contract_name}")
    print(f"Compiler: {compiler}")

    if not source_code:
        print("Empty source")
        return

    # Save source
    with open('marketing_mining_source.sol', 'w') as f:
        f.write(source_code)
    print(f"Source saved ({len(source_code)} chars)")

    lower = source_code.lower()

    # Key vulnerability indicators
    print("\n--- VULNERABILITY PATTERNS ---")

    patterns = {
        'getReserves': 'getreserves' in lower,
        'getAmountOut': 'getamountout' in lower,
        'TWAP/Oracle': 'twap' in lower or 'oracle' in lower,
        'Chainlink': 'chainlink' in lower or 'aggregator' in lower,
        'Price gate': 'require' in lower and 'price' in lower,
        'Liquidation': 'liquidat' in lower,
        'Borrow': 'borrow' in lower,
        'Mint': 'mint' in lower,
        'Withdraw': 'withdraw' in lower,
        'ReentrancyGuard': 'reentrancyguard' in lower or 'nonreentrant' in lower,
    }

    for name, found in patterns.items():
        status = "YES" if found else "NO"
        print(f"  {name}: {status}")

    # Query contract state
    print("\n--- CONTRACT STATE ---")

    selectors = [
        ("owner()", "owner"),
        ("admin()", "admin"),
        ("implementation()", "implementation"),
        ("paused()", "paused"),
        ("totalSupply()", "totalSupply"),
        ("token()", "token"),
        ("pair()", "pair"),
        ("router()", "router"),
        ("factory()", "factory"),
        ("getPrice()", "getPrice"),
    ]

    for sig, desc in selectors:
        selector = get_function_selector(sig)
        result = eth_call(address, selector)
        if result and result != "0x" and len(result) > 10:
            if any(x in sig.lower() for x in ['address', 'owner', 'admin', 'implementation', 'token', 'pair', 'router', 'factory']):
                addr = decode_address(result)
                if addr and addr != "0x" + "0" * 40:
                    print(f"  {desc}: {addr}")
            else:
                value = decode_uint256(result)
                if value > 0:
                    print(f"  {desc}: {value}")

    # Check token balances
    print("\n--- TOKEN BALANCES IN CONTRACT ---")

    tokens = [
        ("WETH", "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", 18),
        ("USDC", "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", 6),
        ("USDT", "0xdAC17F958D2ee523a2206206994597C13D831ec7", 6),
    ]

    selector = get_function_selector("balanceOf(address)")
    for name, token_addr, decimals in tokens:
        try:
            data = selector + encode(['address'], [address]).hex()
            result = eth_call(token_addr, data)
            if result:
                bal = decode_uint256(result)
                if bal > 0:
                    print(f"  {name}: {bal / 10**decimals:.4f}")
        except:
            pass

    # Look for attack surface in source
    print("\n--- ATTACK SURFACE ANALYSIS ---")

    # Find functions that use getReserves
    if 'getreserves' in lower:
        print("\n  Functions using getReserves:")
        lines = source_code.split('\n')
        for i, line in enumerate(lines):
            if 'getreserves' in line.lower():
                # Get context (5 lines before and after)
                start = max(0, i - 3)
                end = min(len(lines), i + 5)
                for j in range(start, end):
                    print(f"    {j}: {lines[j][:80]}")
                print()

    # Find require statements with price
    if 'require' in lower and 'price' in lower:
        print("\n  Price-gated requires:")
        lines = source_code.split('\n')
        for i, line in enumerate(lines):
            if 'require' in line.lower() and 'price' in line.lower():
                print(f"    {i}: {line.strip()[:100]}")

    # Economic analysis
    print("\n" + "=" * 70)
    print("ECONOMIC ANALYSIS")
    print("=" * 70)
    print(f"""
Target value: {eth_bal / 1e18:.2f} ETH (${eth_bal / 1e18 * 2279:,.0f})

IF spot price manipulation is possible:
1. Flash loan large amount to manipulate Uniswap reserves
2. Trigger price-gated function at manipulated price
3. Extract value
4. Repay flash loan

Manipulation cost estimate:
- Moving ETH/USDC price by 10% requires ~$10M capital
- Moving smaller pools by 50%+ may be cheaper
- Flash loan fees: ~0.09% of borrowed amount

For exploit to be viable:
- Extractable value > (flash loan fee + gas + slippage)
- If 10% of 1523 ETH extractable: 152 ETH ($346K)
- Flash loan fee on $10M: ~$9K
- Net profit potential: ~$337K if fully exploitable
""")

if __name__ == "__main__":
    main()
