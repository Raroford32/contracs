#!/usr/bin/env python3
"""
Analyze Juicebox Prices contract for manipulation opportunities.
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import json

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

PRICES_CONTRACT = "0xa9537cc42555564206d4e57c0eb6943d56e83a30"
TERMINAL_V1 = "0xd569d3cce55b71a8a3f3c418c329a66e5f714431"

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        result = resp.json()
        if 'error' in result:
            print(f"Error: {result['error']}")
            return None
        return result.get("result", "0x")
    except Exception as e:
        print(f"Error: {e}")
        return None

def decode_uint256(hex_result):
    if not hex_result or hex_result == "0x" or len(hex_result) < 66:
        return 0
    return int(hex_result[:66], 16)

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def main():
    print("=" * 70)
    print("JUICEBOX PRICES CONTRACT ANALYSIS")
    print("=" * 70)

    # Get source code
    source_data = get_contract_source(PRICES_CONTRACT)
    if source_data:
        source_code = source_data.get('SourceCode', '')
        print(f"Contract Name: {source_data.get('ContractName', 'Unknown')}")
        print(f"Compiler: {source_data.get('CompilerVersion', 'Unknown')}")

        # Save for analysis
        with open('juicebox_prices.sol', 'w') as f:
            f.write(source_code)

    # Check owner
    selector = get_function_selector("owner()")
    result = eth_call(PRICES_CONTRACT, selector)
    if result and len(result) >= 42:
        owner = "0x" + result[-40:]
        print(f"Owner: {owner}")

    # Check what price feeds exist
    # Try getting ETH/USD price
    print("\n--- PRICE FEEDS ---")

    # The Prices contract likely has feeds for different currencies
    # Common currency codes: 1 = USD, 2 = EUR, etc.

    # Try to get the price of currency 1 (USD)
    selector = get_function_selector("getETHPriceFor(uint256)")
    data = selector + encode(['uint256'], [1]).hex()  # USD
    result = eth_call(PRICES_CONTRACT, data)
    if result:
        price = decode_uint256(result)
        print(f"ETH/USD Price: ${price / 1e18:.2f}")

    # Try targetCurrencyBasis
    selector = get_function_selector("targetCurrencyBasis()")
    result = eth_call(PRICES_CONTRACT, selector)
    if result:
        basis = decode_uint256(result)
        print(f"Target Currency Basis: {basis}")

    # Check feed for currency 1
    selector = get_function_selector("feedFor(uint256)")
    data = selector + encode(['uint256'], [1]).hex()
    result = eth_call(PRICES_CONTRACT, data)
    if result and len(result) >= 42:
        feed = "0x" + result[-40:]
        print(f"Feed for USD: {feed}")

        # If it's Chainlink, get the price directly
        selector = get_function_selector("latestRoundData()")
        result = eth_call(feed, selector)
        if result and len(result) >= 130:
            try:
                data = bytes.fromhex(result[2:])
                answer = int.from_bytes(data[32:64], 'big')
                updatedAt = int.from_bytes(data[96:128], 'big')
                print(f"Chainlink ETH/USD: ${answer / 1e8:.2f}")
                print(f"Updated: {updatedAt}")
            except:
                pass

    # Analyze potential attack vectors
    print("\n" + "=" * 70)
    print("PRICE MANIPULATION ANALYSIS")
    print("=" * 70)

    print("""
JUICEBOX PRICE FEED MECHANICS:

1. Prices contract aggregates multiple price feeds
2. Used when projects configure funding cycles with targets in fiat
3. If ETH/USD price is manipulable, could affect:
   - Funding target calculations
   - Overflow amounts
   - Redemption values

ATTACK VECTOR ASSESSMENT:

1. CHAINLINK MANIPULATION
   - Juicebox uses Chainlink for ETH/USD
   - Chainlink is decentralized, manipulation requires:
     * Control of multiple oracle nodes
     * OR manipulation of underlying DEX prices (very expensive)
   - VERDICT: Not economically feasible for TIER_0-2 attackers

2. STALE PRICE EXPLOITATION
   - If Chainlink goes stale, what happens?
   - Need to check if Juicebox has staleness checks
   - Could exploit during high volatility + oracle delay

3. CURRENCY FEED SUBSTITUTION
   - Can attacker add/modify price feeds?
   - Need to check owner permissions

CONCLUSION:
Price manipulation on Juicebox is not viable unless:
- A custom price feed without Chainlink is used
- Chainlink becomes stale during high volatility
- There's an owner key compromise
""")

    # Check FundingCycles for project-specific targets
    print("\n" + "=" * 70)
    print("CHECKING FUNDING CYCLES")
    print("=" * 70)

    FUNDING_CYCLES = "0xf507b2a1dd7439201eb07f11e1d62afb29216e2e"

    # Get source
    source_data = get_contract_source(FUNDING_CYCLES)
    if source_data:
        print(f"FundingCycles Contract: {source_data.get('ContractName', 'Unknown')}")

        source_code = source_data.get('SourceCode', '')
        with open('juicebox_funding_cycles.sol', 'w') as f:
            f.write(source_code)

    # Get current funding cycle of project 1 (Juicebox itself?)
    selector = get_function_selector("currentOf(uint256)")
    data = selector + encode(['uint256'], [1]).hex()
    result = eth_call(FUNDING_CYCLES, data)
    if result and len(result) >= 256:
        print(f"\nProject 1 Current Cycle Data: {result[:66]}...")

    # Check total count
    selector = get_function_selector("count()")
    result = eth_call(FUNDING_CYCLES, selector)
    if result:
        count = decode_uint256(result)
        print(f"Total Funding Cycles Created: {count}")

if __name__ == "__main__":
    main()
