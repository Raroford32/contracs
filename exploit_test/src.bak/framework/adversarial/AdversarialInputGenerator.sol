// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title AdversarialInputGenerator
 * @notice Generates adversarial inputs for fuzzing and exploit testing
 * @dev Covers malicious swapData, custom routers, extreme values, flash loans
 */
contract AdversarialInputGenerator is Test {

    // ============ CONSTANTS ============

    uint256 constant TYPE_MAX = type(uint256).max;
    uint256 constant TYPE_MAX_128 = type(uint128).max;
    uint256 constant TYPE_MAX_96 = type(uint96).max;
    uint256 constant TYPE_MAX_64 = type(uint64).max;

    // Common token decimals
    uint256 constant DECIMALS_6 = 1e6;
    uint256 constant DECIMALS_8 = 1e8;
    uint256 constant DECIMALS_18 = 1e18;
    uint256 constant DECIMALS_27 = 1e27;

    // Flash loan providers
    address constant AAVE_V3 = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    address constant BALANCER = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address constant DYDX = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;

    // ============ ADVERSARIAL AMOUNT GENERATION ============

    struct AmountSet {
        uint256[] amounts;
        string[] descriptions;
    }

    function generateAdversarialAmounts() public pure returns (AmountSet memory set) {
        set.amounts = new uint256[](25);
        set.descriptions = new string[](25);

        // Zero and near-zero
        set.amounts[0] = 0;
        set.descriptions[0] = "zero";

        set.amounts[1] = 1;
        set.descriptions[1] = "dust_1";

        set.amounts[2] = 2;
        set.descriptions[2] = "dust_2";

        // Boundary values
        set.amounts[3] = TYPE_MAX;
        set.descriptions[3] = "uint256_max";

        set.amounts[4] = TYPE_MAX - 1;
        set.descriptions[4] = "uint256_max_minus_1";

        set.amounts[5] = TYPE_MAX_128;
        set.descriptions[5] = "uint128_max";

        set.amounts[6] = TYPE_MAX_128 + 1;
        set.descriptions[6] = "uint128_overflow";

        set.amounts[7] = TYPE_MAX_96;
        set.descriptions[7] = "uint96_max";

        set.amounts[8] = TYPE_MAX_64;
        set.descriptions[8] = "uint64_max";

        // Decimal boundaries
        set.amounts[9] = DECIMALS_6 - 1;
        set.descriptions[9] = "usdc_decimals_minus_1";

        set.amounts[10] = DECIMALS_6;
        set.descriptions[10] = "usdc_1_token";

        set.amounts[11] = DECIMALS_18 - 1;
        set.descriptions[11] = "eth_decimals_minus_1";

        set.amounts[12] = DECIMALS_18;
        set.descriptions[12] = "eth_1_token";

        // Flash loan scale
        set.amounts[13] = 1_000_000 * DECIMALS_18;
        set.descriptions[13] = "flash_loan_1m_eth";

        set.amounts[14] = 100_000_000 * DECIMALS_6;
        set.descriptions[14] = "flash_loan_100m_usdc";

        set.amounts[15] = 1_000_000_000 * DECIMALS_18;
        set.descriptions[15] = "flash_loan_1b_eth";

        // Rounding attack amounts
        set.amounts[16] = DECIMALS_18 + 1;
        set.descriptions[16] = "rounding_plus_1";

        set.amounts[17] = DECIMALS_18 * 2 - 1;
        set.descriptions[17] = "rounding_2x_minus_1";

        // Precision edge cases
        set.amounts[18] = DECIMALS_27;
        set.descriptions[18] = "ray_precision";

        set.amounts[19] = DECIMALS_27 * DECIMALS_18;
        set.descriptions[19] = "ray_times_wad";

        // Potential overflow triggers
        set.amounts[20] = TYPE_MAX / 2;
        set.descriptions[20] = "half_max";

        set.amounts[21] = TYPE_MAX / 2 + 1;
        set.descriptions[21] = "half_max_plus_1";

        // Liquidity-related
        set.amounts[22] = 1000; // Minimum liquidity often burned
        set.descriptions[22] = "min_liquidity";

        set.amounts[23] = 1001; // Just above minimum
        set.descriptions[23] = "min_liquidity_plus_1";

        // Common protocol thresholds
        set.amounts[24] = 10000; // BPS denominator
        set.descriptions[24] = "bps_denominator";
    }

    // ============ ADVERSARIAL ADDRESS GENERATION ============

    struct AddressSet {
        address[] addresses;
        string[] descriptions;
    }

    function generateAdversarialAddresses() public returns (AddressSet memory set) {
        set.addresses = new address[](20);
        set.descriptions = new string[](20);

        // Null and special addresses
        set.addresses[0] = address(0);
        set.descriptions[0] = "zero_address";

        set.addresses[1] = address(1);
        set.descriptions[1] = "address_1_precompile";

        set.addresses[2] = address(0x2);
        set.descriptions[2] = "address_2_precompile";

        set.addresses[3] = address(0x9);
        set.descriptions[3] = "address_9_precompile_last";

        // Dead/burn addresses
        set.addresses[4] = address(0xdead);
        set.descriptions[4] = "dead_address";

        set.addresses[5] = 0x000000000000000000000000000000000000dEaD;
        set.descriptions[5] = "full_dead_address";

        // Test context
        set.addresses[6] = address(this);
        set.descriptions[6] = "this_contract";

        set.addresses[7] = msg.sender;
        set.descriptions[7] = "msg_sender";

        // Generated attackers
        set.addresses[8] = makeAddr("attacker1");
        set.descriptions[8] = "attacker_1";

        set.addresses[9] = makeAddr("attacker2");
        set.descriptions[9] = "attacker_2";

        set.addresses[10] = makeAddr("victim");
        set.descriptions[10] = "victim";

        // Common protocol addresses
        set.addresses[11] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // WETH
        set.descriptions[11] = "weth";

        set.addresses[12] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // USDC
        set.descriptions[12] = "usdc";

        set.addresses[13] = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // USDT
        set.descriptions[13] = "usdt";

        set.addresses[14] = 0x6B175474E89094C44Da98b954EedeAC495271d0F; // DAI
        set.descriptions[14] = "dai";

        // Flash loan providers (potential reentrancy targets)
        set.addresses[15] = AAVE_V3;
        set.descriptions[15] = "aave_v3_pool";

        set.addresses[16] = BALANCER;
        set.descriptions[16] = "balancer_vault";

        // Malicious contract placeholder
        set.addresses[17] = makeAddr("malicious_router");
        set.descriptions[17] = "malicious_router";

        set.addresses[18] = makeAddr("malicious_oracle");
        set.descriptions[18] = "malicious_oracle";

        set.addresses[19] = makeAddr("malicious_callback");
        set.descriptions[19] = "malicious_callback";
    }

    // ============ MALICIOUS SWAP DATA GENERATION ============

    struct SwapDataSet {
        bytes[] swapData;
        string[] descriptions;
    }

    function generateMaliciousSwapData(
        address targetToken,
        address maliciousTarget
    ) public pure returns (SwapDataSet memory set) {
        set.swapData = new bytes[](15);
        set.descriptions = new string[](15);

        // Empty data
        set.swapData[0] = "";
        set.descriptions[0] = "empty_swap_data";

        // Invalid selector
        set.swapData[1] = hex"deadbeef";
        set.descriptions[1] = "invalid_selector";

        // Valid swap selectors with malicious params
        set.swapData[2] = abi.encodeWithSignature(
            "swap(uint256,uint256,address,bytes)",
            0, TYPE_MAX, maliciousTarget, ""
        );
        set.descriptions[2] = "swap_max_amount_out";

        set.swapData[3] = abi.encodeWithSignature(
            "swap(uint256,uint256,address,bytes)",
            TYPE_MAX, 0, maliciousTarget, ""
        );
        set.descriptions[3] = "swap_max_amount_in_zero_out";

        // Uniswap V2 style
        set.swapData[4] = abi.encodeWithSignature(
            "swapExactTokensForTokens(uint256,uint256,address[],address,uint256)",
            TYPE_MAX, 0, new address[](0), maliciousTarget, block.timestamp
        );
        set.descriptions[4] = "uniswap_v2_max_in_zero_min";

        // Uniswap V3 style
        set.swapData[5] = abi.encodeWithSignature(
            "exactInputSingle((address,address,uint24,address,uint256,uint256,uint160))",
            targetToken, maliciousTarget, 3000, maliciousTarget, TYPE_MAX, 0, 0
        );
        set.descriptions[5] = "uniswap_v3_exact_input_malicious";

        // Callback injection
        set.swapData[6] = abi.encodeWithSignature(
            "flash(address,uint256,uint256,bytes)",
            maliciousTarget, TYPE_MAX, TYPE_MAX,
            abi.encodeWithSignature("attack()")
        );
        set.descriptions[6] = "flash_with_attack_callback";

        // Aggregator style - struct encoded manually
        set.swapData[7] = abi.encodeWithSignature(
            "swap(address,bytes,bytes,bytes)",
            address(0),
            abi.encode(targetToken, targetToken, maliciousTarget, maliciousTarget, TYPE_MAX, uint256(0), block.timestamp),
            "",
            abi.encodeWithSignature("attack()")
        );
        set.descriptions[7] = "aggregator_malicious_executor";

        // Curve style
        set.swapData[8] = abi.encodeWithSignature(
            "exchange(int128,int128,uint256,uint256)",
            0, 1, TYPE_MAX, 0
        );
        set.descriptions[8] = "curve_max_in_zero_min";

        // Balancer style
        set.swapData[9] = abi.encodeWithSignature(
            "swap((bytes32,uint8,address,address,uint256,bytes),(address,bool,address,bool),uint256,uint256)",
            [bytes32(0), uint8(0), targetToken, targetToken, TYPE_MAX, ""],
            [maliciousTarget, true, maliciousTarget, false],
            0, block.timestamp
        );
        set.descriptions[9] = "balancer_single_swap_malicious";

        // Large calldata (potential DoS)
        bytes memory largeData = new bytes(100000);
        set.swapData[10] = largeData;
        set.descriptions[10] = "large_calldata_dos";

        // Nested encoding
        set.swapData[11] = abi.encode(
            abi.encode(
                abi.encode(maliciousTarget, TYPE_MAX)
            )
        );
        set.descriptions[11] = "nested_encoding";

        // Malformed ABI
        set.swapData[12] = abi.encodePacked(
            bytes4(keccak256("swap(uint256,uint256,address,bytes)")),
            bytes32(TYPE_MAX),
            bytes16(0) // Truncated
        );
        set.descriptions[12] = "malformed_abi_truncated";

        // Self-referential
        set.swapData[13] = abi.encodeWithSignature(
            "execute(address,bytes)",
            address(0), abi.encodeWithSignature("execute(address,bytes)", address(0), "")
        );
        set.descriptions[13] = "self_referential_execute";

        // Reentrancy trigger
        set.swapData[14] = abi.encodeWithSignature(
            "functionCallWithValue(address,bytes,uint256)",
            maliciousTarget,
            abi.encodeWithSignature("attack()"),
            0
        );
        set.descriptions[14] = "reentrancy_trigger";
    }

    // ============ MALICIOUS ROUTER/ORACLE CONTRACTS ============

    function deployMaliciousRouter() public returns (address) {
        MaliciousRouter router = new MaliciousRouter();
        return address(router);
    }

    function deployMaliciousOracle(uint256 manipulatedPrice) public returns (address) {
        MaliciousOracle oracle = new MaliciousOracle(manipulatedPrice);
        return address(oracle);
    }

    function deployReentrantCallback(
        address target,
        bytes memory attackCalldata
    ) public returns (address) {
        ReentrantCallback callback = new ReentrantCallback(target, attackCalldata);
        return address(callback);
    }

    // ============ PRICE MANIPULATION SCENARIOS ============

    struct PriceScenario {
        uint256 priceBefore;
        uint256 priceAfter;
        string description;
    }

    function generatePriceManipulationScenarios() public pure returns (PriceScenario[] memory) {
        PriceScenario[] memory scenarios = new PriceScenario[](12);

        // Flash crash
        scenarios[0] = PriceScenario(DECIMALS_18, DECIMALS_18 / 100, "99%_flash_crash");
        scenarios[1] = PriceScenario(DECIMALS_18, DECIMALS_18 / 2, "50%_crash");
        scenarios[2] = PriceScenario(DECIMALS_18, DECIMALS_18 * 9 / 10, "10%_crash");

        // Flash pump
        scenarios[3] = PriceScenario(DECIMALS_18, DECIMALS_18 * 100, "100x_pump");
        scenarios[4] = PriceScenario(DECIMALS_18, DECIMALS_18 * 10, "10x_pump");
        scenarios[5] = PriceScenario(DECIMALS_18, DECIMALS_18 * 2, "2x_pump");

        // Edge cases
        scenarios[6] = PriceScenario(DECIMALS_18, 1, "price_to_dust");
        scenarios[7] = PriceScenario(1, DECIMALS_18, "dust_to_normal");
        scenarios[8] = PriceScenario(DECIMALS_18, 0, "price_to_zero");
        scenarios[9] = PriceScenario(0, DECIMALS_18, "zero_to_normal");
        scenarios[10] = PriceScenario(DECIMALS_18, TYPE_MAX_128, "price_to_max");
        scenarios[11] = PriceScenario(TYPE_MAX_128, DECIMALS_18, "max_to_normal");

        return scenarios;
    }

    // ============ FLASH LOAN SEQUENCES ============

    struct FlashLoanSequence {
        address provider;
        address token;
        uint256 amount;
        bytes[] steps;
        string description;
    }

    function generateFlashLoanSequences(
        address targetProtocol,
        address targetToken
    ) public view returns (FlashLoanSequence[] memory) {
        FlashLoanSequence[] memory sequences = new FlashLoanSequence[](5);

        // Simple borrow and interact
        bytes[] memory steps1 = new bytes[](2);
        steps1[0] = abi.encodeWithSignature("approve(address,uint256)", targetProtocol, TYPE_MAX);
        steps1[1] = abi.encodeWithSignature("deposit(uint256)", 1_000_000 * DECIMALS_18);

        sequences[0] = FlashLoanSequence({
            provider: AAVE_V3,
            token: targetToken,
            amount: 1_000_000 * DECIMALS_18,
            steps: steps1,
            description: "flash_deposit_exploit"
        });

        // Price manipulation + liquidation
        bytes[] memory steps2 = new bytes[](3);
        steps2[0] = abi.encodeWithSignature("manipulatePrice(uint256)", DECIMALS_18 / 10);
        steps2[1] = abi.encodeWithSignature("liquidate(address,uint256)", makeAddr("victim"), TYPE_MAX);
        steps2[2] = abi.encodeWithSignature("resetPrice()");

        sequences[1] = FlashLoanSequence({
            provider: BALANCER,
            token: targetToken,
            amount: 10_000_000 * DECIMALS_18,
            steps: steps2,
            description: "oracle_manipulation_liquidation"
        });

        // Reentrancy during callback
        bytes[] memory steps3 = new bytes[](1);
        steps3[0] = abi.encodeWithSignature("reenter()");

        sequences[2] = FlashLoanSequence({
            provider: AAVE_V3,
            token: targetToken,
            amount: 100_000 * DECIMALS_18,
            steps: steps3,
            description: "reentrancy_during_flash"
        });

        // Multi-token arbitrage
        bytes[] memory steps4 = new bytes[](4);
        steps4[0] = abi.encodeWithSignature("swap(address,address,uint256)", targetToken, 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, 500_000 * DECIMALS_18);
        steps4[1] = abi.encodeWithSignature("swap(address,address,uint256)", 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, 500 * DECIMALS_18);
        steps4[2] = abi.encodeWithSignature("swap(address,address,uint256)", 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, targetToken, 500_000 * DECIMALS_6);
        steps4[3] = abi.encodeWithSignature("collect()");

        sequences[3] = FlashLoanSequence({
            provider: BALANCER,
            token: targetToken,
            amount: 1_000_000 * DECIMALS_18,
            steps: steps4,
            description: "multi_token_arbitrage"
        });

        // Share price manipulation
        bytes[] memory steps5 = new bytes[](3);
        steps5[0] = abi.encodeWithSignature("deposit(uint256)", 10_000_000 * DECIMALS_18);
        steps5[1] = abi.encodeWithSignature("donate(uint256)", 1_000_000 * DECIMALS_18);
        steps5[2] = abi.encodeWithSignature("withdraw(uint256)", TYPE_MAX);

        sequences[4] = FlashLoanSequence({
            provider: AAVE_V3,
            token: targetToken,
            amount: 11_000_000 * DECIMALS_18,
            steps: steps5,
            description: "share_price_inflation"
        });

        return sequences;
    }

    // ============ REPEATED CALL SEQUENCES ============

    function generateRepeatedCallSequences(
        address target,
        bytes4 selector,
        uint256 repetitions
    ) public pure returns (bytes[] memory) {
        bytes[] memory calls = new bytes[](repetitions);

        for (uint256 i = 0; i < repetitions; i++) {
            // Vary the amount slightly each iteration to test accumulation
            calls[i] = abi.encodeWithSelector(selector, 1 + i);
        }

        return calls;
    }

    // ============ CALLBACK ATTACK VECTORS ============

    struct CallbackVector {
        bytes4 callbackSelector;
        bytes callbackData;
        string description;
    }

    function generateCallbackAttackVectors(
        address target
    ) public view returns (CallbackVector[] memory) {
        CallbackVector[] memory vectors = new CallbackVector[](8);

        // Uniswap V3 callbacks
        vectors[0] = CallbackVector({
            callbackSelector: bytes4(keccak256("uniswapV3SwapCallback(int256,int256,bytes)")),
            callbackData: abi.encode(int256(TYPE_MAX_128), int256(0), abi.encode(target)),
            description: "uniswap_v3_swap_callback_exploit"
        });

        vectors[1] = CallbackVector({
            callbackSelector: bytes4(keccak256("uniswapV3FlashCallback(uint256,uint256,bytes)")),
            callbackData: abi.encode(TYPE_MAX, 0, abi.encodeWithSignature("attack()")),
            description: "uniswap_v3_flash_callback_exploit"
        });

        // ERC777 callback
        vectors[2] = CallbackVector({
            callbackSelector: bytes4(keccak256("tokensReceived(address,address,address,uint256,bytes,bytes)")),
            callbackData: abi.encode(target, target, target, TYPE_MAX, "", abi.encodeWithSignature("reenter()")),
            description: "erc777_tokens_received_reenter"
        });

        // ERC721 callback
        vectors[3] = CallbackVector({
            callbackSelector: bytes4(keccak256("onERC721Received(address,address,uint256,bytes)")),
            callbackData: abi.encode(target, target, 0, abi.encodeWithSignature("attack()")),
            description: "erc721_received_exploit"
        });

        // ERC1155 callback
        vectors[4] = CallbackVector({
            callbackSelector: bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)")),
            callbackData: abi.encode(target, target, 0, TYPE_MAX, abi.encodeWithSignature("attack()")),
            description: "erc1155_received_exploit"
        });

        // Flash loan callback
        vectors[5] = CallbackVector({
            callbackSelector: bytes4(keccak256("onFlashLoan(address,address,uint256,uint256,bytes)")),
            callbackData: abi.encode(target, target, TYPE_MAX, 0, abi.encodeWithSignature("drain()")),
            description: "flash_loan_callback_exploit"
        });

        // Balancer flash loan
        vectors[6] = CallbackVector({
            callbackSelector: bytes4(keccak256("receiveFlashLoan(address[],uint256[],uint256[],bytes)")),
            callbackData: abi.encode(new address[](1), new uint256[](1), new uint256[](1), abi.encodeWithSignature("exploit()")),
            description: "balancer_flash_callback_exploit"
        });

        // Generic fallback exploitation
        vectors[7] = CallbackVector({
            callbackSelector: bytes4(0),
            callbackData: abi.encodeWithSignature("fallbackExploit()"),
            description: "fallback_exploit"
        });

        return vectors;
    }
}

// ============ MALICIOUS CONTRACTS ============

contract MaliciousRouter {
    address public owner;
    bool public attackMode;

    constructor() {
        owner = msg.sender;
    }

    function setAttackMode(bool _mode) external {
        attackMode = _mode;
    }

    // Fake swap that steals tokens
    function swap(
        uint256 amountIn,
        uint256,
        address to,
        bytes calldata
    ) external returns (uint256) {
        if (attackMode) {
            // Instead of swapping, try to drain the caller
            // This would need token approval
        }
        return amountIn; // Return same amount (no actual swap)
    }

    // Fake getAmountOut that returns inflated values
    function getAmountOut(
        uint256 amountIn,
        address,
        address
    ) external pure returns (uint256) {
        return amountIn * 1000; // Wildly inflated
    }

    fallback() external payable {}
    receive() external payable {}
}

contract MaliciousOracle {
    uint256 public price;
    address public owner;

    constructor(uint256 _price) {
        price = _price;
        owner = msg.sender;
    }

    function setPrice(uint256 _price) external {
        price = _price;
    }

    function latestAnswer() external view returns (int256) {
        return int256(price);
    }

    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    ) {
        return (1, int256(price), block.timestamp, block.timestamp, 1);
    }

    function getPrice(address) external view returns (uint256) {
        return price;
    }

    function decimals() external pure returns (uint8) {
        return 18;
    }
}

contract ReentrantCallback {
    address public target;
    bytes public attackCalldata;
    uint256 public attackCount;

    constructor(address _target, bytes memory _attackCalldata) {
        target = _target;
        attackCalldata = _attackCalldata;
    }

    // ERC777 hook
    function tokensReceived(
        address,
        address,
        address,
        uint256,
        bytes calldata,
        bytes calldata
    ) external {
        _attack();
    }

    // Uniswap V3 callback
    function uniswapV3SwapCallback(
        int256,
        int256,
        bytes calldata
    ) external {
        _attack();
    }

    // Flash loan callback
    function onFlashLoan(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) external returns (bytes32) {
        _attack();
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }

    // Generic fallback reentrancy
    fallback() external payable {
        _attack();
    }

    receive() external payable {
        _attack();
    }

    function _attack() internal {
        if (attackCount < 3) {
            attackCount++;
            (bool success,) = target.call(attackCalldata);
            // Silently fail if attack doesn't work
        }
    }
}
