// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "forge-std/StdInvariant.sol";

/**
 * @title InvariantSecurityModel
 * @notice Invariant-first security modeling for novel vulnerability discovery
 * @dev Defines value-conservation invariants for each DeFi subsystem
 */
abstract contract InvariantSecurityModel is StdInvariant, Test {

    // ============ INVARIANT TRACKING ============

    struct InvariantCheck {
        string name;
        string category;
        bool enabled;
        uint256 checkCount;
        uint256 violationCount;
        int256 maxDeviation;
    }

    struct StateSnapshot {
        uint256 timestamp;
        uint256 blockNumber;
        mapping(bytes32 => uint256) values;
    }

    mapping(bytes32 => InvariantCheck) public invariants;
    bytes32[] public invariantIds;

    mapping(address => StateSnapshot) internal snapshots;

    // Tolerance for rounding (in basis points, 1 = 0.01%)
    uint256 public constant ROUNDING_TOLERANCE_BPS = 1;
    uint256 public constant BPS_DENOMINATOR = 10000;

    // ============ EVENTS ============

    event InvariantViolation(
        bytes32 indexed invariantId,
        string name,
        uint256 expected,
        uint256 actual,
        int256 deviation
    );

    event InvariantRegistered(bytes32 indexed invariantId, string name, string category);

    // ============ INVARIANT REGISTRATION ============

    function _registerInvariant(
        string memory name,
        string memory category
    ) internal returns (bytes32 id) {
        id = keccak256(abi.encodePacked(name, category));
        invariants[id] = InvariantCheck({
            name: name,
            category: category,
            enabled: true,
            checkCount: 0,
            violationCount: 0,
            maxDeviation: 0
        });
        invariantIds.push(id);
        emit InvariantRegistered(id, name, category);
    }

    // ============ VAULT INVARIANTS ============

    /**
     * @notice Total assets should equal sum of all shares * price per share
     * INV-V1: totalAssets >= totalSupply * pricePerShare / precision (within rounding)
     */
    function invariant_vault_conservation(
        address vault,
        address asset
    ) public returns (bool valid, int256 deviation) {
        bytes32 id = keccak256(abi.encodePacked("vault_conservation", vault));

        uint256 totalAssets;
        uint256 totalSupply;
        uint256 pricePerShare;

        // Get vault state
        try IVault(vault).totalAssets() returns (uint256 ta) {
            totalAssets = ta;
        } catch {
            return (true, 0); // Can't check
        }

        try IVault(vault).totalSupply() returns (uint256 ts) {
            totalSupply = ts;
        } catch {
            return (true, 0);
        }

        if (totalSupply == 0) return (true, 0);

        try IVault(vault).convertToAssets(1e18) returns (uint256 pps) {
            pricePerShare = pps;
        } catch {
            try IVault(vault).pricePerShare() returns (uint256 pps) {
                pricePerShare = pps;
            } catch {
                return (true, 0);
            }
        }

        // Calculate expected assets based on shares
        uint256 expectedAssets = (totalSupply * pricePerShare) / 1e18;

        // Allow for rounding tolerance
        uint256 tolerance = (expectedAssets * ROUNDING_TOLERANCE_BPS) / BPS_DENOMINATOR;

        if (totalAssets + tolerance >= expectedAssets && totalAssets <= expectedAssets + tolerance) {
            valid = true;
            deviation = int256(totalAssets) - int256(expectedAssets);
        } else {
            valid = false;
            deviation = int256(totalAssets) - int256(expectedAssets);
            _recordViolation(id, expectedAssets, totalAssets, deviation);
        }

        invariants[id].checkCount++;
        if (!valid) invariants[id].violationCount++;
        if (deviation > invariants[id].maxDeviation || -deviation > invariants[id].maxDeviation) {
            invariants[id].maxDeviation = deviation > 0 ? deviation : -deviation;
        }
    }

    /**
     * @notice Share price should be monotonically non-decreasing (no loss without withdrawal)
     * INV-V2: pricePerShare(t2) >= pricePerShare(t1) for t2 > t1 (without withdrawals)
     */
    function invariant_vault_share_price_monotonic(
        address vault
    ) public returns (bool valid, uint256 currentPrice, uint256 previousPrice) {
        bytes32 id = keccak256(abi.encodePacked("vault_share_price_monotonic", vault));
        bytes32 priceKey = keccak256(abi.encodePacked("lastPrice", vault));

        // Get current price
        try IVault(vault).convertToAssets(1e18) returns (uint256 price) {
            currentPrice = price;
        } catch {
            try IVault(vault).pricePerShare() returns (uint256 price) {
                currentPrice = price;
            } catch {
                return (true, 0, 0);
            }
        }

        // Get previous price from snapshot
        previousPrice = snapshots[vault].values[priceKey];

        if (previousPrice == 0) {
            // First check, store price
            snapshots[vault].values[priceKey] = currentPrice;
            return (true, currentPrice, 0);
        }

        // Check monotonicity (allow tiny rounding decrease)
        uint256 tolerance = previousPrice / 10000; // 0.01% tolerance
        valid = currentPrice >= previousPrice - tolerance;

        if (!valid) {
            int256 deviation = int256(currentPrice) - int256(previousPrice);
            _recordViolation(id, previousPrice, currentPrice, deviation);
        }

        // Update stored price
        snapshots[vault].values[priceKey] = currentPrice;

        invariants[id].checkCount++;
        if (!valid) invariants[id].violationCount++;
    }

    // ============ LENDING MARKET INVARIANTS ============

    /**
     * @notice Borrowable value must be <= collateral value * LTV
     * INV-L1: borrowValue <= collateralValue * LTV / precision
     */
    function invariant_lending_ltv_bound(
        address lendingPool,
        address user
    ) public returns (bool valid, uint256 borrowValue, uint256 maxBorrowable) {
        bytes32 id = keccak256(abi.encodePacked("lending_ltv_bound", lendingPool, user));

        // Try to get user account data
        try ILendingPool(lendingPool).getUserAccountData(user) returns (
            uint256 totalCollateralETH,
            uint256 totalDebtETH,
            uint256 availableBorrowsETH,
            uint256 currentLiquidationThreshold,
            uint256 ltv,
            uint256 healthFactor
        ) {
            borrowValue = totalDebtETH;
            maxBorrowable = (totalCollateralETH * ltv) / 10000;

            valid = borrowValue <= maxBorrowable;

            if (!valid) {
                int256 deviation = int256(borrowValue) - int256(maxBorrowable);
                _recordViolation(id, maxBorrowable, borrowValue, deviation);
            }
        } catch {
            return (true, 0, 0);
        }

        invariants[id].checkCount++;
        if (!valid) invariants[id].violationCount++;
    }

    /**
     * @notice Health factor must be >= 1 for non-liquidatable positions
     * INV-L2: healthFactor >= 1e18 OR position is liquidatable
     */
    function invariant_lending_health_factor(
        address lendingPool,
        address user
    ) public returns (bool valid, uint256 healthFactor) {
        bytes32 id = keccak256(abi.encodePacked("lending_health_factor", lendingPool, user));

        try ILendingPool(lendingPool).getUserAccountData(user) returns (
            uint256, uint256, uint256, uint256, uint256, uint256 hf
        ) {
            healthFactor = hf;
            valid = healthFactor >= 1e18 || healthFactor == 0; // 0 means no debt

            if (!valid) {
                int256 deviation = int256(healthFactor) - int256(1e18);
                _recordViolation(id, 1e18, healthFactor, deviation);
            }
        } catch {
            return (true, 0);
        }

        invariants[id].checkCount++;
        if (!valid) invariants[id].violationCount++;
    }

    // ============ DEX/AMM INVARIANTS ============

    /**
     * @notice Constant product invariant: k should not decrease
     * INV-D1: x * y >= k_initial (after fees)
     */
    function invariant_dex_constant_product(
        address pair
    ) public returns (bool valid, uint256 currentK, uint256 previousK) {
        bytes32 id = keccak256(abi.encodePacked("dex_constant_product", pair));
        bytes32 kKey = keccak256(abi.encodePacked("lastK", pair));

        // Get reserves
        try IPair(pair).getReserves() returns (uint112 reserve0, uint112 reserve1, uint32) {
            currentK = uint256(reserve0) * uint256(reserve1);
        } catch {
            return (true, 0, 0);
        }

        previousK = snapshots[pair].values[kKey];

        if (previousK == 0) {
            snapshots[pair].values[kKey] = currentK;
            return (true, currentK, 0);
        }

        // k should not decrease significantly (small tolerance for rounding)
        uint256 tolerance = previousK / 10000;
        valid = currentK >= previousK - tolerance;

        if (!valid) {
            int256 deviation = int256(currentK) - int256(previousK);
            _recordViolation(id, previousK, currentK, deviation);
        }

        snapshots[pair].values[kKey] = currentK;

        invariants[id].checkCount++;
        if (!valid) invariants[id].violationCount++;
    }

    /**
     * @notice LP token supply should reflect actual liquidity
     * INV-D2: sqrt(reserve0 * reserve1) proportional to totalSupply
     */
    function invariant_dex_lp_supply(
        address pair
    ) public returns (bool valid, uint256 sqrtK, uint256 totalSupply) {
        bytes32 id = keccak256(abi.encodePacked("dex_lp_supply", pair));

        try IPair(pair).getReserves() returns (uint112 reserve0, uint112 reserve1, uint32) {
            sqrtK = sqrt(uint256(reserve0) * uint256(reserve1));
        } catch {
            return (true, 0, 0);
        }

        try IPair(pair).totalSupply() returns (uint256 ts) {
            totalSupply = ts;
        } catch {
            return (true, 0, 0);
        }

        if (totalSupply == 0) {
            valid = sqrtK == 0;
        } else {
            // sqrtK/totalSupply should be relatively constant
            // This is a simplified check
            valid = sqrtK > 0;
        }

        invariants[id].checkCount++;
        if (!valid) invariants[id].violationCount++;
    }

    // ============ STAKING/REWARDS INVARIANTS ============

    /**
     * @notice Total claimable rewards should not exceed allocated rewards
     * INV-S1: sum(userClaimable) <= totalRewardsAllocated
     */
    function invariant_staking_rewards_bound(
        address staking,
        address[] memory users
    ) public returns (bool valid, uint256 totalClaimable, uint256 rewardsBalance) {
        bytes32 id = keccak256(abi.encodePacked("staking_rewards_bound", staking));

        totalClaimable = 0;

        for (uint256 i = 0; i < users.length; i++) {
            try IStaking(staking).earned(users[i]) returns (uint256 earned) {
                totalClaimable += earned;
            } catch {}
        }

        // Get rewards token balance
        try IStaking(staking).rewardsToken() returns (address rewardToken) {
            rewardsBalance = IERC20(rewardToken).balanceOf(staking);
        } catch {
            return (true, 0, 0);
        }

        valid = totalClaimable <= rewardsBalance;

        if (!valid) {
            int256 deviation = int256(totalClaimable) - int256(rewardsBalance);
            _recordViolation(id, rewardsBalance, totalClaimable, deviation);
        }

        invariants[id].checkCount++;
        if (!valid) invariants[id].violationCount++;
    }

    /**
     * @notice User stake should be tracked correctly
     * INV-S2: sum(userStakes) == totalStaked
     */
    function invariant_staking_total_consistency(
        address staking,
        address[] memory users
    ) public returns (bool valid, uint256 sumStakes, uint256 totalStaked) {
        bytes32 id = keccak256(abi.encodePacked("staking_total_consistency", staking));

        sumStakes = 0;

        for (uint256 i = 0; i < users.length; i++) {
            try IStaking(staking).balanceOf(users[i]) returns (uint256 bal) {
                sumStakes += bal;
            } catch {}
        }

        try IStaking(staking).totalSupply() returns (uint256 ts) {
            totalStaked = ts;
        } catch {
            return (true, 0, 0);
        }

        // Sum of individual stakes should equal total
        // Allow small tolerance for users not in the list
        valid = sumStakes <= totalStaked;

        invariants[id].checkCount++;
        if (!valid) invariants[id].violationCount++;
    }

    // ============ BRIDGE INVARIANTS ============

    /**
     * @notice Tokens locked on source must equal tokens minted on destination
     * INV-B1: lockedOnSource == mintedOnDestination (cross-chain)
     * Note: This requires off-chain verification in practice
     */
    function invariant_bridge_conservation(
        address bridge,
        address token
    ) public returns (bool valid, uint256 locked) {
        bytes32 id = keccak256(abi.encodePacked("bridge_conservation", bridge, token));

        // Get tokens locked in bridge
        locked = IERC20(token).balanceOf(bridge);

        // In a real scenario, would need to query destination chain
        // For local testing, just verify balance tracking
        valid = true;

        invariants[id].checkCount++;
    }

    // ============ GENERAL ACCOUNTING INVARIANTS ============

    /**
     * @notice No free minting: claimable value cannot increase without cost
     * INV-G1: deltaClaimable <= deltaCost for any user
     */
    function invariant_no_free_mint(
        address protocol,
        address user,
        bytes32 claimableSlot,
        bytes32 costSlot
    ) public returns (bool valid) {
        bytes32 id = keccak256(abi.encodePacked("no_free_mint", protocol, user));

        uint256 prevClaimable = snapshots[protocol].values[keccak256(abi.encodePacked("claimable", user))];
        uint256 prevCost = snapshots[protocol].values[keccak256(abi.encodePacked("cost", user))];

        uint256 currentClaimable = uint256(vm.load(protocol, claimableSlot));
        uint256 currentCost = uint256(vm.load(protocol, costSlot));

        // Store for next check
        snapshots[protocol].values[keccak256(abi.encodePacked("claimable", user))] = currentClaimable;
        snapshots[protocol].values[keccak256(abi.encodePacked("cost", user))] = currentCost;

        if (prevClaimable == 0) return (true); // First check

        int256 deltaClaimable = int256(currentClaimable) - int256(prevClaimable);
        int256 deltaCost = int256(currentCost) - int256(prevCost);

        // If claimable increased, cost should have increased proportionally
        valid = deltaClaimable <= deltaCost || deltaClaimable <= 0;

        if (!valid) {
            _recordViolation(id, uint256(deltaCost > 0 ? deltaCost : int256(0)), uint256(deltaClaimable), deltaClaimable - deltaCost);
        }

        invariants[id].checkCount++;
        if (!valid) invariants[id].violationCount++;
    }

    /**
     * @notice No double-dip: same entitlement cannot be claimed from two states
     * INV-G2: Requires state tracking before/after claims
     */
    function invariant_no_double_claim(
        address protocol,
        address user,
        uint256 claimId
    ) public returns (bool valid, bool alreadyClaimed) {
        bytes32 id = keccak256(abi.encodePacked("no_double_claim", protocol, user, claimId));
        bytes32 claimKey = keccak256(abi.encodePacked("claimed", user, claimId));

        alreadyClaimed = snapshots[protocol].values[claimKey] == 1;

        // Mark as claimed
        snapshots[protocol].values[claimKey] = 1;

        valid = !alreadyClaimed;

        if (!valid) {
            _recordViolation(id, 0, 1, 1);
        }

        invariants[id].checkCount++;
        if (!valid) invariants[id].violationCount++;
    }

    // ============ HELPER FUNCTIONS ============

    function _recordViolation(
        bytes32 id,
        uint256 expected,
        uint256 actual,
        int256 deviation
    ) internal {
        emit InvariantViolation(id, invariants[id].name, expected, actual, deviation);
        console.log("!!! INVARIANT VIOLATION !!!");
        console.log("Invariant:", invariants[id].name);
        console.log("Expected:", expected);
        console.log("Actual:", actual);
        console.logInt(deviation);
    }

    function sqrt(uint256 x) internal pure returns (uint256) {
        if (x == 0) return 0;
        uint256 z = (x + 1) / 2;
        uint256 y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
        return y;
    }

    // ============ REPORTING ============

    function getInvariantReport() external view returns (
        uint256 totalChecks,
        uint256 totalViolations,
        bytes32[] memory violatedIds
    ) {
        uint256 violatedCount = 0;

        for (uint256 i = 0; i < invariantIds.length; i++) {
            totalChecks += invariants[invariantIds[i]].checkCount;
            totalViolations += invariants[invariantIds[i]].violationCount;
            if (invariants[invariantIds[i]].violationCount > 0) {
                violatedCount++;
            }
        }

        violatedIds = new bytes32[](violatedCount);
        uint256 j = 0;
        for (uint256 i = 0; i < invariantIds.length; i++) {
            if (invariants[invariantIds[i]].violationCount > 0) {
                violatedIds[j++] = invariantIds[i];
            }
        }
    }

    function printInvariantReport() external view {
        console.log("=== INVARIANT REPORT ===");
        for (uint256 i = 0; i < invariantIds.length; i++) {
            InvariantCheck storage inv = invariants[invariantIds[i]];
            console.log("---");
            console.log("Name:", inv.name);
            console.log("Category:", inv.category);
            console.log("Checks:", inv.checkCount);
            console.log("Violations:", inv.violationCount);
            console.logInt(inv.maxDeviation);
        }
    }
}

// ============ INTERFACES ============

interface IVault {
    function totalAssets() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function pricePerShare() external view returns (uint256);
    function convertToAssets(uint256 shares) external view returns (uint256);
    function convertToShares(uint256 assets) external view returns (uint256);
}

interface ILendingPool {
    function getUserAccountData(address user) external view returns (
        uint256 totalCollateralETH,
        uint256 totalDebtETH,
        uint256 availableBorrowsETH,
        uint256 currentLiquidationThreshold,
        uint256 ltv,
        uint256 healthFactor
    );
}

interface IPair {
    function getReserves() external view returns (uint112, uint112, uint32);
    function totalSupply() external view returns (uint256);
    function token0() external view returns (address);
    function token1() external view returns (address);
}

interface IStaking {
    function earned(address account) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function rewardsToken() external view returns (address);
    function stakingToken() external view returns (address);
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
}
