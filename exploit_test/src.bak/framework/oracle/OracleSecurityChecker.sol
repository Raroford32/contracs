// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title OracleSecurityChecker
 * @notice Oracle hardening playbook for vulnerability detection
 * @dev Checks for manipulability, staleness, deviation, and liquidity requirements
 */
contract OracleSecurityChecker is Test {

    // ============ CONSTANTS ============

    uint256 constant MAX_STALENESS_SECONDS = 3600; // 1 hour default
    uint256 constant MAX_DEVIATION_BPS = 500; // 5% default
    uint256 constant MIN_LIQUIDITY_USD = 100_000 * 1e18; // $100k minimum

    // Chainlink price feeds
    address constant ETH_USD_FEED = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;
    address constant BTC_USD_FEED = 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c;
    address constant USDC_USD_FEED = 0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6;

    // DEX routers for spot price comparison
    address constant UNISWAP_V2_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    address constant UNISWAP_V3_QUOTER = 0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6;
    address constant CURVE_REGISTRY = 0x90E00ACe148ca3b23Ac1bC8C240C2a7Dd9c2d7f5;

    // ============ STRUCTS ============

    struct OracleAnalysis {
        address oracle;
        OracleType oracleType;
        bool isManipulable;
        bool isStale;
        bool hasLiquidityCheck;
        uint256 lastPrice;
        uint256 lastUpdateTime;
        uint256 manipulationCost;
        uint256 deviationFromSpot;
        string[] vulnerabilities;
    }

    struct PriceComparison {
        uint256 oraclePrice;
        uint256 spotPrice;
        uint256 deviationBps;
        bool withinTolerance;
    }

    enum OracleType {
        CHAINLINK,
        UNISWAP_V2_TWAP,
        UNISWAP_V3_TWAP,
        CURVE_ORACLE,
        CUSTOM_SPOT,
        CUSTOM_TWAP,
        UNKNOWN
    }

    mapping(address => OracleAnalysis) public oracleAnalyses;

    // ============ ORACLE IDENTIFICATION ============

    function identifyOracleType(address oracle) public view returns (OracleType) {
        // Check for Chainlink interface
        try IChainlinkOracle(oracle).latestRoundData() returns (
            uint80, int256, uint256, uint256, uint80
        ) {
            return OracleType.CHAINLINK;
        } catch {}

        // Check for Uniswap V2 pair (used as oracle)
        try IUniswapV2Pair(oracle).getReserves() returns (uint112, uint112, uint32) {
            return OracleType.UNISWAP_V2_TWAP;
        } catch {}

        // Check for Uniswap V3 pool
        try IUniswapV3Pool(oracle).observe(new uint32[](1)) returns (int56[] memory, uint160[] memory) {
            return OracleType.UNISWAP_V3_TWAP;
        } catch {}

        // Check for custom oracle patterns
        try ICustomOracle(oracle).getPrice(address(0)) returns (uint256) {
            return OracleType.CUSTOM_SPOT;
        } catch {}

        try ICustomOracle(oracle).consult(address(0), 1e18) returns (uint256) {
            return OracleType.CUSTOM_TWAP;
        } catch {}

        return OracleType.UNKNOWN;
    }

    // ============ VULNERABILITY CHECKS ============

    function analyzeOracle(
        address oracle,
        address token
    ) public returns (OracleAnalysis memory analysis) {
        analysis.oracle = oracle;
        analysis.oracleType = identifyOracleType(oracle);
        analysis.vulnerabilities = new string[](10);
        uint256 vulnCount = 0;

        // Check staleness
        (analysis.isStale, analysis.lastUpdateTime) = checkStaleness(oracle);
        if (analysis.isStale) {
            analysis.vulnerabilities[vulnCount++] = "STALE_PRICE";
        }

        // Get oracle price
        analysis.lastPrice = getOraclePrice(oracle, token);

        // Check deviation from spot
        uint256 spotPrice = getSpotPrice(token);
        if (spotPrice > 0 && analysis.lastPrice > 0) {
            analysis.deviationFromSpot = calculateDeviationBps(analysis.lastPrice, spotPrice);
            if (analysis.deviationFromSpot > MAX_DEVIATION_BPS) {
                analysis.vulnerabilities[vulnCount++] = "HIGH_DEVIATION_FROM_SPOT";
            }
        }

        // Check manipulability
        (analysis.isManipulable, analysis.manipulationCost) = checkManipulability(oracle, token);
        if (analysis.isManipulable) {
            analysis.vulnerabilities[vulnCount++] = "MANIPULABLE_PRICE_SOURCE";
        }

        // Check liquidity requirements
        analysis.hasLiquidityCheck = checkLiquidityRequirement(oracle);
        if (!analysis.hasLiquidityCheck && analysis.oracleType != OracleType.CHAINLINK) {
            analysis.vulnerabilities[vulnCount++] = "NO_LIQUIDITY_CHECK";
        }

        // Check for single-block manipulation possibility
        if (isSingleBlockManipulable(oracle)) {
            analysis.vulnerabilities[vulnCount++] = "SINGLE_BLOCK_MANIPULABLE";
        }

        // Check for decimal mismatch
        if (hasDecimalMismatch(oracle, token)) {
            analysis.vulnerabilities[vulnCount++] = "DECIMAL_MISMATCH";
        }

        // Store analysis
        oracleAnalyses[oracle] = analysis;
    }

    function checkStaleness(address oracle) public view returns (bool isStale, uint256 lastUpdate) {
        OracleType oracleType = identifyOracleType(oracle);

        if (oracleType == OracleType.CHAINLINK) {
            try IChainlinkOracle(oracle).latestRoundData() returns (
                uint80, int256, uint256, uint256 updatedAt, uint80
            ) {
                lastUpdate = updatedAt;
                isStale = block.timestamp - updatedAt > MAX_STALENESS_SECONDS;
            } catch {
                isStale = true;
            }
        } else if (oracleType == OracleType.UNISWAP_V2_TWAP) {
            // Check cumulative price update
            try IUniswapV2Pair(oracle).getReserves() returns (uint112, uint112, uint32 blockTimestampLast) {
                lastUpdate = blockTimestampLast;
                isStale = block.timestamp - blockTimestampLast > MAX_STALENESS_SECONDS;
            } catch {
                isStale = true;
            }
        } else {
            // For unknown oracles, assume potentially stale
            isStale = false;
            lastUpdate = block.timestamp;
        }
    }

    function checkManipulability(
        address oracle,
        address token
    ) public view returns (bool isManipulable, uint256 manipulationCost) {
        OracleType oracleType = identifyOracleType(oracle);

        if (oracleType == OracleType.CHAINLINK) {
            // Chainlink is generally not manipulable by flash loans
            return (false, type(uint256).max);
        }

        if (oracleType == OracleType.UNISWAP_V2_TWAP || oracleType == OracleType.CUSTOM_SPOT) {
            // Check liquidity to estimate manipulation cost
            (uint112 reserve0, uint112 reserve1,) = IUniswapV2Pair(oracle).getReserves();

            // Estimate cost to move price by 10%
            // Simplified: need ~10% of reserves to move price significantly
            manipulationCost = uint256(reserve0) / 10;

            // If manipulation cost is below threshold, it's manipulable
            isManipulable = manipulationCost < MIN_LIQUIDITY_USD;
        }

        if (oracleType == OracleType.UNISWAP_V3_TWAP) {
            // V3 TWAP is harder to manipulate due to concentrated liquidity
            // But still possible with enough capital
            try IUniswapV3Pool(oracle).liquidity() returns (uint128 liquidity) {
                manipulationCost = uint256(liquidity) / 10;
                isManipulable = manipulationCost < MIN_LIQUIDITY_USD;
            } catch {
                isManipulable = true;
                manipulationCost = 0;
            }
        }
    }

    function checkLiquidityRequirement(address oracle) public view returns (bool hasCheck) {
        // This would ideally involve bytecode analysis
        // For now, we check common patterns

        // Check if oracle has minLiquidity parameter
        try ICustomOracle(oracle).minLiquidity() returns (uint256 minLiq) {
            hasCheck = minLiq > 0;
        } catch {
            hasCheck = false;
        }
    }

    function isSingleBlockManipulable(address oracle) public view returns (bool) {
        OracleType oracleType = identifyOracleType(oracle);

        // Spot oracles are always single-block manipulable
        if (oracleType == OracleType.CUSTOM_SPOT) {
            return true;
        }

        // Check TWAP window for time-weighted oracles
        if (oracleType == OracleType.UNISWAP_V3_TWAP) {
            // Would need to check observation cardinality and window
            return false; // Assume safe if using TWAP
        }

        if (oracleType == OracleType.UNISWAP_V2_TWAP) {
            // V2 TWAP window is typically 30 minutes+
            return false;
        }

        // Unknown oracles might be vulnerable
        return oracleType == OracleType.UNKNOWN;
    }

    function hasDecimalMismatch(address oracle, address token) public view returns (bool) {
        uint8 oracleDecimals;
        uint8 tokenDecimals;

        // Get oracle decimals
        try IChainlinkOracle(oracle).decimals() returns (uint8 dec) {
            oracleDecimals = dec;
        } catch {
            oracleDecimals = 18; // Assume 18 if unknown
        }

        // Get token decimals
        try IERC20Metadata(token).decimals() returns (uint8 dec) {
            tokenDecimals = dec;
        } catch {
            tokenDecimals = 18;
        }

        // Check for potential precision issues
        // Common issue: Oracle returns 8 decimals, token has 18
        return oracleDecimals != tokenDecimals && oracleDecimals != 8;
    }

    // ============ PRICE RETRIEVAL ============

    function getOraclePrice(address oracle, address token) public view returns (uint256) {
        OracleType oracleType = identifyOracleType(oracle);

        if (oracleType == OracleType.CHAINLINK) {
            try IChainlinkOracle(oracle).latestRoundData() returns (
                uint80, int256 price, uint256, uint256, uint80
            ) {
                return price > 0 ? uint256(price) : 0;
            } catch {
                return 0;
            }
        }

        if (oracleType == OracleType.UNISWAP_V2_TWAP) {
            try IUniswapV2Pair(oracle).getReserves() returns (uint112 r0, uint112 r1, uint32) {
                // Simplified price: r1/r0
                return r0 > 0 ? (uint256(r1) * 1e18) / uint256(r0) : 0;
            } catch {
                return 0;
            }
        }

        // Try custom oracle
        try ICustomOracle(oracle).getPrice(token) returns (uint256 price) {
            return price;
        } catch {}

        try ICustomOracle(oracle).latestAnswer() returns (int256 price) {
            return price > 0 ? uint256(price) : 0;
        } catch {}

        return 0;
    }

    function getSpotPrice(address token) public view returns (uint256) {
        // Try to get spot price from Uniswap V3
        if (token == address(0)) return 0;

        // For simplicity, return 0 - in practice would query DEXes
        return 0;
    }

    function calculateDeviationBps(uint256 price1, uint256 price2) public pure returns (uint256) {
        if (price1 == 0 || price2 == 0) return type(uint256).max;

        uint256 diff = price1 > price2 ? price1 - price2 : price2 - price1;
        return (diff * 10000) / price1;
    }

    // ============ ORACLE HARDENING RECOMMENDATIONS ============

    function getHardeningRecommendations(
        address oracle
    ) public view returns (string[] memory recommendations) {
        OracleAnalysis storage analysis = oracleAnalyses[oracle];
        recommendations = new string[](8);
        uint256 count = 0;

        if (analysis.isStale) {
            recommendations[count++] = "Add staleness check with max age threshold";
        }

        if (analysis.isManipulable) {
            recommendations[count++] = "Add minimum liquidity requirement";
            recommendations[count++] = "Use TWAP instead of spot price";
            recommendations[count++] = "Implement price deviation circuit breaker";
        }

        if (!analysis.hasLiquidityCheck) {
            recommendations[count++] = "Add liquidity depth verification";
        }

        if (analysis.oracleType != OracleType.CHAINLINK) {
            recommendations[count++] = "Consider using Chainlink as primary or fallback";
            recommendations[count++] = "Implement multi-oracle medianization";
        }

        recommendations[count++] = "Add price deviation threshold (e.g., 5% max change)";
    }

    // ============ MANIPULATION SIMULATION ============

    function simulateOracleManipulation(
        address oracle,
        address token,
        uint256 manipulationAmount
    ) public returns (uint256 priceBefore, uint256 priceAfter, uint256 impact) {
        priceBefore = getOraclePrice(oracle, token);

        // Would need to simulate swap to manipulate price
        // This is a placeholder for actual manipulation testing

        priceAfter = priceBefore; // No actual manipulation in view
        impact = 0;
    }

    // ============ REPORTING ============

    function printOracleAnalysis(address oracle) public view {
        OracleAnalysis storage analysis = oracleAnalyses[oracle];

        console.log("=== Oracle Security Analysis ===");
        console.log("Oracle:", oracle);
        console.log("Type:", uint256(analysis.oracleType));
        console.log("Is Manipulable:", analysis.isManipulable);
        console.log("Is Stale:", analysis.isStale);
        console.log("Has Liquidity Check:", analysis.hasLiquidityCheck);
        console.log("Last Price:", analysis.lastPrice);
        console.log("Last Update:", analysis.lastUpdateTime);
        console.log("Manipulation Cost:", analysis.manipulationCost);
        console.log("Deviation from Spot (bps):", analysis.deviationFromSpot);

        console.log("Vulnerabilities:");
        for (uint256 i = 0; i < analysis.vulnerabilities.length; i++) {
            if (bytes(analysis.vulnerabilities[i]).length > 0) {
                console.log("  -", analysis.vulnerabilities[i]);
            }
        }
    }
}

// ============ INTERFACES ============

interface IChainlinkOracle {
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
    function decimals() external view returns (uint8);
}

interface IUniswapV2Pair {
    function getReserves() external view returns (uint112, uint112, uint32);
    function price0CumulativeLast() external view returns (uint256);
    function price1CumulativeLast() external view returns (uint256);
}

interface IUniswapV3Pool {
    function observe(uint32[] calldata secondsAgos) external view returns (
        int56[] memory tickCumulatives,
        uint160[] memory secondsPerLiquidityCumulativeX128s
    );
    function liquidity() external view returns (uint128);
    function slot0() external view returns (
        uint160 sqrtPriceX96,
        int24 tick,
        uint16 observationIndex,
        uint16 observationCardinality,
        uint16 observationCardinalityNext,
        uint8 feeProtocol,
        bool unlocked
    );
}

interface ICustomOracle {
    function getPrice(address token) external view returns (uint256);
    function latestAnswer() external view returns (int256);
    function consult(address token, uint256 amountIn) external view returns (uint256);
    function minLiquidity() external view returns (uint256);
}

interface IERC20Metadata {
    function decimals() external view returns (uint8);
}
