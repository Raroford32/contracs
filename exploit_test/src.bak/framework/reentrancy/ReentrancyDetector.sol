// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title ReentrancyDetector
 * @notice Detects reentrancy vulnerabilities through dynamic analysis
 * @dev Checks for external calls before state updates and missing guards
 */
contract ReentrancyDetector is Test {

    // ============ STATE ============

    struct ReentrancyAnalysis {
        address target;
        bytes4 selector;
        bool hasReentrancyGuard;
        bool hasExternalCallBeforeStateUpdate;
        bool exploitableViaETH;
        bool exploitableViaERC777;
        bool exploitableViaERC721;
        bool exploitableViaERC1155;
        bool exploitableViaFlashLoan;
        uint256 maxReentryDepth;
        string[] vulnerabilities;
    }

    struct CallTrace {
        address caller;
        address target;
        bytes4 selector;
        uint256 value;
        uint256 depth;
        bool stateModified;
    }

    mapping(address => mapping(bytes4 => ReentrancyAnalysis)) public analyses;
    CallTrace[] public callTraces;
    uint256 public currentDepth;
    uint256 public maxDepthReached;

    // State tracking
    mapping(address => mapping(bytes32 => bytes32)) public stateSnapshots;
    bool public inReentrancyTest;

    // ============ DETECTION INTERFACE ============

    function analyzeReentrancy(
        address target,
        bytes4 selector
    ) public returns (ReentrancyAnalysis memory analysis) {
        analysis.target = target;
        analysis.selector = selector;
        analysis.vulnerabilities = new string[](10);
        uint256 vulnCount = 0;

        // Check for reentrancy guard
        analysis.hasReentrancyGuard = checkForReentrancyGuard(target);

        // Check for CEI pattern violation
        analysis.hasExternalCallBeforeStateUpdate = checkCEIViolation(target, selector);
        if (analysis.hasExternalCallBeforeStateUpdate && !analysis.hasReentrancyGuard) {
            analysis.vulnerabilities[vulnCount++] = "CEI_VIOLATION_NO_GUARD";
        }

        // Test specific reentrancy vectors
        analysis.exploitableViaETH = testETHReentrancy(target, selector);
        if (analysis.exploitableViaETH) {
            analysis.vulnerabilities[vulnCount++] = "ETH_REENTRANCY";
        }

        analysis.exploitableViaERC777 = testERC777Reentrancy(target, selector);
        if (analysis.exploitableViaERC777) {
            analysis.vulnerabilities[vulnCount++] = "ERC777_HOOK_REENTRANCY";
        }

        analysis.exploitableViaERC721 = testERC721Reentrancy(target, selector);
        if (analysis.exploitableViaERC721) {
            analysis.vulnerabilities[vulnCount++] = "ERC721_CALLBACK_REENTRANCY";
        }

        analysis.exploitableViaERC1155 = testERC1155Reentrancy(target, selector);
        if (analysis.exploitableViaERC1155) {
            analysis.vulnerabilities[vulnCount++] = "ERC1155_CALLBACK_REENTRANCY";
        }

        analysis.exploitableViaFlashLoan = testFlashLoanReentrancy(target, selector);
        if (analysis.exploitableViaFlashLoan) {
            analysis.vulnerabilities[vulnCount++] = "FLASH_LOAN_REENTRANCY";
        }

        // Test max reentry depth
        analysis.maxReentryDepth = testMaxReentryDepth(target, selector);
        if (analysis.maxReentryDepth > 1) {
            analysis.vulnerabilities[vulnCount++] = "MULTIPLE_REENTRY_POSSIBLE";
        }

        // Store analysis
        analyses[target][selector] = analysis;
    }

    // ============ GUARD DETECTION ============

    function checkForReentrancyGuard(address target) public view returns (bool) {
        // Check common reentrancy guard storage slots

        // OpenZeppelin ReentrancyGuard uses slot for _status
        // Slot is typically keccak256("ReentrancyGuard.status") - 1
        bytes32 ozSlot = bytes32(uint256(keccak256("openzeppelin.storage.ReentrancyGuard")) - 1);
        bytes32 ozValue = vm.load(target, ozSlot);
        if (ozValue != bytes32(0)) {
            return true;
        }

        // Check for simple locked bool at low slots
        for (uint256 i = 0; i < 10; i++) {
            bytes32 value = vm.load(target, bytes32(i));
            // A reentrancy guard typically stores 1 or 2
            if (value == bytes32(uint256(1)) || value == bytes32(uint256(2))) {
                // Could be a reentrancy guard, but not definitive
                // Would need bytecode analysis for certainty
            }
        }

        // Check bytecode for common guard patterns
        bytes memory code = target.code;
        if (containsReentrancyGuardPattern(code)) {
            return true;
        }

        return false;
    }

    function containsReentrancyGuardPattern(bytes memory code) internal pure returns (bool) {
        // Look for typical reentrancy guard assembly patterns
        // This is a simplified check - real implementation would do deeper analysis

        // Pattern: SLOAD, PUSH1 0x02, EQ, PUSH1 revert_offset, JUMPI
        // (Checking if status == 2 means "entered")

        if (code.length < 20) return false;

        // Simplified: just check if code has certain size (likely has logic)
        // In practice, would need proper bytecode parsing
        return false;
    }

    // ============ CEI VIOLATION CHECK ============

    function checkCEIViolation(address target, bytes4 selector) public view returns (bool) {
        // This would require bytecode analysis to determine order of operations
        // Simplified: assume potential violation if external calls exist

        bytes memory code = target.code;

        // Check for CALL/STATICCALL/DELEGATECALL opcodes
        bool hasExternalCall = false;
        bool hasStorageWrite = false;
        uint256 externalCallOffset = 0;
        uint256 storageWriteOffset = 0;

        for (uint256 i = 0; i < code.length; i++) {
            uint8 opcode = uint8(code[i]);

            // CALL = 0xF1, STATICCALL = 0xFA, DELEGATECALL = 0xF4
            if (opcode == 0xF1 || opcode == 0xFA || opcode == 0xF4) {
                if (!hasExternalCall) {
                    hasExternalCall = true;
                    externalCallOffset = i;
                }
            }

            // SSTORE = 0x55
            if (opcode == 0x55) {
                hasStorageWrite = true;
                storageWriteOffset = i;
            }
        }

        // CEI violation if external call happens before storage write
        // This is a simplification - real check needs control flow analysis
        return hasExternalCall && hasStorageWrite && externalCallOffset < storageWriteOffset;
    }

    // ============ SPECIFIC REENTRANCY TESTS ============

    function testETHReentrancy(address target, bytes4 selector) public returns (bool) {
        // Deploy attacker contract
        ETHReentrantAttacker attacker = new ETHReentrantAttacker(target, selector);

        // Give attacker some ETH
        vm.deal(address(attacker), 10 ether);

        // Try the attack
        try attacker.attack{value: 1 ether}() {
            return attacker.reentrancySucceeded();
        } catch {
            return false;
        }
    }

    function testERC777Reentrancy(address target, bytes4 selector) public returns (bool) {
        // Deploy ERC777 hook attacker
        ERC777ReentrantAttacker attacker = new ERC777ReentrantAttacker(target, selector);

        // The attack would trigger via tokensReceived callback
        // Simplified: return false as we can't easily deploy ERC777 token
        return false;
    }

    function testERC721Reentrancy(address target, bytes4 selector) public returns (bool) {
        // Deploy ERC721 callback attacker
        ERC721ReentrantAttacker attacker = new ERC721ReentrantAttacker(target, selector);

        // The attack would trigger via onERC721Received callback
        return false;
    }

    function testERC1155Reentrancy(address target, bytes4 selector) public returns (bool) {
        // Deploy ERC1155 callback attacker
        ERC1155ReentrantAttacker attacker = new ERC1155ReentrantAttacker(target, selector);

        // The attack would trigger via onERC1155Received callback
        return false;
    }

    function testFlashLoanReentrancy(address target, bytes4 selector) public returns (bool) {
        // Deploy flash loan reentrancy attacker
        FlashLoanReentrantAttacker attacker = new FlashLoanReentrantAttacker(target, selector);

        // The attack would trigger during flash loan callback
        return false;
    }

    function testMaxReentryDepth(address target, bytes4 selector) public returns (uint256) {
        maxDepthReached = 0;
        currentDepth = 0;

        DepthTester tester = new DepthTester(target, selector);

        try tester.testDepth(5) returns (uint256 depth) {
            return depth;
        } catch {
            return maxDepthReached;
        }
    }

    // ============ CALL TRACING ============

    function startTrace() public {
        delete callTraces;
        inReentrancyTest = true;
    }

    function endTrace() public {
        inReentrancyTest = false;
    }

    function recordCall(
        address caller,
        address target,
        bytes4 selector,
        uint256 value,
        bool stateModified
    ) public {
        if (inReentrancyTest) {
            callTraces.push(CallTrace({
                caller: caller,
                target: target,
                selector: selector,
                value: value,
                depth: currentDepth,
                stateModified: stateModified
            }));
        }
    }

    function analyzeCallTrace() public view returns (
        bool hasReentrancy,
        uint256 maxDepth,
        address reentryPoint
    ) {
        maxDepth = 0;
        hasReentrancy = false;
        reentryPoint = address(0);

        // Look for same target appearing multiple times at increasing depth
        for (uint256 i = 0; i < callTraces.length; i++) {
            if (callTraces[i].depth > maxDepth) {
                maxDepth = callTraces[i].depth;
            }

            for (uint256 j = i + 1; j < callTraces.length; j++) {
                if (callTraces[i].target == callTraces[j].target &&
                    callTraces[i].selector == callTraces[j].selector &&
                    callTraces[j].depth > callTraces[i].depth) {
                    hasReentrancy = true;
                    reentryPoint = callTraces[i].target;
                    break;
                }
            }
        }
    }

    // ============ REPORTING ============

    function printAnalysis(address target, bytes4 selector) public view {
        ReentrancyAnalysis storage analysis = analyses[target][selector];

        console.log("=== Reentrancy Analysis ===");
        console.log("Target:", target);
        console.log("Selector:", uint32(selector));
        console.log("Has Reentrancy Guard:", analysis.hasReentrancyGuard);
        console.log("CEI Violation:", analysis.hasExternalCallBeforeStateUpdate);
        console.log("ETH Reentrancy:", analysis.exploitableViaETH);
        console.log("ERC777 Reentrancy:", analysis.exploitableViaERC777);
        console.log("ERC721 Reentrancy:", analysis.exploitableViaERC721);
        console.log("ERC1155 Reentrancy:", analysis.exploitableViaERC1155);
        console.log("Flash Loan Reentrancy:", analysis.exploitableViaFlashLoan);
        console.log("Max Reentry Depth:", analysis.maxReentryDepth);

        console.log("Vulnerabilities:");
        for (uint256 i = 0; i < analysis.vulnerabilities.length; i++) {
            if (bytes(analysis.vulnerabilities[i]).length > 0) {
                console.log("  -", analysis.vulnerabilities[i]);
            }
        }
    }

    function getCallTraces() public view returns (CallTrace[] memory) {
        return callTraces;
    }
}

// ============ ATTACKER CONTRACTS ============

contract ETHReentrantAttacker {
    address public target;
    bytes4 public selector;
    uint256 public attackCount;
    bool public reentrancySucceeded;

    constructor(address _target, bytes4 _selector) {
        target = _target;
        selector = _selector;
    }

    function attack() external payable {
        attackCount = 0;
        reentrancySucceeded = false;

        // Call target function
        (bool success,) = target.call{value: msg.value}(abi.encodeWithSelector(selector));
        if (!success) revert("Initial call failed");
    }

    receive() external payable {
        if (attackCount < 3) {
            attackCount++;
            reentrancySucceeded = true;

            // Try to reenter
            (bool success,) = target.call{value: 0}(abi.encodeWithSelector(selector));
            // Don't revert on failure - just record that reentrancy was possible
        }
    }

    fallback() external payable {
        if (attackCount < 3) {
            attackCount++;
            reentrancySucceeded = true;

            (bool success,) = target.call{value: 0}(abi.encodeWithSelector(selector));
        }
    }
}

contract ERC777ReentrantAttacker {
    address public target;
    bytes4 public selector;
    uint256 public attackCount;
    bool public reentrancySucceeded;

    constructor(address _target, bytes4 _selector) {
        target = _target;
        selector = _selector;
    }

    // ERC777 tokensReceived hook
    function tokensReceived(
        address,
        address,
        address,
        uint256,
        bytes calldata,
        bytes calldata
    ) external {
        if (attackCount < 3) {
            attackCount++;
            reentrancySucceeded = true;

            (bool success,) = target.call(abi.encodeWithSelector(selector));
        }
    }
}

contract ERC721ReentrantAttacker {
    address public target;
    bytes4 public selector;
    uint256 public attackCount;
    bool public reentrancySucceeded;

    constructor(address _target, bytes4 _selector) {
        target = _target;
        selector = _selector;
    }

    // ERC721 onERC721Received hook
    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external returns (bytes4) {
        if (attackCount < 3) {
            attackCount++;
            reentrancySucceeded = true;

            (bool success,) = target.call(abi.encodeWithSelector(selector));
        }
        return this.onERC721Received.selector;
    }
}

contract ERC1155ReentrantAttacker {
    address public target;
    bytes4 public selector;
    uint256 public attackCount;
    bool public reentrancySucceeded;

    constructor(address _target, bytes4 _selector) {
        target = _target;
        selector = _selector;
    }

    // ERC1155 onERC1155Received hook
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) external returns (bytes4) {
        if (attackCount < 3) {
            attackCount++;
            reentrancySucceeded = true;

            (bool success,) = target.call(abi.encodeWithSelector(selector));
        }
        return this.onERC1155Received.selector;
    }

    // ERC1155 onERC1155BatchReceived hook
    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external returns (bytes4) {
        if (attackCount < 3) {
            attackCount++;
            reentrancySucceeded = true;

            (bool success,) = target.call(abi.encodeWithSelector(selector));
        }
        return this.onERC1155BatchReceived.selector;
    }
}

contract FlashLoanReentrantAttacker {
    address public target;
    bytes4 public selector;
    uint256 public attackCount;
    bool public reentrancySucceeded;

    constructor(address _target, bytes4 _selector) {
        target = _target;
        selector = _selector;
    }

    // Flash loan callback
    function onFlashLoan(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) external returns (bytes32) {
        if (attackCount < 3) {
            attackCount++;
            reentrancySucceeded = true;

            (bool success,) = target.call(abi.encodeWithSelector(selector));
        }
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }

    // Balancer style callback
    function receiveFlashLoan(
        address[] calldata,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external {
        if (attackCount < 3) {
            attackCount++;
            reentrancySucceeded = true;

            (bool success,) = target.call(abi.encodeWithSelector(selector));
        }
    }
}

contract DepthTester {
    address public target;
    bytes4 public selector;
    uint256 public currentDepth;
    uint256 public maxDepth;

    constructor(address _target, bytes4 _selector) {
        target = _target;
        selector = _selector;
    }

    function testDepth(uint256 maxAttempts) external returns (uint256) {
        currentDepth = 0;
        maxDepth = 0;

        for (uint256 i = 0; i < maxAttempts; i++) {
            currentDepth++;
            if (currentDepth > maxDepth) maxDepth = currentDepth;

            (bool success,) = target.call(abi.encodeWithSelector(selector));
            if (!success) break;
        }

        return maxDepth;
    }
}
