// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title AttackSurfaceEnumerator
 * @notice Systematic attack-surface enumeration for novel vulnerability discovery
 * @dev Maps every externally callable function and classifies by risk category
 */
contract AttackSurfaceEnumerator is Test {

    // ============ FUNCTION CLASSIFICATION ============

    struct FunctionSignature {
        bytes4 selector;
        string name;
        FunctionRisk risk;
        bool payable_;
        bool hasExternalCall;
        bool modifiesState;
        bool touchesFunds;
    }

    enum FunctionRisk {
        CRITICAL,    // Direct fund access, admin control
        HIGH,        // Price manipulation, share minting
        MEDIUM,      // State modification, index updates
        LOW,         // View functions, getters
        INFO         // Pure functions, constants
    }

    // ============ DEPENDENCY GRAPH ============

    struct DependencyNode {
        address contractAddr;
        NodeType nodeType;
        address[] dependencies;
        address[] dependents;
        uint256 riskScore;
    }

    enum NodeType {
        VAULT,
        LENDING_POOL,
        DEX,
        ORACLE,
        BRIDGE,
        STRATEGY,
        ROUTER,
        ADAPTER,
        GOVERNANCE,
        TOKEN,
        UNKNOWN
    }

    mapping(address => DependencyNode) public dependencyGraph;
    mapping(address => FunctionSignature[]) public functionMaps;
    address[] public analyzedContracts;

    // ============ COMPREHENSIVE SELECTOR DATABASE ============

    // Funds Movement Selectors
    bytes4[] public fundsMovementSelectors;

    // Oracle Selectors
    bytes4[] public oracleReadSelectors;
    bytes4[] public oracleWriteSelectors;

    // Share/Token Operations
    bytes4[] public shareMintBurnSelectors;

    // Bridge/Cross-chain
    bytes4[] public bridgeSelectors;

    // Index/Accounting Updates
    bytes4[] public indexUpdateSelectors;

    // Admin/Privileged
    bytes4[] public adminSelectors;

    // External Call Patterns
    bytes4[] public externalCallSelectors;

    // Callback Patterns
    bytes4[] public callbackSelectors;

    constructor() {
        _initializeSelectorDatabase();
    }

    function _initializeSelectorDatabase() internal {
        // === FUNDS MOVEMENT ===
        fundsMovementSelectors.push(bytes4(keccak256("deposit(uint256)")));
        fundsMovementSelectors.push(bytes4(keccak256("deposit(uint256,address)")));
        fundsMovementSelectors.push(bytes4(keccak256("deposit(address,uint256)")));
        fundsMovementSelectors.push(bytes4(keccak256("withdraw(uint256)")));
        fundsMovementSelectors.push(bytes4(keccak256("withdraw(uint256,address)")));
        fundsMovementSelectors.push(bytes4(keccak256("withdraw(uint256,address,address)")));
        fundsMovementSelectors.push(bytes4(keccak256("redeem(uint256)")));
        fundsMovementSelectors.push(bytes4(keccak256("redeem(uint256,address,address)")));
        fundsMovementSelectors.push(bytes4(keccak256("transfer(address,uint256)")));
        fundsMovementSelectors.push(bytes4(keccak256("transferFrom(address,address,uint256)")));
        fundsMovementSelectors.push(bytes4(keccak256("swap(uint256,uint256,address,bytes)")));
        fundsMovementSelectors.push(bytes4(keccak256("swap(address,address,uint256,uint256,address)")));
        fundsMovementSelectors.push(bytes4(keccak256("swapExactTokensForTokens(uint256,uint256,address[],address,uint256)")));
        fundsMovementSelectors.push(bytes4(keccak256("swapTokensForExactTokens(uint256,uint256,address[],address,uint256)")));
        fundsMovementSelectors.push(bytes4(keccak256("flash(address,uint256,uint256,bytes)")));
        fundsMovementSelectors.push(bytes4(keccak256("flashLoan(address,address,uint256,bytes)")));
        fundsMovementSelectors.push(bytes4(keccak256("flashLoan(address,address[],uint256[],uint256[],address,bytes,uint16)")));
        fundsMovementSelectors.push(bytes4(keccak256("borrow(uint256)")));
        fundsMovementSelectors.push(bytes4(keccak256("borrow(address,uint256,uint256,uint16,address)")));
        fundsMovementSelectors.push(bytes4(keccak256("repay(uint256)")));
        fundsMovementSelectors.push(bytes4(keccak256("repay(address,uint256,uint256,address)")));
        fundsMovementSelectors.push(bytes4(keccak256("liquidate(address,address,uint256)")));
        fundsMovementSelectors.push(bytes4(keccak256("liquidationCall(address,address,address,uint256,bool)")));
        fundsMovementSelectors.push(bytes4(keccak256("stake(uint256)")));
        fundsMovementSelectors.push(bytes4(keccak256("unstake(uint256)")));
        fundsMovementSelectors.push(bytes4(keccak256("claim(uint256)")));
        fundsMovementSelectors.push(bytes4(keccak256("claimRewards()")));
        fundsMovementSelectors.push(bytes4(keccak256("harvest()")));
        fundsMovementSelectors.push(bytes4(keccak256("compound()")));
        fundsMovementSelectors.push(bytes4(keccak256("emergencyWithdraw()")));
        fundsMovementSelectors.push(bytes4(keccak256("rescue(address,uint256)")));
        fundsMovementSelectors.push(bytes4(keccak256("sweep(address)")));
        fundsMovementSelectors.push(bytes4(keccak256("skim(address)")));
        fundsMovementSelectors.push(bytes4(keccak256("collect(address,int24,int24,uint128,uint128)")));

        // === ORACLE READ ===
        oracleReadSelectors.push(bytes4(keccak256("getPrice(address)")));
        oracleReadSelectors.push(bytes4(keccak256("getPrice()")));
        oracleReadSelectors.push(bytes4(keccak256("latestAnswer()")));
        oracleReadSelectors.push(bytes4(keccak256("latestRoundData()")));
        oracleReadSelectors.push(bytes4(keccak256("getRoundData(uint80)")));
        oracleReadSelectors.push(bytes4(keccak256("consult(address,uint256)")));
        oracleReadSelectors.push(bytes4(keccak256("getAmountOut(uint256,address,address)")));
        oracleReadSelectors.push(bytes4(keccak256("quote(uint256,address,address)")));
        oracleReadSelectors.push(bytes4(keccak256("peek()")));
        oracleReadSelectors.push(bytes4(keccak256("read()")));
        oracleReadSelectors.push(bytes4(keccak256("observe(uint32[])")));
        oracleReadSelectors.push(bytes4(keccak256("slot0()")));

        // === ORACLE WRITE ===
        oracleWriteSelectors.push(bytes4(keccak256("setPrice(uint256)")));
        oracleWriteSelectors.push(bytes4(keccak256("setPrice(address,uint256)")));
        oracleWriteSelectors.push(bytes4(keccak256("updatePrice(address,uint256)")));
        oracleWriteSelectors.push(bytes4(keccak256("push()")));
        oracleWriteSelectors.push(bytes4(keccak256("poke()")));
        oracleWriteSelectors.push(bytes4(keccak256("update()")));
        oracleWriteSelectors.push(bytes4(keccak256("update(address)")));

        // === SHARE/TOKEN MINT/BURN ===
        shareMintBurnSelectors.push(bytes4(keccak256("mint(address,uint256)")));
        shareMintBurnSelectors.push(bytes4(keccak256("mint(uint256)")));
        shareMintBurnSelectors.push(bytes4(keccak256("burn(uint256)")));
        shareMintBurnSelectors.push(bytes4(keccak256("burn(address,uint256)")));
        shareMintBurnSelectors.push(bytes4(keccak256("burnFrom(address,uint256)")));
        shareMintBurnSelectors.push(bytes4(keccak256("issue(address,uint256)")));
        shareMintBurnSelectors.push(bytes4(keccak256("destroy(address,uint256)")));

        // === BRIDGE/CROSS-CHAIN ===
        bridgeSelectors.push(bytes4(keccak256("bridge(uint256,address,uint256)")));
        bridgeSelectors.push(bytes4(keccak256("sendMessage(address,bytes)")));
        bridgeSelectors.push(bytes4(keccak256("relayMessage(address,address,bytes,uint256)")));
        bridgeSelectors.push(bytes4(keccak256("send(uint16,bytes,address,address,bytes)")));
        bridgeSelectors.push(bytes4(keccak256("sendFrom(address,uint16,bytes32,uint256,(address,address,bytes))")));
        bridgeSelectors.push(bytes4(keccak256("lzReceive(uint16,bytes,uint64,bytes)")));
        bridgeSelectors.push(bytes4(keccak256("sgReceive(uint16,bytes,uint256,address,uint256,bytes)")));
        bridgeSelectors.push(bytes4(keccak256("anyExecute(bytes)")));

        // === INDEX/ACCOUNTING UPDATES ===
        indexUpdateSelectors.push(bytes4(keccak256("updateIndex()")));
        indexUpdateSelectors.push(bytes4(keccak256("accrueInterest()")));
        indexUpdateSelectors.push(bytes4(keccak256("accrue()")));
        indexUpdateSelectors.push(bytes4(keccak256("sync()")));
        indexUpdateSelectors.push(bytes4(keccak256("rebase()")));
        indexUpdateSelectors.push(bytes4(keccak256("distribute()")));
        indexUpdateSelectors.push(bytes4(keccak256("updateAccounting()")));
        indexUpdateSelectors.push(bytes4(keccak256("checkpoint()")));
        indexUpdateSelectors.push(bytes4(keccak256("kick(address)")));

        // === ADMIN/PRIVILEGED ===
        adminSelectors.push(bytes4(keccak256("setOwner(address)")));
        adminSelectors.push(bytes4(keccak256("transferOwnership(address)")));
        adminSelectors.push(bytes4(keccak256("acceptOwnership()")));
        adminSelectors.push(bytes4(keccak256("renounceOwnership()")));
        adminSelectors.push(bytes4(keccak256("grantRole(bytes32,address)")));
        adminSelectors.push(bytes4(keccak256("revokeRole(bytes32,address)")));
        adminSelectors.push(bytes4(keccak256("setAdmin(address)")));
        adminSelectors.push(bytes4(keccak256("setGovernance(address)")));
        adminSelectors.push(bytes4(keccak256("setGuardian(address)")));
        adminSelectors.push(bytes4(keccak256("setOperator(address)")));
        adminSelectors.push(bytes4(keccak256("setKeeper(address)")));
        adminSelectors.push(bytes4(keccak256("setOracle(address)")));
        adminSelectors.push(bytes4(keccak256("setPriceFeed(address)")));
        adminSelectors.push(bytes4(keccak256("setTreasury(address)")));
        adminSelectors.push(bytes4(keccak256("setFeeRecipient(address)")));
        adminSelectors.push(bytes4(keccak256("setFee(uint256)")));
        adminSelectors.push(bytes4(keccak256("setFees(uint256,uint256)")));
        adminSelectors.push(bytes4(keccak256("pause()")));
        adminSelectors.push(bytes4(keccak256("unpause()")));
        adminSelectors.push(bytes4(keccak256("setPaused(bool)")));
        adminSelectors.push(bytes4(keccak256("upgradeTo(address)")));
        adminSelectors.push(bytes4(keccak256("upgradeToAndCall(address,bytes)")));
        adminSelectors.push(bytes4(keccak256("initialize()")));
        adminSelectors.push(bytes4(keccak256("initialize(address)")));
        adminSelectors.push(bytes4(keccak256("initialize(address,address)")));
        adminSelectors.push(bytes4(keccak256("init(bytes)")));
        adminSelectors.push(bytes4(keccak256("setup(bytes)")));

        // === EXTERNAL CALL PATTERNS ===
        externalCallSelectors.push(bytes4(keccak256("execute(address,bytes)")));
        externalCallSelectors.push(bytes4(keccak256("execute(address,uint256,bytes)")));
        externalCallSelectors.push(bytes4(keccak256("executeTransaction(address,uint256,string,bytes,uint256)")));
        externalCallSelectors.push(bytes4(keccak256("multicall(bytes[])")));
        externalCallSelectors.push(bytes4(keccak256("batch(bytes[],bool)")));
        externalCallSelectors.push(bytes4(keccak256("aggregate((address,bytes)[])")));
        externalCallSelectors.push(bytes4(keccak256("tryAggregate(bool,(address,bytes)[])")));

        // === CALLBACK PATTERNS ===
        callbackSelectors.push(bytes4(keccak256("onFlashLoan(address,address,uint256,uint256,bytes)")));
        callbackSelectors.push(bytes4(keccak256("uniswapV3SwapCallback(int256,int256,bytes)")));
        callbackSelectors.push(bytes4(keccak256("uniswapV3MintCallback(uint256,uint256,bytes)")));
        callbackSelectors.push(bytes4(keccak256("uniswapV3FlashCallback(uint256,uint256,bytes)")));
        callbackSelectors.push(bytes4(keccak256("pancakeV3SwapCallback(int256,int256,bytes)")));
        callbackSelectors.push(bytes4(keccak256("algebraSwapCallback(int256,int256,bytes)")));
        callbackSelectors.push(bytes4(keccak256("onERC721Received(address,address,uint256,bytes)")));
        callbackSelectors.push(bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)")));
        callbackSelectors.push(bytes4(keccak256("tokensReceived(address,address,address,uint256,bytes,bytes)")));
        callbackSelectors.push(bytes4(keccak256("receiveFlashLoan(address[],uint256[],uint256[],bytes)")));
    }

    // ============ ENUMERATION FUNCTIONS ============

    function enumerateAttackSurface(address target) external returns (FunctionSignature[] memory) {
        FunctionSignature[] memory discovered = new FunctionSignature[](200);
        uint256 count = 0;

        // Probe all selector categories
        count = _probeCategory(target, fundsMovementSelectors, discovered, count, FunctionRisk.CRITICAL, true);
        count = _probeCategory(target, oracleReadSelectors, discovered, count, FunctionRisk.MEDIUM, false);
        count = _probeCategory(target, oracleWriteSelectors, discovered, count, FunctionRisk.HIGH, true);
        count = _probeCategory(target, shareMintBurnSelectors, discovered, count, FunctionRisk.CRITICAL, true);
        count = _probeCategory(target, bridgeSelectors, discovered, count, FunctionRisk.CRITICAL, true);
        count = _probeCategory(target, indexUpdateSelectors, discovered, count, FunctionRisk.MEDIUM, true);
        count = _probeCategory(target, adminSelectors, discovered, count, FunctionRisk.CRITICAL, true);
        count = _probeCategory(target, externalCallSelectors, discovered, count, FunctionRisk.CRITICAL, true);
        count = _probeCategory(target, callbackSelectors, discovered, count, FunctionRisk.HIGH, false);

        // Resize array to actual count
        FunctionSignature[] memory result = new FunctionSignature[](count);
        for (uint256 i = 0; i < count; i++) {
            result[i] = discovered[i];
            functionMaps[target].push(discovered[i]);
        }

        analyzedContracts.push(target);
        return result;
    }

    function _probeCategory(
        address target,
        bytes4[] storage selectors,
        FunctionSignature[] memory discovered,
        uint256 startIndex,
        FunctionRisk risk,
        bool modifiesState
    ) internal view returns (uint256 newIndex) {
        newIndex = startIndex;

        for (uint256 i = 0; i < selectors.length && newIndex < discovered.length; i++) {
            (bool exists, bool payable_) = _probeSelector(target, selectors[i]);
            if (exists) {
                discovered[newIndex] = FunctionSignature({
                    selector: selectors[i],
                    name: "", // Would need ABI lookup
                    risk: risk,
                    payable_: payable_,
                    hasExternalCall: _checkForExternalCall(target, selectors[i]),
                    modifiesState: modifiesState,
                    touchesFunds: risk == FunctionRisk.CRITICAL
                });
                newIndex++;
            }
        }
    }

    function _probeSelector(address target, bytes4 selector) internal view returns (bool exists, bool payable_) {
        // Try staticcall first (for view/pure functions)
        (bool successStatic,) = target.staticcall(abi.encodeWithSelector(selector));

        // Try regular call with 0 value to check if it exists
        // Note: This is view-only, actual call would need to be in a different context
        exists = successStatic || target.code.length > 0;

        // Check if payable by looking for value parameter handling
        payable_ = false; // Would need more sophisticated analysis
    }

    function _checkForExternalCall(address target, bytes4 selector) internal view returns (bool) {
        // Simplified check - would need bytecode analysis for accuracy
        // Look for CALL/DELEGATECALL/STATICCALL opcodes after this selector
        return false;
    }

    // ============ DEPENDENCY GRAPH BUILDING ============

    function buildDependencyGraph(address[] calldata contracts) external {
        for (uint256 i = 0; i < contracts.length; i++) {
            _analyzeContractDependencies(contracts[i]);
        }

        // Build reverse dependencies
        for (uint256 i = 0; i < contracts.length; i++) {
            DependencyNode storage node = dependencyGraph[contracts[i]];
            for (uint256 j = 0; j < node.dependencies.length; j++) {
                dependencyGraph[node.dependencies[j]].dependents.push(contracts[i]);
            }
        }
    }

    function _analyzeContractDependencies(address target) internal {
        DependencyNode storage node = dependencyGraph[target];
        node.contractAddr = target;
        node.nodeType = _classifyContractType(target);

        // Find dependencies by probing common getter patterns
        address[] memory potentialDeps = _findPotentialDependencies(target);
        for (uint256 i = 0; i < potentialDeps.length; i++) {
            if (potentialDeps[i] != address(0) && potentialDeps[i].code.length > 0) {
                node.dependencies.push(potentialDeps[i]);
            }
        }

        // Calculate risk score based on type and dependencies
        node.riskScore = _calculateRiskScore(target, node.nodeType, node.dependencies.length);
    }

    function _classifyContractType(address target) internal view returns (NodeType) {
        // Try to identify contract type by probing selectors

        // Vault patterns
        if (_hasSelector(target, bytes4(keccak256("deposit(uint256,address)"))) &&
            _hasSelector(target, bytes4(keccak256("withdraw(uint256,address,address)")))) {
            return NodeType.VAULT;
        }

        // Lending pool patterns
        if (_hasSelector(target, bytes4(keccak256("borrow(address,uint256,uint256,uint16,address)"))) ||
            _hasSelector(target, bytes4(keccak256("liquidationCall(address,address,address,uint256,bool)")))) {
            return NodeType.LENDING_POOL;
        }

        // DEX patterns
        if (_hasSelector(target, bytes4(keccak256("swap(uint256,uint256,address,bytes)"))) ||
            _hasSelector(target, bytes4(keccak256("getReserves()")))) {
            return NodeType.DEX;
        }

        // Oracle patterns
        if (_hasSelector(target, bytes4(keccak256("latestAnswer()"))) ||
            _hasSelector(target, bytes4(keccak256("latestRoundData()")))) {
            return NodeType.ORACLE;
        }

        // Bridge patterns
        if (_hasSelector(target, bytes4(keccak256("lzReceive(uint16,bytes,uint64,bytes)"))) ||
            _hasSelector(target, bytes4(keccak256("relayMessage(address,address,bytes,uint256)")))) {
            return NodeType.BRIDGE;
        }

        // Router patterns
        if (_hasSelector(target, bytes4(keccak256("swapExactTokensForTokens(uint256,uint256,address[],address,uint256)")))) {
            return NodeType.ROUTER;
        }

        // Token patterns
        if (_hasSelector(target, bytes4(keccak256("transfer(address,uint256)"))) &&
            _hasSelector(target, bytes4(keccak256("balanceOf(address)")))) {
            return NodeType.TOKEN;
        }

        return NodeType.UNKNOWN;
    }

    function _hasSelector(address target, bytes4 selector) internal view returns (bool) {
        (bool success,) = target.staticcall(abi.encodeWithSelector(selector));
        return success;
    }

    function _findPotentialDependencies(address target) internal view returns (address[] memory) {
        address[] memory deps = new address[](20);
        uint256 count = 0;

        // Probe common dependency getters
        bytes4[] memory depGetters = new bytes4[](15);
        depGetters[0] = bytes4(keccak256("oracle()"));
        depGetters[1] = bytes4(keccak256("priceFeed()"));
        depGetters[2] = bytes4(keccak256("token()"));
        depGetters[3] = bytes4(keccak256("asset()"));
        depGetters[4] = bytes4(keccak256("underlying()"));
        depGetters[5] = bytes4(keccak256("pool()"));
        depGetters[6] = bytes4(keccak256("router()"));
        depGetters[7] = bytes4(keccak256("factory()"));
        depGetters[8] = bytes4(keccak256("vault()"));
        depGetters[9] = bytes4(keccak256("strategy()"));
        depGetters[10] = bytes4(keccak256("treasury()"));
        depGetters[11] = bytes4(keccak256("governance()"));
        depGetters[12] = bytes4(keccak256("admin()"));
        depGetters[13] = bytes4(keccak256("owner()"));
        depGetters[14] = bytes4(keccak256("implementation()"));

        for (uint256 i = 0; i < depGetters.length && count < deps.length; i++) {
            (bool success, bytes memory result) = target.staticcall(abi.encodeWithSelector(depGetters[i]));
            if (success && result.length >= 32) {
                address dep = abi.decode(result, (address));
                if (dep != address(0) && dep != target) {
                    deps[count++] = dep;
                }
            }
        }

        // Resize
        address[] memory finalDeps = new address[](count);
        for (uint256 i = 0; i < count; i++) {
            finalDeps[i] = deps[i];
        }
        return finalDeps;
    }

    function _calculateRiskScore(
        address target,
        NodeType nodeType,
        uint256 depCount
    ) internal view returns (uint256) {
        uint256 baseScore;

        if (nodeType == NodeType.VAULT || nodeType == NodeType.LENDING_POOL) {
            baseScore = 100;
        } else if (nodeType == NodeType.DEX || nodeType == NodeType.BRIDGE) {
            baseScore = 90;
        } else if (nodeType == NodeType.ORACLE) {
            baseScore = 80;
        } else if (nodeType == NodeType.ROUTER || nodeType == NodeType.ADAPTER) {
            baseScore = 70;
        } else {
            baseScore = 50;
        }

        // Increase score based on dependencies (more deps = more attack surface)
        return baseScore + (depCount * 5);
    }

    // ============ REPORTING ============

    function getHighRiskFunctions(address target) external view returns (FunctionSignature[] memory) {
        FunctionSignature[] storage all = functionMaps[target];
        uint256 highRiskCount = 0;

        for (uint256 i = 0; i < all.length; i++) {
            if (all[i].risk == FunctionRisk.CRITICAL || all[i].risk == FunctionRisk.HIGH) {
                highRiskCount++;
            }
        }

        FunctionSignature[] memory result = new FunctionSignature[](highRiskCount);
        uint256 j = 0;
        for (uint256 i = 0; i < all.length; i++) {
            if (all[i].risk == FunctionRisk.CRITICAL || all[i].risk == FunctionRisk.HIGH) {
                result[j++] = all[i];
            }
        }
        return result;
    }

    function getWeakLinks() external view returns (address[] memory) {
        // Find contracts with high risk scores that are dependencies of many others
        address[] memory weakLinks = new address[](analyzedContracts.length);
        uint256 count = 0;

        for (uint256 i = 0; i < analyzedContracts.length; i++) {
            DependencyNode storage node = dependencyGraph[analyzedContracts[i]];
            if (node.dependents.length >= 2 && node.riskScore >= 80) {
                weakLinks[count++] = analyzedContracts[i];
            }
        }

        // Resize
        address[] memory result = new address[](count);
        for (uint256 i = 0; i < count; i++) {
            result[i] = weakLinks[i];
        }
        return result;
    }

    function printDependencyGraph(address target) external view {
        DependencyNode storage node = dependencyGraph[target];
        console.log("=== Dependency Graph for", target, "===");
        console.log("Type:", uint256(node.nodeType));
        console.log("Risk Score:", node.riskScore);
        console.log("Dependencies:", node.dependencies.length);
        for (uint256 i = 0; i < node.dependencies.length; i++) {
            console.log("  ->", node.dependencies[i]);
        }
        console.log("Dependents:", node.dependents.length);
        for (uint256 i = 0; i < node.dependents.length; i++) {
            console.log("  <-", node.dependents[i]);
        }
    }
}
