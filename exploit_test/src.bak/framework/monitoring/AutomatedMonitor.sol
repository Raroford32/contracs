// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title AutomatedMonitor
 * @notice Real-time monitoring for anomaly detection
 * @dev Monitors supply changes, price deviations, reentrancy patterns
 */
contract AutomatedMonitor is Test {

    // ============ EVENTS ============

    event AnomalyDetected(
        address indexed target,
        AnomalyType anomalyType,
        uint256 severity,
        string description
    );

    event CircuitBreakerTriggered(
        address indexed target,
        string reason
    );

    event InvariantViolation(
        address indexed target,
        string invariantName,
        uint256 expected,
        uint256 actual
    );

    // ============ ENUMS ============

    enum AnomalyType {
        SUPPLY_SPIKE,
        SUPPLY_DRAIN,
        PRICE_DEVIATION,
        ORACLE_STALE,
        REENTRANCY_DETECTED,
        UNUSUAL_MINT,
        UNUSUAL_BURN,
        ASSET_OUTFLOW,
        FLASH_LOAN_ACTIVITY,
        GOVERNANCE_CHANGE
    }

    enum Severity {
        INFO,
        LOW,
        MEDIUM,
        HIGH,
        CRITICAL
    }

    // ============ STRUCTS ============

    struct MonitoringConfig {
        uint256 maxSupplyChangePercent;      // Max allowed supply change per block (bps)
        uint256 maxPriceDeviationPercent;    // Max price deviation from TWAP (bps)
        uint256 maxOracleStaleness;          // Max oracle staleness (seconds)
        uint256 maxAssetOutflowPercent;      // Max asset outflow per tx (bps)
        uint256 reentrancyThreshold;         // Max reentrancy depth allowed
        bool circuitBreakerEnabled;
    }

    struct ContractState {
        uint256 totalSupply;
        uint256 totalAssets;
        uint256 sharePrice;
        uint256 lastUpdateBlock;
        uint256 lastUpdateTime;
        uint256 oraclePrice;
        uint256 spotPrice;
    }

    struct Anomaly {
        address target;
        AnomalyType anomalyType;
        uint256 severity;
        uint256 timestamp;
        uint256 blockNumber;
        string description;
        bytes context;
    }

    // ============ STATE ============

    mapping(address => MonitoringConfig) public configs;
    mapping(address => ContractState) public previousStates;
    mapping(address => ContractState) public currentStates;
    mapping(address => bool) public circuitBreakerActive;

    Anomaly[] public anomalies;
    uint256 public totalAnomalies;

    // Default thresholds
    uint256 constant DEFAULT_MAX_SUPPLY_CHANGE = 1000;    // 10%
    uint256 constant DEFAULT_MAX_PRICE_DEVIATION = 500;   // 5%
    uint256 constant DEFAULT_MAX_ORACLE_STALENESS = 3600; // 1 hour
    uint256 constant DEFAULT_MAX_OUTFLOW = 2000;          // 20%
    uint256 constant DEFAULT_REENTRANCY_THRESHOLD = 1;

    // ============ CONFIGURATION ============

    function configureMonitoring(
        address target,
        MonitoringConfig memory config
    ) public {
        configs[target] = config;
    }

    function setDefaultConfig(address target) public {
        configs[target] = MonitoringConfig({
            maxSupplyChangePercent: DEFAULT_MAX_SUPPLY_CHANGE,
            maxPriceDeviationPercent: DEFAULT_MAX_PRICE_DEVIATION,
            maxOracleStaleness: DEFAULT_MAX_ORACLE_STALENESS,
            maxAssetOutflowPercent: DEFAULT_MAX_OUTFLOW,
            reentrancyThreshold: DEFAULT_REENTRANCY_THRESHOLD,
            circuitBreakerEnabled: true
        });
    }

    // ============ MONITORING FUNCTIONS ============

    function monitor(address target) public returns (Anomaly[] memory detected) {
        // Capture current state
        _captureState(target);

        // Run all checks
        Anomaly[] memory tempAnomalies = new Anomaly[](10);
        uint256 count = 0;

        // Check supply anomalies
        (bool supplyAnomaly, Anomaly memory supplyA) = checkSupplyAnomaly(target);
        if (supplyAnomaly) {
            tempAnomalies[count++] = supplyA;
        }

        // Check price deviation
        (bool priceAnomaly, Anomaly memory priceA) = checkPriceDeviation(target);
        if (priceAnomaly) {
            tempAnomalies[count++] = priceA;
        }

        // Check oracle staleness
        (bool oracleAnomaly, Anomaly memory oracleA) = checkOracleStaleness(target);
        if (oracleAnomaly) {
            tempAnomalies[count++] = oracleA;
        }

        // Check asset outflow
        (bool outflowAnomaly, Anomaly memory outflowA) = checkAssetOutflow(target);
        if (outflowAnomaly) {
            tempAnomalies[count++] = outflowA;
        }

        // Check for unusual mint/burn
        (bool mintBurnAnomaly, Anomaly memory mintBurnA) = checkMintBurnAnomaly(target);
        if (mintBurnAnomaly) {
            tempAnomalies[count++] = mintBurnA;
        }

        // Store detected anomalies
        detected = new Anomaly[](count);
        for (uint256 i = 0; i < count; i++) {
            detected[i] = tempAnomalies[i];
            anomalies.push(tempAnomalies[i]);
            totalAnomalies++;

            emit AnomalyDetected(
                detected[i].target,
                detected[i].anomalyType,
                detected[i].severity,
                detected[i].description
            );

            // Trigger circuit breaker for critical anomalies
            if (detected[i].severity >= uint256(Severity.CRITICAL) &&
                configs[target].circuitBreakerEnabled) {
                _triggerCircuitBreaker(target, detected[i].description);
            }
        }

        // Update previous state
        previousStates[target] = currentStates[target];
    }

    function _captureState(address target) internal {
        ContractState storage state = currentStates[target];
        state.lastUpdateBlock = block.number;
        state.lastUpdateTime = block.timestamp;

        // Try to get total supply
        try IERC20Like(target).totalSupply() returns (uint256 supply) {
            state.totalSupply = supply;
        } catch {}

        // Try to get total assets (for vaults)
        try IVaultLike(target).totalAssets() returns (uint256 assets) {
            state.totalAssets = assets;
        } catch {}

        // Try to get share price
        try IVaultLike(target).pricePerShare() returns (uint256 price) {
            state.sharePrice = price;
        } catch {
            try IVaultLike(target).convertToAssets(1e18) returns (uint256 price) {
                state.sharePrice = price;
            } catch {}
        }

        // Try to get oracle price
        try IOracleLike(target).latestAnswer() returns (int256 price) {
            state.oraclePrice = price > 0 ? uint256(price) : 0;
        } catch {}
    }

    // ============ ANOMALY CHECKS ============

    function checkSupplyAnomaly(address target) public view returns (bool detected, Anomaly memory anomaly) {
        ContractState storage prev = previousStates[target];
        ContractState storage curr = currentStates[target];

        if (prev.totalSupply == 0) return (false, anomaly);

        uint256 changePercent;
        bool isIncrease;

        if (curr.totalSupply > prev.totalSupply) {
            changePercent = ((curr.totalSupply - prev.totalSupply) * 10000) / prev.totalSupply;
            isIncrease = true;
        } else {
            changePercent = ((prev.totalSupply - curr.totalSupply) * 10000) / prev.totalSupply;
            isIncrease = false;
        }

        if (changePercent > configs[target].maxSupplyChangePercent) {
            detected = true;
            anomaly = Anomaly({
                target: target,
                anomalyType: isIncrease ? AnomalyType.SUPPLY_SPIKE : AnomalyType.SUPPLY_DRAIN,
                severity: changePercent > 5000 ? uint256(Severity.CRITICAL) : uint256(Severity.HIGH),
                timestamp: block.timestamp,
                blockNumber: block.number,
                description: isIncrease ? "Abnormal supply increase" : "Abnormal supply decrease",
                context: abi.encode(prev.totalSupply, curr.totalSupply, changePercent)
            });
        }
    }

    function checkPriceDeviation(address target) public view returns (bool detected, Anomaly memory anomaly) {
        ContractState storage prev = previousStates[target];
        ContractState storage curr = currentStates[target];

        if (prev.sharePrice == 0 || curr.sharePrice == 0) return (false, anomaly);

        uint256 deviationPercent;
        if (curr.sharePrice > prev.sharePrice) {
            deviationPercent = ((curr.sharePrice - prev.sharePrice) * 10000) / prev.sharePrice;
        } else {
            deviationPercent = ((prev.sharePrice - curr.sharePrice) * 10000) / prev.sharePrice;
        }

        if (deviationPercent > configs[target].maxPriceDeviationPercent) {
            detected = true;
            anomaly = Anomaly({
                target: target,
                anomalyType: AnomalyType.PRICE_DEVIATION,
                severity: deviationPercent > 2000 ? uint256(Severity.CRITICAL) : uint256(Severity.HIGH),
                timestamp: block.timestamp,
                blockNumber: block.number,
                description: "Abnormal price deviation detected",
                context: abi.encode(prev.sharePrice, curr.sharePrice, deviationPercent)
            });
        }
    }

    function checkOracleStaleness(address target) public view returns (bool detected, Anomaly memory anomaly) {
        ContractState storage curr = currentStates[target];

        if (curr.oraclePrice == 0) return (false, anomaly);

        // Would need actual oracle update time - simplified check
        if (curr.lastUpdateTime > 0 &&
            block.timestamp - curr.lastUpdateTime > configs[target].maxOracleStaleness) {
            detected = true;
            anomaly = Anomaly({
                target: target,
                anomalyType: AnomalyType.ORACLE_STALE,
                severity: uint256(Severity.HIGH),
                timestamp: block.timestamp,
                blockNumber: block.number,
                description: "Oracle price is stale",
                context: abi.encode(curr.lastUpdateTime, block.timestamp)
            });
        }
    }

    function checkAssetOutflow(address target) public view returns (bool detected, Anomaly memory anomaly) {
        ContractState storage prev = previousStates[target];
        ContractState storage curr = currentStates[target];

        if (prev.totalAssets == 0) return (false, anomaly);

        if (curr.totalAssets < prev.totalAssets) {
            uint256 outflowPercent = ((prev.totalAssets - curr.totalAssets) * 10000) / prev.totalAssets;

            if (outflowPercent > configs[target].maxAssetOutflowPercent) {
                detected = true;
                anomaly = Anomaly({
                    target: target,
                    anomalyType: AnomalyType.ASSET_OUTFLOW,
                    severity: outflowPercent > 5000 ? uint256(Severity.CRITICAL) : uint256(Severity.HIGH),
                    timestamp: block.timestamp,
                    blockNumber: block.number,
                    description: "Large asset outflow detected",
                    context: abi.encode(prev.totalAssets, curr.totalAssets, outflowPercent)
                });
            }
        }
    }

    function checkMintBurnAnomaly(address target) public view returns (bool detected, Anomaly memory anomaly) {
        ContractState storage prev = previousStates[target];
        ContractState storage curr = currentStates[target];

        // Check for mint without corresponding asset increase
        if (curr.totalSupply > prev.totalSupply && curr.totalAssets <= prev.totalAssets) {
            detected = true;
            anomaly = Anomaly({
                target: target,
                anomalyType: AnomalyType.UNUSUAL_MINT,
                severity: uint256(Severity.CRITICAL),
                timestamp: block.timestamp,
                blockNumber: block.number,
                description: "Mint without asset backing",
                context: abi.encode(prev.totalSupply, curr.totalSupply, prev.totalAssets, curr.totalAssets)
            });
        }

        // Check for burn without corresponding asset decrease
        if (curr.totalSupply < prev.totalSupply && curr.totalAssets >= prev.totalAssets) {
            detected = true;
            anomaly = Anomaly({
                target: target,
                anomalyType: AnomalyType.UNUSUAL_BURN,
                severity: uint256(Severity.HIGH),
                timestamp: block.timestamp,
                blockNumber: block.number,
                description: "Burn without asset release",
                context: abi.encode(prev.totalSupply, curr.totalSupply, prev.totalAssets, curr.totalAssets)
            });
        }
    }

    // ============ CIRCUIT BREAKER ============

    function _triggerCircuitBreaker(address target, string memory reason) internal {
        circuitBreakerActive[target] = true;
        emit CircuitBreakerTriggered(target, reason);
    }

    function resetCircuitBreaker(address target) external {
        circuitBreakerActive[target] = false;
    }

    function isCircuitBreakerActive(address target) external view returns (bool) {
        return circuitBreakerActive[target];
    }

    // ============ REENTRANCY MONITORING ============

    mapping(address => uint256) public reentrancyDepth;
    mapping(address => uint256) public maxReentrancyDepth;

    function trackReentrancy(address target) public returns (bool suspicious) {
        reentrancyDepth[target]++;

        if (reentrancyDepth[target] > maxReentrancyDepth[target]) {
            maxReentrancyDepth[target] = reentrancyDepth[target];
        }

        if (reentrancyDepth[target] > configs[target].reentrancyThreshold) {
            suspicious = true;

            anomalies.push(Anomaly({
                target: target,
                anomalyType: AnomalyType.REENTRANCY_DETECTED,
                severity: uint256(Severity.CRITICAL),
                timestamp: block.timestamp,
                blockNumber: block.number,
                description: "Reentrancy pattern detected",
                context: abi.encode(reentrancyDepth[target])
            }));

            emit AnomalyDetected(
                target,
                AnomalyType.REENTRANCY_DETECTED,
                uint256(Severity.CRITICAL),
                "Reentrancy pattern detected"
            );
        }
    }

    function exitReentrancy(address target) public {
        if (reentrancyDepth[target] > 0) {
            reentrancyDepth[target]--;
        }
    }

    // ============ REPORTING ============

    function getAnomalies(address target) public view returns (Anomaly[] memory) {
        uint256 count = 0;
        for (uint256 i = 0; i < anomalies.length; i++) {
            if (anomalies[i].target == target) count++;
        }

        Anomaly[] memory result = new Anomaly[](count);
        uint256 j = 0;
        for (uint256 i = 0; i < anomalies.length; i++) {
            if (anomalies[i].target == target) {
                result[j++] = anomalies[i];
            }
        }
        return result;
    }

    function getCriticalAnomalies() public view returns (Anomaly[] memory) {
        uint256 count = 0;
        for (uint256 i = 0; i < anomalies.length; i++) {
            if (anomalies[i].severity >= uint256(Severity.CRITICAL)) count++;
        }

        Anomaly[] memory result = new Anomaly[](count);
        uint256 j = 0;
        for (uint256 i = 0; i < anomalies.length; i++) {
            if (anomalies[i].severity >= uint256(Severity.CRITICAL)) {
                result[j++] = anomalies[i];
            }
        }
        return result;
    }

    function printMonitoringReport(address target) public view {
        console.log("=== Monitoring Report ===");
        console.log("Target:", target);
        console.log("Circuit Breaker Active:", circuitBreakerActive[target]);
        console.log("Max Reentrancy Depth:", maxReentrancyDepth[target]);

        console.log("Current State:");
        console.log("  Total Supply:", currentStates[target].totalSupply);
        console.log("  Total Assets:", currentStates[target].totalAssets);
        console.log("  Share Price:", currentStates[target].sharePrice);

        Anomaly[] memory targetAnomalies = getAnomalies(target);
        console.log("Anomalies Detected:", targetAnomalies.length);

        for (uint256 i = 0; i < targetAnomalies.length; i++) {
            console.log("---");
            console.log("Type:", uint256(targetAnomalies[i].anomalyType));
            console.log("Severity:", targetAnomalies[i].severity);
            console.log("Description:", targetAnomalies[i].description);
            console.log("Block:", targetAnomalies[i].blockNumber);
        }
    }
}

// ============ INTERFACES ============

interface IERC20Like {
    function totalSupply() external view returns (uint256);
    function balanceOf(address) external view returns (uint256);
}

interface IVaultLike {
    function totalAssets() external view returns (uint256);
    function pricePerShare() external view returns (uint256);
    function convertToAssets(uint256) external view returns (uint256);
}

interface IOracleLike {
    function latestAnswer() external view returns (int256);
    function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80);
}
