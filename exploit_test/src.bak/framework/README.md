# Novel Unprivileged Vulnerability Discovery Framework

A comprehensive, process-based system for discovering novel vulnerabilities at scale in Solidity/EVM protocols. Specialized in access control, privilege escalation, and emergent multi-step takeovers that do not resemble known patterns.

## Architecture

```
src/framework/
├── VulnDiscoveryFramework.sol     # Core infrastructure and base test
├── VulnDiscoveryOrchestrator.sol  # Master orchestration
├── enumeration/
│   └── AttackSurfaceEnumerator.sol # Systematic function mapping
├── invariants/
│   └── InvariantSecurityModel.sol  # Protocol invariant definitions
├── adversarial/
│   └── AdversarialInputGenerator.sol # Malicious input generation
├── oracle/
│   └── OracleSecurityChecker.sol   # Oracle manipulation detection
├── reentrancy/
│   └── ReentrancyDetector.sol      # Reentrancy vulnerability detection
├── arithmetic/
│   └── ArithmeticPrecisionAudit.sol # Rounding/precision exploits
├── monitoring/
│   └── AutomatedMonitor.sol        # Real-time anomaly detection
└── utils/
    └── EtherscanFetcher.sol        # Contract data utilities
```

## Quick Start

### 1. Single Contract Analysis

```solidity
// In your test file
import "../src/framework/VulnDiscoveryOrchestrator.sol";

contract MyTest is Test {
    VulnDiscoveryOrchestrator orchestrator;

    function setUp() public {
        orchestrator = new VulnDiscoveryOrchestrator();
    }

    function test_analyze() public {
        address target = 0x...; // Your target
        VulnDiscoveryOrchestrator.FullAnalysis memory analysis =
            orchestrator.analyzeContract(target);

        // Check results
        if (analysis.criticalCount > 0) {
            // Critical vulnerabilities found!
        }
    }
}
```

### 2. Run with Mainnet Fork

```bash
# Quick analysis
forge test --match-contract VulnDiscoveryTest --fork-url $ETH_RPC_URL -vvv

# Deep fuzzing
FOUNDRY_PROFILE=deep forge test --match-test test_fuzzInvariants --fork-url $ETH_RPC_URL -vvvv
```

### 3. Batch Analysis

```solidity
address[] memory targets = new address[](10);
// ... populate targets from contracts.txt

VulnDiscoveryOrchestrator.FullAnalysis[] memory results =
    orchestrator.batchAnalyze(targets);
```

## Module Documentation

### 1. Attack Surface Enumeration (`AttackSurfaceEnumerator.sol`)

Maps every externally callable function and classifies by risk:

- **CRITICAL**: Direct fund access, admin control, upgrades
- **HIGH**: Price manipulation, share minting, oracle writes
- **MEDIUM**: State modification, index updates
- **LOW**: View functions, getters

```solidity
FunctionSignature[] memory functions = enumerator.enumerateAttackSurface(target);

// Build dependency graph
address[] memory contracts = new address[](10);
enumerator.buildDependencyGraph(contracts);

// Find weak links
address[] memory weakLinks = enumerator.getWeakLinks();
```

**Function Categories Detected:**
- Funds movement (deposit, withdraw, swap, flash)
- Oracle operations (read/write)
- Share/token mint/burn
- Bridge/cross-chain
- Index/accounting updates
- Admin/privileged operations
- External call patterns (execute, multicall)
- Callbacks (flash loans, token hooks)

### 2. Invariant Security Model (`InvariantSecurityModel.sol`)

Defines and checks protocol-specific invariants:

**Vault Invariants:**
- INV-V1: `totalAssets >= totalSupply * pricePerShare`
- INV-V2: Share price monotonically non-decreasing

**Lending Invariants:**
- INV-L1: `borrowValue <= collateralValue * LTV`
- INV-L2: `healthFactor >= 1` for non-liquidatable positions

**DEX/AMM Invariants:**
- INV-D1: Constant product `k` should not decrease
- INV-D2: LP supply proportional to sqrt(reserves)

**Staking Invariants:**
- INV-S1: Total claimable <= rewards balance
- INV-S2: Sum of stakes == total staked

**General Invariants:**
- INV-G1: No free mint (claimable increase requires cost)
- INV-G2: No double claim

```solidity
// Check vault conservation
(bool valid, int256 diff) = invariant_vault_conservation(vault, asset);

// Get report
(uint256 checks, uint256 violations, bytes32[] memory violated) =
    getInvariantReport();
```

### 3. Adversarial Input Generator (`AdversarialInputGenerator.sol`)

Generates malicious inputs for comprehensive testing:

**Adversarial Amounts:**
- Zero and dust (0, 1, 2)
- Boundaries (uint256.max, uint128.max, uint96.max)
- Decimal boundaries (1e6-1, 1e18-1)
- Flash loan scale (1M ETH, 100M USDC)
- Rounding triggers

**Malicious Swap Data:**
- Invalid selectors
- Max amounts
- Callback injection
- Large calldata (DoS)
- Self-referential calls

**Flash Loan Sequences:**
- Simple exploit patterns
- Price manipulation + liquidation
- Reentrancy during callback
- Multi-token arbitrage
- Share price inflation

```solidity
// Generate amounts
AmountSet memory amounts = adversarial.generateAdversarialAmounts();

// Generate swap data
SwapDataSet memory swapData = adversarial.generateMaliciousSwapData(token, attacker);

// Deploy attacker contracts
address router = adversarial.deployMaliciousRouter();
address oracle = adversarial.deployMaliciousOracle(manipulatedPrice);
```

### 4. Oracle Security Checker (`OracleSecurityChecker.sol`)

Comprehensive oracle vulnerability detection:

**Checks:**
- Staleness (configurable threshold)
- Manipulability (liquidity-based)
- Deviation from spot price
- Single-block manipulation possibility
- Decimal mismatch

**Oracle Types Detected:**
- Chainlink
- Uniswap V2 TWAP
- Uniswap V3 TWAP
- Curve
- Custom spot/TWAP

```solidity
OracleAnalysis memory analysis = oracleChecker.analyzeOracle(oracle, token);

// Check specific vulnerabilities
if (analysis.isManipulable) {
    // Manipulation cost: analysis.manipulationCost
}
if (analysis.isStale) {
    // Last update: analysis.lastUpdateTime
}

// Get hardening recommendations
string[] memory recs = oracleChecker.getHardeningRecommendations(oracle);
```

### 5. Reentrancy Detector (`ReentrancyDetector.sol`)

Dynamic reentrancy analysis:

**Vectors Tested:**
- ETH reentrancy (receive/fallback)
- ERC777 hooks (tokensReceived)
- ERC721 callbacks (onERC721Received)
- ERC1155 callbacks (onERC1155Received)
- Flash loan callbacks

**Checks:**
- Presence of reentrancy guard
- CEI pattern violation
- Maximum reentry depth

```solidity
ReentrancyAnalysis memory analysis =
    reentrancyDetector.analyzeReentrancy(target, selector);

if (!analysis.hasReentrancyGuard && analysis.hasExternalCallBeforeStateUpdate) {
    // VULNERABLE!
}

// Check specific vectors
if (analysis.exploitableViaETH) { /* ETH reentrancy */ }
if (analysis.exploitableViaERC777) { /* ERC777 hook */ }
```

### 6. Arithmetic Precision Audit (`ArithmeticPrecisionAudit.sol`)

Detects precision and arithmetic vulnerabilities:

**Vulnerabilities Detected:**
- Rounding exploits
- First depositor/share inflation
- Overflow/underflow risks
- Precision drift over iterations
- Mixed decimal handling

```solidity
uint256[] memory testAmounts = generateAdversarialAmounts();
PrecisionAnalysis memory analysis =
    arithmeticAudit.analyzePrecision(target, selector, testAmounts);

if (analysis.hasRoundingVuln) {
    // Profit potential: analysis.roundingProfit
}
if (analysis.hasPrecisionDrift) {
    // Iterations to exploit: analysis.iterationsToExploit
}

// Specific attack tests
(bool vulnerable, uint256 profit) = testShareInflationAttack(vault);
```

### 7. Automated Monitor (`AutomatedMonitor.sol`)

Real-time anomaly detection:

**Anomaly Types:**
- Supply spike/drain
- Price deviation
- Oracle staleness
- Reentrancy patterns
- Unusual mint/burn
- Large asset outflow
- Flash loan activity

**Features:**
- Configurable thresholds
- Circuit breaker support
- Reentrancy depth tracking

```solidity
// Configure
monitor.setDefaultConfig(target);

// Run monitoring
Anomaly[] memory anomalies = monitor.monitor(target);

// Check for critical issues
Anomaly[] memory critical = monitor.getCriticalAnomalies();

// Circuit breaker
if (monitor.isCircuitBreakerActive(target)) {
    // Emergency!
}
```

## Running Tests

### Profiles

```bash
# Quick (development)
FOUNDRY_PROFILE=quick forge test

# Default (balanced)
forge test

# Fuzz (extended fuzzing)
FOUNDRY_PROFILE=fuzz forge test

# Deep (comprehensive)
FOUNDRY_PROFILE=deep forge test
```

### Fork Testing

```bash
# Mainnet
forge test --fork-url https://mainnet.infura.io/v3/YOUR_KEY -vvv

# BSC
FOUNDRY_PROFILE=bsc forge test -vvv

# Specific block
forge test --fork-url $RPC --fork-block-number 19000000
```

### Specific Tests

```bash
# Single contract
TARGET=0x... forge test --match-test test_quickExploit

# Batch analysis
forge test --match-test test_batchAnalyze

# Invariant fuzzing
forge test --match-test test_fuzzInvariants
```

## Output Format

### Analysis Summary
```
========================================
       ANALYSIS SUMMARY
========================================
Target: 0x...
Block: 19000000

ATTACK SURFACE:
  Total Functions: 45
  Critical Functions: 8
  High-Risk Functions: 12

VULNERABILITIES:
  Critical: 2
  High: 3
  Medium: 1
  Low: 0

SPECIFIC FINDINGS:
  Oracle Vulnerable: true
  Reentrancy Vulnerable: false
  Arithmetic Vulnerable: true
  Access Control Issues: false

EXPLOIT STATUS:
  Exploit Found: true
  Max Profit (wei): 1000000000000000000
========================================
```

## Integration with Existing Workflow

1. **Load contracts from contracts.txt**
2. **Fetch source code via Etherscan API** (optional)
3. **Run full analysis** on each contract
4. **Generate POC tests** for vulnerabilities
5. **Validate on mainnet fork**
6. **Report findings** with exact call sequences

## Best Practices

1. Always run on mainnet fork for accurate results
2. Use `FOUNDRY_PROFILE=deep` for production audits
3. Validate all findings manually
4. Check both proxy and implementation contracts
5. Monitor for state changes during testing

## Threat Model

Attacker capabilities assumed:
- Unprivileged EOA(s)
- Can create unlimited addresses
- Can call any public/external function
- Can use flash loans
- Can wait for time-based conditions
- Can interact with external protocols

## License

MIT
