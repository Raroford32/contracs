#!/usr/bin/env python3
"""
Find contracts that ACTUALLY CALL getReserves() for price calculations.
Not just importing interfaces - looking for actual usage patterns.
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import time
import json
import re

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

def get_eth_balance(address):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_getBalance",
        "params": [address, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return int(resp.json().get("result", "0x0"), 16)
    except:
        return 0

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def check_actual_spot_price_usage(source_code):
    """Check if contract actually CALLS getReserves for value calculations"""
    findings = []
    severity = 0

    # Pattern 1: Direct call to getReserves on a variable
    # e.g., pair.getReserves(), IUniswapV2Pair(pairAddress).getReserves()
    call_patterns = [
        r'\w+\.getReserves\s*\(',  # var.getReserves(
        r'IUniswapV2Pair\s*\([^)]+\)\s*\.getReserves',  # IUniswapV2Pair(addr).getReserves
        r'getReserves\s*\(\s*\)\s*;',  # getReserves();
    ]

    has_actual_call = False
    for pattern in call_patterns:
        matches = re.findall(pattern, source_code)
        if matches:
            # Make sure it's not just in an interface definition
            lines = source_code.split('\n')
            for i, line in enumerate(lines):
                if re.search(pattern, line):
                    # Check if previous lines indicate we're in an interface
                    context = '\n'.join(lines[max(0,i-10):i])
                    if 'interface ' not in context.lower():
                        has_actual_call = True
                        findings.append(f"ACTUAL_CALL: Line {i}: {line.strip()[:80]}")
                        severity += 3

    if not has_actual_call:
        return [], 0

    # Check what the reserves are used for
    lower = source_code.lower()

    # Check for price calculation patterns
    price_calcs = [
        (r'reserve[0-9]\s*/\s*reserve[0-9]', 'PRICE_CALC: reserve0/reserve1', 3),
        (r'amount\s*\*\s*reserve', 'VALUE_CALC: amount * reserve', 3),
        (r'reserve.*\*.*price', 'VALUE_CALC: reserve * price', 3),
    ]

    for pattern, desc, sev in price_calcs:
        if re.search(pattern, lower):
            findings.append(desc)
            severity += sev

    # Check for value extraction dependent on price
    if 'withdraw' in lower or 'redeem' in lower or 'liquidat' in lower:
        if has_actual_call:
            findings.append("VALUE_EXTRACTION: Has value extraction function with spot price")
            severity += 4

    # Check for missing TWAP
    if 'twap' not in lower and 'timeaverage' not in lower and 'cumulative' not in lower:
        if has_actual_call:
            findings.append("NO_TWAP: No TWAP protection for spot price")
            severity += 2

    return findings, severity

def main():
    print("=" * 70)
    print("SPOT PRICE USAGE SEARCH (ACTUAL CALLS)")
    print("=" * 70)

    # Read all contracts
    with open('/home/user/contracs/contracts.txt', 'r') as f:
        all_contracts = [line.strip() for line in f if line.strip().startswith('0x')]

    targets = []

    # Scan all contracts
    for i, address in enumerate(all_contracts):
        if i % 100 == 0:
            print(f"\nProgress: {i}/{len(all_contracts)}")

        # Get balance
        eth_bal = get_eth_balance(address)
        eth_value = eth_bal / 1e18

        # Skip very low value
        if eth_value < 20:
            continue

        # Get source
        source_data = get_contract_source(address)
        time.sleep(0.25)

        if not source_data:
            continue

        source_code = source_data.get('SourceCode', '')
        contract_name = source_data.get('ContractName', 'Unknown')

        if not source_code:
            continue

        # Check for actual spot price usage
        findings, severity = check_actual_spot_price_usage(source_code)

        if findings and severity >= 5:
            target = {
                'address': address,
                'name': contract_name,
                'eth': eth_value,
                'severity': severity,
                'findings': findings
            }
            targets.append(target)

            print(f"\n  *** SPOT PRICE USAGE: {contract_name} ({address[:10]}...)")
            print(f"      ETH: {eth_value:.2f} | Severity: {severity}")
            for f in findings:
                print(f"      - {f}")

    # Sort by severity and value
    targets.sort(key=lambda x: (x['severity'], x['eth']), reverse=True)

    # Summary
    print("\n" + "=" * 70)
    print("TARGETS WITH ACTUAL SPOT PRICE USAGE")
    print("=" * 70)

    for i, target in enumerate(targets[:15]):
        print(f"\n{i+1}. {target['name']} ({target['address'][:10]}...)")
        print(f"   ETH: {target['eth']:.2f} (${target['eth'] * 2279:,.0f})")
        print(f"   Severity: {target['severity']}")
        for f in target['findings']:
            print(f"   - {f}")

    # Save
    with open('spot_price_usage_targets.json', 'w') as f:
        json.dump(targets, f, indent=2)

    print(f"\nFound {len(targets)} contracts with actual spot price usage")

if __name__ == "__main__":
    main()
