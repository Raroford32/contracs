#!/usr/bin/env python3
"""
LUSD Cross-Protocol Arbitrage Analysis

If LUSD trades below $1 on Curve, we can:
1. Buy LUSD cheap on Curve
2. Redeem LUSD for ETH at Liquity (at $1 - fee)
3. Profit = discount - redemption fee

This is a valid cross-protocol semantic mismatch:
- Curve: prices LUSD by AMM curve
- Liquity: always values LUSD at $1 for redemptions
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"

# Curve LUSD pools
LUSD_3CRV_POOL = "0xed279fdd11ca84beef15af5d39bb4d4bee23f0ca"  # LUSD/3CRV MetaPool
CURVE_3POOL = "0xbebc44782c7db0a1a60cb6fe97d0b483032ff1c7"  # 3CRV

# Liquity
LIQUITY_TROVE_MANAGER = "0xa39739ef8b0231dbfa0dcda07d7e29faabcf4bb2"
LIQUITY_PRICE_FEED = "0x4c517d4e2c851ca76d7ec94b805269df0f2201de"
LUSD_TOKEN = "0x5f98805a4e8be255a32880fdec7f6728c6568ba0"

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        result = resp.json()
        if 'error' in result:
            return None
        return result.get("result", "0x")
    except:
        return None

def decode_uint256(hex_result):
    if not hex_result or hex_result == "0x":
        return 0
    return int(hex_result, 16)

def format_ether(wei):
    if wei > 10**30:
        return "overflow"
    return f"{wei / 1e18:.6f}"

def main():
    print("=" * 70)
    print("LUSD CROSS-PROTOCOL ARBITRAGE ANALYSIS")
    print("=" * 70)

    # 1. Get LUSD price on Curve
    print("\n--- CURVE LUSD/3CRV POOL ---")

    # Get virtual price (value of LP token)
    selector = get_function_selector("get_virtual_price()")
    result = eth_call(LUSD_3CRV_POOL, selector)
    if result:
        vp = decode_uint256(result)
        print(f"Virtual Price: {format_ether(vp)}")

    # Get pool balances
    # LUSD/3CRV pool: index 0 = LUSD, index 1 = 3CRV
    for i in range(2):
        selector = get_function_selector("balances(uint256)")
        data = selector + encode(['uint256'], [i]).hex()
        result = eth_call(LUSD_3CRV_POOL, data)
        if result:
            bal = decode_uint256(result)
            token = "LUSD" if i == 0 else "3CRV"
            print(f"Balance[{i}] ({token}): {format_ether(bal)}")

    # Calculate LUSD price by simulating a swap
    # get_dy(i, j, dx) - returns amount out for swap i->j
    # Swap 1000 LUSD for 3CRV
    dx = 1000 * 10**18
    selector = get_function_selector("get_dy(int128,int128,uint256)")
    data = selector + encode(['int128', 'int128', 'uint256'], [0, 1, dx]).hex()
    result = eth_call(LUSD_3CRV_POOL, data)

    if result:
        dy = decode_uint256(result)
        lusd_to_3crv_rate = dy / dx
        print(f"\nSwap 1000 LUSD -> 3CRV: {format_ether(dy)} 3CRV")
        print(f"LUSD to 3CRV rate: {lusd_to_3crv_rate:.6f}")

    # Get 3CRV price (3pool virtual price)
    selector = get_function_selector("get_virtual_price()")
    result = eth_call(CURVE_3POOL, selector)
    if result:
        vp_3pool = decode_uint256(result)
        print(f"\n3CRV Virtual Price: {format_ether(vp_3pool)}")

        # Calculate effective LUSD price
        # LUSD -> 3CRV rate * 3CRV value = LUSD value in USD
        if 'dy' in dir():
            effective_lusd_price = lusd_to_3crv_rate * (vp_3pool / 1e18)
            print(f"Effective LUSD Price: ${effective_lusd_price:.6f}")

    # 2. Get Liquity redemption rate
    print("\n--- LIQUITY REDEMPTION ---")

    # Get base rate
    selector = get_function_selector("baseRate()")
    result = eth_call(LIQUITY_TROVE_MANAGER, selector)
    if result:
        base_rate = decode_uint256(result)
        print(f"Base Rate: {base_rate / 1e18 * 100:.4f}%")

    # Get ETH price from Liquity
    selector = get_function_selector("lastGoodPrice()")
    result = eth_call(LIQUITY_PRICE_FEED, selector)
    if result:
        eth_price = decode_uint256(result)
        print(f"Liquity ETH Price: ${format_ether(eth_price)}")

    # Calculate redemption value
    # When you redeem LUSD, you get ETH at the oracle price minus fee
    # Redemption fee = max(0.5%, baseRate)
    if 'base_rate' in dir() and 'eth_price' in dir():
        redemption_fee = max(0.005, base_rate / 1e18)  # 0.5% minimum
        print(f"Redemption Fee: {redemption_fee * 100:.4f}%")

        # Value of redeeming 1000 LUSD
        lusd_amount = 1000
        eth_received = (lusd_amount / (eth_price / 1e18)) * (1 - redemption_fee)
        usd_value = eth_received * (eth_price / 1e18)
        print(f"\nRedeem {lusd_amount} LUSD -> {eth_received:.6f} ETH (${usd_value:.2f})")

    # 3. Calculate arbitrage opportunity
    print("\n--- ARBITRAGE CALCULATION ---")

    if 'effective_lusd_price' in dir() and 'eth_price' in dir():
        # Cost to buy 1000 LUSD on Curve (in USD)
        cost = 1000 * effective_lusd_price

        # Value from redemption (in USD)
        redemption_value = usd_value

        # Profit
        profit = redemption_value - cost
        profit_pct = (profit / cost) * 100

        print(f"Cost to buy 1000 LUSD on Curve: ${cost:.2f}")
        print(f"Value from Liquity redemption: ${redemption_value:.2f}")
        print(f"Profit: ${profit:.2f} ({profit_pct:.2f}%)")

        if profit > 0:
            print("\n!!! ARBITRAGE OPPORTUNITY EXISTS !!!")
            print(f"At scale (100k LUSD): ${profit * 100:.2f} profit")

            # Calculate gas costs
            # Swap on Curve: ~150k gas
            # Redemption on Liquity: ~300k gas
            # Total: ~450k gas
            gas_cost_gwei = 30  # 30 gwei
            gas_cost_eth = 450000 * gas_cost_gwei * 1e-9
            gas_cost_usd = gas_cost_eth * (eth_price / 1e18)
            print(f"Estimated gas cost: ${gas_cost_usd:.2f}")

            net_profit = profit - gas_cost_usd
            print(f"Net profit (1000 LUSD): ${net_profit:.2f}")

            # Minimum profitable amount
            if profit_pct > 0:
                min_amount = gas_cost_usd / (profit_pct / 100)
                print(f"Minimum profitable amount: {min_amount:.0f} LUSD")
        else:
            print("\nNo profitable arbitrage at current prices")

    # 4. Check for larger arbitrage via price manipulation
    print("\n--- PRICE MANIPULATION ANALYSIS ---")

    # What if we could move Curve price?
    print("Analyzing Curve pool depth...")

    # Get total liquidity
    selector = get_function_selector("totalSupply()")
    result = eth_call(LUSD_3CRV_POOL, selector)
    if result:
        lp_supply = decode_uint256(result)
        print(f"LP Token Supply: {format_ether(lp_supply)}")

    # Check imbalance impact
    # A large LUSD sell would push price down
    large_amount = 1_000_000 * 10**18  # 1M LUSD
    selector = get_function_selector("get_dy(int128,int128,uint256)")
    data = selector + encode(['int128', 'int128', 'uint256'], [0, 1, large_amount]).hex()
    result = eth_call(LUSD_3CRV_POOL, data)

    if result:
        dy_large = decode_uint256(result)
        rate_large = dy_large / large_amount
        print(f"\nSwap 1M LUSD -> 3CRV: {format_ether(dy_large)} 3CRV")
        print(f"Rate for 1M: {rate_large:.6f} (vs {lusd_to_3crv_rate:.6f} for 1k)")
        print(f"Slippage: {(1 - rate_large/lusd_to_3crv_rate) * 100:.2f}%")

    # 5. Summary
    print("\n" + "=" * 70)
    print("SUMMARY")
    print("=" * 70)
    print("""
CROSS-PROTOCOL SEMANTIC MISMATCH:
- Curve: Prices LUSD based on AMM balance
- Liquity: Values LUSD at exactly $1 for redemptions

ARBITRAGE MECHANICS:
1. If LUSD < $1 - redemption_fee on Curve
2. Buy LUSD on Curve
3. Redeem for ETH at Liquity (at $1 value)
4. Sell ETH for stablecoin
5. Profit = discount - redemption_fee - gas

VIABILITY:
- Currently Liquity redemption fee is ~0.7%
- Need LUSD to trade at < $0.993 for arbitrage
- Typical LUSD price stays close to $1 due to this exact arbitrage
- MEV bots already capture these opportunities quickly

POTENTIAL EXPLOIT:
- Flash loan to temporarily push LUSD price down
- Requires a vulnerable protocol that reads LUSD at Curve price
- Then exploit price difference
""")

if __name__ == "__main__":
    main()
