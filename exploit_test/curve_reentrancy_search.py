#!/usr/bin/env python3
"""
Search for Curve read-only reentrancy exploitation opportunities.

The attack vector:
1. Curve's remove_liquidity_one_coin burns LP tokens BEFORE updating state
2. During the callback (receiving ETH), virtual_price is stale/manipulated
3. If another protocol reads virtual_price during this callback, they get wrong price
4. This can be exploited for profit if that protocol allows actions based on the price

Target: Find protocols that:
- Use Curve LP tokens as collateral or pricing
- Read virtual_price or getRate() during external calls
- Allow borrowing/minting/swapping based on that price
"""

import requests
from eth_abi import decode, encode
from eth_utils import keccak
import time

RPC_URL = "https://mainnet.infura.io/v3/bfc7283659224dd6b5124ebbc2b14e2c"
ETHERSCAN_API = "https://api.etherscan.io/v2/api"
ETHERSCAN_KEY = "5UWN6DNT7UZCEJYNE3J6FCVAWH4QJW255K"

# Known Curve pools
CURVE_POOLS = {
    'stETH': '0xDC24316b9AE028F1497c275EB9192a3Ea0f67022',
    '3pool': '0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7',
    'frxETH': '0xa1F8A6807c402E4A15ef4EBa36528A3FED24E577',
    'tricrypto2': '0xD51a44d3FaE010294C616388b506AcdA1bfAAE46',
    'crvUSD/USDC': '0x4DEcE678ceceb27446b35C672dC7d61F30bAD69E',
    'ETH/stETH-ng': '0x21E27a5E5513D6e65C4f830167390997aA84843a',
}

# Known protocols that might use Curve LP tokens
POTENTIAL_TARGETS = [
    # Lending protocols that accept Curve LP
    ('Abracadabra', '0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce'),  # MIM cauldron
    ('Inverse Finance', '0x7Fcb7DAC61eE35b3D4a51117A7c58D53f0a8a670'),  # DOLA
    ('Alchemix', '0xaB8e74017a8Cc7c15FFcCd726603790d26d7DeCa'),  # alETH

    # Vaults that use Curve LP
    ('Yearn yCRV', '0xFCc5c47bE19d06BF83eB04298b026F81069ff65b'),
    ('Convex Booster', '0xF403C135812408BFbE8713b5A23a04b3D48AAE31'),
]

def eth_call(to, data):
    payload = {
        "jsonrpc": "2.0",
        "method": "eth_call",
        "params": [{"to": to, "data": data}, "latest"],
        "id": 1
    }
    try:
        resp = requests.post(RPC_URL, json=payload, timeout=10)
        return resp.json().get("result", "0x")
    except:
        return "0x"

def get_function_selector(sig):
    return "0x" + keccak(text=sig).hex()[:8]

def decode_uint256(hex_result):
    if hex_result == "0x" or not hex_result:
        return 0
    return int(hex_result, 16)

def format_ether(wei):
    return f"{wei / 1e18:.4f}"

def get_contract_source(address):
    url = f"{ETHERSCAN_API}?chainid=1&module=contract&action=getsourcecode&address={address}&apikey={ETHERSCAN_KEY}"
    try:
        resp = requests.get(url, timeout=30)
        data = resp.json()
        if data.get('status') == '1' and data.get('result'):
            return data['result'][0]
    except:
        pass
    return None

def search_source_for_curve_patterns(source_code):
    """Search for patterns that indicate Curve LP price reading"""
    patterns = {
        'virtual_price': 'get_virtual_price' in source_code.lower(),
        'curve_pool': 'icurve' in source_code.lower() or 'curvepool' in source_code.lower(),
        'lp_price': 'lp_price' in source_code.lower() or 'lprice' in source_code.lower(),
        'rate': 'getrate' in source_code.lower(),
        'oracle': 'oracle' in source_code.lower(),
        'collateral': 'collateral' in source_code.lower(),
        'borrow': 'borrow' in source_code.lower(),
        'liquidat': 'liquidat' in source_code.lower(),
    }
    return patterns

def analyze_curve_pool(name, address):
    """Analyze a Curve pool for reentrancy potential"""
    print(f"\n--- {name} ({address}) ---")

    # Get virtual price
    selector = get_function_selector("get_virtual_price()")
    result = eth_call(address, selector)
    if result and result != "0x":
        vp = decode_uint256(result)
        print(f"  Virtual Price: {format_ether(vp)}")

    # Get pool balances
    for i in range(3):
        selector = get_function_selector("balances(uint256)")
        data = selector + encode(['uint256'], [i]).hex()
        result = eth_call(address, data)
        if result and result != "0x":
            bal = decode_uint256(result)
            if bal > 0:
                print(f"  Balance[{i}]: {format_ether(bal)}")

    # Check for admin balances (protocol fee)
    selector = get_function_selector("admin_balances(uint256)")
    for i in range(2):
        data = selector + encode(['uint256'], [i]).hex()
        result = eth_call(address, data)
        if result and result != "0x":
            admin_bal = decode_uint256(result)
            if admin_bal > 0:
                print(f"  Admin Balance[{i}]: {format_ether(admin_bal)}")

def search_contracts_for_curve_integration():
    """Search all contracts for Curve integration patterns"""
    print("\n" + "=" * 70)
    print("SEARCHING FOR CURVE INTEGRATION IN CONTRACTS.TXT")
    print("=" * 70)

    with open('/home/user/contracs/contracts.txt', 'r') as f:
        addresses = [line.strip() for line in f if line.strip().startswith('0x') and len(line.strip()) == 42]

    curve_integrated = []

    # Sample first 500 contracts
    for i, address in enumerate(addresses[:500]):
        if i % 50 == 0:
            print(f"Checked {i}/500 contracts, found {len(curve_integrated)} with Curve integration")
            time.sleep(1)  # Rate limiting for Etherscan

        source = get_contract_source(address)
        if not source:
            continue

        source_code = source.get('SourceCode', '')
        contract_name = source.get('ContractName', 'Unknown')

        if not source_code:
            continue

        patterns = search_source_for_curve_patterns(source_code)

        # Check if this contract reads Curve prices
        if patterns['virtual_price'] or patterns['curve_pool']:
            # Check if it also does borrowing/collateral
            if patterns['borrow'] or patterns['collateral'] or patterns['liquidat']:
                curve_integrated.append({
                    'address': address,
                    'name': contract_name,
                    'patterns': patterns
                })
                print(f"\n  FOUND: {contract_name} ({address})")
                print(f"    Patterns: {[k for k, v in patterns.items() if v]}")

    return curve_integrated

def check_reentrancy_protection(address, source_code):
    """Check if contract has reentrancy protection"""
    protections = {
        'nonReentrant': 'nonreentrant' in source_code.lower(),
        'ReentrancyGuard': 'reentrancyguard' in source_code.lower(),
        '_status': '_status' in source_code and 'entered' in source_code.lower(),
        'locked': 'locked' in source_code.lower() and 'require(!locked' in source_code.lower(),
    }
    return any(protections.values()), protections

def main():
    print("=" * 70)
    print("CURVE READ-ONLY REENTRANCY EXPLOITATION SEARCH")
    print("=" * 70)
    print("""
Attack Vector:
1. Call Curve pool's remove_liquidity_one_coin with ETH
2. During ETH callback, pool state is inconsistent
3. In callback, interact with a protocol that reads Curve's virtual_price
4. Protocol sees manipulated price, allows unfavorable trade
5. Profit from price discrepancy

Searching for vulnerable protocols...
""")

    # First, analyze Curve pools
    print("\n" + "=" * 70)
    print("ANALYZING CURVE POOLS")
    print("=" * 70)

    for name, address in CURVE_POOLS.items():
        analyze_curve_pool(name, address)

    # Check known potential targets
    print("\n" + "=" * 70)
    print("CHECKING KNOWN POTENTIAL TARGETS")
    print("=" * 70)

    for name, address in POTENTIAL_TARGETS:
        print(f"\n--- {name} ({address}) ---")

        source = get_contract_source(address)
        if source:
            source_code = source.get('SourceCode', '')
            contract_name = source.get('ContractName', 'Unknown')
            print(f"  Contract: {contract_name}")

            if source_code:
                patterns = search_source_for_curve_patterns(source_code)
                has_protection, protections = check_reentrancy_protection(address, source_code)

                print(f"  Curve Patterns: {[k for k, v in patterns.items() if v]}")
                print(f"  Reentrancy Protection: {has_protection}")

                if patterns['virtual_price'] and not has_protection:
                    print(f"  *** POTENTIAL VULNERABILITY: Reads virtual_price without reentrancy guard! ***")

    # Search all contracts
    print("\n" + "=" * 70)
    print("SEARCHING ALL CONTRACTS FOR CURVE INTEGRATION")
    print("=" * 70)

    curve_integrated = search_contracts_for_curve_integration()

    print("\n" + "=" * 70)
    print("SEARCH COMPLETE")
    print("=" * 70)
    print(f"\nFound {len(curve_integrated)} contracts with Curve integration + lending patterns")

    if curve_integrated:
        print("\nThese contracts warrant deep manual analysis for read-only reentrancy:")
        for c in curve_integrated:
            print(f"  - {c['name']} ({c['address']})")

if __name__ == "__main__":
    main()
